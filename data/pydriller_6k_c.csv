Message,Code,Lines,Complexity
Makes the autotools scripts work on Mac OS X. Also hopefully makes gtest compile on Windows CE.,"
 #ifndef GTEST_INCLUDE_GTEST_GTEST_MESSAGE_H_
 #define GTEST_INCLUDE_GTEST_GTEST_MESSAGE_H_
 
-#if defined(__APPLE__) && !defined(GTEST_NOT_MAC_FRAMEWORK_MODE)
-// When using Google Test on the Mac as a framework, all the includes will be
-// in the framework headers folder along with gtest.h.
-// Define GTEST_NOT_MAC_FRAMEWORK_MODE if you are building Google Test on
-// the Mac and are not using it as a framework.
-// More info on frameworks available here:
-// http://developer.apple.com/documentation/MacOSX/Conceptual/BPFrameworks/
-// Concepts/WhatAreFrameworks.html.
-#include ""gtest-string.h"" // NOLINT
-#include ""gtest-internal.h"" // NOLINT
-#else
 #include <gtest/internal/gtest-string.h>
 #include <gtest/internal/gtest-internal.h>
-#endif // defined(__APPLE__) && !defined(GTEST_NOT_MAC_FRAMEWORK_MODE)
 
 namespace testing {
 
",72,18
"Makes Google Test compile on Mac OS X and Cygwin, and adds project files for Microsoft Visual Studio.","
 // Test flag names share, in upper case.
 //
 // Macros indicating the current platform:
+// GTEST_OS_CYGWIN - defined iff compiled on Cygwin.
 // GTEST_OS_LINUX - defined iff compiled on Linux.
 // GTEST_OS_MAC - defined iff compiled on Mac OS X.
 // GTEST_OS_WINDOWS - defined iff compiled on Windows.

 #define GTEST_FLAG_PREFIX_UPPER ""GTEST_""
 
 // Determines the platform on which Google Test is compiled.
-#ifdef _MSC_VER
+#ifdef __CYGWIN__
+#define GTEST_OS_CYGWIN
+#elif defined _MSC_VER
 // TODO(kenton@google.com): GTEST_OS_WINDOWS is currently used to mean
 // both ""The OS is Windows"" and ""The compiler is MSVC"". These
 // meanings really should be separated in order to better support
",148,29
Fixes some style nits; also fixes minor bugs in gtest-death-test.cc.," String FormatForFailureMessage(wchar_t wchar);
 // This internal macro is used to avoid duplicated code.
 #define GTEST_FORMAT_IMPL(operand2_type, operand1_printer)\
 inline String FormatForComparisonFailureMessage(\
- operand2_type::value_type* str, const operand2_type& operand2) {\
+ operand2_type::value_type* str, const operand2_type& /*operand2*/) {\
 return operand1_printer(str);\
 }\
 inline String FormatForComparisonFailureMessage(\
- const operand2_type::value_type* str, const operand2_type& operand2) {\
+ const operand2_type::value_type* str, const operand2_type& /*operand2*/) {\
 return operand1_printer(str);\
 }
 
",141,23
Makes the output understandable by VS when compiled by MSVC.," static const char * TestPartResultTypeToString(TestPartResultType type) {
 
 case TPRT_NONFATAL_FAILURE:
 case TPRT_FATAL_FAILURE:
- return ""Failure"";
+#ifdef _MSC_VER
+ return ""error: "";
+#else
+ return ""Failure\n"";
+#endif
 }
 
 return ""Unknown result type"";
 static void PrintTestPartResult(
 
 printf(""%s"", file_name == NULL ? ""unknown file"" : file_name);
 if (test_part_result.line_number() >= 0) {
+#ifdef _MSC_VER
+ printf(""(%d)"", test_part_result.line_number());
+#else
 printf("":%d"", test_part_result.line_number());
+#endif
 }
- printf("": %s\n"", TestPartResultTypeToString(test_part_result.type()));
+ printf("": %s"", TestPartResultTypeToString(test_part_result.type()));
 printf(""%s\n"", test_part_result.message());
 fflush(stdout);
 }
",2031,471
Adds a test for the GTEST_PRINT_TIME env var. By Balazs.Dan@gmail.com.," def TestEnvVarAffectsFlag(command):
 TestFlag(command, 'color', 'yes', 'auto')
 TestFlag(command, 'filter', 'FooTest.Bar', '*')
 TestFlag(command, 'output', 'tmp/foo.xml', '')
+ TestFlag(command, 'print_time', '1', '0')
 TestFlag(command, 'repeat', '999', '1')
 
 if IS_WINDOWS:
",71,14
Makes death tests create temporary files in /tmp instead of the current folder.," class CapturedStderr {
 CapturedStderr() {
 uncaptured_fd_ = dup(STDERR_FILENO);
 
- char name_template[] = ""captured_stderr.XXXXXX"";
+ // There's no guarantee that a test has write access to the
+ // current directory, so we create the temporary file in the /tmp
+ // directory instead.
+ char name_template[] = ""/tmp/captured_stderr.XXXXXX"";
 const int captured_fd = mkstemp(name_template);
 filename_ = name_template;
 fflush(NULL);
",162,35
Makes gtest work on Windows Mobile and Symbian. By Mika Raento.," inline const char* GetEnv(const char* name) {
 #endif
 }
 
+#ifdef _WIN32_WCE
+// Windows CE has no C library. The abort() function is used in
+// several places in Google Test. This implementation provides a reasonable
+// imitation of standard behaviour.
+void abort();
+#else
+inline void abort() { ::abort(); }
+#endif // _WIN32_WCE
+
 // Macro for referencing flags.
 #define GTEST_FLAG(name) FLAGS_gtest_##name
 
",150,30
Fixes the definition of GTEST_ATTRIBUTE_UNUSED and make the tests pass in opt mode.,"
 // struct Foo {
 // Foo() { ... }
 // } GTEST_ATTRIBUTE_UNUSED;
-#if defined(GTEST_OS_WINDOWS) || (defined(GTEST_OS_LINUX) && defined(SWIG))
-#define GTEST_ATTRIBUTE_UNUSED
-#else
+#if defined(__GNUC__) && !defined(COMPILER_ICC)
 #define GTEST_ATTRIBUTE_UNUSED __attribute__ ((unused))
-#endif // GTEST_OS_WINDOWS || (GTEST_OS_LINUX && SWIG)
+#else
+#define GTEST_ATTRIBUTE_UNUSED
+#endif
 
 // A macro to disallow the evil copy constructor and operator= functions
 // This should be used in the private: declarations for a class.
",150,30
Changes test creation functions to factories. By Vlad Losev.," class TestInfoImpl {
 public:
 TestInfoImpl(TestInfo* parent, const char* test_case_name,
 const char* name, TypeId fixture_class_id,
- TestMaker maker);
+ internal::TestFactoryBase* factory);
 ~TestInfoImpl();
 
 // Returns true if this test should run.
 class TestInfoImpl {
 const TypeId fixture_class_id_; // ID of the test fixture class
 bool should_run_; // True iff this test should run
 bool is_disabled_; // True iff this test is disabled
- const TestMaker maker_; // The function that creates the test object
+ internal::TestFactoryBase* const factory_; // The factory that creates
+ // the test object
 
 // This field is mutable and needs to be reset before running the
 // test for the second time.
",498,108
Implement wide->UTF-8 string conversion more correctly,"
 #include <sys/mman.h>
 #endif // GTEST_HAS_STD_STRING && defined(GTEST_OS_LINUX)
 
+// Determines whether the system compiler uses UTF-16 for encoding wide strings.
+#if defined(GTEST_OS_WINDOWS) || defined(GTEST_OS_CYGWIN) || \
+ defined(__SYMBIAN32__)
+#define GTEST_WIDE_STRING_USES_UTF16_ 1
+#endif
+
 // Defines some utility macros.
 
 // The GNU compiler emits a warning if nested ""if"" statements are followed by
",150,30
Adds support for type-parameterized tests (by Zhanyong Wan); also adds case-insensitive wide string comparison to the String class (by Vlad Losev).," class GTestNCTest(unittest.TestCase):
 ('CATCHES_CALLING_SETUP_IN_ENVIRONMENT_WITH_TYPO',
 [r'Setup_should_be_spelled_SetUp']),
 
+ ('CATCHES_WRONG_CASE_IN_TYPED_TEST_P',
+ [r'BarTest.*was not declared']),
+
+ ('CATCHES_WRONG_CASE_IN_REGISTER_TYPED_TEST_CASE_P',
+ [r'BarTest.*was not declared']),
+
+ ('CATCHES_WRONG_CASE_IN_INSTANTIATE_TYPED_TEST_CASE_P',
+ [r'BarTest.*not declared']),
+
+ ('CATCHES_INSTANTIATE_TYPED_TESET_CASE_P_WITH_SAME_NAME_PREFIX',
+ [r'redefinition of.*My.*FooTest']),
+
 ('SANITY',
 None)
 ]
",34,1
Improves thread-safe death tests by changing to the original working directory before they are executed; also fixes out-dated comments about death tests.," class UnitTest {
 // INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.
 int Run() GTEST_MUST_USE_RESULT;
 
+ // Returns the working directory when the first TEST() or TEST_F()
+ // was executed. The UnitTest object owns the string.
+ const char* original_working_dir() const;
+
 // Returns the TestCase object for the test that's currently running,
 // or NULL if no test is running.
 const TestCase* current_test_case() const;
",308,29
Makes Google Test compile (and all tests pass) on cygwin (possibly on wingw too).," bool String::CaseInsensitiveWideCStringEquals(const wchar_t* lhs,
 
 #ifdef GTEST_OS_WINDOWS
 return _wcsicmp(lhs, rhs) == 0;
-#elif defined(GTEST_OS_MAC)
- // Mac OS X doesn't define wcscasecmp.
+#elif defined(GTEST_OS_LINUX)
+ return wcscasecmp(lhs, rhs) == 0;
+#else
+ // Mac OS X and Cygwin don't define wcscasecmp. Other unknown OSes
+ // may not define it either.
 wint_t left, right;
 do {
 left = towlower(*lhs++);
 right = towlower(*rhs++);
 } while (left && left == right);
 return left == right;
-#else
- return wcscasecmp(lhs, rhs) == 0;
 #endif // OS selector
 }
 
",2173,507
Makes the Python tests more portable by calling standard functions to interpret the result of os.system(). This could fix the broken Python tests on some users' machines.," def Run(command):
 """"""
 
 exit_code = os.system(command)
- # On Unix-like systems, the lowest 8 bits of the exit code is the
- # signal number that killed the process (or 0 if it wasn't killed by
- # a signal).
- return (exit_code & 255) != 0
+ return os.WIFSIGNALED(exit_code)
 
 
 # The unit test.
",86,13
"Lots of changes:
* changes the XML report format to match JUnit/Ant's.
* improves file path handling.
* allows the user to disable RTTI using the GTEST_HAS_RTTI macro.
* makes the code compile with -Wswitch-enum."," struct AssertTypeEq<T, T> {
 // GetTypeName<T>() returns a human-readable name of type T.
 template <typename T>
 String GetTypeName() {
+#if GTEST_HAS_RTTI
+
 const char* const name = typeid(T).name();
 #ifdef __GNUC__
 int status = 0;
 String GetTypeName() {
 #else
 return name;
 #endif // __GNUC__
+
+#else
+ return ""<type>"";
+#endif // GTEST_HAS_RTTI
 }
 
 // A unique type used as the default value for the arguments of class
",3061,4
"On some Linux distros, you need to explicitly #include <limits.h> to get
the definition of PATH_MAX. This patch adds it in the appropriate place.","
 #include <sys/syslimits.h>
 #include <unistd.h>
 #else
+#include <limits.h>
 #include <sys/stat.h>
 #include <unistd.h>
 #endif // _WIN32_WCE or _WIN32
",159,52
Makes Google Test compile on Solaris and z/OS. By Rainer Klaffenboeck.,"
 #include <limits.h>
 #include <sys/stat.h>
 #include <unistd.h>
-#endif // _WIN32_WCE or _WIN32
+#endif // _WIN32_WCE or _WIN32
+
+#ifdef GTEST_OS_WINDOWS
+#define GTEST_PATH_MAX_ _MAX_PATH
+#elif defined(PATH_MAX)
+#define GTEST_PATH_MAX_ PATH_MAX
+#elif defined(_XOPEN_PATH_MAX)
+#define GTEST_PATH_MAX_ _XOPEN_PATH_MAX
+#else
+#define GTEST_PATH_MAX_ _POSIX_PATH_MAX
+#endif // GTEST_OS_WINDOWS
 
 #include <gtest/internal/gtest-string.h>
 
 FilePath FilePath::GetCurrentDir() {
 // something reasonable.
 return FilePath(kCurrentDirectoryString);
 #elif defined(GTEST_OS_WINDOWS)
- char cwd[_MAX_PATH + 1] = {};
+ char cwd[GTEST_PATH_MAX_ + 1] = {};
 return FilePath(_getcwd(cwd, sizeof(cwd)) == NULL ? """" : cwd);
 #else
- char cwd[PATH_MAX + 1] = {};
+ char cwd[GTEST_PATH_MAX_ + 1] = {};
 return FilePath(getcwd(cwd, sizeof(cwd)) == NULL ? """" : cwd);
 #endif
 }
",159,52
Clarifies how gtest supports different platforms in README and code comments.,"
 // GTEST_OS_WINDOWS - defined iff compiled on Windows.
 // GTEST_OS_ZOS - defined iff compiled on IBM z/OS.
 //
+// Among the platforms, Cygwin, Linux, Max OS X, and Windows have the
+// most stable support. Since core members of the Google Test project
+// don't have access to other platforms, support for them may be less
+// stable. If you notice any problems on your platform, please notify
+// googletestframework@googlegroups.com (patches for fixing them are
+// even more welcome!).
+//
 // Note that it is possible that none of the GTEST_OS_ macros are defined.
 //
 // Macros indicating available Google Test features:
",152,32
Value-parameterized tests and many bugfixes,"
 
 #include ""sample2.h""
 
+#include <string.h>
+
 // Clones a 0-terminated C string, allocating memory using new.
 const char * MyString::CloneCString(const char * c_string) {
 if (c_string == NULL) return NULL;
 
 const size_t len = strlen(c_string);
 char * const clone = new char[ len + 1 ];
- strcpy(clone, c_string);
+ memcpy(clone, c_string, len + 1);
 
 return clone;
 }
",14,3
Fixed two of the failing tests mentioned in issue 9," def GetExitStatus(exit_code):
 return -1
 
 
+def RunCommandSuppressOutput(command, working_dir=None):
+ """"""Changes into a specified directory, if provided, and executes a command.
+ Restores the old directory afterwards.
+
+ Args:
+ command: A command to run.
+ working_dir: A directory to change into.
+ """"""
+
+ old_dir = None
+ try:
+ if working_dir is not None:
+ old_dir = os.getcwd()
+ os.chdir(working_dir)
+ f = os.popen(command, 'r')
+ f.read()
+ ret_code = f.close()
+ finally:
+ if old_dir is not None:
+ os.chdir(old_dir)
+ if ret_code is None:
+ ret_code = 0
+ return ret_code
+
+
 def Main():
 """"""Runs the unit test.""""""
 
",58,18
Enables the Python tests to run with 2.3 (necessary for testing on Mac OS X Tiger); also fixes gtest_output_test when built with xcode.," GTEST_DECLARE_bool_(show_internal_stack_frames);
 
 namespace internal {
 
+// The value of GetTestTypeId() as seen from within the Google Test
+// library. This is solely for testing GetTestTypeId().
+extern const TypeId kTestTypeIdInGoogleTest;
+
 // Names of the flags (needed for parsing Google Test flags).
 const char kBreakOnFailureFlag[] = ""break_on_failure"";
 const char kCatchExceptionsFlag[] = ""catch_exceptions"";
",547,114
Fixed gtest_break_on_failure_unittest on Ubuntu 8.04 and Windows,"
 
 #include <gtest/gtest.h>
 
+#ifdef GTEST_OS_WINDOWS
+#include <windows.h>
+#endif
 
 namespace {
 
 TEST(Foo, Bar) {
 
 
 int main(int argc, char **argv) {
+#ifdef GTEST_OS_WINDOWS
+ // Suppresses display of the Windows error dialog upon encountering
+ // a general protection fault (segment violation).
+ SetErrorMode(SEM_NOGPFAULTERRORBOX | SEM_FAILCRITICALERRORS);
+#endif
 testing::InitGoogleTest(&argc, argv);
 
 return RUN_ALL_TESTS();
",12,3
Adding test/gtest_uninitialized_test.py missing from the previous check-in," def AssertEq(expected, actual):
 raise AssertionError
 
 
-def GetOutput(command):
- """"""Runs the given command and returns its output.""""""
-
- stdin, stdout = os.popen2(command, 't')
- stdin.close()
- output = stdout.read()
- stdout.close()
- return output
-
-
 def TestExitCodeAndOutput(command):
 """"""Runs the given command and verifies its exit code and output.""""""
 
 # Verifies that 'command' exits with code 1.
- AssertEq(1, gtest_test_utils.GetExitStatus(os.system(command)))
-
- output = GetOutput(command)
- Assert('InitGoogleTest' in output)
+ p = gtest_test_utils.Subprocess(command)
+ Assert(p.exited)
+ AssertEq(1, p.exit_code)
+ Assert('InitGoogleTest' in p.output)
 
 
 if IS_WINDOWS:
",47,8
Allow Google Mock to initialize Google Test," inline Environment* AddGlobalTestEnvironment(Environment* env) {
 //
 // No value is returned. Instead, the Google Test flag variables are
 // updated.
+//
+// Calling the function for the second time has no user-visible effect.
 void InitGoogleTest(int* argc, char** argv);
 
 // This overloaded version can be used in Windows programs compiled in
 // UNICODE mode.
-#ifdef GTEST_OS_WINDOWS
 void InitGoogleTest(int* argc, wchar_t** argv);
-#endif // GTEST_OS_WINDOWS
 
 namespace internal {
 
",320,31
Fixes compatibility with IBM z/OS. By Rainer Klaffenboeck.,"
 #include <vector>
 
 #elif defined(GTEST_OS_SYMBIAN)
-// No autoconf on Symbian
 #define GTEST_HAS_GETTIMEOFDAY
 #include <sys/time.h> // NOLINT
 
 #elif defined(GTEST_OS_ZOS)
+#define GTEST_HAS_GETTIMEOFDAY
+#include <sys/time.h> // NOLINT
+
 // On z/OS we additionally need strings.h for strcasecmp.
 #include <strings.h>
 
",2247,508
"Use <tuple> instead of <tr1/tuple> when the compiler is not gcc, to conform with the TR1 spec."," INSTANTIATE_TEST_CASE_P(AnotherInstantiationName, FooTest, ValuesIn(pets));
 #include <gtest/internal/gtest-internal.h>
 #include <gtest/internal/gtest-param-util.h>
 #include <gtest/internal/gtest-param-util-generated.h>
-#ifdef GTEST_HAS_COMBINE
-#include <tr1/tuple>
-#endif // GTEST_HAS_COMBINE
 
 namespace testing {
 
",950,67
Implements the --gtest_death_test_use_fork flag and StaticAssertTypeEq.," GTEST_DECLARE_string_(internal_run_death_test);
 
 // Names of the flags (needed for parsing Google Test flags).
 const char kDeathTestStyleFlag[] = ""death_test_style"";
+const char kDeathTestUseFork[] = ""death_test_use_fork"";
 const char kInternalRunDeathTestFlag[] = ""internal_run_death_test"";
 
 #ifdef GTEST_HAS_DEATH_TEST
",52,4
Implements --gtest_also_run_disabled_tests. By Eric Roman.," TEST(BarTest, TestTwo) {
 TEST(BarTest, TestThree) {
 }
 
+TEST(BarTest, DISABLED_TestFour) {
+ FAIL() << ""Expected failure."";
+}
+
+TEST(BarTest, DISABLED_TestFive) {
+ FAIL() << ""Expected failure."";
+}
 
 // Test case BazTest.
 
 TEST(BazTest, TestA) {
 TEST(BazTest, TestB) {
 }
 
+TEST(BazTest, DISABLED_TestC) {
+ FAIL() << ""Expected failure."";
+}
+
+// Test case FoobarTest
+
+TEST(DISABLED_FoobarTest, Test1) {
+ FAIL() << ""Expected failure."";
+}
+
+TEST(DISABLED_FoobarTest, DISABLED_Test2) {
+ FAIL() << ""Expected failure."";
+}
+
+// Test case FoobarbazTest
+
+TEST(DISABLED_FoobarbazTest, TestA) {
+ FAIL() << ""Expected failure."";
+}
+
 #ifdef GTEST_HAS_PARAM_TEST
 class ParamTest : public testing::TestWithParam<int> {
 };
",53,17
Improves compatibility with cygwin by making the definition of GTEST_HAS_GLOBAL_WSTRING correct on this platform.,"
 // is available.
 
 #if defined(GTEST_OS_CYGWIN) || defined(GTEST_OS_SOLARIS)
-// At least some versions of cygwin don't support ::std::wstring.
+// Cygwin 1.5 and below doesn't support ::std::wstring.
+// Cygwin 1.7 might add wstring support; this should be updated when clear.
 // Solaris' libc++ doesn't support it either.
 #define GTEST_HAS_STD_WSTRING 0
 #else

 #ifndef GTEST_HAS_GLOBAL_WSTRING
 // The user didn't tell us whether ::wstring is available, so we need
 // to figure it out.
-#define GTEST_HAS_GLOBAL_WSTRING GTEST_HAS_GLOBAL_STRING
+#define GTEST_HAS_GLOBAL_WSTRING \
+ (GTEST_HAS_STD_WSTRING && GTEST_HAS_GLOBAL_STRING)
 #endif // GTEST_HAS_GLOBAL_WSTRING
 
 #if GTEST_HAS_STD_STRING || GTEST_HAS_GLOBAL_STRING || \
",185,41
Fixes the bug where the XML output path is affected by test changing the current directory. By Stefan Weigand.," class FilePath {
 int number,
 const char* extension);
 
+ // Given directory = ""dir"", relative_path = ""test.xml"",
+ // returns ""dir/test.xml"".
+ // On Windows, uses \ as the separator rather than /.
+ static FilePath ConcatPaths(const FilePath& directory,
+ const FilePath& relative_path);
+
 // Returns a pathname for a file that does not currently exist. The pathname
 // will be directory/base_name.extension or
 // directory/base_name_<number>.extension if directory/base_name.extension
 class FilePath {
 // root directory per disk drive.)
 bool IsRootDirectory() const;
 
+ // Returns true if pathname describes an absolute path.
+ bool IsAbsolutePath() const;
+
 private:
 // Replaces multiple consecutive separators with a single separator.
 // For example, ""bar///foo"" becomes ""bar/foo"". Does not eliminate other
",50,10
Improves error messages for undefined return value (by Sverre Sundsdal); improves gmock_doctor.," TEST(UnexpectedCallTest, UnsatisifiedPrerequisites) {
 
 #endif // GMOCK_HAS_REGEX
 
+#ifdef GTEST_HAS_DEATH_TEST
+
+TEST(UndefinedReturnValueTest, ReturnValueIsMandatory) {
+ MockA a;
+ // TODO(wan@google.com): We should really verify the output message,
+ // but we cannot yet due to that EXPECT_DEATH only captures stderr
+ // while Google Mock logs to stdout.
+ EXPECT_DEATH(a.ReturnResult(1), """");
+}
+
+#endif // GTEST_HAS_DEATH_TEST
+
 // Tests that an excessive call (one whose arguments match the
 // matchers but is called too many times) performs the default action.
 TEST(ExcessiveCallTest, DoesDefaultAction) {
",1323,103
Implements a simple regex matcher (to be used by death tests on Windows).," bool FilePath::DirectoryExists() const {
 // root directory per disk drive.)
 bool FilePath::IsRootDirectory() const {
 #ifdef GTEST_OS_WINDOWS
- const char* const name = pathname_.c_str();
 // TODO(wan@google.com): on Windows a network share like
 // \\server\share can be a root directory, although it cannot be the
 // current directory. Handle this properly.
",169,57
Fixes some warnings when compiled with MSVC at warning level 4.," String GetCurrentOsStackTraceExceptTop(UnitTest* unit_test, int skip_count);
 // Returns the number of failed test parts in the given test result object.
 int GetFailedPartCount(const TestResult* result);
 
+// A helper for suppressing warnings on unreachable code in some macros.
+inline bool True() { return true; }
+
 } // namespace internal
 } // namespace testing
 
 int GetFailedPartCount(const TestResult* result);
 GTEST_AMBIGUOUS_ELSE_BLOCKER_ \
 if (const char* gtest_msg = """") { \
 ::testing::internal::HasNewFatalFailureHelper gtest_fatal_failure_checker; \
- { statement; } \
+ if (::testing::internal::True()) { statement; } \
 if (gtest_fatal_failure_checker.has_new_fatal_failure()) { \
 gtest_msg = ""Expected: "" #statement "" doesn't generate new fatal "" \
 ""failures in the current thread.\n"" \
",271,44
Exposes gtest flags to user code access. By Alexander Demin.," namespace testing {
 
 // Declares the flags.
 //
-// We don't want the users to modify these flags in the code, but want
-// Google Test's own unit tests to be able to access them. Therefore we
-// declare them here as opposed to in gtest.h.
-GTEST_DECLARE_bool_(also_run_disabled_tests);
-GTEST_DECLARE_bool_(break_on_failure);
-GTEST_DECLARE_bool_(catch_exceptions);
-GTEST_DECLARE_string_(color);
+// We don't want the users to modify this flag in the code, but want
+// Google Test's own unit tests to be able to access it. Therefore we
+// declare it here as opposed to in gtest.h.
 GTEST_DECLARE_bool_(death_test_use_fork);
-GTEST_DECLARE_string_(filter);
-GTEST_DECLARE_bool_(list_tests);
-GTEST_DECLARE_string_(output);
-GTEST_DECLARE_bool_(print_time);
-GTEST_DECLARE_int32_(repeat);
-GTEST_DECLARE_bool_(show_internal_stack_frames);
-GTEST_DECLARE_int32_(stack_trace_depth);
 
 namespace internal {
 
",562,114
Adds tests for EXPECT_FATAL_FAILURE and reduces the golden file bloat (by Zhanyong Wan). Fixes more warnings on Windows (by Vlad Losev).," int GetFailedPartCount(const TestResult* result) {
 return result->failed_part_count();
 }
 
+// Used by the GTEST_HIDE_UNREACHABLE_CODE_ macro to suppress unreachable
+// code warnings.
+namespace {
+class ClassUniqueToAlwaysTrue {};
+}
+
+bool AlwaysTrue() {
+#if GTEST_HAS_EXCEPTIONS
+ // This condition is always false so AlwaysTrue() never actually throws,
+ // but it makes the compiler think that it may throw.
+ if (atoi(""42"") == 36) // NOLINT
+ throw ClassUniqueToAlwaysTrue();
+#endif // GTEST_HAS_EXCEPTIONS
+ return true;
+}
+
 // Parses a string as a command line flag. The string should have
 // the format ""--flag=value"". When def_optional is true, the ""=value""
 // part can be omitted.
",2267,515
Implements action Throw(exception).," DoAll(Action1 a1, Action2 a2, Action3 a3, Action4 a4, Action5 a5, Action6 a6,
 arg4_type arg4, arg5_type arg5, arg6_type arg6, arg7_type arg7, \
 arg8_type arg8, arg9_type arg9) const
 
+namespace testing {
+
+// Action Throw(exception) can be used in a mock function of any type
+// to throw the given exception. Any copyable value can be thrown.
+#if GTEST_HAS_EXCEPTIONS
+ACTION_P(Throw, exception) { throw exception; }
+#endif // GTEST_HAS_EXCEPTIONS
+
+} // namespace testing
+
 #endif // GMOCK_INCLUDE_GMOCK_GMOCK_GENERATED_ACTIONS_H_
",1072,122
Implements the test sharding protocol. By Eric Fellheimer.," TEST(BazTest, DISABLED_TestC) {
 FAIL() << ""Expected failure."";
 }
 
+// Test case HasDeathTest
+
+TEST(HasDeathTest, Test1) {
+#ifdef GTEST_HAS_DEATH_TEST
+ EXPECT_DEATH({exit(1);},
+ "".*"");
+#endif // GTEST_HAS_DEATH_TEST
+}
+
+// We need at least two death tests to make sure that the all death tests
+// aren't on the first shard.
+TEST(HasDeathTest, Test2) {
+#ifdef GTEST_HAS_DEATH_TEST
+ EXPECT_DEATH({exit(1);},
+ "".*"");
+#endif // GTEST_HAS_DEATH_TEST
+}
+
+
 // Test case FoobarTest
 
 TEST(DISABLED_FoobarTest, Test1) {
",61,21
Adds gtest_all_test.cc. Also cleans up gtest_unittest.cc.," TEST(GetCurrentOsStackTraceExceptTopTest, ReturnsTheStackTrace) {
 EXPECT_STREQ("""", GetCurrentOsStackTraceExceptTop(unit_test, 0).c_str());
 EXPECT_STREQ("""", GetCurrentOsStackTraceExceptTop(unit_test, 1).c_str());
 }
-
-#ifndef GTEST_OS_SYMBIAN
-// We will want to integrate running the unittests to a different
-// main application on Symbian.
-int main(int argc, char** argv) {
- testing::InitGoogleTest(&argc, argv);
-
-#ifdef GTEST_HAS_DEATH_TEST
- if (!testing::internal::GTEST_FLAG(internal_run_death_test).empty()) {
- // Skip the usual output capturing if we're running as the child
- // process of an threadsafe-style death test.
- freopen(""/dev/null"", ""w"", stdout);
- }
-#endif // GTEST_HAS_DEATH_TEST
-
- // Runs all tests using Google Test.
- return RUN_ALL_TESTS();
-}
-#endif // GTEST_OS_SYMBIAN
",3502,483
Implements the MATCHER* macros.," namespace proto2 { class Message; }
 namespace testing {
 namespace internal {
 
+// Converts an identifier name to a space-separated list of lower-case
+// words. Each maximum substring of the form [A-Za-z][a-z]*|\d+ is
+// treated as one word. For example, both ""FooBar123"" and
+// ""foo_bar_123"" are converted to ""foo bar 123"".
+string ConvertIdentifierNameToWords(const char* id_name);
+
 // Defining a variable of type CompileAssertTypesEqual<T1, T2> will cause a
 // compiler error iff T1 and T2 are different types.
 template <typename T1, typename T2>
",128,14
Makes sure all internal macros are named GMOCK_*_. No functionality is changed.,"
 
 namespace testing {
 
-GMOCK_DEFINE_string(verbose, internal::kWarningVerbosity,
- ""Controls how verbose Google Mock's output is.""
- "" Valid values:\n""
- "" info - prints all messages.\n""
- "" warning - prints warnings and errors.\n""
- "" error - prints errors only."");
+GMOCK_DEFINE_string_(verbose, internal::kWarningVerbosity,
+ ""Controls how verbose Google Mock's output is.""
+ "" Valid values:\n""
+ "" info - prints all messages.\n""
+ "" warning - prints warnings and errors.\n""
+ "" error - prints errors only."");
 
 namespace internal {
 
",55,16
Updates the definitions of GTEST_HAS_EXCEPTIONS and GTEST_HAS_STD_STRING to be C++ standard compliant.,"
 // gcc defines __EXCEPTIONS to 1 iff exceptions are enabled. For
 // other compilers, we assume exceptions are disabled to be
 // conservative.
-#define GTEST_HAS_EXCEPTIONS (defined(__GNUC__) && __EXCEPTIONS)
+#if defined(__GNUC__) && __EXCEPTIONS
+#define GTEST_HAS_EXCEPTIONS 1
+#else
+#define GTEST_HAS_EXCEPTIONS 0
+#endif // defined(__GNUC__) && __EXCEPTIONS
 #endif // _MSC_VER
 
 // Determines whether ::std::string and ::string are available.

 // need to figure it out. The only environment that we know
 // ::std::string is not available is MSVC 7.1 or lower with exceptions
 // disabled.
-#define GTEST_HAS_STD_STRING \
- (!(defined(_MSC_VER) && (_MSC_VER < 1400) && !GTEST_HAS_EXCEPTIONS))
+#if defined(_MSC_VER) && (_MSC_VER < 1400) && !GTEST_HAS_EXCEPTIONS
+#define GTEST_HAS_STD_STRING 0
+#else
+#define GTEST_HAS_STD_STRING 1
+#endif
 #endif // GTEST_HAS_STD_STRING
 
 #ifndef GTEST_HAS_GLOBAL_STRING
",187,41
Cleans up macro definitions.," class Message {
 }
 
 ~Message() { delete ss_; }
-#ifdef GTEST_OS_SYMBIAN
+#if GTEST_OS_SYMBIAN
 // Streams a value (either a pointer or not) to this object.
 template <typename T>
 inline Message& operator <<(const T& value) {
 class Message {
 }
 
 private:
-#ifdef GTEST_OS_SYMBIAN
+#if GTEST_OS_SYMBIAN
 // These are needed as the Nokia Symbian Compiler cannot decide between
 // const T& and const T* in a function template. The Nokia compiler _can_
 // decide between class template specializations for T and T*, so a
",72,18
Implements death tests on Windows (by Vlad Losev); enables POSIX regex on Mac and Cygwin; fixes build issue on some Linux versions due to PATH_MAX.,"
 #include <limits.h>
 #include <sys/stat.h> // NOLINT
 #include <unistd.h> // NOLINT
+#include <climits> // Some Linux distributions define PATH_MAX here.
 #endif // _WIN32_WCE or _WIN32
 
 #if GTEST_OS_WINDOWS
",170,57
Implements --gtest_throw_on_failure for using gtest with other testing frameworks.," TEST(Foo, Bar) {
 
 } // namespace
 
-
 int main(int argc, char **argv) {
 #if GTEST_OS_WINDOWS
 // Suppresses display of the Windows error dialog upon encountering
",12,3
"Fixes death-test-related tests on Windows, by Vlad Losev."," class TypedTestCasePState {
 fprintf(stderr, ""%s Test %s must be defined before ""
 ""REGISTER_TYPED_TEST_CASE_P(%s, ...).\n"",
 FormatFileLocation(file, line).c_str(), test_name, case_name);
+ fflush(stderr);
 abort();
 }
 defined_test_names_.insert(test_name);
",272,43
"Fixes build failure on Windows, by Rainer Klaffenboeck.","
 #include <stdlib.h>
 #include <stdio.h>
 
-#if !GTEST_OS_WINDOWS
+#if GTEST_OS_WINDOWS
+#include <io.h>
+#include <sys/stat.h>
+#else
 #include <unistd.h>
 #endif // GTEST_OS_WINDOWS
 
",351,122
Implements the --help flag; fixes tests on Windows.,"
 #include <stdio.h>
 #include <iostream> // Used for GTEST_CHECK_
 
-#define GTEST_NAME_ ""Google Test""
+#define GTEST_DEV_EMAIL_ ""googletestframework@@googlegroups.com""
 #define GTEST_FLAG_PREFIX_ ""gtest_""
 #define GTEST_FLAG_PREFIX_UPPER_ ""GTEST_""
+#define GTEST_NAME_ ""Google Test""
+#define GTEST_PROJECT_URL_ ""http://code.google.com/p/googletest/""
 
 // Determines the version of gcc that is used to compile this.
 #ifdef __GNUC__
 struct is_pointer : public false_type {};
 template <typename T>
 struct is_pointer<T*> : public true_type {};
 
+#if GTEST_OS_WINDOWS
+#define GTEST_PATH_SEP_ ""\\""
+#else
+#define GTEST_PATH_SEP_ ""/""
+#endif // GTEST_OS_WINDOWS
+
 // Defines BiggestInt as the biggest signed integer type the compiler
 // supports.
-
 #if GTEST_OS_WINDOWS
 typedef __int64 BiggestInt;
 #else
-typedef long long BiggestInt; // NOLINT
+typedef long long BiggestInt; // NOLINT
 #endif // GTEST_OS_WINDOWS
 
 // The maximum number a BiggestInt can represent. This definition
",185,41
Fixes a typo in Vlad's email address.,"
 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 //
-// Author: wan@google.com (Zhanyong Wan), vladl@losev.com (Vlad Losev)
+// Author: wan@google.com (Zhanyong Wan), vladl@google.com (Vlad Losev)
 //
 // This file implements death tests.
 
",761,143
Makes the code compile on Windows CE.," namespace {
 
 using ::std::ostream;
 
-#if GTEST_OS_WINDOWS
+#ifdef _WIN32_WCE
+#define snprintf _snprintf
+#elif GTEST_OS_WINDOWS
 #define snprintf _snprintf_s
 #endif
 
 static void PrintAsWideCharLiteralTo(wchar_t c, ostream* os) {
 *os << ""\\v"";
 break;
 default:
- // isprint() takes an int and requires it to be either EOF or in
- // the range [0, 255]. We check that c is in this range before calling it.
- if ((c & 0xFF) == c && isprint(c)) {
+ // Checks whether c is printable or not. Printable characters are in
+ // the range [0x20,0x7E].
+ // We test the value of c directly instead of calling isprint(), as
+ // isprint() is buggy on Windows mobile.
+ if (0x20 <= c && c <= 0x7E) {
 *os << static_cast<char>(c);
 } else {
 // Buffer size enough for the maximum number of digits and \0.
",169,42
Enables death tests on Cygwin and Mac (by Vlad Losev); fixes a python test on Mac.,"
 // (this is covered by GTEST_HAS_STD_STRING guard).
 // 3. abort() in a VC 7.1 application compiled as GUI in debug config
 // pops up a dialog window that cannot be suppressed programmatically.
-#if GTEST_HAS_STD_STRING && (GTEST_HAS_CLONE || \
- GTEST_OS_WINDOWS && _MSC_VER >= 1400)
+#if GTEST_HAS_STD_STRING && (GTEST_OS_LINUX || \
+ GTEST_OS_MAC || \
+ GTEST_OS_CYGWIN || \
+ (GTEST_OS_WINDOWS && _MSC_VER >= 1400))
 #define GTEST_HAS_DEATH_TEST 1
 #include <vector>
-#endif // GTEST_HAS_STD_STRING && (GTEST_HAS_CLONE ||
- // GTEST_OS_WINDOWS && _MSC_VER >= 1400)
+#endif
 
 // Determines whether to support value-parameterized tests.
 
",185,41
"Fixes two tests on Cygwin, which has no python 2.4.","
-#!/usr/bin/python2.4
+#!/usr/bin/env python
 #
 # Copyright 2009, Google Inc.
 # All rights reserved.
",62,9
Cleans up death test implementation (by Vlad Losev); changes the XML format to be closer to junitreport (by Zhanyong Wan).," void ParseGoogleTestFlagsOnly(int* argc, wchar_t** argv);
 
 // Returns the message describing the last system error, regardless of the
 // platform.
-String GetLastSystemErrorMessage();
+String GetLastErrnoDescription();
 
 #if GTEST_OS_WINDOWS
 // Provides leak-safe Windows kernel handle ownership.
",617,129
Makes gtest compile without warning with gcc 4.0.3 and -Wall -Wextra.," class ParameterizedTestCaseInfo : public ParameterizedTestCaseInfoBase {
 // about a generator.
 int AddTestCaseInstantiation(const char* instantiation_name,
 GeneratorCreationFunc* func,
- const char* file,
- int line) {
+ const char* /* file */,
+ int /* line */) {
 instantiations_.push_back(::std::make_pair(instantiation_name, func));
 return 0; // Return value used only to run this method in namespace scope.
 }
",367,75
Simplifies implementation by defining a POSIX portability layer; adds the death test style flag to --help.,"
 
 #include <gtest/internal/gtest-internal.h>
 
-#if GTEST_HAS_DEATH_TEST && GTEST_OS_WINDOWS
-#include <io.h>
-#elif GTEST_HAS_DEATH_TEST
-#include <unistd.h>
-#endif // GTEST_HAS_DEATH_TEST && GTEST_OS_WINDOWS
-
 namespace testing {
 namespace internal {
 
 class InternalRunDeathTestFlag {
 
 ~InternalRunDeathTestFlag() {
 if (write_fd_ >= 0)
-// Suppress MSVC complaints about POSIX functions.
-#ifdef _MSC_VER
-#pragma warning(push)
-#pragma warning(disable: 4996)
-#endif // _MSC_VER
- close(write_fd_);
-#ifdef _MSC_VER
-#pragma warning(pop)
-#endif // _MSC_VER
+ posix::close(write_fd_);
 }
 
 String file() const { return file_; }
",70,11
Makes gmock compile with gcc -Wall -Wextra -Wno-unused-parameter.," class AssignAction {
 AssignAction(T1* ptr, T2 value) : ptr_(ptr), value_(value) {}
 
 template <typename Result, typename ArgumentTuple>
- void Perform(const ArgumentTuple &args) const {
+ void Perform(const ArgumentTuple& /* args */) const {
 *ptr_ = value_;
 }
 private:
 class SetErrnoAndReturnAction {
 : errno_(errno_value),
 result_(result) {}
 template <typename Result, typename ArgumentTuple>
- Result Perform(const ArgumentTuple &args) const {
+ Result Perform(const ArgumentTuple& /* args */) const {
 errno = errno_;
 return result_;
 }
",456,85
Works around a VC bug by avoiding defining a function named strdup().," class Arguments {
 }
 }
 void AddArgument(const char* argument) {
- args_.insert(args_.end() - 1, strdup(argument));
+ args_.insert(args_.end() - 1, posix::StrDup(argument));
 }
 
 template <typename Str>
 class Arguments {
 for (typename ::std::vector<Str>::const_iterator i = arguments.begin();
 i != arguments.end();
 ++i) {
- args_.insert(args_.end() - 1, strdup(i->c_str()));
+ args_.insert(args_.end() - 1, posix::StrDup(i->c_str()));
 }
 }
 char* const* Argv() {
",689,131
Fixes MSVC casting warning.," inline FILE* fdopen(int fd, const char* mode) {
 }
 inline int fclose(FILE *fp) { return ::fclose(fp); }
 
-inline int read(int fd, void* buf, size_t count) {
+inline int read(int fd, void* buf, unsigned int count) {
 return static_cast<int>(::read(fd, buf, count));
 }
-inline int write(int fd, const void* buf, size_t count) {
+inline int write(int fd, const void* buf, unsigned int count) {
 return static_cast<int>(::write(fd, buf, count));
 }
 inline int close(int fd) { return ::close(fd); }
",238,58
Fixes a MSVC warning (by Vlad Losev); fixes SConscript to work with VC 7.1 and exceptions enabled (by Zhanyong Wan).," namespace posix {
 
 typedef struct _stat stat_struct;
 
-inline int chdir(const char* dir) { return ::_chdir(dir); }
 // We cannot write ::_fileno() as MSVC defines it as a macro.
 inline int fileno(FILE* file) { return _fileno(file); }
 inline int isatty(int fd) { return ::_isatty(fd); }
 inline bool IsDir(const stat_struct& st) {
 
 typedef struct stat stat_struct;
 
-using ::chdir;
 using ::fileno;
 using ::isatty;
 using ::stat;
 inline const char* strncpy(char* dest, const char* src, size_t n) {
 return ::strncpy(dest, src, n);
 }
 
+inline int chdir(const char* dir) { return ::chdir(dir); }
+
 inline FILE* fopen(const char* path, const char* mode) {
 return ::fopen(path, mode);
 }
",237,58
Fixes an error when compiling with gcc 4.4.," class FunctionMockerBase : public UntypedFunctionMockerBase {
 // called by the ON_CALL() and EXPECT_CALL() macros.
 FunctionMocker<F>& RegisterOwner(const void* mock_obj) {
 Mock::Register(mock_obj, this);
- return *down_cast<FunctionMocker<F>*>(this);
+ return *::testing::internal::down_cast<FunctionMocker<F>*>(this);
 }
 
 // The following two functions are from UntypedFunctionMockerBase.
",842,149
Cleans up the use of GTEST_OS_WINDOWS and _MSC_VER.,"
 #ifndef GTEST_INCLUDE_GTEST_GTEST_H_
 #define GTEST_INCLUDE_GTEST_GTEST_H_
 
-// The following platform macros are used throughout Google Test:
+// The following platform macro is used throughout Google Test:
 // _WIN32_WCE Windows CE (set in project files)
-//
-// Note that even though _MSC_VER and _WIN32_WCE really indicate a compiler
-// and a Win32 implementation, respectively, we use them to indicate the
-// combination of compiler - Win 32 API - C library, since the code currently
-// only supports:
-// Windows proper with Visual C++ and MS C library (_MSC_VER && !_WIN32_WCE) and
-// Windows Mobile with Visual C++ and no C library (_WIN32_WCE).
 
 #include <limits>
 #include <gtest/internal/gtest-internal.h>
",341,34
Adds sample4_unittest to scons (by Vlad Losev); adds logic for getting the thread count on Mac (by Vlad Losev); adds HasFailure() and HasNonfatalFailure() (by Zhanyong Wan).," class Test {
 // Returns true iff the current test has a fatal failure.
 static bool HasFatalFailure();
 
+ // Returns true iff the current test has a non-fatal failure.
+ static bool HasNonfatalFailure();
+
+ // Returns true iff the current test has a (either fatal or
+ // non-fatal) failure.
+ static bool HasFailure() { return HasFatalFailure() || HasNonfatalFailure(); }
+
 // Logs a property for the current test. Only the last value for a given
 // key is remembered.
 // These are public static so they can be called from utility functions
",343,36
Makes the Python tests more stable (by Vlad Losev); fixes a memory leak in GetThreadCount() on Mac (by Vlad Losev); improves fuse_gtest_files.py to support fusing Google Mock files (by Zhanyong Wan).," BREAK_ON_FAILURE_FLAG = 'gtest_break_on_failure'
 THROW_ON_FAILURE_ENV_VAR = 'GTEST_THROW_ON_FAILURE'
 
 # Path to the gtest_break_on_failure_unittest_ program.
-EXE_PATH = os.path.join(gtest_test_utils.GetBuildDir(),
- 'gtest_break_on_failure_unittest_')
+EXE_PATH = gtest_test_utils.GetTestExecutablePath(
+ 'gtest_break_on_failure_unittest_')
 
 
 # Utilities.
",100,17
Makes gtest print elapsed time by default.," def TestEnvVarAffectsFlag(command):
 TestFlag(command, 'color', 'yes', 'auto')
 TestFlag(command, 'filter', 'FooTest.Bar', '*')
 TestFlag(command, 'output', 'tmp/foo.xml', '')
- TestFlag(command, 'print_time', '1', '0')
+ TestFlag(command, 'print_time', '0', '1')
 TestFlag(command, 'repeat', '999', '1')
 TestFlag(command, 'throw_on_failure', '1', '0')
 TestFlag(command, 'death_test_style', 'threadsafe', 'fast')
",53,12
Implements --gmock_catch_leaked_mocks and Mock::AllowLeak.," else:
 PROGRAM = 'gmock_output_test_'
 
 PROGRAM_PATH = os.path.join(gmock_test_utils.GetBuildDir(), PROGRAM)
-COMMAND = PROGRAM_PATH + ' --gtest_stack_trace_depth=0'
+COMMAND = PROGRAM_PATH + ' --gtest_stack_trace_depth=0 --gtest_print_time=0'
 GOLDEN_NAME = 'gmock_output_test_golden.txt'
 GOLDEN_PATH = os.path.join(gmock_test_utils.GetSourceDir(),
 GOLDEN_NAME)
",81,13
Renames the POSIX wrappers (by Zhanyong Wan) and adds more targets to SConscript (by Vlad Losev).," class InternalRunDeathTestFlag {
 
 ~InternalRunDeathTestFlag() {
 if (write_fd_ >= 0)
- posix::close(write_fd_);
+ posix::Close(write_fd_);
 }
 
 String file() const { return file_; }
",70,11
Makes --gtest_list_tests honor the test filter (by Jay Campan).," class TestInfo {
 // Returns the test comment.
 const char* comment() const;
 
- // Returns true if this test should run.
+ // Returns true if this test matches the user-specified filter.
+ bool matches_filter() const;
+
+ // Returns true if this test should run, that is if the test is not disabled
+ // (or it is disabled but the also_run_disabled_tests flag has been specified)
+ // and its full name matches the user-specified filter.
 //
 // Google Test allows the user to filter the tests by their full names.
 // The full name of a test Bar in test case Foo is defined as
",344,36
Ports gtest to minGW (by Kenton Varda).,"
 // be used where std::wstring is unavailable).
 // GTEST_HAS_TR1_TUPLE 1 - Define it to 1/0 to indicate tr1::tuple
 // is/isn't available.
+// GTEST_HAS_SEH - Define it to 1/0 to indicate whether the
+// compiler supports Microsoft's ""Structured
+// Exception Handling"".
 
 // This header defines the following utilities:
 //

 #define GTEST_MUST_USE_RESULT_
 #endif // __GNUC__ && (GTEST_GCC_VER_ >= 30400) && !COMPILER_ICC
 
+// Determine whether the compiler supports Microsoft's Structured Exception
+// Handling. This is supported by several Windows compilers but generally
+// does not exist on any other system.
+#ifndef GTEST_HAS_SEH
+// The user didn't tell us, so we need to figure it out.
+
+#if defined(_MSC_VER) || defined(__BORLANDC__)
+// These two compilers are known to support SEH.
+#define GTEST_HAS_SEH 1
+#else
+// Assume no SEH.
+#define GTEST_HAS_SEH 0
+#endif
+
+#endif // GTEST_HAS_SEH
+
 namespace testing {
 
 class Message;
",235,63
"Ports gtest to C++Builder, by Josh Kelley.","
 namespace testing {
 namespace internal {
 
-#ifdef _MSC_VER
-// MSVC does not provide a definition of STDERR_FILENO.
+#if defined(_MSC_VER) || defined(__BORLANDC__)
+// MSVC and C++Builder do not provide a definition of STDERR_FILENO.
 const int kStdErrFileno = 2;
 #else
 const int kStdErrFileno = STDERR_FILENO;
",371,122
Turns --gmock_catch_leaked_mocks on by default.," namespace testing {
 // TODO(wan@google.com): support using environment variables to
 // control the flag values, like what Google Test does.
 
-// TODO(wan@google.com): change the default value to true after people
-// have a chance to fix their leaked mocks.
-GMOCK_DEFINE_bool_(catch_leaked_mocks, false,
+GMOCK_DEFINE_bool_(catch_leaked_mocks, true,
 ""true iff Google Mock should report leaked mock objects ""
 ""as failures."");
 
",67,21
Trivial source code format tweak.,"
 
 #include <gtest/gtest.h>
 
-
 namespace {
 
 // Test case FooTest.
 TEST_F(FooTest, Xyz) {
 FAIL() << ""Expected failure."";
 }
 
-
 // Test case BarTest.
 
 TEST(BarTest, TestOne) {
 TEST(HasDeathTest, Test2) {
 #endif // GTEST_HAS_DEATH_TEST
 }
 
-
 // Test case FoobarTest
 
 TEST(DISABLED_FoobarTest, Test1) {
 INSTANTIATE_TEST_CASE_P(SeqQ, ParamTest, testing::Values(5, 6));
 
 } // namespace
 
-
 int main(int argc, char **argv) {
 testing::InitGoogleTest(&argc, argv);
 
",61,21
Removes dead code (by Vlad Losev). Fixes tr1 tuple's path on gcc version before 4.0.0 (by Zhanyong Wan).,"
 // gtest-port.h's responsibility to #include the header implementing
 // tr1/tuple.
 #if GTEST_HAS_TR1_TUPLE
-#if defined(__GNUC__)
-// GCC implements tr1/tuple in the <tr1/tuple> header. This does not
-// conform to the TR1 spec, which requires the header to be <tuple>.
+#if defined(__GNUC__) && (GTEST_GCC_VER_ >= 40000)
+// GCC 4.0+ implements tr1/tuple in the <tr1/tuple> header. This does
+// not conform to the TR1 spec, which requires the header to be <tuple>.
 #include <tr1/tuple>
 #else
-// If the compiler is not GCC, we assume the user is using a
+// If the compiler is not GCC 4.0+, we assume the user is using a
 // spec-conforming TR1 implementation.
 #include <tuple>
 #endif // __GNUC__
",242,69
Fixes tr1 tuple's path when compiled with gcc version < 4.0.0 (by Zhanyong Wan).,"
 // To avoid conditional compilation everywhere, we make it
 // gmock-port.h's responsibility to #include the header implementing
 // tr1/tuple.
-#if defined(__GNUC__)
-// GCC implements tr1/tuple in the <tr1/tuple> header. This does not
-// conform to the TR1 spec, which requires the header to be <tuple>.
+#if defined(__GNUC__) && GTEST_GCC_VER_ >= 40000
+// GTEST_GCC_VER_ is defined in gtest-port.h and 40000 corresponds to
+// version 4.0.0.
+// GCC 4.0+ implements tr1/tuple in the <tr1/tuple> header. This does
+// not conform to the TR1 spec, which requires the header to be <tuple>.
 #include <tr1/tuple>
 #else
-// If the compiler is not GCC, we assume the user is using a
+// If the compiler is not GCC 4.0+, we assume the user is using a
 // spec-conforming TR1 implementation.
 #include <tuple>
 #endif // __GNUC__
",59,11
Uses DebugBreak() to properly break on Windows (by Vlad Losev).," void UnitTest::AddTestPartResult(TestPartResultType result_type,
 // with another testing framework) and specify the former on the
 // command line for debugging.
 if (GTEST_FLAG(break_on_failure)) {
+#if GTEST_OS_WINDOWS
+ // Using DebugBreak on Windows allows gtest to still break into a debugger
+ // when a failure happens and both the --gtest_break_on_failure and
+ // the --gtest_catch_exceptions flags are specified.
+ DebugBreak();
+#else
 *static_cast<int*>(NULL) = 1;
+#endif // GTEST_OS_WINDOWS
 } else if (GTEST_FLAG(throw_on_failure)) {
 #if GTEST_HAS_EXCEPTIONS
 throw GoogleTestFailureException(result);
",2495,560
Improves the error message for leaked mocks to include the test name (by Zhanyong Wan).," inline To down_cast(From* f) { // so we only accept pointers
 return static_cast<To>(f);
 }
 
-// The GMOCK_COMPILE_ASSERT macro can be used to verify that a compile time
+// The GMOCK_COMPILE_ASSERT_ macro can be used to verify that a compile time
 // expression is true. For example, you could use it to verify the
 // size of a static array:
 //
-// GMOCK_COMPILE_ASSERT(ARRAYSIZE(content_type_names) == CONTENT_NUM_TYPES,
-// content_type_names_incorrect_size);
+// GMOCK_COMPILE_ASSERT_(ARRAYSIZE(content_type_names) == CONTENT_NUM_TYPES,
+// content_type_names_incorrect_size);
 //
 // or to make sure a struct is smaller than a certain size:
 //
-// GMOCK_COMPILE_ASSERT(sizeof(foo) < 128, foo_too_large);
+// GMOCK_COMPILE_ASSERT_(sizeof(foo) < 128, foo_too_large);
 //
 // The second argument to the macro is the name of the variable. If
 // the expression is false, most compilers will issue a warning/error
",59,11
"Issue 44: ""const"" is missing for const return types

The modifiers (things like const, volatile, etc) were not being added
to return types."," def _GenerateMethods(output_lines, source, class_node):
 const = 'CONST_'
 return_type = 'void'
 if node.return_type:
- return_type = node.return_type.name
+ # Add modifier bits like const.
+ modifiers = ''
+ if node.return_type.modifiers:
+ modifiers = ' '.join(node.return_type.modifiers) + ' '
+ return_type = modifiers + node.return_type.name
 if node.return_type.pointer:
 return_type += '*'
 if node.return_type.reference:
",97,30
Fix grammar in comment," import sys
 from cpp import ast
 from cpp import utils
 
-# How many spaces to indent. Can me set with INDENT environment variable.
+# How many spaces to indent. Can set me with INDENT environment variable.
 _INDENT = 2
 
 
",97,30
Fixes the broken gtest_break_on_failure_unittest.py.," import unittest
 
 # Constants.
 
+IS_WINDOWS = os.name == 'nt'
+
 # The environment variable for enabling/disabling the break-on-failure mode.
 BREAK_ON_FAILURE_ENV_VAR = 'GTEST_BREAK_ON_FAILURE'
 
",111,19
"Makes the mock generator work with python2.3.5, which comes with Mac OS X Tiger.","
+#!/usr/bin/env python
 #
 # Copyright 2007 Neal Norwitz
 # Portions Copyright 2007 Google Inc.
",24,4
"Partially implemented SafeMatcherCast (by Vlad Losev); updated the implementation of Not, AnyOf, and AllOf to use SafeMatcherCast (by Vlad Losev); implemented ACTION_TEMPLATE (by Zhanyong Wan); worked around bugs on Symbian (by Zhanyong Wan)."," void PrintTo(const T& value, ::std::ostream* os) {
 //
 // For protocol messages, we want to give people a chance to
 // override Google Mock's format by defining a PrintTo() or
- // operator<<. For STL containers, we believe the Google Mock's
- // format is superior to what util/gtl/stl-logging.h offers.
- // Therefore we don't want it to be accidentally overridden by the
- // latter (even if the user includes stl-logging.h through other
- // headers indirectly, Google Mock's format will still be used).
+ // operator<<. For STL containers, other formats can be
+ // incompatible with Google Mock's format for the container
+ // elements; therefore we check for container types here to ensure
+ // that our format is used.
 DefaultPrintTo(IsContainerTest<T>(0), value, os);
 }
 
",311,58
Adds more tests for using SetArgumentPointee with protobufs; works around a compiler bug on Symbian that gmock-printers.h triggers; reduces template code bloat in gmock-matchers.h; avoids RTTI when it's disabled.," inline To down_cast(From* f) { // so we only accept pointers
 implicit_cast<From*, To>(0);
 }
 
+#if GTEST_HAS_RTTI
 assert(f == NULL || dynamic_cast<To>(f) != NULL); // RTTI: debug mode only!
+#endif
 return static_cast<To>(f);
 }
 
",59,12
Finishes SafeMatcherCast by catching lossy arithmetic conversions at compile-time; uses ACTION_TEMPLATE to simplify the definition of many actions; makes mock object uncopyable; teaches gmock doctor about wrong MOCK_METHODn.," inline void PrintTo(char* s, ::std::ostream* os) {
 PrintTo(implicit_cast<const char*>(s), os);
 }
 
-// MSVC compiler can be configured to define whar_t as a typedef
-// of unsigned short. Defining an overload for const wchar_t* in that case
-// would cause pointers to unsigned shorts be printed as wide strings,
-// possibly accessing more memory than intended and causing invalid
-// memory accesses. MSVC defines _NATIVE_WCHAR_T_DEFINED symbol when
-// wchar_t is implemented as a native type.
+// MSVC can be configured to define wchar_t as a typedef of unsigned
+// short. It defines _NATIVE_WCHAR_T_DEFINED when wchar_t is a native
+// type. When wchar_t is a typedef, defining an overload for const
+// wchar_t* would cause unsigned short* be printed as a wide string,
+// possibly causing invalid memory accesses.
 #if !defined(_MSC_VER) || defined(_NATIVE_WCHAR_T_DEFINED)
 // Overloads for wide C strings
 void PrintTo(const wchar_t* s, ::std::ostream* os);
",317,58
Adds missing copyright in test/gtest-test-part_test.cc (by Markus Heule). Minor format adjustments.," int main(int argc, char **argv) {
 GeneratorEvaluationTest::set_param_value(1);
 #endif // GTEST_HAS_PARAM_TEST
 
- testing::InitGoogleTest(&argc, argv);
+ ::testing::InitGoogleTest(&argc, argv);
 return RUN_ALL_TESTS();
 }
",512,81
"Avoids unnecessary printing of call into to internal buffers;
Made the universal value printer safer when printing char[];
Removed duplicated code in InvokeWith;
Improved gmock_doctor.py."," const char kWarningVerbosity[] = ""warning"";
 // No logs are printed.
 const char kErrorVerbosity[] = ""error"";
 
+// Returns true iff a log with the given severity is visible according
+// to the --gmock_verbose flag.
+bool LogIsVisible(LogSeverity severity);
+
 // Prints the given message to stdout iff 'severity' >= the level
 // specified by the --gmock_verbose flag. If stack_frames_to_skip >=
 // 0, also prints the stack trace excluding the top
",187,3
"Makes all container matchers work with (possibly multi-dimensional) native arrays; makes Contains() accept a matcher; adds Value(x, m); improves gmock doctor to diagnose the Type in Template Base disease."," import sys
 import unittest
 
 # Allow the cpp imports below to work when run as a standalone script.
-sys.path.append(os.path.dirname(os.path.dirname(__file__)))
+sys.path.append(os.path.join(os.path.dirname(__file__), '..'))
 
 from cpp import ast
 from cpp import gmock_class
",91,8
Adds support for xterm-256color (by Michihiro Kuramochi).," GTEST_DEFINE_string_(
 ""Whether to use colors in the output. Valid values: yes, no, ""
 ""and auto. 'auto' means to use colors if the output is ""
 ""being sent to a terminal and the TERM environment variable ""
- ""is set to xterm or xterm-color."");
+ ""is set to xterm, xterm-color, xterm-256color or cygwin."");
 
 GTEST_DEFINE_string_(
 filter,
 bool ShouldUseColor(bool stdout_is_tty) {
 const bool term_supports_color =
 String::CStringEquals(term, ""xterm"") ||
 String::CStringEquals(term, ""xterm-color"") ||
+ String::CStringEquals(term, ""xterm-256color"") ||
 String::CStringEquals(term, ""cygwin"");
 return stdout_is_tty && term_supports_color;
 #endif // GTEST_OS_WINDOWS
",2496,561
"Implements the Args<k1, ..., kn>(m) matcher."," class Expectation : public ExpectationBase {
 DescribeMatchFailureTupleTo(matchers_, args, os);
 }
 if (!extra_matcher_.Matches(args)) {
- *os << "" Expected: "";
+ *os << "" Expected args: "";
 extra_matcher_.DescribeTo(os);
- *os << ""\n Actual: false"";
+ *os << ""\n Actual: don't match"";
 
 internal::ExplainMatchResultAsNeededTo<const ArgumentTuple&>(
 extra_matcher_, args, os);
",847,158
Implements .With() as a synonym of .WithArguments(); implements AllArgs(m) as a synonym of m; relies on gtest-port to #include tuple; fixes a compatibility with Symbian.," inline bool Value(const T& value, M matcher) {
 return testing::Matches(matcher)(value);
 }
 
+// AllArgs(m) is a synonym of m. This is useful in
+//
+// EXPECT_CALL(foo, Bar(_, _)).With(AllArgs(Eq()));
+//
+// which is easier to read than
+//
+// EXPECT_CALL(foo, Bar(_, _)).With(Eq());
+template <typename InnerMatcher>
+inline InnerMatcher AllArgs(const InnerMatcher& matcher) { return matcher; }
+
 // These macros allow using matchers to check values in Google Test
 // tests. ASSERT_THAT(value, matcher) and EXPECT_THAT(value, matcher)
 // succeed iff the value matches the matcher. If the assertion fails,
",1345,294
Fixes a typo in run_tests.py and its test (by Vlad Losev).," class TestRunner(object):
 if self.subprocess:
 return self.subprocess.Popen(args).wait()
 else:
- return self.os.spawn(self.os.P_WAIT, args[0], args)
+ return self.os.spawnv(self.os.P_WAIT, args[0], args)
 
 def RunBinaryTest(self, test):
 """"""Runs the binary test script given its path relative to the gtest root.
",261,26
Works around a gcc bug when compiling tr1/tuple with RTTI disabled.,"
 #elif defined(__GNUC__) && (GTEST_GCC_VER_ >= 40000)
 // GCC 4.0+ implements tr1/tuple in the <tr1/tuple> header. This does
 // not conform to the TR1 spec, which requires the header to be <tuple>.
+
+#if !GTEST_HAS_RTTI && GTEST_GCC_VER_ < 40302
+// Until version 4.3.2, gcc has a bug that causes <tr1/functional>,
+// which is #included by <tr1/tuple>, to not compile when RTTI is
+// disabled. _TR1_FUNCTIONAL is the header guard for
+// <tr1/functional>. Hence the following #define is a hack to prevent
+// <tr1/functional> from being included.
+#define _TR1_FUNCTIONAL 1
+#include <tr1/tuple>
+#undef _TR1_FUNCTIONAL // Allows the user to #include
+ // <tr1/functional> if he chooses to.
+#else
 #include <tr1/tuple>
+#endif // !GTEST_HAS_RTTI && GTEST_GCC_VER_ < 40302
+
 #else
 // If the compiler is not GCC 4.0+, we assume the user is using a
 // spec-conforming TR1 implementation.
",244,69
Fixes the logic for determining whether cxxabi.h is available.,"
 
 #if GTEST_HAS_TYPED_TEST || GTEST_HAS_TYPED_TEST_P
 
-#ifdef __GNUC__
+// #ifdef __GNUC__ is too general here. It is possible to use gcc without using
+// libstdc++ (which is where cxxabi.h comes from).
+#ifdef __GLIBCXX__
 #include <cxxabi.h>
-#endif // __GNUC__
+#endif // __GLIBCXX__
 
 #include <typeinfo>
 
 String GetTypeName() {
 #if GTEST_HAS_RTTI
 
 const char* const name = typeid(T).name();
-#ifdef __GNUC__
+#ifdef __GLIBCXX__
 int status = 0;
 // gcc's implementation of typeid(T).name() mangles the type name,
 // so we have to demangle it.
 String GetTypeName() {
 return name_str;
 #else
 return name;
-#endif // __GNUC__
+#endif // __GLIBCXX__
 
 #else
 return ""<type>"";
",3061,4
Removes the .WithArguments() clause from ON_CALL and EXPECT_CALL.," class DefaultActionSpec {
 return *this;
 }
 
- // Implements the .WithArguments() clause as a synonym of .With()
- // for backward compatibility. WithArguments() is deprecated and
- // new code should always use With(), as .With(Args<1, 2>(m)) is
- // clearer than .WithArguments(Args<1, 2>(m)).
- DefaultActionSpec& WithArguments(const Matcher<const ArgumentTuple&>& m) {
- return With(m);
- }
-
 // Implements the .WillByDefault() clause.
 DefaultActionSpec& WillByDefault(const Action<F>& action) {
 ExpectSpecProperty(last_clause_ < kWillByDefault,
 class Expectation : public ExpectationBase {
 return *this;
 }
 
- // Implements the .WithArguments() clause as a synonym of .With().
- // This is deprecated and new code should always use With().
- Expectation& WithArguments(const Matcher<const ArgumentTuple&>& m) {
- return With(m);
- }
-
 // Implements the .Times() clause.
 Expectation& Times(const Cardinality& cardinality) {
 if (last_clause_ ==kTimes) {
",847,158
Implements a subset of TR1 tuple needed by gtest and gmock (by Zhanyong Wan); cleaned up the Python tests (by Vlad Losev); made run_tests.py invokable from any directory (by Vlad Losev).," __author__ = 'wan@google.com (Zhanyong Wan)'
 import gtest_test_utils
 import os
 import sys
-import unittest
 
 
 # Constants.
 def Run(command):
 # The tests.
 
 
-class GTestBreakOnFailureUnitTest(unittest.TestCase):
+class GTestBreakOnFailureUnitTest(gtest_test_utils.TestCase):
 """"""Tests using the GTEST_BREAK_ON_FAILURE environment variable or
 the --gtest_break_on_failure flag to turn assertion failures into
 segmentation faults.
",110,19
Switches from Boost TR1 tuple to gtest's TR1 tuple.," TEST(NativeArrayTest, ConstructorFromArrayReferenceWorks) {
 
 TEST(NativeArrayTest, ConstructorFromTupleWorks) {
 int a[3] = { 0, 1, 2 };
+ int* const p = a;
 // Tests with a plain pointer.
- NativeArray<int> na(make_tuple(a, 3U), kReference);
+ NativeArray<int> na(make_tuple(p, 3U), kReference);
 EXPECT_EQ(a, na.begin());
 
 const linked_ptr<char> b(new char);
 TEST(StlContainerViewTest, WorksForDynamicNativeArray) {
 StlContainerView<tuple<const int*, int> >::const_reference>();
 
 int a1[3] = { 0, 1, 2 };
+ const int* const p1 = a1;
 NativeArray<int> a2 = StlContainerView<tuple<const int*, int> >::
- ConstReference(make_tuple(a1, 3));
+ ConstReference(make_tuple(p1, 3));
 EXPECT_EQ(3, a2.size());
 EXPECT_EQ(a1, a2.begin());
 
",656,105
Fixes broken gtest_unittest on Cygwin and cleans it up (by Vlad Losev); fixes the wrong usage of os.environ.clear() in gtest_output_test.py (by Vlad Losev); fixes the logic for detecting Symbian (by Zhanyong Wan); moves TestProperty for event listener (by Vlad Losev).,"
 // Determines the platform on which Google Test is compiled.
 #ifdef __CYGWIN__
 #define GTEST_OS_CYGWIN 1
-#elif __SYMBIAN32__
+#elif defined __SYMBIAN32__
 #define GTEST_OS_SYMBIAN 1
 #elif defined _WIN32
 #define GTEST_OS_WINDOWS 1
",245,69
Fixes compatibility with Windows CE and Symbian (By Tim Baverstock and Mika).," INSTANTIATE_TEST_CASE_P(AnotherInstantiationName, FooTest, ValuesIn(pets));
 
 #endif // 0
 
+#include <gtest/internal/gtest-port.h>
 
+#if !GTEST_OS_SYMBIAN
 #include <utility>
-
-#include <gtest/internal/gtest-port.h>
+#endif
 
 #if GTEST_HAS_PARAM_TEST
 
",950,67
Fixes the broken run_tests_test (by Vlad Losev).," except:
 
 
 IS_WINDOWS = os.name == 'nt'
+IS_CYGWIN = os.name == 'posix' and 'CYGWIN' in os.uname()[0]
 
 # Here we expose a class from a particular module, depending on the
 # environment. The comment suppresses the 'Invalid variable name' lint
 def GetTestExecutablePath(executable_name):
 """"""
 
 path = os.path.abspath(os.path.join(GetBuildDir(), executable_name))
- if IS_WINDOWS and not path.endswith('.exe'):
+ if (IS_WINDOWS or IS_CYGWIN) and not path.endswith('.exe'):
 path += '.exe'
 
 if not os.path.exists(path):
",111,28
Turns on exceptions when compiling gtest_output_test (by Vlad Losev); moves TestCase to gtest.h to prepare for the event listener API (by Vlad Losev).," namespace testing {
 
 class Message; // Represents a failure message.
 class Test; // Represents a test.
-class TestCase; // A collection of related tests.
 class TestPartResult; // Result of a test part.
 class TestInfo; // Information about a test.
 class UnitTest; // A collection of test cases.
",273,43
Makes gmock-spec-builders_test.cc and gmock-internal-utils_test.cc work where both ::string and ::std::string are defined.," TEST(ExpectTest, FailsNonfatallyOnFalse) {
 
 class LogIsVisibleTest : public ::testing::Test {
 protected:
- virtual void SetUp() { original_verbose_ = GMOCK_FLAG(verbose); }
+ virtual void SetUp() {
+ // The code needs to work when both ::string and ::std::string are
+ // defined and the flag is implemented as a
+ // testing::internal::String. In this case, without the call to
+ // c_str(), the compiler will complain that it cannot figure out
+ // whether the String flag should be converted to a ::string or an
+ // ::std::string before being assigned to original_verbose_.
+ original_verbose_ = GMOCK_FLAG(verbose).c_str();
+ }
+
 virtual void TearDown() { GMOCK_FLAG(verbose) = original_verbose_; }
 
 string original_verbose_;
",658,105
Refactors for the event listener API (by Vlad Losev): hides some methods in UnitTest; implements the result printers using the public API.,"
 
 namespace testing {
 
+using internal::GetUnitTestImpl;
+
 // Gets the summary of the failure message by omitting the stack trace
 // in it.
 internal::String TestPartResult::ExtractSummary(const char* message) {
 namespace internal {
 
 HasNewFatalFailureHelper::HasNewFatalFailureHelper()
 : has_new_fatal_failure_(false),
- original_reporter_(UnitTest::GetInstance()->impl()->
+ original_reporter_(GetUnitTestImpl()->
 GetTestPartResultReporterForCurrentThread()) {
- UnitTest::GetInstance()->impl()->SetTestPartResultReporterForCurrentThread(
- this);
+ GetUnitTestImpl()->SetTestPartResultReporterForCurrentThread(this);
 }
 
 HasNewFatalFailureHelper::~HasNewFatalFailureHelper() {
- UnitTest::GetInstance()->impl()->SetTestPartResultReporterForCurrentThread(
+ GetUnitTestImpl()->SetTestPartResultReporterForCurrentThread(
 original_reporter_);
 }
 
",59,17
Reduces the flakiness of gtest-port_test on Mac; improves the Python tests; hides methods that we don't want to publish; makes win-dbg8 the default scons configuration (all by Vlad Losev).," KNOWN BUILD DIRECTORIES
 defines them as follows (the default build directory is the first one
 listed in each group):
 On Windows:
- <gtest root>/scons/build/win-dbg/scons/
- <gtest root>/scons/build/win-opt/scons/
 <gtest root>/scons/build/win-dbg8/scons/
 <gtest root>/scons/build/win-opt8/scons/
+ <gtest root>/scons/build/win-dbg/scons/
+ <gtest root>/scons/build/win-opt/scons/
 On Mac:
 <gtest root>/scons/build/mac-dbg/scons/
 <gtest root>/scons/build/mac-opt/scons/
 IS_CYGWIN = os.name == 'posix' and 'CYGWIN' in os.uname()[0]
 # Definition of CONFIGS must match that of the build directory names in the
 # SConstruct script. The first list item is the default build configuration.
 if IS_WINDOWS:
- CONFIGS = ('win-dbg', 'win-dbg8', 'win-opt', 'win-opt8')
+ CONFIGS = ('win-dbg8', 'win-opt8', 'win-dbg', 'win-opt')
 elif IS_MAC:
 CONFIGS = ('mac-dbg', 'mac-opt')
 else:
",263,23
A trivial comment fix.," inline PolymorphicMatcher<internal::ContainerEqMatcher<
 //
 // ::std::map<int, size_t> page_lengths;
 // page_lengths[1] = 100;
-// EXPECT_THAT(map_int, Contains(::std::pair<const int, size_t>(1, 100)));
+// EXPECT_THAT(page_lengths,
+// Contains(::std::pair<const int, size_t>(1, 100)));
 //
 // const char* user_ids[] = { ""joe"", ""mike"", ""tom"" };
 // EXPECT_THAT(user_ids, Contains(Eq(::std::string(""tom""))));
",1345,294
Makes List a random-access data structure. This simplifies the implementation and makes it easier to implement test shuffling.," class TestResult {
 TimeInMillis elapsed_time() const { return elapsed_time_; }
 
 // Returns the i-th test part result among all the results. i can range
- // from 0 to test_property_count() - 1. If i is not in that range, returns
- // NULL.
- const TestPartResult* GetTestPartResult(int i) const;
+ // from 0 to test_property_count() - 1. If i is not in that range, aborts
+ // the program.
+ const TestPartResult& GetTestPartResult(int i) const;
 
 // Returns the i-th test property. i can range from 0 to
- // test_property_count() - 1. If i is not in that range, returns NULL.
- const TestProperty* GetTestProperty(int i) const;
+ // test_property_count() - 1. If i is not in that range, aborts the
+ // program.
+ const TestProperty& GetTestProperty(int i) const;
 
 private:
 friend class DefaultGlobalTestPartResultReporter;
",487,59
Adds color support for TERM=linux (by Alexander Demin); renames List to Vector (by Zhanyong Wan); implements Vector::Erase (by Vlad Losev).," class Message {
 // decide between class template specializations for T and T*, so a
 // tr1::type_traits-like is_pointer works, and we can overload on that.
 template <typename T>
- inline void StreamHelper(internal::true_type dummy, T* pointer) {
+ inline void StreamHelper(internal::true_type /*dummy*/, T* pointer) {
 if (pointer == NULL) {
 *ss_ << ""(null)"";
 } else {
 class Message {
 }
 }
 template <typename T>
- inline void StreamHelper(internal::false_type dummy, const T& value) {
+ inline void StreamHelper(internal::false_type /*dummy*/, const T& value) {
 ::GTestStreamToHelper(ss_, value);
 }
 #endif // GTEST_OS_SYMBIAN
",72,18
Adds the command line flags needed for test shuffling. Most code by Josh Kelley.," HELP_REGEX = re.compile(
 FLAG_PREFIX + r'filter=.*' +
 FLAG_PREFIX + r'also_run_disabled_tests.*' +
 FLAG_PREFIX + r'repeat=.*' +
+ FLAG_PREFIX + r'shuffle.*' +
+ FLAG_PREFIX + r'random_seed=.*' +
 FLAG_PREFIX + r'color=.*' +
 FLAG_PREFIX + r'print_time.*' +
 FLAG_PREFIX + r'output=.*' +
",62,9
"More refactoring for the event listener API, by Vlad Losev."," TEST_F(MacroLogicDeathTest, ChildDoesNotDie) {
 EXPECT_TRUE(factory_->TestDeleted());
 }
 
-// Returns the number of successful parts in the current test.
-static size_t GetSuccessfulTestPartCount() {
- return GetUnitTestImpl()->current_test_result()->successful_part_count();
-}
-
 // Tests that a successful death test does not register a successful
 // test part.
 TEST(SuccessRegistrationDeathTest, NoSuccessPart) {
 EXPECT_DEATH(_exit(1), """");
- EXPECT_EQ(0u, GetSuccessfulTestPartCount());
+ EXPECT_EQ(0, GetUnitTestImpl()->current_test_result()->total_part_count());
 }
 
 TEST(StreamingAssertionsDeathTest, DeathTest) {
",704,119
Makes ByRef(x) printable as a reference to x.," _COMMON_GMOCK_SYMBOLS = [
 'Not',
 'NotNull',
 'Pointee',
- 'PointeeIsInitializedProto',
 'Property',
 'Ref',
 'ResultOf',
",352,30
Adds the ReturnArg<k>() action (by Tim Hockin); refactors gmock-matchers.h (by Zhanyong Wan).," ACTION_TEMPLATE(InvokeArgument,
 ::std::tr1::get<k>(args), p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);
 }
 
+// Action ReturnArg<k>() returns the k-th argument of the mock function.
+ACTION_TEMPLATE(ReturnArg,
+ HAS_1_TEMPLATE_PARAMS(int, k),
+ AND_0_VALUE_PARAMS()) {
+ return std::tr1::get<k>(args);
+}
+
 // Action SaveArg<k>(pointer) saves the k-th (0-based) argument of the
 // mock function to *pointer.
 ACTION_TEMPLATE(SaveArg,
",952,124
Makes gtest compile clean with gcc -Wall -Werror (by Zhanyong Wan); refactors scons script (by Vlad Losev).," const char kShuffleFlag[] = ""shuffle"";
 const char kThrowOnFailureFlag[] = ""throw_on_failure"";
 
 // A valid random seed must be in [1, kMaxRandomSeed].
-const unsigned int kMaxRandomSeed = 99999;
+const int kMaxRandomSeed = 99999;
 
 // Returns the current time in milliseconds.
 TimeInMillis GetTimeInMillis();
 inline int GetRandomSeedFromFlag(Int32 random_seed_flag) {
 // Normalizes the actual seed to range [1, kMaxRandomSeed] such that
 // it's easy to type.
 const int normalized_seed =
- static_cast<int>((raw_seed - 1U) % kMaxRandomSeed) + 1;
+ static_cast<int>((raw_seed - 1U) %
+ static_cast<unsigned int>(kMaxRandomSeed)) + 1;
 return normalized_seed;
 }
 
",515,106
Makes gtest compilable on Win CE.," static void PrintTestPartResult(const TestPartResult& test_part_result) {
 PrintTestPartResultToString(test_part_result);
 printf(""%s\n"", result.c_str());
 fflush(stdout);
-#if GTEST_OS_WINDOWS
 // If the test program runs in Visual Studio or a debugger, the
- // following states add the test part result message to the Output
+ // following statements add the test part result message to the Output
 // window such that the user can double-click on it to jump to the
 // corresponding source code location; otherwise they do nothing.
+#ifdef _WIN32_WCE
+ // Windows Mobile doesn't support the ANSI version of OutputDebugString,
+ // it works only with UTF16 strings.
+ ::OutputDebugString(internal::String::AnsiToUtf16(result.c_str()));
+ ::OutputDebugString(L""\n"");
+#elif GTEST_OS_WINDOWS
 ::OutputDebugStringA(result.c_str());
 ::OutputDebugStringA(""\n"");
 #endif
",2563,595
Implements EXPECT_DEATH_IF_SUPPORTED (by Vlad Losev); Fixes compatibility with Symbian (by Araceli Checa); Removes GetCapturedStderr()'s dependency on std::string (by Vlad Losev).," inline void FlushInfoLog() { fflush(NULL); }
 // CaptureStderr - starts capturing stderr.
 // GetCapturedStderr - stops capturing stderr and returns the captured string.
 
-#if GTEST_HAS_STD_STRING
 void CaptureStderr();
-::std::string GetCapturedStderr();
-#endif // GTEST_HAS_STD_STRING
+String GetCapturedStderr();
 
 #if GTEST_HAS_DEATH_TEST
 
",248,71
Removes duplicated definition of SetArgumentPointee (by Vlad Losev); Makes gmock compilable on platforms that don't have ::abort() (by Acadeli Checa); Fixes compatibility with Symbian's STLport (by Acadeli Checa).," class GMockCheckProvider {
 }
 ~GMockCheckProvider() {
 ::std::cerr << ::std::endl;
- abort();
+ posix::Abort();
 }
 ::std::ostream& GetStream() { return ::std::cerr; }
 };
",57,12
"Unbreak the build for Solaris by selecting the correct include headers for its
POSIX regex support. Patch contributed by Monty Taylor <monty.taylor@gmail.com>
to the protocol buffer project, and relayed by Kenton to GoogleTest. Tweaked to
include the new define in the #endif comment.","
 #define GTEST_OS_SOLARIS 1
 #endif // __CYGWIN__
 
-#if GTEST_OS_CYGWIN || GTEST_OS_LINUX || GTEST_OS_MAC || GTEST_OS_SYMBIAN
+#if GTEST_OS_CYGWIN || GTEST_OS_LINUX || GTEST_OS_MAC || GTEST_OS_SYMBIAN || \
+ GTEST_OS_SOLARIS
 
 // On some platforms, <regex.h> needs someone to define size_t, and
 // won't compile otherwise. We can #include it here as we already

 // simple regex implementation instead.
 #define GTEST_USES_SIMPLE_RE 1
 
-#endif // GTEST_OS_CYGWIN || GTEST_OS_LINUX || GTEST_OS_MAC
+#endif // GTEST_OS_CYGWIN || GTEST_OS_LINUX || GTEST_OS_MAC ||
+ // GTEST_OS_SYMBIAN || GTEST_OS_SOLARIS
 
 // Defines GTEST_HAS_EXCEPTIONS to 1 if exceptions are enabled, or 0
 // otherwise.
",248,71
Improves protobuf print format.," class TypeWithoutFormatter {
 sizeof(value), os);
 }
 };
+
+// We print a protobuf using its ShortDebugString() when the string
+// doesn't exceed this many characters; otherwise we print it using
+// DebugString() for better readability.
+const size_t kProtobufOneLinerMaxLength = 50;
+
 template <typename T>
 class TypeWithoutFormatter<T, true> {
 public:
 static void PrintValue(const T& value, ::std::ostream* os) {
- // Both ProtocolMessage and proto2::Message have the
- // ShortDebugString() method, so the same implementation works for
- // both.
- ::std::operator<<(*os, ""<"" + value.ShortDebugString() + "">"");
+ const ::testing::internal::string short_str = value.ShortDebugString();
+ const ::testing::internal::string pretty_str =
+ short_str.length() <= kProtobufOneLinerMaxLength ?
+ short_str : (""\n"" + value.DebugString());
+ ::std::operator<<(*os, ""<"" + pretty_str + "">"");
 }
 };
 
",333,61
Fixes an uninitialized field in class OsStackTraceGetter.," class OsStackTraceGetterInterface {
 // A working implementation of the OsStackTraceGetterInterface interface.
 class OsStackTraceGetter : public OsStackTraceGetterInterface {
 public:
- OsStackTraceGetter() {}
+ OsStackTraceGetter() : caller_frame_(NULL) {}
 virtual String CurrentStackTrace(int max_depth, int skip_count);
 virtual void UponLeavingGTest();
 
",515,106
Adds mutable_impl() and impl() to PolymorphicMatcher (by Zhanyong Wan); Enables gMock to compile with VC 7.1 (by Vlad Losev).," class PolymorphicMatcher {
 public:
 explicit PolymorphicMatcher(const Impl& impl) : impl_(impl) {}
 
+ // Returns a mutable reference to the underlying matcher
+ // implementation object.
+ Impl& mutable_impl() { return impl_; }
+
+ // Returns an immutable reference to the underlying matcher
+ // implementation object.
+ const Impl& impl() const { return impl_; }
+
 template <typename T>
 operator Matcher<T>() const {
 return Matcher<T>(new MonomorphicImpl<T>(impl_));
 class PolymorphicMatcher {
 // doesn't need to customize it.
 ExplainMatchResultTo(impl_, x, os);
 }
+
 private:
 const Impl impl_;
 };
 
- const Impl impl_;
+ Impl impl_;
 };
 
 // Creates a matcher from its implementation. This is easier to use
",1543,337
Enables String to contain NUL (by Zhanyong Wan); Adds scons scripts (by Vlad Losev).," static String FlagToEnvVar(const char* flag) {
 (Message() << GTEST_FLAG_PREFIX_ << flag).GetString();
 
 Message env_var;
- for (int i = 0; i != full_flag.GetLength(); i++) {
+ for (size_t i = 0; i != full_flag.length(); i++) {
 env_var << static_cast<char>(toupper(full_flag.c_str()[i]));
 }
 
",372,123
"Depends on gtest r300, which allows String to contain NUL."," static const char* ParseGoogleMockFlagValue(const char* str,
 
 // The flag must start with ""--gmock_"".
 const String flag_str = String::Format(""--gmock_%s"", flag);
- const size_t flag_len = flag_str.GetLength();
+ const size_t flag_len = flag_str.length();
 if (strncmp(str, flag_str.c_str(), flag_len) != 0) return NULL;
 
 // Skips the flag name.
",67,21
"More implementation of the event listener interface (by Vlad Losev); Reduces the stack space usage of assertions by moving AssertHelper's fields to the heap (by Jorg Brown); Makes String faster, smaller, and simpler (by Zhanyong Wan); Fixes a bug in String::Format() (by Chandler); Adds the /MD version of VC projects to the distribution (by Vlad Losev)."," namespace testing {
 
 // The possible outcomes of a test part (i.e. an assertion or an
 // explicit SUCCEED(), FAIL(), or ADD_FAILURE()).
+// TODO(vladl@google.com): Rename the enum values to kSuccess,
+// kNonFatalFailure, and kFatalFailure before publishing the event listener
+// API (see issue http://code.google.com/p/googletest/issues/detail?id=165).
 enum TestPartResultType {
 TPRT_SUCCESS, // Succeeded.
 TPRT_NONFATAL_FAILURE, // Failed but the test can continue.
",69,12
Removes deprecated /Wp64 flag from VC projects; also removes unneeded VC projects.," int UnitTestImpl::RunAllTests() {
 if (g_help_flag)
 return 0;
 
- // TODO(vladl@google.com): Add a call to PostFlagParsingInit() here when
- // merging into the main branch.
+ // Repeats the call to the post-flag parsing initialization in case the
+ // user didn't call InitGoogleTest.
+ PostFlagParsingInit();
 
 // Even if sharding is not on, test runners may want to use the
 // GTEST_SHARD_STATUS_FILE to query whether the test supports the sharding
",2575,608
Improves EXPECT_DEATH_IF_SUPPORTED to allow streaming of messages and enforcing the validity of arguments (by Vlad Losev); adds samples for the event listener API (by Vlad Losev); simplifies the tests using EXPECT_DEATH_IF_SUPPORTED (by Zhanyong Wan).," TEST(GetThreadCountTest, ReturnsZeroWhenUnableToCountThreads) {
 }
 #endif // GTEST_OS_MAC
 
-#if GTEST_HAS_DEATH_TEST
-
 TEST(GtestCheckDeathTest, DiesWithCorrectOutputOnFailure) {
 const bool a_false_condition = false;
 const char regex[] =
 TEST(GtestCheckDeathTest, DiesWithCorrectOutputOnFailure) {
 #endif // _MSC_VER
 "".*a_false_condition.*Extra info.*"";
 
- EXPECT_DEATH(GTEST_CHECK_(a_false_condition) << ""Extra info"", regex);
+ EXPECT_DEATH_IF_SUPPORTED(GTEST_CHECK_(a_false_condition) << ""Extra info"",
+ regex);
 }
 
+#if GTEST_HAS_DEATH_TEST
+
 TEST(GtestCheckDeathTest, LivesSilentlyOnSuccess) {
 EXPECT_EXIT({
 GTEST_CHECK_(true) << ""Extra info"";
",505,71
Simplifies the tests using EXPECT_DEATH_IF_SUPPORTED.," TEST(AssertTest, SucceedsOnTrue) {
 Assert(true, __FILE__, __LINE__); // This should succeed too.
 }
 
-#if GTEST_HAS_DEATH_TEST
-
 // Tests that Assert(false, ...) generates a fatal failure.
 TEST(AssertTest, FailsFatallyOnFalse) {
- EXPECT_DEATH({ // NOLINT
+ EXPECT_DEATH_IF_SUPPORTED({
 Assert(false, __FILE__, __LINE__, ""This should fail."");
 }, """");
 
- EXPECT_DEATH({ // NOLINT
+ EXPECT_DEATH_IF_SUPPORTED({
 Assert(false, __FILE__, __LINE__);
 }, """");
 }
 
-#endif // GTEST_HAS_DEATH_TEST
-
 // Tests that Expect(true, ...) succeeds.
 TEST(ExpectTest, SucceedsOnTrue) {
 Expect(true, __FILE__, __LINE__, ""This should succeed."");
",663,105
Adds new matcher Pair(). Replaces GMOCK_CHECK_ with GTEST_CHECK_ (by Vlad Losev).," class MockObjectRegistry {
 // This can help the user identify the leaked object.
 std::cout << ""\n"";
 const MockObjectState& state = it->second;
- internal::FormatFileLocation(
- state.first_used_file, state.first_used_line, &std::cout);
+ std::cout << internal::FormatFileLocation(state.first_used_file,
+ state.first_used_line);
 std::cout << "" ERROR: this mock object"";
 if (state.first_used_test != """") {
 std::cout << "" (used in test "" << state.first_used_test_case << "".""
",250,59
Small code simplification (by Vlad Losev).," static void FailFromInternalError(int fd) {
 } while (num_read == -1 && errno == EINTR);
 
 if (num_read == 0) {
- GTEST_LOG_(FATAL) << error.GetString().c_str();
+ GTEST_LOG_(FATAL) << error.GetString();
 } else {
 const int last_error = errno;
- const String message = GetLastErrnoDescription();
 GTEST_LOG_(FATAL) << ""Error while reading death test internal: ""
- << message.c_str() << "" ["" << last_error << ""]"";
+ << GetLastErrnoDescription() << "" ["" << last_error << ""]"";
 }
 }
 
 void DeathTestImpl::ReadAndInterpretStatusByte() {
 }
 } else {
 GTEST_LOG_(FATAL) << ""Read from death test child process failed: ""
- << GetLastErrnoDescription().c_str();
+ << GetLastErrnoDescription();
 }
 GTEST_DEATH_TEST_CHECK_SYSCALL_(posix::Close(read_fd()));
 set_read_fd(-1);
",686,130
Simplifies the definition of NativeArray. Works around a VC bug in StrictMock & NiceMock.," TEST(PrintStlContainerTest, NestedContainer) {
 }
 
 TEST(PrintStlContainerTest, OneDimensionalNativeArray) {
- const int a[] = { 1, 2, 3 };
- NativeArray<int> b(a, kReference);
+ const int a[3] = { 1, 2, 3 };
+ NativeArray<int> b(a, 3, kReference);
 EXPECT_EQ(""{ 1, 2, 3 }"", Print(b));
 }
 
 TEST(PrintStlContainerTest, TwoDimensionalNativeArray) {
- const int a[][3] = { { 1, 2, 3 }, { 4, 5, 6 } };
- NativeArray<int[3]> b(a, kReference);
+ const int a[2][3] = { { 1, 2, 3 }, { 4, 5, 6 } };
+ NativeArray<int[3]> b(a, 2, kReference);
 EXPECT_EQ(""{ { 1, 2, 3 }, { 4, 5, 6 } }"", Print(b));
 }
 
",750,117
Makes gtest compile clean with MSVC's warning 4100 (unused formal parameter) enabled.," class TypeParameterizedTestCase {
 template <GTEST_TEMPLATE_ Fixture, typename Types>
 class TypeParameterizedTestCase<Fixture, Templates0, Types> {
 public:
- static bool Register(const char* prefix, const char* case_name,
- const char* test_names) {
+ static bool Register(const char* /*prefix*/, const char* /*case_name*/,
+ const char* /*test_names*/) {
 return true;
 }
 };
",269,43
"Renames the methods in the event listener API, and changes the order of *End events (by Vlad Losev)."," class TersePrinter : public EmptyTestEventListener {
 }
 
 // Called after a failed assertion or a SUCCESS().
- virtual void OnNewTestPartResult(const TestPartResult& test_part_result) {
+ virtual void OnTestPartResult(const TestPartResult& test_part_result) {
 fprintf(stdout,
 ""%s in %s:%d\n%s\n"",
 test_part_result.failed() ? ""*** Failure"" : ""Success"",
",106,23
"Makes gtest compile cleanly with MSVC's warning 4511 & 4512 (copy ctor /
assignment operator cannot be generated) enabled."," class SequenceTestingListener : public EmptyTestEventListener {
 
 Vector<String>* vector_;
 const char* const id_;
+
+ GTEST_DISALLOW_COPY_AND_ASSIGN_(SequenceTestingListener);
 };
 
 TEST(EventListenerTest, AppendKeepsOrder) {
",4249,571
Renames the TestPartResult type enums and adjusts the order of methods in the event listener interface (by Vlad Losev).," bool AlwaysTrue();
 = ::testing::Message()
 
 #define GTEST_FATAL_FAILURE_(message) \
- return GTEST_MESSAGE_(message, ::testing::TPRT_FATAL_FAILURE)
+ return GTEST_MESSAGE_(message, ::testing::TestPartResult::kFatalFailure)
 
 #define GTEST_NONFATAL_FAILURE_(message) \
- GTEST_MESSAGE_(message, ::testing::TPRT_NONFATAL_FAILURE)
+ GTEST_MESSAGE_(message, ::testing::TestPartResult::kNonFatalFailure)
 
 #define GTEST_SUCCESS_(message) \
- GTEST_MESSAGE_(message, ::testing::TPRT_SUCCESS)
+ GTEST_MESSAGE_(message, ::testing::TestPartResult::kSuccess)
 
 // Suppresses MSVC warnings 4072 (unreachable code) for the code following
 // statement if it returns or throws (or doesn't return or throw in some
",269,43
Adds a Random class to support --gtest_shuffle (by Josh Kelley); Makes the scons script build in a deterministic order (by Zhanyong Wan).," String GetCurrentOsStackTraceExceptTop(UnitTest* unit_test, int skip_count);
 // A helper for suppressing warnings on unreachable code in some macros.
 bool AlwaysTrue();
 
+// A simple Linear Congruential Generator for generating random
+// numbers with a uniform distribution. Unlike rand() and srand(), it
+// doesn't use global state (and therefore can't interfere with user
+// code). Unlike rand_r(), it's portable. An LCG isn't very random,
+// but it's good enough for our purposes.
+class Random {
+ public:
+ static const UInt32 kMaxRange = 1u << 31;
+
+ explicit Random(UInt32 seed) : state_(seed) {}
+
+ void Reseed(UInt32 seed) { state_ = seed; }
+
+ // Generates a random number from [0, range). Crashes if 'range' is
+ // 0 or greater than kMaxRange.
+ UInt32 Generate(UInt32 range);
+
+ private:
+ UInt32 state_;
+ GTEST_DISALLOW_COPY_AND_ASSIGN_(Random);
+};
+
 } // namespace internal
 } // namespace testing
 
",279,45
Removes gmock's dependency on python2.4.,"
-#!/usr/bin/python2.4
+#!/usr/bin/env python
 #
 # Copyright 2008, Google Inc.
 # All rights reserved.
",352,30
Removes gtest's dependency on python2.4.,"
-#!/usr/bin/python2.4
+#!/usr/bin/env python
 #
 # Copyright 2006, Google Inc.
 # All rights reserved.
",531,21
"Makes gmock compile on minGW, which uses gcc 3.4.5."," void DefaultPrintTo(IsNotContainer /* dummy */,
 if (p == NULL) {
 *os << ""NULL"";
 } else {
- // We cannot use implicit_cast or static_cast here, as they don't
- // work when p is a function pointer.
- *os << reinterpret_cast<const void*>(p);
+ // We want to print p as a const void*. However, we cannot cast
+ // it to const void* directly, even using reinterpret_cast, as
+ // earlier versions of gcc (e.g. 3.4.5) cannot compile the cast
+ // when p is a function pointer. Casting to UInt64 first solves
+ // the problem.
+ *os << reinterpret_cast<const void*>(reinterpret_cast<internal::UInt64>(p));
 }
 }
 
",333,61
Publishes the even listener API (by Vlad Losev); adds OS-indicating macros to simplify gtest code (by Zhanyong Wan).," class String {
 // memory using malloc().
 static const char* CloneCString(const char* c_str);
 
-#ifdef _WIN32_WCE
+#if GTEST_OS_WINDOWS_MOBILE
 // Windows CE does not have the 'ANSI' versions of Win32 APIs. To be
 // able to pass strings to Win32 APIs on CE we need to convert them
 // to 'Unicode', UTF-16.
",95,26
Simplifies gmock code using gtest's OS-indicating macros.," class AssignAction {
 const T2 value_;
 };
 
-#ifndef _WIN32_WCE
+#if !GTEST_OS_WINDOWS_MOBILE
 
 // Implements the SetErrnoAndReturn action to simulate return from
 // various system calls and libc functions.
 class SetErrnoAndReturnAction {
 const T result_;
 };
 
-#endif // _WIN32_WCE
+#endif // !GTEST_OS_WINDOWS_MOBILE
 
 // Implements the SetArgumentPointee<N>(x) action for any function
 // whose N-th argument (0-based) is a pointer to x's type. The
 PolymorphicAction<internal::AssignAction<T1, T2> > Assign(T1* ptr, T2 val) {
 return MakePolymorphicAction(internal::AssignAction<T1, T2>(ptr, val));
 }
 
-#ifndef _WIN32_WCE
+#if !GTEST_OS_WINDOWS_MOBILE
 
 // Creates an action that sets errno and returns the appropriate error.
 template <typename T>
 SetErrnoAndReturn(int errval, T result) {
 internal::SetErrnoAndReturnAction<T>(errval, result));
 }
 
-#endif // _WIN32_WCE
+#endif // !GTEST_OS_WINDOWS_MOBILE
 
 // Various overloads for InvokeWithoutArgs().
 
",482,88
Adds the IsNull() matcher.," using testing::IgnoreResult;
 using testing::Invoke;
 using testing::InvokeArgument;
 using testing::InvokeWithoutArgs;
+using testing::IsNull;
 using testing::Le;
 using testing::Lt;
 using testing::Matcher;
 TEST(LinkTest, TestMatcherNotNull) {
 ON_CALL(mock, VoidFromString(NotNull())).WillByDefault(Return());
 }
 
+// Tests the linkage of the IsNull matcher.
+TEST(LinkTest, TestMatcherIsNull) {
+ Mock mock;
+
+ ON_CALL(mock, VoidFromString(IsNull())).WillByDefault(Return());
+}
+
 // Tests the linkage of the Ref matcher.
 TEST(LinkTest, TestMatcherRef) {
 Mock mock;
",372,59
"Makes gmock work on Symbian (both 3rd & 5th editions), original patch contributed by Mika Raento."," class ElementsAreMatcher1 {
 typedef typename internal::StlContainerView<RawContainer>::type::value_type
 Element;
 
- const Matcher<const Element&> matchers[] = {
- MatcherCast<const Element&>(e1_),
- };
-
- return MakeMatcher(new ElementsAreMatcherImpl<Container>(matchers, 1));
+ // Nokia's Symbian Compiler has a nasty bug where the object put
+ // in a one-element local array is not destructed when the array
+ // goes out of scope. This leads to obvious badness as we've
+ // added the linked_ptr in it to our other linked_ptrs list.
+ // Hence we implement ElementsAreMatcher1 specially to avoid using
+ // a local array.
+ const Matcher<const Element&> matcher =
+ MatcherCast<const Element&>(e1_);
+ return MakeMatcher(new ElementsAreMatcherImpl<Container>(&matcher, 1));
 }
 
 private:
",637,67
"Makes gtest compile cleanly with MSVC's /W4 (by Zhanyong Wan).
Renames EventListenrs to TestEventListeners (by Zhanyong Wan).
Fixes invalid characters in XML report (by Vlad Losev).
Refacotrs SConscript (by Vlad Losev)."," bool ExitedUnsuccessfully(int exit_status);
 // ASSERT_EXIT*, and EXPECT_EXIT*.
 #define GTEST_DEATH_TEST_(statement, predicate, regex, fail) \
 GTEST_AMBIGUOUS_ELSE_BLOCKER_ \
- if (true) { \
+ if (::testing::internal::AlwaysTrue()) { \
 const ::testing::internal::RE& gtest_regex = (regex); \
 ::testing::internal::DeathTest* gtest_dt; \
 if (!::testing::internal::DeathTest::Create(#statement, &gtest_regex, \
 InternalRunDeathTestFlag* ParseInternalRunDeathTestFlag();
 GTEST_LOG_(WARNING) \
 << ""Death tests are not supported on this platform.\n"" \
 << ""Statement '"" #statement ""' cannot be verified.""; \
- } else if (!::testing::internal::AlwaysTrue()) { \
+ } else if (::testing::internal::AlwaysFalse()) { \
 ::testing::internal::RE::PartialMatch("".*"", (regex)); \
 GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement); \
 terminator; \
",70,11
Changes gmock's version to 1.4.0. Also fixes a compiler warning.," TEST(PrintStlContainerTest, HashMultiSet) {
 std::vector<int> numbers;
 for (size_t i = 0; i != result.length(); i++) {
 if (expected_pattern[i] == 'd') {
- ASSERT_TRUE(isdigit(result[i]));
+ ASSERT_TRUE(isdigit(result[i]) != 0);
 numbers.push_back(result[i] - '0');
 } else {
 EXPECT_EQ(expected_pattern[i], result[i]) << "" where result is ""
",750,117
"Implements test shuffling (by Zhanyong Wan, based on Josh Kelley's original patch).
Enables death tests on minGW (by Vlad Losev).","
 // pops up a dialog window that cannot be suppressed programmatically.
 #if GTEST_HAS_STD_STRING && \
 (GTEST_OS_LINUX || GTEST_OS_MAC || GTEST_OS_CYGWIN || \
- (GTEST_OS_WINDOWS_DESKTOP && _MSC_VER >= 1400))
+ (GTEST_OS_WINDOWS_DESKTOP && _MSC_VER >= 1400) || GTEST_OS_WINDOWS_MINGW)
 #define GTEST_HAS_DEATH_TEST 1
 #include <vector> // NOLINT
 #endif
",234,65
"Refactors the scons script (by Vlad Losev).
Fixes a typo in __GNUC__ (by Zhanyong Wan)."," bool ParseNaturalNumber(const ::std::string& str, Integer* number) {
 char* end;
 // BiggestConvertible is the largest integer type that system-provided
 // string-to-number conversion routines can return.
-#if GTEST_OS_WINDOWS && !defined(__GNU_C__)
+#if GTEST_OS_WINDOWS && !defined(__GNUC__)
 // MSVC and C++ Builder define __int64 instead of the standard long long.
 typedef unsigned __int64 BiggestConvertible;
 const BiggestConvertible parsed = _strtoui64(str.c_str(), &end, 10);
 #else
 typedef unsigned long long BiggestConvertible; // NOLINT
 const BiggestConvertible parsed = strtoull(str.c_str(), &end, 10);
-#endif // GTEST_OS_WINDOWS && !defined(__GNU_C__)
+#endif // GTEST_OS_WINDOWS && !defined(__GNUC__)
 const bool parse_success = *end == '\0' && errno == 0;
 
 // TODO(vladl@google.com): Convert this to compile time assertion when it is
",571,122
Works around a Symbian compiler bug that causes memory leak (by Mika Raento).," void Mock::ClearDefaultActionsLocked(void* mock_obj) {
 // needed by VerifyAndClearExpectationsLocked().
 }
 
+Expectation::Expectation() {}
+
+Expectation::Expectation(
+ const internal::linked_ptr<internal::ExpectationBase>& expectation_base)
+ : expectation_base_(expectation_base) {}
+
+Expectation::~Expectation() {}
+
 // Adds an expectation to a sequence.
 void Sequence::AddExpectation(const Expectation& expectation) const {
 if (*last_expectation_ != expectation) {
",255,62
Fixes: Scons build file broken when used in another SConstruct; warning in VC 8.0 when compiled with /Wp64," void XmlUnitTestResultPrinter::OutputXmlCDataSection(::std::ostream* stream,
 for (;;) {
 const char* const next_segment = strstr(segment, ""]]>"");
 if (next_segment != NULL) {
- stream->write(segment, next_segment - segment);
+ stream->write(
+ segment, static_cast<std::streamsize>(next_segment - segment));
 *stream << ""]]>]]&gt;<![CDATA["";
 segment = next_segment + strlen(""]]>"");
 } else {
",2675,635
Enables more verbose output for expectations (by Sverre Sundsdal); Fixes information loss warning when compiled by VC8.0 with /Wp64; Skips two tests on Windows Mobile that don't work there.,"
 #include <iostream> // NOLINT
 #include <map>
 #include <set>
+#include <string>
 #include <gmock/gmock.h>
 #include <gtest/gtest.h>
 
 namespace internal {
 Mutex g_gmock_mutex(Mutex::NO_CONSTRUCTOR_NEEDED_FOR_STATIC_MUTEX);
 
 // Constructs an ExpectationBase object.
-ExpectationBase::ExpectationBase(const char* file, int line)
+ExpectationBase::ExpectationBase(const char* file,
+ int line,
+ const string& source_text)
 : file_(file),
 line_(line),
+ source_text_(source_text),
 cardinality_specified_(false),
 cardinality_(Exactly(1)),
 call_count_(0),
",259,62
Prints help when encountering unrecognized Google Test flags.,"
 
 #define GTEST_DEV_EMAIL_ ""googletestframework@@googlegroups.com""
 #define GTEST_FLAG_PREFIX_ ""gtest_""
+#define GTEST_FLAG_PREFIX_DASH_ ""gtest-""
 #define GTEST_FLAG_PREFIX_UPPER_ ""GTEST_""
 #define GTEST_NAME_ ""Google Test""
 #define GTEST_PROJECT_URL_ ""http://code.google.com/p/googletest/""
",234,65
Fixes linker error when used with gMock on Windows," bool ParseStringFlag(const char* str, const char* flag, String* value) {
 
 // Determines whether a string pointed by *str has the prefix parameter as
 // its prefix and advances it to point past the prefix if it does.
-bool SkipPrefix(const char* prefix, const char** str) {
- const int prefix_len = strlen(prefix);
+static bool SkipPrefix(const char* prefix, const char** str) {
+ const size_t prefix_len = strlen(prefix);
 
 if (strncmp(*str, prefix, prefix_len) != 0)
 return false;
 bool SkipPrefix(const char* prefix, const char** str) {
 // recognized, it will print its help message. Flags starting with
 // GTEST_INTERNAL_PREFIX_ followed by ""internal_"" are considered Google Test
 // internal flags and do not trigger the help message.
-bool HasGoogleTestFlagPrefix(const char* str) {
+static bool HasGoogleTestFlagPrefix(const char* str) {
 return (SkipPrefix(""--"", &str) ||
 SkipPrefix(""-"", &str) ||
 SkipPrefix(""/"", &str)) &&
",2716,647
Adds a dummy test to gmock-port.test.cc.,"
 #include <gmock/internal/gmock-port.h>
 #include <gtest/gtest.h>
 
-// This file intentionally contains no test at this moment.
+// This file intentionally contains no tests at this moment.
+
+// Putting a dummy test here makes references to symbols in the gtest
+// library and avoids 'undefined symbol' linker errors in gmock_main.
+TEST(DummyTest, Dummy) {}
",3,1
Fixes the code to work with fuse_gtest.py.," INSTANTIATE_TEST_CASE_P(AnotherInstantiationName, FooTest, ValuesIn(pets));
 #include <utility>
 #endif
 
-#if GTEST_HAS_PARAM_TEST
-
+// scripts/fuse_gtest.py depends on gtest's own header being #included
+// *unconditionally*. Therefore these #includes cannot be moved
+// inside #if GTEST_HAS_PARAM_TEST.
 #include <gtest/internal/gtest-internal.h>
 #include <gtest/internal/gtest-param-util.h>
 #include <gtest/internal/gtest-param-util-generated.h>
 
+#if GTEST_HAS_PARAM_TEST
+
 namespace testing {
 
 // Functions producing parameter generators.
",950,67
Improves the scons scripts and run_tests.py (by Vlad Losev); uses typed tests in gtest-port_test.cc only when typed tests are available (by Zhanyong Wan); makes gtest-param-util-generated.h conform to the C++ standard (by Zhanyong Wan).,"
 #if GTEST_HAS_PARAM_TEST
 
 namespace testing {
+
+// Forward declarations of ValuesIn(), which is implemented in
+// include/gtest/gtest-param-test.h.
+template <typename ForwardIterator>
+internal::ParamGenerator<
+ typename ::std::iterator_traits<ForwardIterator>::value_type> ValuesIn(
+ ForwardIterator begin, ForwardIterator end);
+
+template <typename T, size_t N>
+internal::ParamGenerator<T> ValuesIn(const T (&array)[N]);
+
+template <class Container>
+internal::ParamGenerator<typename Container::value_type> ValuesIn(
+ const Container& container);
+
 namespace internal {
 
 // Used in the Values() function to provide polymorphic capabilities.
",4231,406
Blocks test binaries from inheriting GTEST_OUTPUT variable when invoked from Python test scripts (fixes issue 223).," except:
 _SUBPROCESS_MODULE_AVAILABLE = False
 # pylint: enable-msg=C6204
 
+GTEST_OUTPUT_VAR_NAME = 'GTEST_OUTPUT'
 
 IS_WINDOWS = os.name == 'nt'
 IS_CYGWIN = os.name == 'posix' and 'CYGWIN' in os.uname()[0]
 def Main():
 # unittest.main(). Otherwise the latter will be confused by the
 # --gtest_* flags.
 _ParseAndStripGTestFlags(sys.argv)
+ # The tested binaries should not be writing XML output files unless the
+ # script explicitly instructs them to.
+ # TODO(vladl@google.com): Move this into Subprocess when we implement
+ # passing environment into it as a parameter.
+ if GTEST_OUTPUT_VAR_NAME in os.environ:
+ del os.environ[GTEST_OUTPUT_VAR_NAME]
+
 _test_module.main()
",121,31
Implements the element_type typedef in testing::internal::scoped_ptr. This is needed to test gmock's IsNull/NotNull with it.," bool IsTrue(bool condition);
 template <typename T>
 class scoped_ptr {
 public:
+ typedef T element_type;
+
 explicit scoped_ptr(T* p = NULL) : ptr_(p) {}
 ~scoped_ptr() { reset(); }
 
",235,65
Enables gmock's implicit_cast to work with source types that have a non-const conversion operator (by Zhanyong Wan).," namespace internal {
 // but the proposal was submitted too late. It will probably make
 // its way into the language in the future.
 template<typename To, typename From>
-inline To implicit_cast(From const &f) {
+inline To implicit_cast(const From& f) {
 return f;
 }
+// Nokia's compiler can't tell which version of implicit_cast to use when
+// the source is a const, causing the compilation to fail with the error
+// ""ambiguous access to overloaded function"". So we only support the const
+// version of implicit_cast on Symbian.
+#if !GTEST_OS_SYMBIAN
+// This overload is needed in case the From type has a non-const type
+// conversion operator to type To.
+template<typename To, typename From>
+inline To implicit_cast(From& f) {
+ return f;
+}
+#endif
 
 // When you upcast (that is, cast a pointer from type Foo to type
 // SuperclassOfFoo), it's fine to use implicit_cast<>, since upcasts
",33,6
Refactors run_tests.py s.t. it can be shared by gmock (by Vlad Losev); Fixes a warning in gtest-tuple_test.cc on Cygwin (by Vlad Losev).," TEST(TupleConstructorTest, DefaultConstructorDefaultInitializesEachField) {
 b3 = a3;
 EXPECT_EQ(0.0, get<0>(b3));
 EXPECT_EQ('\0', get<1>(b3));
- EXPECT_EQ(NULL, get<2>(b3));
+ EXPECT_TRUE(get<2>(b3) == NULL);
 
 tuple<int, int, int, int, int, int, int, int, int, int> a10, b10;
 b10 = a10;
",200,21
Pulls in gtest r344; improves implicit_cast (by Zhanyong Wan); makes the Python tests work on Windows (by Vlad Losev); adds run_tests.py (by Vlad Losev).," def _NeedToUseReturnNullDiagnoser(msg):
 regex = ('instantiated from \'testing::internal::ReturnAction<R>'
 '::operator testing::Action<Func>\(\) const.*\n' +
 _FILE_LINE_RE + r'instantiated from here\n'
- r'.*gmock-port\.h.*error: invalid conversion from '
- r'\'long int\' to \'(?P<type>.+\*)')
+ r'.*error: no matching function for call to \'implicit_cast\('
+ r'long int&\)')
 diagnosis = """"""
 You are probably calling Return(NULL) and the compiler isn't sure how to turn
-NULL into a %(type)s*. Use ReturnNull() instead.
+NULL into the right type. Use ReturnNull() instead.
 Note: the line number may be off; please fix all instances of Return(NULL).""""""
 return _GenericDiagnoser('NRNULL', 'Need to use ReturnNull',
 regex, diagnosis, msg)
",355,30
Exposes SkipPrefix s.t. it can be used by gmock (by Vlad Losev).," TestInfo* MakeAndRegisterTestInfo(
 TearDownTestCaseFunc tear_down_tc,
 TestFactoryBase* factory);
 
+// If *pstr starts with the given prefix, modifies *pstr to be right
+// past the prefix and returns true; otherwise leaves *pstr unchanged
+// and returns false. None of pstr, *pstr, and prefix can be NULL.
+bool SkipPrefix(const char* prefix, const char** pstr);
+
 #if GTEST_HAS_TYPED_TEST || GTEST_HAS_TYPED_TEST_P
 
 // State of the definition of a type-parameterized test case.
",285,46
Fixes Cygwin compatibility (by Vlad Losev); Improves Python tests (by Vlad Losev); Fixes ambiguous call to implicit_cast; Uses gtest's SkipPrefix() instead gmock's own (by Vlad Losev).," inline To down_cast(From* f) { // so we only accept pointers
 // completely.
 if (false) {
 const To to = NULL;
- implicit_cast<From*>(to);
+ ::testing::internal::implicit_cast<From*>(to);
 }
 
 #if GTEST_HAS_RTTI
",28,5
Stops supporting MSVC 7.1 with exceptions disabled.,"
 // ::std::string is not available is MSVC 7.1 or lower with exceptions
 // disabled.
 #if defined(_MSC_VER) && (_MSC_VER < 1400) && !GTEST_HAS_EXCEPTIONS
+#if !GTEST_ALLOW_VC71_WITHOUT_EXCEPTIONS_
+#error ""When compiling gtest using MSVC 7.1, exceptions must be enabled.""
+#error ""Otherwise std::string and std::vector don't compile.""
+#endif
 #define GTEST_HAS_STD_STRING 0
 #else
 #define GTEST_HAS_STD_STRING 1
",235,65
Turns on -Wshadow (by Preston Jackson).," class TestPartResult {
 // C'tor. TestPartResult does NOT have a default constructor.
 // Always use this constructor (with parameters) to create a
 // TestPartResult object.
- TestPartResult(Type type,
- const char* file_name,
- int line_number,
- const char* message)
- : type_(type),
- file_name_(file_name),
- line_number_(line_number),
- summary_(ExtractSummary(message)),
- message_(message) {
+ TestPartResult(Type a_type,
+ const char* a_file_name,
+ int a_line_number,
+ const char* a_message)
+ : type_(a_type),
+ file_name_(a_file_name),
+ line_number_(a_line_number),
+ summary_(ExtractSummary(a_message)),
+ message_(a_message) {
 }
 
 // Gets the outcome of the test part.
",69,12
Removes uses of GTEST_HAS_STD_STRING.," inline String FormatForComparisonFailureMessage(\
 return operand1_printer(str);\
 }
 
-#if GTEST_HAS_STD_STRING
 GTEST_FORMAT_IMPL_(::std::string, String::ShowCStringQuoted)
-#endif // GTEST_HAS_STD_STRING
 #if GTEST_HAS_STD_WSTRING
 GTEST_FORMAT_IMPL_(::std::wstring, String::ShowWideCStringQuoted)
 #endif // GTEST_HAS_STD_WSTRING
",285,46
"Fixes a slew of compiler warnings and turns on ""warning as error"" in the scons build."," class NiceMock : public MockClass {
 ::testing::Mock::UnregisterCallReaction(
 internal::implicit_cast<MockClass*>(this));
 }
+
+ private:
+ GTEST_DISALLOW_COPY_AND_ASSIGN_(NiceMock);
 };
 
 template <class MockClass>
 class StrictMock : public MockClass {
 ::testing::Mock::UnregisterCallReaction(
 internal::implicit_cast<MockClass*>(this));
 }
+
+ private:
+ GTEST_DISALLOW_COPY_AND_ASSIGN_(StrictMock);
 };
 
 // The following specializations catch some (relatively more common)
",172,24
Removes support for MSVC 7.1 from the scons scripts.," import sys
 
 SCRIPT_DIR = os.path.dirname(__file__) or '.'
 
-# Some Python tests don't work in all configurations.
-PYTHON_TESTS_TO_SKIP = (
- ('win-dbg', 'gtest_throw_on_failure_test.py'),
- ('win-opt', 'gtest_throw_on_failure_test.py'),
- )
-
 sys.path.append(os.path.join(SCRIPT_DIR, 'test'))
 import run_tests_util
 
 def _Main():
 test_runner = run_tests_util.TestRunner(script_dir=SCRIPT_DIR)
 tests = test_runner.GetTestsToRun(args,
 options.configurations,
- options.built_configurations,
- python_tests_to_skip=PYTHON_TESTS_TO_SKIP)
+ options.built_configurations)
 if not tests:
 sys.exit(1) # Incorrect parameters given, abort execution.
 
",21,2
Adds an experimental CMake build script; makes the samples compile without warnings on Windows.," class PreCalculatedPrimeTable : public PrimeTable {
 
 const int is_prime_size_;
 bool* const is_prime_;
+
+ // Disables compiler wqarning ""assignment operator could ot be generated.""
+ void operator=(const PreCalculatedPrimeTable& rhs);
 };
 
 #endif // GTEST_SAMPLES_PRIME_TABLES_H_
",54,20
"Fixes a typo in gtest-port.h, by Manuel Klimek.","
 // 2010 are the only mainstream compilers that come with a TR1 tuple
 // implementation. MSVC 2008 (9.0) provides TR1 tuple in a 323 MB
 // Feature Pack download, which we cannot assume the user has.
-#if (defined(__GNUC__) && (GTEST_GCC_VER_ >= 40000)) || _MSV_VER >= 1600
+#if (defined(__GNUC__) && (GTEST_GCC_VER_ >= 40000)) || _MSC_VER >= 1600
 #define GTEST_USE_OWN_TR1_TUPLE 0
 #else
 #define GTEST_USE_OWN_TR1_TUPLE 1
",233,65
Changes Message() to print double with enough precision by default.,"
 #ifndef GTEST_INCLUDE_GTEST_GTEST_MESSAGE_H_
 #define GTEST_INCLUDE_GTEST_GTEST_MESSAGE_H_
 
+#include <limits>
+
 #include <gtest/internal/gtest-string.h>
 #include <gtest/internal/gtest-internal.h>
 
 class Message {
 // ASSERT/EXPECT in a procedure adds over 200 bytes to the procedure's
 // stack frame leading to huge stack frames in some cases; gcc does not reuse
 // the stack space.
- Message() : ss_(new internal::StrStream) {}
+ Message() : ss_(new internal::StrStream) {
+ // By default, we want there to be enough precision when printing
+ // a double to a Message.
+ *ss_ << std::setprecision(std::numeric_limits<double>::digits10 + 2);
+ }
 
 // Copy constructor.
 Message(const Message& msg) : ss_(new internal::StrStream) { // NOLINT
",75,18
Implements the new matcher API.," class TypedExpectation : public ExpectationBase {
 if (!TupleMatches(matchers_, args)) {
 DescribeMatchFailureTupleTo(matchers_, args, os);
 }
- if (!extra_matcher_.Matches(args)) {
+ StringMatchResultListener listener;
+ if (!extra_matcher_.MatchAndExplain(args, &listener)) {
 *os << "" Expected args: "";
 extra_matcher_.DescribeTo(os);
 *os << ""\n Actual: don't match"";
 
- internal::ExplainMatchResultAsNeededTo<const ArgumentTuple&>(
- extra_matcher_, args, os);
+ internal::StreamInParensAsNeeded(listener.str(), os);
 *os << ""\n"";
 }
 } else if (!AllPrerequisitesAreSatisfied()) {
",955,182
Enables regex matchers on all platforms.,"
 
 #if GTEST_OS_LINUX
 
-// On some platforms, <regex.h> needs someone to define size_t, and
-// won't compile otherwise. We can #include it here as we already
-// included <stdlib.h>, which is guaranteed to define size_t through
-// <stddef.h>.
-#include <regex.h> // NOLINT
-
-// Defines this iff Google Mock uses the enhanced POSIX regular
-// expression syntax. This is public as it affects how a user uses
-// regular expression matchers.
-#define GMOCK_USES_POSIX_RE 1
-
 #endif // GTEST_OS_LINUX
 
-#if defined(GMOCK_USES_PCRE) || defined(GMOCK_USES_POSIX_RE)
-// Defines this iff regular expression matchers are supported. This
-// is public as it tells a user whether he can use regular expression
-// matchers.
-#define GMOCK_HAS_REGEX 1
-#endif // defined(GMOCK_USES_PCRE) || defined(GMOCK_USES_POSIX_RE)
-
 namespace testing {
 namespace internal {
 
",27,5
Implements stdout capturing (by Vlad Losev); fixes compiler error on NVCC (by Zhanyong Wan).," void ColoredPrintf(GTestColor color, const char* fmt, ...) {
 SetConsoleTextAttribute(stdout_handle,
 GetColorAttribute(color) | FOREGROUND_INTENSITY);
 vprintf(fmt, args);
+ // Unless we flush stream buffers now the next SetConsoleTextAttribute
+ // call can reset the color before the output reaches the console.
+ fflush(stdout);
 
 // Restores the text color.
 SetConsoleTextAttribute(stdout_handle, old_color_attrs);
",2716,646
Introduces macro GTEST_HAS_STREAM_REDIRECTION_ (by Vlad Losev); fixes unsynchronized color text output on Windows (by Vlad Losev); fixes the cmake script to work with MSVC 10 (by Manuel Klimek).," GTestLog::~GTestLog() {
 #pragma warning(disable: 4996)
 #endif // _MSC_VER
 
-// Stream capturing is not supported on Windows Mobile.
-#if !GTEST_OS_WINDOWS_MOBILE
+#if GTEST_HAS_STREAM_REDIRECTION_
 
 // Object that captures an output stream (stdout/stderr).
 class CapturedStream {
 String GetCapturedStdout() { return GetCapturedStream(&g_captured_stdout); }
 // Stops capturing stderr and returns the captured string.
 String GetCapturedStderr() { return GetCapturedStream(&g_captured_stderr); }
 
-#endif // !GTEST_OS_WINDOWS_MOBILE
+#endif // GTEST_HAS_STREAM_REDIRECTION_
 
 #if GTEST_HAS_DEATH_TEST
 
",392,127
"Adds support for alternate path separator on Windows, and make all tests pass with CMake and VC++ 9 (by Manuel Klimek)."," class FilePath {
 // particular, RemoveTrailingPathSeparator() only removes one separator, and
 // it is called in CreateDirectoriesRecursively() assuming that it will change
 // a pathname from directory syntax (trailing separator) to filename syntax.
+ //
+ // On Windows this method also replaces the alternate path separator '/' with
+ // the primary path separator '\\', so that for example ""bar\\/\\foo"" becomes
+ // ""bar\\foo"".
 
 void Normalize();
 
+ // Returns a pointer to the last occurence of a valid path separator in
+ // the FilePath. On Windows, for example, both '/' and '\' are valid path
+ // separators. Returns NULL if no path separator was found.
+ const char* FindLastPathSeparator() const;
+
 String pathname_;
 }; // class FilePath
 
",51,10
Adds Solaris support (by Hady Zalek),"
 // tuple template as a friend (it complains that tuple is redefined). This
 // hack bypasses the bug by declaring the members that should otherwise be
 // private as public.
-#if defined(__SYMBIAN32__)
+// Sun Studio versions < 12 also have the above bug.
+#if defined(__SYMBIAN32__) || (defined(__SUNPRO_CC) && __SUNPRO_CC < 0x590)
 #define GTEST_DECLARE_TUPLE_AS_FRIEND_ public:
 #else
 #define GTEST_DECLARE_TUPLE_AS_FRIEND_ \
",626,30
Adds Solaris support to test scripts.," class CapturedStream {
 char temp_file_path[MAX_PATH + 1] = { '\0' }; // NOLINT
 
 ::GetTempPathA(sizeof(temp_dir_path), temp_dir_path);
- ::GetTempFileNameA(temp_dir_path, ""gtest_redir"", 0, temp_file_path);
+ const UINT success = ::GetTempFileNameA(temp_dir_path,
+ ""gtest_redir"",
+ 0, // Generate unique file name.
+ temp_file_path);
+ GTEST_CHECK_(success != 0)
+ << ""Unable to create a temporary file in "" << temp_dir_path;
 const int captured_fd = creat(temp_file_path, _S_IREAD | _S_IWRITE);
+ GTEST_CHECK_(captured_fd != -1) << ""Unable to open temporary file ""
+ << temp_file_path;
 filename_ = temp_file_path;
 #else
 // There's no guarantee that a test has write access to the
",402,128
Google Test's Python tests now pass on Solaris.," EXE_PATH = gtest_test_utils.GetTestExecutablePath(
 # Utilities.
 
 
+environ = os.environ.copy()
+
+
 def SetEnvVar(env_var, value):
 """"""Sets an environment variable to a given value; unsets it when the
 given value is None.
 """"""
 
 if value is not None:
- os.environ[env_var] = value
- elif env_var in os.environ:
- del os.environ[env_var]
+ environ[env_var] = value
+ elif env_var in environ:
+ del environ[env_var]
 
 
 def Run(command):
 """"""Runs a command; returns 1 if it was killed by a signal, or 0 otherwise.""""""
 
- p = gtest_test_utils.Subprocess(command)
+ p = gtest_test_utils.Subprocess(command, env=environ)
 if p.terminated_by_signal:
 return 1
 else:
",111,19
"Adds threading support (by Miklos Fazekas, Vlad Losev, and Chandler Carruth); adds wide InitGoogleTest to gtest.def (by Vlad Losev); updates the version number (by Zhanyong Wan); updates the release notes for 1.5.0 (by Vlad Losev); removes scons scripts from the distribution (by Zhanyong Wan); adds the cmake build script to the distribution (by Zhanyong Wan); adds fused source files to the distribution (by Vlad Losev and Chandler Carruth)."," namespace testing {
 namespace internal {
 
 // Protects copying of all linked_ptr objects.
-extern Mutex g_linked_ptr_mutex;
+GTEST_DECLARE_STATIC_MUTEX_(g_linked_ptr_mutex);
 
 // This is used internally by all instances of linked_ptr<>. It needs to be
 // a non-template class because different types of linked_ptr<> can refer to
",110,30
Adds threading support (by Vlad Losev); updates the version number (by Zhanyong Wan); adds release notes for 1.5.0 (by Vlad Losev).," template <typename F> class FunctionMockerBase;
 // expectations when InSequence() is used, and thus affect which
 // expectation gets picked. Therefore, we sequence all mock function
 // calls to ensure the integrity of the mock objects' states.
-extern Mutex g_gmock_mutex;
+GTEST_DECLARE_STATIC_MUTEX_(g_gmock_mutex);
 
 // Abstract base class of FunctionMockerBase. This is the
 // type-agnostic part of the function mocker interface. Its pure
",955,182
Simplifies the implementation by using std::vector instead of Vector.," struct TraceInfo; // Information about a trace point.
 class ScopedTrace; // Implements scoped trace.
 class TestInfoImpl; // Opaque implementation of TestInfo
 class UnitTestImpl; // Opaque implementation of UnitTest
-template <typename E> class Vector; // A generic vector.
 
 // How many times InitGoogleTest() has been called.
 extern int g_init_gtest_count;
",284,46
Fixes MSVC warnings in 64-bit mode.," bool ShouldRunTestOnShard(int total_shards, int shard_index, int test_id);
 // the given predicate.
 template <class Container, typename Predicate>
 inline int CountIf(const Container& c, Predicate predicate) {
- return std::count_if(c.begin(), c.end(), predicate);
+ return static_cast<int>(std::count_if(c.begin(), c.end(), predicate));
 }
 
 // Applies a function/functor to each element in the container.
 void ShuffleRange(internal::Random* random, int begin, int end,
 // Performs an in-place shuffle of the vector's elements.
 template <typename E>
 inline void Shuffle(internal::Random* random, std::vector<E>* v) {
- ShuffleRange(random, 0, v->size(), v);
+ ShuffleRange(random, 0, static_cast<int>(v->size()), v);
 }
 
 // A function for deleting an object. Handy for being used as a
",457,84
Fixes issue 216 (gtest_output_test broken on Solaris," class GTestOutputTest(gtest_test_utils.TestCase):
 test_output = RemoveMatchingTests(test_output, 'DeathTest')
 if not SUPPORTS_TYPED_TESTS:
 test_output = RemoveMatchingTests(test_output, 'TypedTest')
+ test_output = RemoveMatchingTests(test_output, 'TypedDeathTest')
+ test_output = RemoveMatchingTests(test_output, 'TypeParamDeathTest')
 if not SUPPORTS_THREADS:
 test_output = RemoveMatchingTests(test_output,
 'ExpectFailureWithThreadsTest')
",160,20
Makes all samples compile with -Wall -Wshadow -Werror.,"
 #include <string.h>
 
 // Clones a 0-terminated C string, allocating memory using new.
-const char * MyString::CloneCString(const char * c_string) {
- if (c_string == NULL) return NULL;
+const char* MyString::CloneCString(const char* a_c_string) {
+ if (a_c_string == NULL) return NULL;
 
- const size_t len = strlen(c_string);
- char * const clone = new char[ len + 1 ];
- memcpy(clone, c_string, len + 1);
+ const size_t len = strlen(a_c_string);
+ char* const clone = new char[ len + 1 ];
+ memcpy(clone, a_c_string, len + 1);
 
 return clone;
 }
 
 // Sets the 0-terminated C string this MyString object
 // represents.
-void MyString::Set(const char * c_string) {
+void MyString::Set(const char* a_c_string) {
 // Makes sure this works when c_string == c_string_
- const char * const temp = MyString::CloneCString(c_string);
+ const char* const temp = MyString::CloneCString(a_c_string);
 delete[] c_string_;
 c_string_ = temp;
 }
",14,3
Updating the xcode/Samples.,"
 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 //
-// Author: preston.jackson@gmail.com (Preston Jackson)
+// Author: preston.a.jackson@gmail.com (Preston Jackson)
 //
 // Google Test - FrameworkSample
 // widget.cc
 Widget::Widget(int number, const std::string& name)
 name_(name) {}
 
 Widget::~Widget() {}
- 
+
 float Widget::GetFloatValue() const {
 return number_;
 }
 float Widget::GetFloatValue() const {
 int Widget::GetIntValue() const {
 return static_cast<int>(number_);
 }
- 
+
 std::string Widget::GetStringValue() const {
 return name_;
 }
",19,6
Renames ThreadStartSempahore to Notificaton (by Vlad Losev); adds threading tests for SCOPED_TRACE() (by Vlad Losev); replaces native pthread calls with gtest's threading constructs (by Vlad Losev); fixes flakiness in CountedDestructor (by Vlad Losev); minor MSVC 7.1 clean-up (by Zhanyong Wan).," namespace internal {
 
 // String - a UTF-8 string class.
 //
-// We cannot use std::string as Microsoft's STL implementation in
-// Visual C++ 7.1 has problems when exception is disabled. There is a
-// hack to work around this, but we've seen cases where the hack fails
-// to work.
+// For historic reasons, we don't use std::string.
 //
-// Also, String is different from std::string in that it can represent
-// both NULL and the empty string, while std::string cannot represent
-// NULL.
+// TODO(wan@google.com): replace this class with std::string or
+// implement it in terms of the latter.
+//
+// Note that String can represent both NULL and the empty string,
+// while std::string cannot represent NULL.
 //
 // NULL and the empty string are considered different. NULL is less
 // than anything (including the empty string) except itself.
",97,26
Supports building gtest as a DLL (by Vlad Losev).," namespace testing {
 // latter (it causes an access violation if you do). The Message
 // class hides this difference by treating a NULL char pointer as
 // ""(null)"".
-class Message {
+class GTEST_API_ Message {
 private:
 // The type of basic IO manipulators (endl, ends, and flush) for
 // narrow streams.
",75,18
Adds a free function MatchAndExplain().," inline bool Value(const T& value, M matcher) {
 return testing::Matches(matcher)(value);
 }
 
+// Matches the value against the given matcher and explains the match
+// result to listener.
+template <typename T, typename M>
+inline bool MatchAndExplain(
+ M matcher, const T& value, MatchResultListener* listener) {
+ return SafeMatcherCast<const T&>(matcher).MatchAndExplain(value, listener);
+}
+
 // AllArgs(m) is a synonym of m. This is useful in
 //
 // EXPECT_CALL(foo, Bar(_, _)).With(AllArgs(Eq()));
",1674,337
Adds a smoketest for ThreadWithParam.," TEST(ThreadLocalTest, PointerAndConstPointerReturnSameValue) {
 }
 
 #if GTEST_IS_THREADSAFE
+
+void AddTwo(int* param) { *param += 2; }
+
+TEST(ThreadWithParamTest, ConstructorExecutesThreadFunc) {
+ int i = 40;
+ ThreadWithParam<int*> thread(&AddTwo, &i, NULL);
+ thread.Join();
+ EXPECT_EQ(42, i);
+}
+
 TEST(MutexDeathTest, AssertHeldShouldAssertWhenNotLocked) {
 // AssertHeld() is flaky only in the presence of multiple threads accessing
 // the lock. In this case, the test is robust.
",692,104
Fixes an 'unreachable code' warning by MSVC on certain opt settings in gtest-death-test_test.cc.," void DieInside(const char* function) {
 // system call and thus safer in the presence of threads. exit()
 // will invoke user-defined exit-hooks, which may do dangerous
 // things that conflict with death tests.
- _exit(1);
+ //
+ // Some compilers can recognize that _exit() never returns and issue the
+ // 'unreachable code' warning for code following this function, unless
+ // fooled by a fake condition.
+ if (AlwaysTrue())
+ _exit(1);
 }
 
 // Tests that death tests work.
",757,133
"Fixes a typo in comment, by Vlad Losev."," class ParamGeneratorInterface {
 virtual ParamIteratorInterface<T>* End() const = 0;
 };
 
-// Wraps ParamGeneratorInetrface<T> and provides general generator syntax
+// Wraps ParamGeneratorInterface<T> and provides general generator syntax
 // compatible with the STL Container concept.
 // This class implements copy initialization semantics and the contained
 // ParamGeneratorInterface<T> instance is shared among all copies
",370,75
Fixes the explanation generated by many composite matchers (by Manuel Klimek); publishes the gmock value printer as testing::PrintToString() (by Zhanyong Wan).," TEST(ArgsTest, CanMatchTupleByReference) {
 
 // Validates that arg is printed as str.
 MATCHER_P(PrintsAs, str, """") {
- typedef GMOCK_REMOVE_CONST_(GMOCK_REMOVE_REFERENCE_(arg_type)) RawTuple;
- return
- testing::internal::UniversalPrinter<RawTuple>::PrintToString(arg) == str;
+ return testing::PrintToString(arg) == str;
 }
 
 TEST(ArgsTest, AcceptsTenTemplateArgs) {
",793,135
Fixes a -Wextra warning in gtest-param-util.h and updates the cmake script to verify it (by Zhanyong Wan); adds support for hermetic build to the cmake script (by Vlad Losev).," class RangeGenerator : public ParamGeneratorInterface<T> {
 
 private:
 Iterator(const Iterator& other)
- : base_(other.base_), value_(other.value_), index_(other.index_),
+ : ParamIteratorInterface<T>(),
+ base_(other.base_), value_(other.value_), index_(other.index_),
 step_(other.step_) {}
 
 // No implementation - assignment is unsupported.
",371,75
Fixes comments and tests for the moment of generator parameter evaluation in INSTANTIATE_TEST_CASE_P.," INSTANTIATE_TEST_CASE_P(AnotherInstantiationName, FooTest, ValuesIn(pets));
 // in the given test case, whether their definitions come before or
 // AFTER the INSTANTIATE_TEST_CASE_P statement.
 //
-// Please also note that generator expressions are evaluated in
-// RUN_ALL_TESTS(), after main() has started. This allows evaluation of
-// parameter list based on command line parameters.
+// Please also note that generator expressions (including parameters to the
+// generators) are evaluated in InitGoogleTest(), after main() has started.
+// This allows the user on one hand, to adjust generator parameters in order
+// to dynamically determine a set of tests to run and on the other hand,
+// give the user a chance to inspect the generated tests with Google Test
+// reflection API before RUN_ALL_TESTS() is executed.
 //
 // You can see samples/sample7_unittest.cc and samples/sample8_unittest.cc
 // for more examples.
",950,67
Adds missing gtest DLL exports.," namespace internal {
 // Names are NOT checked for syntax correctness -- no checking for illegal
 // characters, malformed paths, etc.
 
-class FilePath {
+class GTEST_API_ FilePath {
 public:
 FilePath() : pathname_("""") { }
 FilePath(const FilePath& rhs) : pathname_(rhs.pathname_) { }
",51,10
Makes gtest work with Sun Studio. Patch submitted by Hady Zalek.,"
-// This file was GENERATED by a script. DO NOT EDIT BY HAND!!!
+// This file was GENERATED by command:
+// pump.py gtest-type-util.h.pump
+// DO NOT EDIT BY HAND!!!
 
 // Copyright 2008 Google Inc.
 // All Rights Reserved.

 #include <cxxabi.h>
 #endif // __GLIBCXX__
 
-#include <typeinfo>
-
 namespace testing {
 namespace internal {
 
",3060,4
"Enables death tests on AIX, by Hady Zalek.","
 // abort() in a VC 7.1 application compiled as GUI in debug config
 // pops up a dialog window that cannot be suppressed programmatically.
 #if (GTEST_OS_LINUX || GTEST_OS_MAC || GTEST_OS_CYGWIN || GTEST_OS_SOLARIS || \
- (GTEST_OS_WINDOWS_DESKTOP && _MSC_VER >= 1400) || GTEST_OS_WINDOWS_MINGW)
+ (GTEST_OS_WINDOWS_DESKTOP && _MSC_VER >= 1400) || \
+ GTEST_OS_WINDOWS_MINGW || GTEST_OS_AIX)
 #define GTEST_HAS_DEATH_TEST 1
 #include <vector> // NOLINT
 #endif
",397,101
Makes the cmake script work on Solaris and AIX (by Hady Zalek).," Derived* CheckedDowncastToActualType(Base* base) {
 return dynamic_cast<Derived*>(base); // NOLINT
 #else
 return static_cast<Derived*>(base); // Poor man's downcast.
-#endif // GTEST_HAS_RTTI
+#endif
 }
 
 #if GTEST_HAS_STREAM_REDIRECTION_
",397,101
Supports no-RTTI mode on AIX (by Hady Zalek).,"
 #define GTEST_HAS_RTTI 1
 #else
 #define GTEST_HAS_RTTI 0
-#endif // _CPPRTTI
+#endif
 
 #elif defined(__GNUC__)
 

 #define GTEST_HAS_RTTI 1
 #endif // GTEST_GCC_VER >= 40302
 
+#elif defined(__IBMCPP__)
+
+// IBM Visual Age defines __RTTI_ALL__ to 1 if both the typeid and
+// dynamic_cast features are present.
+#ifdef __RTTI_ALL__
+#define GTEST_HAS_RTTI 1
+#else
+#define GTEST_HAS_RTTI 0
+#endif
+
 #else
 
 // Unknown compiler - assume RTTI is enabled.
",397,101
Fixes compatibility with Visual Age versions lower than 9.0 (by Hady Zalek); updates the release notes.,"
 #define GTEST_HAS_RTTI 0
 #endif
 
-#elif defined(__GNUC__)
-
 // Starting with version 4.3.2, gcc defines __GXX_RTTI iff RTTI is enabled.
-#if GTEST_GCC_VER_ >= 40302
+#elif defined(__GNUC__) && (GTEST_GCC_VER_ >= 40302)
+
 #ifdef __GXX_RTTI
 #define GTEST_HAS_RTTI 1
 #else
 #define GTEST_HAS_RTTI 0
 #endif // __GXX_RTTI
-#else
-// For gcc versions smaller than 4.3.2, we assume RTTI is enabled.
-#define GTEST_HAS_RTTI 1
-#endif // GTEST_GCC_VER >= 40302
 
-#elif defined(__IBMCPP__)
+// Starting with version 9.0 IBM Visual Age defines __RTTI_ALL__ to 1 if
+// both the typeid and dynamic_cast features are present.
+#elif defined(__IBMCPP__) && (__IBMCPP__ >= 900)
 
-// IBM Visual Age defines __RTTI_ALL__ to 1 if both the typeid and
-// dynamic_cast features are present.
 #ifdef __RTTI_ALL__
 #define GTEST_HAS_RTTI 1
 #else

 
 #else
 
-// Unknown compiler - assume RTTI is enabled.
+// For all other compilers, we assume RTTI is enabled.
 #define GTEST_HAS_RTTI 1
 
 #endif // _MSC_VER
",397,101
C++ Builder compatibility patch by Josh Kelley.,"
 #ifndef GTEST_INCLUDE_GTEST_INTERNAL_GTEST_STRING_H_
 #define GTEST_INCLUDE_GTEST_INTERNAL_GTEST_STRING_H_
 
+#ifdef __BORLANDC__
+// string.h is not guaranteed to provide strcpy on C++ Builder.
+#include <mem.h>
+#endif
+
 #include <string.h>
 #include <gtest/internal/gtest-port.h>
 
",98,26
Fixes gtest_filter_unittest and gtest_help_test on systems without death tests.,"
 TEST(HelpFlagTest, ShouldNotBeRun) {
 ASSERT_TRUE(false) << ""Tests shouldn't be run when --help is specified."";
 }
+
+#if GTEST_HAS_DEATH_TEST
+TEST(DeathTest, UsedByPythonScriptToDetectSupportForDeathTestsInThisBinary) {}
+#endif
",5,2
"Adds alternative spellings for FAIL, SUCCEED, and TEST."," TEST(EventListenerTest, RemovingDefaultXmlGeneratorWorks) {
 EXPECT_FALSE(is_destroyed);
 delete listener;
 }
+
+// Sanity tests to ensure that the alternative, verbose spellings of
+// some of the macros work. We don't test them thoroughly as that
+// would be quite involved. Since their implementations are
+// straightforward, and they are rarely used, we'll just rely on the
+// users to tell us when they are broken.
+GTEST_TEST(AlternativeNameTest, Works) { // GTEST_TEST is the same as TEST.
+ GTEST_SUCCEED() << ""OK""; // GTEST_SUCCEED is the same as SUCCEED.
+
+ // GTEST_FAIL is the same as FAIL.
+ EXPECT_FATAL_FAILURE(GTEST_FAIL() << ""An expected failure"",
+ ""An expected failure"");
+}
",4390,616
Fixes gtest-port_test on MinGW.," TEST(GtestCheckDeathTest, DiesWithCorrectOutputOnFailure) {
 const char regex[] =
 #ifdef _MSC_VER
 ""gtest-port_test\\.cc\\(\\d+\\):""
-#else
+#elif GTEST_USES_POSIX_RE
 ""gtest-port_test\\.cc:[0-9]+""
+#else
+ ""gtest-port_test\\.cc:\\d+""
 #endif // _MSC_VER
 "".*a_false_condition.*Extra info.*"";
 
",714,106
Implements color output in GNU Screen sessions (issue 277).," bool ShouldUseColor(bool stdout_is_tty) {
 String::CStringEquals(term, ""xterm"") ||
 String::CStringEquals(term, ""xterm-color"") ||
 String::CStringEquals(term, ""xterm-256color"") ||
+ String::CStringEquals(term, ""screen"") ||
 String::CStringEquals(term, ""linux"") ||
 String::CStringEquals(term, ""cygwin"");
 return stdout_is_tty && term_supports_color;
",2726,650
Adds a synchronization test.," TEST(VerifyAndClearTest, DoesNotAffectOtherMockObjects) {
 // action or as a default action without causing a dead lock. It
 // verifies that the action is not performed inside the critical
 // section.
+TEST(SynchronizationTest, CanCallMockMethodInAction) {
+ MockA a;
+ MockC c;
+ ON_CALL(a, DoA(_))
+ .WillByDefault(IgnoreResult(InvokeWithoutArgs(&c,
+ &MockC::NonVoidMethod)));
+ EXPECT_CALL(a, DoA(1));
+ EXPECT_CALL(a, DoA(1))
+ .WillOnce(Invoke(&a, &MockA::DoA))
+ .RetiresOnSaturation();
+ EXPECT_CALL(c, NonVoidMethod());
 
-void Helper(MockC* c) {
- c->NonVoidMethod();
+ a.DoA(1);
+ // This will match the second EXPECT_CALL() and trigger another a.DoA(1),
+ // which will in turn match the first EXPECT_CALL() and trigger a call to
+ // c.NonVoidMethod() that was specified by the ON_CALL() since the first
+ // EXPECT_CALL() did not specify an action.
 }
 
 } // namespace
",1688,145
Improves support for building Google Test as Windows DLL.," void DeathTestImpl::Abort(AbortReason reason) {
 const char status_ch =
 reason == TEST_DID_NOT_DIE ? kDeathTestLived : kDeathTestReturned;
 GTEST_DEATH_TEST_CHECK_SYSCALL_(posix::Write(write_fd(), &status_ch, 1));
- GTEST_DEATH_TEST_CHECK_SYSCALL_(posix::Close(write_fd()));
+ // We are leaking the descriptor here because on some platforms (i.e.,
+ // when built as Windows DLL), destructors of global objects will still
+ // run after calling _exit(). On such systems, write_fd_ will be
+ // indirectly closed from the destructor of UnitTestImpl, causing double
+ // close if it is also closed here. On debug configurations, double close
+ // may assert. As there are no in-process buffers to flush here, we are
+ // relying on the OS to close the descriptor after the process terminates
+ // when the destructors are not run.
 _exit(1); // Exits w/o any normal exit hooks (we were supposed to crash)
 }
 
",686,130
Fixes tests leaking altered values of GMOCK_FLAG(verbose) (issue 110).," void TestLogWithSeverity(const string& verbosity, LogSeverity severity,
 // Tests that when the stack_frames_to_skip parameter is negative,
 // Log() doesn't include the stack trace in the output.
 TEST(LogTest, NoStackTraceWhenStackFramesToSkipIsNegative) {
+ const string saved_flag = GMOCK_FLAG(verbose);
 GMOCK_FLAG(verbose) = kInfoVerbosity;
 CaptureStdout();
 Log(INFO, ""Test log.\n"", -1);
 EXPECT_STREQ(""\nTest log.\n"", GetCapturedStdout().c_str());
+ GMOCK_FLAG(verbose) = saved_flag;
 }
 
 // Tests that in opt mode, a positive stack_frames_to_skip argument is
",654,104
Silence a Clang warning about an unused variable.," struct StaticAssertTypeEqHelper<T, T> {};
 // to cause a compiler error.
 template <typename T1, typename T2>
 bool StaticAssertTypeEq() {
- internal::StaticAssertTypeEqHelper<T1, T2>();
+ (void)internal::StaticAssertTypeEqHelper<T1, T2>();
 return true;
 }
 
",591,79
Moves the universal printer from gmock to gtest (by Vlad Losev).," ACTION_TEMPLATE(SetArgReferee,
 // Ensures that argument #k is a reference. If you get a compiler
 // error on the next line, you are using SetArgReferee<k>(value) in
 // a mock function whose k-th (0-based) argument is not a reference.
- GMOCK_COMPILE_ASSERT_(internal::is_reference<argk_type>::value,
+ GTEST_COMPILE_ASSERT_(internal::is_reference<argk_type>::value,
 SetArgReferee_must_be_used_with_a_reference_argument);
 ::std::tr1::get<k>(args) = value;
 }
",84,16
"Suppresses some Clang warnings (by Chandler Carruth, Jeffrey Yasskin, and Zhanyong Wan)."," GTEST_API_ AssertionResult DoubleLE(const char* expr1, const char* expr2,
 // to cause a compiler error.
 template <typename T1, typename T2>
 bool StaticAssertTypeEq() {
- internal::StaticAssertTypeEqHelper<T1, T2>();
+ (void)internal::StaticAssertTypeEqHelper<T1, T2>();
 return true;
 }
 
",586,79
Renames test script flags.,"
 """"""Tests the --help flag of Google C++ Testing Framework.
 
 SYNOPSIS
- gtest_help_test.py --gtest_build_dir=BUILD/DIR
+ gtest_help_test.py --build_dir=BUILD/DIR
 # where BUILD/DIR contains the built gtest_help_test_ file.
 gtest_help_test.py
 """"""
",81,16
Fixes a typo in comments.," class GTEST_API_ UnitTestImpl {
 }
 
 // Registers all parameterized tests defined using TEST_P and
- // INSTANTIATE_TEST_P, creating regular tests for each test/parameter
- // combination. This method can be called more then once; it has
- // guards protecting from registering the tests more then once.
- // If value-parameterized tests are disabled, RegisterParameterizedTests
- // is present but does nothing.
+ // INSTANTIATE_TEST_CASE_P, creating regular tests for each test/parameter
+ // combination. This method can be called more then once; it has guards
+ // protecting from registering the tests more then once. If
+ // value-parameterized tests are disabled, RegisterParameterizedTests is
+ // present but does nothing.
 void RegisterParameterizedTests();
 
 // Runs all tests in this UnitTest object, prints the result, and
",463,84
Adds GTEST_REMOVE_REFERENCE_AND_CONST_.," struct RemoveConst<T[N]> {
 #define GTEST_REMOVE_CONST_(T) \
 typename ::testing::internal::RemoveConst<T>::type
 
+// Turns const U&, U&, const U, and U all into U.
+#define GTEST_REMOVE_REFERENCE_AND_CONST_(T) \
+ GTEST_REMOVE_CONST_(GTEST_REMOVE_REFERENCE_(T))
+
 // Adds reference to a type if it is not a reference type,
 // otherwise leaves it unchanged. This is the same as
 // tr1::add_reference, which is not widely available yet.
 class NativeArray {
 // Ensures that the user doesn't instantiate NativeArray with a
 // const or reference type.
 static_cast<void>(StaticAssertTypeEqHelper<Element,
- GTEST_REMOVE_CONST_(GTEST_REMOVE_REFERENCE_(Element))>());
+ GTEST_REMOVE_REFERENCE_AND_CONST_(Element)>());
 if (relation_to_source_ == kCopy)
 delete[] array_;
 }
",425,73
Implements printing parameters of failed parameterized tests (issue 71).," SUPPORTS_STACK_TRACES = False
 
 CAN_GENERATE_GOLDEN_FILE = (SUPPORTS_DEATH_TESTS and
 SUPPORTS_TYPED_TESTS and
- SUPPORTS_THREADS)
+ (SUPPORTS_THREADS or IS_WINDOWS))
 
 
 class GTestOutputTest(gtest_test_utils.TestCase):
",160,20
Fixes a wrong comment for OnTestPartResult().," class TestEventListener {
 // Fired before the test starts.
 virtual void OnTestStart(const TestInfo& test_info) = 0;
 
- // Fired after a failed assertion or a SUCCESS().
+ // Fired after a failed assertion or a SUCCEED() invocation.
 virtual void OnTestPartResult(const TestPartResult& test_part_result) = 0;
 
 // Fired after the test ends.
",586,79
Adds tests for SkipPrefix().," GTEST_API_ TestInfo* MakeAndRegisterTestInfo(
 // If *pstr starts with the given prefix, modifies *pstr to be right
 // past the prefix and returns true; otherwise leaves *pstr unchanged
 // and returns false. None of pstr, *pstr, and prefix can be NULL.
-bool SkipPrefix(const char* prefix, const char** pstr);
+GTEST_API_ bool SkipPrefix(const char* prefix, const char** pstr);
 
 #if GTEST_HAS_TYPED_TEST || GTEST_HAS_TYPED_TEST_P
 
",425,73
Makes gtest report failures in ad hoc test assertions executed before RUN_ALL_TESTS().," class GTEST_API_ UnitTestImpl {
 // doesn't apply there.)
 int RunAllTests();
 
- // Clears the results of all tests, including the ad hoc test.
- void ClearResult() {
+ // Clears the results of all tests, except the ad hoc tests.
+ void ClearNonAdHocTestResult() {
 ForEach(test_cases_, TestCase::ClearTestCaseResult);
+ }
+
+ // Clears the results of ad-hoc test assertions.
+ void ClearAdHocTestResult() {
 ad_hoc_test_result_.Clear();
 }
 
",465,85
Implements ReturnPointee() and ReturnRefOfCopy().," ACTION_TEMPLATE(DeleteArg,
 delete ::std::tr1::get<k>(args);
 }
 
+// This action returns the value pointed to by 'pointer'.
+ACTION_P(ReturnPointee, pointer) { return *pointer; }
+
 // Action Throw(exception) can be used in a mock function of any type
 // to throw the given exception. Any copyable value can be thrown.
 #if GTEST_HAS_EXCEPTIONS
",85,17
"Makes gtest_break_on_failure_unittest work on minGW (by vladl); improves
the NULL-dereferencing hack to work with LLVM (by chandlerc)."," void UnitTest::AddTestPartResult(TestPartResult::Type result_type,
 // the --gtest_catch_exceptions flags are specified.
 DebugBreak();
 #else
- *static_cast<int*>(NULL) = 1;
+ // Dereference NULL through a volatile pointer to prevent the compiler
+ // from removing. We use this rather than abort() or __builtin_trap() for
+ // portability: Symbian doesn't implement abort() well, and some debuggers
+ // don't correctly trap abort().
+ *static_cast<volatile int*>(NULL) = 1;
 #endif // GTEST_OS_WINDOWS
 } else if (GTEST_FLAG(throw_on_failure)) {
 #if GTEST_HAS_EXCEPTIONS
",2728,651
Fixes definitions from pthread.h used before the header inclusion.,"
 #define GTEST_HAS_PTHREAD (GTEST_OS_LINUX || GTEST_OS_MAC)
 #endif // GTEST_HAS_PTHREAD
 
+#if GTEST_HAS_PTHREAD
+// gtest-port.h guarantees to #include <pthread.h> when GTEST_HAS_PTHREAD is
+// true.
+#include <pthread.h>
+#endif
+
 // Determines whether Google Test can use tr1/tuple. You can define
 // this macro to 0 to prevent Google Test from using tuple (any
 // feature depending on tuple with be disabled in this mode).
 class ThreadWithParam : public ThreadWithParamBase {
 GTEST_DISALLOW_COPY_AND_ASSIGN_(ThreadWithParam);
 };
 
-// gtest-port.h guarantees to #include <pthread.h> when GTEST_HAS_PTHREAD is
-// true.
-#include <pthread.h>
-
 // MutexBase and Mutex implement mutex on pthreads-based platforms. They
 // are used in conjunction with class MutexLock:
 //
",420,106
Fixes warnings when built by GCC with -Wswitch-default. Original patch by Zhixu Liu (zhixu.liu@gmail.com).," GTEST_API_ bool ExitedUnsuccessfully(int exit_status);
 gtest_dt->Abort(::testing::internal::DeathTest::TEST_DID_NOT_DIE); \
 break; \
 } \
+ default: \
+ break; \
 } \
 } \
 } else \
",71,11
Removes unused scons scripts; picks up gtest r446.," Matcher<tuple<char, int> > LessThan() {
 
 TEST(ArgsTest, ExplainsMatchResultWithInnerExplanation) {
 const Matcher<tuple<char, int, int> > m = Args<0, 2>(LessThan());
- EXPECT_EQ(""whose fields (#0, #2) are ('a' (97), 42), ""
+ EXPECT_EQ(""whose fields (#0, #2) are ('a' (97, 0x61), 42), ""
 ""where the first value is 55 more than the second"",
 Explain(m, make_tuple('a', 42, 42)));
 EXPECT_EQ(""whose fields (#0, #2) are ('\\0', 43)"",
",793,130
Allows Google Test to build on OSes other then a pre-determined set and implements GTEST_HAS_POSIX_REGEX condition for compatibility with them.,"
 #include <limits.h>
 #include <stdlib.h>
 #include <stdio.h>
+#include <string.h>
 
 #if GTEST_OS_WINDOWS_MOBILE
 #include <windows.h> // For TerminateProcess()
",403,128
Adds ADD_FAILURE_AT (by Zhanyong Wan); disables -Wswitch-default (by Vlad Losev).," const T* TestWithParam<T>::parameter_ = NULL;
 // Generates a nonfatal failure with a generic message.
 #define ADD_FAILURE() GTEST_NONFATAL_FAILURE_(""Failed"")
 
+// Generates a nonfatal failure at the given source file location with
+// a generic message.
+#define ADD_FAILURE_AT(file, line) \
+ GTEST_MESSAGE_AT_(file, line, ""Failed"", \
+ ::testing::TestPartResult::kNonFatalFailure)
+
 // Generates a fatal failure with a generic message.
 #define GTEST_FAIL() GTEST_FATAL_FAILURE_(""Failed"")
 
",574,75
Makes gtest print enums as integers instead of hex dumps (by Zhanyong Wan); improves the hex dump format (by Zhanyong Wan); gets rid of class TestInfoImpl (by Zhanyong Wan); adds exception handling (by Vlad Losev).," void PrintByteSegmentInObjectTo(const unsigned char* obj_bytes, size_t start,
 if (i != 0) {
 // Organizes the bytes into groups of 2 for easy parsing by
 // human.
- if ((j % 2) == 0) {
- *os << "" "";
- }
+ if ((j % 2) == 0)
+ *os << ' ';
+ else
+ *os << '-';
 }
 snprintf(text, sizeof(text), ""%02X"", obj_bytes[j]);
 *os << text;
",189,48
Removes some gmock internal macros; sorts the file lists in Makefile.am; picks up gtest r454.," DoAll(Action1 a1, Action2 a2, Action3 a3, Action4 a4, Action5 a5, Action6 a6,
 
 // The name of the class template implementing the action template.
 #define GMOCK_ACTION_CLASS_(name, value_params)\
- GMOCK_CONCAT_TOKEN_(name##Action, GMOCK_INTERNAL_COUNT_##value_params)
+ GTEST_CONCAT_TOKEN_(name##Action, GMOCK_INTERNAL_COUNT_##value_params)
 
 #define ACTION_TEMPLATE(name, template_params, value_params)\
 template <GMOCK_INTERNAL_DECL_##template_params\
",829,100
Removes the Windows golden file (by Vlad Losev); implements test result streaming (by Nikhil Jindal and cleaned up by Zhanyong Wan).," GTEST_DECLARE_int32_(stack_trace_depth);
 // non-zero code otherwise.
 GTEST_DECLARE_bool_(throw_on_failure);
 
+// When this flag is set with a ""host:port"" string, on supported
+// platforms test results are streamed to the specified port on
+// the specified host machine.
+GTEST_DECLARE_string_(stream_result_to);
+
 // The upper limit for valid stack trace depths.
 const int kMaxStackTraceDepth = 100;
 
 class WindowsDeathTest;
 class UnitTestImpl* GetUnitTestImpl();
 void ReportFailureInUnknownLocation(TestPartResult::Type result_type,
 const String& message);
-class PrettyUnitTestResultPrinter;
-class XmlUnitTestResultPrinter;
 
 // Converts a streamable value to a String. A NULL pointer is
 // converted to ""(null)"". When the input value is a ::string,
",593,90
Casts char to unsigned char before calling isspace() etc to avoid undefined behavior (by Zhanyong Wan); removes conditional #includes keyed on GTEST_HAS_PROTOBUF_ (by Zhanyong Wan); publishes GTEST_HAS_STREAM_REDIRECTION (by Vlad Losev); forward declares some classes properly (by Samuel Benzaquen); honors the --gtest_catch_exceptions flag (by Vlad Losev).," String StreamableToString(const T& streamable) {
 
 } // namespace internal
 
+// The friend relationship of some of these classes is cyclic.
+// If we don't forward declare them the compiler might confuse the classes
+// in friendship clauses with same named classes on the scope.
+class Test;
+class TestCase;
+class TestInfo;
+class UnitTest;
+
 // A class for indicating whether an assertion was successful. When
 // the assertion wasn't successful, the AssertionResult object
 // remembers a non-empty message that describes how it failed.
",597,90
Publishes GTEST_HAS_STREAM_REDIRECTION (by Vlad Losev); casts char to unsigned char before calling isspace() etc to avoid undefined behavior (by Zhanyong Wan); fixes the VC projects (by Fredrik Roubert).," string ConvertIdentifierNameToWords(const char* id_name) {
 for (const char* p = id_name; *p != '\0'; prev_char = *(p++)) {
 // We don't care about the current locale as the input is
 // guaranteed to be a valid C++ identifier name.
- const bool starts_new_word = isupper(*p) ||
- (!isalpha(prev_char) && islower(*p)) ||
- (!isdigit(prev_char) && isdigit(*p));
+ const bool starts_new_word = IsUpper(*p) ||
+ (!IsAlpha(prev_char) && IsLower(*p)) ||
+ (!IsDigit(prev_char) && IsDigit(*p));
 
- if (isalnum(*p)) {
+ if (IsAlNum(*p)) {
 if (starts_new_word && result != """")
 result += ' ';
- result += static_cast<char>(tolower(*p));
+ result += ToLower(*p);
 }
 }
 return result;
",80,25
Removes all uses of StrStream; fixes the VC projects and simplifies them by using gtest-all.cc.," AssertionResult CmpHelperFloatingPointEQ(const char* expected_expression,
 return AssertionSuccess();
 }
 
- StrStream expected_ss;
+ ::std::stringstream expected_ss;
 expected_ss << std::setprecision(std::numeric_limits<RawType>::digits10 + 2)
 << expected;
 
- StrStream actual_ss;
+ ::std::stringstream actual_ss;
 actual_ss << std::setprecision(std::numeric_limits<RawType>::digits10 + 2)
 << actual;
 
 return EqFailure(expected_expression,
 actual_expression,
- StrStreamToString(&expected_ss),
- StrStreamToString(&actual_ss),
+ StringStreamToString(&expected_ss),
+ StringStreamToString(&actual_ss),
 false);
 }
 
",597,90
Include gtest headers as user headers instead of system headers.,"
 
 #include <limits>
 
-#include <gtest/internal/gtest-string.h>
-#include <gtest/internal/gtest-internal.h>
+#include ""gtest/internal/gtest-string.h""
+#include ""gtest/internal/gtest-internal.h""
 
 namespace testing {
 
",74,17
Include gtest and gmock headers as user headers instead of system headers.,"
 #include <errno.h>
 #endif
 
-#include <gmock/internal/gmock-internal-utils.h>
-#include <gmock/internal/gmock-port.h>
+#include ""gmock/internal/gmock-internal-utils.h""
+#include ""gmock/internal/gmock-port.h""
 
 namespace testing {
 
",535,93
Removes uses of deprecated AssertionFailure() API (by Vlad Losev).," AssertionResult CmpHelper##op_name(const char* expr1, const char* expr2, \
 if (val1 op val2) {\
 return AssertionSuccess();\
 } else {\
- Message msg;\
- msg << ""Expected: ("" << expr1 << "") "" #op "" ("" << expr2\
+ return AssertionFailure() \
+ << ""Expected: ("" << expr1 << "") "" #op "" ("" << expr2\
 << ""), actual: "" << FormatForComparisonFailureMessage(val1, val2)\
 << "" vs "" << FormatForComparisonFailureMessage(val2, val1);\
- return AssertionFailure(msg);\
 }\
 }\
 GTEST_API_ AssertionResult CmpHelper##op_name(\
",597,90
Adds SetArgPointee to replace SetArgumentPointee.," inline internal::DoDefaultAction DoDefault() {
 // Creates an action that sets the variable pointed by the N-th
 // (0-based) function argument to 'value'.
 template <size_t N, typename T>
+PolymorphicAction<
+ internal::SetArgumentPointeeAction<
+ N, T, internal::IsAProtocolMessage<T>::value> >
+SetArgPointee(const T& x) {
+ return MakePolymorphicAction(internal::SetArgumentPointeeAction<
+ N, T, internal::IsAProtocolMessage<T>::value>(x));
+}
+// The following version is DEPRECATED.
+template <size_t N, typename T>
 PolymorphicAction<
 internal::SetArgumentPointeeAction<
 N, T, internal::IsAProtocolMessage<T>::value> >
",543,94
Makes gtest wokr on MinGW (by Vlad Losev); removes unused linked_ptr::release() method (by Zhanyong Wan).," class linked_ptr {
 T* get() const { return value_; }
 T* operator->() const { return value_; }
 T& operator*() const { return *value_; }
- // Release ownership of the pointed object and returns it.
- // Sole ownership by this linked_ptr object is required.
- T* release() {
- bool last = link_.depart();
- assert(last);
- T* v = value_;
- value_ = NULL;
- return v;
- }
 
 bool operator==(T* p) const { return value_ == p; }
 bool operator!=(T* p) const { return value_ != p; }
",103,29
Adds a missing #include (by Vlad Losev).,"
 
 #include ""gtest/gtest-spi.h""
 #include ""gtest/gtest-message.h""
+#include ""gtest/internal/gtest-internal.h""
 #include ""gtest/internal/gtest-string.h""
 
 // Indicates that this translation unit is part of Google Test's
",404,128
Adds action SaveArgPointee.,"
 #ifndef GMOCK_INCLUDE_GMOCK_GMOCK_MORE_ACTIONS_H_
 #define GMOCK_INCLUDE_GMOCK_GMOCK_MORE_ACTIONS_H_
 
+#include <algorithm>
+
 #include ""gmock/gmock-generated-actions.h""
 
 namespace testing {
 ACTION_TEMPLATE(SaveArg,
 *pointer = ::std::tr1::get<k>(args);
 }
 
+// Action SaveArgPointee<k>(pointer) saves the value pointed to
+// by the k-th (0-based) argument of the mock function to *pointer.
+ACTION_TEMPLATE(SaveArgPointee,
+ HAS_1_TEMPLATE_PARAMS(int, k),
+ AND_1_VALUE_PARAMS(pointer)) {
+ *pointer = *::std::tr1::get<k>(args);
+}
+
 // Action SetArgReferee<k>(value) assigns 'value' to the variable
 // referenced by the k-th (0-based) argument of the mock function.
 ACTION_TEMPLATE(SetArgReferee,
",91,18
Modifies handling of C++ exceptions in death tests to treat exceptions escaping them as failures.," TEST_F(TestForDeathTest, SingleEvaluation) {
 }
 
 // Tests that run-away death tests are reported as failures.
-TEST_F(TestForDeathTest, Runaway) {
+TEST_F(TestForDeathTest, RunawayIsFailure) {
 EXPECT_NONFATAL_FAILURE(EXPECT_DEATH(static_cast<void>(0), ""Foo""),
 ""failed to die."");
+}
 
+// Tests that death tests report executing 'return' in the statement as
+// failure.
+TEST_F(TestForDeathTest, ReturnIsFailure) {
 EXPECT_FATAL_FAILURE(ASSERT_DEATH(return, ""Bar""),
 ""illegal return in test statement."");
 }
 
-
 // Tests that EXPECT_DEBUG_DEATH works as expected,
 // that is, in debug mode, it:
 // 1. Asserts on death.
",750,133
Fixes compiler warning when built with -std=c++0x.," enum TypeKind {
 kProtobuf, // a protobuf type
 kConvertibleToInteger, // a type implicitly convertible to BiggestInt
 // (e.g. a named or unnamed enum type)
- kOtherType, // anything else
+ kOtherType // anything else
 };
 
 // TypeWithoutFormatter<T, kTypeKind>::PrintValue(value, os) is called
",350,64
Changes default of --gtest_catch_exceptions to true.," GTEST_DEFINE_bool_(
 
 GTEST_DEFINE_bool_(
 catch_exceptions,
- internal::BoolFromGTestEnv(""catch_exceptions"", false),
+ internal::BoolFromGTestEnv(""catch_exceptions"", true),
 ""True iff "" GTEST_NAME_
 "" should catch exceptions and treat them as test failures."");
 
 static const char kColorEncodedHelpMessage[] =
 "" Turn assertion failures into debugger break-points.\n""
 "" @G--"" GTEST_FLAG_PREFIX_ ""throw_on_failure@D\n""
 "" Turn assertion failures into C++ exceptions.\n""
-"" @G--"" GTEST_FLAG_PREFIX_ ""catch_exceptions@D\n""
-"" Suppress pop-ups caused by exceptions.\n""
+"" @G--"" GTEST_FLAG_PREFIX_ ""catch_exceptions=0@D\n""
+"" Do not report exceptions as test failures. Instead, allow them\n""
+"" to crash the program or throw a pop-up (on Windows).\n""
 ""\n""
 ""Except for @G--"" GTEST_FLAG_PREFIX_ ""list_tests@D, you can alternatively set ""
 ""the corresponding\n""
",2831,709
Adds comment clarifying the use of default-constructed matchers.," class MatcherBase {
 template <typename T>
 class Matcher : public internal::MatcherBase<T> {
 public:
- // Constructs a null matcher. Needed for storing Matcher objects in
- // STL containers.
+ // Constructs a null matcher. Needed for storing Matcher objects in STL
+ // containers. A default-constructed matcher is not yet initialized. You
+ // cannot use it until a valid value has been assigned to it.
 Matcher() {}
 
 // Constructs a matcher from its implementation.
",1770,356
Adds Google Native Client compatibility (issue 329).,"
 // GTEST_OS_CYGWIN - Cygwin
 // GTEST_OS_LINUX - Linux
 // GTEST_OS_MAC - Mac OS X
+// GTEST_OS_NACL - Google Native Client (NaCl)
 // GTEST_OS_SOLARIS - Sun Solaris
 // GTEST_OS_SYMBIAN - Symbian
 // GTEST_OS_WINDOWS - Windows (Desktop, MinGW, or Mobile)

 #define GTEST_OS_SOLARIS 1
 #elif defined(_AIX)
 #define GTEST_OS_AIX 1
+#elif defined __native_client__
+#define GTEST_OS_NACL 1
 #endif // __CYGWIN__
 
 // Brings in definitions for functions used in the testing::internal::posix

 // is not the case, we need to include headers that provide the functions
 // mentioned above.
 #include <unistd.h>
-#include <strings.h>
+#if !GTEST_OS_NACL
+// TODO(vladl@google.com): Remove this condition when Native Client SDK adds
+// strings.h (tracked in
+// http://code.google.com/p/nativeclient/issues/detail?id=1175).
+#include <strings.h> // Native Client doesn't provide strings.h.
+#endif
 #elif !GTEST_OS_WINDOWS_MOBILE
 #include <direct.h>
 #include <io.h>
",444,114
Makes gtest print string literals correctly when it contains \x escape sequences. Contributed by Yair Chuchem.," inline bool IsSpace(char ch) {
 inline bool IsUpper(char ch) {
 return isupper(static_cast<unsigned char>(ch)) != 0;
 }
+inline bool IsXDigit(char ch) {
+ return isxdigit(static_cast<unsigned char>(ch)) != 0;
+}
 
 inline char ToLower(char ch) {
 return static_cast<char>(tolower(static_cast<unsigned char>(ch)));
",447,115
Enables SetArgPointee<>() to accept a string literal; removes a self-assignment warning; teaches gmock doctor to diagnose TTB with Clang; picks up gtest r525.," SetArgPointee(const T& x) {
 return MakePolymorphicAction(internal::SetArgumentPointeeAction<
 N, T, internal::IsAProtocolMessage<T>::value>(x));
 }
+// This overload allows SetArgPointee() to accept a string literal.
+template <size_t N>
+PolymorphicAction<
+ internal::SetArgumentPointeeAction<N, const char*, false> >
+SetArgPointee(const char* p) {
+ return MakePolymorphicAction(internal::SetArgumentPointeeAction<
+ N, const char*, false>(p));
+}
 // The following version is DEPRECATED.
 template <size_t N, typename T>
 PolymorphicAction<
",550,95
Suppresses self-assignment warnings.," class LinkedPtrTest : public testing::Test {
 TEST_F(LinkedPtrTest, GeneralTest) {
 {
 linked_ptr<A> a0, a1, a2;
- a0 = a0;
+ // Use explicit function call notation here to suppress self-assign warning.
+ a0.operator=(a0);
 a1 = a2;
 ASSERT_EQ(a0.get(), static_cast<A*>(NULL));
 ASSERT_EQ(a1.get(), static_cast<A*>(NULL));
",105,9
Fixes GCC 4.6 warnings (patch by Jeffrey Yasskin).," typedef char IsNotContainer;
 template <class C>
 IsNotContainer IsContainerTest(...) { return '\0'; }
 
+// EnableIf<condition>::type is void when 'Cond' is true, and
+// undefined when 'Cond' is false. To use SFINAE to make a function
+// overload only apply when a particular expression is true, add
+// ""typename EnableIf<expression>::type* = 0"" as the last parameter.
+template<bool> struct EnableIf;
+template<> struct EnableIf<true> { typedef void type; }; // NOLINT
+
 // Utilities for native arrays.
 
 // ArrayEq() compares two k-dimensional native arrays using the
 class GTEST_TEST_CLASS_NAME_(test_case_name, test_name) : public parent_class {\
 GTEST_TEST_CLASS_NAME_(test_case_name, test_name)() {}\
 private:\
 virtual void TestBody();\
- static ::testing::TestInfo* const test_info_;\
+ static ::testing::TestInfo* const test_info_ GTEST_ATTRIBUTE_UNUSED_;\
 GTEST_DISALLOW_COPY_AND_ASSIGN_(\
 GTEST_TEST_CLASS_NAME_(test_case_name, test_name));\
 };\
",408,68
Renames some internal functions to avoid name clashes.," void PrintTo(const char* s, ostream* os) {
 if (s == NULL) {
 *os << ""NULL"";
 } else {
- *os << implicit_cast<const void*>(s) << "" pointing to "";
+ *os << ImplicitCast_<const void*>(s) << "" pointing to "";
 PrintCharsAsStringTo(s, strlen(s), os);
 }
 }
 void PrintTo(const wchar_t* s, ostream* os) {
 if (s == NULL) {
 *os << ""NULL"";
 } else {
- *os << implicit_cast<const void*>(s) << "" pointing to "";
+ *os << ImplicitCast_<const void*>(s) << "" pointing to "";
 PrintWideCharsAsStringTo(s, wcslen(s), os);
 }
 }
",200,54
Picks up gtest r536; renames implicit_cast and down_cast to reduce the chance of clash (by Roman Perepelitsa); enables gmock_gen.py to handle storage specifiers (by Steve Fox).," class ReturnAction {
 // single-argument constructor (e.g. Result is std::vector<int>) and R
 // has a type conversion operator template. In that case, value_(value)
 // won't compile as the compiler doesn't known which constructor of
- // Result to call. implicit_cast forces the compiler to convert R to
+ // Result to call. ImplicitCast_ forces the compiler to convert R to
 // Result without considering explicit constructors, thus resolving the
 // ambiguity. value_ is then initialized using its copy constructor.
 explicit Impl(R value)
- : value_(::testing::internal::implicit_cast<Result>(value)) {}
+ : value_(::testing::internal::ImplicitCast_<Result>(value)) {}
 
 virtual Result Perform(const ArgumentTuple&) { return value_; }
 
",550,95
"Adds type_param and value_param as <testcase> attributes to the XML
report; also removes the comment() and test_case_comment() fields of
TestInfo. Proposed and initally implemented by Joey Oravec.
Re-implemented by Vlad Losev."," class ParameterizedTestCaseInfo : public ParameterizedTestCaseInfoBase {
 param_it != generator.end(); ++param_it, ++i) {
 Message test_name_stream;
 test_name_stream << test_info->test_base_name.c_str() << ""/"" << i;
- std::string comment = ""GetParam() = "" + PrintToString(*param_it);
 MakeAndRegisterTestInfo(
 test_case_name_stream.GetString().c_str(),
 test_name_stream.GetString().c_str(),
- """", // test_case_comment
- comment.c_str(),
+ NULL, // No type parameter.
+ PrintToString(*param_it).c_str(),
 GetTestCaseTypeId(),
 TestCase::SetUpTestCase,
 TestCase::TearDownTestCase,
",364,73
Removes unused include directive.,"
 
 #include <string.h> // For strcmp.
 #include <algorithm>
-#include <sstream>
 
 using ::testing::InitGoogleTest;
 
",224,22
Adds null check for file locations in XML output printer.," GTEST_API_ AssertionResult IsHRESULTFailure(const char* expr,
 
 #endif // GTEST_OS_WINDOWS
 
-// Formats a source file path and a line number as they would appear
-// in a compiler error message.
-inline String FormatFileLocation(const char* file, int line) {
- const char* const file_name = file == NULL ? ""unknown file"" : file;
- if (line < 0) {
- return String::Format(""%s:"", file_name);
- }
-#ifdef _MSC_VER
- return String::Format(""%s(%d):"", file_name, line);
-#else
- return String::Format(""%s:%d:"", file_name, line);
-#endif // _MSC_VER
-}
-
 // Types of SetUpTestCase() and TearDownTestCase() functions.
 typedef void (*SetUpTestCaseFunc)();
 typedef void (*TearDownTestCaseFunc)();
",401,64
Updates an outdated error message.," def GetTestExecutablePath(executable_name, build_dir=None):
 message = (
 'Unable to find the test binary. Please make sure to provide path\n'
 'to the binary via the --build_dir flag or the BUILD_DIR\n'
- 'environment variable. For convenient use, invoke this script via\n'
- 'mk_test.py.\n'
- # TODO(vladl@google.com): change mk_test.py to test.py after renaming
- # the file.
- 'Please run mk_test.py -h for help.')
+ 'environment variable.')
 print >> sys.stderr, message
 sys.exit(1)
 
",129,36
Improves cross-platform compatibility of gmock output. This fixes issue 135.," class ExpectationBase {
 
 // Describes the source file location of this expectation.
 void DescribeLocationTo(::std::ostream* os) const {
- *os << file() << "":"" << line() << "": "";
+ *os << FormatFileLocation(file(), line()) << "" "";
 }
 
 // Describes how many times a function call matching this
 class FunctionMockerBase : public UntypedFunctionMockerBase {
 ""returning default value.\n"");
 } else {
 *os << ""taking default action specified at:\n""
- << spec->file() << "":"" << spec->line() << "":\n"";
+ << FormatFileLocation(spec->file(), spec->line()) << ""\n"";
 }
 }
 
",954,182
Fixes off-by-one error in a message about test sharding (by David Glasser).," void PrettyUnitTestResultPrinter::OnTestIterationStart(
 }
 
 if (internal::ShouldShard(kTestTotalShards, kTestShardIndex, false)) {
+ const Int32 shard_index = Int32FromEnvOrDie(kTestShardIndex, -1);
 ColoredPrintf(COLOR_YELLOW,
- ""Note: This is test shard %s of %s.\n"",
- internal::posix::GetEnv(kTestShardIndex),
+ ""Note: This is test shard %d of %s.\n"",
+ static_cast<int>(shard_index) + 1,
 internal::posix::GetEnv(kTestTotalShards));
 }
 
",2848,712
Indents preprocessor directives.," class GTEST_API_ Message {
 }
 
 private:
+
 #if GTEST_OS_SYMBIAN
 // These are needed as the Nokia Symbian Compiler cannot decide between
 // const T& and const T* in a function template. The Nokia compiler _can_
",74,17
Makes Google Mock compile much faster and use much less memory; reviewed by Nico Weber. This fixes issue 68.," def _IncompleteByReferenceArgumentDiagnoser(msg):
 r'(.*\n)*?' +
 _CLANG_NON_GMOCK_FILE_LINE_RE +
 r'note: in instantiation of member function '
- r'\'testing::internal::FunctionMocker<.*>::Invoke\' '
- r'requested here')
+ r'\'testing::internal2::TypeWithoutFormatter<.*>::'
+ r'PrintValue\' requested here')
 diagnosis = """"""
 In order to mock this function, Google Mock needs to see the definition
 of type ""%(type)s"" - declaration alone is not enough. Either #include
",474,30
Fixes PrintUnprintableTypeTest.InGlobalNamespace in gtest-printers_test on 64bit PowerPCs.," TEST(PrintTupleTest, NestedTuple) {
 // Unprintable types in the global namespace.
 TEST(PrintUnprintableTypeTest, InGlobalNamespace) {
 EXPECT_EQ(""1-byte object <00>"",
- Print(UnprintableTemplateInGlobal<bool>()));
+ Print(UnprintableTemplateInGlobal<char>()));
 }
 
 // Unprintable types in a user namespace.
",851,138
"Fixes non-conforming uses of commas in enums s.t. the code compiles on
Sun OS. Patch by Hady Zalek."," enum EnumWithoutPrinter {
 
 // An enum with a << operator.
 enum EnumWithStreaming {
- kEWS1 = 10,
+ kEWS1 = 10
 };
 
 std::ostream& operator<<(std::ostream& os, EnumWithStreaming e) {
 std::ostream& operator<<(std::ostream& os, EnumWithStreaming e) {
 
 // An enum with a PrintTo() function.
 enum EnumWithPrintTo {
- kEWPT1 = 1,
+ kEWPT1 = 1
 };
 
 void PrintTo(EnumWithPrintTo e, std::ostream* os) {
",851,138
"Fixes compatibility with Borland C++Builder. Original patch by Josh
Kelley. Simplified by Zhanyong Wan."," namespace internal {
 template <typename T1, typename T2>
 String FormatForComparisonFailureMessage(const T1& value,
 const T2& /* other_operand */) {
- return PrintToString(value);
+ // C++Builder compiles this incorrectly if the namespace isn't explicitly
+ // given.
+ return ::testing::PrintToString(value);
 }
 
 // The helper function for {ASSERT|EXPECT}_EQ.
",621,95
"Makes IsContainerTest compatible with Sun C++ and Visual Age C++, based on Hady Zalek's report and experiment; also fixes a bug that causes it to think that a class named const_iterator is a container; also clarifies the Borland C++ compatibility fix in the comments based on Josh Kelley's suggestion."," struct TuplePrefixPrinter<0> {
 // We have to specialize the entire TuplePrefixPrinter<> class
 // template here, even though the definition of
 // TersePrintPrefixToStrings() is the same as the generic version, as
-// Borland C++ doesn't support specializing a method.
+// Embarcadero (formerly CodeGear, formerly Borland) C++ doesn't
+// support specializing a method template of a class template.
 template <>
 struct TuplePrefixPrinter<1> {
 template <typename Tuple>
",358,65
"Fixes compatibility with Sun C++ (by Hady Zalek); fixes compatibility
with Android (by Zachary Vorhies)."," struct RemoveConst { typedef T type; }; // NOLINT
 template <typename T>
 struct RemoveConst<const T> { typedef T type; }; // NOLINT
 
-// MSVC 8.0 has a bug which causes the above definition to fail to
-// remove the const in 'const int[3]'. The following specialization
-// works around the bug. However, it causes trouble with gcc and thus
-// needs to be conditionally compiled.
-#ifdef _MSC_VER
+// MSVC 8.0 and Sun C++ have a bug which causes the above definition
+// to fail to remove the const in 'const int[3]'. The following
+// specialization works around the bug. However, it causes trouble
+// with GCC and thus needs to be conditionally compiled.
+#if defined(_MSC_VER) || defined(__SUNPRO_CC)
 template <typename T, size_t N>
 struct RemoveConst<T[N]> {
 typedef typename RemoveConst<T>::type type[N];
 };
-#endif // _MSC_VER
+#endif
 
 // A handy wrapper around RemoveConst that works when the argument
 // T depends on template parameters.
",407,64
Fixes Google Mock Doctor affected by the latest tweaks to Clang.," def _TypeInTemplatedBaseDiagnoser(msg):
 _CLANG_FILE_LINE_RE +
 r'error: use of undeclared identifier \'(?P<type>.*)\'\n'
 r'(.*\n)*?'
- r'(?P=file):(?P=line):(?P=column): error: '
+ r'(?P=file):(?P=line):\d+: error: '
 r'non-friend class member \'Result\' cannot have a qualified name'
 )
 clang_regex_type_of_a_param = (
",474,30
Fixes Windows CE compatibility problem (issue http://code.google.com/p/googletest/issues/detail?id=362).," class ParameterizedTestCaseRegistry {
 // and terminate the program since we cannot guaranty correct
 // test case setup and tear-down in this case.
 ReportInvalidTestCaseType(test_case_name, file, line);
- abort();
+ posix::Abort();
 } else {
 // At this point we are sure that the object we found is of the same
 // type we are looking for, so we downcast it to that type
",364,73
Changes diagnostic output of the question mark from '\?' to '?'.," static CharFormat PrintAsCharLiteralTo(Char c, ostream* os) {
 case L'\'':
 *os << ""\\'"";
 break;
- case L'\?':
- *os << ""\\?"";
- break;
 case L'\\':
 *os << ""\\\\"";
 break;
",197,53
makes gtest compatible with HP UX (by Pasi Valminen); fixes a typo in the name of xlC (by Hady Zalek).,"
 // libstdc++ (which is where cxxabi.h comes from).
 # ifdef __GLIBCXX__
 # include <cxxabi.h>
+# elif defined(__HP_aCC)
+# include <acxx_demangle.h>
 # endif // __GLIBCXX__
 
 namespace testing {
 String GetTypeName() {
 # if GTEST_HAS_RTTI
 
 const char* const name = typeid(T).name();
-# ifdef __GLIBCXX__
+# if defined(__GLIBCXX__) || defined(__HP_aCC)
 int status = 0;
 // gcc's implementation of typeid(T).name() mangles the type name,
 // so we have to demangle it.
- char* const readable_name = abi::__cxa_demangle(name, 0, 0, &status);
+# ifdef __GLIBCXX__
+ using abi::__cxa_demangle;
+# endif // __GLIBCXX__
+ char* const readable_name = __cxa_demangle(name, 0, 0, &status);
 const String name_str(status == 0 ? readable_name : name);
 free(readable_name);
 return name_str;
 # else
 return name;
-# endif // __GLIBCXX__
+# endif // __GLIBCXX__ || __HP_aCC
 
 # else
 
",3062,5
Removes commas from last items in enums (a C++ standard compliance fix).," enum {
 
 # endif // GTEST_OS_LINUX
 
- kCaseC = 42,
+ kCaseC = 42
 };
 
 TEST(AssertionTest, AnonymousEnum) {
",4823,670
Fixes a compiler error when compiling with Visual Age (by Hady Zalek).," enum CharFormat {
 // Returns true if c is a printable ASCII character. We test the
 // value of c directly instead of calling isprint(), which is buggy on
 // Windows Mobile.
-static inline bool IsPrintableAscii(wchar_t c) {
+inline bool IsPrintableAscii(wchar_t c) {
 return 0x20 <= c && c <= 0x7E;
 }
 
",197,53
fixes XL C++ compiler errors (by Pasi Valminen)," struct RemoveConst { typedef T type; }; // NOLINT
 template <typename T>
 struct RemoveConst<const T> { typedef T type; }; // NOLINT
 
-// MSVC 8.0 and Sun C++ have a bug which causes the above definition
-// to fail to remove the const in 'const int[3]'. The following
-// specialization works around the bug. However, it causes trouble
-// with GCC and thus needs to be conditionally compiled.
-#if defined(_MSC_VER) || defined(__SUNPRO_CC)
+// MSVC 8.0, Sun C++, and IBM XL C++ have a bug which causes the above
+// definition to fail to remove the const in 'const int[3]' and 'const
+// char[3][4]'. The following specialization works around the bug.
+// However, it causes trouble with GCC and thus needs to be
+// conditionally compiled.
+#if defined(_MSC_VER) || defined(__SUNPRO_CC) || defined(__IBMCPP__)
 template <typename T, size_t N>
-struct RemoveConst<T[N]> {
+struct RemoveConst<const T[N]> {
 typedef typename RemoveConst<T>::type type[N];
 };
 #endif
",407,64
Simplifies ASCII character detection in gtest-printers.h. This also makes it possible to build Google Test on MinGW.," static void PrintWideCharsAsStringTo(const wchar_t* begin, size_t len,
 bool is_previous_hex = false;
 for (size_t index = 0; index < len; ++index) {
 const wchar_t cur = begin[index];
- if (is_previous_hex && 0 <= cur && cur < 128 &&
- IsXDigit(static_cast<char>(cur))) {
+ if (is_previous_hex && isascii(cur) && IsXDigit(static_cast<char>(cur))) {
 // Previous character is of '\x..' form and this character can be
 // interpreted as another hexadecimal digit in its number. Break string to
 // disambiguate.
",196,52
"Avoids iterator_traits, as it's not available in libCStd when compiled with Sun C++."," internal::ParamGenerator<T> Range(T start, T end) {
 //
 template <typename ForwardIterator>
 internal::ParamGenerator<
- typename ::std::iterator_traits<ForwardIterator>::value_type> ValuesIn(
- ForwardIterator begin,
- ForwardIterator end) {
- typedef typename ::std::iterator_traits<ForwardIterator>::value_type
- ParamType;
+ typename ::testing::internal::IteratorTraits<ForwardIterator>::value_type>
+ValuesIn(ForwardIterator begin, ForwardIterator end) {
+ typedef typename ::testing::internal::IteratorTraits<ForwardIterator>
+ ::value_type ParamType;
 return internal::ParamGenerator<ParamType>(
 new internal::ValuesInIteratorRangeGenerator<ParamType>(begin, end));
 }
",958,69
Fixes Sun C++ compiler errors (by Pasi Valminen)," GTEST_API_ bool ShouldRunTestOnShard(
 // the given predicate.
 template <class Container, typename Predicate>
 inline int CountIf(const Container& c, Predicate predicate) {
- return static_cast<int>(std::count_if(c.begin(), c.end(), predicate));
+ // Implemented as an explicit loop since std::count_if() in libCstd on
+ // Solaris has a non-standard signature.
+ int count = 0;
+ for (typename Container::const_iterator it = c.begin(); it != c.end(); ++it) {
+ if (predicate(*it))
+ ++count;
+ }
+ return count;
 }
 
 // Applies a function/functor to each element in the container.
",439,74
Corrects condition to compile out MSVC's pragmas. This fixes the build on MinGW.," class TrulyMatcher {
 template <typename T>
 bool MatchAndExplain(T& x, // NOLINT
 MatchResultListener* /* listener */) const {
-#if GTEST_OS_WINDOWS
+#if _MSC_VER
 // MSVC warns about converting a value into bool (warning 4800).
 # pragma warning(push) // Saves the current warning state.
 # pragma warning(disable:4800) // Temporarily disables warning 4800.
-#endif // GTEST_OS_WINDOWS
+#endif
 return predicate_(x);
-#if GTEST_OS_WINDOWS
+#if _MSC_VER
 # pragma warning(pop) // Restores the warning state.
-#endif // GTEST_OS_WINDOWS
+#endif
 }
 
 void DescribeTo(::std::ostream* os) const {
",1770,356
Updates conditional directives to be consistent with the rest of the project.," class TrulyMatcher {
 template <typename T>
 bool MatchAndExplain(T& x, // NOLINT
 MatchResultListener* /* listener */) const {
-#if _MSC_VER
+#ifdef _MSC_VER
 // MSVC warns about converting a value into bool (warning 4800).
 # pragma warning(push) // Saves the current warning state.
 # pragma warning(disable:4800) // Temporarily disables warning 4800.
 #endif
 return predicate_(x);
-#if _MSC_VER
+#ifdef _MSC_VER
 # pragma warning(pop) // Restores the warning state.
 #endif
 }
",1770,356
fixes a problem caused by gcc 4.6 optimization (by Paul Pluzhnikov),"
 # define GTEST_API_
 #endif
 
+#if defined(__GNUC__)
+// Ask the compiler to never inline a given function.
+#define GTEST_NO_INLINE_ __attribute__((noinline))
+#else
+#define GTEST_NO_INLINE_
+#endif // __GNUC__
+
 namespace testing {
 
 class Message;
",462,115
simplifies TrulyMatcher and adds a test for it," class TrulyMatcher {
 template <typename T>
 bool MatchAndExplain(T& x, // NOLINT
 MatchResultListener* /* listener */) const {
-#ifdef _MSC_VER
- // MSVC warns about converting a value into bool (warning 4800).
-# pragma warning(push) // Saves the current warning state.
-# pragma warning(disable:4800) // Temporarily disables warning 4800.
-#endif
- return predicate_(x);
-#ifdef _MSC_VER
-# pragma warning(pop) // Restores the warning state.
-#endif
+ // Without the if-statement, MSVC sometimes warns about converting
+ // a value to bool (warning 4800).
+ //
+ // We cannot write 'return !!predicate_(x);' as that doesn't work
+ // when predicate_(x) returns a class convertible to bool but
+ // having no operator!().
+ if (predicate_(x))
+ return true;
+ return false;
 }
 
 void DescribeTo(::std::ostream* os) const {
",1772,355
Fixes XL C++ 10.1 compiler errors (based on patch by Hady Zalek); cleans up formatting of GTEST_NO_INLINE_.,"
 # define GTEST_API_
 #endif
 
-#if defined(__GNUC__)
+#ifdef __GNUC__
 // Ask the compiler to never inline a given function.
-#define GTEST_NO_INLINE_ __attribute__((noinline))
+# define GTEST_NO_INLINE_ __attribute__((noinline))
 #else
-#define GTEST_NO_INLINE_
-#endif // __GNUC__
+# define GTEST_NO_INLINE_
+#endif
 
 namespace testing {
 
",462,115
Adds support for death tests in OpenBSD (by Pawe Hajdan Jr.),"
 // GTEST_OS_LINUX_ANDROID - Google Android
 // GTEST_OS_MAC - Mac OS X
 // GTEST_OS_NACL - Google Native Client (NaCl)
+// GTEST_OS_OPENBSD - OpenBSD
 // GTEST_OS_SOLARIS - Sun Solaris
 // GTEST_OS_SYMBIAN - Symbian
 // GTEST_OS_WINDOWS - Windows (Desktop, MinGW, or Mobile)

 # define GTEST_OS_HPUX 1
 #elif defined __native_client__
 # define GTEST_OS_NACL 1
+#elif defined __OpenBSD__
+# define GTEST_OS_OPENBSD 1
 #endif // __CYGWIN__
 
 // Brings in definitions for functions used in the testing::internal::posix

 // pops up a dialog window that cannot be suppressed programmatically.
 #if (GTEST_OS_LINUX || GTEST_OS_MAC || GTEST_OS_CYGWIN || GTEST_OS_SOLARIS || \
 (GTEST_OS_WINDOWS_DESKTOP && _MSC_VER >= 1400) || \
- GTEST_OS_WINDOWS_MINGW || GTEST_OS_AIX || GTEST_OS_HPUX)
+ GTEST_OS_WINDOWS_MINGW || GTEST_OS_AIX || GTEST_OS_HPUX || \
+ GTEST_OS_OPENBSD)
 # define GTEST_HAS_DEATH_TEST 1
 # include <vector> // NOLINT
 #endif
",462,115
Simplifies the code by removing condfitional section that is no longer necessary.," struct RemoveConst<const T> { typedef T type; }; // NOLINT
 // MSVC 8.0, Sun C++, and IBM XL C++ have a bug which causes the above
 // definition to fail to remove the const in 'const int[3]' and 'const
 // char[3][4]'. The following specialization works around the bug.
-// However, it causes trouble with GCC and thus needs to be
-// conditionally compiled.
-#if defined(_MSC_VER) || defined(__SUNPRO_CC) || defined(__IBMCPP__)
 template <typename T, size_t N>
 struct RemoveConst<const T[N]> {
 typedef typename RemoveConst<T>::type type[N];
 };
-#endif
 
 // A handy wrapper around RemoveConst that works when the argument
 // T depends on template parameters.
",407,64
Adds support for building Google Mock as a shared library (DLL).," class TestInfoImpl; // Opaque implementation of TestInfo
 class UnitTestImpl; // Opaque implementation of UnitTest
 
 // How many times InitGoogleTest() has been called.
-extern int g_init_gtest_count;
+GTEST_API_ extern int g_init_gtest_count;
 
 // The text used in failure messages to indicate the start of the
 // stack trace.
",407,64
Fixes broken build on VC++ 7.1.," inline void UniversalTersePrint(char* str, ::std::ostream* os) {
 // NUL-terminated string.
 template <typename T>
 void UniversalPrint(const T& value, ::std::ostream* os) {
- UniversalPrinter<T>::Print(value, os);
+ // A workarond for the bug in VC++ 7.1 that prevents us from instantiating
+ // UniversalPrinter with T directly.
+ typedef T T1;
+ UniversalPrinter<T1>::Print(value, os);
 }
 
 #if GTEST_HAS_TR1_TUPLE
",359,65
Suppresses the tail-call optimization of StackGrowsDown() in GCC4.6 (by Paul Pluzhnikov).," static int ExecDeathTestChildMain(void* child_arg) {
 // GTEST_NO_INLINE_ is required to prevent GCC 4.6 from inlining
 // StackLowerThanAddress into StackGrowsDown, which then doesn't give
 // correct answer.
-bool StackLowerThanAddress(const void* ptr) GTEST_NO_INLINE_;
-bool StackLowerThanAddress(const void* ptr) {
+void StackLowerThanAddress(const void* ptr, bool* result) GTEST_NO_INLINE_;
+void StackLowerThanAddress(const void* ptr, bool* result) {
 int dummy;
- return &dummy < ptr;
+ *result = (&dummy < ptr);
 }
 
 bool StackGrowsDown() {
 int dummy;
- return StackLowerThanAddress(&dummy);
+ bool result;
+ StackLowerThanAddress(&dummy, &result);
+ return result;
 }
 
 // A threadsafe implementation of fork(2) for threadsafe-style death tests
",713,136
QNX compatibility patch (by Haruka Iwao).,"
 # include <mach/vm_map.h>
 #endif // GTEST_OS_MAC
 
+#if GTEST_OS_QNX
+# include <devctl.h>
+# include <sys/procfs.h>
+#endif // GTEST_OS_QNX
+
 #include ""gtest/gtest-spi.h""
 #include ""gtest/gtest-message.h""
 #include ""gtest/internal/gtest-internal.h""
 size_t GetThreadCount() {
 }
 }
 
+#elif GTEST_OS_QNX
+
+// Returns the number of threads running in the process, or 0 to indicate that
+// we cannot detect it.
+size_t GetThreadCount() {
+ const int fd = open(""/proc/self/as"", O_RDONLY);
+ if (fd < 0) {
+ return 0;
+ }
+ procfs_info process_info;
+ const int status =
+ devctl(fd, DCMD_PROC_INFO, &process_info, sizeof(process_info), NULL);
+ close(fd);
+ if (status == EOK) {
+ return static_cast<size_t>(process_info.num_threads);
+ } else {
+ return 0;
+ }
+}
+
 #else
 
 size_t GetThreadCount() {
",438,138
Fixes a resource leak in gtest-port_test (by Haruka Iwao).," class AtomicCounterWithMutex {
 SleepMilliseconds(random_.Generate(30));
 
 GTEST_CHECK_POSIX_SUCCESS_(pthread_mutex_unlock(&memory_barrier_mutex));
+ GTEST_CHECK_POSIX_SUCCESS_(pthread_mutex_destroy(&memory_barrier_mutex));
 }
 value_ = temp + 1;
 }
",858,139
Fixes a user reported test break (modifying a dict while iterating).,"
 # define GTEST_NO_INLINE_
 #endif
 
+// _LIBCPP_VERSION is defined by the libc++ library from the LLVM project.
+#if defined(__GLIBCXX__) || defined(_LIBCPP_VERSION)
+# define GTEST_HAS_CXXABI_H_ 1
+#else
+# define GTEST_HAS_CXXABI_H_ 0
+#endif
+
 namespace testing {
 
 class Message;
",462,115
Improves support for Clang in Google Mock Doctor.," def _NeedToUseSymbolDiagnoser(msg):
 
 gcc_regex = (_GCC_FILE_LINE_RE + r'error: \'(?P<symbol>.+)\' '
 r'(was not declared in this scope|has not been declared)')
- clang_regex = (_CLANG_FILE_LINE_RE + r'error: use of undeclared identifier '
- r'\'(?P<symbol>.+)\'')
+ clang_regex = (_CLANG_FILE_LINE_RE +
+ r'error: (use of undeclared identifier|unknown type name) '
+ r'\'(?P<symbol>[^\']+)\'')
 diagnosis = """"""
 '%(symbol)s' is defined by Google Mock in the testing namespace.
 Did you forget to write
",475,30
Adds a new macro simplifying use of snprinf on MS platforms.," inline void Abort() { abort(); }
 
 } // namespace posix
 
+// MSVC ""deprecates"" snprintf and issues warnings wherever it is used. In
+// order to avoid these warnings, we need to use _snprintf or _snprintf_s on
+// MSVC-based platforms. We map the GTEST_SNPRINTF_ macro to the appropriate
+// function in order to achieve that. We use macro definition here because
+// snprintf is a variadic function.
+#if _MSC_VER >= 1400 && !GTEST_OS_WINDOWS_MOBILE
+// MSVC 2005 and above support variadic macros.
+# define GTEST_SNPRINTF_(buffer, size, format, ...) \
+ _snprintf_s(buffer, size, size, format, __VA_ARGS__)
+#elif defined(_MSC_VER)
+// Windows CE does not define _snprintf_s and MSVC prior to 2005 doesn't
+// complain about _snprintf.
+# define GTEST_SNPRINTF_ _snprintf
+#else
+# define GTEST_SNPRINTF_ snprintf
+#endif
+
 // The maximum number a BiggestInt can represent. This definition
 // works no matter BiggestInt is represented in one's complement or
 // two's complement.
",462,115
Modifies gmock_doctor.py to work with GCC output that contains file:line:char positions and left and right quote characters (U+2018 and U+2019) instead of apostrophes (U+0027).," _COMMON_GMOCK_SYMBOLS = [
 ]
 
 # Regex for matching source file path and line number in the compiler's errors.
-_GCC_FILE_LINE_RE = r'(?P<file>.*):(?P<line>\d+):\s+'
+_GCC_FILE_LINE_RE = r'(?P<file>.*):(?P<line>\d+):(\d+:)?\s+'
 _CLANG_FILE_LINE_RE = r'(?P<file>.*):(?P<line>\d+):(?P<column>\d+):\s+'
 _CLANG_NON_GMOCK_FILE_LINE_RE = (
 r'(?P<file>.*[/\\^](?!gmock-)[^/\\]+):(?P<line>\d+):(?P<column>\d+):\s+')
 def Diagnose(msg):
 """"""Generates all possible diagnoses given the compiler error message.""""""
 
 msg = re.sub(r'\x1b\[[^m]*m', '', msg) # Strips all color formatting.
+ # Assuming the string is using the UTF-8 encoding, replaces the left and
+ # the right single quote characters with apostrophes.
+ msg = re.sub(r'(\xe2\x80\x98|\xe2\x80\x99)', ""'"", msg)
 
 diagnoses = []
 for diagnoser in _DIAGNOSERS:
",476,30
Fixes test failure on 32-bit Ubuntu.," void SetSigprofActionAndTimer() {
 // Disables ITIMER_PROF timer and ignores SIGPROF signal.
 void DisableSigprofActionAndTimer(struct sigaction* old_signal_action) {
 struct itimerval timer;
+ timer.it_interval.tv_sec = 0;
 timer.it_interval.tv_usec = 0;
- timer.it_value.tv_usec = 0;
+ timer.it_value = timer.it_interval;
 ASSERT_EQ(0, setitimer(ITIMER_PROF, &timer, NULL));
 struct sigaction signal_action;
 memset(&signal_action, 0, sizeof(signal_action));
",842,144
Adds ability to inject death test child arguments for test purposes.,"
 // GTEST_FLAG() - references a flag.
 // GTEST_DECLARE_*() - declares a flag.
 // GTEST_DEFINE_*() - defines a flag.
-// GetArgvs() - returns the command line as a vector of strings.
+// GetInjectableArgvs() - returns the command line as a vector of strings.
 //
 // Environment variable utilities:
 // GetEnv() - gets the value of an environment variable.
 GTEST_API_ String GetCapturedStderr();
 
 #if GTEST_HAS_DEATH_TEST
 
-// A copy of all command line arguments. Set by InitGoogleTest().
-extern ::std::vector<String> g_argvs;
+const ::std::vector<testing::internal::string>& GetInjectableArgvs();
+void SetInjectableArgvs(const ::std::vector<testing::internal::string>*
+ new_argvs);
 
-// GTEST_HAS_DEATH_TEST implies we have ::std::string.
-const ::std::vector<String>& GetArgvs();
+// A copy of all command line arguments. Set by InitGoogleTest().
+extern ::std::vector<testing::internal::string> g_argvs;
 
 #endif // GTEST_HAS_DEATH_TEST
 
",464,115
Implements the timestamp attribute for the testsuites element in the output XML (external contribution by Dirk Meister).," class GTEST_API_ UnitTest {
 // Gets the number of tests that should run.
 int test_to_run_count() const;
 
+ // Gets the time of the test program start, in ms from the start of the
+ // UNIX epoch.
+ TimeInMillis start_timestamp() const;
+
 // Gets the elapsed time, in milliseconds.
 TimeInMillis elapsed_time() const;
 
",622,95
Simplifies test assertions in sample5.," TEST_F(IntegerFunctionTest, Factorial) {
 // Tests IsPrime()
 TEST_F(IntegerFunctionTest, IsPrime) {
 // Tests negative input.
- EXPECT_TRUE(!IsPrime(-1));
- EXPECT_TRUE(!IsPrime(-2));
- EXPECT_TRUE(!IsPrime(INT_MIN));
+ EXPECT_FALSE(IsPrime(-1));
+ EXPECT_FALSE(IsPrime(-2));
+ EXPECT_FALSE(IsPrime(INT_MIN));
 
 // Tests some trivial cases.
- EXPECT_TRUE(!IsPrime(0));
- EXPECT_TRUE(!IsPrime(1));
+ EXPECT_FALSE(IsPrime(0));
+ EXPECT_FALSE(IsPrime(1));
 EXPECT_TRUE(IsPrime(2));
 EXPECT_TRUE(IsPrime(3));
 
 // Tests positive input.
- EXPECT_TRUE(!IsPrime(4));
+ EXPECT_FALSE(IsPrime(4));
 EXPECT_TRUE(IsPrime(5));
- EXPECT_TRUE(!IsPrime(6));
+ EXPECT_FALSE(IsPrime(6));
 EXPECT_TRUE(IsPrime(23));
 }
 
",70,7
Fixed Google Mock Doctor Clang regexes to work on both k8 and piii (by Greg Miller).," def _NeedToUseReturnNullDiagnoser(msg):
 r'(.*\n)*?' +
 _CLANG_NON_GMOCK_FILE_LINE_RE + r'note: in instantiation '
 r'of function template specialization '
- r'\'testing::internal::ReturnAction<long>::operator '
+ r'\'testing::internal::ReturnAction<(int|long)>::operator '
 r'Action<(?P<type>.*)\(\)>\' requested here')
 diagnosis = """"""
 You are probably calling Return(NULL) and the compiler isn't sure how to turn
",476,30
Changes to fix gtest-printers_test on VC++ 2010.," using ::std::pair;
 using ::std::set;
 using ::std::vector;
 using ::testing::PrintToString;
+using ::testing::internal::ImplicitCast_;
 using ::testing::internal::NativeArray;
 using ::testing::internal::RE;
 using ::testing::internal::Strings;
 TEST(PrintTupleTest, VariousSizes) {
 EXPECT_EQ(""(false, 2, 3, 4, true, 6, 7, true, 9)"", Print(t9));
 
 const char* const str = ""8"";
+ // VC++ 2010's implementation of tuple of C++0x is deficient, requiring
+ // an explicit type cast of NULL to be used.
 tuple<bool, char, short, testing::internal::Int32, // NOLINT
 testing::internal::Int64, float, double, const char*, void*, string>
- t10(false, 'a', 3, 4, 5, 1.5F, -2.5, str, NULL, ""10"");
+ t10(false, 'a', 3, 4, 5, 1.5F, -2.5, str,
+ ImplicitCast_<void*>(NULL), ""10"");
 EXPECT_EQ(""(false, 'a' (97, 0x61), 3, 4, 5, 1.5, -2.5, "" + PrintPointer(str) +
 "" pointing to \""8\"", NULL, \""10\"")"",
 Print(t10));
",867,140
"Expressed the thread-safety annotations in code, replacing the existing comment-based system (by Aaron Jacobs)."," class linked_ptr_internal {
 // framework.
 
 // Join an existing circle.
- // L < g_linked_ptr_mutex
- void join(linked_ptr_internal const* ptr) {
+ void join(linked_ptr_internal const* ptr)
+ GTEST_LOCK_EXCLUDED_(g_linked_ptr_mutex) {
 MutexLock lock(&g_linked_ptr_mutex);
 
 linked_ptr_internal const* p = ptr;
 class linked_ptr_internal {
 
 // Leave whatever circle we're part of. Returns true if we were the
 // last member of the circle. Once this is done, you can join() another.
- // L < g_linked_ptr_mutex
- bool depart() {
+ bool depart()
+ GTEST_LOCK_EXCLUDED_(g_linked_ptr_mutex) {
 MutexLock lock(&g_linked_ptr_mutex);
 
 if (next_ == this) return true;
",105,29
Adds empty methods to Mutex on platforms where Google Test is not thread-safe. This will support a reentrancy fix in Google Mock.," class ThreadLocal {
 class Mutex {
 public:
 Mutex() {}
+ void Lock() {}
+ void Unlock() {}
 void AssertHeld() const {}
 };
 
",466,117
Fixes a lock reentrancy when destroying a mock causes destruction of another mock (issue 79) (by Aaron Jacobs).," bool UntypedFunctionMockerBase::VerifyAndClearExpectationsLocked()
 untyped_expectation->line(), ss.str());
 }
 }
- untyped_expectations_.clear();
+
+ // Deleting our expectations may trigger other mock objects to be deleted, for
+ // example if an action contains a reference counted smart pointer to that
+ // mock object, and that is the last reference. So if we delete our
+ // expectations within the context of the global mutex we may deadlock when
+ // this method is called again. Instead, make a copy of the set of
+ // expectations to delete, clear our set within the mutex, and then clear the
+ // copied set outside of it.
+ UntypedExpectations expectations_to_delete;
+ untyped_expectations_.swap(expectations_to_delete);
+
+ g_gmock_mutex.Unlock();
+ expectations_to_delete.clear();
+ g_gmock_mutex.Lock();
+
 return expectations_met;
 }
 
",498,113
Improves conformance to the Google C++ Style Guide (by Greg Miller).," class GTEST_API_ TestPartResult {
 
 // Returns true iff the test part fatally failed.
 bool fatally_failed() const { return type_ == kFatalFailure; }
+
 private:
 Type type_;
 
",70,13
Removes spurious semicolon.," class OsStackTraceGetter : public OsStackTraceGetterInterface {
 virtual String CurrentStackTrace(int max_depth, int skip_count)
 GTEST_LOCK_EXCLUDED_(mutex_);
 
- virtual void UponLeavingGTest();
- GTEST_LOCK_EXCLUDED_(mutex_);
+ virtual void UponLeavingGTest() GTEST_LOCK_EXCLUDED_(mutex_);
 
 // This string is inserted in place of stack frames that are part of
 // Google Test's implementation.
",443,75
"Adds file and line information to the ""message"", which is used as the summary
of a failure."," class GTEST_API_ UnitTestImpl {
 // For example, if Foo() calls Bar(), which in turn calls
 // CurrentOsStackTraceExceptTop(1), Foo() will be included in the
 // trace but Bar() and CurrentOsStackTraceExceptTop() won't.
- String CurrentOsStackTraceExceptTop(int skip_count);
+ String CurrentOsStackTraceExceptTop(int skip_count) GTEST_NO_INLINE_;
 
 // Finds and returns a TestCase with the given name. If one doesn't
 // exist, creates one and returns it.
",443,75
"Misc small updates to some debug death code, and to messages streaming to macros"," inline internal::ParamGenerator<bool> Bool() {
 // Boolean flags:
 //
 // class FlagDependentTest
-// : public testing::TestWithParam<tuple(bool, bool)> > {
+// : public testing::TestWithParam<tuple<bool, bool> > {
 // virtual void SetUp() {
 // // Assigns external_flag_1 and external_flag_2 values from the tuple.
 // tie(external_flag_1, external_flag_2) = GetParam();
",958,69
Reduced template instantiation depth for the AllOf and AnyOf matchers. Also some formatting changes.,"
 #ifndef GMOCK_INCLUDE_GMOCK_GMOCK_ACTIONS_H_
 #define GMOCK_INCLUDE_GMOCK_GMOCK_ACTIONS_H_
 
-#include <algorithm>
-#include <string>
-
 #ifndef _WIN32_WCE
 # include <errno.h>
 #endif
 
+#include <algorithm>
+#include <string>
+
 #include ""gmock/internal/gmock-internal-utils.h""
 #include ""gmock/internal/gmock-port.h""
 
 class DefaultValue {
 return value_ == NULL ?
 internal::BuiltInDefaultValue<T>::Get() : *value_;
 }
+
 private:
 static const T* value_;
 };
 class DefaultValue<T&> {
 return address_ == NULL ?
 internal::BuiltInDefaultValue<T&>::Get() : *address_;
 }
+
 private:
 static T* address_;
 };
",538,92
Teach gtest to autodetect rtti support with clang (by Nico Weber).,"
 # define GTEST_HAS_RTTI 0
 # endif // __GXX_RTTI
 
+// Clang defines __GXX_RTTI starting with version 3.0, but its manual recommends
+// using has_feature instead. has_feature(cxx_rtti) is supported since 2.7, the
+// first version with C++ support.
+# elif defined(__clang__)
+
+# define GTEST_HAS_RTTI __has_feature(cxx_rtti)
+
 // Starting with version 9.0 IBM Visual Age defines __RTTI_ALL__ to 1 if
 // both the typeid and dynamic_cast features are present.
 # elif defined(__IBMCPP__) && (__IBMCPP__ >= 900)
",483,120
"Fixes threading annotations and compatibility with C++11, which doesn't
allow exepctions to be thrown in a destructor."," void StreamingListener::MakeConnection() {
 // Pushes the given source file location and message onto a per-thread
 // trace stack maintained by Google Test.
 ScopedTrace::ScopedTrace(const char* file, int line, const Message& message)
- GTEST_LOCK_EXCLUDED_(UnitTest::mutex_) {
+ GTEST_LOCK_EXCLUDED_(&UnitTest::mutex_) {
 TraceInfo trace;
 trace.file = file;
 trace.line = line;
 ScopedTrace::ScopedTrace(const char* file, int line, const Message& message)
 
 // Pops the info pushed by the c'tor.
 ScopedTrace::~ScopedTrace()
- GTEST_LOCK_EXCLUDED_(UnitTest::mutex_) {
+ GTEST_LOCK_EXCLUDED_(&UnitTest::mutex_) {
 UnitTest::GetInstance()->PopGTestTrace();
 }
 
",2875,716
"Pulls in gtest r615.

Renames internal enums to the kFoo naming style.

Fixes gmock doctor to work with newer versions of Clang."," DoAll(Action1 a1, Action2 a2, Action3 a3, Action4 a4, Action5 a5, Action6 a6,
 p9##_type>::gmock_Impl<F>::gmock_PerformImpl(\
 GMOCK_ACTION_ARG_TYPES_AND_NAMES_UNUSED_) const
 
-// TODO(wan@google.com): move the following to a different .h file
-// such that we don't have to run 'pump' every time the code is
-// updated.
 namespace testing {
 
 // The ACTION*() macros trigger warning C4100 (unreferenced formal
",829,100
"Improves gtest's failure messages. In particulars, char pointers and
char arrays are not escapped properly."," inline bool IsUpper(char ch) {
 inline bool IsXDigit(char ch) {
 return isxdigit(static_cast<unsigned char>(ch)) != 0;
 }
+inline bool IsXDigit(wchar_t ch) {
+ const unsigned char low_byte = static_cast<unsigned char>(ch);
+ return ch == low_byte && isxdigit(low_byte) != 0;
+}
 
 inline char ToLower(char ch) {
 return static_cast<char>(tolower(static_cast<unsigned char>(ch)));
",487,122
added defines for iOS," void ColoredPrintf(GTestColor color, const char* fmt, ...) {
 va_list args;
 va_start(args, fmt);
 
-#if GTEST_OS_WINDOWS_MOBILE || GTEST_OS_SYMBIAN || GTEST_OS_ZOS
+#if GTEST_OS_WINDOWS_MOBILE || GTEST_OS_SYMBIAN || GTEST_OS_ZOS || GTEST_OS_IOS
 const bool use_color = false;
 #else
 static const bool in_color_mode =
",2867,712
Fixed Native Client build of gtest when using glibc (by Ben Smith).,"
 #elif GTEST_OS_WINDOWS
 # include <direct.h>
 # include <io.h>
-#elif GTEST_OS_SYMBIAN || GTEST_OS_NACL
-// Symbian OpenC and NaCl have PATH_MAX in sys/syslimits.h
+#elif GTEST_OS_SYMBIAN
+// Symbian OpenC has PATH_MAX in sys/syslimits.h
 # include <sys/syslimits.h>
 #else
 # include <limits.h>
",190,67
Makes gmock's Pointee() work for optional<T> (by Jeffrey Yasskin).," struct PointeeOf<T*> { typedef T type; }; // NOLINT
 // smart pointer, or returns p itself when p is already a raw pointer.
 // The following default implementation is for the smart pointer case.
 template <typename Pointer>
-inline typename Pointer::element_type* GetRawPointer(const Pointer& p) {
+inline const typename Pointer::element_type* GetRawPointer(const Pointer& p) {
 return p.get();
 }
 // This overloaded version is for the raw pointer case.
",192,3
Removes obsolete debug code.,"
 // This allows a user to use his own types in Google Test assertions by
 // overloading the << operator.
 //
-// util/gtl/stl_logging-inl.h overloads << for STL containers. These
+// util/gtl/stl_logging.h overloads << for STL containers. These
 // overloads cannot be defined in the std namespace, as that will be
 // undefined behavior. Therefore, they are defined in the global
 // namespace instead.
",403,64
Improves Android support (by David Turner).," class DirectoryCreationTest : public Test {
 return String(temp_dir);
 else
 return String::Format(""%s\\"", temp_dir);
+#elif GTEST_OS_LINUX_ANDROID
+ return String(""/sdcard/"");
 #else
 return String(""/tmp/"");
 #endif // GTEST_OS_WINDOWS_MOBILE
",457,92
Fixes an out-dated URL.," class FloatingPoint {
 // bits. Therefore, 4 should be enough for ordinary use.
 //
 // See the following article for more details on ULP:
- // http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm.
+ // http://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/
 static const size_t kMaxUlps = 4;
 
 // Constructs a FloatingPoint from a raw floating-point number.
",403,64
"Removes testing::internal::String::Format(), which causes problems as it truncates the result at 4096 chars. Also update an obsolete link in comment."," class GTEST_API_ TestInfo {
 friend class TestCase;
 friend class internal::UnitTestImpl;
 friend TestInfo* internal::MakeAndRegisterTestInfo(
- const char* test_case_name, const char* name,
+ const char* test_case_name,
+ const char* name,
 const char* type_param,
 const char* value_param,
 internal::TypeId fixture_class_id,
 class GTEST_API_ TestInfo {
 
 // Constructs a TestInfo object. The newly constructed instance assumes
 // ownership of the factory object.
- TestInfo(const char* test_case_name, const char* name,
- const char* a_type_param,
- const char* a_value_param,
+ TestInfo(const std::string& test_case_name,
+ const std::string& name,
+ const char* a_type_param, // NULL if not a type-parameterized test
+ const char* a_value_param, // NULL if not a value-parameterized test
 internal::TypeId fixture_class_id,
 internal::TestFactoryBase* factory);
 
",657,97
Fixes gUnit streaming output format.," class ExecDeathTest;
 class NoExecDeathTest;
 class FinalSuccessChecker;
 class GTestFlagSaver;
+class StreamingListenerTest;
 class TestResultAccessor;
 class TestEventListenersAccessor;
 class TestEventRepeater;
 class GTEST_API_ TestInfo {
 friend class Test;
 friend class TestCase;
 friend class internal::UnitTestImpl;
+ friend class internal::StreamingListenerTest;
 friend TestInfo* internal::MakeAndRegisterTestInfo(
 const char* test_case_name,
 const char* name,
 class GTEST_API_ UnitTest {
 friend class Test;
 friend class internal::AssertHelper;
 friend class internal::ScopedTrace;
+ friend class internal::StreamingListenerTest;
 friend Environment* AddGlobalTestEnvironment(Environment* env);
 friend internal::UnitTestImpl* internal::GetUnitTestImpl();
 friend void internal::ReportFailureInUnknownLocation(
",660,97
"Removes an unused variable; also refactors to support an up-coming
googlemock change."," class GTestFlagSaver {
 bool list_tests_;
 std::string output_;
 bool print_time_;
- bool pretty_;
 internal::Int32 random_seed_;
 internal::Int32 repeat_;
 bool shuffle_;
",541,100
"Makes googlemock throw a runtime_error instead of abort when a mock
method with no default value is invoked (if exceptions are enabled)."," TEST(DoDefaultTest, ReturnsBuiltInDefaultValueByDefault) {
 EXPECT_EQ(0, mock.IntFunc(true));
 }
 
-// Tests that DoDefault() aborts the process when there is no built-in
-// default value for the return type.
+// Tests that DoDefault() throws (when exceptions are enabled) or aborts
+// the process when there is no built-in default value for the return type.
 TEST(DoDefaultDeathTest, DiesForUnknowType) {
 MockClass mock;
 EXPECT_CALL(mock, Foo())
 .WillRepeatedly(DoDefault());
+#if GTEST_HAS_EXCEPTIONS
+ EXPECT_ANY_THROW(mock.Foo());
+#else
 EXPECT_DEATH_IF_SUPPORTED({
 mock.Foo();
 }, """");
+#endif
 }
 
 // Tests that using DoDefault() inside a composite action leads to a
",824,135
Implements RUN_ALL_TESTS() as a function.," bool StaticAssertTypeEq() {
 GTEST_TEST_(test_fixture, test_name, test_fixture, \
 ::testing::internal::GetTypeId<test_fixture>())
 
-// Use this macro in main() to run all tests. It returns 0 if all
+} // namespace testing
+
+// Use this function in main() to run all tests. It returns 0 if all
 // tests are successful, or 1 otherwise.
 //
 // RUN_ALL_TESTS() should be invoked after the command line has been
 // parsed by InitGoogleTest().
+//
+// This function was formerly a macro; thus, it is in the global
+// namespace and has an all-caps name.
+int RUN_ALL_TESTS() GTEST_MUST_USE_RESULT_;
 
-#define RUN_ALL_TESTS()\
- (::testing::UnitTest::GetInstance()->Run())
-
-} // namespace testing
+inline int RUN_ALL_TESTS() {
+ return ::testing::UnitTest::GetInstance()->Run();
+}
 
 #endif // GTEST_INCLUDE_GTEST_GTEST_H_
",664,98
Fixes a nasty issue in gtest's template instantiation.," class UnitTestImpl* GetUnitTestImpl();
 void ReportFailureInUnknownLocation(TestPartResult::Type result_type,
 const std::string& message);
 
-// Converts a streamable value to an std::string. A NULL pointer is
-// converted to ""(null)"". When the input value is a ::string,
-// ::std::string, ::wstring, or ::std::wstring object, each NUL
-// character in it is replaced with ""\\0"".
-// Declared in gtest-internal.h but defined here, so that it has access
-// to the definition of the Message class, required by the ARM
-// compiler.
-template <typename T>
-std::string StreamableToString(const T& streamable) {
- return (Message() << streamable).GetString();
-}
-
 } // namespace internal
 
 // The friend relationship of some of these classes is cyclic.
",660,97
"Fixes unused function warning on Mac, and fixes compatibility with newer GCC."," struct CompileAssert {
 };
 
 #define GTEST_COMPILE_ASSERT_(expr, msg) \
- typedef ::testing::internal::CompileAssert<(bool(expr))> \
- msg[bool(expr) ? 1 : -1]
+ typedef ::testing::internal::CompileAssert<(static_cast<bool>(expr))> \
+ msg[static_cast<bool>(expr) ? 1 : -1] GTEST_ATTRIBUTE_UNUSED_
 
 // Implementation details of GTEST_COMPILE_ASSERT_:
 //
",500,122
Implements NaggyMock.," class GTEST_API_ Mock {
 template <typename M>
 friend class NiceMock;
 
+ template <typename M>
+ friend class NaggyMock;
+
 template <typename M>
 friend class StrictMock;
 
",923,144
Removes unused variables and functions.," TEST(ActionPnMacroTest, TypesAreCorrect) {
 Plus(1, 2, 3, 4, 5, 6, 7, 8, '9');
 PlusActionP10<int, int, int, int, int, int, int, int, int, char> a10 =
 Plus(1, 2, 3, 4, 5, 6, 7, 8, 9, '0');
+
+ // Avoid ""unused variable"" warnings.
+ (void)a0;
+ (void)a1;
+ (void)a2;
+ (void)a3;
+ (void)a4;
+ (void)a5;
+ (void)a6;
+ (void)a7;
+ (void)a8;
+ (void)a9;
+ (void)a10;
 }
 
 // Tests that an ACTION_P*() action can be explicitly instantiated
",881,163
"Improves the tests for nice, naggy, and strict mocks."," class OnCallSpec : public UntypedOnCallSpecBase {
 enum CallReaction {
 kAllow,
 kWarn,
- kFail
+ kFail,
+ kDefault = kWarn // By default, warn about uninteresting calls.
 };
 
 } // namespace internal
",924,144
"Removes an unnecessary semi-colon, which causes a warning in GCC's pedantic mode."," class PolymorphicMatcher {
 template <typename T>
 inline Matcher<T> MakeMatcher(const MatcherInterface<T>* impl) {
 return Matcher<T>(impl);
-};
+}
 
 // Creates a polymorphic matcher from its implementation. This is
 // easier to use than the PolymorphicMatcher<Impl> constructor as it
",1909,375
"Supports colored output on term type screen-256color.

Proposed as a one-line patch by Tom Jakubowski (tom@crystae.net);
finished by Zhanyong Wan."," GTEST_DEFINE_string_(
 ""Whether to use colors in the output. Valid values: yes, no, ""
 ""and auto. 'auto' means to use colors if the output is ""
 ""being sent to a terminal and the TERM environment variable ""
- ""is set to xterm, xterm-color, xterm-256color, linux or cygwin."");
+ ""is set to a terminal type that supports colors."");
 
 GTEST_DEFINE_string_(
 filter,
 bool ShouldUseColor(bool stdout_is_tty) {
 String::CStringEquals(term, ""xterm-color"") ||
 String::CStringEquals(term, ""xterm-256color"") ||
 String::CStringEquals(term, ""screen"") ||
+ String::CStringEquals(term, ""screen-256color"") ||
 String::CStringEquals(term, ""linux"") ||
 String::CStringEquals(term, ""cygwin"");
 return stdout_is_tty && term_supports_color;
",2764,678
Prints a useful message when GetParam() is called in a non-parameterized test.," class WithParamInterface {
 // references static data, to reduce the opportunity for incorrect uses
 // like writing 'WithParamInterface<bool>::GetParam()' for a test that
 // uses a fixture whose parameter type is int.
- const ParamType& GetParam() const { return *parameter_; }
+ const ParamType& GetParam() const {
+ GTEST_CHECK_(parameter_ != NULL)
+ << ""GetParam() can only be called inside a value-parameterized test ""
+ << ""-- did you intend to write TEST_P instead of TEST_F?"";
+ return *parameter_;
+ }
 
 private:
 // Sets parameter value. The caller is responsible for making sure the value
",665,97
Makes WhenSorted() support associative containers (by billydonahue@google.com).," class WhenSortedByMatcher {
 GTEST_REMOVE_REFERENCE_AND_CONST_(LhsContainer)> LhsView;
 typedef typename LhsView::type LhsStlContainer;
 typedef typename LhsView::const_reference LhsStlContainerReference;
- typedef typename LhsStlContainer::value_type LhsValue;
+ // Transforms std::pair<const Key, Value> into std::pair<Key, Value>
+ // so that we can match associative containers.
+ typedef typename RemoveConstFromKey<
+ typename LhsStlContainer::value_type>::type LhsValue;
 
 Impl(const Comparator& comparator, const ContainerMatcher& matcher)
 : comparator_(comparator), matcher_(matcher) {}
",1932,379
Fixes some compatibility issues with STLport.," using ::std::tr1::make_tuple;
 using ::std::tr1::tuple;
 #endif
 
-#if _MSC_VER
-// MSVC defines the following classes in the ::stdext namespace while
-// gcc defines them in the :: namespace. Note that they are not part
-// of the C++ standard.
+// The hash_* classes are not part of the C++ standard. STLport
+// defines them in namespace std. MSVC defines them in ::stdext. GCC
+// defines them in ::.
+#ifdef _STLP_HASH_MAP // We got <hash_map> from STLport.
+using ::std::hash_map;
+using ::std::hash_set;
+using ::std::hash_multimap;
+using ::std::hash_multiset;
+#elif _MSC_VER
 using ::stdext::hash_map;
 using ::stdext::hash_set;
 using ::stdext::hash_multimap;
",1018,164
Implements support for calling Test::RecordProperty() outside of a test.," class GTestXMLTestCase(gtest_test_utils.TestCase):
 actual_attributes = actual_node .attributes
 self.assertEquals(
 expected_attributes.length, actual_attributes.length,
- 'attribute numbers differ in element ' + actual_node.tagName)
+ 'attribute numbers differ in element %s:\nExpected: %r\nActual: %r' % (
+ actual_node.tagName, expected_attributes.keys(),
+ actual_attributes.keys()))
 for i in range(expected_attributes.length):
 expected_attr = expected_attributes.item(i)
 actual_attr = actual_attributes.get(expected_attr.name)
",95,21
Fixes a thread annotation; updates CHANGES for 1.7.0," Environment* UnitTest::AddEnvironment(Environment* env) {
 // assertion macros (e.g. ASSERT_TRUE, EXPECT_EQ, etc) eventually call
 // this to report their results. The user code should use the
 // assertion macros instead of calling this directly.
-GTEST_LOCK_EXCLUDED_(mutex_)
 void UnitTest::AddTestPartResult(
 TestPartResult::Type result_type,
 const char* file_name,
 int line_number,
 const std::string& message,
- const std::string& os_stack_trace) {
+ const std::string& os_stack_trace) GTEST_LOCK_EXCLUDED_(mutex_) {
 Message msg;
 msg << message;
 
",2904,697
Makes EXPECT_THAT typesafe; updates CHANGES for 1.7.0; pulls in gtest r653," class PredicateFormatterFromMatcher {
 // know which type to instantiate it to until we actually see the
 // type of x here.
 //
- // We write MatcherCast<const T&>(matcher_) instead of
+ // We write SafeMatcherCast<const T&>(matcher_) instead of
 // Matcher<const T&>(matcher_), as the latter won't compile when
 // matcher_ has type Matcher<T> (e.g. An<int>()).
- const Matcher<const T&> matcher = MatcherCast<const T&>(matcher_);
+ // We don't write MatcherCast<const T&> either, as that allows
+ // potentially unsafe downcasting of the matcher argument.
+ const Matcher<const T&> matcher = SafeMatcherCast<const T&>(matcher_);
 StringMatchResultListener listener;
 if (MatchPrintAndExplain(x, matcher, &listener))
 return AssertionSuccess();
",1932,379
"When --gtest_filter is specified, XML report now doesn't contain information about tests that are filtered out (issue 141)."," class GTEST_API_ UnitTestImpl {
 // Gets the number of failed tests.
 int failed_test_count() const;
 
+ // Gets the number of disabled tests that will be reported in the XML report.
+ int reportable_disabled_test_count() const;
+
 // Gets the number of disabled tests.
 int disabled_test_count() const;
 
+ // Gets the number of tests to be printed in the XML report.
+ int reportable_test_count() const;
+
 // Gets the number of all tests.
 int total_test_count() const;
 
",544,100
Fixes compatibility with C++11: (1 - 1) is no longer a NULL pointer constant.," bool g_help_flag = false;
 
 } // namespace internal
 
+static const char* GetDefaultFilter() {
+ return kUniversalFilter;
+}
+
 GTEST_DEFINE_bool_(
 also_run_disabled_tests,
 internal::BoolFromGTestEnv(""also_run_disabled_tests"", false),
 GTEST_DEFINE_string_(
 
 GTEST_DEFINE_string_(
 filter,
- internal::StringFromGTestEnv(""filter"", kUniversalFilter),
+ internal::StringFromGTestEnv(""filter"", GetDefaultFilter()),
 ""A colon-separated list of glob (not regex) patterns ""
 ""for filtering the tests to run, optionally followed by a ""
 ""'-' and a : separated list of negative patterns (tests to ""
",2930,706
"New floating-point matchers: DoubleNear() and friends;
AllOf() and AnyOf() can accept any number of arguments now in C++11 mode."," class SubstractAction : public ActionInterface<int(int, int)> { // NOLINT
 TEST(WithArgsTest, NonInvokeAction) {
 Action<int(const string&, int, int)> a = // NOLINT
 WithArgs<2, 1>(MakeAction(new SubstractAction));
- EXPECT_EQ(8, a.Perform(make_tuple(CharPtr(""hi""), 2, 10)));
+ EXPECT_EQ(8, a.Perform(make_tuple(string(""hi""), 2, 10)));
 }
 
 // Tests using WithArgs to pass all original arguments in the original order.
",881,163
Fixes uses of pair to std::pair; pulls in gtest r655.," class BothOfMatcherImpl : public MatcherInterface<T> {
 template <int kSize, typename Head, typename... Tail>
 struct MatcherList {
 typedef MatcherList<kSize - 1, Tail...> MatcherListTail;
- typedef pair<Head, typename MatcherListTail::ListType> ListType;
+ typedef ::std::pair<Head, typename MatcherListTail::ListType> ListType;
 
 // BuildList stores variadic type values in a nested pair structure.
 // Example:
 struct MatcherList {
 // MatcherList.
 template <typename Matcher1, typename Matcher2>
 struct MatcherList<2, Matcher1, Matcher2> {
- typedef pair<Matcher1, Matcher2> ListType;
+ typedef ::std::pair<Matcher1, Matcher2> ListType;
 
 static ListType BuildList(const Matcher1& matcher1,
 const Matcher2& matcher2) {
- return pair<Matcher1, Matcher2>(matcher1, matcher2);
+ return ::std::pair<Matcher1, Matcher2>(matcher1, matcher2);
 }
 
 template <typename T, template <typename /* T */> class CombiningMatcher>
",2030,399
supports a protocol for catching tests that prematurely exit," EXE_PATH = gtest_test_utils.GetTestExecutablePath(
 'gtest_break_on_failure_unittest_')
 
 
-# Utilities.
-
-
-environ = os.environ.copy()
-
-
-def SetEnvVar(env_var, value):
- """"""Sets an environment variable to a given value; unsets it when the
- given value is None.
- """"""
-
- if value is not None:
- environ[env_var] = value
- elif env_var in environ:
- del environ[env_var]
+environ = gtest_test_utils.environ
+SetEnvVar = gtest_test_utils.SetEnvVar
+
+# Tests in this file run a Google-Test-based test program and expect it
+# to terminate prematurely. Therefore they are incompatible with
+# the premature-exit-file protocol by design. Unset the
+# premature-exit filepath to prevent Google Test from creating
+# the file.
+SetEnvVar(gtest_test_utils.PREMATURE_EXIT_FILE_ENV_VAR, None)
 
 
 def Run(command):
",108,16
makes googlemock generator handle some class templates; pulls in gtest r662," class AstBuilder(object):
 self._AddBackToken(token)
 
 return class_type(class_token.start, class_token.end, class_name,
- bases, None, body, self.namespace_stack)
+ bases, templated_types, body, self.namespace_stack)
 
 def handle_namespace(self):
 token = self._GetNextToken()
",1241,387
fixes the bug reported by Andrzej Jarzabek where 2 gmock tests fail when built with VS," TEST(ExpectCallTest, TakesDefaultActionWhenWillListIsExhausted) {
 "" - returning default value.""));
 }
 
-TEST(FunctionMockerTest, ReportsExpectCallLocationForExhausedActions) {
+TEST(FunctionMockerMessageTest, ReportsExpectCallLocationForExhausedActions) {
 MockB b;
 std::string expect_call_location = FormatFileLocation(__FILE__, __LINE__ + 1);
 EXPECT_CALL(b, DoB()).Times(AnyNumber()).WillOnce(Return(1));
 TEST(FunctionMockerTest, ReportsExpectCallLocationForExhausedActions) {
 EXPECT_PRED_FORMAT2(IsSubstring, expect_call_location, output);
 }
 
-TEST(FunctionMockerTest,
+TEST(FunctionMockerMessageTest,
 ReportsDefaultActionLocationOfUninterestingCallsForNaggyMock) {
 std::string on_call_location;
 CaptureStdout();
",1809,160
avoids clash with the max() macro on Windows,"
 #endif
 
 #include <ctype.h>
+#include <float.h>
 #include <string.h>
 #include <iomanip>
 #include <limits>
 class FloatingPoint {
 return ReinterpretBits(kExponentBitMask);
 }
 
+ // Returns the maximum representable finite floating-point number.
+ static RawType Max();
+
 // Non-static methods
 
 // Returns the bits that represents this number.
 class FloatingPoint {
 FloatingPointUnion u_;
 };
 
+// We cannot use std::numeric_limits<T>::max() as it clashes with the max()
+// macro defined by <windows.h>.
+template <>
+inline float FloatingPoint<float>::Max() { return FLT_MAX; }
+template <>
+inline double FloatingPoint<double>::Max() { return DBL_MAX; }
+
 // Typedefs the instances of the FloatingPoint template class that we
 // care to use.
 typedef FloatingPoint<float> Float;
",409,65
"Delete whitespace, and change the return type of ImplicitlyConvertible::MakeFrom() to From&."," class ImplicitlyConvertible {
 // MakeFrom() is an expression whose type is From. We cannot simply
 // use From(), as the type From may not have a public default
 // constructor.
- static From MakeFrom();
+ static typename AddReference<From>::type MakeFrom();
 
 // These two functions are overloaded. Given an expression
 // Helper(x), the compiler will pick the first version if x can be
",409,65
Add MemorySanitizer annotations in gtest printers. Also remove unused variable kPathSeparatorString.," using ::std::tuple_size;
 # define GTEST_HAS_CXXABI_H_ 0
 #endif
 
+// A function level attribute to disable checking for use of uninitialized
+// memory when built with MemorySanitizer.
+#if defined(__clang__)
+# if __has_feature(memory_sanitizer)
+# define GTEST_ATTRIBUTE_NO_SANITIZE_MEMORY_ \
+ __attribute__((no_sanitize_memory))
+# else
+# define GTEST_ATTRIBUTE_NO_SANITIZE_MEMORY_
+# endif
+#else
+# define GTEST_ATTRIBUTE_NO_SANITIZE_MEMORY_
+#endif
+
 namespace testing {
 
 class Message;
",500,122
Fix warnings encountered with clang -Wall.," class Secret;
 // expression is true. For example, you could use it to verify the
 // size of a static array:
 //
-// GTEST_COMPILE_ASSERT_(ARRAYSIZE(content_type_names) == CONTENT_NUM_TYPES,
-// content_type_names_incorrect_size);
+// GTEST_COMPILE_ASSERT_(GTEST_ARRAY_SIZE_(names) == NUM_NAMES,
+// names_incorrect_size);
 //
 // or to make sure a struct is smaller than a certain size:
 //
 struct StaticAssertTypeEqHelper;
 template <typename T>
 struct StaticAssertTypeEqHelper<T, T> {};
 
+// Evaluates to the number of elements in 'array'.
+#define GTEST_ARRAY_SIZE_(array) (sizeof(array) / sizeof(array[0]))
+
 #if GTEST_HAS_GLOBAL_STRING
 typedef ::string string;
 #else
",500,122
"Distinguish between C++11 language and library support for <initializer_list>.
Fix spelling: repositary -> repository.","
 # endif
 #endif
 
+// C++11 specifies that <initializer_list> provides std::initializer_list. Use
+// that if gtest is used in C++11 mode and libstdc++ isn't very old (binaries
+// targeting OS X 10.6 can build with clang but need to use gcc4.2's
+// libstdc++).
+#if GTEST_LANG_CXX11 && (!defined(__GLIBCXX__) || __GLIBCXX__ > 20110325)
+# define GTEST_HAS_STD_INITIALIZER_LIST_ 1
+#endif
+
 // Brings in definitions for functions used in the testing::internal::posix
 // namespace (read, write, close, chdir, isatty, stat). We do not currently
 // use them on Windows Mobile.
",500,122
"Distinguish between C++11 language and library support for <initializer_list>.
Fix spelling: repositary -> repository.
Pull in gtest 671.","
 #include ""gmock/internal/gmock-port.h""
 #include ""gtest/gtest.h""
 
-#if GTEST_LANG_CXX11
-#include <initializer_list> // NOLINT -- must be after gtest.h
+#if GTEST_HAS_STD_INITIALIZER_LIST_
+# include <initializer_list> // NOLINT -- must be after gtest.h
 #endif
 
 namespace testing {
 inline internal::ElementsAreArrayMatcher<T> ElementsAreArray(
 return ElementsAreArray(vec.begin(), vec.end());
 }
 
-#if GTEST_LANG_CXX11
+#if GTEST_HAS_STD_INITIALIZER_LIST_
 template <typename T>
 inline internal::ElementsAreArrayMatcher<T>
 ElementsAreArray(::std::initializer_list<T> xs) {
 UnorderedElementsAreArray(const ::std::vector<T, A>& vec) {
 return UnorderedElementsAreArray(vec.begin(), vec.end());
 }
 
-#if GTEST_LANG_CXX11
+#if GTEST_HAS_STD_INITIALIZER_LIST_
 template <typename T>
 inline internal::UnorderedElementsAreArrayMatcher<T>
 UnorderedElementsAreArray(::std::initializer_list<T> xs) {
",2320,455
"Adds a note in the ""uninteresting mock method call"" warning to advise people how to handle the warning.
Clarifies the purpose of utilities in gmock-port.h and adds guidance w.r.t. gmock-port.h vs gtest-port.h.
Pulls in gtest r674."," void ReportUninterestingCall(CallReaction reaction, const string& msg) {
 Log(kInfo, msg, 3);
 break;
 case kWarn:
- Log(kWarning, msg, 3);
+ Log(kWarning,
+ msg +
+ ""\nNOTE: You can safely ignore the above warning unless this ""
+ ""call should not happen. Do not suppress it by blindly adding ""
+ ""an EXPECT_CALL() if you don't mean to enforce the call. ""
+ ""See http://code.google.com/p/googlemock/wiki/CookBook#""
+ ""Knowing_When_to_Expect for details."",
+ 3);
 break;
 default: // FAIL
 Expect(false, NULL, -1, msg);
",506,113
"Make Google Test build cleanly on Visual Studio 2010, 2012, 2013.
Also improve an error message in gtest_test_utils.py.","
 private:
 #endif
 
+// Visual Studio 2010, 2012, and 2013 define symbols in std::tr1 that conflict
+// with our own definitions. Therefore using our own tuple does not work on
+// those compilers.
+#if defined(_MSC_VER) && _MSC_VER >= 1600 /* 1600 is Visual Studio 2010 */
+# error ""gtest's tuple doesn't compile on Visual Studio 2010 or later. \
+GTEST_USE_OWN_TR1_TUPLE must be set to 0 on those compilers.""
+#endif
+
 // GTEST_n_TUPLE_(T) is the type of an n-tuple.
 #define GTEST_0_TUPLE_(T) tuple<>
 #define GTEST_1_TUPLE_(T) tuple<T##0, void, void, void, void, void, void, \
",668,30
"Make Google Mock build cleanly on Visual Studio 2010, 2012, 2013."," class FooInterface {
 #endif // GTEST_OS_WINDOWS
 };
 
+// Const qualifiers on arguments were once (incorrectly) considered
+// significant in determining whether two virtual functions had the same
+// signature. This was fixed in Visual Studio 2008. However, the compiler
+// still emits a warning that alerts about this change in behavior.
+#ifdef _MSC_VER
+# pragma warning(push)
+# pragma warning(disable : 4373)
+#endif
 class MockFoo : public FooInterface {
 public:
 MockFoo() {}
 class MockFoo : public FooInterface {
 private:
 GTEST_DISALLOW_COPY_AND_ASSIGN_(MockFoo);
 };
+#ifdef _MSC_VER
+# pragma warning(pop)
+#endif
 
 class FunctionMockerTest : public testing::Test {
 protected:
",381,38
"Add GTEST_MOVE macro, to support mocking methods with move-only return types.
Add GTEST_ATTRIBUTE_NO_SANITIZE_ADDRESS_"," using ::std::ostream;
 
 // Prints a segment of bytes in the given object.
 GTEST_ATTRIBUTE_NO_SANITIZE_MEMORY_
+GTEST_ATTRIBUTE_NO_SANITIZE_ADDRESS_
 void PrintByteSegmentInObjectTo(const unsigned char* obj_bytes, size_t start,
 size_t count, ostream* os) {
 char text[5] = """";
 void PrintTo(wchar_t wc, ostream* os) {
 // and may not be NUL-terminated.
 template <typename CharType>
 GTEST_ATTRIBUTE_NO_SANITIZE_MEMORY_
+GTEST_ATTRIBUTE_NO_SANITIZE_ADDRESS_
 static void PrintCharsAsStringTo(
 const CharType* begin, size_t len, ostream* os) {
 const char* const kQuoteBegin = sizeof(CharType) == 1 ? ""\"""" : ""L\"""";
 static void PrintCharsAsStringTo(
 // 'begin'. CharType must be either char or wchar_t.
 template <typename CharType>
 GTEST_ATTRIBUTE_NO_SANITIZE_MEMORY_
+GTEST_ATTRIBUTE_NO_SANITIZE_ADDRESS_
 static void UniversalPrintCharArray(
 const CharType* begin, size_t len, ostream* os) {
 // The code
",205,52
"Suppress ""Conditional expression is constant"" warning on Visual Studio."," struct TuplePrefixPrinter {
 template <typename Tuple>
 static void PrintPrefixTo(const Tuple& t, ::std::ostream* os) {
 TuplePrefixPrinter<N - 1>::PrintPrefixTo(t, os);
+ GTEST_INTENTIONAL_CONST_COND_PUSH_
 if (N > 1) {
+ GTEST_INTENTIONAL_CONST_COND_POP_
 *os << "", "";
 }
 UniversalPrinter<
",433,73
Standards compliance changes to fix QNX build.,"
 
 #if GTEST_OS_QNX
 # include <devctl.h>
+# include <fcntl.h>
 # include <sys/procfs.h>
 #endif // GTEST_OS_QNX
 
",456,142
Remove code referencing Google protocol buffers version 1.," TEST(PrintPrintableTypeTest, TemplateInUserNamespace) {
 
 #if GTEST_HAS_PROTOBUF_
 
-// Tests printing a protocol message.
-TEST(PrintProtocolMessageTest, PrintsShortDebugString) {
- testing::internal::TestMessage msg;
- msg.set_member(""yes"");
- EXPECT_EQ(""<member:\""yes\"">"", Print(msg));
-}
-
 // Tests printing a short proto2 message.
 TEST(PrintProto2MessageTest, PrintsShortDebugStringWhenItIsShort) {
 testing::internal::FooMessage msg;
",1080,170
Add annotations to suppress ThreadSanitizer failures due to gunit/gmock printer.," using ::std::tuple_size;
 # define GTEST_ATTRIBUTE_NO_SANITIZE_ADDRESS_
 #endif // __clang__
 
+// A function level attribute to disable ThreadSanitizer instrumentation.
+#if defined(__clang__)
+# if __has_feature(thread_sanitizer)
+# define GTEST_ATTRIBUTE_NO_SANITIZE_THREAD_ \
+ __attribute__((no_sanitize_thread))
+# else
+# define GTEST_ATTRIBUTE_NO_SANITIZE_THREAD_
+# endif // __has_feature(thread_sanitizer)
+#else
+# define GTEST_ATTRIBUTE_NO_SANITIZE_THREAD_
+#endif // __clang__
+
 namespace testing {
 
 class Message;
",503,122
Make the gmock generator work with the 'override' keyword. Also pull in gtest 680.," _INDENT = 2
 
 
 def _GenerateMethods(output_lines, source, class_node):
- function_type = ast.FUNCTION_VIRTUAL | ast.FUNCTION_PURE_VIRTUAL
+ function_type = (ast.FUNCTION_VIRTUAL | ast.FUNCTION_PURE_VIRTUAL |
+ ast.FUNCTION_OVERRIDE)
 ctor_or_dtor = ast.FUNCTION_CTOR | ast.FUNCTION_DTOR
 indent = ' ' * _INDENT
 
",148,48
"Implement threading support for gtest on Windows.
Also, stop using localtime(). Instead, use localtime_r() on most systems, localtime_s() on Windows."," GTEST_API_ void ParseGoogleTestFlagsOnly(int* argc, wchar_t** argv);
 // platform.
 GTEST_API_ std::string GetLastErrnoDescription();
 
-# if GTEST_OS_WINDOWS
-// Provides leak-safe Windows kernel handle ownership.
-class AutoHandle {
- public:
- AutoHandle() : handle_(INVALID_HANDLE_VALUE) {}
- explicit AutoHandle(HANDLE handle) : handle_(handle) {}
-
- ~AutoHandle() { Reset(); }
-
- HANDLE Get() const { return handle_; }
- void Reset() { Reset(INVALID_HANDLE_VALUE); }
- void Reset(HANDLE handle) {
- if (handle != handle_) {
- if (handle_ != INVALID_HANDLE_VALUE)
- ::CloseHandle(handle_);
- handle_ = handle;
- }
- }
-
- private:
- HANDLE handle_;
-
- GTEST_DISALLOW_COPY_AND_ASSIGN_(AutoHandle);
-};
-# endif // GTEST_OS_WINDOWS
-
 // Attempts to parse a string into a positive integer pointed to by the
 // number parameter. Returns true if that is possible.
 // GTEST_HAS_DEATH_TEST implies that we have ::std::string, so we can use
",526,92
"Implement threading support for gmock on Windows.
Replace U+2013 with U+002D in comment lines.
Pull in gtest 681."," GTEST_API_ string FormatMatcherDescription(bool negation,
 // . [ sink ] .
 //
 // See Also:
-// [1] Cormen, et al (2001). ""Section 26.2: The FordFulkerson method"".
-// ""Introduction to Algorithms (Second ed.)"", pp. 651664.
-// [2] ""FordFulkerson algorithm"", Wikipedia,
+// [1] Cormen, et al (2001). ""Section 26.2: The Ford-Fulkerson method"".
+// ""Introduction to Algorithms (Second ed.)"", pp. 651-664.
+// [2] ""Ford-Fulkerson algorithm"", Wikipedia,
 // 'http://en.wikipedia.org/wiki/Ford%E2%80%93Fulkerson_algorithm'
 class MaxBipartiteMatchState {
 public:
",276,65
Export tuple and friends in the ::testing namespace.," using ::testing::Combine;
 // PreCalculatedPrimeTable disabled. We do this by defining fixture which will
 // accept different combinations of parameters for instantiating a
 // HybridPrimeTable instance.
-class PrimeTableTest : public TestWithParam< ::std::tr1::tuple<bool, int> > {
+class PrimeTableTest : public TestWithParam< ::testing::tuple<bool, int> > {
 protected:
 virtual void SetUp() {
 // This can be written as
 class PrimeTableTest : public TestWithParam< ::std::tr1::tuple<bool, int> > {
 //
 // once the Google C++ Style Guide allows use of ::std::tr1::tie.
 //
- bool force_on_the_fly = ::std::tr1::get<0>(GetParam());
- int max_precalculated = ::std::tr1::get<1>(GetParam());
+ bool force_on_the_fly = ::testing::get<0>(GetParam());
+ int max_precalculated = ::testing::get<1>(GetParam());
 table_ = new HybridPrimeTable(force_on_the_fly, max_precalculated);
 }
 virtual void TearDown() {
",75,15
Push upstream to SVN.," static bool IsPathSeparator(char c) {
 
 // Returns the current working directory, or """" if unsuccessful.
 FilePath FilePath::GetCurrentDir() {
-#if GTEST_OS_WINDOWS_MOBILE
+#if GTEST_OS_WINDOWS_MOBILE || GTEST_OS_WINDOWS_PHONE || GTEST_OS_WINDOWS_RT
 // Windows CE doesn't have a current directory, so we just return
 // something reasonable.
 return FilePath(kCurrentDirectoryString);
",190,67
"Push several shanges:

 Make single argument constructors explicit in macros.

 Remove NOMINMAX macro.

 Add macros for disabling Microsoft Visual C++ warnings.

 Add WhenDynamicCastTo<T> matcher.
 A matcher that matches a pointer that matches inner_matcher when
 dynamic_cast<T> is applied.

 Add IWYU export pragmas to the tuple include lines.

 Fix NativeArray to not require a copy constructor unless we ask for one.
 This allows ElementsAre() to support non-copyable types.

 Examine WINAPI_FAMILY_PARTITION macros to better distinguish windows platforms.
 Author: martin@martin.st
 From: https://codereview.appspot.com/57220043/"," DoAll(Action1 a1, Action2 a2, Action3 a3, Action4 a4, Action5 a5, Action6 a6,
 GMOCK_INTERNAL_DECL_TYPE_##value_params>\
 class GMOCK_ACTION_CLASS_(name, value_params) {\
 public:\
- GMOCK_ACTION_CLASS_(name, value_params)\
+ explicit GMOCK_ACTION_CLASS_(name, value_params)\
 GMOCK_INTERNAL_INIT_##value_params {}\
 template <typename F>\
 class gmock_Impl : public ::testing::ActionInterface<F> {\
 DoAll(Action1 a1, Action2 a2, Action3 a3, Action4 a4, Action5 a5, Action6 a6,
 template <typename p0##_type>\
 class name##ActionP {\
 public:\
- name##ActionP(p0##_type gmock_p0) : p0(gmock_p0) {}\
+ explicit name##ActionP(p0##_type gmock_p0) : p0(gmock_p0) {}\
 template <typename F>\
 class gmock_Impl : public ::testing::ActionInterface<F> {\
 public:\
",792,100
Disable asan instrumentation for StackGrowsDown().," void StackLowerThanAddress(const void* ptr, bool* result) {
 *result = (&dummy < ptr);
 }
 
+// Make sure AddressSanitizer does not tamper with the stack here.
+GTEST_ATTRIBUTE_NO_SANITIZE_ADDRESS_
 bool StackGrowsDown() {
 int dummy;
 bool result;
",758,145
Add MockFunction::AsStdFunction(). Also pull in gtest 688.," TEST(MockFunctionTest, WorksFor10Arguments) {
 EXPECT_EQ(2, foo.Call(true, 'a', 0, 0, 0, 0, 0, 'b', 1, false));
 }
 
+#if GTEST_LANG_CXX11
+TEST(MockFunctionTest, AsStdFunction) {
+ MockFunction<int(int)> foo;
+ auto call = [](const std::function<int(int)> &f, int i) {
+ return f(i);
+ };
+ EXPECT_CALL(foo, Call(1)).WillOnce(Return(-1));
+ EXPECT_CALL(foo, Call(2)).WillOnce(Return(-2));
+ EXPECT_EQ(-1, call(foo.AsStdFunction(), 1));
+ EXPECT_EQ(-2, call(foo.AsStdFunction(), 2));
+}
+#endif // GTEST_LANG_CXX11
+
 } // namespace gmock_generated_function_mockers_test
 } // namespace testing
",391,39
Reduce the number of occurrences of gendered pronouns in gtest.,"
 
 // Indicates that this translation unit is part of Google Test's
 // implementation. It must come before gtest-internal-inl.h is
-// included, or there will be a compiler error. This trick is to
-// prevent a user from accidentally including gtest-internal-inl.h in
-// his code.
+// included, or there will be a compiler error. This trick exists to
+// prevent the accidental inclusion of gtest-internal-inl.h in the
+// user's code.
 #define GTEST_IMPLEMENTATION_ 1
 #include ""src/gtest-internal-inl.h""
 #undef GTEST_IMPLEMENTATION_
",758,145
"Additional changes, to add support for Windows Phone and Windows RT"," using ::std::tuple_size;
 # endif
 
 #define GTEST_IS_THREADSAFE \
- (GTEST_OS_WINDOWS || GTEST_HAS_PTHREAD)
+ (0 \
+ || (GTEST_OS_WINDOWS && !GTEST_OS_WINDOWS_PHONE && !GTEST_OS_WINDOWS_RT) \
+ || GTEST_HAS_PTHREAD)
 
 #endif // GTEST_HAS_SEH
 
 class Notification {
 GTEST_DISALLOW_COPY_AND_ASSIGN_(Notification);
 };
 
-# elif GTEST_OS_WINDOWS
+# elif GTEST_OS_WINDOWS && !GTEST_OS_WINDOWS_PHONE && !GTEST_OS_WINDOWS_RT
 
 GTEST_API_ void SleepMilliseconds(int n);
 
 class ThreadWithParam : public ThreadWithParamBase {
 # endif // GTEST_HAS_PTHREAD && !GTEST_OS_WINDOWS_MINGW
 
 # if 0 // OS detection
-# elif GTEST_OS_WINDOWS
+# elif GTEST_OS_WINDOWS && !GTEST_OS_WINDOWS_PHONE && !GTEST_OS_WINDOWS_RT
 
 // Mutex implements mutex on Windows platforms. It is used in conjunction
 // with class MutexLock:
",660,146
Expand equality failure messages with a by-line diff.," TEST(NonfatalFailureTest, EscapesStringOperands) {
 EXPECT_EQ(golden, actual);
 }
 
+TEST(NonfatalFailureTest, DiffForLongStrings) {
+ std::string golden_str(kGoldenString, sizeof(kGoldenString) - 1);
+ EXPECT_EQ(golden_str, ""Line 2"");
+}
+
 // Tests catching a fatal failure in a subroutine.
 TEST(FatalFailureTest, FatalFailureInSubroutine) {
 printf(""(expecting a failure that x should be 1)\n"");
",586,111
Mock out GetCurrentDir in NaCl.," FilePath FilePath::GetCurrentDir() {
 return FilePath(_getcwd(cwd, sizeof(cwd)) == NULL ? """" : cwd);
 #else
 char cwd[GTEST_PATH_MAX_ + 1] = { '\0' };
- return FilePath(getcwd(cwd, sizeof(cwd)) == NULL ? """" : cwd);
+ char* result = getcwd(cwd, sizeof(cwd));
+# if GTEST_OS_NACL
+ // getcwd will likely fail in NaCl due to the sandbox, so return something
+ // reasonable. The user may have provided a shim implementation for getcwd,
+ // however, so fallback only when failure is detected.
+ return FilePath(result == NULL ? kCurrentDirectoryString : cwd);
+# endif // GTEST_OS_NACL
+ return FilePath(result == NULL ? """" : cwd);
 #endif // GTEST_OS_WINDOWS_MOBILE
 }
 
",192,69
"Distinguish between C++11 language and library support for std::function, std::begin, std::end, and std::move in gtest and gmock."," TEST(PrintTr1TupleTest, NestedTuple) {
 
 #endif // GTEST_HAS_TR1_TUPLE
 
-#if GTEST_LANG_CXX11
+#if GTEST_HAS_STD_TUPLE_
 // Tests printing ::std::tuples.
 
 // Tuples of various arities.
",1080,170
"Distinguish between C++11 language and library support for std::function, std::begin, std::end, and std::move in gtest and gmock.
Bring in gtest 694."," class BeginEndDistanceIsMatcher {
 
 virtual bool MatchAndExplain(Container container,
 MatchResultListener* listener) const {
-#if GTEST_LANG_CXX11
+#if GTEST_HAS_STD_BEGIN_AND_END_
 using std::begin;
 using std::end;
 DistanceType distance = std::distance(begin(container), end(container));
",2503,487
Add ByMove() modifier for the Return() action. Pull in gtest 695.," template <typename T>
 class ReferenceOrValueWrapper {
 public:
 // Constructs a wrapper from the given value/reference.
- explicit ReferenceOrValueWrapper(T value)
- : value_(GTEST_MOVE_(value)) {}
+ explicit ReferenceOrValueWrapper(T value) : value_(move(value)) {}
 
 // Unwraps and returns the underlying value/reference, exactly as
 // originally passed. The behavior of calling this more than once on
 // the same object is unspecified.
- T Unwrap() {
- return GTEST_MOVE_(value_);
- }
+ T Unwrap() { return move(value_); }
 
 // Provides nondestructive access to the underlying value/reference.
 // Always returns a const reference (more precisely,
 class ActionResultHolder : public UntypedActionResultHolderBase {
 private:
 typedef ReferenceOrValueWrapper<T> Wrapper;
 
- explicit ActionResultHolder(Wrapper result)
- : result_(GTEST_MOVE_(result)) {}
+ explicit ActionResultHolder(Wrapper result) : result_(move(result)) {}
 
 Wrapper result_;
 
",949,151
"Silence a signedness-comparison warning in gmock-actions_test.
include <functional> when using std::function in gmock.","
 #include ""gmock/gmock-spec-builders.h""
 #include ""gmock/internal/gmock-internal-utils.h""
 
+#if GTEST_HAS_STD_FUNCTION_
+# include <functional>
+#endif
+
 namespace testing {
 namespace internal {
 
",348,44
Call move() by qualified name (::testing::internal::move() or just internal::move()).," inline void FlushInfoLog() { fflush(NULL); }
 
 #if GTEST_HAS_STD_MOVE_
 using std::move;
-#else // GTEST_LANG_CXX11
+#else // GTEST_HAS_STD_MOVE_
 template <typename T>
 const T& move(const T& t) {
 return t;
 const T& move(const T& t) {
 // similar functions users may have (e.g., implicit_cast). The internal
 // namespace alone is not enough because the function can be found by ADL.
 template<typename To>
-inline To ImplicitCast_(To x) { return move(x); }
+inline To ImplicitCast_(To x) { return ::testing::internal::move(x); }
 
 // When you upcast (that is, cast a pointer from type Foo to type
 // SuperclassOfFoo), it's fine to use ImplicitCast_<>, since upcasts
",665,147
"Generate relational matchers (Eq,Lt, etc) with CRTP instead of macro."," TEST(MatcherCastTest, FromSameType) {
 EXPECT_FALSE(m2.Matches(1));
 }
 
-// Implicitly convertible form any type.
+// Implicitly convertible from any type.
 struct ConvertibleFromAny {
 ConvertibleFromAny(int a_value) : value(a_value) {}
 template <typename T>
- ConvertibleFromAny(const T& a_value) : value(-1) {
+ ConvertibleFromAny(const T& /*a_value*/) : value(-1) {
 ADD_FAILURE() << ""Conversion constructor called"";
 }
 int value;
",4111,550
Fix gmock Action behaviour when return type is Wrapper," class ReturnAction {
 // Result without considering explicit constructors, thus resolving the
 // ambiguity. value_ is then initialized using its copy constructor.
 explicit Impl(const linked_ptr<R>& value)
- : value_(ImplicitCast_<Result>(*value)) {}
+ : value_before_cast_(*value),
+ value_(ImplicitCast_<Result>(value_before_cast_)) {}
 
 virtual Result Perform(const ArgumentTuple&) { return value_; }
 
 private:
 GTEST_COMPILE_ASSERT_(!is_reference<Result>::value,
 Result_cannot_be_a_reference_type);
+ // We save the value before casting just in case it is being cast to a
+ // wrapper type.
+ R value_before_cast_;
 Result value_;
 
- GTEST_DISALLOW_ASSIGN_(Impl);
+ GTEST_DISALLOW_COPY_AND_ASSIGN_(Impl);
 };
 
 // Partially specialize for ByMoveWrapper. This version of ReturnAction will
",594,102
Fix gmock-matchers_test's ConstIter.," class Streamlike {
 class ConstIter : public std::iterator<std::input_iterator_tag,
 value_type,
 ptrdiff_t,
- const value_type&,
- const value_type*> {
+ const value_type*,
+ const value_type&> {
 public:
 ConstIter(const Streamlike* s,
 typename std::list<value_type>::iterator pos)
",4111,550
Strip trailing whitespace when stringifying type lists.," class TypeParameterizedTest {
 MakeAndRegisterTestInfo(
 (std::string(prefix) + (prefix[0] == '\0' ? """" : ""/"") + case_name + ""/""
 + StreamableToString(index)).c_str(),
- GetPrefixUntilComma(test_names).c_str(),
+ StripTrailingSpaces(GetPrefixUntilComma(test_names)).c_str(),
 GetTypeName<Type>().c_str(),
 NULL, // No value parameter.
 GetTypeId<FixtureClass>(),
",429,66
Remove special support for GTEST_OS_IOS_SIMULATOR.,"
 // GTEST_OS_LINUX_ANDROID - Google Android
 // GTEST_OS_MAC - Mac OS X
 // GTEST_OS_IOS - iOS
-// GTEST_OS_IOS_SIMULATOR - iOS simulator
 // GTEST_OS_NACL - Google Native Client (NaCl)
 // GTEST_OS_OPENBSD - OpenBSD
 // GTEST_OS_QNX - QNX

 # define GTEST_OS_MAC 1
 # if TARGET_OS_IPHONE
 # define GTEST_OS_IOS 1
-# if TARGET_IPHONE_SIMULATOR
-# define GTEST_OS_IOS_SIMULATOR 1
-# endif
 # endif
 #elif defined __linux__
 # define GTEST_OS_LINUX 1
 using ::std::tuple_size;
 // abort() in a VC 7.1 application compiled as GUI in debug config
 // pops up a dialog window that cannot be suppressed programmatically.
 #if (GTEST_OS_LINUX || GTEST_OS_CYGWIN || GTEST_OS_SOLARIS || \
- (GTEST_OS_MAC && !GTEST_OS_IOS) || GTEST_OS_IOS_SIMULATOR || \
+ (GTEST_OS_MAC && !GTEST_OS_IOS) || \
 (GTEST_OS_WINDOWS_DESKTOP && _MSC_VER >= 1400) || \
 GTEST_OS_WINDOWS_MINGW || GTEST_OS_AIX || GTEST_OS_HPUX || \
 GTEST_OS_OPENBSD || GTEST_OS_QNX)
",671,150
"Handle parameters without variable names when the type includes *, & or []."," class TypeConverter(object):
 first_token = None
 default = []
 
- def AddParameter():
+ def AddParameter(end):
 if default:
 del default[0] # Remove flag.
- end = type_modifiers[-1].end
 parts = self.DeclarationToParts(type_modifiers, True)
 (name, type_name, templated_types, modifiers,
 unused_default, unused_other_tokens) = parts
 class TypeConverter(object):
 continue
 
 if s.name == ',':
- AddParameter()
+ AddParameter(s.start)
 name = type_name = ''
 type_modifiers = []
 pointer = reference = array = False
 class TypeConverter(object):
 default.append(s)
 else:
 type_modifiers.append(s)
- AddParameter()
+ AddParameter(tokens[-1].end)
 return result
 
 def CreateReturnType(self, return_type_seq):
",1243,387
Prevent gmock_gen from returning exit code zero on a failure to parse.," def main(argv=sys.argv):
 return
 except:
 # An error message was already printed since we couldn't parse.
- pass
+ sys.exit(1)
 else:
 lines = _GenerateMocks(filename, source, entire_ast, desired_class_names)
 sys.stdout.write('\n'.join(lines))
",148,48
Add support for C++11 explicitly defaulted and deleted special member functions in the gmock generator.," class AstBuilder(object):
 body = None
 if token.name == '=':
 token = self._GetNextToken()
- assert token.token_type == tokenize.CONSTANT, token
- assert token.name == '0', token
- modifiers |= FUNCTION_PURE_VIRTUAL
- token = self._GetNextToken()
+
+ if token.name == 'default' or token.name == 'delete':
+ # Ignore explicitly defaulted and deleted special members
+ # in C++11.
+ token = self._GetNextToken()
+ else:
+ # Handle pure-virtual declarations.
+ assert token.token_type == tokenize.CONSTANT, token
+ assert token.name == '0', token
+ modifiers |= FUNCTION_PURE_VIRTUAL
+ token = self._GetNextToken()
 
 if token.name == '[':
 # TODO(nnorwitz): store tokens and improve parsing.
",1246,387
Noop changes to suppress compile-time warnings in WINDOWS code paths.," inline const char* StrError(int errnum) { return strerror(errnum); }
 inline const char* GetEnv(const char* name) {
 #if GTEST_OS_WINDOWS_MOBILE || GTEST_OS_WINDOWS_PHONE | GTEST_OS_WINDOWS_RT
 // We are on Windows CE, which has no environment variables.
+ static_cast<void>(name); // To prevent 'unused argument' warning.
 return NULL;
 #elif defined(__BORLANDC__) || defined(__SunOS_5_8) || defined(__SunOS_5_9)
 // Environment variables which we programmatically clear will be set to the
",672,150
Change an example to use 'override' rather than 'virtual'. Add missing headers for 'connect' and 'socket'.," GTEST_API_ AssertionResult AssertionFailure(const Message& msg);
 //
 // class FooTest : public testing::Test {
 // protected:
-// virtual void SetUp() { ... }
-// virtual void TearDown() { ... }
+// void SetUp() override { ... }
+// void TearDown() override { ... }
 // ...
 // };
 //
",716,103
"Makes DoubleNear() print the diff between the actual and the expected value when the match fails. 
Also fix bogus MSVC warning about ""alignment of a member was sensitive to packing"".
Also bring in gtest 701."," template <class Class, typename MethodPtr>
 class InvokeMethodAction {
 public:
 InvokeMethodAction(Class* obj_ptr, MethodPtr method_ptr)
- : obj_ptr_(obj_ptr), method_ptr_(method_ptr) {}
+ : method_ptr_(method_ptr), obj_ptr_(obj_ptr) {}
 
 template <typename Result, typename ArgumentTuple>
 Result Perform(const ArgumentTuple& args) const {
 class InvokeMethodAction {
 }
 
 private:
- Class* const obj_ptr_;
+ // The order of these members matters. Reversing the order can trigger
+ // warning C4121 in MSVC (see
+ // http://computer-programming-forum.com/7-vc.net/6fbc30265f860ad1.htm ).
 const MethodPtr method_ptr_;
+ Class* const obj_ptr_;
 
 GTEST_DISALLOW_ASSIGN_(InvokeMethodAction);
 };
",101,19
Adding support to gmock_gen for nested templates.," class TypeConverter(object):
 else:
 names.append(t.name)
 name = ''.join(names)
- result.append(Type(name_tokens[0].start, name_tokens[-1].end,
- name, templated_types, modifiers,
- reference, pointer, array))
+ if name_tokens:
+ result.append(Type(name_tokens[0].start, name_tokens[-1].end,
+ name, templated_types, modifiers,
+ reference, pointer, array))
 del name_tokens[:]
 
 i = 0
",1247,388
Make ReturnNull() support unique_ptr and shared_ptr.," class ReturnAction {
 // Implements the ReturnNull() action.
 class ReturnNullAction {
 public:
- // Allows ReturnNull() to be used in any pointer-returning function.
+ // Allows ReturnNull() to be used in any pointer-returning function. In C++11
+ // this is enforced by returning nullptr, and in non-C++11 by asserting a
+ // pointer type on compile time.
 template <typename Result, typename ArgumentTuple>
 static Result Perform(const ArgumentTuple&) {
+#if GTEST_LANG_CXX11
+ return nullptr;
+#else
 GTEST_COMPILE_ASSERT_(internal::is_pointer<Result>::value,
 ReturnNull_can_be_used_to_return_a_pointer_only);
 return NULL;
+#endif // GTEST_LANG_CXX11
 }
 };
 
",595,103
Fix build of Objective-C++ files with new clang versions.," struct _RTL_CRITICAL_SECTION;
 # define _HAS_EXCEPTIONS 1
 # endif // _HAS_EXCEPTIONS
 # define GTEST_HAS_EXCEPTIONS _HAS_EXCEPTIONS
+# elif defined(__clang__)
+// __EXCEPTIONS determines if cleanups are enabled. In Obj-C++ files, there can
+// be cleanups for ObjC exceptions, but C++ exceptions might still be disabled.
+// So use a __has_feature check for C++ exceptions instead.
+# define GTEST_HAS_EXCEPTIONS __has_feature(cxx_exceptions)
 # elif defined(__GNUC__) && __EXCEPTIONS
 // gcc defines __EXCEPTIONS to 1 iff exceptions are enabled.
 # define GTEST_HAS_EXCEPTIONS 1
",672,150
Add asserts to prevent mysterious hangs in a non-thread-safe gmock build.," class linked_ptr_internal {
 MutexLock lock(&g_linked_ptr_mutex);
 
 linked_ptr_internal const* p = ptr;
- while (p->next_ != ptr) p = p->next_;
+ while (p->next_ != ptr) {
+ assert(p->next_ != this &&
+ ""Trying to join() a linked ring we are already in. ""
+ ""Is GMock thread safety enabled?"");
+ p = p->next_;
+ }
 p->next_ = this;
 next_ = ptr;
 }
 class linked_ptr_internal {
 
 if (next_ == this) return true;
 linked_ptr_internal const* p = next_;
- while (p->next_ != this) p = p->next_;
+ while (p->next_ != this) {
+ assert(p->next_ != next_ &&
+ ""Trying to depart() a linked ring we are not in. ""
+ ""Is GMock thread safety enabled?"");
+ p = p->next_;
+ }
 p->next_ = next_;
 return false;
 }
",115,31
"This change adds an explicit invocation of std::move to workaround a problem
in VC++'s /analyze compiler that was causing build errors in Chrome:

https://code.google.com/p/googlemock/issues/detail?id=172"," class PropertyMatcher {
 *listener << ""whose given property is "";
 // Cannot pass the return value (for example, int) to MatchPrintAndExplain,
 // which takes a non-const reference as argument.
+#if defined(_PREFAST_ ) && _MSC_VER == 1800
+ // Workaround bug in VC++ 2013's /analyze parser.
+ // https://connect.microsoft.com/VisualStudio/feedback/details/1106363/internal-compiler-error-with-analyze-due-to-failure-to-infer-move
+ posix::Abort(); // To make sure it is never run.
+ return false;
+#else
 RefToConstProperty result = (obj.*property_)();
 return MatchPrintAndExplain(result, matcher_, listener);
+#endif
 }
 
 bool MatchAndExplainImpl(true_type /* is_pointer */, const Class* p,
",2666,532
Enable GTest thread safety on Native Client.," struct _RTL_CRITICAL_SECTION;
 
 // Determines whether Google Test can use the pthreads library.
 #ifndef GTEST_HAS_PTHREAD
-// The user didn't tell us explicitly, so we assume pthreads support is
-// available on Linux and Mac.
+// The user didn't tell us explicitly, so we make reasonable assumptions about
+// which platforms have pthreads support.
 //
 // To disable threading support in Google Test, add -DGTEST_HAS_PTHREAD=0
 // to your compiler flags.
 # define GTEST_HAS_PTHREAD (GTEST_OS_LINUX || GTEST_OS_MAC || GTEST_OS_HPUX \
- || GTEST_OS_QNX || GTEST_OS_FREEBSD)
+ || GTEST_OS_QNX || GTEST_OS_FREEBSD || GTEST_OS_NACL)
 #endif // GTEST_HAS_PTHREAD
 
 #if GTEST_HAS_PTHREAD
",672,150
Suppresses the stack trace in a warning for uninteresting call by default; the stack trace will still be printed when --gmock_verbose=info is printed.," GTEST_API_ ThreadLocal<Sequence*> g_gmock_implicit_sequence;
 // Reports an uninteresting call (whose description is in msg) in the
 // manner specified by 'reaction'.
 void ReportUninterestingCall(CallReaction reaction, const string& msg) {
+ // Include a stack trace only if --gmock_verbose=info is specified.
+ const int stack_frames_to_skip =
+ GMOCK_FLAG(verbose) == kInfoVerbosity ? 3 : -1;
 switch (reaction) {
 case kAllow:
- Log(kInfo, msg, 3);
+ Log(kInfo, msg, stack_frames_to_skip);
 break;
 case kWarn:
 Log(kWarning,
 void ReportUninterestingCall(CallReaction reaction, const string& msg) {
 ""call should not happen. Do not suppress it by blindly adding ""
 ""an EXPECT_CALL() if you don't mean to enforce the call. ""
 ""See http://code.google.com/p/googlemock/wiki/CookBook#""
- ""Knowing_When_to_Expect for details."",
- 3);
+ ""Knowing_When_to_Expect for details.\n"",
+ stack_frames_to_skip);
 break;
 default: // FAIL
 Expect(false, NULL, -1, msg);
",508,114
"Make an int64->double conversion explicit to silence -Wconversion.

Addresses issue #173:
 https://code.google.com/p/googlemock/issues/detail?id=173"," std::string XmlUnitTestResultPrinter::RemoveInvalidXmlCharacters(
 // Formats the given time in milliseconds as seconds.
 std::string FormatTimeInMillisAsSeconds(TimeInMillis ms) {
 ::std::stringstream ss;
- ss << ms/1000.0;
+ ss << (static_cast<double>(ms) * 1e-3);
 return ss.str();
 }
 
",3183,778
"Work around some unsigned->signed warnings in our tests/.
Thanks to Diego Barrios Romero <eldruin@gmail.com>."," class DestructorTracker {
 }
 
 private:
- static int GetNewIndex() {
+ static size_t GetNewIndex() {
 DestructorCall::List().push_back(new DestructorCall);
 return DestructorCall::List().size() - 1;
 }
- const int index_;
+ const size_t index_;
 
 GTEST_DISALLOW_ASSIGN_(DestructorTracker);
 };
",933,157
urxvt supports colors," bool ShouldUseColor(bool stdout_is_tty) {
 String::CStringEquals(term, ""xterm-256color"") ||
 String::CStringEquals(term, ""screen"") ||
 String::CStringEquals(term, ""screen-256color"") ||
+ String::CStringEquals(term, ""rxvt-unicode"") ||
+ String::CStringEquals(term, ""rxvt-unicode-256color"") ||
 String::CStringEquals(term, ""linux"") ||
 String::CStringEquals(term, ""cygwin"");
 return stdout_is_tty && term_supports_color;
",3185,780
"Change IsNull and NotNull to use ==/!= nullptr in C++11.
Also update gmock_doctor due to Clang wording change."," class IsNullMatcher {
 template <typename Pointer>
 bool MatchAndExplain(const Pointer& p,
 MatchResultListener* /* listener */) const {
+#if GTEST_LANG_CXX11
+ return p == nullptr;
+#else // GTEST_LANG_CXX11
 return GetRawPointer(p) == NULL;
+#endif // GTEST_LANG_CXX11
 }
 
 void DescribeTo(::std::ostream* os) const { *os << ""is NULL""; }
 class NotNullMatcher {
 template <typename Pointer>
 bool MatchAndExplain(const Pointer& p,
 MatchResultListener* /* listener */) const {
+#if GTEST_LANG_CXX11
+ return p != nullptr;
+#else // GTEST_LANG_CXX11
 return GetRawPointer(p) != NULL;
+#endif // GTEST_LANG_CXX11
 }
 
 void DescribeTo(::std::ostream* os) const { *os << ""isn't NULL""; }
",2668,534
Fix EXPECT_THAT() to support literal strings as a second argument.," TEST(SafeMatcherCastTest, ValueIsNotCopied) {
 EXPECT_TRUE(m.Matches(n));
 }
 
+TEST(ExpectThat, TakesLiterals) {
+ EXPECT_THAT(1, 1);
+ EXPECT_THAT(1.0, 1.0);
+ EXPECT_THAT(string(), """");
+}
+
+TEST(ExpectThat, TakesFunctions) {
+ struct Helper {
+ static void Func() {}
+ };
+ void (*func)() = Helper::Func;
+ EXPECT_THAT(func, Helper::Func);
+ EXPECT_THAT(func, &Helper::Func);
+}
+
 // Tests that A<T>() matches any value of type T.
 TEST(ATest, MatchesAnyValue) {
 // Tests a matcher for a value type.
",4143,556
"Mark the default constructor of Matcher<> explicit.
This prevents implicitly constructing a matcher from {}."," class Matcher : public internal::MatcherBase<T> {
 // Constructs a null matcher. Needed for storing Matcher objects in STL
 // containers. A default-constructed matcher is not yet initialized. You
 // cannot use it until a valid value has been assigned to it.
- Matcher() {}
+ explicit Matcher() {} // NOLINT
 
 // Constructs a matcher from its implementation.
 explicit Matcher(const MatcherInterface<T>* impl)
",2668,534
fully-qualify use of scoped_ptr name," using testing::internal::ThreadWithParam;
 #endif
 
 namespace posix = ::testing::internal::posix;
-using testing::internal::scoped_ptr;
 
 // Tests catching fatal failures.
 
 class DeathTestAndMultiThreadsTest : public testing::Test {
 
 private:
 SpawnThreadNotifications notifications_;
- scoped_ptr<ThreadWithParam<SpawnThreadNotifications*> > thread_;
+ testing::internal::scoped_ptr<ThreadWithParam<SpawnThreadNotifications*> >
+ thread_;
 };
 
 #endif // GTEST_IS_THREADSAFE
",586,111
"Add GTEST_ATTRIBUTE_UNUSED_ to the dummy variable generated in
INSTANTIATE_TEST_CASE_P."," internal::CartesianProductHolder10<Generator1, Generator2, Generator3,
 # define INSTANTIATE_TEST_CASE_P(prefix, test_case_name, generator) \
 ::testing::internal::ParamGenerator<test_case_name::ParamType> \
 gtest_##prefix##test_case_name##_EvalGenerator_() { return generator; } \
- int gtest_##prefix##test_case_name##_dummy_ = \
+ int gtest_##prefix##test_case_name##_dummy_ GTEST_ATTRIBUTE_UNUSED_ = \
 ::testing::UnitTest::GetInstance()->parameterized_test_registry(). \
 GetTestCasePatternHolder<test_case_name>(\
 #test_case_name, __FILE__, __LINE__)->AddTestCaseInstantiation(\
",958,69
Control death test with an #ifdef guard.," TEST_F(TestForDeathTest, AcceptsAnythingConvertibleToRE) {
 
 # endif // GTEST_HAS_GLOBAL_STRING
 
+# if !GTEST_USES_PCRE
+
 const ::std::string regex_std_str(regex_c_str);
 EXPECT_DEATH(GlobalFunction(), regex_std_str);
+
+# endif // !GTEST_USES_PCRE
 }
 
 // Tests that a non-void function can be used in a death test.
",913,154
Add GTEST_ATTRIBUTE_UNUSED_ to the dummy variable generated in INSTANTIATE_TEST_CASE_P.," internal::CartesianProductHolder10<Generator1, Generator2, Generator3,
 GTEST_TEST_CLASS_NAME_(test_case_name, test_name)>()); \
 return 0; \
 } \
- static int gtest_registering_dummy_; \
+ static int gtest_registering_dummy_ GTEST_ATTRIBUTE_UNUSED_; \
 GTEST_DISALLOW_COPY_AND_ASSIGN_(\
 GTEST_TEST_CLASS_NAME_(test_case_name, test_name)); \
 }; \
",958,69
Remove TestPrematureExitFileEnvVarIsSet," using ::testing::internal::posix::StatStruct;
 
 namespace {
 
-// Is the TEST_PREMATURE_EXIT_FILE environment variable expected to be
-// set?
-const bool kTestPrematureExitFileEnvVarShouldBeSet = false;
-
 class PrematureExitTest : public Test {
 public:
 // Returns true iff the given file exists.
 TEST_F(PrematureExitDeathTest, FileExistsDuringExecutionOfDeathTest) {
 }, """");
 }
 
-// Tests that TEST_PREMATURE_EXIT_FILE is set where it's expected to
-// be set.
-TEST_F(PrematureExitTest, TestPrematureExitFileEnvVarIsSet) {
- GTEST_INTENTIONAL_CONST_COND_PUSH_()
- if (kTestPrematureExitFileEnvVarShouldBeSet) {
- GTEST_INTENTIONAL_CONST_COND_POP_()
- const char* const filepath = GetEnv(""TEST_PREMATURE_EXIT_FILE"");
- ASSERT_TRUE(filepath != NULL);
- ASSERT_NE(*filepath, '\0');
- }
-}
-
 // Tests that the premature-exit file exists during the execution of a
 // normal (non-death) test.
 TEST_F(PrematureExitTest, PrematureExitFileExistsDuringTestExecution) {
",60,13
Add support for gtest custom printers.," template <typename T>
 
 } // namespace testing
 
+// Include any custom printer added by the local installation.
+// We must include this header at the end to make sure it can use the
+// declarations from this file.
+#include ""gtest/internal/custom/gtest-printers.h""
+
 #endif // GTEST_INCLUDE_GTEST_GTEST_PRINTERS_H_
",438,73
Change GetDefaultFilter to allow for the injection of a custom filter.," bool g_help_flag = false;
 } // namespace internal
 
 static const char* GetDefaultFilter() {
+#ifdef GTEST_TEST_FILTER_ENV_VAR_
+ const char* const testbridge_test_only = getenv(GTEST_TEST_FILTER_ENV_VAR_);
+ if (testbridge_test_only != NULL) {
+ return testbridge_test_only;
+ }
+#endif // GTEST_TEST_FILTER_ENV_VAR_
 return kUniversalFilter;
 }
 
",3189,782
"Move the selection of the flag saver implementation into gtest-port.h and
custom/gtest-port.h."," class GTEST_API_ Test {
 // internal method to avoid clashing with names used in user TESTs.
 void DeleteSelf_() { delete this; }
 
- // Uses a GTestFlagSaver to save and restore all Google Test flags.
- const internal::GTestFlagSaver* const gtest_flag_saver_;
+ const internal::scoped_ptr< GTEST_FLAG_SAVER_ > gtest_flag_saver_;
 
 // Often a user misspells SetUp() as Setup() and spends a long time
 // wondering why it is never called by Google Test. The declaration of
",716,103
Add support for --gtest_flagfile," inline std::string GetPrefixUntilComma(const char* str) {
 return comma == NULL ? str : std::string(str, comma);
 }
 
+// Splits a given string on a given delimiter, populating a given
+// vector with the fields.
+void SplitString(const ::std::string& str, char delimiter,
+ ::std::vector< ::std::string>* dest);
+
 // TypeParameterizedTest<Fixture, TestSel, Types>::Register()
 // registers a list of type-parameterized tests with Google Test. The
 // return value is insignificant - we just need to return something
",431,66
Add support for --gtest_flagfile.," INSTANTIATE_TYPED_TEST_CASE_P(My, FooTest, MyTypes);
 ::testing::internal::TemplateSel< \
 GTEST_TEST_CLASS_NAME_(CaseName, TestName)>, \
 GTEST_TYPE_PARAMS_(CaseName)>::Register(\
- """", #CaseName, #TestName, 0); \
+ """", ::testing::internal::CodeLocation(__FILE__, __LINE__), \
+ #CaseName, #TestName, 0); \
 template <typename gtest_TypeParam_> \
 void GTEST_TEST_CLASS_NAME_(CaseName, TestName)<gtest_TypeParam_>::TestBody()
 
 INSTANTIATE_TYPED_TEST_CASE_P(My, FooTest, MyTypes);
 ::testing::internal::TypeParameterizedTestCase<CaseName, \
 GTEST_CASE_NAMESPACE_(CaseName)::gtest_AllTests_, \
 ::testing::internal::TypeList< Types >::type>::Register(\
- #Prefix, #CaseName, GTEST_REGISTERED_TEST_NAMES_(CaseName))
+ #Prefix, \
+ ::testing::internal::CodeLocation(__FILE__, __LINE__), \
+ &GTEST_TYPED_TEST_CASE_P_STATE_(CaseName), \
+ #CaseName, GTEST_REGISTERED_TEST_NAMES_(CaseName))
 
 #endif // GTEST_HAS_TYPED_TEST_P
 
",34,4
Determine the existence of hash_map/hash_set in gtest-port.h.," struct _RTL_CRITICAL_SECTION;
 # include <time.h> // NOLINT
 #endif
 
+// Determines if hash_map/hash_set are available.
+// Only used for testing against those containers.
+#if !defined(GTEST_HAS_HASH_MAP_)
+# if _MSC_VER
+# define GTEST_HAS_HASH_MAP_ 1 // Indicates that hash_map is available.
+# define GTEST_HAS_HASH_SET_ 1 // Indicates that hash_set is available.
+# endif // _MSC_VER
+#endif // !defined(GTEST_HAS_HASH_MAP_)
+
 // Determines whether Google Test can use tr1/tuple. You can define
 // this macro to 0 to prevent Google Test from using tuple (any
 // feature depending on tuple with be disabled in this mode).
",677,152
Move Callback-related generated actions to a custom/ file.," def _OverloadedFunctionActionDiagnoser(msg):
 clang_regex = (_CLANG_FILE_LINE_RE + r'error: no matching '
 r'function for call to \'Invoke\'\r?\n'
 r'(.*\n)*?'
- r'.*\bgmock-\w+-actions\.h:\d+:\d+:\s+'
+ r'.*\bcallback-actions\.h:\d+:\d+:\s+'
 r'note: candidate template ignored:\s+'
 r'couldn\'t infer template argument \'FunctionImpl\'')
 diagnosis = """"""
 def _OverloadedMethodActionDiagnoser(msg):
 clang_regex = (_CLANG_FILE_LINE_RE + r'error: no matching function '
 r'for call to \'Invoke\'\r?\n'
 r'(.*\n)*?'
- r'.*\bgmock-\w+-actions\.h:\d+:\d+: '
+ r'.*\bcallback-actions\.h:\d+:\d+: '
 r'note: candidate function template not viable: '
 r'requires .*, but 2 (arguments )?were provided')
 diagnosis = """"""
",493,33
GTEST_USE_OWN_FLAGFILE support," typedef TypeWithSize<8>::Int TimeInMillis; // Represents time in milliseconds.
 # define GTEST_FLAG(name) FLAGS_gtest_##name
 #endif // !defined(GTEST_FLAG)
 
+#if !defined(GTEST_USE_OWN_FLAGFILE_FLAG_)
+# define GTEST_USE_OWN_FLAGFILE_FLAG_ 1
+#endif // !defined(GTEST_USE_OWN_FLAGFILE_FLAG_)
+
 #if !defined(GTEST_DECLARE_bool_)
 # define GTEST_FLAG_SAVER_ ::testing::internal::GTestFlagSaver
 
",677,152
Condition some code on !GTEST_HAS_MUTEX_AND_THREAD_LOCAL_," TEST(ThreadLocalTest, ParameterizedConstructorSetsDefault) {
 EXPECT_STREQ(""foo"", result.c_str());
 }
 
+# if !GTEST_HAS_MUTEX_AND_THREAD_LOCAL_
+
+// Tests in this section depend on that Google Test's own ThreadLocal
+// implementation stores a copy of the default value shared by all
+// threads. We don't want to test this for an external implementation received
+// through GTEST_HAS_MUTEX_AND_THREAD_LOCAL_.
+
 // Keeps track of whether of destructors being called on instances of
 // DestructorTracker. On Windows, waits for the destructor call reports.
 class DestructorCall {
 TEST(ThreadLocalTest, DestroysManagedObjectAtThreadExit) {
 DestructorCall::ResetList();
 }
 
+# endif // !GTEST_HAS_MUTEX_AND_THREAD_LOCAL_
+
 TEST(ThreadLocalTest, ThreadLocalMutationsAffectOnlyCurrentThread) {
 ThreadLocal<std::string> thread_local_string;
 thread_local_string.set(""Foo"");
",932,156
"Allow the single-arg Values() overload to to conversions, just like every other
overload."," class ValueArray1 {
 explicit ValueArray1(T1 v1) : v1_(v1) {}
 
 template <typename T>
- operator ParamGenerator<T>() const { return ValuesIn(&v1_, &v1_ + 1); }
+ operator ParamGenerator<T>() const {
+ const T array[] = {static_cast<T>(v1_)};
+ return ValuesIn(array);
+ }
 
 private:
 // No implementation - assignment is unsupported.
",4555,406
Add injection point for GTEST_KILLED_BY_SIGNAL_OVERRIDE.," KilledBySignal::KilledBySignal(int signum) : signum_(signum) {
 
 // KilledBySignal function-call operator.
 bool KilledBySignal::operator()(int exit_status) const {
+# if defined(GTEST_KILLED_BY_SIGNAL_OVERRIDE_)
+ {
+ bool result;
+ if (GTEST_KILLED_BY_SIGNAL_OVERRIDE_(signum_, exit_status, &result)) {
+ return result;
+ }
+ }
+# endif // defined(GTEST_KILLED_BY_SIGNAL_OVERRIDE_)
 return WIFSIGNALED(exit_status) && WTERMSIG(exit_status) == signum_;
 }
 # endif // !GTEST_OS_WINDOWS
",748,144
Inject implementation of *FromGTestEnv using macros.," TEST(Int32FromGTestEnvTest, ReturnsDefaultWhenVariableIsNotSet) {
 EXPECT_EQ(10, Int32FromGTestEnv(""temp"", 10));
 }
 
+# if !defined(GTEST_GET_INT32_FROM_ENV_)
+
 // Tests that Int32FromGTestEnv() returns the default value when the
 // environment variable overflows as an Int32.
 TEST(Int32FromGTestEnvTest, ReturnsDefaultWhenValueOverflows) {
 TEST(Int32FromGTestEnvTest, ReturnsDefaultWhenValueIsInvalid) {
 EXPECT_EQ(50, Int32FromGTestEnv(""temp"", 50));
 }
 
+# endif // !defined(GTEST_GET_INT32_FROM_ENV_)
+
 // Tests that Int32FromGTestEnv() parses and returns the value of the
 // environment variable when it represents a valid decimal integer in
 // the range of an Int32.
",5139,713
Add support for named value-parameterized tests.," TEST(ExpectFatalFailureTest, FailsWhenStatementThrows) {
 
 #endif // GTEST_HAS_EXCEPTIONS
 
+// This #ifdef block tests the output of value-parameterized tests.
+
+#if GTEST_HAS_PARAM_TEST
+
+std::string ParamNameFunc(const testing::TestParamInfo<std::string>& info) {
+ return info.param;
+}
+
+class ParamTest : public testing::TestWithParam<std::string> {
+};
+
+TEST_P(ParamTest, Success) {
+ EXPECT_EQ(""a"", GetParam());
+}
+
+TEST_P(ParamTest, Failure) {
+ EXPECT_EQ(""b"", GetParam()) << ""Expected failure"";
+}
+
+INSTANTIATE_TEST_CASE_P(PrintingStrings,
+ ParamTest,
+ testing::Values(std::string(""a"")),
+ ParamNameFunc);
+
+#endif // GTEST_HAS_PARAM_TEST
+
 // This #ifdef block tests the output of typed tests.
 #if GTEST_HAS_TYPED_TEST
 
",599,112
"Explicitly specify return value for lambda in AsStdFunction() to ensure it
works properly where return type is a reference."," TEST(MockFunctionTest, AsStdFunction) {
 EXPECT_EQ(-1, call(foo.AsStdFunction(), 1));
 EXPECT_EQ(-2, call(foo.AsStdFunction(), 2));
 }
+
+TEST(MockFunctionTest, AsStdFunctionReturnsReference) {
+ MockFunction<int&()> foo;
+ int value = 1;
+ EXPECT_CALL(foo, Call()).WillOnce(ReturnRef(value));
+ int& ref = foo.AsStdFunction()();
+ EXPECT_EQ(1, ref);
+ value = 2;
+ EXPECT_EQ(2, ref);
+}
 #endif // GTEST_HAS_STD_FUNCTION_
 
 } // namespace gmock_generated_function_mockers_test
",400,40
Fix an instance of move-pessimization.," const T& move(const T& t) {
 // similar functions users may have (e.g., implicit_cast). The internal
 // namespace alone is not enough because the function can be found by ADL.
 template<typename To>
-inline To ImplicitCast_(To x) { return ::testing::internal::move(x); }
+inline To ImplicitCast_(To x) { return x; }
 
 // When you upcast (that is, cast a pointer from type Foo to type
 // SuperclassOfFoo), it's fine to use ImplicitCast_<>, since upcasts
",731,166
Inject GTEST_EXTRA_DEATH_TEST_COMMAND_LINE_ARGS_,"
 
 #include ""gtest/gtest-death-test.h""
 #include ""gtest/internal/gtest-port.h""
+#include ""gtest/internal/custom/gtest.h""
 
 #if GTEST_HAS_DEATH_TEST
 
 class ExecDeathTest : public ForkingDeathTest {
 static ::std::vector<testing::internal::string>
 GetArgvsForDeathTestChildProcess() {
 ::std::vector<testing::internal::string> args = GetInjectableArgvs();
+# if defined(GTEST_EXTRA_DEATH_TEST_COMMAND_LINE_ARGS_)
+ ::std::vector<testing::internal::string> extra_args =
+ GTEST_EXTRA_DEATH_TEST_COMMAND_LINE_ARGS_();
+ args.insert(args.end(), extra_args.begin(), extra_args.end());
+# endif // defined(GTEST_EXTRA_DEATH_TEST_COMMAND_LINE_ARGS_)
 return args;
 }
 // The name of the file in which the death test is located.
",752,145
Inject GetArgvs() with a macro from custom/gtest-port.h.," class ScopedTrace; // Implements scoped trace.
 class TestInfoImpl; // Opaque implementation of TestInfo
 class UnitTestImpl; // Opaque implementation of UnitTest
 
-// How many times InitGoogleTest() has been called.
-GTEST_API_ extern int g_init_gtest_count;
-
 // The text used in failure messages to indicate the start of the
 // stack trace.
 GTEST_API_ extern const char kStackTraceMarker[];
",465,70
Inject GTEST_CUSTOM_TEST_EVENT_LISTENER_," void UnitTestImpl::PostFlagParsingInit() {
 if (!post_flag_parse_init_performed_) {
 post_flag_parse_init_performed_ = true;
 
+#if defined(GTEST_CUSTOM_TEST_EVENT_LISTENER_)
+ // Register to send notifications about key process state changes.
+ listeners()->Append(new GTEST_CUSTOM_TEST_EVENT_LISTENER_());
+#endif // defined(GTEST_CUSTOM_TEST_EVENT_LISTENER_)
+
 #if GTEST_HAS_DEATH_TEST
 InitDeathTestSubprocessControlInfo();
 SuppressTestEventsIfInSubprocess();
",3244,797
Inject the name of the Init function using a macro.,"
 # define GTEST_PROJECT_URL_ ""http://code.google.com/p/googletest/""
 #endif // !defined(GTEST_DEV_EMAIL_)
 
+#if !defined(GTEST_INIT_GOOGLE_TEST_NAME_)
+# define GTEST_INIT_GOOGLE_TEST_NAME_ ""testing::InitGoogleTest""
+#endif // !defined(GTEST_INIT_GOOGLE_TEST_NAME_)
+
 // Determines the version of gcc that is used to compile this.
 #ifdef __GNUC__
 // 40302 means version 4.3.2.
",731,166
Inject the custom InitGoogleTest function using a macro.," void InitGoogleTestImpl(int* argc, CharType** argv) {
 //
 // Calling the function for the second time has no user-visible effect.
 void InitGoogleTest(int* argc, char** argv) {
+#if defined(GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_)
+ GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_(argc, argv);
+#else // defined(GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_)
 internal::InitGoogleTestImpl(argc, argv);
+#endif // defined(GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_)
 }
 
 // This overloaded version can be used in Windows programs compiled in
 // UNICODE mode.
 void InitGoogleTest(int* argc, wchar_t** argv) {
+#if defined(GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_)
+ GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_(argc, argv);
+#else // defined(GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_)
 internal::InitGoogleTestImpl(argc, argv);
+#endif // defined(GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_)
 }
 
 } // namespace testing
",3246,799
Inject GTEST_EXTRA_DEATH_TEST_CHILD_SETUP," bool UnitTestImpl::RunAllTests() {
 
 #if GTEST_HAS_DEATH_TEST
 in_subprocess_for_death_test = (internal_run_death_test_flag_.get() != NULL);
+# if defined(GTEST_EXTRA_DEATH_TEST_CHILD_SETUP_)
+ if (in_subprocess_for_death_test) {
+ GTEST_EXTRA_DEATH_TEST_CHILD_SETUP_();
+ }
+# endif // defined(GTEST_EXTRA_DEATH_TEST_CHILD_SETUP_)
 #endif // GTEST_HAS_DEATH_TEST
 
 const bool should_shard = ShouldShard(kTestTotalShards, kTestShardIndex,
",3249,801
Order the initializers correctly.," void Notification::WaitForNotification() {
 }
 
 Mutex::Mutex()
- : type_(kDynamic),
- owner_thread_id_(0),
+ : owner_thread_id_(0),
+ type_(kDynamic),
 critical_section_init_phase_(0),
 critical_section_(new CRITICAL_SECTION) {
 ::InitializeCriticalSection(critical_section_);
",769,203
Templatize ParseeGoogleMockStringFlag on String type.," static bool ParseGoogleMockBoolFlag(const char* str, const char* flag,
 //
 // On success, stores the value of the flag in *value, and returns
 // true. On failure, returns false without changing *value.
+template <typename String>
 static bool ParseGoogleMockStringFlag(const char* str, const char* flag,
- std::string* value) {
+ String* value) {
 // Gets the value of the flag as a string.
 const char* const value_str = ParseGoogleMockFlagValue(str, flag, false);
 
",68,21
Inject customization point for gmock-matchers.h," inline InnerMatcher AllArgs(const InnerMatcher& matcher) { return matcher; }
 
 } // namespace testing
 
+// Include any custom callback matchers added by the local installation.
+// We must include this header at the end to make sure it can use the
+// declarations from this file.
+#include ""gmock/internal/custom/gmock-matchers.h""
 #endif // GMOCK_INCLUDE_GMOCK_GMOCK_MATCHERS_H_
-
",2669,534
Introduct GTEST_HAS_STD_SHARED_PTR_,"
 # define GTEST_HAS_STD_INITIALIZER_LIST_ 1
 # define GTEST_HAS_STD_MOVE_ 1
 # define GTEST_HAS_STD_UNIQUE_PTR_ 1
+# define GTEST_HAS_STD_SHARED_PTR_ 1
 #endif
 
 // C++11 specifies that <tuple> provides std::tuple.
",731,166
Prevent MSVC from issuing warnings about possible value truncations.," class RangeGenerator : public ParamGeneratorInterface<T> {
 return base_;
 }
 virtual void Advance() {
- value_ = value_ + step_;
+ value_ = static_cast<T>(value_ + step_);
 index_++;
 }
 virtual ParamIteratorInterface<T>* Clone() const {
 class RangeGenerator : public ParamGeneratorInterface<T> {
 const T& end,
 const IncrementT& step) {
 int end_index = 0;
- for (T i = begin; i < end; i = i + step)
+ for (T i = begin; i < end; i = static_cast<T>(i + step))
 end_index++;
 return end_index;
 }
",443,84
Injection point for GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_,"
 
 #include <string>
 #include ""gtest/gtest.h""
+#include ""gtest/internal/custom/gtest.h""
+
+#if !defined(GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_)
 
 using testing::GMOCK_FLAG(verbose);
 using testing::InitGoogleMock;
 TEST(WideInitGoogleMockTest, ParsesGoogleMockFlagAndUnrecognizedFlag) {
 TestInitGoogleMock(argv, new_argv, ""error"");
 }
 
+#endif // !defined(GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_)
+
 // Makes sure Google Mock flags can be accessed in code.
 TEST(FlagTest, IsAccessibleInCode) {
 bool dummy = testing::GMOCK_FLAG(catch_leaked_mocks) &&
",142,14
"Rename custom/callback-actions.h[.pump] =>
 custom/gmock-generated-actions.h[.pump]."," ACTION_TEMPLATE(ReturnNew,
 
 } // namespace testing
 
-// Include any custom callback actions added by the local installation.
+// Include any custom actions added by the local installation.
 // We must include this header at the end to make sure it can use the
 // declarations from this file.
-#include ""gmock/internal/custom/callback-actions.h""
+#include ""gmock/internal/custom/gmock-generated-actions.h""
 
 #endif // GMOCK_INCLUDE_GMOCK_GMOCK_GENERATED_ACTIONS_H_
",820,100
"Googlemock has some tuples containing lvalue refs in its unit tests.
These tuples are created with make_tuple, which is given temporaries.
The make_tuple is in a function argument list.

A possibly overzealous static_assert in libc++'s std::tuple ctor
is firing in our 'Perform(make_tuple(""hi""))' calls, so
we can't use its make_tuple here. Instead we will use
explicitly-constructed tuples constructed from non-temporary strings.

Workaround for llvm bug:
 https://llvm.org/bugs/show_bug.cgi?id=20855

An alternative to https://github.com/google/googletest/pull/580 ."," TEST(InvokeTest, FunctionThatTakes10Arguments) {
 TEST(InvokeTest, FunctionWithUnusedParameters) {
 Action<int(int, int, double, const string&)> a1 =
 Invoke(SumOfFirst2);
- EXPECT_EQ(12, a1.Perform(make_tuple(10, 2, 5.6, string(""hi""))));
+ string s(""hi"");
+ EXPECT_EQ(12, a1.Perform(
+ tuple<int, int, double, const string&>(10, 2, 5.6, s)));
 
 Action<int(int, int, bool, int*)> a2 =
 Invoke(SumOfFirst2);
 TEST(InvokeMethodTest, Binary) {
 Foo foo;
 Action<string(const string&, char)> a = Invoke(&foo, &Foo::Binary);
 string s(""Hell"");
- EXPECT_EQ(""Hello"", a.Perform(make_tuple(s, 'o')));
+ EXPECT_EQ(""Hello"", a.Perform(
+ tuple<const string&, char>(s, 'o')));
 }
 
 // Tests using Invoke() with a ternary method.
",513,98
Include <memory> to use std::unique_ptr.,"
 #include ""gmock/internal/gmock-internal-utils.h""
 #include <stdlib.h>
 #include <map>
+#include <memory>
 #include <string>
 #include <sstream>
 #include <vector>
",466,73
Fix unused static variable warning on Windows," namespace internal {
 
 // Valid only for fast death tests. Indicates the code is running in the
 // child process of a fast style death test.
+# if !GTEST_OS_WINDOWS
 static bool g_in_fast_death_test_child = false;
+# endif
 
 // Returns a Boolean value indicating whether the caller is currently
 // executing in the context of the death test child process. Tools such as
",752,145
Fix the googlemock autotools build.,"
 
 #include <string>
 #include ""gtest/gtest.h""
-#include ""gtest/internal/custom/gtest.h""
 
 #if !defined(GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_)
 
",141,14
Implement GetThreadCount for AIX.,"
 # include <sys/procfs.h>
 #endif // GTEST_OS_QNX
 
+#if GTEST_OS_AIX
+# include <procinfo.h>
+#endif // GTEST_OS_AIX
+
 #include ""gtest/gtest-spi.h""
 #include ""gtest/gtest-message.h""
 #include ""gtest/internal/gtest-internal.h""
 size_t GetThreadCount() {
 }
 }
 
+#elif GTEST_OS_AIX
+
+size_t GetThreadCount() {
+ struct procentry64 entry;
+ pid_t pid = getpid();
+ int status = getprocs64(&entry, sizeof(entry), NULL, 0, &pid, 1);
+ if (status == 1) {
+ return entry.pi_thcount;
+ } else {
+ return 0;
+ }
+}
+
 #else
 
 size_t GetThreadCount() {
",780,205
Add include of sys/types.h.,"
 
 #if GTEST_OS_AIX
 # include <procinfo.h>
+# include <sys/types.h>
 #endif // GTEST_OS_AIX
 
 #include ""gtest/gtest-spi.h""
",781,205
"googlemock: Support C++11 language with pre-C++11 library

This guards use of <type_traits> and its features with
GTEST_HAS_STD_TYPE_TRAITS_, and std::function with
GTEST_HAS_STD_FUNCTION_."," class MyNonDefaultConstructible {
 int value_;
 };
 
-#if GTEST_LANG_CXX11
+#if GTEST_HAS_STD_TYPE_TRAITS_
 
 TEST(BuiltInDefaultValueTest, ExistsForDefaultConstructibleType) {
 EXPECT_TRUE(BuiltInDefaultValue<MyDefaultConstructible>::Exists());
 TEST(BuiltInDefaultValueTest, IsDefaultConstructedForDefaultConstructibleType) {
 EXPECT_EQ(42, BuiltInDefaultValue<MyDefaultConstructible>::Get().value());
 }
 
-#endif // GTEST_LANG_CXX11
+#endif // GTEST_HAS_STD_TYPE_TRAITS_
 
 TEST(BuiltInDefaultValueTest, DoesNotExistForNonDefaultConstructibleType) {
 EXPECT_FALSE(BuiltInDefaultValue<MyNonDefaultConstructible>::Exists());
",892,126
"googlemock: Disable WhenDynamicCastToTest tests when RTTI is off

https://github.com/google/googletest/issues/610"," MATCHER_P(FieldIIs, inner_matcher, """") {
 return ExplainMatchResult(inner_matcher, arg.i, result_listener);
 }
 
+#if GTEST_HAS_RTTI
+
 TEST(WhenDynamicCastToTest, SameType) {
 Derived derived;
 derived.i = 4;
 TEST(WhenDynamicCastToTest, AmbiguousCast) {
 
 TEST(WhenDynamicCastToTest, Describe) {
 Matcher<Base*> matcher = WhenDynamicCastTo<Derived*>(Pointee(_));
-#if GTEST_HAS_RTTI
 const string prefix =
 ""when dynamic_cast to "" + internal::GetTypeName<Derived*>() + "", "";
-#else // GTEST_HAS_RTTI
- const string prefix = ""when dynamic_cast, "";
-#endif // GTEST_HAS_RTTI
 EXPECT_EQ(prefix + ""points to a value that is anything"", Describe(matcher));
 EXPECT_EQ(prefix + ""does not point to a value that is anything"",
 DescribeNegation(matcher));
 TEST(WhenDynamicCastToTest, BadReference) {
 EXPECT_THAT(as_base_ref, Not(WhenDynamicCastTo<const OtherDerived&>(_)));
 }
 
+#endif // GTEST_HAS_RTTI
+
 // Minimal const-propagating pointer.
 template <typename T>
 class ConstPropagatingPtr {
",4130,553
"Fix definition of GTEST_API_ macro for gcc and clang [#451].

This is to enable using gtest with -fvisibility=hidden."," using ::std::tuple_size;
 #endif // GTEST_HAS_SEH
 
 #ifdef _MSC_VER
-
 # if GTEST_LINKED_AS_SHARED_LIBRARY
 # define GTEST_API_ __declspec(dllimport)
 # elif GTEST_CREATE_SHARED_LIBRARY
 # define GTEST_API_ __declspec(dllexport)
 # endif
-
-#endif // _MSC_VER
+#elif __GNUC__ >= 4 || defined(__clang__)
+# define GTEST_API_ __attribute__((visibility (""default"")))
+#endif // _MSC_VER
 
 #ifndef GTEST_API_
 # define GTEST_API_
",731,166
Fix symbol visibility of StreamingListener.," class TestResultAccessor {
 #if GTEST_CAN_STREAM_RESULTS_
 
 // Streams test results to the given port on the given host machine.
-class StreamingListener : public EmptyTestEventListener {
+class GTEST_API_ StreamingListener : public EmptyTestEventListener {
 public:
 // Abstract base class for writing strings to a socket.
 class AbstractSocketWriter {
",524,92
Better use of character constants," TEST(IsXDigitTest, WorksForNarrowAscii) {
 }
 
 TEST(IsXDigitTest, ReturnsFalseForNarrowNonAscii) {
- EXPECT_FALSE(IsXDigit(static_cast<char>(0x80u)));
- EXPECT_FALSE(IsXDigit(static_cast<char>('0' | 0x80u)));
+ EXPECT_FALSE(IsXDigit('\x80'));
+ EXPECT_FALSE(IsXDigit(static_cast<char>('0' | '\x80')));
 }
 
 TEST(IsXDigitTest, WorksForWideAscii) {
",926,157
Fix missing-field-initializers GCC/Clang warning (issue 433).," class MutexBase {
 extern ::testing::internal::MutexBase mutex
 
 // Defines and statically (i.e. at link time) initializes a static mutex.
-// The initialization list here does not explicitly initialize each field,
-// instead relying on default initialization for the unspecified fields. In
-// particular, the owner_ field (a pthread_t) is not explicitly initialized.
-// This allows initialization to work whether pthread_t is a scalar or struct.
-// The flag -Wmissing-field-initializers must not be specified for this to work.
 # define GTEST_DEFINE_STATIC_MUTEX_(mutex) \
- ::testing::internal::MutexBase mutex = { PTHREAD_MUTEX_INITIALIZER, false }
+ ::testing::internal::MutexBase mutex = { PTHREAD_MUTEX_INITIALIZER, false, pthread_t() }
 
 // The Mutex class can only be used for mutexes created at runtime. It
 // shares its API with MutexBase otherwise.
",731,166
"Update GTEST_PROJECT_URL_ in internal/gtest-port.h

As repository moved to github. All urls need to be changed. There is
still plenty to do.","
 # define GTEST_FLAG_PREFIX_DASH_ ""gtest-""
 # define GTEST_FLAG_PREFIX_UPPER_ ""GTEST_""
 # define GTEST_NAME_ ""Google Test""
-# define GTEST_PROJECT_URL_ ""http://code.google.com/p/googletest/""
+# define GTEST_PROJECT_URL_ ""https://github.com/google/googletest/""
 #endif // !defined(GTEST_DEV_EMAIL_)
 
 #if !defined(GTEST_INIT_GOOGLE_TEST_NAME_)
",731,166
add python 3 support to tests," environ = os.environ.copy()
 
 def AssertEq(expected, actual):
 if expected != actual:
- print 'Expected: %s' % (expected,)
- print ' Actual: %s' % (actual,)
+ print('Expected: %s' % (expected,))
+ print(' Actual: %s' % (actual,))
 raise AssertionError
 
 
",45,10
Add tmux and tmux-256color to the colored terminal list.," bool ShouldUseColor(bool stdout_is_tty) {
 String::CStringEquals(term, ""xterm-256color"") ||
 String::CStringEquals(term, ""screen"") ||
 String::CStringEquals(term, ""screen-256color"") ||
+ String::CStringEquals(term, ""tmux"") ||
+ String::CStringEquals(term, ""tmux-256color"") ||
 String::CStringEquals(term, ""rxvt-unicode"") ||
 String::CStringEquals(term, ""rxvt-unicode-256color"") ||
 String::CStringEquals(term, ""linux"") ||
",3251,803
Fix link that's returned when running tests. #714," void ReportUninterestingCall(CallReaction reaction, const string& msg) {
 ""\nNOTE: You can safely ignore the above warning unless this ""
 ""call should not happen. Do not suppress it by blindly adding ""
 ""an EXPECT_CALL() if you don't mean to enforce the call. ""
- ""See http://code.google.com/p/googlemock/wiki/CookBook#""
- ""Knowing_When_to_Expect for details.\n"",
+ ""See https://github.com/google/googletest/blob/master/googlemock/docs/CookBook.md#""
+ ""knowing-when-to-expect for details.\n"",
 stack_frames_to_skip);
 break;
 default: // FAIL
",508,114
Fix compilation on MinGW with native threads," TEST(WindowsTypesTest, HANDLEIsVoidStar) {
 StaticAssertTypeEq<HANDLE, void*>();
 }
 
+#if GTEST_OS_WINDOWS_MINGW
+TEST(WindowsTypesTest, _CRITICAL_SECTIONIs_CRITICAL_SECTION) {
+ StaticAssertTypeEq<CRITICAL_SECTION, _CRITICAL_SECTION>();
+}
+#else
 TEST(WindowsTypesTest, CRITICAL_SECTIONIs_RTL_CRITICAL_SECTION) {
 StaticAssertTypeEq<CRITICAL_SECTION, _RTL_CRITICAL_SECTION>();
 }
+#endif
+
 #endif // GTEST_OS_WINDOWS
 
 } // namespace internal
",929,158
"Read Bazel's $XML_OUTPUT_FILE environment variable

If $XML_OUTPUT_FILE is set, and $GTEST_OUTPUT and --gtest_output are not
specified, produce output as if GTEST_OUTPUT=xml:$XML_OUTPUT_FILE had
been set."," bool ParseInt32(const Message& src_text, const char* str, Int32* value);
 bool BoolFromGTestEnv(const char* flag, bool default_val);
 GTEST_API_ Int32 Int32FromGTestEnv(const char* flag, Int32 default_val);
 const char* StringFromGTestEnv(const char* flag, const char* default_val);
+std::string OutputFromGTestEnv(const char * default_val);
 
 } // namespace internal
 } // namespace testing
 
 #endif // GTEST_INCLUDE_GTEST_INTERNAL_GTEST_PORT_H_
-
",732,166
Fix inconsistent style," bool ParseInt32(const Message& src_text, const char* str, Int32* value);
 bool BoolFromGTestEnv(const char* flag, bool default_val);
 GTEST_API_ Int32 Int32FromGTestEnv(const char* flag, Int32 default_val);
 const char* StringFromGTestEnv(const char* flag, const char* default_val);
-std::string OutputFromGTestEnv(const char * default_val);
+std::string OutputFromGTestEnv(const char* default_val);
 
 } // namespace internal
 } // namespace testing
",732,166
Restructure $XML_OUTPUT_FILE logic," bool ParseInt32(const Message& src_text, const char* str, Int32* value);
 // corresponding to the given Google Test flag.
 bool BoolFromGTestEnv(const char* flag, bool default_val);
 GTEST_API_ Int32 Int32FromGTestEnv(const char* flag, Int32 default_val);
-const char* StringFromGTestEnv(const char* flag, const char* default_val);
-std::string OutputFromGTestEnv(const char* default_val);
+std::string StringFromGTestEnv(const char* flag, const char* default_val);
 
 } // namespace internal
 } // namespace testing
",731,166
Fix env_var_test to ignore XML_OUTPUT_FILE if already set," class GTestEnvVarTest(gtest_test_utils.TestCase):
 def testEnvVarAffectsFlag(self):
 """"""Tests that environment variable should affect the corresponding flag.""""""
 
+ SetEnvVar('XML_OUTPUT_FILE', None)
+
 TestFlag('break_on_failure', '1', '0')
 TestFlag('color', 'yes', 'auto')
 TestFlag('filter', 'FooTest.Bar', '*')
",58,12
Fix a test to compile when tuple isn't available.," using ::testing::internal::Strings;
 using ::testing::internal::UniversalPrint;
 using ::testing::internal::UniversalPrinter;
 using ::testing::internal::UniversalTersePrint;
+#if GTEST_HAS_TR1_TUPLE || GTEST_HAS_STD_TUPLE_
 using ::testing::internal::UniversalTersePrintTupleFieldsToStrings;
+#endif
 using ::testing::internal::string;
 
 // The hash_* classes are not part of the C++ standard. STLport
",1063,169
"remove duplicated words

Signed-off-by: Li Peng <lip@dtdream.com>"," class MaxBipartiteMatchState {
 // Each element of the left_ vector represents a left hand side node
 // (i.e. an element) and each element of right_ is a right hand side
 // node (i.e. a matcher). The values in the left_ vector indicate
- // outflow from that node to a node on the the right_ side. The values
+ // outflow from that node to a node on the right_ side. The values
 // in the right_ indicate inflow, and specify which left_ node is
 // feeding that right_ node, if any. For example, left_[3] == 1 means
 // there's a flow from element #3 to matcher #1. Such a flow would also
",276,65
Performance fixes reported by cppcheck," TEST(NativeArrayTest, MethodsWork) {
 EXPECT_EQ(0, *it);
 ++it;
 EXPECT_EQ(1, *it);
- it++;
+ ++it;
 EXPECT_EQ(2, *it);
 ++it;
 EXPECT_EQ(na.end(), it);
 TEST(SkipPrefixTest, DoesNotSkipWhenPrefixDoesNotMatch) {
 EXPECT_FALSE(SkipPrefix(""world!"", &p));
 EXPECT_EQ(str, p);
 }
-
",5144,713
fix to operator precedence in GTEST_TEST_BOOLEAN_ with expressions that implement operator bool," class TestWithParam : public Test, public WithParamInterface<T> {
 // AssertionResult. For more information on how to use AssertionResult with
 // these macros see comments on that class.
 #define EXPECT_TRUE(condition) \
- GTEST_TEST_BOOLEAN_(condition, #condition, false, true, \
+ GTEST_TEST_BOOLEAN_((condition), #condition, false, true, \
 GTEST_NONFATAL_FAILURE_)
 #define EXPECT_FALSE(condition) \
 GTEST_TEST_BOOLEAN_(!(condition), #condition, true, false, \
 GTEST_NONFATAL_FAILURE_)
 #define ASSERT_TRUE(condition) \
- GTEST_TEST_BOOLEAN_(condition, #condition, false, true, \
+ GTEST_TEST_BOOLEAN_((condition), #condition, false, true, \
 GTEST_FATAL_FAILURE_)
 #define ASSERT_FALSE(condition) \
 GTEST_TEST_BOOLEAN_(!(condition), #condition, true, false, \
",686,102
Fix to tests that return object which implement operator bool," class TestWithParam : public Test, public WithParamInterface<T> {
 // AssertionResult. For more information on how to use AssertionResult with
 // these macros see comments on that class.
 #define EXPECT_TRUE(condition) \
- GTEST_TEST_BOOLEAN_((condition), #condition, false, true, \
+ GTEST_TEST_BOOLEAN_(!!(condition), #condition, false, true, \
 GTEST_NONFATAL_FAILURE_)
 #define EXPECT_FALSE(condition) \
 GTEST_TEST_BOOLEAN_(!(condition), #condition, true, false, \
 GTEST_NONFATAL_FAILURE_)
 #define ASSERT_TRUE(condition) \
- GTEST_TEST_BOOLEAN_((condition), #condition, false, true, \
+ GTEST_TEST_BOOLEAN_(!!(condition), #condition, false, true, \
 GTEST_FATAL_FAILURE_)
 #define ASSERT_FALSE(condition) \
 GTEST_TEST_BOOLEAN_(!(condition), #condition, true, false, \
",686,102
Rollback change #808.," class TestWithParam : public Test, public WithParamInterface<T> {
 // AssertionResult. For more information on how to use AssertionResult with
 // these macros see comments on that class.
 #define EXPECT_TRUE(condition) \
- GTEST_TEST_BOOLEAN_(!!(condition), #condition, false, true, \
+ GTEST_TEST_BOOLEAN_((condition), #condition, false, true, \
 GTEST_NONFATAL_FAILURE_)
 #define EXPECT_FALSE(condition) \
 GTEST_TEST_BOOLEAN_(!(condition), #condition, true, false, \
 GTEST_NONFATAL_FAILURE_)
 #define ASSERT_TRUE(condition) \
- GTEST_TEST_BOOLEAN_(!!(condition), #condition, false, true, \
+ GTEST_TEST_BOOLEAN_((condition), #condition, false, true, \
 GTEST_FATAL_FAILURE_)
 #define ASSERT_FALSE(condition) \
 GTEST_TEST_BOOLEAN_(!(condition), #condition, true, false, \
",686,102
Support running MSVC build on AppVeyour," FooTest\.
 TypedTest/0\. # TypeParam = (VeryLo{245}|class VeryLo{239})\.\.\.
 TestA
 TestB
-TypedTest/1\. # TypeParam = int\s*\*
+TypedTest/1\. # TypeParam = int\s*\*( __ptr64)?
 TestA
 TestB
 TypedTest/2\. # TypeParam = .*MyArray<bool,\s*42>
 TypedTest/2\. # TypeParam = .*MyArray<bool,\s*42>
 My/TypeParamTest/0\. # TypeParam = (VeryLo{245}|class VeryLo{239})\.\.\.
 TestA
 TestB
-My/TypeParamTest/1\. # TypeParam = int\s*\*
+My/TypeParamTest/1\. # TypeParam = int\s*\*( __ptr64)?
 TestA
 TestB
 My/TypeParamTest/2\. # TypeParam = .*MyArray<bool,\s*42>
",118,10
Reformatted the Unprintable operator== code style.," class Unprintable {
 char c_;
 };
 
-inline bool operator==(const Unprintable&, /* lhs */ const Unprintable& /* rhs */) { return true; }
+inline bool operator==(const Unprintable& /* lhs */, 
+ const Unprintable& /* rhs */) { 
+ return true; 
+}
 
 TEST(EqTest, CanDescribeSelf) {
 Matcher<Unprintable> m = Eq(Unprintable());
",4134,554
Fix build with MinGW-w64,"
 # include <io.h>
 # endif
 // In order to avoid having to include <windows.h>, use forward declaration
-#if GTEST_OS_WINDOWS_MINGW
+#if GTEST_OS_WINDOWS_MINGW && !defined(__MINGW64_VERSION_MAJOR)
 // MinGW defined _CRITICAL_SECTION and _RTL_CRITICAL_SECTION as two
 // separate (equivalent) structs, instead of using typedef
 typedef struct _CRITICAL_SECTION GTEST_CRITICAL_SECTION;
",732,166
enable null detection on Solaris Studio 12u4+," class ThreadLocal {
 GTEST_API_ size_t GetThreadCount();
 
 // Passing non-POD classes through ellipsis (...) crashes the ARM
-// compiler and generates a warning in Sun Studio. The Nokia Symbian
+// compiler and generates a warning in Sun Studio before 12u4. The Nokia Symbian
 // and the IBM XL C/C++ compiler try to instantiate a copy constructor
 // for objects passed through ellipsis (...), failing for uncopyable
 // objects. We define this to ensure that only POD is passed through
 // ellipsis on these systems.
-#if defined(__SYMBIAN32__) || defined(__IBMCPP__) || defined(__SUNPRO_CC)
+#if defined(__SYMBIAN32__) || defined(__IBMCPP__) || \
+ (defined(__SUNPRO_CC) && __SUNPRO_CC < 0x5130)
 // We lose support for NULL detection where the compiler doesn't like
 // passing non-POD classes through ellipsis (...).
 # define GTEST_ELLIPSIS_NEEDS_POD_ 1
",732,166
"Fix detection of GTEST_HAS_CLONE for Android.

This was not in Gingerbread for anything but ARM (even though the
libs were hacked to lie about it being available in gingerbread)."," using ::std::tuple_size;
 
 # if GTEST_OS_LINUX && !defined(__ia64__)
 # if GTEST_OS_LINUX_ANDROID
-// On Android, clone() is only available on ARM starting with Gingerbread.
-# if defined(__arm__) && __ANDROID_API__ >= 9
+// On Android, clone() became available at different API levels for each 32-bit
+// architecture.
+# if defined(__LP64__) || \
+ (defined(__arm__) && __ANDROID_API__ >= 9) || \
+ (defined(__mips__) && __ANDROID_API__ >= 12) || \
+ (defined(__i386__) && __ANDROID_API__ >= 17)
 # define GTEST_HAS_CLONE 1
 # else
 # define GTEST_HAS_CLONE 0
",731,166
Fix or condition typo ( '|' -> '||' )," inline int Close(int fd) { return close(fd); }
 inline const char* StrError(int errnum) { return strerror(errnum); }
 #endif
 inline const char* GetEnv(const char* name) {
-#if GTEST_OS_WINDOWS_MOBILE || GTEST_OS_WINDOWS_PHONE | GTEST_OS_WINDOWS_RT
+#if GTEST_OS_WINDOWS_MOBILE || GTEST_OS_WINDOWS_PHONE || GTEST_OS_WINDOWS_RT
 // We are on Windows CE, which has no environment variables.
 static_cast<void>(name); // To prevent 'unused argument' warning.
 return NULL;
",732,166
"Fix a typo

Help says ""FILE_PATH defaults to test_details.xml"", but the real path is test_detail.xml."," static const char kColorEncodedHelpMessage[] =
 "" @G--"" GTEST_FLAG_PREFIX_ ""output=xml@Y[@G:@YDIRECTORY_PATH@G""
 GTEST_PATH_SEP_ ""@Y|@G:@YFILE_PATH]@D\n""
 "" Generate an XML report in the given directory or with the given file\n""
-"" name. @YFILE_PATH@D defaults to @Gtest_details.xml@D.\n""
+"" name. @YFILE_PATH@D defaults to @Gtest_detail.xml@D.\n""
 #if GTEST_CAN_STREAM_RESULTS_
 "" @G--"" GTEST_FLAG_PREFIX_ ""stream_result_to=@YHOST@G:@YPORT@D\n""
 "" Stream test results to the given server.\n""
",3251,803
"Annotate ColoredPrintf with the format attribute and fix bugs.

googletest doesn't currently build with clang's very aggressive
-Wformat-nonliteral warning. It requires that all non-literal format
strings come from the argument of a function annotated with a compatible
format attribute.

Fixing that reports that ColoredPrintf's callers weren't passing the
normal -Wformat warning. Some messages were passed directly into the
format string rather than via ""%s""."," using ::std::tuple_size;
 # define GTEST_ATTRIBUTE_UNUSED_
 #endif
 
+// Use this annotation before a function that takes a printf format string.
+#if defined(__GNUC__) && !defined(COMPILER_ICC)
+# if defined(__MINGW_PRINTF_FORMAT)
+// MinGW has two different printf implementations. Ensure the format macro
+// matches the selected implementation. See
+// https://sourceforge.net/p/mingw-w64/wiki2/gnu%20printf/.
+# define GTEST_ATTRIBUTE_PRINTF_(string_index, first_to_check) \
+ __attribute__((__format__(__MINGW_PRINTF_FORMAT, string_index, \
+ first_to_check)))
+# else
+# define GTEST_ATTRIBUTE_PRINTF_(string_index, first_to_check) \
+ __attribute__((__format__(__printf__, string_index, first_to_check)))
+# endif
+#else
+# define GTEST_ATTRIBUTE_PRINTF_(string_index, first_to_check)
+#endif
+
 // A macro to disallow operator=
 // This should be used in the private: declarations for a class.
 #define GTEST_DISALLOW_ASSIGN_(type)\
",732,166
"Add GTEST_ATTRIBUTE_UNUSED_ to REGISTER_TYPED_TEST_CASE_P

If REGISTER_TYPED_TEST_CASE_P is included in a header file, but
the .cc file does not declare INSTANTIATE_TYPED_TEST_CASE_P, an
unused-variable warning may be raised by the compiler."," INSTANTIATE_TYPED_TEST_CASE_P(My, FooTest, MyTypes);
 namespace GTEST_CASE_NAMESPACE_(CaseName) { \
 typedef ::testing::internal::Templates<__VA_ARGS__>::type gtest_AllTests_; \
 } \
- static const char* const GTEST_REGISTERED_TEST_NAMES_(CaseName) = \
- GTEST_TYPED_TEST_CASE_P_STATE_(CaseName).VerifyRegisteredTestNames(\
- __FILE__, __LINE__, #__VA_ARGS__)
+ static const char* const GTEST_REGISTERED_TEST_NAMES_(CaseName) \
+ GTEST_ATTRIBUTE_UNUSED = \
+ GTEST_TYPED_TEST_CASE_P_STATE_(CaseName).VerifyRegisteredTestNames(\
+ __FILE__, __LINE__, #__VA_ARGS__)
 
 // The 'Types' template argument below must have spaces around it
 // since some compilers may choke on '>>' when passing a template
",34,4
fix typo /GTEST_ATTRIBUTE_UNUSED/GTEST_ATTRIBUTE_UNUSED_/," INSTANTIATE_TYPED_TEST_CASE_P(My, FooTest, MyTypes);
 typedef ::testing::internal::Templates<__VA_ARGS__>::type gtest_AllTests_; \
 } \
 static const char* const GTEST_REGISTERED_TEST_NAMES_(CaseName) \
- GTEST_ATTRIBUTE_UNUSED = \
+ GTEST_ATTRIBUTE_UNUSED_ = \
 GTEST_TYPED_TEST_CASE_P_STATE_(CaseName).VerifyRegisteredTestNames(\
 __FILE__, __LINE__, #__VA_ARGS__)
 
",34,4
"Changes to make TempDir() public

Fixes #1076."," bool StaticAssertTypeEq() {
 GTEST_TEST_(test_fixture, test_name, test_fixture, \
 ::testing::internal::GetTypeId<test_fixture>())
 
+// Returns a path to temporary directory.
+// Tries to determine an appropriate directory for the platform.
+GTEST_API_ std::string TempDir();
+
 } // namespace testing
 
 // Use this function in main() to run all tests. It returns 0 if all
",687,102
"Pick up GTEST_API_ definition in gtest/internal/custom/gtest-port.h.

This makes it possible for a port to define the specifier used for
exported symbols without having to change Google Test."," using ::std::tuple_size;
 
 #endif // GTEST_HAS_SEH
 
+// GTEST_API_ qualifies all symbols that must be exported. The definitions below
+// are guarded by #ifndef to give embedders a chance to define GTEST_API_ in
+// gtest/internal/custom/gtest-port.h
+#ifndef GTEST_API_
+
 #ifdef _MSC_VER
 # if GTEST_LINKED_AS_SHARED_LIBRARY
 # define GTEST_API_ __declspec(dllimport)
 using ::std::tuple_size;
 # define GTEST_API_ __attribute__((visibility (""default"")))
 #endif // _MSC_VER
 
+#endif // GTEST_API_
+
 #ifndef GTEST_API_
 # define GTEST_API_
-#endif
+#endif // GTEST_API_
 
 #ifdef __GNUC__
 // Ask the compiler to never inline a given function.
",732,166
"Fixing typo in documentation.

This upstreams a Google-internal change."," class GTEST_API_ UnitTest {
 internal::UnitTestImpl* impl() { return impl_; }
 const internal::UnitTestImpl* impl() const { return impl_; }
 
- // These classes and funcions are friends as they need to access private
+ // These classes and functions are friends as they need to access private
 // members of UnitTest.
 friend class Test;
 friend class internal::AssertHelper;
",687,102
"Use std::string and ::string explicitly in gtest and gmock code.

This merges a Google-internal change (117235625).

Original CL description:
This CL was created manually in about an hour with sed, a Python script
to find all the places unqualified 'string' was mentioned, and some help
from Emacs to add the ""std::"" qualifications, plus a few manual tweaks."," class BetweenCardinalityImpl : public CardinalityInterface {
 };
 
 // Formats ""n times"" in a human-friendly way.
-inline internal::string FormatTimes(int n) {
+inline std::string FormatTimes(int n) {
 if (n == 1) {
 return ""once"";
 } else if (n == 2) {
",89,25
"Gender-neutralize comments in gtest.h.

This merges a Google-internal change."," bool StaticAssertTypeEq() {
 // name of the test within the test case.
 //
 // A test fixture class must be declared earlier. The user should put
-// his test code between braces after using this macro. Example:
+// the test code between braces after using this macro. Example:
 //
 // class FooTest : public testing::Test {
 // protected:
",687,102
"Changes add ability to overwrite TempDir(), issue https://github.com/google/googletest/issues/1093"," void InitGoogleTest(int* argc, wchar_t** argv) {
 }
 
 std::string TempDir() {
+#if defined(GTEST_CUSTOM_TEMPDIR_FUNCTION_)
+ return GTEST_CUSTOM_TEMPDIR_FUNCTION_();
+#endif
 #if GTEST_OS_WINDOWS_MOBILE
 return ""\\temp\\"";
 #elif GTEST_OS_WINDOWS
 std::string TempDir() {
 #endif // GTEST_OS_WINDOWS_MOBILE
 }
 
-
 } // namespace testing
",3263,811
Create gtest-internal.h," namespace edit_distance {
 // Returns the optimal edits to go from 'left' to 'right'.
 // All edits cost the same, with replace having lower priority than
 // add/remove.
-// Simple implementation of the WagnerFischer algorithm.
+// Simple implementation of the Wagner-Fischer algorithm.
 // See http://en.wikipedia.org/wiki/Wagner-Fischer_algorithm
 enum EditType { kMatch, kAdd, kRemove, kReplace };
 GTEST_API_ std::vector<EditType> CalculateOptimalEdits(
",466,70
"Allow death test child to bypass WER under MinGW

The mechanics of suppressing debugger trapping and Windows Error Reporting for the crashed child process in a death test are currently guarded under the `GTEST_HAS_SEH` macro. This seems unnecessary, as the logic does not call any APIs related to Structured Error Handling.

Replace the guarding macro with the more permissive `GTEST_OS_WINDOWS`, so that Windows toolchains without SEH support (e.g. MinGW) can benefit from it.

Fixes: #1116"," int UnitTest::Run() {
 // used for the duration of the program.
 impl()->set_catch_exceptions(GTEST_FLAG(catch_exceptions));
 
-#if GTEST_HAS_SEH
+#if GTEST_OS_WINDOWS
 // Either the user wants Google Test to catch exceptions thrown by the
 // tests or this is executing in the context of death test child
 // process. In either case the user does not want to see pop-up dialogs
 int UnitTest::Run() {
 _WRITE_ABORT_MSG | _CALL_REPORTFAULT); // pop-up window, core dump.
 # endif
 }
-#endif // GTEST_HAS_SEH
+#endif // GTEST_OS_WINDOWS
 
 return internal::HandleExceptionsInMethodIfSupported(
 impl(),
",3263,811
"Fixed misspelling in assertion message.

This upstreams a Google-internal change (146491438)."," class SafeMatcherCastImpl {
 // type U.
 GTEST_COMPILE_ASSERT_(
 internal::is_reference<T>::value || !internal::is_reference<U>::value,
- cannot_convert_non_referentce_arg_to_reference);
+ cannot_convert_non_reference_arg_to_reference);
 // In case both T and U are arithmetic types, enforce that the
 // conversion is not lossy.
 typedef GTEST_REMOVE_REFERENCE_AND_CONST_(T) RawT;
",2667,534
"Fix typo in gmock-actions.h

This upstreams a Google-internal change (141765019)."," class DoBothAction {
 // return sqrt(x*x + y*y);
 // }
 // ...
-// EXEPCT_CALL(mock, Foo(""abc"", _, _))
+// EXPECT_CALL(mock, Foo(""abc"", _, _))
 // .WillOnce(Invoke(DistanceToOriginWithLabel));
-// EXEPCT_CALL(mock, Bar(5, _, _))
+// EXPECT_CALL(mock, Bar(5, _, _))
 // .WillOnce(Invoke(DistanceToOriginWithIndex));
 //
 // you could write
 class DoBothAction {
 // return sqrt(x*x + y*y);
 // }
 // ...
-// EXEPCT_CALL(mock, Foo(""abc"", _, _)).WillOnce(Invoke(DistanceToOrigin));
-// EXEPCT_CALL(mock, Bar(5, _, _)).WillOnce(Invoke(DistanceToOrigin));
+// EXPECT_CALL(mock, Foo(""abc"", _, _)).WillOnce(Invoke(DistanceToOrigin));
+// EXPECT_CALL(mock, Bar(5, _, _)).WillOnce(Invoke(DistanceToOrigin));
 typedef internal::IgnoredValue Unused;
 
 // This constructor allows us to turn an Action<From> object into an
",615,107
"Fix background color in ColoredPrintf

Re-use existing background color for Widows' console window.
This fixes a problem where the background color for ColoredPrintf would be BLACK even if the user's console is using a different BG color."," void ColoredPrintf(GTestColor color, const char* fmt, ...) {
 CONSOLE_SCREEN_BUFFER_INFO buffer_info;
 GetConsoleScreenBufferInfo(stdout_handle, &buffer_info);
 const WORD old_color_attrs = buffer_info.wAttributes;
-
+ // Let's reuse the BG
+ const WORD existing_bg = old_color_attrs & 0x00F0;
+ 
 // We need to flush the stream buffers into the console before each
 // SetConsoleTextAttribute call lest it affect the text that is already
 // printed but has not yet reached the console.
 fflush(stdout);
 SetConsoleTextAttribute(stdout_handle,
- GetColorAttribute(color) | FOREGROUND_INTENSITY);
+ GetColorAttribute(color) | existing_bg | FOREGROUND_INTENSITY);
 vprintf(fmt, args);
 
 fflush(stdout);
",3264,811
Add background_mask instead of using magic number," void ColoredPrintf(GTestColor color, const char* fmt, ...) {
 GetConsoleScreenBufferInfo(stdout_handle, &buffer_info);
 const WORD old_color_attrs = buffer_info.wAttributes;
 // Let's reuse the BG
- const WORD existing_bg = old_color_attrs & 0x00F0;
+ const WORD background_mask = BACKGROUND_BLUE | BACKGROUND_GREEN | BACKGROUND_RED | BACKGROUND_INTENSITY; 
+ const WORD existing_bg = old_color_attrs & background_mask;
 
 // We need to flush the stream buffers into the console before each
 // SetConsoleTextAttribute call lest it affect the text that is already
",3265,811
Colouring in help text," static const char kColorEncodedHelpMessage[] =
 ""Test Output:\n""
 "" @G--"" GTEST_FLAG_PREFIX_ ""color=@Y(@Gyes@Y|@Gno@Y|@Gauto@Y)@D\n""
 "" Enable/disable colored output. The default is @Gauto@D.\n""
-"" -@G-"" GTEST_FLAG_PREFIX_ ""print_time=0@D\n""
+"" @G--"" GTEST_FLAG_PREFIX_ ""print_time=0@D\n""
 "" Don't print the elapsed time of each test.\n""
 "" @G--"" GTEST_FLAG_PREFIX_ ""output=xml@Y[@G:@YDIRECTORY_PATH@G""
 GTEST_PATH_SEP_ ""@Y|@G:@YFILE_PATH]@D\n""
",3263,811
Remove unnecessary const," int GetBgOffset(WORD background_mask) {
 return bitOffset;
 }
 
-WORD GetNewColor(const GTestColor color, const WORD old_color_attrs) {
+WORD GetNewColor(GTestColor color, WORD old_color_attrs) {
 // Let's reuse the BG
 static const WORD background_mask = BACKGROUND_BLUE | BACKGROUND_GREEN | BACKGROUND_RED | BACKGROUND_INTENSITY;
 static const WORD foreground_mask = FOREGROUND_BLUE | FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_INTENSITY;
",3281,816
"Use wider types to prevent unsigned overflow diagnostics

The rest of the (covered) codebase is already integer overflow clean.
This is a cherry-pick of an internal change.

TESTED=gtest_shuffle_test goes from fail to pass with -fsanitize=integer"," namespace internal {
 // than kMaxRange.
 UInt32 Random::Generate(UInt32 range) {
 // These constants are the same as are used in glibc's rand(3).
- state_ = (1103515245U*state_ + 12345U) % kMaxRange;
+ // Use wider types than necessary to prevent unsigned overflow diagnostics.
+ state_ = static_cast<UInt32>(1103515245ULL*state_ + 12345U) % kMaxRange;
 
 GTEST_CHECK_(range > 0)
 << ""Cannot generate a number in the range [0, 0)."";
",3263,811
Correct some typos in a comment," TEST(ActionTemplateTest, WorksForIntegralTemplateParams) {
 EXPECT_FALSE(b); // Verifies that resetter is deleted.
 }
 
-// Tests that ACTION_TEMPLATES works for template parameters.
+// Tests that ACTION_TEMPLATE works for a template with template parameters.
 ACTION_TEMPLATE(ReturnSmartPointer,
 HAS_1_TEMPLATE_PARAMS(template <typename Pointee> class,
 Pointer),
",884,163
fix small typo in comment," class QueueTest : public testing::Test {
 // accessed from sub-classes.
 
 // virtual void SetUp() will be called before each test is run. You
- // should define it if you need to initialize the varaibles.
+ // should define it if you need to initialize the variables.
 // Otherwise, this can be skipped.
 virtual void SetUp() {
 q1_.Enqueue(1);
",47,7
Samples changes upstreaming,"
 #include <stdio.h>
 #include <stdlib.h>
 
-#include ""gtest/gtest.h""
-namespace {
+#include ""third_party/gtest/include/gtest/gtest.h""
 using ::testing::EmptyTestEventListener;
 using ::testing::InitGoogleTest;
 using ::testing::Test;
 using ::testing::TestPartResult;
 using ::testing::UnitTest;
 
 namespace {
-
 // We will track memory used by this class.
 class Water {
 public:
 TEST(ListenersTest, LeaksWater) {
 Water* water = new Water;
 EXPECT_TRUE(water != NULL);
 }
-
 } // namespace
 
 int main(int argc, char **argv) {
 int main(int argc, char **argv) {
 }
 return RUN_ALL_TESTS();
 }
-} // namespace
\ No newline at end of file
",61,11
"Pass MSVC's C4826 warning.

MSVC has an optional warning which flags when 32-bit pointers get cast
into a 64-bit value. This is a little overaggressive I think, but to
ease compiling in projects with aggressive warnings, fix this by just
casting to const void * directly. Modern GCCs seem to compile it just
fine."," void DefaultPrintTo(WrapPrinterType<kPrintFunctionPointer> /* dummy */,
 *os << ""NULL"";
 } else {
 // T is a function type, so '*os << p' doesn't do what we want
- // (it just prints p as bool). We want to print p as a const
- // void*. However, we cannot cast it to const void* directly,
- // even using reinterpret_cast, as earlier versions of gcc
- // (e.g. 3.4.5) cannot compile the cast when p is a function
- // pointer. Casting to UInt64 first solves the problem.
- *os << reinterpret_cast<const void*>(
- reinterpret_cast<internal::UInt64>(p));
+ // (it just prints p as bool). Cast p to const void* to print it.
+ *os << reinterpret_cast<const void*>(p);
 }
 }
 
",485,81
Infinite Loop when calling a mock function that takes boost::filesystem::path as parameter #521: Add is_same type trait," template <bool bool_value> const bool bool_constant<bool_value>::value;
 typedef bool_constant<false> false_type;
 typedef bool_constant<true> true_type;
 
+template <typename T, typename U>
+struct is_same : public false_type {};
+
+template <typename T>
+struct is_same<T, T> : public true_type {};
+
 template <typename T>
 struct is_pointer : public false_type {};
 
",736,166
Infinite Loop when calling a mock function that takes boost::filesystem::path as parameter #521: Add is_same type trait and prevent infinite loops for recursive containers," template <bool bool_value> const bool bool_constant<bool_value>::value;
 typedef bool_constant<false> false_type;
 typedef bool_constant<true> true_type;
 
+template <typename T, typename U>
+struct is_same : public false_type {};
+
+template <typename T>
+struct is_same<T, T> : public true_type {};
+
 template <typename T>
 struct is_pointer : public false_type {};
 
",736,166
Adding a flag option to change the default mock type," enum CallReaction {
 kAllow,
 kWarn,
 kFail,
- kDefault = kWarn // By default, warn about uninteresting calls.
 };
 
 } // namespace internal
",955,151
"Initial Revision, review 164634031","
 
 #include ""sample3-inl.h""
 #include ""gtest/gtest.h""
-namespace{
+namespace {
 // To use a test fixture, derive a class from testing::Test.
 class QueueTestSmpl3 : public testing::Test {
 protected: // You should make the members protected s.t. they can be
",49,7
Fix scoped enum not working in gmock-gen.py," class AstBuilder(object):
 return self._GetNestedType(Union)
 
 def handle_enum(self):
+ token = self._GetNextToken()
+ if not (token.token_type == tokenize.NAME and token.name == 'class'):
+ self._AddBackToken(token)
 return self._GetNestedType(Enum)
 
 def handle_auto(self):
",1250,390
Added support for WINAPI_PARTITION_TV_TITLE which is defined on XboxOne," namespace {
 AssertionResult HRESULTFailureHelper(const char* expr,
 const char* expected,
 long hr) { // NOLINT
-# if GTEST_OS_WINDOWS_MOBILE
+# if GTEST_OS_WINDOWS_MOBILE || GTEST_OS_WINDOWS_TV_TITLE
 
 // Windows CE doesn't support FormatMessage.
 const char error_text[] = """";
",3251,803
Removed extra colon in error log," void ReportInvalidTestCaseType(const char* test_case_name,
 
 GTEST_LOG_(ERROR) 
 << FormatFileLocation(code_location.file.c_str(),
- code_location.line),
+ code_location.line)
 << "" "" << errors.GetString();
 }
 #endif // GTEST_HAS_PARAM_TEST
",3286,816
Add function name to exception if there's no default action," UntypedFunctionMockerBase::UntypedInvokeWith(const void* const untyped_args)
 
 if (!need_to_report_uninteresting_call) {
 // Perform the action without printing the call information.
- return this->UntypedPerformDefaultAction(untyped_args, """");
+ return this->UntypedPerformDefaultAction(untyped_args, ""Function call: "" + std::string(Name()));
 }
 
 // Warns about the uninteresting call.
",507,114
Handling invalid flag values," bool UntypedFunctionMockerBase::VerifyAndClearExpectationsLocked()
 return expectations_met;
 }
 
+CallReaction intToCallReaction(int mock_behavior) {
+ if (mock_behavior >= kAllow && mock_behavior <= kFail) {
+ return static_cast<internal::CallReaction>(mock_behavior);
+ }
+ return kWarn;
+}
+
 } // namespace internal
 
 // Class Mock.
 internal::CallReaction Mock::GetReactionOnUninterestingCalls(
 GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex) {
 internal::MutexLock l(&internal::g_gmock_mutex);
 return (g_uninteresting_call_reaction.count(mock_obj) == 0) ?
- static_cast<internal::CallReaction>(GMOCK_FLAG(default_mock_behavior)) :
+ internal::intToCallReaction(GMOCK_FLAG(default_mock_behavior)) :
 g_uninteresting_call_reaction[mock_obj];
 }
 
",514,117
adds test for NiceMock with unknown return value," class MockFoo : public Foo {
 
 MOCK_METHOD0(DoThis, void());
 MOCK_METHOD1(DoThat, int(bool flag));
+ MOCK_METHOD0(ReturnSomething, Mock());
 
 private:
 GTEST_DISALLOW_COPY_AND_ASSIGN_(MockFoo);
 TEST(NiceMockTest, AllowsExpectedCall) {
 nice_foo.DoThis();
 }
 
+// Tests that an unexpected call on a nice mock which returns a non-built in
+// default value throws an exception and the exception contains the name of
+// the method.
+TEST(NiceMockTest, ThrowsExceptionForUnknownReturnTypes) {
+NiceMock<MockFoo> nice_foo;
+try{
+nice_foo.ReturnSomething();
+FAIL();
+} catch (const std::runtime_error& ex) {
+const std::string exception_msg(ex.what());
+EXPECT_NE(exception_msg.find(""ReturnSomething""), std::string::npos);
+}
+}
+
 // Tests that an unexpected call on a nice mock fails.
 TEST(NiceMockTest, UnexpectedCallFails) {
 NiceMock<MockFoo> nice_foo;
",244,37
Fix test if exceptions are not supported," TEST(NiceMockTest, AllowsExpectedCall) {
 // the method.
 TEST(NiceMockTest, ThrowsExceptionForUnknownReturnTypes) {
 NiceMock<MockFoo> nice_foo;
+#if GTEST_HAS_EXCEPTIONS
 try{
 nice_foo.ReturnSomething();
 FAIL();
 TEST(NiceMockTest, ThrowsExceptionForUnknownReturnTypes) {
 const std::string exception_msg(ex.what());
 EXPECT_NE(exception_msg.find(""ReturnSomething""), std::string::npos);
 }
+#else
+EXPECT_DEATH_IF_SUPPORTED({
+nice_foo.ReturnSomething();
+}, """");
+#endif
 }
 
 // Tests that an unexpected call on a nice mock fails.
",247,38
Switch return type to class without default constructor," using testing::internal::CaptureStdout;
 using testing::internal::GetCapturedStdout;
 #endif
 
+// Dummy class without default constructor.
+class Dummy {
+ public:
+ Dummy(int) {}
+};
+
 // Defines some mock classes needed by the tests.
 
 class Foo {
 class MockFoo : public Foo {
 
 MOCK_METHOD0(DoThis, void());
 MOCK_METHOD1(DoThat, int(bool flag));
- MOCK_METHOD0(ReturnSomething, Mock());
+ MOCK_METHOD0(ReturnSomething, Dummy());
 
 private:
 GTEST_DISALLOW_COPY_AND_ASSIGN_(MockFoo);
",251,39
Change tabs to spaces in test case," TEST(NiceMockTest, AllowsExpectedCall) {
 // default value throws an exception and the exception contains the name of
 // the method.
 TEST(NiceMockTest, ThrowsExceptionForUnknownReturnTypes) {
-NiceMock<MockFoo> nice_foo;
+ NiceMock<MockFoo> nice_foo;
 #if GTEST_HAS_EXCEPTIONS
-try{
-nice_foo.ReturnSomething();
-FAIL();
-} catch (const std::runtime_error& ex) {
-const std::string exception_msg(ex.what());
-EXPECT_NE(exception_msg.find(""ReturnSomething""), std::string::npos);
-}
+ try {
+ nice_foo.ReturnSomething();
+ FAIL();
+ } catch (const std::runtime_error& ex) {
+ const std::string exception_msg(ex.what());
+ EXPECT_NE(exception_msg.find(""ReturnSomething""), std::string::npos);
+ }
 #else
-EXPECT_DEATH_IF_SUPPORTED({
-nice_foo.ReturnSomething();
-}, """");
+ EXPECT_DEATH_IF_SUPPORTED({
+ nice_foo.ReturnSomething();
+ }, """");
 #endif
 }
 
",251,39
"Added ""explicit"" as per compiler suggestion"," using testing::internal::GetCapturedStdout;
 // Class without default constructor.
 class NotDefaultConstructible {
 public:
- NotDefaultConstructible(int) {}
+ explicit NotDefaultConstructible(int) {}
 };
 
 // Defines some mock classes needed by the tests.
",249,39
Remove unused variable," TEST(NiceMockTest, ThrowsExceptionForUnknownReturnTypes) {
 nice_foo.ReturnNonDefaultConstructible();
 FAIL();
 } catch (const std::runtime_error& ex) {
- const std::string exception_msg(ex.what());
 EXPECT_THAT(ex.what(), HasSubstr(""ReturnNonDefaultConstructible""));
 }
 #else
",248,39
Support ref-qualified member functions in Property().," class AClass {
 // A getter that returns a reference to const.
 const std::string& s() const { return s_; }
 
+#if GTEST_LANG_CXX11
+ const std::string& s_ref() const & { return s_; }
+#endif
+
 void set_s(const std::string& new_s) { s_ = new_s; }
 
 // A getter that returns a reference to non-const.
 double& x() const { return x_; }
+
 private:
 int n_;
 std::string s_;
 TEST(PropertyTest, WorksForReferenceToConstProperty) {
 EXPECT_FALSE(m.Matches(a));
 }
 
+#if GTEST_LANG_CXX11
+// Tests that Property(&Foo::property, ...) works when property() is
+// ref-qualified.
+TEST(PropertyTest, WorksForRefQualifiedProperty) {
+ Matcher<const AClass&> m = Property(&AClass::s_ref, StartsWith(""hi""));
+
+ AClass a;
+ a.set_s(""hill"");
+ EXPECT_TRUE(m.Matches(a));
+
+ a.set_s(""hole"");
+ EXPECT_FALSE(m.Matches(a));
+}
+#endif
+
 // Tests that Property(&Foo::property, ...) works when property()
 // returns a reference to non-const.
 TEST(PropertyTest, WorksForReferenceToNonConstProperty) {
",4149,556
"Speed up printing of characters which need hex escaping

This change speeds up the runtime of a value-parameterized test I have
which has lots of values with large strings full of unprintable
characters by 2x. I profiled it and traced most of the slowness during
googletest startup down to the way String::FormatHexInt was creating and
destroyed a stringstream for each character in the string for each
value."," static CharFormat PrintAsCharLiteralTo(Char c, ostream* os) {
 *os << static_cast<char>(c);
 return kAsIs;
 } else {
- *os << ""\\x"" + String::FormatHexInt(static_cast<UnsignedChar>(c));
+ ostream::fmtflags flags = os->flags();
+ *os << ""\\x"" << std::hex << std::uppercase
+ << static_cast<int>(static_cast<UnsignedChar>(c));
+ os->flags(flags);
 return kHexEscape;
 }
 }
",212,52
fix typo in comment and string (SetUpTestCase)," TEST(DISABLED_TestCase, DISABLED_TestShouldNotRun) {
 FAIL() << ""Unexpected failure: Test in disabled test case should not be run."";
 }
 
-// Check that when all tests in a test case are disabled, SetupTestCase() and
+// Check that when all tests in a test case are disabled, SetUpTestCase() and
 // TearDownTestCase() are not called.
 class DisabledTestsTest : public Test {
 protected:
 static void SetUpTestCase() {
 FAIL() << ""Unexpected failure: All tests disabled in test case. ""
- ""SetupTestCase() should not be called."";
+ ""SetUpTestCase() should not be called."";
 }
 
 static void TearDownTestCase() {
",5144,713
remove unused TestCase import,"
 using ::testing::EmptyTestEventListener;
 using ::testing::InitGoogleTest;
 using ::testing::Test;
-using ::testing::TestCase;
 using ::testing::TestEventListeners;
 using ::testing::TestInfo;
 using ::testing::TestPartResult;
",60,11
"Detect Fuchsia, and set GTEST_HAS_PTHREAD on GTEST_OS_FUCHSIA","
 // GTEST_OS_AIX - IBM AIX
 // GTEST_OS_CYGWIN - Cygwin
 // GTEST_OS_FREEBSD - FreeBSD
+// GTEST_OS_FUCHSIA - Fuchsia
 // GTEST_OS_HPUX - HP-UX
 // GTEST_OS_LINUX - Linux
 // GTEST_OS_LINUX_ANDROID - Google Android
 typedef struct _RTL_CRITICAL_SECTION GTEST_CRITICAL_SECTION;
 //
 // To disable threading support in Google Test, add -DGTEST_HAS_PTHREAD=0
 // to your compiler flags.
-# define GTEST_HAS_PTHREAD (GTEST_OS_LINUX || GTEST_OS_MAC || GTEST_OS_HPUX \
- || GTEST_OS_QNX || GTEST_OS_FREEBSD || GTEST_OS_NACL || GTEST_OS_NETBSD)
+#define GTEST_HAS_PTHREAD \
+ (GTEST_OS_LINUX || GTEST_OS_MAC || GTEST_OS_HPUX || GTEST_OS_QNX || \
+ GTEST_OS_FREEBSD || GTEST_OS_NACL || GTEST_OS_NETBSD || GTEST_OS_FUCHSIA)
 #endif // GTEST_HAS_PTHREAD
 
 #if GTEST_HAS_PTHREAD
",736,166
change links from former code.google.com to current github repository," DoAll(Action1 a1, Action2 a2, Action3 a3, Action4 a4, Action5 a5, Action6 a6,
 // MORE INFORMATION:
 //
 // To learn more about using these macros, please search for 'ACTION'
-// on http://code.google.com/p/googlemock/wiki/CookBook.
+// on https://github.com/google/googletest/blob/master/googlemock/docs/CookBook.md
 
 // An internal macro needed for implementing ACTION*().
 #define GMOCK_ACTION_ARG_TYPES_AND_NAMES_UNUSED_\
",820,100
"Allow macros inside of parametrized test names.

This allows doing things like TEST_P(TestFixture, MAYBE(TestName)) for nicer conditional test disabling."," TEST_P(NamingTest, TestsReportCorrectNamesAndParameters) {
 
 INSTANTIATE_TEST_CASE_P(ZeroToFiveSequence, NamingTest, Range(0, 5));
 
+// Tests that macros in test names are expanded correctly.
+class MacroNamingTest : public TestWithParam<int> {};
+
+#define PREFIX_WITH_FOO(test_name) FOO_##test_name
+#define PREFIX_WITH_MACRO(test_name) Macro##test_name
+
+TEST_P(PREFIX_WITH_MACRO(NamingTest), PREFIX_WITH_FOO(SomeTestName)) {
+ const ::testing::TestInfo* const test_info =
+ ::testing::UnitTest::GetInstance()->current_test_info();
+
+ EXPECT_STREQ(""FortyTwo/MacroNamingTest"", test_info->test_case_name());
+ EXPECT_STREQ(""FOO_SomeTestName"", test_info->name());
+}
+
+INSTANTIATE_TEST_CASE_P(FortyTwo, MacroNamingTest, Values(42));
+
 // Tests that user supplied custom parameter names are working correctly.
 // Runs the test with a builtin helper method which uses PrintToString,
 // as well as a custom function and custom functor to ensure all possible
",689,108
Add a non-parametrized test.," TEST_P(PREFIX_WITH_MACRO(NamingTest), PREFIX_WITH_FOO(SomeTestName)) {
 
 INSTANTIATE_TEST_CASE_P(FortyTwo, MacroNamingTest, Values(42));
 
+// Tests the same thing for non-parametrized tests.
+class MacroNamingTestNonParametrized : public ::testing::Test {};
+
+TEST_F(PREFIX_WITH_MACRO(NamingTestNonParametrized),
+ PREFIX_WITH_FOO(SomeTestName)) {
+ const ::testing::TestInfo* const test_info =
+ ::testing::UnitTest::GetInstance()->current_test_info();
+
+ EXPECT_STREQ(""MacroNamingTestNonParametrized"", test_info->test_case_name());
+ EXPECT_STREQ(""FOO_SomeTestName"", test_info->name());
+}
+
 // Tests that user supplied custom parameter names are working correctly.
 // Runs the test with a builtin helper method which uses PrintToString,
 // as well as a custom function and custom functor to ensure all possible
",697,109
"avoid -Wshadow warning on GCC

When using INSTANTIATE_TEST_CASE_P with a lambda function which uses
'info' as parameter name, GCC complains that this would shadow
parameter 'info' used in the macro's VA_ARGS call."," TEST_P(CustomLambdaNamingTest, CustomTestNames) {}
 INSTANTIATE_TEST_CASE_P(CustomParamNameLambda,
 CustomLambdaNamingTest,
 Values(std::string(""LambdaName"")),
- [](const ::testing::TestParamInfo<std::string>& info) {
- return info.param;
+ [](const ::testing::TestParamInfo<std::string>& tpinfo) {
+ return tpinfo.param;
 });
 
 #endif // GTEST_LANG_CXX11
",681,107
avoid warning about unused variable," class UnitTestRecordPropertyTestEnvironment : public Environment {
 };
 
 // This will test property recording outside of any test or test case.
-static Environment* record_property_env =
+Environment* record_property_env =
 AddGlobalTestEnvironment(new UnitTestRecordPropertyTestEnvironment);
 
 // This group of tests is for predicate assertions (ASSERT_PRED*, etc)
 TEST(AssertionSyntaxTest, WorksWithConst) {
 
 } // namespace
 
+// we don't use the variable further, just avoid compiler warning
+// by defining a function which uses it
+void dummy_use_of_record_property_env() {
+(void) record_property_env;
+}
+
 namespace testing {
 
 // Tests that Google Test tracks SUCCEED*.
",5147,714
"remove GTEST_HAS_PARAM_TESTS

As mentioned in issue #360:
""Now that all the platforms gtest supports work with value-parameterized
tests, we should remove the uses of the GTEST_HAS_PARAM_TESTS macro from
the codebase everywhere.""
https://github.com/google/googletest/issues/360"," TEST_P(DerivedTest, DoesBlah) {
 # include <utility>
 #endif
 
-// scripts/fuse_gtest.py depends on gtest's own header being #included
-// *unconditionally*. Therefore these #includes cannot be moved
-// inside #if GTEST_HAS_PARAM_TEST.
 #include ""gtest/internal/gtest-internal.h""
 #include ""gtest/internal/gtest-param-util.h""
 #include ""gtest/internal/gtest-param-util-generated.h""
 
-#if GTEST_HAS_PARAM_TEST
-
 namespace testing {
 
 // Functions producing parameter generators.
 internal::CartesianProductHolder10<Generator1, Generator2, Generator3,
 
 } // namespace testing
 
-#endif // GTEST_HAS_PARAM_TEST
-
 #endif // GTEST_INCLUDE_GTEST_GTEST_PARAM_TEST_H_
",958,69
use GTEST_ATTRIBUTE_UNUSED_ instead of dummy function," class UnitTestRecordPropertyTestEnvironment : public Environment {
 };
 
 // This will test property recording outside of any test or test case.
-Environment* record_property_env =
+Environment* record_property_env GTEST_ATTRIBUTE_UNUSED_ =
 AddGlobalTestEnvironment(new UnitTestRecordPropertyTestEnvironment);
 
 // This group of tests is for predicate assertions (ASSERT_PRED*, etc)
 TEST(AssertionSyntaxTest, WorksWithConst) {
 
 } // namespace
 
-// we don't use the variable further, just avoid compiler warning
-// by defining a function which uses it
-void dummy_use_of_record_property_env() {
-(void) record_property_env;
-}
-
 namespace testing {
 
 // Tests that Google Test tracks SUCCEED*.
",5144,713
"Make the failure messages from EXPECT_EQ and friends actually symmetric,

instead of reading more like reversing the former ""expected"" and ""actual""
roles of the LHS and RHS arguments.

This patch is manually applied from internal version (125109873)"," AssertionResult EqFailure(const char* lhs_expression,
 const std::string& rhs_value,
 bool ignoring_case) {
 Message msg;
- msg << "" Expected: "" << lhs_expression;
+ msg << ""Expected equality of these values:"";
+ msg << ""\n "" << lhs_expression;
 if (lhs_value != lhs_expression) {
- msg << ""\n Which is: "" << lhs_value;
+ msg << ""\n Which is: "" << lhs_value;
 }
- msg << ""\nTo be equal to: "" << rhs_expression;
+ msg << ""\n "" << rhs_expression;
 if (rhs_value != rhs_expression) {
- msg << ""\n Which is: "" << rhs_value;
+ msg << ""\n Which is: "" << rhs_value;
 }
 
 if (ignoring_case) {
",3278,816
"Remove redundant declaration

TempDir() function is declared twice, once in `internal/gtest-port.h`
and a second time in `gtest.h`.

Fixes a warning with GCC when -Wredundant-decls is given."," std::string StringFromGTestEnv(const char* flag, const char* default_val);
 
 } // namespace internal
 
-// Returns a path to temporary directory.
-// Tries to determine an appropriate directory for the platform.
-GTEST_API_ std::string TempDir();
-
 } // namespace testing
 
 #endif // GTEST_INCLUDE_GTEST_INTERNAL_GTEST_PORT_H_
",735,166
"Swap reinterpret_cast for static_cast

Swap reinterpret_cast for static_cast"," class TypeWithoutFormatter {
 public:
 // This default version is called when kTypeKind is kOtherType.
 static void PrintValue(const T& value, ::std::ostream* os) {
- PrintBytesInObjectTo(reinterpret_cast<const unsigned char*>(
- reinterpret_cast<const void *>(&value)),
+ PrintBytesInObjectTo(static_cast<const unsigned char*>(
+ reinterpret_cast<const void *>(&value)),
 sizeof(value), os);
 }
 };
",488,82
Use gender-neutral pronouns in comments and docs," class FunctionMockerBase : public UntypedFunctionMockerBase {
 // There is no generally useful and implementable semantics of
 // copying a mock object, so copying a mock is usually a user error.
 // Thus we disallow copying function mockers. If the user really
- // wants to copy a mock object, he should implement his own copy
+ // wants to copy a mock object, they should implement their own copy
 // operation, for example:
 //
 // class MockFoo : public Foo {
",955,151
Fix tests with VS2015 and VS2017,"
 # include <forward_list> // NOLINT
 #endif
 
+// Disable MSVC2015 warning for std::pair: ""decorated name length exceeded, name was truncated"".
+#if defined(_MSC_VER) && (_MSC_VER == 1900)
+# pragma warning(disable:4503)
+#endif
+
 namespace testing {
 
 namespace internal {
",4149,556
Fix gmock tests when std::unary_function unavailable," TEST(ResultOfTest, WorksForFunctionReferences) {
 
 // Tests that ResultOf(f, ...) compiles and works as expected when f is a
 // function object.
-struct Functor : public ::std::unary_function<int, std::string> {
- result_type operator()(argument_type input) const {
+struct Functor {
+ typedef std::string result_type;
+ typedef int argument_type;
+
+ std::string operator()(int input) const {
 return IntToStringFunction(input);
 }
 };
",4151,556
"fix for VS2017 deprecation of ::tr1::tuple
change static_cast to ImplicitCast_ for consitency
fixes for building with path names containing spaces"," typedef struct _RTL_CRITICAL_SECTION GTEST_CRITICAL_SECTION;
 # if GTEST_OS_LINUX_ANDROID && defined(_STLPORT_MAJOR)
 // STLport, provided with the Android NDK, has neither <tr1/tuple> or <tuple>.
 # define GTEST_HAS_TR1_TUPLE 0
+# elif _MSC_VER >= 1910
+ // VS2017 deprecated ::tr1::tuple
+# define GTEST_HAS_TR1_TUPLE 0
 # else
-// The user didn't tell us not to do it, so we assume it's OK.
+ // The user didn't tell us not to do it, so we assume it's OK.
 # define GTEST_HAS_TR1_TUPLE 1
 # endif
 #endif // GTEST_HAS_TR1_TUPLE
",735,166
replaced back accidently removed static_cast with consistent ImplicitCast_," TEST(PrintTr1TupleTest, VariousSizes) {
 ::std::tr1::tuple<bool, char, short, testing::internal::Int32, // NOLINT
 testing::internal::Int64, float, double, const char*, void*,
 std::string>
- t10(false, 'a', 3, 4, 5, 1.5F, -2.5, str, ImplicitCast_<void*>(NULL),
+ t10(false, 'a', ImplicitCast_<short>(3), 4, 5, 1.5F, -2.5, str, ImplicitCast_<void*>(NULL),
 ""10"");
 EXPECT_EQ(""(false, 'a' (97, 0x61), 3, 4, 5, 1.5, -2.5, "" + PrintPointer(str) +
 "" pointing to \""8\"", NULL, \""10\"")"",
",1094,174
Fix value pointed to by `_NSGetArgc()` on macOS,"
 # define vsnprintf _vsnprintf
 #endif // GTEST_OS_WINDOWS
 
+#if GTEST_OS_MAC
+# ifndef GTEST_OS_IOS
+# include <crt_externs.h>
+# endif
+#endif
+
 namespace testing {
 
 using internal::CountIf;
 void ParseGoogleTestFlagsOnlyImpl(int* argc, CharType** argv) {
 }
 }
 
+// Fix the value of *_NSGetArgc() on macOS, but iff 
+// *_NSGetArgv() == argv
+#if GTEST_OS_MAC
+# ifndef GTEST_OS_IOS
+ if (*_NSGetArgv() == argv) {
+ *_NSGetArgc() = *argc;
+ }
+# endif
+#endif
+
 if (g_help_flag) {
 // We print the help here instead of in RUN_ALL_TESTS(), as the
 // latter may not be called at all if the user is using Google
",3282,818
Fix location of `_NSGetArgv` correction.," void ParseGoogleTestFlagsOnlyImpl(int* argc, CharType** argv) {
 }
 }
 
-// Fix the value of *_NSGetArgc() on macOS, but iff 
-// *_NSGetArgv() == argv
-#if GTEST_OS_MAC
-# ifndef GTEST_OS_IOS
- if (*_NSGetArgv() == argv) {
- *_NSGetArgc() = *argc;
- }
-# endif
-#endif
-
 if (g_help_flag) {
 // We print the help here instead of in RUN_ALL_TESTS(), as the
 // latter may not be called at all if the user is using Google
 void ParseGoogleTestFlagsOnlyImpl(int* argc, CharType** argv) {
 // other parts of Google Test.
 void ParseGoogleTestFlagsOnly(int* argc, char** argv) {
 ParseGoogleTestFlagsOnlyImpl(argc, argv);
+ 
+ // Fix the value of *_NSGetArgc() on macOS, but iff 
+ // *_NSGetArgv() == argv
+ // Only applicable to char** version of argv
+#if GTEST_OS_MAC
+# ifndef GTEST_OS_IOS
+ if (*_NSGetArgv() == argv) {
+ *_NSGetArgc() = *argc;
+ }
+# endif
+#endif
 }
 void ParseGoogleTestFlagsOnly(int* argc, wchar_t** argv) {
 ParseGoogleTestFlagsOnlyImpl(argc, argv);
",3282,818
Remove C4996 warning in VS2017," typedef struct _RTL_CRITICAL_SECTION GTEST_CRITICAL_SECTION;
 # if GTEST_OS_LINUX_ANDROID && defined(_STLPORT_MAJOR)
 // STLport, provided with the Android NDK, has neither <tr1/tuple> or <tuple>.
 # define GTEST_HAS_TR1_TUPLE 0
+# elif defined(_MSC_VER) && (_MSC_VER >= 1910)
+// Prevent `warning C4996: 'std::tr1': warning STL4002: The non-Standard std::tr1 namespace and TR1-only machinery are deprecated and will be REMOVED.`
+# define GTEST_HAS_TR1_TUPLE 0
 # else
 // The user didn't tell us not to do it, so we assume it's OK.
 # define GTEST_HAS_TR1_TUPLE 1
",735,166
remove implicit casts," typedef struct _RTL_CRITICAL_SECTION GTEST_CRITICAL_SECTION;
 // Prevent `warning C4996: 'std::tr1': warning STL4002: The non-Standard std::tr1 namespace and TR1-only machinery are deprecated and will be REMOVED.`
 # define GTEST_HAS_TR1_TUPLE 0
 # else
- // The user didn't tell us not to do it, so we assume it's OK.
+// The user didn't tell us not to do it, so we assume it's OK.
 # define GTEST_HAS_TR1_TUPLE 1
 # endif
 #endif // GTEST_HAS_TR1_TUPLE
",735,166
"Re-enable MSVC++ C4389 warning in CmdHelperEq()

C4389 was inhibited in commit 4b83461 making behavior inconsistent with
other compilers."," AssertionResult CmpHelperEQ(const char* lhs_expression,
 const char* rhs_expression,
 const T1& lhs,
 const T2& rhs) {
-GTEST_DISABLE_MSC_WARNINGS_PUSH_(4389 /* signed/unsigned mismatch */)
 if (lhs == rhs) {
 return AssertionSuccess();
 }
-GTEST_DISABLE_MSC_WARNINGS_POP_()
 
 return CmpHelperEQFailure(lhs_expression, rhs_expression, lhs, rhs);
 }
",685,102
"Avoid warning C4619 in MSVC 2017.

C4800 has since been removed in MSVC 2017, so trying to silence it
throws warning C4619 when enabled."," class GTEST_API_ AssertionResult {
 // Used in EXPECT_TRUE/FALSE(assertion_result).
 AssertionResult(const AssertionResult& other);
 
+#if defined(_MSC_VER) && _MSC_VER < 1910
 GTEST_DISABLE_MSC_WARNINGS_PUSH_(4800 /* forcing value to bool */)
+#endif
 
 // Used in the EXPECT_TRUE/FALSE(bool_expression).
 //
 class GTEST_API_ AssertionResult {
 /*enabler*/ = NULL)
 : success_(success) {}
 
+#if defined(_MSC_VER) && _MSC_VER < 1910
 GTEST_DISABLE_MSC_WARNINGS_POP_()
+#endif
 
 // Assignment operator.
 AssertionResult& operator=(AssertionResult other) {
",685,102
"Fix testing::Combine on MSVC 2017.

On platforms with std::tuple and not std::tr1::tuple, GTEST_HAS_COMBINE
gets turned off when it works fine (due to GTEST_TUPLE_NAMESPACE_).
Elsewhere in the project, several GTEST_HAS_TR1_TUPLE checks
additionally check GTEST_HAS_STD_TUPLE_, so use that formulation.

(The ones that don't are specific to std::tr1::tuple and are followed by
an identical GTEST_HAS_STD_TUPLE_ version underneath it.)

In particular, this fixes testing::Combine on MSVC 2017, which regressed
here:
https://github.com/google/googletest/pull/1348#issuecomment-353879010"," using ::std::tuple_size;
 // Determines whether to support Combine().
 // The implementation doesn't work on Sun Studio since it doesn't
 // understand templated conversion operators.
-#if GTEST_HAS_TR1_TUPLE && !defined(__SUNPRO_CC)
+#if (GTEST_HAS_TR1_TUPLE || GTEST_HAS_STD_TUPLE_) && !defined(__SUNPRO_CC)
 # define GTEST_HAS_COMBINE 1
 #endif
 
",735,166
"OSS Sync, cl 163329677"," class PreCalculatedPrimeTable : public PrimeTable {
 ::std::fill(is_prime_, is_prime_ + is_prime_size_, true);
 is_prime_[0] = is_prime_[1] = false;
 
- for (int i = 2; i <= max; i++) {
+ // Checks every candidate for prime number (we know that 2 is the only even
+ // prime).
+ for (int i = 2; i*i <= max; i += i%2+1) {
 if (!is_prime_[i]) continue;
 
 // Marks all multiples of i (except i itself) as non-prime.
- for (int j = 2*i; j <= max; j += i) {
+ // We are starting here from i-th multiplier, because all smaller
+ // complex numbers were already marked.
+ for (int j = i*i; j <= max; j += i) {
 is_prime_[j] = false;
 }
 }
",54,20
"Pass the -Wmissing-declarations warning.

This makes it easier to use GTest in projects that build with the
-Wmissing-declarations warning. This fixes the warning in headers and
source files, though not GTest's own tests as it is rather noisy there."," BoundSecondMatcher<Tuple2Matcher, Second> MatcherBindSecond(
 return BoundSecondMatcher<Tuple2Matcher, Second>(tm, second);
 }
 
+// Joins a vector of strings as if they are fields of a tuple; returns
+// the joined string. This function is exported for testing.
+GTEST_API_ string JoinAsTuple(const Strings& fields);
+
 // Returns the description for a matcher defined using the MATCHER*()
 // macro where the user-supplied description string is """", if
 // 'negation' is false; otherwise returns the description of the
",2680,535
"Also define GTEST_ATTRIBUTE_PRINTF_ in clang-cl.

clang-cl is clang for Windows running in MSVC mode. Chromium uses it for
Windows builds. clang-cl is weird in that it defines __clang__ and
_MSC_VER, but *NOT* __GNUC__. This is vaguely analogous to how normal
clang defines __clang__ (what it is) and __GNUC__ (what it is compatible
with).

However, clang-cl still implements most GCC extensions, being clang.
Notably, the way to control -Wformat-literal is still with
__attribute__((__format__)). For better error-checking and strict
-Wformatl-literal compatibility (see
53c478d639b8eebd2942e88266610ebc79c541f6), define
GTEST_ATTRIBUTE_PRINTF_ in clang-cl too."," using ::std::tuple_size;
 #endif
 
 // Use this annotation before a function that takes a printf format string.
-#if defined(__GNUC__) && !defined(COMPILER_ICC)
+#if (defined(__GNUC__) || defined(__clang__)) && !defined(COMPILER_ICC)
 # if defined(__MINGW_PRINTF_FORMAT)
 // MinGW has two different printf implementations. Ensure the format macro
 // matches the selected implementation. See
",735,166
upstreaming cl 124976692,"
 #include ""gmock/internal/gmock-port.h""
 #include ""gtest/gtest.h""
 #include ""gtest/gtest-spi.h""
-
-// Indicates that this translation unit is part of Google Test's
-// implementation. It must come before gtest-internal-inl.h is
-// included, or there will be a compiler error. This trick is to
-// prevent a user from accidentally including gtest-internal-inl.h in
-// their code.
-#define GTEST_IMPLEMENTATION_ 1
 #include ""src/gtest-internal-inl.h""
-#undef GTEST_IMPLEMENTATION_
 
 #if GTEST_OS_CYGWIN
 # include <sys/types.h> // For ssize_t. NOLINT
",465,73
"code cleanup in preparation for merges, cl 180857299"," void DieWithEmbeddedNul() {
 }
 
 # if GTEST_USES_PCRE
+
 // Tests that EXPECT_DEATH and ASSERT_DEATH work when the error
 // message has a NUL character in it.
 TEST_F(TestForDeathTest, EmbeddedNulInMessage) {
- // TODO(wan@google.com): <regex.h> doesn't support matching strings
- // with embedded NUL characters - find a way to workaround it.
 EXPECT_DEATH(DieWithEmbeddedNul(), ""my null world"");
 ASSERT_DEATH(DieWithEmbeddedNul(), ""my null world"");
 }
+
 # endif // GTEST_USES_PCRE
 
 // Tests that death test macros expand to code which interacts well with switch
",913,154
Revert one file for now," void SubWithTrace(int n) {
 SubWithoutTrace(n);
 }
 
-TEST(SCOPED_TRACETest, AcceptedValues) {
- SCOPED_TRACE(""literal string"");
- SCOPED_TRACE(std::string(""std::string""));
- SCOPED_TRACE(1337); // streamable type
- const char* null_value = NULL;
- SCOPED_TRACE(null_value);
-
- ADD_FAILURE() << ""Just checking that all these values work fine."";
-}
-
 // Tests that SCOPED_TRACE() obeys lexical scopes.
 TEST(SCOPED_TRACETest, ObeysScopes) {
 printf(""(expected to fail)\n"");
",599,112
"Small cleanups, merge","
 //
 // Author: wan@google.com (Zhanyong Wan)
 
-#include ""gtest/gtest.h""
 #include ""sample4.h""
+#include ""gtest/gtest.h""
+
 namespace {
 // Tests the Increment() method.
+
 TEST(Counter, Increment) {
 Counter c;
 
 TEST(Counter, Increment) {
 EXPECT_EQ(1, c.Increment());
 EXPECT_EQ(2, c.Increment());
 }
+
 } // namespace
",10,1
"Code merge, upstreaming accumulated changes, cleanup"," INSTANTIATE_TYPED_TEST_CASE_P(My, FooTest, MyTypes);
 } \
 static const char* const GTEST_REGISTERED_TEST_NAMES_(CaseName) \
 GTEST_ATTRIBUTE_UNUSED_ = \
- GTEST_TYPED_TEST_CASE_P_STATE_(CaseName).VerifyRegisteredTestNames(\
+ GTEST_TYPED_TEST_CASE_P_STATE_(CaseName).VerifyRegisteredTestNames( \
 __FILE__, __LINE__, #__VA_ARGS__)
 
 // The 'Types' template argument below must have spaces around it
",34,4
Upstream cl 103120214," GTEST_API_ AssertionResult DoubleLE(const char* expr1, const char* expr2,
 // of the dummy variable name, thus allowing multiple SCOPED_TRACE()s
 // to appear in the same block - as long as they are on different
 // lines.
+//
+// Assuming that each thread maintains its own stack of traces.
+// Therefore, a SCOPED_TRACE() would (correctly) only affect the
+// assertions in its own thread.
 #define SCOPED_TRACE(message) \
 ::testing::internal::ScopedTrace GTEST_CONCAT_TOKEN_(gtest_trace_, __LINE__)(\
- __FILE__, __LINE__, ::testing::Message() << (message))
+ __FILE__, __LINE__, (message))
+
 
 // Compile-time assertion for type equality.
 // StaticAssertTypeEq<type1, type2>() compiles iff type1 and type2 are
",685,102
Test files for corresponding changes," import re
 import sys
 from xml.dom import minidom, Node
 
+IS_LINUX = os.name == 'posix' and os.uname()[0] == 'Linux'
+
 import gtest_test_utils
 import gtest_xml_test_utils
 
",230,13
"Reverting some changes, need to make the merge compile"," class GTEST_API_ TestInfo {
 // Returns the line where this test is defined.
 int line() const { return location_.line; }
 
- // Return true if this test should not be run because it's in another shard.
- bool is_in_another_shard() const { return is_in_another_shard_; }
-
 // Returns true if this test should run, that is if the test is not
 // disabled (or it is disabled but the also_run_disabled_tests flag has
 // been specified) and its full name matches the user-specified filter.
 class GTEST_API_ TestInfo {
 bool is_reportable() const {
 // The XML report includes tests matching the filter, excluding those
 // run in other shards.
- return matches_filter_ && !is_in_another_shard_;
+ return matches_filter_;
 }
 
 // Returns the result of the test.
",688,102
Expose ScopedTrace utility in public interface," def RemoveLocations(test_output):
 'FILE_NAME:#: '.
 """"""
 
- return re.sub(r'.*[/\\](.+)(\:\d+|\(\d+\))\: ', r'\1:#: ', test_output)
+ return re.sub(r'.*[/\\]((gtest_output_test_|gtest).cc)(\:\d+|\(\d+\))\: ',
+ r'\1:#: ', test_output)
 
 
 def RemoveStackTraceDetails(output):
",166,22
"Check whether _MSC_VER is defined when detecting presence of cxxabi.h under libc++.

If _MSC_VER is defined, it means that we are using the Microsoft
ABI, so cxxabi.h (which is associated with the Itanium ABI) will not
be available."," using ::std::tuple_size;
 #endif
 
 // _LIBCPP_VERSION is defined by the libc++ library from the LLVM project.
-#if defined(__GLIBCXX__) || defined(_LIBCPP_VERSION)
+#if defined(__GLIBCXX__) || (defined(_LIBCPP_VERSION) && !defined(_MSC_VER))
 # define GTEST_HAS_CXXABI_H_ 1
 #else
 # define GTEST_HAS_CXXABI_H_ 0
",735,166
"merges, cl/155419551 and other"," int UnitTestImpl::FilterTests(ReactionToSharding shard_tests) {
 (GTEST_FLAG(also_run_disabled_tests) || !is_disabled) &&
 matches_filter;
 
- const bool is_selected = is_runnable &&
- (shard_tests == IGNORE_SHARDING_PROTOCOL ||
- ShouldRunTestOnShard(total_shards, shard_index,
- num_runnable_tests));
+ const bool is_in_another_shard =
+ shard_tests != IGNORE_SHARDING_PROTOCOL &&
+ !ShouldRunTestOnShard(total_shards, shard_index, num_runnable_tests);
+ test_info->is_in_another_shard_ = is_in_another_shard;
+ const bool is_selected = is_runnable && !is_in_another_shard;
 
 num_runnable_tests += is_runnable;
 num_selected_tests += is_selected;
",3281,815
"Merging, upstream http://cl/182836545"," namespace {
 
 
 // Used for verifying that global environment set-up and tear-down are
-// inside the gtest_repeat loop.
+// inside the --gtest_repeat loop.
 
 int g_environment_set_up_count = 0;
 int g_environment_tear_down_count = 0;
",121,16
Many code merge/upstream changes,"
 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
 
 #include <stdio.h>
-
 #include ""gtest/gtest.h""
 
 GTEST_API_ int main(int argc, char **argv) {
",7,1
upstream cl 182543808," GTEST_DECLARE_string_(output);
 // test.
 GTEST_DECLARE_bool_(print_time);
 
+// This flags control whether Google Test prints UTF8 characters as text.
+GTEST_DECLARE_bool_(print_utf8);
+
 // This flag specifies the random number seed.
 GTEST_DECLARE_int32_(random_seed);
 
",710,109
placating gcc and its overzeauls size comparison warnings," TEST(IsValidUTF8Test, IllFormedUTF8) {
 {""\xEE\x80\x80"", ""\""\\xEE\\x80\\x80\""\n As Text: \""\""""}
 };
 
- for (int i = 0; i < sizeof(kTestdata)/sizeof(kTestdata[0]); ++i) {
+ for (int i = 0; i < int(sizeof(kTestdata)/sizeof(kTestdata[0])); ++i) {
 EXPECT_PRINT_TO_STRING_(kTestdata[i][0], kTestdata[i][1]);
 }
 }
",1132,177
"Use _CPPUNWIND instead of _HAS_EXCEPTIONS with MSVC.

_HAS_EXCEPTIONS is specific to the MSVC STL and defining it to 0 causes
problems with libc++, so libc++ users may leave it undefined. This can
cause GTEST_HAS_EXCEPTIONS to be defined incorrectly if the user has
disabled exceptions via the compiler, which can lead to build errors.

_CPPUNWIND is a builtin macro provided by the compiler so it should
work with both STLs."," typedef struct _RTL_CRITICAL_SECTION GTEST_CRITICAL_SECTION;
 #ifndef GTEST_HAS_EXCEPTIONS
 // The user didn't tell us whether exceptions are enabled, so we need
 // to figure it out.
-# if defined(_MSC_VER) || defined(__BORLANDC__)
-// MSVC's and C++Builder's implementations of the STL use the _HAS_EXCEPTIONS
+# if defined(_MSC_VER) && defined(_CPPUNWIND)
+// MSVC defines _CPPUNWIND to 1 iff exceptions are enabled.
+# define GTEST_HAS_EXCEPTIONS 1
+# elif defined(__BORLANDC__)
+// C++Builder's implementation of the STL uses the _HAS_EXCEPTIONS
 // macro to enable exceptions, so we'll do the same.
 // Assumes that exceptions are enabled by default.
 # ifndef _HAS_EXCEPTIONS
",735,166
Adding tests to googlemock bazel,"
-#!/usr/bin/env python
-#
 # Copyright 2006, Google Inc.
 # All rights reserved.
 #
 import sys
 SCRIPT_DIR = os.path.dirname(__file__) or '.'
 
 # isdir resolves symbolic links.
-gtest_tests_util_dir = os.path.join(SCRIPT_DIR, '../gtest/test')
+gtest_tests_util_dir = os.path.join(SCRIPT_DIR, '../googletest/test')
 if os.path.isdir(gtest_tests_util_dir):
 GTEST_TESTS_UTIL_DIR = gtest_tests_util_dir
 else:
- GTEST_TESTS_UTIL_DIR = os.path.join(SCRIPT_DIR, '../../gtest/test')
+ GTEST_TESTS_UTIL_DIR = os.path.join(SCRIPT_DIR, '../../googletest/test')
 
 sys.path.append(GTEST_TESTS_UTIL_DIR)
 import gtest_test_utils # pylint: disable-msg=C6204
",31,6
Ability to optionally depend on Abseil plus upstream of 183716547," TEST(UniversalTersePrintTupleFieldsToStringsTestWithStd, PrintsTersely) {
 
 #endif // GTEST_HAS_STD_TUPLE_
 
+#if GTEST_HAS_ABSL
+
+TEST(PrintOptionalTest, Basic) {
+ absl::optional<int> value;
+ EXPECT_EQ(""(nullopt)"", PrintToString(value));
+ value = {7};
+ EXPECT_EQ(""(7)"", PrintToString(value));
+ EXPECT_EQ(""(1.1)"", PrintToString(absl::optional<double>{1.1}));
+ EXPECT_EQ(""(\""A\"")"", PrintToString(absl::optional<std::string>{""A""}));
+}
+#endif // GTEST_HAS_ABSL
+
 } // namespace gtest_printers_test
 } // namespace testing
",1140,178
Merges and also adding new bazel build mode,"
 
 #if GTEST_HAS_ABSL
 #include ""absl/types/optional.h""
+#include ""absl/strings/string_view.h""
 #endif // GTEST_HAS_ABSL
 
 namespace testing {
 inline void PrintTo(const ::std::wstring& s, ::std::ostream* os) {
 #if GTEST_HAS_ABSL
 // Overload for absl::string_view.
 inline void PrintTo(absl::string_view sp, ::std::ostream* os) {
- PrintTo(string(sp), os);
+ PrintTo(::std::string(sp), os);
 }
 #endif // GTEST_HAS_ABSL
 
",525,88
"Fix std::iscntrl use in gtest-printers.cc

ContainsUnprintableControlCodes() in gtest-printers.cc passes a char
argument to std::iscntrl. Although its argument is an int, std::iscntrl
produces undefined behavior if its argument is not representable as an
unsigned char. The standard library on Windows asserts that the argument
is an unsigned char, resulting in an assertion crash on debug builds."," void PrintTo(const wchar_t* s, ostream* os) {
 namespace {
 
 bool ContainsUnprintableControlCodes(const char* str, size_t length) {
+ const unsigned char *s = reinterpret_cast<const unsigned char *>(str);
+
 for (size_t i = 0; i < length; i++) {
- char ch = *str++;
+ unsigned char ch = *s++;
 if (std::iscntrl(ch)) {
 switch (ch) {
 case '\t':
",282,94
moving JoinAsTuple to internal," BoundSecondMatcher<Tuple2Matcher, Second> MatcherBindSecond(
 return BoundSecondMatcher<Tuple2Matcher, Second>(tm, second);
 }
 
-// Joins a vector of strings as if they are fields of a tuple; returns
-// the joined string. This function is exported for testing.
-GTEST_API_ string JoinAsTuple(const Strings& fields);
-
 // Returns the description for a matcher defined using the MATCHER*()
 // macro where the user-supplied description string is """", if
 // 'negation' is false; otherwise returns the description of the
",2679,535
clang warning https://travis-ci.org/google/googletest/jobs/340978022," TEST(CombineTest, CombineWithMaxNumberOfParameters) {
 
 class NonDefaultConstructAssignString {
 public:
- NonDefaultConstructAssignString(const std::string& str) : str_(str) {}
+ NonDefaultConstructAssignString(const std::string& s) : str_(s) {}
 
 const std::string& str() const { return str_; }
 
",707,106
clang warning 'https://travis-ci.org/google/googletest/jobs/340987201'," class CustomFunctorNamingTest : public TestWithParam<std::string> {};
 TEST_P(CustomFunctorNamingTest, CustomTestNames) {}
 
 struct CustomParamNameFunctor {
- std::string operator()(const ::testing::TestParamInfo<std::string>& info) {
- return info.param;
+ std::string operator()(const ::testing::TestParamInfo<std::string>& inf) {
+ return inf.param;
 }
 };
 
 TEST_P(CustomLambdaNamingTest, CustomTestNames) {}
 INSTANTIATE_TEST_CASE_P(CustomParamNameLambda,
 CustomLambdaNamingTest,
 Values(std::string(""LambdaName"")),
- [](const ::testing::TestParamInfo<std::string>& info) {
- return info.param;
+ [](const ::testing::TestParamInfo<std::string>& inf) {
+ return inf.param;
 });
 
 #endif // GTEST_LANG_CXX11
",707,106
"Fix unused function warning on Mac OS.

As of recently, Google Test fails to compile with the warning below when
used in projects with strict warning settings.

googletest/src/gtest-death-test.cc:1004:13: error: unused function 'StackGrowsDown' [-Werror,-Wunused-function]"," static int ExecDeathTestChildMain(void* child_arg) {
 }
 # endif // !GTEST_OS_QNX
 
+# if GTEST_HAS_CLONE
 // Two utility routines that together determine the direction the stack
 // grows.
 // This could be accomplished more elegantly by a single recursive
 static bool StackGrowsDown() {
 StackLowerThanAddress(&dummy, &result);
 return result;
 }
+# endif // GTEST_HAS_CLONE
 
 // Spawns a child process with the same executable as the current process in
 // a thread-safe manner and instructs it to run the death test. The
",753,146
Removed trailing comma in enum," class NativeArray {
 private:
 enum {
 kCheckTypeIsNotConstOrAReference = StaticAssertTypeEqHelper<
- Element, GTEST_REMOVE_REFERENCE_AND_CONST_(Element)>::value,
+ Element, GTEST_REMOVE_REFERENCE_AND_CONST_(Element)>::value
 };
 
 // Initializes this object with a copy of the input.
",469,70
"merging unitests, check"," TEST(StringAssertionTest, ASSERT_STREQ) {
 const char p2[] = ""good"";
 ASSERT_STREQ(p1, p2);
 
- EXPECT_FATAL_FAILURE(
- ASSERT_STREQ(""bad"", ""good""),
- ""Expected equality of these values:\n \""bad\""\n \""good\"""");
+ EXPECT_FATAL_FAILURE(ASSERT_STREQ(""bad"", ""good""),
+ "" \""bad\""\n \""good\"""");
 }
 
 // Tests ASSERT_STREQ with NULL arguments.
 TEST(AssertionTest, ASSERT_EQ_NULL) {
 // A failure.
 static int n = 0;
 EXPECT_FATAL_FAILURE(ASSERT_EQ(NULL, &n),
- "" &n\n Which is:"");
+ "" &n\n Which is: 0x"");
 }
 #endif // GTEST_CAN_COMPARE_NULL
 
",5150,712
Try to handle unsigned wchar_t (arm) a bit better," struct LinkedPtrLessThan {
 // To gcc,
 // wchar_t == signed wchar_t != unsigned wchar_t == unsigned int
 #ifdef __GNUC__
+#if !defined(__WCHAR_UNSIGNED__)
 // signed/unsigned wchar_t are valid types.
 # define GMOCK_HAS_SIGNED_WCHAR_T_ 1
 #endif
+#endif
 
 // In what follows, we use the term ""kind"" to indicate whether a type
 // is bool, an integer type (excluding bool), a floating-point type,
",224,3
merging unittests - 5," TEST(ExpectTest, EXPECT_EQ_NULL) {
 // A failure.
 int n = 0;
 EXPECT_NONFATAL_FAILURE(EXPECT_EQ(NULL, &n),
- ""&n\n"");
+ "" &n\n Which is:"");
 }
 #endif // GTEST_CAN_COMPARE_NULL
 
 TEST(EqAssertionTest, CharPointer) {
 ASSERT_EQ(p1, p1);
 
 EXPECT_NONFATAL_FAILURE(EXPECT_EQ(p0, p2),
- ""p2"");
+ "" p2\n Which is:"");
 EXPECT_NONFATAL_FAILURE(EXPECT_EQ(p1, p2),
- ""p2"");
+ "" p2\n Which is:"");
 EXPECT_FATAL_FAILURE(ASSERT_EQ(reinterpret_cast<char*>(0x1234),
 reinterpret_cast<char*>(0xABC0)),
 ""ABC0"");
 TEST(EqAssertionTest, WideCharPointer) {
 EXPECT_EQ(p0, p0);
 
 EXPECT_NONFATAL_FAILURE(EXPECT_EQ(p0, p2),
- ""p2"");
+ "" p2\n Which is:"");
 EXPECT_NONFATAL_FAILURE(EXPECT_EQ(p1, p2),
- ""p2"");
+ "" p2\n Which is:"");
 void* pv3 = (void*)0x1234; // NOLINT
 void* pv4 = (void*)0xABC0; // NOLINT
 const wchar_t* p3 = reinterpret_cast<const wchar_t*>(pv3);
",5149,712
"Use a full message in the JSON output for failures

The full message unlike summary also includes stack trace."," void JsonUnitTestResultPrinter::OutputJsonTestInfo(::std::ostream* stream,
 const std::string location =
 internal::FormatCompilerIndependentFileLocation(part.file_name(),
 part.line_number());
- const std::string summary = EscapeJson(location + ""\n"" + part.summary());
+ const std::string message = EscapeJson(location + ""\n"" + part.message());
 *stream << kIndent << "" {\n""
- << kIndent << "" \""failure\"": \"""" << summary << ""\"",\n""
+ << kIndent << "" \""failure\"": \"""" << message << ""\"",\n""
 << kIndent << "" \""type\"": \""\""\n""
 << kIndent << "" }"";
 }
",3559,862
"Allow macros inside of parametrized test names.

This allows doing things like TEST_P(TestFixture, MAYBE(TestName))
for nicer conditional test disabling.

Upstream of cr/188748737.

Tested:
Added unit tests MacroNamingTest and MacroNamingTestNonParametrized."," internal::CartesianProductHolder10<Generator1, Generator2, Generator3,
 }
 # endif // GTEST_HAS_COMBINE
 
-
-
 # define TEST_P(test_case_name, test_name) \
 class GTEST_TEST_CLASS_NAME_(test_case_name, test_name) \
 : public test_case_name { \
 internal::CartesianProductHolder10<Generator1, Generator2, Generator3,
 #test_case_name, \
 ::testing::internal::CodeLocation(\
 __FILE__, __LINE__))->AddTestPattern(\
- #test_case_name, \
- #test_name, \
+ GTEST_STRINGIFY_(test_case_name), \
+ GTEST_STRINGIFY_(test_name), \
 new ::testing::internal::TestMetaFactory< \
 GTEST_TEST_CLASS_NAME_(\
 test_case_name, test_name)>()); \
",958,69
"More merges, removing old dead code"," class MyNonDefaultConstructible {
 int value_;
 };
 
-#if GTEST_HAS_STD_TYPE_TRAITS_
+#if GTEST_LANG_CXX11
 
 TEST(BuiltInDefaultValueTest, ExistsForDefaultConstructibleType) {
 EXPECT_TRUE(BuiltInDefaultValue<MyDefaultConstructible>::Exists());
 TEST(BuiltInDefaultValueTest, IsDefaultConstructedForDefaultConstructibleType) {
 EXPECT_EQ(42, BuiltInDefaultValue<MyDefaultConstructible>::Get().value());
 }
 
-#endif // GTEST_HAS_STD_TYPE_TRAITS_
+#endif // GTEST_LANG_CXX11
 
 TEST(BuiltInDefaultValueTest, DoesNotExistForNonDefaultConstructibleType) {
 EXPECT_FALSE(BuiltInDefaultValue<MyNonDefaultConstructible>::Exists());
",893,127
"merge, again, IsRecursiveContainer"," class ExpectationSet {
 public:
 // A bidirectional iterator that can read a const element in the set.
 typedef Expectation::Set::const_iterator const_iterator;
+ typedef Expectation::Set::iterator iterator;
 
 // An object stored in the set. This is an alias of Expectation.
 typedef Expectation::Set::value_type value_type;
",956,151
reverting gtest_list_tests_unittest.py," FooTest\.
 TypedTest/0\. # TypeParam = (VeryLo{245}|class VeryLo{239})\.\.\.
 TestA
 TestB
-TypedTest/1\. # TypeParam = int\s*\*
+TypedTest/1\. # TypeParam = int\s*\*( __ptr64)?
 TestA
 TestB
 TypedTest/2\. # TypeParam = .*MyArray<bool,\s*42>
 TypedTest/2\. # TypeParam = .*MyArray<bool,\s*42>
 My/TypeParamTest/0\. # TypeParam = (VeryLo{245}|class VeryLo{239})\.\.\.
 TestA
 TestB
-My/TypeParamTest/1\. # TypeParam = int\s*\*
+My/TypeParamTest/1\. # TypeParam = int\s*\*( __ptr64)?
 TestA
 TestB
 My/TypeParamTest/2\. # TypeParam = .*MyArray<bool,\s*42>
",118,10
"provide alternative for DebugBreak()

This uses asm(""int3"") for clang/gcc on x86 as alternative for DebugBreak()"," void UnitTest::AddTestPartResult(
 // when a failure happens and both the --gtest_break_on_failure and
 // the --gtest_catch_exceptions flags are specified.
 DebugBreak();
+#elif (defined(__clang__) || defined(__GNUC__)) && (defined(__x86_64__) || defined(__i386__))
+ // with clang/gcc we can acchieve the same effect on x86 by invoking int3
+ asm(""int3"");
 #else
 // Dereference NULL through a volatile pointer to prevent the compiler
 // from removing. We use this rather than abort() or __builtin_trap() for
",3601,869
"Testing, gtest-port.h merge"," typedef struct _RTL_CRITICAL_SECTION GTEST_CRITICAL_SECTION;
 # elif defined(_MSC_VER) && (_MSC_VER >= 1910)
 // Prevent `warning C4996: 'std::tr1': warning STL4002: The non-Standard std::tr1 namespace and TR1-only machinery are deprecated and will be REMOVED.`
 # define GTEST_HAS_TR1_TUPLE 0
+# elif defined(_LIBCPP_VERSION)
+// libc++ doesn't support TR1.
+# define GTEST_HAS_TR1_TUPLE 0
 # else
 // The user didn't tell us not to do it, so we assume it's OK.
 # define GTEST_HAS_TR1_TUPLE 1
",766,167
"merging, just comments format"," typedef struct _RTL_CRITICAL_SECTION GTEST_CRITICAL_SECTION;
 // STLport, provided with the Android NDK, has neither <tr1/tuple> or <tuple>.
 # define GTEST_HAS_TR1_TUPLE 0
 # elif defined(_MSC_VER) && (_MSC_VER >= 1910)
-// Prevent `warning C4996: 'std::tr1': warning STL4002: The non-Standard std::tr1 namespace and TR1-only machinery are deprecated and will be REMOVED.`
+// Prevent `warning C4996: 'std::tr1': warning STL4002:
+// The non-Standard std::tr1 namespace and TR1-only machinery
+// are deprecated and will be REMOVED.`
 # define GTEST_HAS_TR1_TUPLE 0
 # elif GTEST_LANG_CXX11 && defined(_LIBCPP_VERSION)
 // libc++ doesn't support TR1.
",766,167
"merging gtest-port.h , 191439094"," typedef struct _RTL_CRITICAL_SECTION GTEST_CRITICAL_SECTION;
 // Determines whether Google Test's own tr1 tuple implementation
 // should be used.
 #ifndef GTEST_USE_OWN_TR1_TUPLE
+// We use our own tuple implementation on Symbian.
+# if GTEST_OS_SYMBIAN
+# define GTEST_USE_OWN_TR1_TUPLE 1
+# else
 // The user didn't tell us, so we need to figure it out.
 
 // We use our own TR1 tuple if we aren't sure the user has an
 typedef struct _RTL_CRITICAL_SECTION GTEST_CRITICAL_SECTION;
 # else
 # define GTEST_USE_OWN_TR1_TUPLE 1
 # endif
-
+# endif // GTEST_OS_SYMBIAN
 #endif // GTEST_USE_OWN_TR1_TUPLE
 
-// To avoid conditional compilation everywhere, we make it
-// gtest-port.h's responsibility to #include the header implementing
-// tuple.
+// To avoid conditional compilation we make it gtest-port.h's responsibility
+// to #include the header implementing tuple.
 #if GTEST_HAS_STD_TUPLE_
 # include <tuple> // IWYU pragma: export
 # define GTEST_TUPLE_NAMESPACE_ ::std
",766,167
"merging port, cont. 191443078"," typedef struct _RTL_CRITICAL_SECTION GTEST_CRITICAL_SECTION;
 # include <tr1/tuple> // NOLINT
 # endif // !GTEST_HAS_RTTI && GTEST_GCC_VER_ < 40302
 
-# else
-// If the compiler is not GCC 4.0+, we assume the user is using a
-// spec-conforming TR1 implementation.
+// VS 2010 now has tr1 support.
+# elif _MSC_VER >= 1600
 # include <tuple> // IWYU pragma: export // NOLINT
+
+# else // GTEST_USE_OWN_TR1_TUPLE
+# include <tr1/tuple> // IWYU pragma: export // NOLINT
 # endif // GTEST_USE_OWN_TR1_TUPLE
 
 #endif // GTEST_HAS_TR1_TUPLE
",757,167
"Upstreaming, cl 191344765"," TEST(IsHashTable, Basic) {
 EXPECT_TRUE(testing::internal::IsHashTable<std::unordered_set<int>>::value);
 #endif // GTEST_LANG_CXX11
 #if GTEST_HAS_HASH_SET_
- EXPECT_TRUE(testing::internal::IsHashTable<hash_set<int>>::value);
+ EXPECT_TRUE(testing::internal::IsHashTable<__gnu_cxx::hash_set<int>>::value);
 #endif // GTEST_HAS_HASH_SET_
 }
 
",5186,716
Tweaking https://github.com/google/googletest/pull/1523 to exclude nacl," void UnitTest::AddTestPartResult(
 // when a failure happens and both the --gtest_break_on_failure and
 // the --gtest_catch_exceptions flags are specified.
 DebugBreak();
-#elif (defined(__clang__) || defined(__GNUC__)) && (defined(__x86_64__) || defined(__i386__))
+#elif (!defined(__native_client__)) && \
+ ((defined(__clang__) || defined(__GNUC__)) && \
+ (defined(__x86_64__) || defined(__i386__)))
 // with clang/gcc we can achieve the same effect on x86 by invoking int3
 asm(""int3"");
 #else
",3601,869
fix build break on locale windows," namespace edit_distance {
 // Returns the optimal edits to go from 'left' to 'right'.
 // All edits cost the same, with replace having lower priority than
 // add/remove.
-// Simple implementation of the WagnerFischer algorithm.
+// Simple implementation of the Wagner-Fischer algorithm.
 // See http://en.wikipedia.org/wiki/Wagner-Fischer_algorithm
 enum EditType { kMatch, kAdd, kRemove, kReplace };
 GTEST_API_ std::vector<EditType> CalculateOptimalEdits(
",503,71
Fixing build break on MSVC," TEST(MatcherCastTest, FromSameType) {
 struct ConvertibleFromAny {
 ConvertibleFromAny(int a_value) : value(a_value) {}
 template <typename T>
- ConvertibleFromAny(const T& /*a_value*/) : value(-1) {
+explicit ConvertibleFromAny(const T& /*a_value*/) : value(-1) {
 ADD_FAILURE() << ""Conversion constructor called"";
 }
 int value;
",4325,587
"Address MSVC warning C4503, decorated name length exceeded, name was truncated"," TEST_P(BipartiteRandomTest, LargerNets) {
 }
 
 // Test argument is a std::pair<int, int> representing (nodes, iters).
+GTEST_DISABLE_MSC_WARNINGS_PUSH_(4503)
 INSTANTIATE_TEST_CASE_P(Samples, BipartiteRandomTest,
 testing::Values(
 std::make_pair(5, 10000),
 INSTANTIATE_TEST_CASE_P(Samples, BipartiteRandomTest,
 std::make_pair(7, 2000),
 std::make_pair(8, 500),
 std::make_pair(9, 100)));
+GTEST_DISABLE_MSC_WARNINGS_POP_()
 
 // Tests IsReadableTypeName().
 
",4327,587
"More on MSVC warning C4503, decorated name length exceeded"," INSTANTIATE_TEST_CASE_P(AllGraphs, BipartiteTest,
 ::testing::Range(0, 5));
 
 // Parameterized by a pair interpreted as (LhsSize, RhsSize).
+GTEST_DISABLE_MSC_WARNINGS_PUSH_(4503)
 class BipartiteNonSquareTest
 : public ::testing::TestWithParam<std::pair<size_t, size_t> > {
 };
 TEST_P(BipartiteRandomTest, LargerNets) {
 }
 
 // Test argument is a std::pair<int, int> representing (nodes, iters).
-GTEST_DISABLE_MSC_WARNINGS_PUSH_(4503)
 INSTANTIATE_TEST_CASE_P(Samples, BipartiteRandomTest,
 testing::Values(
 std::make_pair(5, 10000),
",4327,587
Merging matchers test," using testing::internal::RE;
 using testing::internal::scoped_ptr;
 using testing::internal::StreamMatchResultListener;
 using testing::internal::Strings;
+using testing::internal::linked_ptr;
+using testing::internal::scoped_ptr;
+using testing::internal::string;
 using testing::make_tuple;
 using testing::tuple;
 
",4922,663
Have to wait for this one," TEST(MatcherCastTest, NonImplicitlyConstructibleTypeWithOperatorEq) {
 namespace convertible_from_any {
 // Implicitly convertible from any type.
 struct ConvertibleFromAny {
- ConvertibleFromAny(int a_value) : value(a_value) {}
+ explicit ConvertibleFromAny(int a_value) : value(a_value) {}
 template <typename T>
 ConvertibleFromAny(const T& /*a_value*/) : value(-1) {
 ADD_FAILURE() << ""Conversion constructor called"";
",4922,663
And more MCVS warnings,"
 namespace testing {
 
 // The macros trigger warning C4100 (unreferenced formal
-// parameter) in MSVC with -W4. Unfortunately they cannot be fixed in
-// the macro definition, as the warnings are generated when the macro
-// is expanded and macro expansion cannot contain #pragma. Therefore
-// we suppress them here.
+// parameter) in MSVC with -W4.
 #ifdef _MSC_VER
-# pragma warning(push)
 # pragma warning(disable:4100)
+#if (_MSC_VER == 1900)
+# pragma warning(disable:4800)
+ #endif
 #endif
 
 // Defines a matcher that matches an empty container. The container must
",16,4
Deal with MCVS warnings,"
 namespace testing {
 namespace internal {
 
+// Silence C4100 (unreferenced formal
+// parameter) for MSVC
+#ifdef _MSC_VER
+# pragma warning(disable:4100)
+#endif
+
 // Joins a vector of strings as if they are fields of a tuple; returns
 // the joined string.
 GTEST_API_ std::string JoinAsTuple(const Strings& fields);
",224,3
Cont. deal with MCVS warnings," namespace testing {
 // Silence C4100 (unreferenced formal
 // parameter) for MSVC
 #ifdef _MSC_VER
+# pragma warning(push)
 # pragma warning(disable:4100)
 #if (_MSC_VER == 1900)
 # pragma warning(disable:4800)
 MATCHER(IsFalse, negation ? ""is true"" : ""is false"") {
 return !static_cast<bool>(arg);
 }
 
+#ifdef _MSC_VER
+# pragma warning(pop)
+#endif
+
+
 } // namespace testing
 
 #endif // GMOCK_GMOCK_MORE_MATCHERS_H_
",16,4
"deal with MSVC warn, cont 1"," namespace internal {
 // C4805('==': unsafe mix of type 'const int' and type 'const bool')
 #ifdef _MSC_VER
 # pragma warning(push)
-# pragma warning(disable:4100)
-# pragma warning(disable:C4805)
+# pragma warning(disable: 4100 C4805)
 #endif
 
 // Joins a vector of strings as if they are fields of a tuple; returns
",224,3
preproc syntax ( I can never remember it),"
 
 // Silence C4800 (C4800: 'int *const ': forcing value
 // to bool 'true' or 'false') for MSVC 14
-#ifdef _MSC_VER && (_MSC_VER == 1900)
-# pragma warning(push)
-# pragma warning(disable:4800)
+#ifdef _MSC_VER
+#if _MSC_VER == 1900
+# pragma warning(push)
+# pragma warning(disable:4800)
+#endif
 #endif
 
 namespace testing {
 InSequence::~InSequence() {
 
 } // namespace testing
 
-#ifdef _MSC_VER && (_MSC_VER == 1900)
-# pragma warning(pop)
+#ifdef _MSC_VER
+#if _MSC_VER == 1900
+# pragma warning(pop)
+#endif
 #endif
",544,119
And also silence for MSVS14,"
 #endif
 
 // Silence C4800 (C4800: 'int *const ': forcing value
-// to bool 'true' or 'false') for MSVC 14
+// to bool 'true' or 'false') for MSVC 14,15
 #ifdef _MSC_VER
-#if _MSC_VER == 1900
+#if _MSC_VER <= 1900
 # pragma warning(push)
 # pragma warning(disable:4800)
 #endif
",544,119
"Revert ""gmock actions 2""","
-// This file was GENERATED by command:
-// pump.py gmock-generated-actions.h.pump
-// DO NOT EDIT BY HAND!!!
+// This file was GENERATED by a script. DO NOT EDIT BY HAND!!!
 
 // Copyright 2007, Google Inc.
 // All rights reserved.
",820,100
"RE-Doing the merge, this time with gcc on mac in the PR so I can catch errors before merging the PR","
 #endif
 
 // Silence C4800 (C4800: 'int *const ': forcing value
-// to bool 'true' or 'false') for MSVC 14
-#ifdef _MSC_VER && _MSC_VER == 1900
-# pragma warning(push)
-# pragma warning(disable:4800)
+// to bool 'true' or 'false') for MSVC 14,15
+#ifdef _MSC_VER
+#if _MSC_VER <= 1900
+# pragma warning(push)
+# pragma warning(disable:4800)
+#endif
 #endif
-
 
 namespace testing {
 namespace internal {
 InSequence::~InSequence() {
 
 } // namespace testing
 
-#ifdef _MSC_VER && _MSC_VER == 1900
-# pragma warning(pop)
+#ifdef _MSC_VER
+#if _MSC_VER <= 1900
+# pragma warning(pop)
+#endif
 #endif
",544,119
..and this should be it,"
 namespace testing {
 namespace internal {
 
+// Silence MSVC C4100 (unreferenced formal parameter) and
+// C4805('==': unsafe mix of type 'const int' and type 'const bool')
+#ifdef _MSC_VER
+# pragma warning(push)
+# pragma warning(disable:4100)
+# pragma warning(disable:4805)
+#endif
+
 // Joins a vector of strings as if they are fields of a tuple; returns
 // the joined string.
 GTEST_API_ std::string JoinAsTuple(const Strings& fields);
 struct BooleanConstant {};
 
 // Emit an assertion failure due to incorrect DoDefault() usage. Out-of-lined to
 // reduce code size.
-void IllegalDoDefault(const char* file, int line);
+GTEST_API_ void IllegalDoDefault(const char* file, int line);
 
 #if GTEST_LANG_CXX11
 // Helper types for Apply() below.
 auto Apply(F&& f, Tuple&& args)
 make_int_pack<std::tuple_size<Tuple>::value>());
 }
 #endif
+
+
+#ifdef _MSC_VER
+# pragma warning(pop)
+#endif
+
 } // namespace internal
 } // namespace testing
 
",224,3
Upstream cl/192179348," class VariantMatcher {
 private:
 static std::string GetTypeName() {
 #if GTEST_HAS_RTTI
- return internal::GetTypeName<T>();
+ GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(
+ return internal::GetTypeName<T>());
 #endif
 return ""the element type"";
 }
 class AnyCastMatcher {
 private:
 static std::string GetTypeName() {
 #if GTEST_HAS_RTTI
- return internal::GetTypeName<T>();
+ GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(
+ return internal::GetTypeName<T>());
 #endif
 return ""the element type"";
 }
",3236,646
"merge, ... gmock-matchers test","
 
 // Disable MSVC2015 warning for std::pair:
 // ""decorated name length exceeded, name was truncated"".
-#if defined(_MSC_VER) && (_MSC_VER == 1900)
+#if defined(_MSC_VER) && (_MSC_VER <= 1900)
 # pragma warning(push)
 # pragma warning(disable:4503)
 #endif
 namespace convertible_from_any {
 struct ConvertibleFromAny {
 ConvertibleFromAny(int a_value) : value(a_value) {}
 template <typename T>
- explicit ConvertibleFromAny(const T& /*a_value*/) : value(-1) {
+ ConvertibleFromAny(const T& /*a_value*/) : value(-1) {
 ADD_FAILURE() << ""Conversion constructor called"";
 }
 int value;
 TEST(NotTest, WorksOnMoveOnlyType) {
 } // namespace gmock_matchers_test
 } // namespace testing
 
-#if defined(_MSC_VER) && (_MSC_VER == 1900)
+#if defined(_MSC_VER) && (_MSC_VER <= 1900)
 # pragma warning(pop)
 #endif
 
",4922,663
"merging, fix OSX issue","
 #include ""gmock/internal/gmock-internal-utils.h""
 #include <stdlib.h>
 #include <map>
-#include <memory>
 #include <string>
 #include <sstream>
 #include <vector>
",480,77
more fixing osx libstd++ bugs," TEST(InvokeTest, FunctionThatTakes10Arguments) {
 // Tests using Invoke() with functions with parameters declared as Unused.
 TEST(InvokeTest, FunctionWithUnusedParameters) {
 Action<int(int, int, double, const std::string&)> a1 = Invoke(SumOfFirst2);
- EXPECT_EQ(12, a1.Perform(make_tuple(10, 2, 5.6, std::string(""hi""))));
+ tuple<int, int, double, std::string> dummy = make_tuple(10, 2, 5.6, std::string(""hi""));
+ EXPECT_EQ(12, a1.Perform(dummy));
 
 Action<int(int, int, bool, int*)> a2 =
 Invoke(SumOfFirst2);
",514,98
merging gmock actions test," using testing::ReturnRef;
 using testing::ReturnRefOfCopy;
 using testing::SetArgPointee;
 using testing::SetArgumentPointee;
+using testing::Unused;
 using testing::_;
 using testing::get;
 using testing::internal::BuiltInDefaultValue;
",995,139
"merging, testing, this should be it"," TEST(FunctorActionTest, UnusedArguments) {
 // Verify that users can ignore uninteresting arguments.
 Action<int(int, double y, double z)> a =
 [](int i, Unused, Unused) { return 2 * i; };
- tuple<int, double, const int&> dummy = make_tuple(3, 7.3, 9.44);
+ tuple<int, double, double> dummy = make_tuple(3, 7.3, 9.44);
 EXPECT_EQ(6, a.Perform(dummy));
 }
 
",996,139
"merge, explicit, ( should be it)"," namespace convertible_from_any {
 struct ConvertibleFromAny {
 ConvertibleFromAny(int a_value) : value(a_value) {}
 template <typename T>
- explicit ConvertibleFromAny(const T& /*a_value*/) : value(-1) {
+ ConvertibleFromAny(const T& /*a_value*/) : value(-1) {
 ADD_FAILURE() << ""Conversion constructor called"";
 }
 int value;
",4940,666
Clone of unsubmitted cr/176529515. Introduce parameterless expectations.," GTEST_API_ bool LogIsVisible(LogSeverity severity);
 GTEST_API_ void Log(LogSeverity severity, const std::string& message,
 int stack_frames_to_skip);
 
+// A marker class that is used to resolve parameterless expectations to the
+// correct overload. This must not be instantiable, to prevent client code from
+// accidentally resolving to the overload; for example:
+//
+// ON_CALL(mock, Method({}, nullptr))
+//
+class WithoutMatchers {
+ private:
+ WithoutMatchers() {}
+ friend WithoutMatchers GetWithoutMatchers();
+};
+
+// Internal use only: access the singleton instance of WithoutMatchers.
+WithoutMatchers GetWithoutMatchers();
+
 // TODO(wan@google.com): group all type utilities together.
 
 // Type traits.
",230,3
Don't use generalized initializer list; is C++11 extension.," GTEST_API_ void Log(LogSeverity severity, const std::string& message,
 std::cout << ::std::flush;
 }
 
-WithoutMatchers GetWithoutMatchers() { return {}; }
+WithoutMatchers GetWithoutMatchers() { return WithoutMatchers(); }
 
 GTEST_API_ void IllegalDoDefault(const char* file, int line) {
 internal::Assert(
",106,31
"Mark new GetWithoutMatchers method as part of the exported API, to address MSVC linker errors."," class WithoutMatchers {
 };
 
 // Internal use only: access the singleton instance of WithoutMatchers.
-WithoutMatchers GetWithoutMatchers();
+GTEST_API_ WithoutMatchers GetWithoutMatchers();
 
 // TODO(wan@google.com): group all type utilities together.
 
",230,3
Add GTEST_API_ tag to WithoutMatchers class. Hopefully that fixes the problem on MSVC?," GTEST_API_ void Log(LogSeverity severity, const std::string& message,
 //
 // ON_CALL(mock, Method({}, nullptr))
 //
-class WithoutMatchers {
+class GTEST_API_ WithoutMatchers {
 private:
 WithoutMatchers() {}
 friend WithoutMatchers GetWithoutMatchers();
",230,3
Revert useless use of GTEST_API_ on WithoutMatchers decl.," GTEST_API_ void Log(LogSeverity severity, const std::string& message,
 //
 // ON_CALL(mock, Method({}, nullptr))
 //
-class GTEST_API_ WithoutMatchers {
+class WithoutMatchers {
 private:
 WithoutMatchers() {}
 friend WithoutMatchers GetWithoutMatchers();
",230,3
Fix friend declaration to use GTEST_API_ decl spec.," GTEST_API_ void Log(LogSeverity severity, const std::string& message,
 class WithoutMatchers {
 private:
 WithoutMatchers() {}
- friend WithoutMatchers GetWithoutMatchers();
+ friend GTEST_API_ WithoutMatchers GetWithoutMatchers();
 };
 
 // Internal use only: access the singleton instance of WithoutMatchers.
",230,3
reverting just to test," TEST(MatcherCastTest, NonImplicitlyConstructibleTypeWithOperatorEq) {
 namespace convertible_from_any {
 // Implicitly convertible from any type.
 struct ConvertibleFromAny {
- ConvertibleFromAny(int a_value) : value(a_value) {}
+explicit ConvertibleFromAny(int a_value) : value(a_value) {}
 template <typename T>
 ConvertibleFromAny(const T& /*a_value*/) : value(-1) {
 ADD_FAILURE() << ""Conversion constructor called"";
",4940,666
Add Fuchsia support for death test.," class TestEventListenersAccessor;
 class TestEventRepeater;
 class UnitTestRecordPropertyTestHelper;
 class WindowsDeathTest;
+class FuchsiaDeathTest;
 class UnitTestImpl* GetUnitTestImpl();
 void ReportFailureInUnknownLocation(TestPartResult::Type result_type,
 const std::string& message);
 class GTEST_API_ TestResult {
 friend class internal::TestResultAccessor;
 friend class internal::UnitTestImpl;
 friend class internal::WindowsDeathTest;
+ friend class internal::FuchsiaDeathTest;
 
 // Gets the vector of TestPartResults.
 const std::vector<TestPartResult>& test_part_results() const {
",718,110
Fix more stuff and get tests to pass,"
 #endif // GTEST_OS_AIX
 
 #if GTEST_OS_FUCHSIA
+# include <zircon/process.h>
 # include <zircon/syscalls.h>
 #endif
 
 size_t GetThreadCount() {
 #elif GTEST_OS_FUCHSIA
 
 size_t GetThreadCount() {
- return static_cast<size_t>(zx_system_get_num_cpus());
+ int dummy_buffer;
+ size_t avail;
+ zx_status_t status = zx_object_get_info(
+ zx_process_self(),
+ ZX_INFO_PROCESS_THREADS,
+ &dummy_buffer,
+ 0,
+ nullptr,
+ &avail);
+ if(status == ZX_OK) {
+ return avail;
+ } else {
+ return 0;
+ }
 }
 
 #else
",806,205
"Fix the bug where ad_hoc_test_result() functions of UnitTest and TestCase objects would return failures registered at TestCase and UnitTest scopes, respectively."," OsStackTraceGetterInterface* UnitTestImpl::os_stack_trace_getter() {
 return os_stack_trace_getter_;
 }
 
-// Returns the TestResult for the test that's currently running, or
-// the TestResult for the ad hoc test if no test is running.
+// Returns the most specific TestResult currently running.
 TestResult* UnitTestImpl::current_test_result() {
- return current_test_info_ ?
- &(current_test_info_->result_) : &ad_hoc_test_result_;
+ if (current_test_info_ != nullptr) {
+ return &current_test_info_->result_;
+ }
+ if (current_test_case_ != nullptr) {
+ return &current_test_case_->ad_hoc_test_result_;
+ }
+ return &ad_hoc_test_result_;
 }
 
 // Shuffles all test cases, and the tests within each test case,
",3606,870
"Use NULL instead of nullptr, for pre-C++11 builds."," OsStackTraceGetterInterface* UnitTestImpl::os_stack_trace_getter() {
 
 // Returns the most specific TestResult currently running.
 TestResult* UnitTestImpl::current_test_result() {
- if (current_test_info_ != nullptr) {
+ if (current_test_info_ != NULL) {
 return &current_test_info_->result_;
 }
- if (current_test_case_ != nullptr) {
+ if (current_test_case_ != NULL) {
 return &current_test_case_->ad_hoc_test_result_;
 }
 return &ad_hoc_test_result_;
",3606,870
Remove unused variable in Fuchsia.," namespace internal {
 
 // Valid only for fast death tests. Indicates the code is running in the
 // child process of a fast style death test.
-# if !GTEST_OS_WINDOWS
+# if !GTEST_OS_WINDOWS && !GTEST_OS_FUCHSIA
 static bool g_in_fast_death_test_child = false;
 # endif
 
",879,166
"Upstream, cl/199129756

Add printer for std::nullptr_t, addressing https://github.com/google/googletest/issues/1616"," inline void PrintTo(absl::string_view sp, ::std::ostream* os) {
 }
 #endif // GTEST_HAS_ABSL
 
+#if GTEST_LANG_CXX11
+inline void PrintTo(std::nullptr_t, ::std::ostream* os) { *os << ""(nullptr)""; }
+#endif // GTEST_LANG_CXX11
+
 #if GTEST_HAS_TR1_TUPLE || GTEST_HAS_STD_TUPLE_
 // Helper function for printing a tuple. T must be instantiated with
 // a tuple type.
",528,89
Fuchsia: Change fdio include path.,"
 # endif // GTEST_OS_QNX
 
 # if GTEST_OS_FUCHSIA
-# include <fdio/io.h>
-# include <fdio/spawn.h>
+# include <lib/fdio/io.h>
+# include <lib/fdio/spawn.h>
 # include <zircon/processargs.h>
 # include <zircon/syscalls.h>
 # endif // GTEST_OS_FUCHSIA
",882,166
"Rename AdvancedGuide.md to advanced.md and adjust the links. 
Part of documentation rationalization work"," EXAMPLES
 This tool is experimental. In particular, it assumes that there is no
 conditional inclusion of Google Test headers. Please report any
 problems to googletestframework@googlegroups.com. You can read
-https://github.com/google/googletest/blob/master/googletest/docs/AdvancedGuide.md for
+https://github.com/google/googletest/blob/master/googletest/docs/advanced.md for
 more information.
 """"""
 
",124,26
"Eliminate GTEST_TEST_FILTER_ENV_VAR_.

GTEST_TEST_FILTER_ENV_VAR_ was used to specify an environment variable to obtain
the default test filter from. By default it was unset which broke
""--test_filter"" for bazel. This CL eliminates GTEST_TEST_FILTER_ENV_VAR_ and
explicitly obtains the default test filter from the environment variable
TESTBRIDGE_TEST_ONLY if it exists."," bool g_help_flag = false;
 
 } // namespace internal
 
+// Bazel passes in the argument to '--test_filter' via the TESTBRIDGE_TEST_ONLY
+// environment variable.
 static const char* GetDefaultFilter() {
-#ifdef GTEST_TEST_FILTER_ENV_VAR_
- const char* const testbridge_test_only = getenv(GTEST_TEST_FILTER_ENV_VAR_);
+ const char* const testbridge_test_only =
+ internal::posix::GetEnv(""TESTBRIDGE_TEST_ONLY"");
 if (testbridge_test_only != NULL) {
 return testbridge_test_only;
 }
-#endif // GTEST_TEST_FILTER_ENV_VAR_
 return kUniversalFilter;
 }
 
",3607,869
FIX: Compilation warning with GCC regarding a non-initialised member from MutexBase class.," class MutexBase {
 // This allows initialization to work whether pthread_t is a scalar or struct.
 // The flag -Wmissing-field-initializers must not be specified for this to work.
 # define GTEST_DEFINE_STATIC_MUTEX_(mutex) \
- ::testing::internal::MutexBase mutex = { PTHREAD_MUTEX_INITIALIZER, false }
+ ::testing::internal::MutexBase mutex = { PTHREAD_MUTEX_INITIALIZER, false, 0 }
 
 // The Mutex class can only be used for mutexes created at runtime. It
 // shares its API with MutexBase otherwise.
",757,167
VS2005 with SP1(_MSC_VER=1400) already supports __pragma,"
 // GTEST_DISABLE_MSC_WARNINGS_PUSH_(4800 4385)
 // /* code that triggers warnings C4800 and C4385 */
 // GTEST_DISABLE_MSC_WARNINGS_POP_()
-#if _MSC_VER >= 1500
+#if _MSC_VER >= 1400
 # define GTEST_DISABLE_MSC_WARNINGS_PUSH_(warnings) \
 __pragma(warning(push)) \
 __pragma(warning(disable: warnings))
",757,167
"Fix issue #1654.

Signed-off-by: Adrian Moran <amoran@ikerlan.es>","
 namespace {
 
 using testing::HasSubstr;
+#if GTEST_HAS_EXCEPTIONS
 using testing::internal::GoogleTestFailureException;
+#endif
 
 // A type that cannot be default constructed.
 class NonDefaultConstructible {
",30,4
"Avoid full test in no exceptions are enabled.

Signed-off-by: Adrian Moran <amoran@ikerlan.es>","
 
 // Tests Google Mock's functionality that depends on exceptions.
 
+#if GTEST_HAS_EXCEPTIONS
 #include ""gmock/gmock.h""
 #include ""gtest/gtest.h""
 
 namespace {
 
 using testing::HasSubstr;
-#if GTEST_HAS_EXCEPTIONS
 using testing::internal::GoogleTestFailureException;
-#endif
 
 // A type that cannot be default constructed.
 class NonDefaultConstructible {
 class MockFoo {
 MOCK_METHOD0(GetNonDefaultConstructible, NonDefaultConstructible());
 };
 
-#if GTEST_HAS_EXCEPTIONS
 
 TEST(DefaultValueTest, ThrowsRuntimeErrorWhenNoDefaultValue) {
 MockFoo mock;
 TEST(DefaultValueTest, ThrowsRuntimeErrorWhenNoDefaultValue) {
 }
 }
 
-#endif
-
 } // unnamed namespace
+#endif
",30,4
Adds the UniversalPrinter for absl::variant.,"
 #if GTEST_HAS_ABSL
 #include ""absl/strings/string_view.h""
 #include ""absl/types/optional.h""
+#include ""absl/types/variant.h""
 #endif // GTEST_HAS_ABSL
 
 namespace testing {
 class UniversalPrinter<::absl::optional<T>> {
 }
 };
 
+// Printer for absl::variant
+
+template <typename... T>
+class UniversalPrinter<::absl::variant<T...>> {
+ public:
+ static void Print(const ::absl::variant<T...>& value, ::std::ostream* os) {
+ *os << '(';
+ absl::visit(Visitor{os}, value);
+ *os << ')';
+ }
+
+ private:
+ struct Visitor {
+ template <typename U>
+ void operator()(const U& u) const {
+ *os << ""'"" << GetTypeName<U>() << ""' with value "";
+ UniversalPrint(u, os);
+ }
+ ::std::ostream* os;
+ };
+};
+
 #endif // GTEST_HAS_ABSL
 
 // UniversalPrintArray(begin, len, os) prints an array of 'len'
",547,91
"Put ifdef guard after the includes.

Signed-off-by: Adrian Moran <amoran@ikerlan.es>","
 
 // Tests Google Mock's functionality that depends on exceptions.
 
-#if GTEST_HAS_EXCEPTIONS
 #include ""gmock/gmock.h""
 #include ""gtest/gtest.h""
 
+#if GTEST_HAS_EXCEPTIONS
 namespace {
 
 using testing::HasSubstr;
",30,4
Disable MSVC function deprecation when using Clang," GTestLog::~GTestLog() {
 
 // Disable Microsoft deprecation warnings for POSIX functions called from
 // this class (creat, dup, dup2, and close)
-GTEST_DISABLE_MSC_WARNINGS_PUSH_(4996)
+GTEST_DISABLE_MSC_DEPRECATED_PUSH_()
 
 #if GTEST_HAS_STREAM_REDIRECTION
 
 class CapturedStream {
 GTEST_DISALLOW_COPY_AND_ASSIGN_(CapturedStream);
 };
 
-GTEST_DISABLE_MSC_WARNINGS_POP_()
+GTEST_DISABLE_MSC_DEPRECATED_POP_()
 
 static CapturedStream* g_captured_stderr = NULL;
 static CapturedStream* g_captured_stdout = NULL;
",806,205
Fix warning C4819: The file contains a character that cannot be represented in the current code page (936). Save the file in Unicode format to prevent data loss," class FunctionMocker<R(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)> : public
 //
 // class MockClass {
 // // Overload 1
-// MockSpec<string&()> gmock_GetName() {  }
+// MockSpec<string&()> gmock_GetName() { ... }
 // // Overload 2. Declared const so that the compiler will generate an
 // // error when trying to resolve between this and overload 4 in
 // // 'gmock_GetName(WithoutMatchers(), nullptr)'.
 class FunctionMocker<R(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)> : public
 // }
 //
 // // Overload 3
-// const string& gmock_GetName() const {  }
+// const string& gmock_GetName() const { ... }
 // // Overload 4
 // MockSpec<const string&()> gmock_GetName(
 // const WithoutMatchers&, const Function<const string&()>*) const{
",378,46
Formatting and a link," class scoped_ptr {
 // Defines RE.
 
 #if GTEST_USES_PCRE
-using ::RE;
+// if used, PCRE is injected by custom/gtest-port.h
 #elif GTEST_USES_POSIX_RE || GTEST_USES_SIMPLE_RE
 
 // A simple C++ wrapper for <regex.h>. It uses the POSIX Extended
",756,167
"Code sync, mostly formatting and removing outdates","
 namespace {
 
 using testing::HasSubstr;
+
 using testing::internal::GoogleTestFailureException;
 
 // A type that cannot be default constructed.
 class MockFoo {
 MOCK_METHOD0(GetNonDefaultConstructible, NonDefaultConstructible());
 };
 
-
 TEST(DefaultValueTest, ThrowsRuntimeErrorWhenNoDefaultValue) {
 MockFoo mock;
 try {
 TEST(DefaultValueTest, ThrowsRuntimeErrorWhenNoDefaultValue) {
 }
 }
 
+
 } // unnamed namespace
 #endif
",30,4
"Formatting changes, code sync","
 // threads concurrently.
 
 #include ""gmock/gmock.h""
-
 #include ""gtest/gtest.h""
 
 namespace testing {
 namespace {
 
-// From ""gtest/internal/gtest-port.h"".
+// From gtest-port.h.
 using ::testing::internal::ThreadWithParam;
 
 // The maximum number of test threads (not including helper threads)
",197,22
Updated broken and outdated URLs," Mutex::~Mutex() {
 // to clean them up.
 // TODO(yukawa): Switch to Slim Reader/Writer (SRW) Locks, which requires
 // nothing to clean it up but is available only on Vista and later.
- // http://msdn.microsoft.com/en-us/library/windows/desktop/aa904937.aspx
+ // https://docs.microsoft.com/en-us/windows/desktop/Sync/slim-reader-writer--srw--locks
 if (type_ == kDynamic) {
 ::DeleteCriticalSection(critical_section_);
 delete critical_section_;
",806,205
Formatting changes for automatic code management,"
 //
 // This file implements some commonly used actions.
 
+// GOOGLETEST_CM0002 DO NOT DELETE
+
 #ifndef GMOCK_INCLUDE_GMOCK_GMOCK_ACTIONS_H_
 #define GMOCK_INCLUDE_GMOCK_GMOCK_ACTIONS_H_
 
",641,114
"small tweaks, OSS merge cl 206357486","
 #include ""gtest/gtest.h""
 
 GTEST_API_ int main(int argc, char **argv) {
- printf(""Running main() from gtest_main.cc\n"");
+ printf(""Running main() from %s\n"", __FILE__);
 testing::InitGoogleTest(&argc, argv);
 return RUN_ALL_TESTS();
 }
",7,1
Formatting changes and upstreaming one test,"
 
 __author__ = 'wan@google.com (Zhanyong Wan)'
 
-
 import gmock_test_utils
 
-
 PROGRAM_PATH = gmock_test_utils.GetTestExecutablePath('gmock_leak_test_')
 TEST_WITH_EXPECT_CALL = [PROGRAM_PATH, '--gtest_filter=*ExpectCall*']
 TEST_WITH_ON_CALL = [PROGRAM_PATH, '--gtest_filter=*OnCall*']
",56,5
googltest-color-test changes," IS_WINDOWS = os.name == 'nt'
 
 COLOR_ENV_VAR = 'GTEST_COLOR'
 COLOR_FLAG = 'gtest_color'
-COMMAND = gtest_test_utils.GetTestExecutablePath('gtest_color_test_')
+COMMAND = gtest_test_utils.GetTestExecutablePath('googletest-color-test_')
 
 
 def SetEnvVar(env_var, value):
 def SetEnvVar(env_var, value):
 
 
 def UsesColor(term, color_env_var, color_flag):
- """"""Runs gtest_color_test_ and returns its exit code.""""""
+ """"""Runs googletest-color-test_ and returns its exit code.""""""
 
 SetEnvVar('TERM', term)
 SetEnvVar(COLOR_ENV_VAR, color_env_var)
",66,14
changes for googletest env var test," import gtest_test_utils
 IS_WINDOWS = os.name == 'nt'
 IS_LINUX = os.name == 'posix' and os.uname()[0] == 'Linux'
 
-COMMAND = gtest_test_utils.GetTestExecutablePath('gtest_env_var_test_')
+COMMAND = gtest_test_utils.GetTestExecutablePath('googletest-env-var-test_')
 
 environ = os.environ.copy()
 
 def SetEnvVar(env_var, value):
 
 
 def GetFlag(flag):
- """"""Runs gtest_env_var_test_ and returns its output.""""""
+ """"""Runs googletest-env-var-test_ and returns its output.""""""
 
 args = [COMMAND]
 if flag is not None:
",54,12
changes to googletest break on failure and googletest filter unittests,"
 // Tests Google Test's throw-on-failure mode with exceptions disabled.
 //
 // This program must be compiled with exceptions disabled. It will be
-// invoked by gtest_throw_on_failure_test.py, and is expected to exit
+// invoked by googletest-throw-on-failure-test.py, and is expected to exit
 // with non-zero in the throw-on-failure mode or 0 otherwise.
 
 #include ""gtest/gtest.h""
",15,3
gtest catch exceptions test and gtest shuffle test," FILTER_FLAG = FLAG_PREFIX + 'filter'
 # Path to the gtest_catch_exceptions_ex_test_ binary, compiled with
 # exceptions enabled.
 EX_EXE_PATH = gtest_test_utils.GetTestExecutablePath(
- 'gtest_catch_exceptions_ex_test_')
+ 'googletest_catch_exceptions_ex_test_')
 
 # Path to the gtest_catch_exceptions_test_ binary, compiled with
 # exceptions disabled.
 EXE_PATH = gtest_test_utils.GetTestExecutablePath(
- 'gtest_catch_exceptions_no_ex_test_')
+ 'googletest_catch_exceptions_no_ex_test_')
 
 environ = gtest_test_utils.environ
 SetEnvVar = gtest_test_utils.SetEnvVar
",158,12
various changes to tests," TEST(CxxExceptionDeathTest, PrintsMessageForStdExceptions) {
 ""exceptional message"");
 // Verifies that the location is mentioned in the failure text.
 EXPECT_NONFATAL_FAILURE(EXPECT_DEATH(throw TestException(), """"),
- ""gtest-death-test_ex_test.cc"");
+ ""googletest-death-test_ex_test.cc"");
 }
 # endif // GTEST_HAS_EXCEPTIONS
 
",34,8
cleaning up and adding test changes to CMake," TEST(MacroTest, ADD_FAILURE_AT) {
 // Unfortunately, we cannot verify that the failure message contains
 // the right file path and line number the same way, as
 // EXPECT_NONFATAL_FAILURE() doesn't get to see the file path and
- // line number. Instead, we do that in gtest_output_test_.cc.
+ // line number. Instead, we do that in googletest-output-test_.cc.
 }
 
 // Tests FAIL.
",5221,721
"Printers test: fixed compilation bug, due to unnecessary parentheses in declaration"," struct Foo {
 TEST(PrintPointerTest, MemberVariablePointer) {
 EXPECT_TRUE(HasPrefix(Print(&Foo::value),
 Print(sizeof(&Foo::value)) + ""-byte object ""));
- int (Foo::*p) = NULL; // NOLINT
+ int Foo::*p = NULL; // NOLINT
 EXPECT_TRUE(HasPrefix(Print(p),
 Print(sizeof(p)) + ""-byte object ""));
 }
 TEST(PrintReferenceTest, HandlesMemberFunctionPointer) {
 // Tests that the universal printer prints a member variable pointer
 // passed by reference.
 TEST(PrintReferenceTest, HandlesMemberVariablePointer) {
- int (Foo::*p) = &Foo::value; // NOLINT
+ int Foo::*p = &Foo::value; // NOLINT
 EXPECT_TRUE(HasPrefix(
 PrintByRef(p),
 ""@"" + PrintPointer(&p) + "" "" + Print(sizeof(p)) + ""-byte object ""));
",1123,179
"automatic code sync mgt, comment only"," class Foo {
 int value_;
 };
 
+// GOOGLETEST_CM0005 DO NOT DELETE
+
 // Tests InvokeWithoutArgs(function).
 TEST(InvokeWithoutArgsTest, Function) {
 // As an action that takes one argument.
",883,131
"small cleanup, np functional changes"," class Foo {
 int value_;
 };
 
-// GOOGLETEST_CM0005 DO NOT DELETE
-
 // Tests InvokeWithoutArgs(function).
 TEST(InvokeWithoutArgsTest, Function) {
 // As an action that takes one argument.
",883,131
"Formatting changes,small cleanup, no functionality changes","
 #if GTEST_LANG_CXX11
 # define GTEST_HAS_STD_TUPLE_ 1
 # if defined(__clang__)
-// Inspired by https://clang.llvm.org/docs/LanguageExtensions.html#include-file-checking-macros
+// Inspired by
+// https://clang.llvm.org/docs/LanguageExtensions.html#include-file-checking-macros
 # if defined(__has_include) && !__has_include(<tuple>)
 # undef GTEST_HAS_STD_TUPLE_
 # endif
",756,167
upsream additional printer test," TEST(PrintOptionalTest, Basic) {
 EXPECT_EQ(""(1.1)"", PrintToString(absl::optional<double>{1.1}));
 EXPECT_EQ(""(\""A\"")"", PrintToString(absl::optional<std::string>{""A""}));
 }
+
+struct NonPrintable {
+ unsigned char contents = 17;
+};
+
+TEST(PrintOneofTest, Basic) {
+ using Type = absl::variant<int, StreamableInGlobal, NonPrintable>;
+ EXPECT_EQ(""('int' with value 7)"", PrintToString(Type(7)));
+ EXPECT_EQ(""('StreamableInGlobal' with value StreamableInGlobal)"",
+ PrintToString(Type(StreamableInGlobal{})));
+ EXPECT_EQ(
+ ""('testing::gtest_printers_test::NonPrintable' with value 1-byte object ""
+ ""<11>)"",
+ PrintToString(Type(NonPrintable{})));
+}
 #endif // GTEST_HAS_ABSL
 
 } // namespace gtest_printers_test
",1136,180
Fix typo breaking Fuchsia build," int FuchsiaDeathTest::Wait() {
 } else {
 // Process terminated.
 GTEST_DEATH_TEST_CHECK_(ZX_PKT_IS_SIGNAL_ONE(packet.type));
- GTEST_DEATH_TEST_CHECK_(packet.observed & ZX_PROCESS_TERMINATED);
+ GTEST_DEATH_TEST_CHECK_(packet.signal.observed & ZX_PROCESS_TERMINATED);
 }
 
 ReadAndInterpretStatusByte();
",906,168
"Merge branch 'master' of https://github.com/google/googletest

Formatting changes and code sync
Merge branch 'master' of https://github.com/google/googletest"," static std::string DeathTestThreadWarning(size_t thread_count) {
 msg << ""couldn't detect the number of threads."";
 else
 msg << ""detected "" << thread_count << "" threads."";
+ msg << "" See https://github.com/google/googletest/blob/master/googletest/docs/advanced.md#death-tests-and-threads""
+ << "" for more explanation and suggested solutions, especially if""
+ << "" this is the last message you see before your test times out."";
 return msg.GetString();
 }
 # endif // !GTEST_OS_WINDOWS && !GTEST_OS_FUCHSIA
 int FuchsiaDeathTest::Wait() {
 } else {
 // Process terminated.
 GTEST_DEATH_TEST_CHECK_(ZX_PKT_IS_SIGNAL_ONE(packet.type));
- GTEST_DEATH_TEST_CHECK_(packet.observed & ZX_PROCESS_TERMINATED);
+ GTEST_DEATH_TEST_CHECK_(packet.signal.observed & ZX_PROCESS_TERMINATED);
 }
 
 ReadAndInterpretStatusByte();
",909,168
"Formatting tweaks, no functionality changes","
 // exceptions, and the output is verified by
 // googletest-catch-exceptions-test.py.
 
-#include ""gtest/gtest.h""
-
 #include <stdio.h> // NOLINT
 #include <stdlib.h> // For exit().
 
+#include ""gtest/gtest.h""
+
 #if GTEST_HAS_SEH
 # include <windows.h>
 #endif
",204,48
"Formatting change for auto code management, no functionality changes


Merge branch 'master' of https://github.com/google/googletest","
 
 To update the golden file:
 gmock_output_test.py --build_dir=BUILD/DIR --gengolden
-# where BUILD/DIR contains the built gmock_output_test_ file.
+where BUILD/DIR contains the built gmock_output_test_ file.
 gmock_output_test.py --gengolden
 gmock_output_test.py
+
 """"""
 
 __author__ = 'wan@google.com (Zhanyong Wan)'
",69,11
"Fixing identation, causes build errors when warnings are treated as errors"," static std::string DeathTestThreadWarning(size_t thread_count) {
 else
 msg << ""detected "" << thread_count << "" threads."";
 msg << "" See https://github.com/google/googletest/blob/master/googletest/docs/advanced.md#death-tests-and-threads""
- << "" for more explanation and suggested solutions, especially if""
- << "" this is the last message you see before your test times out."";
+ << "" for more explanation and suggested solutions, especially if""
+ << "" this is the last message you see before your test times out."";
 return msg.GetString();
 }
 # endif // !GTEST_OS_WINDOWS && !GTEST_OS_FUCHSIA
",909,168
"code management comments, [ci-skip], no functionality changes","
 // GTEST_HAS_TYPED_TEST - typed tests
 // GTEST_HAS_TYPED_TEST_P - type-parameterized tests
 // GTEST_IS_THREADSAFE - Google Test is thread-safe.
+// GOOGLETEST_CM0007 DO NOT DELETE
 // GTEST_USES_POSIX_RE - enhanced POSIX regex is used. Do not confuse with
 // GTEST_HAS_POSIX_RE (see above) which users can
 // define themselves.

 // Regular expressions:
 // RE - a simple regular expression class using the POSIX
 // Extended Regular Expression syntax on UNIX-like platforms
+// GOOGLETEST_CM0008 DO NOT DELETE
 // or a reduced regular exception syntax on other
 // platforms, including Windows.
 // Logging:
",756,167
"formatting and small changes related to code management, no functionality changes","
 
 """"""Tests the text output of Google C++ Testing and Mocking Framework.
 
-
-SYNOPSIS
- googletest_output_test.py --build_dir=BUILD/DIR --gengolden
- # where BUILD/DIR contains the built googletest-output-test_ file.
- googletest_output_test.py --gengolden
- googletest_output_test.py
+To update the golden file:
+googletest_output_test.py --build_dir=BUILD/DIR --gengolden
+where BUILD/DIR contains the built googletest-output-test_ file.
+googletest_output_test.py --gengolden
+googletest_output_test.py
 """"""
 
 __author__ = 'wan@google.com (Zhanyong Wan)'
",170,22
Update gmock_output_test.py,"
 # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
-""""""Tests the text output of Google C++ Mocking Framework.
+r""""""Tests the text output of Google C++ Mocking Framework.
 
 To update the golden file:
 gmock_output_test.py --build_dir=BUILD/DIR --gengolden
",69,11
"Code formatting changes, clean up, no functionality changes"," bool DeathTestImpl::Passed(bool status_ok) {
 if (status_ok) {
 # if GTEST_USES_PCRE
 // PCRE regexes support embedded NULs.
- // GTEST_USES_PCRE is defined only in google3 mode
 const bool matched = RE::PartialMatch(error_message, *regex());
 # else
 const bool matched = RE::PartialMatch(error_message.c_str(), *regex());
",912,168
"Comments changes, no functionality changes","
 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-//
-// Author: wan@google.com (Zhanyong Wan)
+
 
 // Google Mock - a framework for writing C++ mock classes.
 //
",641,114
"Comments changes, no functionality changes."," class GTEST_API_ UntypedFunctionMockerBase {
 // this information in the global mock registry. Will be called
 // whenever an EXPECT_CALL() or ON_CALL() is executed on this mock
 // method.
- // TODO(wan@google.com): rename to SetAndRegisterOwner().
+ // FIXME: rename to SetAndRegisterOwner().
 void RegisterOwner(const void* mock_obj)
 GTEST_LOCK_EXCLUDED_(g_gmock_mutex);
 
 class TypedExpectation : public ExpectationBase {
 mocker->DescribeDefaultActionTo(args, what);
 DescribeCallCountTo(why);
 
- // TODO(wan@google.com): allow the user to control whether
+ // FIXME: allow the user to control whether
 // unexpected calls should fail immediately or continue using a
 // flag --gmock_unexpected_calls_are_fatal.
 return NULL;
",955,150
more comments changes," class MockObjectRegistry {
 if (it->second.leakable) // The user said it's fine to leak this object.
 continue;
 
- // TODO(wan@google.com): Print the type of the leaked object.
+ // FIXME: Print the type of the leaked object.
 // This can help the user identify the leaked object.
 std::cout << ""\n"";
 const MockObjectState& state = it->second;
",544,119
"Small formatting change

And then we can merge"," class MutexBase {
 // particular, the owner_ field (a pthread_t) is not explicitly initialized.
 // This allows initialization to work whether pthread_t is a scalar or struct.
 // The flag -Wmissing-field-initializers must not be specified for this to work.
-# define GTEST_DEFINE_STATIC_MUTEX_(mutex) \
- ::testing::internal::MutexBase mutex = { PTHREAD_MUTEX_INITIALIZER, false, 0 }
+#define GTEST_DEFINE_STATIC_MUTEX_(mutex) \
+ ::testing::internal::MutexBase mutex = {PTHREAD_MUTEX_INITIALIZER, false, 0}
 
 // The Mutex class can only be used for mutexes created at runtime. It
 // shares its API with MutexBase otherwise.
",756,167
Minor formatting/style changes,"
 # define vsnprintf _vsnprintf
 #endif // GTEST_OS_WINDOWS
 
-
 #if GTEST_OS_MAC
-# ifndef GTEST_OS_IOS
-# include <crt_externs.h>
-# endif
+#ifndef GTEST_OS_IOS
+#include <crt_externs.h>
+#endif
 #endif
 
 #if GTEST_HAS_ABSL
 void ParseGoogleTestFlagsOnlyImpl(int* argc, CharType** argv) {
 // other parts of Google Test.
 void ParseGoogleTestFlagsOnly(int* argc, char** argv) {
 ParseGoogleTestFlagsOnlyImpl(argc, argv);
- 
- // Fix the value of *_NSGetArgc() on macOS, but iff 
+
+ // Fix the value of *_NSGetArgc() on macOS, but iff
 // *_NSGetArgv() == argv
 // Only applicable to char** version of argv
 #if GTEST_OS_MAC
-# ifndef GTEST_OS_IOS
+#ifndef GTEST_OS_IOS
 if (*_NSGetArgv() == argv) {
 *_NSGetArgc() = *argc;
 }
-# endif
+#endif
 #endif
 }
 void ParseGoogleTestFlagsOnly(int* argc, wchar_t** argv) {
",3664,882
"Testing, adding a few line to sample4"," int Counter::Increment() {
 return counter_++;
 }
 
+// Returns the current counter value, and decrements it.
+// counter can not be less than 0, return 0 in this case
+ int Counter::Decrement() {
+ if (counter_==0){
+ return counter_;
+ }
+ else
+ return counter_--;
+ }
+
 // Prints the current counter value to STDOUT.
 void Counter::Print() const {
 printf(""%d"", counter_);
",15,4
"googletest export

 - 209457486 Import of OSS PR, https://github.com/google/googletest/pu... by misterg <misterg@google.com>

PiperOrigin-RevId: 209457486"," int Counter::Increment() {
 return counter_++;
 }
 
+// Returns the current counter value, and decrements it.
+// counter can not be less than 0, return 0 in this case
+int Counter::Decrement() {
+ if (counter_ == 0) {
+ return counter_;
+ } else {
+ return counter_--;
+ }
+}
+
 // Prints the current counter value to STDOUT.
 void Counter::Print() const {
 printf(""%d"", counter_);
",15,4
"googletest export

 - 209457654 Import of OSS PR, https://github.com/google/googletest/pu... by misterg <misterg@google.com>

PiperOrigin-RevId: 209457654","
 #include ""gmock/internal/gmock-port.h""
 #include ""gtest/gtest.h""
 
+GTEST_DISABLE_MSC_WARNINGS_PUSH_(4251 \
+/* class A needs to have dll-interface to be used by clients of class B */)
+
 namespace testing {
 
 // To implement a cardinality Foo, define:
 inline Cardinality MakeCardinality(const CardinalityInterface* c) {
 
 } // namespace testing
 
+GTEST_DISABLE_MSC_WARNINGS_POP_() // 4251
+
 #endif // GMOCK_INCLUDE_GMOCK_GMOCK_CARDINALITIES_H_
",48,13
"Googletest export

Internal Change

PiperOrigin-RevId: 209471987"," class GTEST_API_ TestCase {
 bool Passed() const { return !Failed(); }
 
 // Returns true iff the test case failed.
- bool Failed() const { return failed_test_count() > 0; }
+ bool Failed() const {
+ return failed_test_count() > 0 || ad_hoc_test_result().Failed();
+ }
 
 // Returns the elapsed time, in milliseconds.
 TimeInMillis elapsed_time() const { return elapsed_time_; }
",723,111
"Googletest export

Internal Change

PiperOrigin-RevId: 209498445"," class GTEST_API_ TestCase {
 bool Passed() const { return !Failed(); }
 
 // Returns true iff the test case failed.
- bool Failed() const {
- return failed_test_count() > 0 || ad_hoc_test_result().Failed();
- }
+ bool Failed() const { return failed_test_count() > 0; }
 
 // Returns the elapsed time, in milliseconds.
 TimeInMillis elapsed_time() const { return elapsed_time_; }
",721,110
"No longer require a functor passed to ResultOf matcher to define `result_of` type.
This makes ResultOf more convenient to use. In particular, the matcher now accepts
lambdas.

PiperOrigin-RevId: 210118509"," struct PolymorphicFunctor {
 typedef int result_type;
 int operator()(int n) { return n; }
 int operator()(const char* s) { return static_cast<int>(strlen(s)); }
+ std::string operator()(int *p) { return p ? ""good ptr"" : ""null""; }
 };
 
 TEST(ResultOfTest, WorksForPolymorphicFunctors) {
 TEST(ResultOfTest, WorksForPolymorphicFunctors) {
 EXPECT_FALSE(matcher_string.Matches(""shrt""));
 }
 
+#if GTEST_LANG_CXX11
+TEST(ResultOfTest, WorksForPolymorphicFunctorsIgnoringResultType) {
+ Matcher<int*> matcher = ResultOf(PolymorphicFunctor(), ""good ptr"");
+
+ int n = 0;
+ EXPECT_TRUE(matcher.Matches(&n));
+ EXPECT_FALSE(matcher.Matches(nullptr));
+}
+
+TEST(ResultOfTest, WorksForLambdas) {
+ Matcher<int> matcher =
+ ResultOf([](int str_len) { return std::string(str_len, 'x'); }, ""xxx"");
+ EXPECT_TRUE(matcher.Matches(3));
+ EXPECT_FALSE(matcher.Matches(1));
+}
+#endif
+
 const int* ReferencingFunction(const int& n) { return &n; }
 
 struct ReferencingFunctor {
",4997,673
"Merge 72a2836945e7a3dcee0730166704587e10bf64ee into 1d9a1912e7f42e8ae66ea365b5b8508fecb31509

Closes #1658

Review and changes, mister@google.com

PiperOrigin-RevId: 210374286"," TEST_F(UnitTestRecordPropertyTest,
 AddRecordWithReservedKeysGeneratesCorrectPropertyList) {
 EXPECT_NONFATAL_FAILURE(
 Test::RecordProperty(""name"", ""1""),
- ""'classname', 'name', 'status', 'time', 'type_param', and 'value_param'""
- "" are reserved"");
+ ""'classname', 'name', 'status', 'time', 'type_param', 'value_param',""
+ "" 'file', and 'line' are reserved"");
 }
 
 class UnitTestRecordPropertyTestEnvironment : public Environment {
",5221,721
"Googletest export

Fix line that was wrapping in the middle of a link

This looks uglier, but has the advantage that the link is kept in one
piece.

PiperOrigin-RevId: 210537337"," AnyOf(M1 m1, M2 m2, M3 m3, M4 m4, M5 m5, M6 m6, M7 m7, M8 m8, M9 m9, M10 m10) {
 // ================
 //
 // To learn more about using these macros, please search for 'MATCHER'
-// on https://github.com/google/googletest/blob/master/googlemock/docs/
-// CookBook.md
+// on
+// https://github.com/google/googletest/blob/master/googlemock/docs/CookBook.md
 
 #define MATCHER(name, description)\
 class name##Matcher {\
",959,74
MSVC warnings silence,"
 
 #include <stdlib.h>
 
+#if _MSC_VER
+ GTEST_DISABLE_MSC_WARNINGS_PUSH_(4127: /* conditional expression is constant */)
+#endif // . _MSC_VER 
+
 #if GTEST_IS_THREADSAFE
 using testing::ScopedFakeTestPartResultReporter;
 using testing::TestPartResultArray;
 int main(int argc, char **argv) {
 // are registered, and torn down in the reverse order.
 testing::AddGlobalTestEnvironment(new FooEnvironment);
 testing::AddGlobalTestEnvironment(new BarEnvironment);
-
+#if _MSC_VER
+ GTEST_DISABLE_MSC_WARNINGS_POP()
+#endif // . _MSC_VER 
 return RunAllTests();
 }
",643,123
Disable MCVS warnings,"
 
 #include ""gtest/gtest.h""
 
+#if _MSC_VER
+GTEST_DISABLE_MSC_WARNINGS_PUSH_(4127 /* conditional expression is constant */)
+#endif // _MSC_VER
+
 using testing::Test;
 
 // Used for testing that SetUpTestCase()/TearDownTestCase(), fixture
 INSTANTIATE_TYPED_TEST_CASE_P(My, TrimmedTest, TrimTypes);
 // must be defined). This dummy test keeps gtest_main linked in.
 TEST(DummyTest, TypedTestsAreNotSupportedOnThisPlatform) {}
 
+#if _MSC_VER
+GTEST_DISABLE_MSC_WARNINGS_POP_() // 4127
+#endif // _MSC_VER
+
 #endif // #if !defined(GTEST_HAS_TYPED_TEST) && !defined(GTEST_HAS_TYPED_TEST_P)
",248,44
Update gmock-matchers.h,"
 # include <initializer_list> // NOLINT -- must be after gtest.h
 #endif
 
-GTEST_DISABLE_MSC_WARNINGS_PUSH_(4251 \
-/* class A needs to have dll-interface to be used by clients of class B */)
+GTEST_DISABLE_MSC_WARNINGS_PUSH_(4251 5046 \
+/* class A needs to have dll-interface to be used by clients of class B */ \
+/* Symbol involving type with internal linkage not defined */)
 
 namespace testing {
 
 PolymorphicMatcher<internal::variant_matcher::VariantMatcher<T> > VariantWith(
 
 } // namespace testing
 
-GTEST_DISABLE_MSC_WARNINGS_POP_() // 4251
+GTEST_DISABLE_MSC_WARNINGS_POP_() // 4251 5046
 
 // Include any custom callback matchers added by the local installation.
 // We must include this header at the end to make sure it can use the
",3260,655
"Googletest export

Internal Change

PiperOrigin-RevId: 210594341","
 # include <initializer_list> // NOLINT -- must be after gtest.h
 #endif
 
-GTEST_DISABLE_MSC_WARNINGS_PUSH_(4251 5046 \
-/* class A needs to have dll-interface to be used by clients of class B */ \
-/* Symbol involving type with internal linkage not defined */)
+GTEST_DISABLE_MSC_WARNINGS_PUSH_(4251 \
+/* class A needs to have dll-interface to be used by clients of class B */)
 
 namespace testing {
 
 PolymorphicMatcher<internal::variant_matcher::VariantMatcher<T> > VariantWith(
 
 } // namespace testing
 
-GTEST_DISABLE_MSC_WARNINGS_POP_() // 4251 5046
+GTEST_DISABLE_MSC_WARNINGS_POP_() // 4251
 
 // Include any custom callback matchers added by the local installation.
 // We must include this header at the end to make sure it can use the
",3259,655
"Googletest export

Fix the typed test names in the tests for customized typed test parameters.

As required by googletest documentation, the names should not contain an underscore.

PiperOrigin-RevId: 210678652"," TYPED_TEST(FooTest, HasPropertyA) { ... }
 // static std::string GetName(int) {
 // if (std::is_same<T, char>()) return ""char"";
 // if (std::is_same<T, int>()) return ""int"";
-// if (std::is_same<T, unsigned int>()) return ""unsigned_int"";
+// if (std::is_same<T, unsigned int>()) return ""unsignedInt"";
 // }
 // };
 // TYPED_TEST_CASE(FooTest, MyTypes, MyTypeNames);
",34,4
"Googletest export

Silence MSVC warnings

PiperOrigin-RevId: 210726964","
 
 #include <stdlib.h>
 
+#if _MSC_VER
+GTEST_DISABLE_MSC_WARNINGS_PUSH_(4127 /* conditional expression is constant */)
+#endif // _MSC_VER
+
 #if GTEST_IS_THREADSAFE
 using testing::ScopedFakeTestPartResultReporter;
 using testing::TestPartResultArray;
 int main(int argc, char **argv) {
 // are registered, and torn down in the reverse order.
 testing::AddGlobalTestEnvironment(new FooEnvironment);
 testing::AddGlobalTestEnvironment(new BarEnvironment);
-
+#if _MSC_VER
+GTEST_DISABLE_MSC_WARNINGS_POP_() // 4127
+#endif // _MSC_VER
 return RunAllTests();
 }
",643,123
"Googletest export

Fix broken OSS windows build.

PiperOrigin-RevId: 210969049","
 # include <initializer_list> // NOLINT -- must be after gtest.h
 #endif
 
-GTEST_DISABLE_MSC_WARNINGS_PUSH_(4251 \
-/* class A needs to have dll-interface to be used by clients of class B */)
+GTEST_DISABLE_MSC_WARNINGS_PUSH_(
+ 4251 5046 /* class A needs to have dll-interface to be used by clients of
+ class B */
+ /* Symbol involving type with internal linkage not defined */)
 
 namespace testing {
 
 PolymorphicMatcher<internal::variant_matcher::VariantMatcher<T> > VariantWith(
 
 } // namespace testing
 
-GTEST_DISABLE_MSC_WARNINGS_POP_() // 4251
+GTEST_DISABLE_MSC_WARNINGS_POP_() // 4251 5046
 
 // Include any custom callback matchers added by the local installation.
 // We must include this header at the end to make sure it can use the
",3260,655
"Make dummy variables static to avoid compiler warnings

Fix -Wmissing-variable-declarations warnings from Clang."," INSTANTIATE_TYPED_TEST_CASE_P(My, FooTest, MyTypes);
 typedef gtest_TypeParam_ TypeParam; \
 virtual void TestBody(); \
 }; \
- bool gtest_##CaseName##_##TestName##_registered_ GTEST_ATTRIBUTE_UNUSED_ = \
+ static bool gtest_##CaseName##_##TestName##_registered_ \
+ GTEST_ATTRIBUTE_UNUSED_ = \
 ::testing::internal::TypeParameterizedTest< \
 CaseName, \
 ::testing::internal::TemplateSel<GTEST_TEST_CLASS_NAME_(CaseName, \
 INSTANTIATE_TYPED_TEST_CASE_P(My, FooTest, MyTypes);
 // since some compilers may choke on '>>' when passing a template
 // instance (e.g. Types<int>)
 # define INSTANTIATE_TYPED_TEST_CASE_P(Prefix, CaseName, Types, ...) \
- bool gtest_##Prefix##_##CaseName GTEST_ATTRIBUTE_UNUSED_ = \
+ static bool gtest_##Prefix##_##CaseName GTEST_ATTRIBUTE_UNUSED_ = \
 ::testing::internal::TypeParameterizedTestCase< \
 CaseName, GTEST_CASE_NAMESPACE_(CaseName)::gtest_AllTests_, \
 ::testing::internal::TypeList< Types >::type>:: \
",34,4
"Make g_argvs static

Fix Clang warning:
| warning: no previous extern declaration for non-static variable 'g_argvs'
| [-Wmissing-variable-declarations]"," void AssertHelper::operator=(const Message& message) const {
 GTEST_API_ GTEST_DEFINE_STATIC_MUTEX_(g_linked_ptr_mutex);
 
 // A copy of all command line arguments. Set by InitGoogleTest().
-::std::vector<std::string> g_argvs;
+static ::std::vector<std::string> g_argvs;
 
 ::std::vector<std::string> GetArgvs() {
 #if defined(GTEST_CUSTOM_GET_ARGVS_)
",3738,893
"Add missing declarations for Google Tests flags

Add declarations for install_failure_signal_handler and flagfile.

Fix Clang warnings:
| warning: no previous extern declaration for non-static variable
| 'FLAGS_gtest_install_failure_signal_handler' [-Wmissing-variable-declarations]
| warning: no previous extern declaration for non-static variable
| 'FLAGS_gtest_flagfile' | [-Wmissing-variable-declarations]"," GTEST_DECLARE_string_(color);
 // the tests to run. If the filter is not given all tests are executed.
 GTEST_DECLARE_string_(filter);
 
+// This flag controls whether Google Test installs a signal handler that dumps
+// debugging information when fatal signals are raised.
+GTEST_DECLARE_bool_(install_failure_signal_handler);
+
 // This flag causes the Google Test to list tests. None of the tests listed
 // are actually run if the flag is provided.
 GTEST_DECLARE_bool_(list_tests);
 GTEST_DECLARE_bool_(throw_on_failure);
 // the specified host machine.
 GTEST_DECLARE_string_(stream_result_to);
 
+#if GTEST_USE_OWN_FLAGFILE_FLAG_
+GTEST_DECLARE_string_(flagfile);
+#endif // GTEST_USE_OWN_FLAGFILE_FLAG_
+
 // The upper limit for valid stack trace depths.
 const int kMaxStackTraceDepth = 100;
 
",723,110
"Googletest export

Make EXPECT_THROW print the actual exception type on the ""threw the wrong exception type"" case if the actual exception is a std::exception

PiperOrigin-RevId: 211519873"," TEST(ExpectTest, EXPECT_THROW) {
 EXPECT_NONFATAL_FAILURE(EXPECT_THROW(ThrowAnInteger(), bool),
 ""Expected: ThrowAnInteger() throws an exception of ""
 ""type bool.\n Actual: it throws a different type."");
+ std::string expected = ""what() arg"";
+ EXPECT_NONFATAL_FAILURE(EXPECT_THROW(throw std::out_of_range(expected), bool),
+ expected);
 EXPECT_NONFATAL_FAILURE(
 EXPECT_THROW(ThrowNothing(), bool),
 ""Expected: ThrowNothing() throws an exception of type bool.\n""
 "" Actual: it throws nothing."");
 }
 
+// We need to make sure always to avoid having multiple blocks which catch a
+// std::exception
+TEST(ExpectTest, EXPECT_THROW_STD_EXCEPTION) {
+ EXPECT_THROW(throw std::exception(), std::exception);
+}
+
 // Tests EXPECT_NO_THROW.
 TEST(ExpectTest, EXPECT_NO_THROW) {
 EXPECT_NO_THROW(ThrowNothing());
",5227,722
"Googletest export

Make EXPECT_THROW print the actual exception type on the ""threw the wrong exception type"" case if the actual exception is a std::exception

PiperOrigin-RevId: 211524592"," TEST(ExpectTest, EXPECT_THROW) {
 EXPECT_NONFATAL_FAILURE(EXPECT_THROW(ThrowAnInteger(), bool),
 ""Expected: ThrowAnInteger() throws an exception of ""
 ""type bool.\n Actual: it throws a different type."");
- std::string expected = ""what() arg"";
- EXPECT_NONFATAL_FAILURE(EXPECT_THROW(throw std::out_of_range(expected), bool),
- expected);
 EXPECT_NONFATAL_FAILURE(
 EXPECT_THROW(ThrowNothing(), bool),
 ""Expected: ThrowNothing() throws an exception of type bool.\n""
 "" Actual: it throws nothing."");
 }
 
-// We need to make sure always to avoid having multiple blocks which catch a
-// std::exception
-TEST(ExpectTest, EXPECT_THROW_STD_EXCEPTION) {
- EXPECT_THROW(throw std::exception(), std::exception);
-}
-
 // Tests EXPECT_NO_THROW.
 TEST(ExpectTest, EXPECT_NO_THROW) {
 EXPECT_NO_THROW(ThrowNothing());
",5221,721
"Return GTEST_ATTRIBUTE_UNUSED_ on record_property_env to avoide comilation error (with -Werror)

The unused attribute was removed with commit 3299a23 on 2018-02-23, but it currently breaks build of 1.8.1, because of -Werror GCC parameter as reported in issue #1825."," class UnitTestRecordPropertyTestEnvironment : public Environment {
 };
 
 // This will test property recording outside of any test or test case.
-static Environment* record_property_env =
+static Environment* record_property_env GTEST_ATTRIBUTE_UNUSED_ =
 AddGlobalTestEnvironment(new UnitTestRecordPropertyTestEnvironment);
 
 // This group of tests is for predicate assertions (ASSERT_PRED*, etc)
",5221,721
Try to fix gcc and clang issues," class NativeArray {
 class AdditionalMessage
 {
 public:
- AdditionalMessage(const std::string& message) : value(message) {}
+ AdditionalMessage(const char* message) : value(message) {}
 AdditionalMessage& operator=(const std::string& message) { value = message; return *this; }
 operator bool() const { return ::testing::internal::AlwaysTrue(); }
 
",554,79
Avoid implicit move operator," public:
 const std::string& get() const { return value; }
 
 private:
+ AdditionalMessage& operator=(AdditionalMessage&&);
 std::string value;
 };
 
",555,79
Make it public again *sigh*," public:
 const std::string& get() const { return value; }
 
 private:
- AdditionalMessage& operator=(AdditionalMessage&&);
 std::string value;
 };
 
",554,79
"Googletest export

Internal Change

PiperOrigin-RevId: 212656679"," class UnitTestRecordPropertyTestEnvironment : public Environment {
 };
 
 // This will test property recording outside of any test or test case.
-static Environment* record_property_env GTEST_ATTRIBUTE_UNUSED_ =
+static Environment* record_property_env =
 AddGlobalTestEnvironment(new UnitTestRecordPropertyTestEnvironment);
 
 // This group of tests is for predicate assertions (ASSERT_PRED*, etc)
",5221,721
"Googletest export

Project import generated by Copybara.

PiperOrigin-RevId: 212678005"," class UnitTestRecordPropertyTestEnvironment : public Environment {
 };
 
 // This will test property recording outside of any test or test case.
-static Environment* record_property_env =
+static Environment* record_property_env GTEST_ATTRIBUTE_UNUSED_ =
 AddGlobalTestEnvironment(new UnitTestRecordPropertyTestEnvironment);
 
 // This group of tests is for predicate assertions (ASSERT_PRED*, etc)
",5221,721
[msys] fix unittest ColoredOutputTest.UsesColorsWhenTermSupportsColors," TEST(ColoredOutputTest, UsesColorsWhenStdoutIsTty) {
 TEST(ColoredOutputTest, UsesColorsWhenTermSupportsColors) {
 GTEST_FLAG(color) = ""auto"";
 
-#if GTEST_OS_WINDOWS
+#if GTEST_OS_WINDOWS && !GTEST_OS_WINDOWS_MINGW
 // On Windows, we ignore the TERM variable as it's usually not set.
 
 SetEnv(""TERM"", ""dumb"");
",5221,720
Removed some newlines," private:
 } \
 catch (const std::exception& e) { \
 if (!gtest_caught_expected) { \
- message.set( \
- ""it throws a different type "" \
+ message.set(""it throws a different type "" \
 ""with message: "" + std::string(e.what())); \
 goto GTEST_CONCAT_TOKEN_(gtest_label_testthrow_, __LINE__); \
 } \
 } \
 catch (...) { \
 if (!gtest_caught_expected) { \
- message.set( \
- ""it throws a different type.""); \
+ message.set(""it throws a different type.""); \
 goto GTEST_CONCAT_TOKEN_(gtest_label_testthrow_, __LINE__); \
 } \
 } \
 if (!gtest_caught_expected) { \
- message.set( \
- ""it throws nothing.""); \
+ message.set(""it throws nothing.""); \
 goto GTEST_CONCAT_TOKEN_(gtest_label_testthrow_, __LINE__); \
 } \
 } else \
",554,79
"Googletest export

support printing std::reference_wrapper<T> in gUnit

PiperOrigin-RevId: 213270392"," inline void PrintTo(absl::string_view sp, ::std::ostream* os) {
 #endif // GTEST_HAS_ABSL
 
 #if GTEST_LANG_CXX11
+
 inline void PrintTo(std::nullptr_t, ::std::ostream* os) { *os << ""(nullptr)""; }
+
+template <typename T>
+void PrintTo(std::reference_wrapper<T> ref, ::std::ostream* os) {
+ // Delegate to wrapped value.
+ PrintTo(ref.get(), os);
+}
+
 #endif // GTEST_LANG_CXX11
 
 #if GTEST_HAS_TR1_TUPLE || GTEST_HAS_STD_TUPLE_
",552,92
"Googletest export

Fixing broken OSS build, add missing include

PiperOrigin-RevId: 213812210","
 #ifndef GTEST_INCLUDE_GTEST_GTEST_PRINTERS_H_
 #define GTEST_INCLUDE_GTEST_GTEST_PRINTERS_H_
 
+#include <functional>
 #include <ostream> // NOLINT
 #include <sstream>
 #include <string>
",553,92
"Rename private member of AdditionalMessage
Shorten lines in unit tests"," class NativeArray {
 class AdditionalMessage
 {
 public:
- AdditionalMessage(const char* message) : value(message) {}
- void set(const std::string& message) { value = message; }
+ AdditionalMessage(const char* message) : msg(message) {}
+ void set(const std::string& message) { msg = message; }
 operator bool() const { return true; }
 
- const std::string& get() const { return value; }
+ const std::string& get() const { return msg; }
 
 private:
- std::string value;
+ std::string msg;
 };
 
 } // namespace internal
",554,79
Fix ColoredOutputTest.UsesColorsWhenTermSupportsColors again," TEST(ColoredOutputTest, UsesColorsWhenStdoutIsTty) {
 TEST(ColoredOutputTest, UsesColorsWhenTermSupportsColors) {
 GTEST_FLAG(color) = ""auto"";
 
-#if GTEST_OS_WINDOWS
+#if GTEST_OS_WINDOWS && !GTEST_OS_WINDOWS_MINGW
 // On Windows, we ignore the TERM variable as it's usually not set.
 
 SetEnv(""TERM"", ""dumb"");
",5248,721
"Merge 2ce0685f76a4db403b7b2650433a584c150f2108 into 75e834700d19aa373b428c7c746f951737354c28

Closes #1544
With refinements and changes

PiperOrigin-RevId: 215273083"," class NativeArray {
 #define GTEST_SUCCESS_(message) \
 GTEST_MESSAGE_(message, ::testing::TestPartResult::kSuccess)
 
-// Suppress MSVC warning 4702 (unreachable code) for the code following
+#define GTEST_SKIP_(message) \
+ return GTEST_MESSAGE_(message, ::testing::TestPartResult::kSkip)
+
+// Suppress MSVC warning 4072 (unreachable code) for the code following
 // statement if it returns or throws (or doesn't return or throw in some
 // situations).
 #define GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement) \
",544,75
"Merge 86fe8a25eb5a6e4546f9e39cf23a5c764217bf85 into 440527a61e1c91188195f7de212c63c77e8f0a45

Closes #1867

PiperOrigin-RevId: 215392714"," TEST(MockFunctionTest, AsStdFunctionReturnsReference) {
 value = 2;
 EXPECT_EQ(2, ref);
 }
+
+TEST(MockFunctionTest, AsStdFunctionWithReferenceParameter) {
+ MockFunction<int(int &)> foo;
+ auto call = [](const std::function<int(int& )> &f, int &i) {
+ return f(i);
+ };
+ int i = 42;
+ EXPECT_CALL(foo, Call(i)).WillOnce(Return(-1));
+ EXPECT_EQ(-1, call(foo.AsStdFunction(), i));
+}
+
 #endif // GTEST_HAS_STD_FUNCTION_
 
 struct MockMethodSizes0 {
",432,42
"Merge d830440d48a9502161448bc78be33a53388dd1f4 into f5260ae757a681566d8f7d0558b8dc0551036506

Closes #1830

PiperOrigin-RevId: 215563532"," class WithParamInterface {
 virtual ~WithParamInterface() {}
 
 // The current parameter value. Is also available in the test fixture's
- // constructor. This member function is non-static, even though it only
- // references static data, to reduce the opportunity for incorrect uses
- // like writing 'WithParamInterface<bool>::GetParam()' for a test that
- // uses a fixture whose parameter type is int.
- const ParamType& GetParam() const {
+ // constructor.
+ static const ParamType& GetParam() {
 GTEST_CHECK_(parameter_ != NULL)
 << ""GetParam() can only be called inside a value-parameterized test ""
 << ""-- did you intend to write TEST_P instead of TEST_F?"";
",730,113
"Remove checking for C++ 11 and a pre-C++11 test from googletest tests

PiperOrigin-RevId: 215789971"," TEST_F(CxxExceptionInConstructorTest, ThrowsExceptionInConstructor) {
 << ""called unexpectedly."";
 }
 
-// Exceptions in destructors are not supported in C++11.
-#if !GTEST_LANG_CXX11
-class CxxExceptionInDestructorTest : public Test {
- public:
- static void TearDownTestCase() {
- printf(""%s"",
- ""CxxExceptionInDestructorTest::TearDownTestCase() ""
- ""called as expected.\n"");
- }
-
- protected:
- ~CxxExceptionInDestructorTest() {
- GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(
- throw std::runtime_error(""Standard C++ exception""));
- }
-};
-
-TEST_F(CxxExceptionInDestructorTest, ThrowsExceptionInDestructor) {}
-#endif // C++11 mode
 
 class CxxExceptionInSetUpTestCaseTest : public Test {
 public:
",190,45
"Apply clang-tidy modernize-use-nullptr to googletest.

Now that googletest has moved to C++11, it should no longer
use NULL or 0 for the null pointer. This patch converts all
such usages to nullptr using clang-tidy.

This prevents LLVM from issuing -Wzero-as-null-pointer-constant
warnings.

PiperOrigin-RevId: 215814400"," TEST_F(FunctionMockerTest, MocksDecimalFunction) {
 Lt(100), 5U, NULL, ""hi""))
 .WillOnce(Return(5));
 
- EXPECT_EQ(5, foo_->Decimal(true, 'a', 0, 0, 1, 0, 0, 5, NULL, ""hi""));
+ EXPECT_EQ(5, foo_->Decimal(true, 'a', 0, 0, 1, 0, 0, 5, nullptr, ""hi""));
 }
 
 // Tests mocking a function that takes a non-const reference.
",432,42
"Make GTestColor and ColoredPrintF available as internal APIs from gtest.h. This is for use in abseil exception safety testing.

PiperOrigin-RevId: 215920581"," class GTEST_API_ AssertHelper {
 GTEST_DISALLOW_COPY_AND_ASSIGN_(AssertHelper);
 };
 
+enum GTestColor { COLOR_DEFAULT, COLOR_RED, COLOR_GREEN, COLOR_YELLOW };
+
+GTEST_API_ GTEST_ATTRIBUTE_PRINTF_(2, 3) void ColoredPrintf(GTestColor color,
+ const char* fmt,
+ ...);
+
 } // namespace internal
 
 // The pure interface class that all value-parameterized tests inherit from.
",728,113
"Remove pre-C++11 code from gtest-printers

PiperOrigin-RevId: 215941759"," void PrintTo(const T& value, ::std::ostream* os) {
 ? kPrintContainer
 : !is_pointer<T>::value
 ? kPrintOther
-#if GTEST_LANG_CXX11
 : std::is_function<typename std::remove_pointer<T>::type>::value
-#else
- : !internal::ImplicitlyConvertible<T, const void*>::value
-#endif
 ? kPrintFunctionPointer
 : kPrintPointer > (),
 value, os);
 inline void PrintTo(absl::string_view sp, ::std::ostream* os) {
 }
 #endif // GTEST_HAS_ABSL
 
-#if GTEST_LANG_CXX11
-
 inline void PrintTo(std::nullptr_t, ::std::ostream* os) { *os << ""(nullptr)""; }
 
 template <typename T>
 void PrintTo(std::reference_wrapper<T> ref, ::std::ostream* os) {
 PrintTo(ref.get(), os);
 }
 
-#endif // GTEST_LANG_CXX11
-
 #if GTEST_HAS_TR1_TUPLE || GTEST_HAS_STD_TUPLE_
 // Helper function for printing a tuple. T must be instantiated with
 // a tuple type.
",552,91
"always define define GTEST_LANG_CXX11 1

PiperOrigin-RevId: 216184859","
 GTEST_DISABLE_MSC_WARNINGS_POP_()
 #endif
 
-#ifndef GTEST_LANG_CXX11
-// gcc and clang define __GXX_EXPERIMENTAL_CXX0X__ when
-// -std={c,gnu}++{0x,11} is passed. The C++11 standard specifies a
-// value for __cplusplus, and recent versions of clang, gcc, and
-// probably other compilers set that too in C++11 mode.
-# if __GXX_EXPERIMENTAL_CXX0X__ || __cplusplus >= 201103L || _MSC_VER >= 1900
-// Compiling in at least C++11 mode.
-# define GTEST_LANG_CXX11 1
-# else
-# define GTEST_LANG_CXX11 0
-# endif
-#endif
+#define GTEST_LANG_CXX11 1
 
 // Distinct from C++11 language support, some environments don't provide
 // proper C++11 library support. Notably, it's possible to build in
",755,167
"Apply [[noreturn]] to Abort()

PiperOrigin-RevId: 216383938"," typedef struct _RTL_CRITICAL_SECTION GTEST_CRITICAL_SECTION;
 # endif // GTEST_TUPLE_NAMESPACE_
 
 # if GTEST_USE_OWN_TR1_TUPLE
-# include ""gtest/internal/gtest-tuple.h"" // IWYU pragma: export // NOLINT
+# include ""third_party/googletest/googletest/include/gtest/internal/gtest-tuple.h"" // IWYU pragma: export // NOLINT
 # elif GTEST_OS_SYMBIAN
 
 // On Symbian, BOOST_HAS_TR1_TUPLE causes Boost's TR1 tuple library to
 GTEST_DISABLE_MSC_DEPRECATED_POP_()
 // Windows CE has no C library. The abort() function is used in
 // several places in Google Test. This implementation provides a reasonable
 // imitation of standard behaviour.
-void Abort();
+[[noreturn]] void Abort();
 #else
-inline void Abort() { abort(); }
+[[noreturn]] inline void Abort() { abort(); }
 #endif // GTEST_OS_WINDOWS_MOBILE
 
 } // namespace posix
",755,167
"Unconditionally use std::tuple.
Remove all mention of TR1 tuple and our own implementation of tuple.

PiperOrigin-RevId: 216395043"," class Action {
 // template <typename Result, typename ArgumentTuple>
 // Result Perform(const ArgumentTuple& args) const {
 // // Processes the arguments and returns a result, using
-// // tr1::get<N>(args) to get the N-th (0-based) argument in the tuple.
+// // std::get<N>(args) to get the N-th (0-based) argument in the tuple.
 // }
 // ...
 // };
 class SetArgumentPointeeAction {
 template <typename Result, typename ArgumentTuple>
 void Perform(const ArgumentTuple& args) const {
 CompileAssertTypesEqual<void, Result>();
- *::testing::get<N>(args) = value_;
+ *::std::get<N>(args) = value_;
 }
 
 private:
 class SetArgumentPointeeAction<N, Proto, true> {
 template <typename Result, typename ArgumentTuple>
 void Perform(const ArgumentTuple& args) const {
 CompileAssertTypesEqual<void, Result>();
- ::testing::get<N>(args)->CopyFrom(*proto_);
+ ::std::get<N>(args)->CopyFrom(*proto_);
 }
 
 private:
",640,114
"Merge 41fc9745d4a448db7d932250d22fac1dda287443 into 658c6390a5b363f46c6ad448ad1bce9d6e97e53a

Accepts #1889

PiperOrigin-RevId: 216709878","
 # include <io.h>
 # include <sys/stat.h>
 # include <map> // Used in ThreadLocal.
+# ifdef _MSC_VER
+# include <crtdbg.h>
+# endif // _MSC_VER
 #else
 # include <unistd.h>
 #endif // GTEST_OS_WINDOWS
",828,209
"Merge c41b2bf861ef2ac1a975af05ff66d9256f280b01 into f203b2db77161fe54846ea9e839ebec81aeeccac

Closes #1899

PiperOrigin-RevId: 216719020","
 // GTEST_OS_NACL - Google Native Client (NaCl)
 // GTEST_OS_NETBSD - NetBSD
 // GTEST_OS_OPENBSD - OpenBSD
+// GTEST_OS_OS2 - OS/2
 // GTEST_OS_QNX - QNX
 // GTEST_OS_SOLARIS - Sun Solaris
 // GTEST_OS_SYMBIAN - Symbian
 typedef struct _RTL_CRITICAL_SECTION GTEST_CRITICAL_SECTION;
 
 // Determines whether the system compiler uses UTF-16 for encoding wide strings.
 #define GTEST_WIDE_STRING_USES_UTF16_ \
- (GTEST_OS_WINDOWS || GTEST_OS_CYGWIN || GTEST_OS_SYMBIAN || GTEST_OS_AIX)
+ (GTEST_OS_WINDOWS || GTEST_OS_CYGWIN || GTEST_OS_SYMBIAN || \
+ GTEST_OS_AIX || GTEST_OS_OS2)
 
 // Determines whether test results can be streamed to a socket.
 #if GTEST_OS_LINUX
",749,167
Change types to remove cast warnings.," class TypedExpectation : public ExpectationBase {
 }
 
 return count <= action_count ?
- *static_cast<const Action<F>*>(untyped_actions_[count - 1]) :
+ *static_cast<const Action<F>*>(untyped_actions_[static_cast<size_t>(count - 1)]) :
 repeated_action();
 }
 
 class FunctionMockerBase : public UntypedFunctionMockerBase {
 ::std::ostream* why) const
 GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {
 g_gmock_mutex.AssertHeld();
- const int count = static_cast<int>(untyped_expectations_.size());
+ const size_t count = untyped_expectations_.size();
 *why << ""Google Mock tried the following "" << count << "" ""
 << (count == 1 ? ""expectation, but it didn't match"" :
 ""expectations, but none matched"")
 << "":\n"";
- for (int i = 0; i < count; i++) {
+ for (size_t i = 0; i < count; i++) {
 TypedExpectation<F>* const expectation =
 static_cast<TypedExpectation<F>*>(untyped_expectations_[i].get());
 *why << ""\n"";
",960,150
"Added Mock::IsNaggy, IsNice, and IsStrict"," class GTEST_API_ Mock {
 static bool VerifyAndClear(void* mock_obj)
 GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex);
 
+ // Returns wether the mock was created as a naggy mock (default)
+ static bool IsNaggy(void* mock_obj)
+ GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex);
+ // Returns wether the mock was created as a nice mock
+ static bool IsNice(void* mock_obj)
+ GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex);
+ // Returns wether the mock was created as a strict mock
+ static bool IsStrict(void* mock_obj)
+ GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex);
+
 private:
 friend class internal::UntypedFunctionMockerBase;
 
",959,151
Don't fully qualify enum member," TEST(RawMockTest, InfoForUninterestingCall) {
 }
 
 TEST(RawMockTest, IsNaggy_IsNice_IsStrict) {
- using internal::CallReaction;
 MockFoo raw_foo;
- ASSERT_EQ(CallReaction::kDefault, CallReaction::kWarn) << ""precondition"";
+ ASSERT_EQ(internal::kDefault, internal::kWarn) << ""precondition"";
 EXPECT_TRUE (Mock::IsNaggy(&raw_foo));
 EXPECT_FALSE(Mock::IsNice(&raw_foo));
 EXPECT_FALSE(Mock::IsStrict(&raw_foo));
",259,39
Removed last reference to internal::kDefault," TEST(RawMockTest, InfoForUninterestingCall) {
 
 TEST(RawMockTest, IsNaggy_IsNice_IsStrict) {
 MockFoo raw_foo;
- ASSERT_EQ(internal::kDefault, internal::kWarn) << ""precondition"";
 EXPECT_TRUE (Mock::IsNaggy(&raw_foo));
 EXPECT_FALSE(Mock::IsNice(&raw_foo));
 EXPECT_FALSE(Mock::IsStrict(&raw_foo));
",311,50
Fix incorrect XML file name in help message," static const char kColorEncodedHelpMessage[] =
 "" @G--"" GTEST_FLAG_PREFIX_ ""output=@Y(@Gjson@Y|@Gxml@Y)[@G:@YDIRECTORY_PATH@G""
 GTEST_PATH_SEP_ ""@Y|@G:@YFILE_PATH]@D\n""
 "" Generate a JSON or XML report in the given directory or with the given\n""
-"" file name. @YFILE_PATH@D defaults to @Gtest_details.xml@D.\n""
+"" file name. @YFILE_PATH@D defaults to @Gtest_detail.xml@D.\n""
 # if GTEST_CAN_STREAM_RESULTS_
 "" @G--"" GTEST_FLAG_PREFIX_ ""stream_result_to=@YHOST@G:@YPORT@D\n""
 "" Stream test results to the given server.\n""
",3777,913
"Googletest export

New variadic implementation for gtest-param-test
Removed non-variadic implementation and added variadic for ValueArray and Values

PiperOrigin-RevId: 217703627"," TEST_F(ParameterizedDeathTest, GetParamDiesFromTestF) {
 
 INSTANTIATE_TEST_CASE_P(RangeZeroToFive, ParameterizedDerivedTest, Range(0, 5));
 
+// Tests param generator working with Enums
+enum MyEnums {
+ ENUM1 = 1,
+ ENUM2 = 3,
+ ENUM3 = 8,
+};
+
+class MyEnumTest : public testing::TestWithParam<MyEnums> {};
+
+TEST_P(MyEnumTest, ChecksParamMoreThanZero) { EXPECT_GE(10, GetParam()); }
+INSTANTIATE_TEST_CASE_P(MyEnumTests, MyEnumTest,
+ ::testing::Values(ENUM1, ENUM2, 0));
 
 int main(int argc, char **argv) {
 // Used in TestGenerationTest test case.
",700,105
"Googletest export

Honor GTEST_SKIP() in SetUp().

PiperOrigin-RevId: 218387359","
 
 #include ""gtest/gtest.h""
 
+using ::testing::Test;
+
 TEST(SkipTest, DoesSkip) {
 GTEST_SKIP();
 EXPECT_EQ(0, 1);
 }
+
+class Fixture : public Test {
+ protected:
+ void SetUp() override {
+ GTEST_SKIP() << ""skipping all tests for this fixture"";
+ }
+};
+
+TEST_F(Fixture, SkipsOneTest) {
+ EXPECT_EQ(5, 7);
+}
+
+TEST_F(Fixture, SkipsAnotherTest) {
+ EXPECT_EQ(99, 100);
+}
",18,4
"Googletest export

Remove linked_ptr and use std::shared_ptr instead

PiperOrigin-RevId: 218571466","
 #ifndef GMOCK_INCLUDE_GMOCK_GMOCK_GENERATED_ACTIONS_H_
 #define GMOCK_INCLUDE_GMOCK_GMOCK_GENERATED_ACTIONS_H_
 
+#include <memory>
 #include <utility>
 
 #include ""gmock/gmock-actions.h""
 class InvokeCallbackAction {
 callback_.get(), args);
 }
 private:
- const linked_ptr<CallbackType> callback_;
+ const std::shared_ptr<CallbackType> callback_;
 };
 
 // An INTERNAL macro for extracting the type of a tuple field. It's
",881,108
"Googletest export

Remove linked_ptr and use std::shared_ptr instead

PiperOrigin-RevId: 218618184","
 #ifndef GMOCK_INCLUDE_GMOCK_GMOCK_GENERATED_ACTIONS_H_
 #define GMOCK_INCLUDE_GMOCK_GMOCK_GENERATED_ACTIONS_H_
 
-#include <memory>
 #include <utility>
 
 #include ""gmock/gmock-actions.h""
 class InvokeCallbackAction {
 callback_.get(), args);
 }
 private:
- const std::shared_ptr<CallbackType> callback_;
+ const linked_ptr<CallbackType> callback_;
 };
 
 // An INTERNAL macro for extracting the type of a tuple field. It's
",880,108
Replaced all NULLs with nullptr in googletest," class GTEST_API_ Message {
 // tr1::type_traits-like is_pointer works, and we can overload on that.
 template <typename T>
 inline void StreamHelper(internal::true_type /*is_pointer*/, T* pointer) {
- if (pointer == NULL) {
+ if (pointer == nullptr) {
 *ss_ << ""(null)"";
 } else {
 *ss_ << pointer;
",78,14
Replaced all NULLs with nullptr in googlemock," GTEST_DISABLE_MSC_WARNINGS_POP_() // 4251
 // failure to disambiguate two overloads of this method in the ON_CALL statement
 // is how we block callers from setting expectations on overloaded methods.
 #define GMOCK_ON_CALL_IMPL_(mock_expr, Setter, call) \
- ((mock_expr).gmock_##call)(::testing::internal::GetWithoutMatchers(), NULL) \
+ ((mock_expr).gmock_##call)(::testing::internal::GetWithoutMatchers(), nullptr) \
 .Setter(__FILE__, __LINE__, #mock_expr, #call)
 
 #define ON_CALL(obj, call) \
",964,150
"Googletest export

Remove linked_ptr and use std::shared_ptr instead

PiperOrigin-RevId: 219129336","
 #ifndef GMOCK_INCLUDE_GMOCK_GMOCK_GENERATED_ACTIONS_H_
 #define GMOCK_INCLUDE_GMOCK_GMOCK_GENERATED_ACTIONS_H_
 
+#include <memory>
 #include <utility>
 
 #include ""gmock/gmock-actions.h""
 class InvokeCallbackAction {
 callback_.get(), args);
 }
 private:
- const linked_ptr<CallbackType> callback_;
+ const std::shared_ptr<CallbackType> callback_;
 };
 
 // An INTERNAL macro for extracting the type of a tuple field. It's
",881,108
"Googletest export

Fix broken Fuchsia cc_test.

PiperOrigin-RevId: 219170936"," class FuchsiaDeathTest : public DeathTestImpl {
 : DeathTestImpl(a_statement, a_regex), file_(file), line_(line) {}
 
 // All of these virtual functions are inherited from DeathTest.
- virtual int Wait();
- virtual TestRole AssumeRole();
+ int Wait() override;
+ TestRole AssumeRole() override;
+ std::string GetErrorLogs() override;
 
 private:
 // The name of the file in which the death test is located.
",953,176
"Googletest export

Remove scoped_ptr replace with std::unique_ptr

PiperOrigin-RevId: 219291284"," class FunctionMockerBase : public UntypedFunctionMockerBase {
 // const_cast is required since in C++98 we still pass ArgumentTuple around
 // by const& instead of rvalue reference.
 void* untyped_args = const_cast<void*>(static_cast<const void*>(&args));
- scoped_ptr<ResultHolder> holder(
+ std::unique_ptr<ResultHolder> holder(
 DownCast_<ResultHolder*>(this->UntypedInvokeWith(untyped_args)));
 return holder->Unwrap();
 }
",963,150
"Googletest export

Adding GTEST_INTERNAL_DEPRECATED ability to mark deprecated

PiperOrigin-RevId: 219515184"," class FlatTuple
 test_case_name, test_name)>); \
 void GTEST_TEST_CLASS_NAME_(test_case_name, test_name)::TestBody()
 
+// Internal Macro to mark an API deprecated, for googletest usage only
+// Usage: class GTEST_INTERNAL_DEPRECATED(message) MyClass or
+// GTEST_INTERNAL_DEPRECATED(message) <return_type> myFunction(); Every usage of
+// a deprecated entity will trigger a warning when compiled with
+// `-Wdeprecated-declarations` option (clang, gcc, any __GNUC__ compiler).
+// For msvc /W3 option will need to be used
+// Note that for 'other' compilers this macro evaluates to nothing to prevent
+// compilations errors.
+#if defined(_MSC_VER)
+#define GTEST_INTERNAL_DEPRECATED(message) __declspec(deprecated(message))
+#elif defined(__GNUC__)
+#define GTEST_INTERNAL_DEPRECATED(message) __attribute__((deprecated(message)))
+#else
+#define GTEST_INTERNAL_DEPRECATED(message)
+#endif
 #endif // GTEST_INCLUDE_GTEST_INTERNAL_GTEST_INTERNAL_H_
",608,75
Remove workarounds for unsupported MSVC versions," class PropertyMatcher {
 *listener << whose_property_ << ""is "";
 // Cannot pass the return value (for example, int) to MatchPrintAndExplain,
 // which takes a non-const reference as argument.
-#if defined(_PREFAST_ ) && _MSC_VER == 1800
- // Workaround bug in VC++ 2013's /analyze parser.
- // https://connect.microsoft.com/VisualStudio/feedback/details/1106363/internal-compiler-error-with-analyze-due-to-failure-to-infer-move
- posix::Abort(); // To make sure it is never run.
- return false;
-#else
 RefToConstProperty result = (obj.*property_)();
 return MatchPrintAndExplain(result, matcher_, listener);
-#endif
 }
 
 bool MatchAndExplainImpl(true_type /* is_pointer */, const Class* p,
",3211,645
Remove GTEST_HAS_HASH_SET/MAP check," typedef struct _RTL_CRITICAL_SECTION GTEST_CRITICAL_SECTION;
 # include <time.h> // NOLINT
 #endif
 
-// Determines if hash_map/hash_set are available.
-// Only used for testing against those containers.
-#if !defined(GTEST_HAS_HASH_MAP_)
-# if defined(_MSC_VER) && (_MSC_VER < 1900)
-# define GTEST_HAS_HASH_MAP_ 1 // Indicates that hash_map is available.
-# define GTEST_HAS_HASH_SET_ 1 // Indicates that hash_set is available.
-# endif // _MSC_VER
-#endif // !defined(GTEST_HAS_HASH_MAP_)
-
 // Determines whether clone(2) is supported.
 // Usually it will only be available on Linux, excluding
 // Linux on the Itanium architecture.
",704,155
Define GTEST_DISABLE_MSC_WARNINGS_PUSH/POP for all compilers,"
 __pragma(warning(disable: warnings))
 # define GTEST_DISABLE_MSC_WARNINGS_POP_() \
 __pragma(warning(pop))
+#else
+// Not all compilers are MSVC
+# define GTEST_DISABLE_MSC_WARNINGS_PUSH_(warnings)
+# define GTEST_DISABLE_MSC_WARNINGS_POP_()
 #endif
 
 // Clang on Windows does not understand MSVC's pragma warning.
",704,155
"Googletest export

Include type_traits header

ElementsAre, UnorderedElementsAre, AllOf, and AnyOf are all defined in terms of std::decay, which is in the type_traits header.

PiperOrigin-RevId: 220818637","
 #include <ostream> // NOLINT
 #include <sstream>
 #include <string>
+#include <type_traits>
 #include <utility>
 #include <vector>
 #include ""gmock/internal/gmock-internal-utils.h""
",3214,646
"Googletest export

Move the Matcher<T> interface to googletest so I can use it to extend death test regex matching in a subsequent change.

PiperOrigin-RevId: 221675910","
 #include ""gtest/internal/gtest-internal.h""
 #include ""gtest/internal/gtest-string.h""
 #include ""gtest/gtest-death-test.h""
+#include ""gtest/gtest-matchers.h""
 #include ""gtest/gtest-message.h""
 #include ""gtest/gtest-param-test.h""
 #include ""gtest/gtest-printers.h""
",733,115
"Googletest export

Point IWYU at an existent path.

PiperOrigin-RevId: 221797154","
 // This file implements just enough of the matcher interface to allow
 // EXPECT_DEATH and friends to accept a matcher argument.
 
-// IWYU pragma: private, include ""testing/base/public/gtest.h""
+// IWYU pragma: private, include ""testing/base/public/gunit.h""
 // IWYU pragma: friend third_party/googletest/googlemock/.*
 // IWYU pragma: friend third_party/googletest/googletest/.*
 
",346,83
"Googletest export

Internal Change

PiperOrigin-RevId: 222123106"," DoAll(Action1 a1, Action2 a2, Action3 a3, Action4 a4, Action5 a5, Action6 a6,
 // MORE INFORMATION:
 //
 // To learn more about using these macros, please search for 'ACTION' on
-// https://github.com/google/googletest/blob/master/googlemock/docs/CookBook.md
+// https://github.com/abseil/googletest/blob/master/googlemock/docs/CookBook.md
 
 // An internal macro needed for implementing ACTION*().
 #define GMOCK_ACTION_ARG_TYPES_AND_NAMES_UNUSED_\
",639,83
"Googletest export

Silence C4100 msvc warning

PiperOrigin-RevId: 222242329","
 #include <type_traits>
 #endif // GTEST_LANG_CXX11
 
+#ifdef _MSC_VER
+# pragma warning(push)
+# pragma warning(disable:4100)
+#endif
+
 namespace testing {
 
 // To implement an action Foo, define:
 inline internal::ReferenceWrapper<T> ByRef(T& l_value) { // NOLINT
 
 } // namespace testing
 
+#ifdef _MSC_VER
+# pragma warning(pop)
+#endif
+
+
 #endif // GMOCK_INCLUDE_GMOCK_GMOCK_ACTIONS_H_
",670,117
"Googletest export

Remove redundant Base/Derived types.

PiperOrigin-RevId: 222243634"," TEST(WithArgsTest, ReturnReference) {
 }
 
 TEST(WithArgsTest, InnerActionWithConversion) {
- struct Base {};
- struct Derived : Base {};
 Action<Derived*()> inner = [] { return nullptr; };
 Action<Base*(double)> a = testing::WithoutArgs(inner);
 EXPECT_EQ(nullptr, a.Perform(std::make_tuple(1.1)));
",969,153
"Googletest export

Remove unintended dependency.

PiperOrigin-RevId: 222243874","
 // This file tests the internal preprocessor macro library.
 #include ""gmock/internal/gmock-pp.h""
 
-#include ""absl/strings/str_join.h""
-#include ""absl/strings/str_split.h""
+#include <string>
+
 #include ""gmock/gmock.h""
 
 namespace testing {
 namespace {
 
 // Matcher to verify that to strings are identical up to whitespace
 // Not 100% correct, because it treats ""AB"" as equal to ""A B"".
-::testing::Matcher<string> SameExceptSpaces(absl::string_view s) {
- auto remove_spaces = [](const absl::string_view& to_split) {
- return absl::StrJoin(absl::StrSplit(to_split, ' '), """");
+::testing::Matcher<const std::string&> SameExceptSpaces(const std::string& s) {
+ auto remove_spaces = [](std::string to_split) {
+ to_split.erase(std::remove(to_split.begin(), to_split.end(), ' '),
+ to_split.end());
+ return to_split;
 };
 return ::testing::ResultOf(remove_spaces, remove_spaces(s));
 }
",142,11
"Googletest export

Fix broken OSS build

PiperOrigin-RevId: 222244158"," TEST(WithArgsTest, VoidAction) {
 }
 
 TEST(WithArgsTest, ReturnReference) {
- Action<int&(int&, void*)> a = WithArgs<0>([](int& a) -> int& { return a; });
+ Action<int&(int&, void*)> aa = WithArgs<0>([](int& a) -> int& { return a; });
 int i = 0;
- const int& res = a.Perform(std::forward_as_tuple(i, nullptr));
+ const int& res = aa.Perform(std::forward_as_tuple(i, nullptr));
 EXPECT_EQ(&i, &res);
 }
 
",969,153
"Googletest export

Applied fixes for ClangTidy modernize-use-override and modernize-use-using.

PiperOrigin-RevId: 223800219"," class NiceMock : public MockClass {
 
 #endif // GTEST_LANG_CXX11
 
- ~NiceMock() {
+ ~NiceMock() { // NOLINT
 ::testing::Mock::UnregisterCallReaction(
 internal::ImplicitCast_<MockClass*>(this));
 }
 class NaggyMock : public MockClass {
 
 #endif // GTEST_LANG_CXX11
 
- ~NaggyMock() {
+ ~NaggyMock() { // NOLINT
 ::testing::Mock::UnregisterCallReaction(
 internal::ImplicitCast_<MockClass*>(this));
 }
 class StrictMock : public MockClass {
 
 #endif // GTEST_LANG_CXX11
 
- ~StrictMock() {
+ ~StrictMock() { // NOLINT
 ::testing::Mock::UnregisterCallReaction(
 internal::ImplicitCast_<MockClass*>(this));
 }
",298,42
Do not define GTEST_IS_THREADSAFE within GTEST_HAS_SEH," typedef struct _RTL_CRITICAL_SECTION GTEST_CRITICAL_SECTION;
 # define GTEST_HAS_SEH 0
 # endif
 
-#define GTEST_IS_THREADSAFE \
- (GTEST_HAS_MUTEX_AND_THREAD_LOCAL_ \
- || (GTEST_OS_WINDOWS && !GTEST_OS_WINDOWS_PHONE && !GTEST_OS_WINDOWS_RT) \
- || GTEST_HAS_PTHREAD)
-
 #endif // GTEST_HAS_SEH
 
+#ifndef GTEST_IS_THREADSAFE
+
+# define GTEST_IS_THREADSAFE \
+ ( GTEST_HAS_MUTEX_AND_THREAD_LOCAL_ \
+ || (GTEST_OS_WINDOWS && !GTEST_OS_WINDOWS_PHONE && !GTEST_OS_WINDOWS_RT) \
+ || GTEST_HAS_PTHREAD)
+
+#endif // GTEST_IS_THREADSAFE
+
 // GTEST_API_ qualifies all symbols that must be exported. The definitions below
 // are guarded by #ifndef to give embedders a chance to define GTEST_API_ in
 // gtest/internal/custom/gtest-port.h
",704,155
"Googletest export

Deduce SizeType for SizeIs() from the return value of the size() member function

PiperOrigin-RevId: 223835674"," class SizeIsMatcher {
 template <typename Container>
 class Impl : public MatcherInterface<Container> {
 public:
- typedef internal::StlContainerView<
- GTEST_REMOVE_REFERENCE_AND_CONST_(Container)> ContainerView;
- typedef typename ContainerView::type::size_type SizeType;
+ using SizeType = decltype(std::declval<Container>().size());
 explicit Impl(const SizeMatcher& size_matcher)
 : size_matcher_(MatcherCast<SizeType>(size_matcher)) {}
 
",2853,548
feat: Add initial support for PlatformIO and Arduino,"
 #include ""gmock/gmock.h""
 #include ""gtest/gtest.h""
 
+#ifdef ARDUINO
+void setup() {
+ int argc = 0;
+ char** argv = nullptr;
+ // Since Google Mock depends on Google Test, InitGoogleMock() is
+ // also responsible for initializing Google Test. Therefore there's
+ // no need for calling testing::InitGoogleTest() separately.
+ testing::InitGoogleMock(&argc, argv);
+}
+void loop() {
+ RUN_ALL_TESTS();
+}
+#else
+
 // MS C++ compiler/linker has a bug on Windows (not on Windows CE), which
 // causes a link error when _tmain is defined in a static library and UNICODE
 // is enabled. For this reason instead of _tmain, main function is used on
 GTEST_API_ int main(int argc, char** argv) {
 testing::InitGoogleMock(&argc, argv);
 return RUN_ALL_TESTS();
 }
+#endif
+ 
",18,2
"Googletest export

The gmock matchers have a concept of MatchAndExpain; where the details of the
matching are written to a ""result listener"". A matcher can avoid creating
expensive debug info by checking result_listener->IsInterested(); but,
unfortunately, the default matcher code (called from EXPECT_THAT) is always
""interested"".

This change implements EXPECT_THAT matching to first run the matcher in a ""not
interested"" mode; and then run it a second time (""interested"") only if the
match fails.

PiperOrigin-RevId: 224929783"," class PredicateFormatterFromMatcher {
 // We don't write MatcherCast<const T&> either, as that allows
 // potentially unsafe downcasting of the matcher argument.
 const Matcher<const T&> matcher = SafeMatcherCast<const T&>(matcher_);
- StringMatchResultListener listener;
- if (MatchPrintAndExplain(x, matcher, &listener))
+
+ // The expected path here is that the matcher should match (i.e. that most
+ // tests pass) so optimize for this case.
+ if (matcher.Matches(x)) {
 return AssertionSuccess();
+ }
 
 ::std::stringstream ss;
 ss << ""Value of: "" << value_text << ""\n""
 << ""Expected: "";
 matcher.DescribeTo(&ss);
+
+ // Rerun the matcher to ""PrintAndExain"" the failure.
+ StringMatchResultListener listener;
+ if (MatchPrintAndExplain(x, matcher, &listener)) {
+ ss << ""\n The matcher failed on the initial attempt; but passed when ""
+ ""rerun to generate the explanation."";
+ }
 ss << ""\n Actual: "" << listener.str();
 return AssertionFailure() << ss.str();
 }
",2858,549
"Googletest export

rollback of 224929783

PiperOrigin-RevId: 225008559"," class PredicateFormatterFromMatcher {
 // We don't write MatcherCast<const T&> either, as that allows
 // potentially unsafe downcasting of the matcher argument.
 const Matcher<const T&> matcher = SafeMatcherCast<const T&>(matcher_);
-
- // The expected path here is that the matcher should match (i.e. that most
- // tests pass) so optimize for this case.
- if (matcher.Matches(x)) {
+ StringMatchResultListener listener;
+ if (MatchPrintAndExplain(x, matcher, &listener))
 return AssertionSuccess();
- }
 
 ::std::stringstream ss;
 ss << ""Value of: "" << value_text << ""\n""
 << ""Expected: "";
 matcher.DescribeTo(&ss);
-
- // Rerun the matcher to ""PrintAndExain"" the failure.
- StringMatchResultListener listener;
- if (MatchPrintAndExplain(x, matcher, &listener)) {
- ss << ""\n The matcher failed on the initial attempt; but passed when ""
- ""rerun to generate the explanation."";
- }
 ss << ""\n Actual: "" << listener.str();
 return AssertionFailure() << ss.str();
 }
",2853,548
"Googletest export

The gmock matchers have a concept of MatchAndExpain; where the details of the
matching are written to a ""result listener"". A matcher can avoid creating
expensive debug info by checking result_listener->IsInterested(); but,
unfortunately, the default matcher code (called from EXPECT_THAT) is always
""interested"".

This change implements EXPECT_THAT matching to first run the matcher in a ""not
interested"" mode; and then run it a second time (""interested"") only if the
match fails.

PiperOrigin-RevId: 225036073"," class PredicateFormatterFromMatcher {
 // We don't write MatcherCast<const T&> either, as that allows
 // potentially unsafe downcasting of the matcher argument.
 const Matcher<const T&> matcher = SafeMatcherCast<const T&>(matcher_);
- StringMatchResultListener listener;
- if (MatchPrintAndExplain(x, matcher, &listener))
+
+ // The expected path here is that the matcher should match (i.e. that most
+ // tests pass) so optimize for this case.
+ if (matcher.Matches(x)) {
 return AssertionSuccess();
+ }
 
 ::std::stringstream ss;
 ss << ""Value of: "" << value_text << ""\n""
 << ""Expected: "";
 matcher.DescribeTo(&ss);
+
+ // Rerun the matcher to ""PrintAndExain"" the failure.
+ StringMatchResultListener listener;
+ if (MatchPrintAndExplain(x, matcher, &listener)) {
+ ss << ""\n The matcher failed on the initial attempt; but passed when ""
+ ""rerun to generate the explanation."";
+ }
 ss << ""\n Actual: "" << listener.str();
 return AssertionFailure() << ss.str();
 }
",2858,549
"Googletest export

Internal Change

PiperOrigin-RevId: 225231727"," DoAll(Action1 a1, Action2 a2, Action3 a3, Action4 a4, Action5 a5, Action6 a6,
 // MORE INFORMATION:
 //
 // To learn more about using these macros, please search for 'ACTION' on
-// https://github.com/abseil/googletest/blob/master/googlemock/docs/CookBook.md
+// https://github.com/google/googletest/blob/master/googlemock/docs/CookBook.md
 
 // An internal macro needed for implementing ACTION*().
 #define GMOCK_ACTION_ARG_TYPES_AND_NAMES_UNUSED_\
",639,83
"Googletest export

Support skipped in XML and JSON output

PiperOrigin-RevId: 225386540"," void XmlUnitTestResultPrinter::OutputXmlTestInfo(::std::ostream* stream,
 }
 
 OutputXmlAttribute(stream, kTestcase, ""status"",
- test_info.should_run() ? ""run"" : ""notrun"");
+ result.Skipped() ? ""skipped"" :
+ test_info.should_run() ? ""run"" : ""notrun"");
 OutputXmlAttribute(stream, kTestcase, ""time"",
 FormatTimeInMillisAsSeconds(result.elapsed_time()));
 OutputXmlAttribute(stream, kTestcase, ""classname"", test_case_name);
 void JsonUnitTestResultPrinter::OutputJsonTestInfo(::std::ostream* stream,
 }
 
 OutputJsonKey(stream, kTestcase, ""status"",
+ result.Skipped() ? ""SKIPPED"" :
 test_info.should_run() ? ""RUN"" : ""NOTRUN"", kIndent);
 OutputJsonKey(stream, kTestcase, ""time"",
 FormatTimeInMillisAsDuration(result.elapsed_time()), kIndent);
",3775,917
"Googletest export

Suppress C4503 for MCVS

PiperOrigin-RevId: 225871050"," TEST(DoAllTest, TenActions) {
 // the macro definition, as the warnings are generated when the macro
 // is expanded and macro expansion cannot contain #pragma. Therefore
 // we suppress them here.
+// Also suppress C4503 decorated name length exceeded, name was truncated
 #ifdef _MSC_VER
 # pragma warning(push)
 # pragma warning(disable:4100)
+# pragma warning(disable:4503)
 #endif
 
 // Tests the ACTION*() macro family.
",765,137
"Googletest export

Suppress C4503 for MCVS , again

PiperOrigin-RevId: 225895719"," TEST(DoAllTest, TenActions) {
 # pragma warning(disable:4100)
 # pragma warning(disable:4503)
 #endif
-
 // Tests the ACTION*() macro family.
 
 // Tests that ACTION() can define an action that doesn't reference the
 TEST(ActionTemplateTest, CanBeOverloadedOnNumberOfValueParameters) {
 EXPECT_EQ(12345, a4.Perform(std::make_tuple()));
 }
 
-#ifdef _MSC_VER
-# pragma warning(pop)
-#endif
 
 } // namespace gmock_generated_actions_test
 } // namespace testing
",765,137
"Googletest export

Unifdef c++11-related macros from googletest now that it requires C++11.

PiperOrigin-RevId: 225905601","
 #ifndef GMOCK_INCLUDE_GMOCK_GMOCK_GENERATED_FUNCTION_MOCKERS_H_
 #define GMOCK_INCLUDE_GMOCK_GMOCK_GENERATED_FUNCTION_MOCKERS_H_
 
+#include <functional>
 #include <utility>
 
 #include ""gmock/gmock-spec-builders.h""
 #include ""gmock/internal/gmock-internal-utils.h""
 
-#if GTEST_HAS_STD_FUNCTION_
-# include <functional>
-#endif
-
 namespace testing {
 namespace internal {
 // Removes the given pointer; this is a helper for the expectation setter method
",17,2
"Googletest export

Get rid of code generation for NiceMock / StrictMock.
They got small enough that it doesn't make sense to generate them.

PiperOrigin-RevId: 226455689","
-// This file was GENERATED by command:
-// pump.py gmock-generated-nice-strict.h.pump
-// DO NOT EDIT BY HAND!!!
-
 // Copyright 2008, Google Inc.
 // All rights reserved.
 //

 
 // GOOGLETEST_CM0002 DO NOT DELETE
 
-#ifndef GMOCK_INCLUDE_GMOCK_GMOCK_GENERATED_NICE_STRICT_H_
-#define GMOCK_INCLUDE_GMOCK_GMOCK_GENERATED_NICE_STRICT_H_
+#ifndef GMOCK_INCLUDE_GMOCK_GMOCK_NICE_STRICT_H_
+#define GMOCK_INCLUDE_GMOCK_GMOCK_NICE_STRICT_H_
 
 #include ""gmock/gmock-spec-builders.h""
 #include ""gmock/internal/gmock-port.h""
 class StrictMock<StrictMock<MockClass> >;
 
 } // namespace testing
 
-#endif // GMOCK_INCLUDE_GMOCK_GMOCK_GENERATED_NICE_STRICT_H_
+#endif // GMOCK_INCLUDE_GMOCK_GMOCK_NICE_STRICT_H_
",100,12
"Merge #2002

PiperOrigin-RevId: 227030722"," class PathLike {
 public:
 struct iterator {
 typedef PathLike value_type;
+
+ iterator& operator++();
+ PathLike& operator*();
 };
 
+ using value_type = char;
+ using const_iterator = iterator;
+
 PathLike() {}
 
 iterator begin() const { return iterator(); }
",1074,176
"Googletest export

Remove the #ifs for old, unsupported and buggy compilers:
* old versions of GCC & MSVC
* Symbian

PiperOrigin-RevId: 227116941"," SetArgPointee(const T& x) {
 N, T, internal::IsAProtocolMessage<T>::value>(x));
 }
 
-#if !((GTEST_GCC_VER_ && GTEST_GCC_VER_ < 40000) || GTEST_OS_SYMBIAN)
-// This overload allows SetArgPointee() to accept a string literal.
-// GCC prior to the version 4.0 and Symbian C++ compiler cannot distinguish
-// this overload from the templated version and emit a compile error.
 template <size_t N>
 PolymorphicAction<
 internal::SetArgumentPointeeAction<N, const char*, false> >
 SetArgPointee(const wchar_t* p) {
 return MakePolymorphicAction(internal::SetArgumentPointeeAction<
 N, const wchar_t*, false>(p));
 }
-#endif
 
 // The following version is DEPRECATED.
 template <size_t N, typename T>
",635,109
"Googletest export

Internal Change

PiperOrigin-RevId: 227575279"," class TuplePrefix {
 const Value& value = std::get<N - 1>(values);
 StringMatchResultListener listener;
 if (!matcher.MatchAndExplain(value, &listener)) {
- // FIXME: include in the message the name of the parameter
- // as used in MOCK_METHOD*() when possible.
 *os << "" Expected arg #"" << N - 1 << "": "";
 std::get<N - 1>(matchers).DescribeTo(os);
 *os << ""\n Actual: "";
 class WhenDynamicCastToMatcher : public WhenDynamicCastToMatcherBase<To> {
 
 template <typename From>
 bool MatchAndExplain(From from, MatchResultListener* listener) const {
- // FIXME: Add more detail on failures. ie did the dyn_cast fail?
 To to = dynamic_cast<To>(from);
 return MatchPrintAndExplain(to, this->matcher_, listener);
 }
",2834,540
"fix: Remove Arduino entry points

Improved flexibility by removing the Arduino entry points in favor of manual calls to setup/loop that the user can call from their entry point. This is the more common use case for Arudino.

Also added the gtest/gmock_main files to the PlatformIO ignore list since we are not supporting that feature."," GTEST_API_ void InitGoogleMock(int* argc, char** argv);
 // UNICODE mode.
 GTEST_API_ void InitGoogleMock(int* argc, wchar_t** argv);
 
+#ifdef ARDUINO
+inline void gmock_setup() {
+ // Since Arduino doesn't have a command line, fake out the argc/argv arguments
+ int argc = 1;
+ const auto arg0 = ""PlatformIO"";
+ char* argv0 = const_cast<char*>(arg0);
+ char** argv = &argv0;
+
+ // Since Google Mock depends on Google Test, InitGoogleMock() is
+ // also responsible for initializing Google Test. Therefore there's
+ // no need for calling testing::InitGoogleTest() separately.
+ testing::InitGoogleMock(&argc, argv);
+}
+inline void gmock_loop() { RUN_ALL_TESTS(); }
+#endif
+
 } // namespace testing
 
 #endif // GMOCK_INCLUDE_GMOCK_GMOCK_H_
",26,2
"Googletest export

TestCase->TestSuite refactoring

PiperOrigin-RevId: 227702164","
 #include <stdlib.h>
 #include <string.h>
 #include <memory>
+#include <type_traits>
 
 #ifndef _WIN32_WCE
 # include <sys/types.h>
",698,155
"Googletest export

Fixes #1261

PiperOrigin-RevId: 227740670","
 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
-// This file is AUTOMATICALLY GENERATED on 01/02/2018 by command
+// This file is AUTOMATICALLY GENERATED on 01/02/2019 by command
 // 'gen_gtest_pred_impl.py 5'. DO NOT EDIT BY HAND!
 
 // Regression test for gtest_pred_impl.h
",1743,231
misc: Reapply Arduino functions," inline int RUN_ALL_TESTS() {
 return ::testing::UnitTest::GetInstance()->Run();
 }
 
+#ifdef ARDUINO
+inline void gtest_setup() {
+ // Since Arduino doesn't have a command line, fake out the argc/argv arguments
+ int argc = 1;
+ const auto arg0 = ""PlatformIO"";
+ char* argv0 = const_cast<char*>(arg0);
+ char** argv = &argv0;
+
+ testing::InitGoogleTest(&argc, argv);
+}
+
+inline void gtest_loop() { RUN_ALL_TESTS(); }
+#endif
+
 GTEST_DISABLE_MSC_WARNINGS_POP_() // 4251
 
 #endif // GTEST_INCLUDE_GTEST_GTEST_H_
",774,129
clang-tidy: modernize-deprecated-headers,"
 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
-#include <stdio.h>
+#include <cstdio>
 #include ""gtest/gtest.h""
 
 #ifdef ARDUINO
",15,3
"fix: Add Arduino setup()/loop() functions back

Added setup()/loop() functions back to *_main.cc files to support compiling in CI. Future features could enable this for the end user.","
 #include ""gmock/gmock.h""
 #include ""gtest/gtest.h""
 
+#ifdef ARDUINO
+void setup() {
+ int argc = 0;
+ char** argv = nullptr;
+ // Since Google Mock depends on Google Test, InitGoogleMock() is
+ // also responsible for initializing Google Test. Therefore there's
+ // no need for calling testing::InitGoogleTest() separately.
+ testing::InitGoogleMock(&argc, argv);
+}
+void loop() { RUN_ALL_TESTS(); }
+#else
+
 // MS C++ compiler/linker has a bug on Windows (not on Windows CE), which
 // causes a link error when _tmain is defined in a static library and UNICODE
 // is enabled. For this reason instead of _tmain, main function is used on
 GTEST_API_ int main(int argc, char** argv) {
 testing::InitGoogleMock(&argc, argv);
 return RUN_ALL_TESTS();
 }
+
+#endif
",16,2
"Googletest export

Replace testing::internal::ImplicitlyConvertible with std::is_convertible
Fixes #2054

PiperOrigin-RevId: 228334305"," class MatcherCastImpl {
 return CastImpl(
 polymorphic_matcher_or_value,
 BooleanConstant<
- internal::ImplicitlyConvertible<M, Matcher<T> >::value>(),
+ std::is_convertible<M, Matcher<T> >::value>(),
 BooleanConstant<
- internal::ImplicitlyConvertible<M, T>::value>());
+ std::is_convertible<M, T>::value>());
 }
 
 private:
 class SafeMatcherCastImpl {
 template <typename U>
 static inline Matcher<T> Cast(const Matcher<U>& matcher) {
 // Enforce that T can be implicitly converted to U.
- GTEST_COMPILE_ASSERT_((internal::ImplicitlyConvertible<T, U>::value),
- T_must_be_implicitly_convertible_to_U);
+ GTEST_COMPILE_ASSERT_((std::is_convertible<T, U>::value),
+ ""T must be implicitly convertible to U"");
 // Enforce that we are not converting a non-reference type T to a reference
 // type U.
 GTEST_COMPILE_ASSERT_(
",2834,540
"Googletest export

...text exposed to GitHub repo https://www.github.com/google/googletest

PiperOrigin-RevId: 228573333"," class MatcherBase {
 !internal::IsSame<U, const U&>::value>::type* = nullptr)
 : impl_(new internal::MatcherInterfaceAdapter<U>(impl)) {}
 
+ MatcherBase(const MatcherBase&) = default;
+ MatcherBase& operator=(const MatcherBase&) = default;
+ MatcherBase(MatcherBase&&) = default;
+ MatcherBase& operator=(MatcherBase&&) = default;
+
 virtual ~MatcherBase() {}
 
 private:
 class PolymorphicMatcher {
 
 private:
 const Impl impl_;
-
- GTEST_DISALLOW_ASSIGN_(MonomorphicImpl);
 };
 
 Impl impl_;
-
- GTEST_DISALLOW_ASSIGN_(PolymorphicMatcher);
 };
 
 // Creates a matcher from its implementation. This is easier to use
 class ComparisonBase {
 
 private:
 Rhs rhs_;
- GTEST_DISALLOW_ASSIGN_(Impl);
 };
 Rhs rhs_;
- GTEST_DISALLOW_ASSIGN_(ComparisonBase);
 };
 
 template <typename Rhs>
 class MatchesRegexMatcher {
 private:
 const std::shared_ptr<const RE> regex_;
 const bool full_match_;
-
- GTEST_DISALLOW_ASSIGN_(MatchesRegexMatcher);
 };
 } // namespace internal
 
",420,106
"Googletest export

Fix warning about deprecation of implicit operations such as copy constructors or assignment operators.

Specifically:

MatcherBase's default copy constructor, assignment operator, move operator, and move assignment operator are now declared explicitly rather than depending on the compiler implicit generation (which is disallowed/warned against due to MatcherBase's declaration of the destructor).

PiperOrigin-RevId: 228573333"," class MatcherBase {
 !internal::IsSame<U, const U&>::value>::type* = nullptr)
 : impl_(new internal::MatcherInterfaceAdapter<U>(impl)) {}
 
+ MatcherBase(const MatcherBase&) = default;
+ MatcherBase& operator=(const MatcherBase&) = default;
+ MatcherBase(MatcherBase&&) = default;
+ MatcherBase& operator=(MatcherBase&&) = default;
+
 virtual ~MatcherBase() {}
 
 private:
 class PolymorphicMatcher {
 
 private:
 const Impl impl_;
-
- GTEST_DISALLOW_ASSIGN_(MonomorphicImpl);
 };
 
 Impl impl_;
-
- GTEST_DISALLOW_ASSIGN_(PolymorphicMatcher);
 };
 
 // Creates a matcher from its implementation. This is easier to use
 class ComparisonBase {
 
 private:
 Rhs rhs_;
- GTEST_DISALLOW_ASSIGN_(Impl);
 };
 Rhs rhs_;
- GTEST_DISALLOW_ASSIGN_(ComparisonBase);
 };
 
 template <typename Rhs>
 class MatchesRegexMatcher {
 private:
 const std::shared_ptr<const RE> regex_;
 const bool full_match_;
-
- GTEST_DISALLOW_ASSIGN_(MatchesRegexMatcher);
 };
 } // namespace internal
 
",420,106
"Googletest export

Change tests to use new Test Suite API

PiperOrigin-RevId: 228908894"," class MacroLogicDeathTest : public testing::Test {
 static testing::internal::ReplaceDeathTestFactory* replacer_;
 static MockDeathTestFactory* factory_;
 
- static void SetUpTestCase() {
+ static void SetUpTestSuite() {
 factory_ = new MockDeathTestFactory;
 replacer_ = new testing::internal::ReplaceDeathTestFactory(factory_);
 }
 
- static void TearDownTestCase() {
+ static void TearDownTestSuite() {
 delete replacer_;
 replacer_ = nullptr;
 delete factory_;
",945,161
"Googletest export

Deduplicate testing::ReferenceWrapper with std::reference_wrapper.
Minor cleanups in matchers_test.

PiperOrigin-RevId: 229022872"," TEST_F(SetErrnoAndReturnTest, CompatibleTypes) {
 
 // Tests ByRef().
 
-// Tests that ReferenceWrapper<T> is copyable.
+// Tests that the result of ByRef() is copyable.
 TEST(ByRefTest, IsCopyable) {
 const std::string s1 = ""Hi"";
 const std::string s2 = ""Hello"";
 
- ::testing::internal::ReferenceWrapper<const std::string> ref_wrapper =
- ByRef(s1);
+ auto ref_wrapper = ByRef(s1);
 const std::string& r1 = ref_wrapper;
 EXPECT_EQ(&s1, &r1);
 
 TEST(ByRefTest, IsCopyable) {
 const std::string& r2 = ref_wrapper;
 EXPECT_EQ(&s2, &r2);
 
- ::testing::internal::ReferenceWrapper<const std::string> ref_wrapper1 =
- ByRef(s1);
+ auto ref_wrapper1 = ByRef(s1);
 // Copies ref_wrapper1 to ref_wrapper.
 ref_wrapper = ref_wrapper1;
 const std::string& r3 = ref_wrapper;
",967,153
"Googletest export

Add move-only argument support to almost all remaining matchers.

PiperOrigin-RevId: 229030728"," class PolymorphicMatcher {
 Impl impl_;
 };
 
-// Creates a matcher from its implementation. This is easier to use
-// than the Matcher<T> constructor as it doesn't require you to
-// explicitly write the template argument, e.g.
+// Creates a matcher from its implementation.
+// DEPRECATED: Especially in the generic code, prefer:
+// Matcher<T>(new MyMatcherImpl<const T&>(...));
 //
-// MakeMatcher(foo);
-// vs
-// Matcher<const string&>(foo);
+// MakeMatcher may create a Matcher that accepts its argument by value, which
+// leads to unnecessary copies & lack of support for non-copyable types.
 template <typename T>
 inline Matcher<T> MakeMatcher(const MatcherInterface<T>* impl) {
 return Matcher<T>(impl);
 class ComparisonBase {
 explicit ComparisonBase(const Rhs& rhs) : rhs_(rhs) {}
 template <typename Lhs>
 operator Matcher<Lhs>() const {
- return MakeMatcher(new Impl<Lhs>(rhs_));
+ return Matcher<Lhs>(new Impl<const Lhs&>(rhs_));
 }
 
 private:
",420,106
"Googletest export

Change remaining samples to use new Test Suite API

PiperOrigin-RevId: 229231566"," TEST_P(PrimeTableTestSmpl7, CanGetNextPrime) {
 //
 // Here, we instantiate our tests with a list of two PrimeTable object
 // factory functions:
-INSTANTIATE_TEST_CASE_P(OnTheFlyAndPreCalculated, PrimeTableTestSmpl7,
- Values(&CreateOnTheFlyPrimeTable,
- &CreatePreCalculatedPrimeTable<1000>));
+INSTANTIATE_TEST_SUITE_P(OnTheFlyAndPreCalculated, PrimeTableTestSmpl7,
+ Values(&CreateOnTheFlyPrimeTable,
+ &CreatePreCalculatedPrimeTable<1000>));
 
 } // namespace
",52,8
"Googletest export

Refactor the `Invoke` and `InvokeWithoutArgs` actions:
 - Replace pump'd classes and functions with templates.
 - Make the polymorphic actions be polymorphic functors instead.
 - Fix Invoke(Callback*) to work with subclasses of the callbacks, instead of trying to diagnose that in gmock_doctor.

PiperOrigin-RevId: 229604112","
 #include <stdio.h>
 #include <ostream> // NOLINT
 #include <string>
+#include <type_traits>
 #include ""gmock/internal/gmock-port.h""
 #include ""gtest/gtest.h""
 
",239,2
"Googletest export

Fix mocking method arguments with templated copy constructors.

A previous change removed workarounds for old compilers from googletest and googlemock. Unfortunately, a bit of code that started as a workaround for Symbian's C++ compiler is still needed to avoid copy/move constructor ambiguity when mocking functions with certain argument types.

The test case added by this CL is extracted from Chrome's codebase, and was discovered while attempting to roll googletest.

PiperOrigin-RevId: 229801765"," class OnCallSpec : public UntypedOnCallSpecBase {
 const ArgumentMatcherTuple& matchers)
 : UntypedOnCallSpecBase(a_file, a_line),
 matchers_(matchers),
- extra_matcher_(_) {}
+ // By default, extra_matcher_ should match anything. However,
+ // we cannot initialize it with _ as that causes ambiguity between
+ // Matcher's copy and move constructor for some argument types.
+ extra_matcher_(A<const ArgumentTuple&>()) {}
 
 // Implements the .With() clause.
 OnCallSpec& With(const Matcher<const ArgumentTuple&>& m) {
 class TypedExpectation : public ExpectationBase {
 : ExpectationBase(a_file, a_line, a_source_text),
 owner_(owner),
 matchers_(m),
- extra_matcher_(_),
+ // By default, extra_matcher_ should match anything. However,
+ // we cannot initialize it with _ as that causes ambiguity between
+ // Matcher's copy and move constructor for some argument types.
+ extra_matcher_(A<const ArgumentTuple&>()),
 repeated_action_(DoDefault()) {}
 
 ~TypedExpectation() override {
",988,156
"Googletest export

Make internal FunctionMocker class final

PiperOrigin-RevId: 230332778"," template <typename F>
 class FunctionMocker;
 
 template <typename R, typename... Args>
-class FunctionMocker<R(Args...)> : public UntypedFunctionMockerBase {
+class FunctionMocker<R(Args...)> final : public UntypedFunctionMockerBase {
 using F = R(Args...);
 
 public:
",988,156
"fix: Add Arduino to embedded platform list

Added Arduino to the embedded platform list to allow for a stubbed out version
of GetCurrentDir."," static bool IsPathSeparator(char c) {
 
 // Returns the current working directory, or """" if unsuccessful.
 FilePath FilePath::GetCurrentDir() {
-#if GTEST_OS_WINDOWS_MOBILE || GTEST_OS_WINDOWS_PHONE || GTEST_OS_WINDOWS_RT
- // Windows CE doesn't have a current directory, so we just return
+#if GTEST_OS_WINDOWS_MOBILE || GTEST_OS_WINDOWS_PHONE || GTEST_OS_WINDOWS_RT || ARDUINO
+ // Windows CE and Arduino don't have a current directory, so we just return
 // something reasonable.
 return FilePath(kCurrentDirectoryString);
 #elif GTEST_OS_WINDOWS
",191,69
"Googletest export

Fix stack overflow in AnyOfArray tests.

PiperOrigin-RevId: 231881125"," TEST(AnyOfArrayTest, BasicForms) {
 EXPECT_THAT(0, Not(AnyOfArray(ar, 0)));
 EXPECT_THAT(1, AnyOfArray(ar, 1));
 EXPECT_THAT(2, Not(AnyOfArray(ar, 1)));
- EXPECT_THAT(3, AnyOfArray(ar + 1, 3));
- EXPECT_THAT(4, Not(AnyOfArray(ar + 1, 3)));
+ EXPECT_THAT(3, AnyOfArray(ar + 1, 2));
+ EXPECT_THAT(4, Not(AnyOfArray(ar + 1, 2)));
 // Array
 // int ar0[0]; Not usable
 int ar1[1] = {1};
",948,139
"Googletest export

Update example code in gtest.h to prefer override over virtual now
that it is widely available in C++11.

PiperOrigin-RevId: 232057792"," GTEST_API_ GTEST_ATTRIBUTE_PRINTF_(2, 3) void ColoredPrintf(GTestColor color,
 // FooTest() {
 // // Can use GetParam() here.
 // }
-// virtual ~FooTest() {
+// ~FooTest() override {
 // // Can use GetParam() here.
 // }
-// virtual void SetUp() {
+// void SetUp() override {
 // // Can use GetParam() here.
 // }
-// virtual void TearDown {
+// void TearDown override {
 // // Can use GetParam() here.
 // }
 // };
 bool StaticAssertTypeEq() {
 //
 // class FooTest : public testing::Test {
 // protected:
-// virtual void SetUp() { b_.AddElement(3); }
+// void SetUp() override { b_.AddElement(3); }
 //
 // Foo a_;
 // Foo b_;
",767,127
"Googletest export

Mark legacy _TEST_CASE_ macros as deprecated

PiperOrigin-RevId: 232303251"," internal::CartesianProductHolder10<Generator1, Generator2, Generator3,
 
 // Legacy API is deprecated but still available
 #ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_
-#define INSTANTIATE_TEST_CASE_P INSTANTIATE_TEST_SUITE_P
+#define INSTANTIATE_TEST_CASE_P \
+ static_assert(::testing::internal::InstantiateTestCase_P_IsDeprecated(), \
+ """"); \
+ INSTANTIATE_TEST_SUITE_P
 #endif // GTEST_REMOVE_LEGACY_TEST_CASEAPI_
 
 } // namespace testing
",159,20
"Googletest export

Address -Wgnu-zero-variadic-macro-arguments
Originally in OSS PR #2063 https://github.com/google/googletest/pull/2063
Fix regression in INSTANTIATE_TEST_SUITE_P macro to accept function pointers properly.

PiperOrigin-RevId: 232316698"," INSTANTIATE_TEST_SUITE_P(CustomParamNameFunction, CustomFunctionNamingTest,
 Values(std::string(""FunctionName"")),
 CustomParamNameFunction);
 
+INSTANTIATE_TEST_SUITE_P(CustomParamNameFunctionP, CustomFunctionNamingTest,
+ Values(std::string(""FunctionNameP"")),
+ &CustomParamNameFunction);
+
 // Test custom naming with a lambda
 
 class CustomLambdaNamingTest : public TestWithParam<std::string> {};
 TEST(CustomNamingTest, CheckNameRegistry) {
 }
 EXPECT_EQ(1u, test_names.count(""CustomTestNames/FunctorName""));
 EXPECT_EQ(1u, test_names.count(""CustomTestNames/FunctionName""));
+ EXPECT_EQ(1u, test_names.count(""CustomTestNames/FunctionNameP""));
 EXPECT_EQ(1u, test_names.count(""CustomTestNames/LambdaName""));
 }
 
",690,105
"Stop TestInfo::Run() calling a function through null pointer

If the object was never created then trying to call &Test::DeleteSelf_
will dereference a null pointer, with undefined behaviour.

Fixes #845"," void TestInfo::Run() {
 test->Run();
 }
 
+ if (test != NULL) {
 // Deletes the test object.
 impl->os_stack_trace_getter()->UponLeavingGTest();
 internal::HandleExceptionsInMethodIfSupported(
- test, &Test::DeleteSelf_, ""the test fixture's destructor"");
+test, &Test::DeleteSelf_, ""the test fixture's destructor"");
+ }
 
 result_.set_elapsed_time(internal::GetTimeInMillis() - start);
 
",3799,926
"Googletest export

Internal changes.

PiperOrigin-RevId: 232953166"," bool StaticAssertTypeEq() {
 // EXPECT_EQ(a_.size(), 0);
 // EXPECT_EQ(b_.size(), 1);
 // }
-
+//
+// GOOGLETEST_CM0011 DO NOT DELETE
 #define TEST_F(test_fixture, test_name)\
 GTEST_TEST_(test_fixture, test_name, test_fixture, \
 ::testing::internal::GetTypeId<test_fixture>())
",767,127
"Fix -Wunused-private-field issues with clang

Provide dummy accessors for private values that are set in initializers,
but not actually used.

Signed-off-by: Enji Cooper <yaneurabeya@gmail.com>"," class Unprintable {
 Unprintable() : c_('a') {}
 
 bool operator==(const Unprintable& /* rhs */) const { return true; }
+ // -Wunused-private-field: dummy accessor for `c_`.
+ char dummy_c() { return c_; }
 private:
 char c_;
 };
",5229,731
"Import `patch-bsd-defines` from FreeBSD ports [1]

As noted in the patch description:
* Add DragonFly and GNU/kFreeBSD support.
* Implement GetThreadCount() for BSDs.

1. https://svnweb.freebsd.org/ports/head/devel/googletest/files/patch-bsd-defines?revision=488934

Signed-off-by: Enji Cooper <yaneurabeya@gmail.com>"," TEST(FormatCompilerIndependentFileLocationTest, FormatsUknownFileAndLine) {
 EXPECT_EQ(""unknown file"", FormatCompilerIndependentFileLocation(nullptr, -1));
 }
 
-#if GTEST_OS_LINUX || GTEST_OS_MAC || GTEST_OS_QNX || GTEST_OS_FUCHSIA
+#if GTEST_OS_LINUX || GTEST_OS_MAC || GTEST_OS_QNX || GTEST_OS_FUCHSIA || \
+ GTEST_OS_DRAGONFLY || GTEST_OS_FREEBSD || GTEST_OS_GNU_KFREEBSD || \
+ GTEST_OS_NETBSD || GTEST_OS_OPENBSD
 void* ThreadFunc(void* data) {
 internal::Mutex* mutex = static_cast<internal::Mutex*>(data);
 mutex->Lock();
",927,157
"Fix clang `-Winconsistent-missing-override` warnings

`DescribeTo(..)` and `MatchAndExplain(..)` in `gmock-matchers_test` both
override virtual methods. Remove the `virtual` keyword and apply `override` to
them instead.

Signed-off-by: Enji Cooper <yaneurabeya@gmail.com>"," TEST(ArgsTest, ExplainsMatchResultWithoutInnerExplanation) {
 // For testing Args<>'s explanation.
 class LessThanMatcher : public MatcherInterface<std::tuple<char, int> > {
 public:
- virtual void DescribeTo(::std::ostream* os) const {}
+ void DescribeTo(::std::ostream* os) const override {}
 
- virtual bool MatchAndExplain(std::tuple<char, int> value,
- MatchResultListener* listener) const {
+ bool MatchAndExplain(std::tuple<char, int> value,
+ MatchResultListener* listener) const override {
 const int diff = std::get<0>(value) - std::get<1>(value);
 if (diff > 0) {
 *listener << ""where the first value is "" << diff
",5229,731
"Fix clang `-Wunused-parameter` warnings

Comment out unused method parameters in their relevant definitions.

Signed-off-by: Enji Cooper <yaneurabeya@gmail.com>"," namespace adl_test {
 MATCHER(M, """") { return true; }
 
 template <typename T1, typename T2>
-bool AllOf(const T1& t1, const T2& t2) { return true; }
+bool AllOf(const T1& /*t1*/, const T2& /*t2*/) { return true; }
 
 TEST(AllOfTest, DoesNotCallAllOfUnqualified) {
 EXPECT_THAT(42, testing::AllOf(
",948,139
"Googletest export

Update gtest-death-test to use new Fuchsia API

Fuchsia has renamed this API and removed the need for several parameters. We now use the newer, simpler API.

PiperOrigin-RevId: 234617715","
 # endif // GTEST_OS_QNX
 
 # if GTEST_OS_FUCHSIA
+# include <lib/fdio/fd.h>
 # include <lib/fdio/io.h>
 # include <lib/fdio/spawn.h>
-# include <lib/fdio/util.h>
-# include <lib/zx/socket.h>
 # include <lib/zx/port.h>
 # include <lib/zx/process.h>
+# include <lib/zx/socket.h>
 # include <zircon/processargs.h>
 # include <zircon/syscalls.h>
 # include <zircon/syscalls/policy.h>
 DeathTest::TestRole FuchsiaDeathTest::AssumeRole() {
 zx::socket::create(0, &stderr_producer_socket, &stderr_socket_);
 GTEST_DEATH_TEST_CHECK_(status >= 0);
 int stderr_producer_fd = -1;
- zx_handle_t producer_handle[1] = { stderr_producer_socket.release() };
- uint32_t producer_handle_type[1] = { PA_FDIO_SOCKET };
- status = fdio_create_fd(
- producer_handle, producer_handle_type, 1, &stderr_producer_fd);
+ status =
+ fdio_fd_create(stderr_producer_socket.release(), &stderr_producer_fd);
 GTEST_DEATH_TEST_CHECK_(status >= 0);
 
 // Make the stderr socket nonblocking.
",965,174
"Googletest export

Build gmock cleanly with clang -Wextra-semi

For https://crbug.com/926235.
From https://github.com/google/googletest/pull/2139.
Fixes https://github.com/google/googletest/issues/2138.

PiperOrigin-RevId: 235832527"," TEST(MockMethodOverloadedMockMethodTest, CanOverloadOnArgNumberInMacroBody) {
 
 #define MY_MOCK_METHODS2_ \
 MOCK_CONST_METHOD1(Overloaded, int(int n)); \
- MOCK_METHOD1(Overloaded, int(int n));
+ MOCK_METHOD1(Overloaded, int(int n))
 
 class MockOverloadedOnConstness {
 public:
",451,45
"Googletest export

Build gmock cleanly with clang -Wextra-semi and -Wextra-semi-stmt

Extends 56ef07a20308 to take -Wc++98-compat-extra-semi
(https://reviews.llvm.org/D43162) and -Wextra-semi-stmt
(https://reviews.llvm.org/D52695) into account.

For https://crbug.com/926235.

PiperOrigin-RevId: 236643095"," void ExpectCallLogger() {
 DummyMock mock;
 EXPECT_CALL(mock, TestMethod());
 mock.TestMethod();
-};
+}
 
 // Verifies that EXPECT_CALL logs if the --gmock_verbose flag is set to ""info"".
 TEST(ExpectCallTest, LogsWhenVerbosityIsInfo) {
 TEST(ExpectCallTest, DoesNotLogWhenVerbosityIsError) {
 void OnCallLogger() {
 DummyMock mock;
 ON_CALL(mock, TestMethod());
-};
+}
 
 // Verifies that ON_CALL logs if the --gmock_verbose flag is set to ""info"".
 TEST(OnCallTest, LogsWhenVerbosityIsInfo) {
",528,76
"Googletest export

Remove mention of unused type ProtocolMessage.

PiperOrigin-RevId: 239242706"," class SetErrnoAndReturnAction {
 
 // Implements the SetArgumentPointee<N>(x) action for any function
 // whose N-th argument (0-based) is a pointer to x's type. The
-// template parameter kIsProto is true iff type A is ProtocolMessage,
-// proto2::Message, or a sub-class of those.
+// template parameter kIsProto is true iff type A is
+// proto2::Message or a sub-class of it.
 template <size_t N, typename A, bool kIsProto>
 class SetArgumentPointeeAction {
 public:
 template <size_t N, typename Proto>
 class SetArgumentPointeeAction<N, Proto, true> {
 public:
 // Constructs an action that sets the variable pointed to by the
- // N-th function argument to 'proto'. Both ProtocolMessage and
- // proto2::Message have the CopyFrom() method, so the same
- // implementation works for both.
+ // N-th function argument to 'proto'.
 explicit SetArgumentPointeeAction(const Proto& proto) : proto_(new Proto) {
 proto_->CopyFrom(proto);
 }
",618,105
"Googletest export

Remove support for ""global"" ::string and ::wstring types.
This support existed for legacy codebases that existed from before namespaces
where a thing. It is no longer necessary.

PiperOrigin-RevId: 241335738"," class BuiltInDefaultValue<T*> {
 }
 
 GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(void, ); // NOLINT
-#if GTEST_HAS_GLOBAL_STRING
-GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(::string, """");
-#endif // GTEST_HAS_GLOBAL_STRING
 GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(::std::string, """");
 GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(bool, false);
 GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(unsigned char, '\0');
",617,105
"Googletest export

Typos: ""more then"" -> ""more than"".
PiperOrigin-RevId: 241483698"," INSTANTIATE_TEST_SUITE_P(InstantiationName,
 Values(""meeny"", ""miny"", ""moe""));
 
 // To distinguish different instances of the pattern, (yes, you
-// can instantiate it more then once) the first argument to the
+// can instantiate it more than once) the first argument to the
 // INSTANTIATE_TEST_SUITE_P macro is a prefix that will be added to the
 // actual test suite name. Remember to pick unique prefixes for different
 // instantiations. The tests from the instantiation above will have
",67,12
"clang: fix `-Wsign-conversion` errors

Cast some values as their unsigned equivalents or `size_t` to match the
parameter type used for the template object under test. Also, provide
UInt32 equivalent delegate methods for some callers (with
int-equivalents for backwards compatibility).

This closes #2146.

Signed-off-by: Enji Cooper <yaneurabeya@gmail.com>"," class TypeParameterizedTest {
 // list.
 MakeAndRegisterTestInfo(
 (std::string(prefix) + (prefix[0] == '\0' ? """" : ""/"") + case_name +
- ""/"" + type_names[index])
+ ""/"" + type_names[static_cast<size_t>(index)])
 .c_str(),
 StripTrailingSpaces(GetPrefixUntilComma(test_names)).c_str(),
 GetTypeName<Type>().c_str(),
",633,89
"MSVC C5046 warning is unavailable in MSVC 2015.

Per the MSVC documentation the warning is new as of Visual Studio 2017,
version 15.8.
https://docs.microsoft.com/en-us/cpp/error-messages/compiler-warnings/c5046?view=vs-2019

GTest users building on MSVC 2015 or older versions of 2017 will, when
C4616 is enabled, see a warning like:

[...]gtest-matchers.h(53): error C2220: warning treated as error - no 'object' file generated
[...]gtest-matchers.h(53): warning C4619: #pragma warning: there is no warning number '5046'

Guard the mention of 5046 by an _MSC_VER check. VS2017 15.8 corresponds
to an _MSC_VER of 1915.
https://docs.microsoft.com/en-us/cpp/preprocessor/predefined-macros?view=vs-2019","
 #include ""gmock/internal/gmock-port.h""
 #include ""gtest/gtest.h""
 
+// MSVC warning C5046 is new as of VS2017 version 15.8.
+#if defined(_MSC_VER) && _MSC_VER >= 1915
+#define GMOCK_MAYBE_5046_ 5046
+#else
+#define GMOCK_MAYBE_5046_
+#endif
+
 GTEST_DISABLE_MSC_WARNINGS_PUSH_(
- 4251 5046 /* class A needs to have dll-interface to be used by clients of
- class B */
+ 4251 GMOCK_MAYBE_5046_ /* class A needs to have dll-interface to be used by
+ clients of class B */
 /* Symbol involving type with internal linkage not defined */)
 
 namespace testing {
",2906,553
"Sort Haiku platform definition alphabetically.

Fixes a minor ordering issue when defining the platform macro.
Also fixes a minor typo: 'Max OS X' -> 'Mac OS X'.","
 // GTEST_OS_CYGWIN - Cygwin
 // GTEST_OS_DRAGONFLY - DragonFlyBSD
 // GTEST_OS_FREEBSD - FreeBSD
-// GTEST_OS_HAIKU - Haiku
 // GTEST_OS_FUCHSIA - Fuchsia
 // GTEST_OS_GNU_KFREEBSD - GNU/kFreeBSD
+// GTEST_OS_HAIKU - Haiku
 // GTEST_OS_HPUX - HP-UX
 // GTEST_OS_LINUX - Linux
 // GTEST_OS_LINUX_ANDROID - Google Android

 // GTEST_OS_WINDOWS_RT - Windows Store App/WinRT
 // GTEST_OS_ZOS - z/OS
 //
-// Among the platforms, Cygwin, Linux, Max OS X, and Windows have the
+// Among the platforms, Cygwin, Linux, Mac OS X, and Windows have the
 // most stable support. Since core members of the Google Test project
 // don't have access to other platforms, support for them may be less
 // stable. If you notice any problems on your platform, please notify
",686,152
"Googletest export

[googletest] Fix death test condition.

PiperOrigin-RevId: 243742424"," DeathTest::TestRole FuchsiaDeathTest::AssumeRole() {
 zx_handle_t child_pipe_handle;
 int child_pipe_fd;
 status = fdio_pipe_half2(&child_pipe_fd, &child_pipe_handle);
- GTEST_DEATH_TEST_CHECK_(status != ZX_OK);
+ GTEST_DEATH_TEST_CHECK_(status == ZX_OK);
 set_read_fd(child_pipe_fd);
 
 // Set the pipe handle for the child.
",971,174
"Googletest export

Expose more information in SuiteApiResolver diagnostic output

PiperOrigin-RevId: 244179347"," TestInfo* RegisterTest(const char* test_suite_name, const char* test_name,
 return internal::MakeAndRegisterTestInfo(
 test_suite_name, test_name, type_param, value_param,
 internal::CodeLocation(file, line), internal::GetTypeId<TestT>(),
- internal::SuiteApiResolver<TestT>::GetSetUpCaseOrSuite(),
- internal::SuiteApiResolver<TestT>::GetTearDownCaseOrSuite(),
+ internal::SuiteApiResolver<TestT>::GetSetUpCaseOrSuite(file, line),
+ internal::SuiteApiResolver<TestT>::GetTearDownCaseOrSuite(file, line),
 new FactoryImpl{std::move(factory)});
 }
 
",754,125
"Googletest export

Fixes https://github.com/google/googletest/issues/2232

PiperOrigin-RevId: 244237560"," bool UnitTestImpl::RunAllTests() {
 // when we are inside the subprocess of a death test.
 const int repeat = in_subprocess_for_death_test ? 1 : GTEST_FLAG(repeat);
 // Repeats forever if the repeat count is negative.
- const bool forever = repeat < 0;
- for (int i = 0; forever || i != repeat; i++) {
+ const bool gtest_repeat_forever = repeat < 0;
+ for (int i = 0; gtest_repeat_forever || i != repeat; i++) {
 // We want to preserve failures generated by ad-hoc test
 // assertions executed before RUN_ALL_TESTS().
 ClearNonAdHocTestResult();
",3836,935
"Googletest export

Add GTEST_FAIL_AT, an equivalent to ADD_FAILURE_AT but that
spawns a fatal failure rather than a non-fatal, eg. the equivalent
of an ASSERT* failure rather than an EXPECT* failure.

PiperOrigin-RevId: 244746609"," class TestWithParam : public Test, public WithParamInterface<T> {
 // Generates a fatal failure with a generic message.
 #define GTEST_FAIL() GTEST_FATAL_FAILURE_(""Failed"")
 
+// Like GTEST_FAIL(), but at the given source file location.
+#define GTEST_FAIL_AT(file, line) \
+ GTEST_MESSAGE_AT_(file, line, ""Failed"", \
+ ::testing::TestPartResult::kFatalFailure)
+
 // Define this macro to 1 to omit the definition of FAIL(), which is a
 // generic name and clashes with some other libraries.
 #if !GTEST_DONT_DEFINE_FAIL
",754,125
"Remove / from parameterized test names if base test name is empty

This is useful to let a subsystem generate test names based on parameterized tests
without exposing them as such to the user.

Signed-off-by: Knut Omang <knut.omang@oracle.com>"," class ParameterizedTestSuiteInfo : public ParameterizedTestSuiteInfoBase {
 
 test_param_names.insert(param_name);
 
- test_name_stream << test_info->test_base_name << ""/"" << param_name;
+ if (!test_info->test_base_name.empty()) {
+ test_name_stream << test_info->test_base_name << ""/"";
+ }
+ test_name_stream << param_name;
 MakeAndRegisterTestInfo(
 test_suite_name.c_str(), test_name_stream.GetString().c_str(),
 nullptr, // No type parameter.
",562,112
"Address fallout from -Wsign-conversion work on Windows

Some Windows users builds were broken after a0d60be. This change
addresses the lingering -Wsign-conversion issues with those platforms
by adding some missing `static_cast` calls as needed.

Signed-off-by: Enji Cooper <yaneurabeya@gmail.com>"," size_t GetThreadCount() {
 #if GTEST_IS_THREADSAFE && GTEST_OS_WINDOWS
 
 void SleepMilliseconds(int n) {
- ::Sleep(n);
+ ::Sleep(static_cast<DWORD>(n));
 }
 
 AutoHandle::AutoHandle()
",869,216
Fix -Wsign-conversion error by adding static_cast," void PrintCharAndCodeTo(Char c, ostream* os) {
 if (format == kHexEscape || (1 <= c && c <= 9)) {
 // Do nothing.
 } else {
- *os << "", 0x"" << String::FormatHexInt(static_cast<UnsignedChar>(c));
+ *os << "", 0x"" << String::FormatHexInt(static_cast<int>(c));
 }
 *os << "")"";
 }
",276,90
"Use std::addressof to instead of plain '&'.

Otherwise the code won't compile if the '&' operater is overloaded and
return something that cannot be casted to void *."," class TypeWithoutFormatter {
 // This default version is called when kTypeKind is kOtherType.
 static void PrintValue(const T& value, ::std::ostream* os) {
 PrintBytesInObjectTo(static_cast<const unsigned char*>(
- reinterpret_cast<const void*>(&value)),
- sizeof(value), os);
+ reinterpret_cast<const void*>(
+ std::addressof(value))), sizeof(value), os);
 }
 };
 
",448,75
"unbreak windows build

windows msvc toolchain with werror and wconversion
will break if converting long to DWORD."," AssertionResult HRESULTFailureHelper(const char* expr,
 char error_text[kBufSize] = { '\0' };
 DWORD message_length = ::FormatMessageA(kFlags,
 0, // no source, we're asking system
- hr, // the error
+ static_cast<DWORD>(hr), // the error
 0, // no line width restrictions
 error_text, // output buffer
 kBufSize, // buf size
",3836,935
"Googletest export

Add a safety nullptr check to catch the case where the /tmp file used for capturing a stream cannot be created.

PiperOrigin-RevId: 250523012"," class CapturedStream {
 char name_template[] = ""/tmp/captured_stream.XXXXXX"";
 # endif // GTEST_OS_LINUX_ANDROID
 const int captured_fd = mkstemp(name_template);
+ if (captured_fd == -1) {
+ GTEST_LOG_(WARNING)
+ << ""Failed to create tmp file "" << name_template
+ << "" for test; does the test have access to the /tmp directory?"";
+ }
 filename_ = name_template;
 # endif // GTEST_OS_WINDOWS
 fflush(nullptr);
 class CapturedStream {
 }
 
 FILE* const file = posix::FOpen(filename_.c_str(), ""r"");
+ if (file == nullptr) {
+ GTEST_LOG_(FATAL) << ""Failed to open tmp file "" << filename_
+ << "" for capturing stream."";
+ }
 const std::string content = ReadEntireFile(file);
 posix::FClose(file);
 return content;
",878,218
Don't allow signed/unsigned wchar_t in gcc 9 and later," inline Element* GetRawPointer(Element* p) { return p; }
 //
 // To gcc,
 // wchar_t == signed wchar_t != unsigned wchar_t == unsigned int
+//
+// gcc-9 appears to treat signed/unsigned wchar_t as ill-formed
+// regardless of the signage of its underlying type.
 #ifdef __GNUC__
-#if !defined(__WCHAR_UNSIGNED__)
+#if !defined(__WCHAR_UNSIGNED__) && (__GNUC__ < 9)
 // signed/unsigned wchar_t are valid types.
 # define GMOCK_HAS_SIGNED_WCHAR_T_ 1
 #endif
",239,2
"Googletest export

comment change

PiperOrigin-RevId: 251231524"," class GTEST_API_ Test {
 // class.
 static void SetUpTestSuite() {}
 
- // Tears down the stuff shared by all tests in this test case.
+ // Tears down the stuff shared by all tests in this test suite.
 //
 // Google Test will call Foo::TearDownTestSuite() after running the last
 // test in test case Foo. Hence a sub-class can define its own
",754,125
"Googletest export

fdio_pipe_half is now the same as fdio_pipe_half2. We can switch back to the cleaner name.

PiperOrigin-RevId: 251633832"," DeathTest::TestRole FuchsiaDeathTest::AssumeRole() {
 zx_status_t status;
 zx_handle_t child_pipe_handle;
 int child_pipe_fd;
- status = fdio_pipe_half2(&child_pipe_fd, &child_pipe_handle);
+ status = fdio_pipe_half(&child_pipe_fd, &child_pipe_handle);
 GTEST_DEATH_TEST_CHECK_(status == ZX_OK);
 set_read_fd(child_pipe_fd);
 
",972,174
Fixed issue #2284 (Incompatibility with C++17)," TEST(ResultOfTest, WorksForFunctionReferences) {
 
 // Tests that ResultOf(f, ...) compiles and works as expected when f is a
 // function object.
-struct Functor : public ::std::unary_function<int, std::string> {
- result_type operator()(argument_type input) const {
+struct Functor {
+ std::string operator()(int input) const {
 return IntToStringFunction(input);
 }
 };
",5037,709
Renaming doc files to make the file names more palatable and in preparation for including documentation in sync process," class ActionHelper {
 // MORE INFORMATION:
 //
 // To learn more about using these macros, please search for 'ACTION' on
-// https://github.com/google/googletest/blob/master/googlemock/docs/CookBook.md
+// https://github.com/google/googletest/blob/master/googlemock/docs/cook_book.md
 
 // An internal macro needed for implementing ACTION*().
 #define GMOCK_ACTION_ARG_TYPES_AND_NAMES_UNUSED_\
",310,44
"Googletest export

Update a broken link in a comment.

PiperOrigin-RevId: 257493975"," class ActionHelper {
 // MORE INFORMATION:
 //
 // To learn more about using these macros, please search for 'ACTION' on
-// https://github.com/google/googletest/blob/master/googlemock/docs/cook_book.md
+// https://github.com/google/googletest/blob/master/googlemock/docs/CookBook.md
 
 // An internal macro needed for implementing ACTION*().
 #define GMOCK_ACTION_ARG_TYPES_AND_NAMES_UNUSED_\
",310,44
"Googletest export

Fix documentation links

PiperOrigin-RevId: 258389329"," class ActionHelper {
 // MORE INFORMATION:
 //
 // To learn more about using these macros, please search for 'ACTION' on
-// https://github.com/google/googletest/blob/master/googlemock/docs/CookBook.md
+// https://github.com/google/googletest/blob/master/googlemock/docs/cook_book.md
 
 // An internal macro needed for implementing ACTION*().
 #define GMOCK_ACTION_ARG_TYPES_AND_NAMES_UNUSED_\
",310,44
"Add missing <functional> include

gmock-spec-builders.h uses std::function (in MockFunction) but did
not include <functional> to provide it. Apparently, it worked since
the header must have been included by something else but better be
safe than sorry.","
 #ifndef GMOCK_INCLUDE_GMOCK_GMOCK_SPEC_BUILDERS_H_
 #define GMOCK_INCLUDE_GMOCK_GMOCK_SPEC_BUILDERS_H_
 
+#include <functional>
 #include <map>
 #include <memory>
 #include <set>
",989,156
"Googletest export

Internal change

PiperOrigin-RevId: 258587862"," gmock_output_test.py
 
 """"""
 
+from io import open # pylint: disable=redefined-builtin, g-importing-member
 import os
 import re
 import sys
 def GetNormalizedCommandOutputAndLeakyTests(cmd):
 
 
 class GMockOutputTest(gmock_test_utils.TestCase):
+
 def testOutput(self):
 (output, leaky_tests) = GetNormalizedCommandOutputAndLeakyTests(COMMAND)
 golden_file = open(GOLDEN_PATH, 'rb')
- golden = golden_file.read()
+ golden = golden_file.read().decode('utf-8')
 golden_file.close()
 
 # The normalized output should match the golden file.
",69,11
"Googletest export

Adds ISO8601 timestamps to XML output and RFC3339 timestamps to JSON output.

Adds timestamps to testsuites, testsuite and testcases structured JSON/XML output for better reporting how/where time is spent on tests.

PiperOrigin-RevId: 260039817"," EXPECTED_1 = {
 0,
 u'time':
 u'*',
+ u'timestamp':
+ u'*',
 u'testsuite': [{
 u'name': u'TestSomeProperties',
 u'status': u'RUN',
 u'result': u'COMPLETED',
 u'time': u'*',
+ u'timestamp': u'*',
 u'classname': u'PropertyOne',
 u'SetUpProp': u'1',
 u'TestSomeProperty': u'1',
 EXPECTED_2 = {
 0,
 u'time':
 u'*',
+ u'timestamp':
+ u'*',
 u'testsuite': [{
 u'name': u'TestSomeProperties',
 u'status': u'RUN',
 u'result': u'COMPLETED',
+ u'timestamp': u'*',
 u'time': u'*',
 u'classname': u'PropertyTwo',
 u'SetUpProp': u'2',
",142,11
update pre-C++11 paragraphs," class ActionHelper {
 //
 // CAVEAT:
 //
-// ACTION*() can only be used in a namespace scope. The reason is
-// that C++ doesn't yet allow function-local types to be used to
-// instantiate templates. The up-coming C++0x standard will fix this.
-// Once that's done, we'll consider supporting using ACTION*() inside
-// a function.
+// ACTION*() can only be used in a namespace scope as templates cannot be
+// declared inside of a local class.
+// Users can, however, define any local functors (e.g. a lambda) that
+// can be used as actions.
 //
 // MORE INFORMATION:
 //
",310,44
"adjust a comment to the similar section in advanced.md

in addition, fix typo of use -> us"," TYPED_TEST_SUITE(FooTest, MyTypes);
 // Then, use TYPED_TEST() instead of TEST_F() to define as many typed
 // tests for this test suite as you want.
 TYPED_TEST(FooTest, DoesBlah) {
- // Inside a test, refer to TypeParam to get the type parameter.
- // Since we are inside a derived class template, C++ requires use to
- // visit the members of FooTest via 'this'.
+ // Inside a test, refer to the special name TypeParam to get the type
+ // parameter. Since we are inside a derived class template, C++ requires
+ // us to visit the members of FooTest via 'this'.
 TypeParam n = this->value_;
 
 // To visit static members of the fixture, add the TestFixture::
",34,4
"remove an excessive mutable type specifier

MockFunction's private member cannot be reached from outside and all its
non-static member functions are not const."," class MockFunction<R(Args...)> {
 }
 
 private:
- mutable internal::FunctionMocker<R(Args...)> mock_;
+ internal::FunctionMocker<R(Args...)> mock_;
 };
 
 // The style guide prohibits ""using"" statements in a namespace scope
",989,156
"Googletest export

Internal Change

PiperOrigin-RevId: 260939845"," int main(int argc, char **argv) {
 // This is an example of using the UnitTest reflection API to inspect test
 // results. Here we discount failures from the tests we expected to fail.
 int unexpectedly_failed_tests = 0;
- for (int i = 0; i < unit_test.total_test_case_count(); ++i) {
- const TestCase& test_case = *unit_test.GetTestCase(i);
- for (int j = 0; j < test_case.total_test_count(); ++j) {
- const TestInfo& test_info = *test_case.GetTestInfo(j);
+ for (int i = 0; i < unit_test.total_test_suite_count(); ++i) {
+ const testing::TestSuite& test_suite = *unit_test.GetTestSuite(i);
+ for (int j = 0; j < test_suite.total_test_count(); ++j) {
+ const TestInfo& test_info = *test_suite.GetTestInfo(j);
 // Counts failed tests that were not meant to fail (those without
 // 'Fails' in the name).
 if (test_info.result()->Failed() &&
",83,19
"Googletest export

Document the fact that {Setup,TearDown}TestSuite failures are currently being dropped.

PiperOrigin-RevId: 260962695"," class GTEST_API_ Test {
 // test in test case Foo. Hence a sub-class can define its own
 // SetUpTestSuite() method to shadow the one defined in the super
 // class.
+ // Failures that happen during SetUpTestSuite are logged but otherwise
+ // ignored.
 static void SetUpTestSuite() {}
 
 // Tears down the stuff shared by all tests in this test suite.
 class GTEST_API_ Test {
 // test in test case Foo. Hence a sub-class can define its own
 // TearDownTestSuite() method to shadow the one defined in the super
 // class.
+ // Failures that happen during TearDownTestSuite are logged but otherwise
+ // ignored.
 static void TearDownTestSuite() {}
 
 // Legacy API is deprecated but still available
",759,128
"Googletest export

Fix signed conversion warning for wchar_t -> wint_t.
Fixes Github issue #2300

PiperOrigin-RevId: 261045497"," bool String::CaseInsensitiveWideCStringEquals(const wchar_t* lhs,
 // Other unknown OSes may not define it either.
 wint_t left, right;
 do {
- left = towlower(*lhs++);
- right = towlower(*rhs++);
+ left = towlower(static_cast<wint_t>(*lhs++));
+ right = towlower(static_cast<wint_t>(*rhs++));
 } while (left && left == right);
 return left == right;
 #endif // OS selector
",3867,939
"Googletest export

Internal Change

PiperOrigin-RevId: 261683482"," class GTEST_API_ UnitTest {
 int failed_test_case_count() const;
 int total_test_case_count() const;
 int test_case_to_run_count() const;
-#endif // EMOVE_LEGACY_TEST_CASEAPI
+#endif // GTEST_REMOVE_LEGACY_TEST_CASEAPI_
 
 // Gets the number of successful tests.
 int successful_test_count() const;
",759,128
remove a dead metafunction," std::string GetTypeName() {
 
 #if GTEST_HAS_TYPED_TEST || GTEST_HAS_TYPED_TEST_P
 
-// AssertyTypeEq<T1, T2>::type is defined if T1 and T2 are the same
-// type. This can be used as a compile-time assertion to ensure that
-// two types are equal.
-
-template <typename T1, typename T2>
-struct AssertTypeEq;
-
-template <typename T>
-struct AssertTypeEq<T, T> {
- typedef bool type;
-};
-
 // A unique type used as the default value for the arguments of class
 // template Types. This allows us to simulate variadic templates
 // (e.g. Types<int>, Type<int, double>, and etc), which C++ doesn't
",3067,8
remove an outdated comment," INSTANTIATE_TYPED_TEST_SUITE_P(My, FooTest, MyTypes);
 #define GTEST_NAME_GENERATOR_(TestSuiteName) \
 gtest_type_params_##TestSuiteName##_NameGenerator
 
-// The 'Types' template argument below must have spaces around it
-// since some compilers may choke on '>>' when passing a template
-// instance (e.g. Types<int>)
 #define TYPED_TEST_SUITE(CaseName, Types, ...) \
 typedef ::testing::internal::TypeList<Types>::type GTEST_TYPE_PARAMS_( \
 CaseName); \
 INSTANTIATE_TYPED_TEST_SUITE_P(My, FooTest, MyTypes);
 REGISTER_TYPED_TEST_SUITE_P
 #endif // GTEST_REMOVE_LEGACY_TEST_CASEAPI_
 
-// The 'Types' template argument below must have spaces around it
-// since some compilers may choke on '>>' when passing a template
-// instance (e.g. Types<int>)
 #define INSTANTIATE_TYPED_TEST_SUITE_P(Prefix, SuiteName, Types, ...) \
 static bool gtest_##Prefix##_##SuiteName GTEST_ATTRIBUTE_UNUSED_ = \
 ::testing::internal::TypeParameterizedTestSuite< \
",34,4
remove a custom implementation of std::add_lvalue_reference," inline void FlushInfoLog() { fflush(nullptr); }
 GTEST_LOG_(FATAL) << #posix_call << ""failed with error "" \
 << gtest_error
 
-// Adds reference to a type if it is not a reference type,
-// otherwise leaves it unchanged. This is the same as
-// tr1::add_reference, which is not widely available yet.
-template <typename T>
-struct AddReference { typedef T& type; }; // NOLINT
-template <typename T>
-struct AddReference<T&> { typedef T& type; }; // NOLINT
-
-// A handy wrapper around AddReference that works when the argument T
-// depends on template parameters.
-#define GTEST_ADD_REFERENCE_(T) \
- typename ::testing::internal::AddReference<T>::type
-
 // Transforms ""T"" into ""const T&"" according to standard reference collapsing
 // rules (this is only needed as a backport for C++98 compilers that do not
 // support reference collapsing). Specifically, it transforms:
",682,152
remove a custom implementation of std::enable_if," class GTEST_API_ AssertionResult {
 template <typename T>
 explicit AssertionResult(
 const T& success,
- typename internal::EnableIf<
+ typename std::enable_if<
 !std::is_convertible<T, AssertionResult>::value>::type*
 /*enabler*/
 = nullptr)
",759,128
remove a custom implementation of std::iterator_traits," TEST_P(DerivedTest, DoesBlah) {
 
 #endif // 0
 
+#include <iterator>
 #include <utility>
 
 #include ""gtest/internal/gtest-internal.h""
 internal::ParamGenerator<T> Range(T start, T end) {
 //
 template <typename ForwardIterator>
 internal::ParamGenerator<
- typename ::testing::internal::IteratorTraits<ForwardIterator>::value_type>
+ typename std::iterator_traits<ForwardIterator>::value_type>
 ValuesIn(ForwardIterator begin, ForwardIterator end) {
- typedef typename ::testing::internal::IteratorTraits<ForwardIterator>
- ::value_type ParamType;
+ typedef typename std::iterator_traits<ForwardIterator>::value_type ParamType;
 return internal::ParamGenerator<ParamType>(
 new internal::ValuesInIteratorRangeGenerator<ParamType>(begin, end));
 }
",67,12
remove a custom implementation of std::is_reference," class SafeMatcherCastImpl {
 // Enforce that we are not converting a non-reference type T to a reference
 // type U.
 GTEST_COMPILE_ASSERT_(
- internal::is_reference<T>::value || !internal::is_reference<U>::value,
+ std::is_reference<T>::value || !std::is_reference<U>::value,
 cannot_convert_non_reference_arg_to_reference);
 // In case both T and U are arithmetic types, enforce that the
 // conversion is not lossy.
",2906,553
remove custom implementations of std::is_same,"
 #include <set>
 #include <sstream>
 #include <string>
+#include <type_traits>
 #include <utility>
 #include <vector>
 #include ""gmock/gmock-actions.h""
 class FunctionMocker<R(Args...)> final : public UntypedFunctionMockerBase {
 const OnCallSpec<F>* const spec = FindOnCallSpec(args);
 
 if (spec == nullptr) {
- *os << (internal::type_equals<Result, void>::value ?
- ""returning directly.\n"" :
- ""returning default value.\n"");
+ *os << (std::is_void<Result>::value ? ""returning directly.\n""
+ : ""returning default value.\n"");
 } else {
 *os << ""taking default action specified at:\n""
 << FormatFileLocation(spec->file(), spec->line()) << ""\n"";
",989,156
"Googletest export

Remove legacy support for signed wchar_t and unsigned wchar_t.

Clang now errors out on these types as well by default. Rather than making the
condition for these types even more complicated, just remove the tests covering
these types since they don't seem to justify the maintenance burden. We
can reasonably expect these types to work in compilers that support them
without needing specific tests for them since they are treated as standard
integral types.

PiperOrigin-RevId: 263577673"," inline Element* GetRawPointer(Element* p) { return p; }
 # define GMOCK_WCHAR_T_IS_NATIVE_ 1
 #endif
 
-// signed wchar_t and unsigned wchar_t are NOT in the C++ standard.
-// Using them is a bad practice and not portable. So DON'T use them.
-//
-// Still, Google Mock is designed to work even if the user uses signed
-// wchar_t or unsigned wchar_t (obviously, assuming the compiler
-// supports them).
-//
-// To gcc,
-// wchar_t == signed wchar_t != unsigned wchar_t == unsigned int
-//
-// gcc-9 appears to treat signed/unsigned wchar_t as ill-formed
-// regardless of the signage of its underlying type.
-#ifdef __GNUC__
-#if !defined(__WCHAR_UNSIGNED__) && (__GNUC__ < 9)
-// signed/unsigned wchar_t are valid types.
-# define GMOCK_HAS_SIGNED_WCHAR_T_ 1
-#endif
-#endif
-
 // In what follows, we use the term ""kind"" to indicate whether a type
 // is bool, an integer type (excluding bool), a floating-point type,
 // or none of them. This categorization is useful for determining
",237,2
"restore mistakenly removed iffs in their explicit form

Due to confusion arisen from ""iff"" standing for ""if and only if"",
this commit uses the latter."," GTEST_API_ FailureReporterInterface* GetFailureReporter() {
 // Protects global resources (stdout in particular) used by Log().
 static GTEST_DEFINE_STATIC_MUTEX_(g_log_mutex);
 
-// Returns true if a log with the given severity is visible according
-// to the --gmock_verbose flag.
+// Returns true if and only if a log with the given severity is visible
+// according to the --gmock_verbose flag.
 GTEST_API_ bool LogIsVisible(LogSeverity severity) {
 if (GMOCK_FLAG(verbose) == kInfoVerbosity) {
 // Always show the log if --gmock_verbose=info.
 GTEST_API_ bool LogIsVisible(LogSeverity severity) {
 }
 }
 
-// Prints the given message to stdout if 'severity' >= the level
+// Prints the given message to stdout if and only if 'severity' >= the level
 // specified by the --gmock_verbose flag. If stack_frames_to_skip >=
 // 0, also prints the stack trace excluding the top
 // stack_frames_to_skip frames. In opt mode, any positive
",106,31
"Googletest export

Merge b8ca465e73ac0954a0c9eec2a84bdd8913d5763b into 90a443f9c2437ca8a682a1ac625eba64e1d74a8a

Closes #2396

COPYBARA_INTEGRATE_REVIEW=https://github.com/google/googletest/pull/2396 from kuzkry:custom-type-traits-true/false_type-and-bool_constant b8ca465e73ac0954a0c9eec2a84bdd8913d5763b
PiperOrigin-RevId: 265064856","
 // This file tests the internal utilities.
 
 #include ""gmock/internal/gmock-internal-utils.h""
+
 #include <stdlib.h>
+
 #include <map>
 #include <memory>
-#include <string>
 #include <sstream>
+#include <string>
 #include <type_traits>
 #include <vector>
+
 #include ""gmock/gmock.h""
 #include ""gmock/internal/gmock-port.h""
-#include ""gtest/gtest.h""
 #include ""gtest/gtest-spi.h""
+#include ""gtest/gtest.h""
 
 // Indicates that this translation unit is part of Google Test's
 // implementation. It must come before gtest-internal-inl.h is
 TEST(LogTest, OnlyWarningsArePrintedWhenVerbosityIsInvalid) {
 
 #endif // GTEST_HAS_STREAM_REDIRECTION
 
-TEST(TypeTraitsTest, true_type) {
- EXPECT_TRUE(true_type::value);
-}
-
-TEST(TypeTraitsTest, false_type) {
- EXPECT_FALSE(false_type::value);
-}
-
 TEST(TypeTraitsTest, remove_reference) {
 EXPECT_TRUE((std::is_same<char, remove_reference<char&>::type>::value));
 EXPECT_TRUE(
",511,72
"Googletest export

Merge 7f4f58da20e1066a888d3e4bcbef541db798a605 into 90a443f9c2437ca8a682a1ac625eba64e1d74a8a

Closes #2395

COPYBARA_INTEGRATE_REVIEW=https://github.com/google/googletest/pull/2395 from kuzkry:custom-type-traits-remove_reference 7f4f58da20e1066a888d3e4bcbef541db798a605
PiperOrigin-RevId: 266189044"," class PointeeMatcher {
 template <typename Pointer>
 class Impl : public MatcherInterface<Pointer> {
 public:
- typedef
- typename PointeeOf<typename std::remove_const<GTEST_REMOVE_REFERENCE_(
- Pointer)>::type>::type Pointee;
+ typedef typename PointeeOf<typename std::remove_const<
+ typename std::remove_reference<Pointer>::type>::type>::type Pointee;
 
 explicit Impl(const InnerMatcher& matcher)
 : matcher_(MatcherCast<const Pointee&>(matcher)) {}
",2904,553
"Googletest export

Extend gtest-port and stubs for ESP_PLATFORM

ESP_PLATFORM is the macro used to indicate compilation for the ESP32
using the esp-idf. This isn't a fully posix compatible system so
various features of google test need to be stubbed out in order for
it to work. It's oddly similar to the GTEST_OS_WINDOWS_PHONE setup.

PiperOrigin-RevId: 267471968"," static bool IsPathSeparator(char c) {
 // Returns the current working directory, or """" if unsuccessful.
 FilePath FilePath::GetCurrentDir() {
 #if GTEST_OS_WINDOWS_MOBILE || GTEST_OS_WINDOWS_PHONE || \
- GTEST_OS_WINDOWS_RT || ARDUINO
- // Windows CE and Arduino don't have a current directory, so we just return
+ GTEST_OS_WINDOWS_RT || ARDUINO || defined(ESP_PLATFORM)
+ // These platforms do not have a current directory, so we just return
 // something reasonable.
 return FilePath(kCurrentDirectoryString);
 #elif GTEST_OS_WINDOWS
",191,69
remove a dead function," inline bool IsDir(const StatStruct& st) { return S_ISDIR(st.st_mode); }
 
 GTEST_DISABLE_MSC_DEPRECATED_PUSH_()
 
-inline const char* StrNCpy(char* dest, const char* src, size_t n) {
- return strncpy(dest, src, n);
-}
-
 // ChDir(), FReopen(), FDOpen(), Read(), Write(), Close(), and
 // StrError() aren't needed on Windows CE at this time and thus not
 // defined there.
",649,151
remove GTEST_HAS_STD_STRING," typedef struct _RTL_CRITICAL_SECTION GTEST_CRITICAL_SECTION;
 # endif // defined(_MSC_VER) || defined(__BORLANDC__)
 #endif // GTEST_HAS_EXCEPTIONS
 
-#if !defined(GTEST_HAS_STD_STRING)
-// Even though we don't use this macro any longer, we keep it in case
-// some clients still depend on it.
-# define GTEST_HAS_STD_STRING 1
-#elif !GTEST_HAS_STD_STRING
-// The user told us that ::std::string isn't available.
-# error ""::std::string isn't available.""
-#endif // !defined(GTEST_HAS_STD_STRING)
-
 #ifndef GTEST_HAS_STD_WSTRING
 // The user didn't tell us whether ::std::wstring is available, so we need
 // to figure it out.
",652,152
change includes in gtest-port.h,"
 
 #include <limits>
 #include <memory>
+#include <sstream>
 
 #include ""gtest/internal/gtest-port.h""
 
",60,10
"Googletest export

Merge 4c9ef099b29d2c840c04643cd9662fd7be712f7b into 565f1b848215b77c3732bca345fe76a0431d8b34

Closes #2403

COPYBARA_INTEGRATE_REVIEW=https://github.com/google/googletest/pull/2403 from IYP-Programer-Yeah:remove-compile-assert-type-equal 4c9ef099b29d2c840c04643cd9662fd7be712f7b
PiperOrigin-RevId: 268681883"," class ReturnVoidAction {
 // Allows Return() to be used in any void-returning function.
 template <typename Result, typename ArgumentTuple>
 static void Perform(const ArgumentTuple&) {
- CompileAssertTypesEqual<void, Result>();
+ static_assert(std::is_void<Result>::value, ""Result should be void."");
 }
 };
 
 class IgnoreResultAction {
 typedef typename internal::Function<F>::Result Result;
 
 // Asserts at compile time that F returns void.
- CompileAssertTypesEqual<void, Result>();
+ static_assert(std::is_void<Result>::value, ""Result type should be void."");
 
 return Action<F>(new Impl<F>(action_));
 }
",575,100
"Googletest export

Merge 3bdefdb473d304803d2a38e2a2cd5cdc1827c3bd into fb49e6c164490a227bbb7cf5223b846c836a0305

Closes #2407

COPYBARA_INTEGRATE_REVIEW=https://github.com/google/googletest/pull/2407 from kuzkry:StaticAssertTypeEq 3bdefdb473d304803d2a38e2a2cd5cdc1827c3bd
PiperOrigin-RevId: 269255328"," class StlContainerView {
 typedef const type& const_reference;
 
 static const_reference ConstReference(const RawContainer& container) {
- // Ensures that RawContainer is not a const type.
- testing::StaticAssertTypeEq<
- RawContainer, typename std::remove_const<RawContainer>::type>();
+ static_assert(!std::is_const<RawContainer>::value,
+ ""RawContainer type must not be const"");
 return container;
 }
 static type Copy(const RawContainer& container) { return container; }
 class StlContainerView<Element[N]> {
 typedef const type const_reference;
 
 static const_reference ConstReference(const Element (&array)[N]) {
- // Ensures that Element is not a const type.
- testing::StaticAssertTypeEq<Element, RawElement>();
+ static_assert(std::is_same<Element, RawElement>::value,
+ ""Element type must not be const"");
 return type(array, N, RelationToSourceReference());
 }
 static type Copy(const Element (&array)[N]) {
",218,2
"square away the stuff that hasn't been merged in a manual review

This fixes up ab8f346b (a manual merge) that has abandoned some things
from PR #2395."," class PointeeMatcher {
 template <typename Pointer>
 class Impl : public MatcherInterface<Pointer> {
 public:
- typedef typename PointeeOf<typename std::remove_const<
- typename std::remove_reference<Pointer>::type>::type>::type Pointee;
+ typedef typename PointeeOf<GTEST_REMOVE_REFERENCE_AND_CONST_(Pointer)>::type
+ Pointee;
 
 explicit Impl(const InnerMatcher& matcher)
 : matcher_(MatcherCast<const Pointee&>(matcher)) {}
",2906,553
"square away the stuff that hasn't been merged in a manual review

This fixes up f2fb48c3 (a manual merge) that has abandoned some things
from PR #2407."," class GTEST_API_ ScopedTrace {
 // to cause a compiler error.
 template <typename T1, typename T2>
 constexpr bool StaticAssertTypeEq() noexcept {
- static_assert(std::is_same<T1, T2>::value,
- ""type1 and type2 are not the same type"");
+ static_assert(std::is_same<T1, T2>::value, ""T1 and T2 are not the same type"");
 return true;
 }
 
",759,128
"remove GTEST_ARRAY_SIZE_

This macro didn't work when an array was passed to a function by pointer,
in which case the information about its size was lost.
Better alternatives are:
* std::extent<T>::value (compile-time)
* std::array<T, N>::size() (compile-time)
* std::distance(std::begin(array), std::end(array)) (run-time)"," class Secret;
 // expression is false, compiler will issue an error containing this identifier.
 #define GTEST_COMPILE_ASSERT_(expr, msg) static_assert(expr, #msg)
 
-// Evaluates to the number of elements in 'array'.
-#define GTEST_ARRAY_SIZE_(array) (sizeof(array) / sizeof(array[0]))
-
 // A helper for suppressing warnings on constant condition. It just
 // returns 'condition'.
 GTEST_API_ bool IsTrue(bool condition);
",646,152
"Add many missing override keywords

This helps corrects builds with -Werror=suggest-overrides"," class PolymorphicMatcher {
 public:
 explicit MonomorphicImpl(const Impl& impl) : impl_(impl) {}
 
- virtual void DescribeTo(::std::ostream* os) const { impl_.DescribeTo(os); }
+ void DescribeTo(::std::ostream* os) const override { impl_.DescribeTo(os); }
 
- virtual void DescribeNegationTo(::std::ostream* os) const {
+ void DescribeNegationTo(::std::ostream* os) const override {
 impl_.DescribeNegationTo(os);
 }
 
- virtual bool MatchAndExplain(T x, MatchResultListener* listener) const {
+ bool MatchAndExplain(T x, MatchResultListener* listener) const override {
 return impl_.MatchAndExplain(x, listener);
 }
 
",398,103
"Googletest export

Use a more portable path for Android to write temp files to.

/sdcard is *not* guaranteed to be available, but /data/local/tmp is.

In some emulated situations, /sdcard may not be mounted, may not be R/W, or
mounting may be delayed until *after* the test process begins.

This is fairly common location to use. See e.g.:
https://reviews.llvm.org/D9569

PiperOrigin-RevId: 270909282"," class CapturedStream {
 // code as part of a regular standalone executable, which doesn't
 // run in a Dalvik process (e.g. when running it through 'adb shell').
 //
- // The location /sdcard is directly accessible from native code
- // and is the only location (unofficially) supported by the Android
- // team. It's generally a symlink to the real SD Card mount point
- // which can be /mnt/sdcard, /mnt/sdcard0, /system/media/sdcard, or
- // other OEM-customized locations. Never rely on these, and always
- // use /sdcard.
- char name_template[] = ""/sdcard/gtest_captured_stream.XXXXXX"";
+ // The location /data/local/tmp is directly accessible from native code.
+ // '/sdcard' and other variants cannot be relied on, as they are not
+ // guaranteed to be mounted, or may have a delay in mounting.
+ char name_template[] = ""/data/local/tmp/gtest_captured_stream.XXXXXX"";
 # else
 char name_template[] = ""/tmp/captured_stream.XXXXXX"";
 # endif // GTEST_OS_LINUX_ANDROID
",878,218
"Googletest export

Makes testing::ResultOf() work with non-copyable arguments.

PiperOrigin-RevId: 271222632"," struct CallableTraits {
 static void CheckIsValid(Functor /* functor */) {}
 
 template <typename T>
- static auto Invoke(Functor f, T arg) -> decltype(f(arg)) { return f(arg); }
+ static auto Invoke(Functor f, const T& arg) -> decltype(f(arg)) {
+ return f(arg);
+ }
 };
 
 // Specialization for function pointers.
 class ResultOfMatcher {
 
 template <typename T>
 operator Matcher<T>() const {
- return Matcher<T>(new Impl<T>(callable_, matcher_));
+ return Matcher<T>(new Impl<const T&>(callable_, matcher_));
 }
 
 private:
",2908,553
"Googletest export

Add a compile time check to ensure that the parameters to TEST and TEST_F are not empty

Some compilers may already fail in that case and even where it works, it's likely to result in technically invalid code by virtue of creating reserved identifiers:
https://en.cppreference.com/w/cpp/language/identifiers

PiperOrigin-RevId: 272543242"," constexpr bool InstantiateTypedTestCase_P_IsDeprecated() { return true; }
 
 // Helper macro for defining tests.
 #define GTEST_TEST_(test_suite_name, test_name, parent_class, parent_id) \
+ static_assert(sizeof(GTEST_STRINGIFY_(test_suite_name)) > 1, \
+ ""test_suite_name must not be empty""); \
+ static_assert(sizeof(GTEST_STRINGIFY_(test_name)) > 1, \
+ ""test_name must not be empty""); \
 class GTEST_TEST_CLASS_NAME_(test_suite_name, test_name) \
 : public parent_class { \
 public: \
",618,89
Use FormatFileLocation for streaming file and line,"
 // EXPECT_CALL).
 
 #include ""gmock/gmock-spec-builders.h""
+#include ""gtest/internal/gtest-port.h""
 
 #include <stdlib.h>
 #include <iostream> // NOLINT
 GTEST_API_ void LogWithLocation(testing::internal::LogSeverity severity,
 const char* file, int line,
 const std::string& message) {
 ::std::ostringstream s;
- s << file << "":"" << line << "": "" << message << ::std::endl;
+ s << internal::FormatFileLocation(file, line) << "" "" << message << ::std::endl;
 Log(severity, s.str(), 0);
 }
 
",555,122
"Googletest export

Add a compile time check to ensure that the parameters to TEST_P and INSTANTIATE_TEST_SUITE_P are not empty. Some compilers already fail in that case and, even where it works, it's likely to result in technically invalid code by virtue of creating reserved identifiers:
https://en.cppreference.com/w/cpp/language/identifiers

PiperOrigin-RevId: 273832263"," class EmptyBasenameParamInst : public testing::TestWithParam<int> {};
 
 TEST_P(EmptyBasenameParamInst, Passes) { EXPECT_EQ(1, GetParam()); }
 
-INSTANTIATE_TEST_SUITE_P(, EmptyBasenameParamInst, testing::Values(1));
+INSTANTIATE_TEST_SUITE_P(All, EmptyBasenameParamInst, testing::Values(1));
 
 static const char kGoldenString[] = ""\""Line\0 1\""\nLine 2"";
 
",672,132
"Googletest export

Fix the O(n^2) number of instantiations in ElemFromList.
It is now O(n). It still has O(1) instantiation depth.

PiperOrigin-RevId: 273980821"," struct Function<R(Args...)> {
 using Result = R;
 static constexpr size_t ArgumentCount = sizeof...(Args);
 template <size_t I>
- using Arg = ElemFromList<I, typename MakeIndexSequence<sizeof...(Args)>::type,
- Args...>;
+ using Arg = ElemFromList<I, Args...>;
 using ArgumentTuple = std::tuple<Args...>;
 using ArgumentMatcherTuple = std::tuple<Matcher<Args>...>;
 using MakeResultVoid = void(Args...);
",217,2
"Googletest export

- Fix a bug in dealing with paramaterized tests where the name is it self a macro expansion.
- Add a compile time check to ensure that the parameters to TEST_P and INSTANTIATE_TEST_SUITE_P are not empty. The above fix causes some compilers to fail in that case and even where it works, it's likely to result in technically invalid code by virtue of creating reserved identifiers:
https://en.cppreference.com/w/cpp/language/identifiers

PiperOrigin-RevId: 274047249"," internal::CartesianProductHolder<Generator...> Combine(const Generator&... g) {
 ::testing::UnitTest::GetInstance() \
 ->parameterized_test_registry() \
 .GetTestSuitePatternHolder<test_suite_name>( \
- #test_suite_name, \
+ GTEST_STRINGIFY_(test_suite_name), \
 ::testing::internal::CodeLocation(__FILE__, __LINE__)) \
 ->AddTestPattern( \
 GTEST_STRINGIFY_(test_suite_name), GTEST_STRINGIFY_(test_name), \
 internal::CartesianProductHolder<Generator...> Combine(const Generator&... g) {
 ::testing::UnitTest::GetInstance() \
 ->parameterized_test_registry() \
 .GetTestSuitePatternHolder<test_suite_name>( \
- #test_suite_name, \
+ GTEST_STRINGIFY_(test_suite_name), \
 ::testing::internal::CodeLocation(__FILE__, __LINE__)) \
 ->AddTestSuiteInstantiation( \
- #prefix, &gtest_##prefix##test_suite_name##_EvalGenerator_, \
+ GTEST_STRINGIFY_(prefix), \
+ &gtest_##prefix##test_suite_name##_EvalGenerator_, \
 &gtest_##prefix##test_suite_name##_EvalGenerateName_, \
 __FILE__, __LINE__)
 
",67,12
Replace compile-test with preprocessor test," TEST(MockMethodMockFunctionTest, MockMethodSizeOverhead) {
 EXPECT_EQ(sizeof(MockMethodSizes0), sizeof(MockMethodSizes4));
 }
 
-// TODO(thejcannon): This just tests that this will compile, as gmock repeating the
-// noexcept specifier isn't supported yet
-struct MockUsesNoexceptWithParenthesis
-{
- MOCK_METHOD(void, func, (), (noexcept(false)));
-};
-
 } // namespace gmock_function_mocker_test
 } // namespace testing
",451,45
"feat: Add support for ESP8266 platform

Added support for ESP8266 Arduino platform.

Refactored Arduino defines to use the GTEST_OS_* model.","
 #include ""gmock/gmock.h""
 #include ""gtest/gtest.h""
 
-#ifdef ARDUINO
+#if defined GTEST_OS_ESP8266 || defined GTEST_OS_ESP32
 void setup() {
 // Since Google Mock depends on Google Test, InitGoogleMock() is
 // also responsible for initializing Google Test. Therefore there's
",14,2
"Add ESP8266 configs to PlatformIO build

Added various conditional compliations for ESP8266 to stub out
missing functionality.","
 #include ""gmock/gmock.h""
 #include ""gtest/gtest.h""
 
-#if defined GTEST_OS_ESP8266 || defined GTEST_OS_ESP32
+#if GTEST_OS_ESP8266 || GTEST_OS_ESP32
+# if GTEST_OS_ESP8266
+extern ""C"" {
+# endif
 void setup() {
 // Since Google Mock depends on Google Test, InitGoogleMock() is
 // also responsible for initializing Google Test. Therefore there's
 void setup() {
 testing::InitGoogleMock();
 }
 void loop() { RUN_ALL_TESTS(); }
+# if GTEST_OS_ESP8266
+}
+# endif
+
 #else
 
 // MS C++ compiler/linker has a bug on Windows (not on Windows CE), which
",16,2
"Add more override keywords

Mark more functions with ""override"" keyword, just like
it was done in commit 2460f97152c.

This should prevent compiler from complaining while compiling both
user code, and the googletest code itself with the -Wsuggest-override
option turned on; with the exception of:
 * calls to new MOCK_METHOD() in test/gmock-function-mocker_test.cc
 * calls to old MOCK_METHODx()/MOCK_CONST_METHODx() in other
 unit test files.

Closes #2493"," INSTANTIATE_TYPED_TEST_SUITE_P(My, FooTest, MyTypes);
 private: \
 typedef CaseName<gtest_TypeParam_> TestFixture; \
 typedef gtest_TypeParam_ TypeParam; \
- virtual void TestBody(); \
+ void TestBody() override; \
 }; \
 static bool gtest_##CaseName##_##TestName##_registered_ \
 GTEST_ATTRIBUTE_UNUSED_ = \
 INSTANTIATE_TYPED_TEST_SUITE_P(My, FooTest, MyTypes);
 private: \
 typedef SuiteName<gtest_TypeParam_> TestFixture; \
 typedef gtest_TypeParam_ TypeParam; \
- virtual void TestBody(); \
+ void TestBody() override; \
 }; \
 static bool gtest_##TestName##_defined_ GTEST_ATTRIBUTE_UNUSED_ = \
 GTEST_TYPED_TEST_SUITE_P_STATE_(SuiteName).AddTestName( \
",34,4
"Googletest export

Remove a test case rendered obsolete by disallowing empty argument for INSTANTIATE_TEST_SUITE_P.
Remove the code that it was testing.

PiperOrigin-RevId: 275040108"," class ParameterizedTestSuiteInfo : public ParameterizedTestSuiteInfoBase {
 
 test_param_names.insert(param_name);
 
- if (!test_info->test_base_name.empty()) {
- test_name_stream << test_info->test_base_name << ""/"";
- }
- test_name_stream << param_name;
+ test_name_stream << test_info->test_base_name << ""/"" << param_name;
 MakeAndRegisterTestInfo(
 test_suite_name.c_str(), test_name_stream.GetString().c_str(),
 nullptr, // No type parameter.
",559,111
"[googletest] Output skip message

Closes #2208

Previously, skip messages were invisible, so debugging skips was hard.

Now we have this:

```
$ ./googletest/gtest_skip_test
Running main() from /home/lesha/github/snarkmaster/googletest/googletest/src/gtest_main.cc
[==========] Running 3 tests from 2 test suites.
[----------] Global test environment set-up.
[----------] 1 test from SkipTest
[ RUN ] SkipTest.DoesSkip
/home/lesha/github/snarkmaster/googletest/googletest/test/gtest_skip_test.cc:38: Skipped
skipping single test
[ SKIPPED ] SkipTest.DoesSkip (0 ms)
[----------] 1 test from SkipTest (1 ms total)
...
```"," class TestWithParam : public Test, public WithParamInterface<T> {
 // Skips test in runtime.
 // Skipping test aborts current function.
 // Skipped tests are neither successful nor failed.
-#define GTEST_SKIP() GTEST_SKIP_(""Skipped"")
+#define GTEST_SKIP() GTEST_SKIP_("""")
 
 // ADD_FAILURE unconditionally adds a failure to the current test.
 // SUCCEED generates a success - it doesn't automatically make the
",759,128
"Googletest export

Addressing https://github.com/google/googletest/issues/2502

Add MOCK_METHOD support for returning function pointers.

PiperOrigin-RevId: 275323671"," class FooInterface {
 virtual int TypeWithComma(const std::map<int, std::string>& a_map) = 0;
 virtual int TypeWithTemplatedCopyCtor(const TemplatedCopyable<int>&) = 0;
 
+ virtual int (*ReturnsFunctionPointer1(int))(bool) = 0;
+ using fn_ptr = int (*)(bool);
+ virtual fn_ptr ReturnsFunctionPointer2(int) = 0;
+
 #if GTEST_OS_WINDOWS
 STDMETHOD_(int, CTNullary)() = 0;
 STDMETHOD_(bool, CTUnary)(int x) = 0;
 class MockFoo : public FooInterface {
 MOCK_METHOD(int, TypeWithTemplatedCopyCtor,
 (const TemplatedCopyable<int>&)); // NOLINT
 
+ MOCK_METHOD(int (*)(bool), ReturnsFunctionPointer1, (int), ());
+ MOCK_METHOD(fn_ptr, ReturnsFunctionPointer2, (int), ());
+
 #if GTEST_OS_WINDOWS
 MOCK_METHOD(int, CTNullary, (), (Calltype(STDMETHODCALLTYPE)));
 MOCK_METHOD(bool, CTUnary, (int), (Calltype(STDMETHODCALLTYPE)));
",456,45
"Googletest export

Remove bool_constant in favor of std::integral_constant<bool, ...>;
The one non-trivial use of bool_constant has been changed to have significantly
fewer template specializations.

PiperOrigin-RevId: 275842490"," class MatcherCastImpl {
 template <bool Ignore>
 static Matcher<T> CastImpl(const M& polymorphic_matcher_or_value,
 std::true_type /* convertible_to_matcher */,
- bool_constant<Ignore>) {
+ std::integral_constant<bool, Ignore>) {
 // M is implicitly convertible to Matcher<T>, which means that either
 // M is a polymorphic matcher or Matcher<T> has an implicit constructor
 // from M. In both cases using the implicit conversion will produce a
",2923,557
"Prevent using ReturnRef on reference to temporary

Fixed issue: 2471"," inline internal::ReturnRefAction<R> ReturnRef(R& x) { // NOLINT
 return internal::ReturnRefAction<R>(x);
 }
 
+// Prevent using ReturnRef on reference to temporary.
+template <typename R>
+internal::ReturnRefAction<R> ReturnRef(R&&) = delete;
+
 // Creates an action that returns the reference to a copy of the
 // argument. The copy is created when the action is constructed and
 // lives as long as the action.
",577,100
"Added tests verifying that temporaries are accepted by ReturnRef

Issue no 2527"," TEST(ReturnRefTest, IsCovariant) {
 EXPECT_EQ(&derived, &a.Perform(std::make_tuple()));
 }
 
+namespace
+{
+template <typename T, typename = decltype(ReturnRef(std::declval<T&&>()))>
+bool CanCallReturnRef(T&&) { return true; }
+bool CanCallReturnRef(Unused) { return false; }
+}
+
+// Tests that ReturnRef(v) is not working with temporaries (T&&)
+TEST(ReturnRefTest, WillNotAcceptTemporaryAkaRValueRef) {
+ int value = 13;
+ EXPECT_TRUE(CanCallReturnRef(value));
+ EXPECT_FALSE(CanCallReturnRef(std::move(value)));
+ EXPECT_FALSE(CanCallReturnRef(value + 1));
+ EXPECT_FALSE(CanCallReturnRef(123));
+}
+
+// Tests that ReturnRef(v) is not working with const temporaries (const T&&)
+TEST(ReturnRefTest, WillNotAcceptConstTemporaryAkaContRValueRef) {
+ const int value = 42;
+ EXPECT_TRUE(CanCallReturnRef(value));
+ EXPECT_FALSE(CanCallReturnRef(std::move(value)));
+}
+
+
 // Tests that ReturnRefOfCopy(v) works for reference types.
 TEST(ReturnRefOfCopyTest, WorksForReference) {
 int n = 42;
",980,153
"Googletest export

Add a matcher `testing::ReturnRoundRobin` which, on each call, returns the next element in the sequence, restarting at the beginning once it has reached the end.

PiperOrigin-RevId: 276312136","
+#!/usr/bin/env python
+#
+# Copyright 2010 Google Inc. All Rights Reserved.
+
+""""""Runs program specified in the command line with the substituted PATH.
+
+ This script is needed for to support building under Pulse which is unable
+ to override the existing PATH variable.
+""""""
+
+import os
+import subprocess
+import sys
+
+SUBST_PATH_ENV_VAR_NAME = ""SUBST_PATH""
+
+def main():
+ if SUBST_PATH_ENV_VAR_NAME in os.environ:
+ os.environ[""PATH""] = os.environ[SUBST_PATH_ENV_VAR_NAME]
+
+ exit_code = subprocess.Popen(sys.argv[1:]).wait()
+
+ # exit_code is negative (-signal) if the process has been terminated by
+ # a signal. Returning negative exit code is not portable and so we return
+ # 100 instead.
+ if exit_code < 0:
+ exit_code = 100
+
+ sys.exit(exit_code)
+
+if __name__ == ""__main__"":
+ main()
",18,3
"Apply 80chars limit

Issue 2527"," TEST(ReturnRefTest, DoesNotWorkForTemporary) {
 auto nonScalarValue = []() -> std::string { return ""ABC""; };
 EXPECT_FALSE(CanCallReturnRef(nonScalarValue()));
 
- // cannot use here callable returning ""const scalar type"" because C++ ignores such const for scalar return type, so the static_cast
+ // cannot use here callable returning ""const scalar type"",
+ // because such const for scalar return type is ignored
 EXPECT_FALSE(CanCallReturnRef(static_cast<const int>(321)));
 
 auto constNonScalarValue = []() -> const std::string { return ""CBA""; };
",985,153
replace autogenerated TypesX classes by variadic ones," struct NameGeneratorSelector {
 };
 
 template <typename NameGenerator>
-void GenerateNamesRecursively(Types0, std::vector<std::string>*, int) {}
+void GenerateNamesRecursively(internal::None, std::vector<std::string>*, int) {}
 
 template <typename NameGenerator, typename Types>
 void GenerateNamesRecursively(Types, std::vector<std::string>* result, int i) {
 class TypeParameterizedTest {
 
 // The base case for the compile time recursion.
 template <GTEST_TEMPLATE_ Fixture, class TestSel>
-class TypeParameterizedTest<Fixture, TestSel, Types0> {
+class TypeParameterizedTest<Fixture, TestSel, internal::None> {
 public:
 static bool Register(const char* /*prefix*/, const CodeLocation&,
 const char* /*case_name*/, const char* /*test_names*/,
",621,89
replace autogenerated TemplatesX classes by variadic ones," INSTANTIATE_TYPED_TEST_SUITE_P(My, FooTest, MyTypes);
 void GTEST_SUITE_NAMESPACE_( \
 SuiteName)::TestName<gtest_TypeParam_>::TestBody()
 
-#define REGISTER_TYPED_TEST_SUITE_P(SuiteName, ...) \
- namespace GTEST_SUITE_NAMESPACE_(SuiteName) { \
- typedef ::testing::internal::Templates<__VA_ARGS__>::type gtest_AllTests_; \
- } \
- static const char* const GTEST_REGISTERED_TEST_NAMES_( \
- SuiteName) GTEST_ATTRIBUTE_UNUSED_ = \
- GTEST_TYPED_TEST_SUITE_P_STATE_(SuiteName).VerifyRegisteredTestNames( \
+#define REGISTER_TYPED_TEST_SUITE_P(SuiteName, ...) \
+ namespace GTEST_SUITE_NAMESPACE_(SuiteName) { \
+ typedef ::testing::internal::Templates<__VA_ARGS__> gtest_AllTests_; \
+ } \
+ static const char* const GTEST_REGISTERED_TEST_NAMES_( \
+ SuiteName) GTEST_ATTRIBUTE_UNUSED_ = \
+ GTEST_TYPED_TEST_SUITE_P_STATE_(SuiteName).VerifyRegisteredTestNames( \
 __FILE__, __LINE__, #__VA_ARGS__)
 
 // Legacy API is deprecated but still available
",34,4
remove gtest-type-util.h.pump,"
-// This file was GENERATED by command:
-// pump.py gtest-type-util.h.pump
-// DO NOT EDIT BY HAND!!!
-
 // Copyright 2008 Google Inc.
 // All Rights Reserved.
 //

 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
-
 // Type utilities needed for implementing typed and type-parameterized
-// tests. This file is generated by a SCRIPT. DO NOT EDIT BY HAND!
+// tests.
 
 // GOOGLETEST_CM0001 DO NOT DELETE
 
",75,8
"Googletest export

Avoid temporary matcher instances.
They are unnecessary and can be relatively more expensive than the rest of the
algorithm.

PiperOrigin-RevId: 277084853"," class UnorderedElementsAreMatcherImpl
 element_printouts->clear();
 ::std::vector<char> did_match;
 size_t num_elements = 0;
+ DummyMatchResultListener dummy;
 for (; elem_first != elem_last; ++num_elements, ++elem_first) {
 if (listener->IsInterested()) {
 element_printouts->push_back(PrintToString(*elem_first));
 }
 for (size_t irhs = 0; irhs != matchers_.size(); ++irhs) {
- did_match.push_back(Matches(matchers_[irhs])(*elem_first));
+ did_match.push_back(
+ matchers_[irhs].MatchAndExplain(*elem_first, &dummy));
 }
 }
 
",2925,557
"Googletest export

Tolerate std::string's explicit copy construction from std::string_view.

PiperOrigin-RevId: 277583394"," class HasSubstrMatcher {
 template <typename MatcheeStringType>
 bool MatchAndExplain(const MatcheeStringType& s,
 MatchResultListener* /* listener */) const {
- const StringType& s2(s);
- return s2.find(substring_) != StringType::npos;
+ return StringType(s).find(substring_) != StringType::npos;
 }
 
 // Describes what this matcher matches.
",2924,557
"Googletest export

Change variable name to match comment.

PiperOrigin-RevId: 277713621"," inline internal::DoDefaultAction DoDefault() {
 // Creates an action that sets the variable pointed by the N-th
 // (0-based) function argument to 'value'.
 template <size_t N, typename T>
-internal::SetArgumentPointeeAction<N, T> SetArgPointee(T x) {
- return {std::move(x)};
+internal::SetArgumentPointeeAction<N, T> SetArgPointee(T value) {
+ return {std::move(value)};
 }
 
 // The following version is DEPRECATED.
 template <size_t N, typename T>
-internal::SetArgumentPointeeAction<N, T> SetArgumentPointee(T x) {
- return {std::move(x)};
+internal::SetArgumentPointeeAction<N, T> SetArgumentPointee(T value) {
+ return {std::move(value)};
 }
 
 // Creates an action that sets a pointer referent to a given value.
",610,106
change incorrect comments," bool PredFunction%(n)s(%(tvs)s) {
 return %(v_sum)s > 0;
 }
 
-// The following two functions are needed to circumvent a bug in
-// gcc 2.95.3, which sometimes has problem with the above template
-// function.
+// The following two functions are needed because a compiler doesn't have
+// a context yet to know which template function must be instantiated.
 bool PredFunction%(n)sInt(%(int_vs)s) {
 return %(v_sum)s > 0;
 }
",532,21
"Fix FlatTuple compilation on older msvc.

googletest 1.10.0 fails to compile on msvc version 19.00.23917
with one compilation error:

src\googletest\include\gtest\internal\gtest-internal.h(1188) : error C2039:
'FlatTupleBase<testing::internal::FlatTuple<bool,bool>,testing::internal::IndexSequence<0,1> >':
is not a member of 'testing::internal::FlatTuple<bool,bool>'

This PR fixes the compilation error by explicitly specifying the full type that Indices is
located in the base type."," struct FlatTupleBase<FlatTuple<T...>, IndexSequence<Idx...>>
 
 // Analog to std::tuple but with different tradeoffs.
 // This class minimizes the template instantiation depth, thus allowing more
-// elements that std::tuple would. std::tuple has been seen to require an
+// elements than std::tuple would. std::tuple has been seen to require an
 // instantiation depth of more than 10x the number of elements in some
 // implementations.
 // FlatTuple and ElemFromList are not recursive and have a fixed depth
 template <typename... T>
 class FlatTuple
 : private FlatTupleBase<FlatTuple<T...>,
 typename MakeIndexSequence<sizeof...(T)>::type> {
- using Indices = typename FlatTuple::FlatTupleBase::Indices;
+
+ using Indices = typename FlatTupleBase<FlatTuple<T...>,
+ typename MakeIndexSequence<sizeof...(T)>::type>::Indices;
 
 public:
 FlatTuple() = default;
",629,92
"Fix internal memory leak in Windows _Crt report.

We use ""MemoryIsNotDeallocated"" to aovid internal expected leak reported
in Windows _Crt report, like:

 {
 #ifdef _MSC_VER
 	MemoryIsNotDeallocated memory_is_not_deeallocated;
 #endif

 	static ThreadIdToThreadLocals* map = new
	ThreadIdToThreadLocals();
	return map;
 }

But int the above code, only ""new ThreadIdToThreadLocals()"" is
protected, if we invoke ""insert()"" function of the return value,
the memory allocated in ""insert()"" will be reported to _Crt report
also. This change try to fix this issue."," class ThreadLocalRegistryImpl {
 // Returns a value that can be used to identify the thread from other threads.
 static ThreadLocalValueHolderBase* GetValueOnCurrentThread(
 const ThreadLocalBase* thread_local_instance) {
+#ifdef _MSC_VER
+ MemoryIsNotDeallocated memory_is_not_deallocated;
+#endif // _MSC_VER
 DWORD current_thread = ::GetCurrentThreadId();
 MutexLock lock(&mutex_);
 ThreadIdToThreadLocals* const thread_to_thread_locals =
",879,219
"Googletest export

Update stale comments to point to proper location.

PiperOrigin-RevId: 281157036"," struct AdlTag {};
 // InvokeArgumentAdl - a helper for InvokeArgument.
 // The basic overloads are provided here for generic functors.
 // Overloads for other custom-callables are provided in the
-// internal/custom/callback-actions.h header.
+// internal/custom/gmock-generated-actions.h header.
 
 template <typename R, typename F>
 R InvokeArgumentAdl(AdlTag, F f) {
",310,44
"Fix compile break for Microsoft Visual Studio 2017 v141

This is a workaround, for those who have to compile with v141 build tools,
for a bug in msvc that the compiler can't compile the WithArgsAction.

see the following link for more details:
https://developercommunityapi.westus.cloudapp.azure.com/content/problem/420339/googlemocks-withargs-doesnt-compile-with-permissiv.html"," struct WithArgsAction {
 // We use the conversion operator to detect the signature of the inner Action.
 template <typename R, typename... Args>
 operator Action<R(Args...)>() const { // NOLINT
- Action<R(typename std::tuple_element<I, std::tuple<Args...>>::type...)>
+ using TupleType = std::tuple<Args...>;
+ Action<R(typename std::tuple_element<I, TupleType>::type...)>
 converted(action);
 
 return [converted](Args... args) -> R {
",611,106
remove g++ 3.3 workaround: using on operator<<," void DefaultPrintNonContainerTo(const T& value, ::std::ostream* os) {
 // 7.3.4-1 [namespace.udir]. This allows us to fall back onto
 // testing::internal2::operator<< in case T doesn't come with a <<
 // operator.
- //
- // We cannot write 'using ::testing::internal2::operator<<;', which
- // gcc 3.3 fails to compile due to a compiler bug.
- using namespace ::testing::internal2; // NOLINT
+
+ using ::testing::internal2::operator<<;
 
 // Assuming T is defined in namespace foo, in the next statement,
 // the compiler will consider all of:
",449,75
remove MSVC workaround: error C2665," TEST(ElementsAreTest, AcceptsStringLiteral) {
 EXPECT_THAT(array, Not(ElementsAre(""hi"", ""one"", ""too"")));
 }
 
-#ifndef _MSC_VER
-
-// The following test passes a value of type const char[] to a
-// function template that expects const T&. Some versions of MSVC
-// generates a compiler error C2665 for that. We believe it's a bug
-// in MSVC. Therefore this test is #if-ed out for MSVC.
-
 // Declared here with the size unknown. Defined AFTER the following test.
 extern const char kHi[];
 
 TEST(ElementsAreTest, AcceptsArrayWithUnknownSize) {
 
 const char kHi[] = ""hi"";
 
-#endif // _MSC_VER
-
 TEST(ElementsAreTest, MakesCopyOfArguments) {
 int x = 1;
 int y = 2;
",947,139
remove MSVC workaround: warning 4355," class ReferenceOrValueWrapper<T&> {
 T* value_ptr_;
 };
 
-// MSVC warns about using 'this' in base member initializer list, so
-// we need to temporarily disable the warning. We have to do it for
-// the entire class to suppress the warning, even though it's about
-// the constructor only.
-GTEST_DISABLE_MSC_WARNINGS_PUSH_(4355)
-
 // C++ treats the void type specially. For example, you cannot define
 // a void-typed variable or pass a void value to a function.
 // ActionResultHolder<T> holds a value of type T, where T must be a
 class FunctionMocker<R(Args...)> final : public UntypedFunctionMockerBase {
 }
 }; // class FunctionMocker
 
-GTEST_DISABLE_MSC_WARNINGS_POP_() // 4355
-
 // Reports an uninteresting call (whose description is in msg) in the
 // manner specified by 'reaction'.
 void ReportUninterestingCall(CallReaction reaction, const std::string& msg);
",987,156
consistency fix for SafeMatcherCastImpl member functions," class SafeMatcherCastImpl {
 // monomorphic matchers are handled by the next one.
 template <typename M>
 static inline Matcher<T> Cast(const M& polymorphic_matcher_or_value) {
- return internal::MatcherCastImpl<T, M>::Cast(polymorphic_matcher_or_value);
+ return MatcherCast<T>(polymorphic_matcher_or_value);
 }
 
 // This overload handles monomorphic matchers.
",2924,557
remove MSVC workaround: wmain link error in the static library," void loop() { RUN_ALL_TESTS(); }
 #endif
 
 #else
-
-// MS C++ compiler/linker has a bug on Windows (not on Windows CE), which
-// causes a link error when _tmain is defined in a static library and UNICODE
-// is enabled. For this reason instead of _tmain, main function is used on
-// Windows. See the following link to track the current status of this bug:
-// https://web.archive.org/web/20170912203238/connect.microsoft.com/VisualStudio/feedback/details/394464/wmain-link-error-in-the-static-library
-// // NOLINT
-#if GTEST_OS_WINDOWS_MOBILE
+#if __MSC_VER
 # include <tchar.h> // NOLINT
 
 GTEST_API_ int _tmain(int argc, TCHAR** argv) {
 #else
 GTEST_API_ int main(int argc, char** argv) {
-#endif // GTEST_OS_WINDOWS_MOBILE
+#endif // __MSC_VER
 std::cout << ""Running main() from gmock_main.cc\n"";
 // Since Google Mock depends on Google Test, InitGoogleMock() is
 // also responsible for initializing Google Test. Therefore there's
",16,2
unify googletest and googlemock main functions," GTEST_API_ int _tmain(int argc, TCHAR** argv) {
 #else
 GTEST_API_ int main(int argc, char** argv) {
 #endif // __MSC_VER
- std::cout << ""Running main() from gmock_main.cc\n"";
+ std::cout << ""Running main() from "" << __FILE__ << '\n';
 // Since Google Mock depends on Google Test, InitGoogleMock() is
 // also responsible for initializing Google Test. Therefore there's
 // no need for calling testing::InitGoogleTest() separately.
",16,2
"Googletest export

Use standard C++11 integer types in gtest-port.h.

Remove testing::internal::{Int,Uint}{32,64} in favor of types
guaranteed to be in <cstdint> since C++11.

Tests for built-in integer type coverage are switched from
{Int,Uint}64 to [unsigned] long long, which is guaranteed by
C++11 to exist and be at least 64-bit wide.

PiperOrigin-RevId: 281565263"," GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(unsigned int, 0U);
 GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(signed int, 0);
 GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(unsigned long, 0UL); // NOLINT
 GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(signed long, 0L); // NOLINT
-GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(UInt64, 0);
-GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(Int64, 0);
+GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(unsigned long long, 0); // NOLINT
+GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(signed long long, 0); // NOLINT
 GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(float, 0);
 GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(double, 0);
 
",610,106
"Googletest export

Make generating goldens work with Python 3

golden_file.write(output) fails with Python 3 with:
TypeError: a bytes-like object is required, not 'str'
PiperOrigin-RevId: 282316101"," if __name__ == '__main__':
 if CAN_GENERATE_GOLDEN_FILE:
 output = GetOutputOfAllCommands()
 golden_file = open(GOLDEN_PATH, 'wb')
- golden_file.write(output)
+ golden_file.write(output.encode())
 golden_file.close()
 else:
 message = (
",169,22
"Googletest export

Wrap call to std::numeric_limits<>::max into round braces to appease MSVC.

Closes #2589

PiperOrigin-RevId: 282581361"," GTEST_DISABLE_MSC_DEPRECATED_POP_()
 using BiggestInt = long long; // NOLINT
 
 // The maximum number a BiggestInt can represent.
-constexpr BiggestInt kMaxBiggestInt = std::numeric_limits<BiggestInt>::max();
+constexpr BiggestInt kMaxBiggestInt = (std::numeric_limits<BiggestInt>::max)();
 
 // This template class serves as a compile-time function from size to
 // type. It maps a size in bytes to a primitive type with that
",644,158
"Revert ""unify googletest and googlemock main functions""

This reverts commit a909becdc599c46bcb57346b6123cb57cd07d15d."," GTEST_API_ int _tmain(int argc, TCHAR** argv) {
 #else
 GTEST_API_ int main(int argc, char** argv) {
 #endif // __MSC_VER
- std::cout << ""Running main() from "" << __FILE__ << '\n';
+ std::cout << ""Running main() from gmock_main.cc\n"";
 // Since Google Mock depends on Google Test, InitGoogleMock() is
 // also responsible for initializing Google Test. Therefore there's
 // no need for calling testing::InitGoogleTest() separately.
",16,2
"Revert ""remove MSVC workaround: wmain link error in the static library""

This reverts commit 298a40f023e6813d2bf73847c3a38ceaf5e46320."," void loop() { RUN_ALL_TESTS(); }
 #endif
 
 #else
-#if __MSC_VER
+
+// MS C++ compiler/linker has a bug on Windows (not on Windows CE), which
+// causes a link error when _tmain is defined in a static library and UNICODE
+// is enabled. For this reason instead of _tmain, main function is used on
+// Windows. See the following link to track the current status of this bug:
+// https://web.archive.org/web/20170912203238/connect.microsoft.com/VisualStudio/feedback/details/394464/wmain-link-error-in-the-static-library
+// // NOLINT
+#if GTEST_OS_WINDOWS_MOBILE
 # include <tchar.h> // NOLINT
 
 GTEST_API_ int _tmain(int argc, TCHAR** argv) {
 #else
 GTEST_API_ int main(int argc, char** argv) {
-#endif // __MSC_VER
+#endif // GTEST_OS_WINDOWS_MOBILE
 std::cout << ""Running main() from gmock_main.cc\n"";
 // Since Google Mock depends on Google Test, InitGoogleMock() is
 // also responsible for initializing Google Test. Therefore there's
",16,2
"Googletest export

Internal change

PiperOrigin-RevId: 283948137","
 # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
-""""""Tests the text output of Google C++ Testing and Mocking Framework.
+r""""""Tests the text output of Google C++ Testing and Mocking Framework.
 
 To update the golden file:
 googletest_output_test.py --build_dir=BUILD/DIR --gengolden
",169,22
"Googletest export

Change googletest to notice failures during SetUpTestSuite() and TearDownTestSuite().

Previously, errors that occurred during those functions were logged but otherwise ignored. After this change, such failures will cause the test to fail and a brief summary will be printed at the bottom of the test log.

See https://github.com/google/googletest/issues/2330.

PiperOrigin-RevId: 284033342"," TEST(SkipPrefixTest, DoesNotSkipWhenPrefixDoesNotMatch) {
 }
 
 // Tests ad_hoc_test_result().
-
-class AdHocTestResultTest : public testing::Test {
- protected:
- static void SetUpTestSuite() {
- FAIL() << ""A failure happened inside SetUpTestSuite()."";
- }
-};
-
-TEST_F(AdHocTestResultTest, AdHocTestResultForTestSuiteShowsFailure) {
- const testing::TestResult& test_result = testing::UnitTest::GetInstance()
- ->current_test_suite()
- ->ad_hoc_test_result();
- EXPECT_TRUE(test_result.Failed());
-}
-
-TEST_F(AdHocTestResultTest, AdHocTestResultTestForUnitTestDoesNotShowFailure) {
+TEST(AdHocTestResultTest, AdHocTestResultForUnitTestDoesNotShowFailure) {
 const testing::TestResult& test_result =
 testing::UnitTest::GetInstance()->ad_hoc_test_result();
 EXPECT_FALSE(test_result.Failed());
",4938,714
"Googletest export

Detect when C++ parametric tests (TEST_P) are not instantiated.

When an un-instantiated TEST_P is found, a new test will be inserted that will emit a warning message.

This can be made to error with minor code edits.
In the future, that is intended to be the default.

PiperOrigin-RevId: 284901666"," INSTANTIATE_TEST_SUITE_P(PrintingStrings,
 testing::Values(std::string(""a"")),
 ParamNameFunc);
 
+// fails under kErrorOnUninstantiatedParameterizedTest=true
+class DetectNotInstantiatedTest : public testing::TestWithParam<int> {};
+TEST_P(DetectNotInstantiatedTest, Used) { }
+
+// This would make the test failure from the above go away.
+// INSTANTIATE_TEST_SUITE_P(Fix, DetectNotInstantiatedTest, testing::Values(1));
+
 // This #ifdef block tests the output of typed tests.
 #if GTEST_HAS_TYPED_TEST
 
",671,132
"Googletest export

Add GTEST_API_ to correct a build failure under MSCV.

PiperOrigin-RevId: 285208464"," class ParameterizedTestSuiteInfoBase {
 GTEST_DISALLOW_COPY_AND_ASSIGN_(ParameterizedTestSuiteInfoBase);
 };
 
-void InsertSyntheticTestCase(const std::string &name, CodeLocation location);
+GTEST_API_ void InsertSyntheticTestCase(const std::string& name,
+ CodeLocation location);
 
 // INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.
 //
",568,112
"Workaround VS bug w.r.t empty arguments to macros

Empty arguments can be passed to macros per C99 and C++11 specs, which
can then be forwarded to other macros.

Visual Studio's compiler has a bug in the following situation:

 #define A(x) #x
 #define B(x, y) A(x)
 B(, b)

In the above case, Visual Studio first expands x to nothing, then
complains that A is not invoked with the right amount of arguments.
However, x in A(x) is still one argument, even if it expands to no
preprocessing tokens. See also https://stackoverflow.com/a/7674214.","
 #define GTEST_CONCAT_TOKEN_IMPL_(foo, bar) foo ## bar
 
 // Stringifies its argument.
-#define GTEST_STRINGIFY_(name) #name
+// Work around a bug in visual studio which doesn't accept code like this:
+//
+// #define GTEST_STRINGIFY_(name) #name
+// #define MACRO(a, b, c) ... GTEST_STRINGIFY_(a) ...
+// MACRO(, x, y)
+//
+// Complaining about the argument to GTEST_STRINGIFY_ being empty.
+// This is allowed by the spec.
+#define GTEST_STRINGIFY_HELPER_(name, ...) #name
+#define GTEST_STRINGIFY_(...) GTEST_STRINGIFY_HELPER_(__VA_ARGS__,)
 
 namespace proto2 { class Message; }
 
",630,92
"Revert ""Googletest export"": Remove test for empty prefix

This reverts commit 4c25e2b87fcb78abcfdee2739db9ed7a19754cd3.
Reason for revert: Reverting the commit that disallows empty prefixes.

Original commit message:

 Remove a test case rendered obsolete by disallowing empty argument for INSTANTIATE_TEST_SUITE_P.
 Remove the code that it was testing."," class ParameterizedTestSuiteInfo : public ParameterizedTestSuiteInfoBase {
 
 test_param_names.insert(param_name);
 
- test_name_stream << test_info->test_base_name << ""/"" << param_name;
+ if (!test_info->test_base_name.empty()) {
+ test_name_stream << test_info->test_base_name << ""/"";
+ }
+ test_name_stream << param_name;
 MakeAndRegisterTestInfo(
 test_suite_name.c_str(), test_name_stream.GetString().c_str(),
 nullptr, // No type parameter.
",571,113
"Disable move constructor and assignment operator for test classes.

Disable move operations for TEST() and TEST_F() macros.
Previous implementation disabled only copy ctor and assing operator, but
this was violating rule of 5[1], which was captured by static code analysis tools
like clang-tidy `cppcoreguidelines-special-member-functions`.

[1]: https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#c21-if-you-define-or-delete-any-default-operation-define-or-delete-them-all"," constexpr bool InstantiateTypedTestCase_P_IsDeprecated() { return true; }
 static ::testing::TestInfo* const test_info_ GTEST_ATTRIBUTE_UNUSED_; \
 GTEST_DISALLOW_COPY_AND_ASSIGN_(GTEST_TEST_CLASS_NAME_(test_suite_name, \
 test_name)); \
+ GTEST_DISALLOW_MOVE_AND_ASSIGN_(GTEST_TEST_CLASS_NAME_(test_suite_name, \
+ test_name)); \
 }; \
 \
 ::testing::TestInfo* const GTEST_TEST_CLASS_NAME_(test_suite_name, \
",630,92
Review notes: Return T& from assignment operators," typedef struct _RTL_CRITICAL_SECTION GTEST_CRITICAL_SECTION;
 // A macro to disallow copy operator=
 // This should be used in the private: declarations for a class.
 #define GTEST_DISALLOW_ASSIGN_(type) \
- void operator=(type const &) = delete
+ type& operator=(type const &) = delete
 
 // A macro to disallow copy constructor and operator=
 // This should be used in the private: declarations for a class.
 typedef struct _RTL_CRITICAL_SECTION GTEST_CRITICAL_SECTION;
 // A macro to disallow move operator=
 // This should be used in the private: declarations for a class.
 #define GTEST_DISALLOW_MOVE_ASSIGN_(type) \
- void operator=(type &&) = delete
+ type& operator=(type &&) = delete
 
 // A macro to disallow move constructor and operator=
 // This should be used in the private: declarations for a class.
",644,158
Deleted functions as part of public interface," constexpr bool InstantiateTypedTestCase_P_IsDeprecated() { return true; }
 : public parent_class { \
 public: \
 GTEST_TEST_CLASS_NAME_(test_suite_name, test_name)() {} \
- \
- private: \
- void TestBody() override; \
- static ::testing::TestInfo* const test_info_ GTEST_ATTRIBUTE_UNUSED_; \
 GTEST_DISALLOW_COPY_AND_ASSIGN_(GTEST_TEST_CLASS_NAME_(test_suite_name, \
 test_name)); \
 GTEST_DISALLOW_MOVE_AND_ASSIGN_(GTEST_TEST_CLASS_NAME_(test_suite_name, \
 test_name)); \
+ \
+ private: \
+ void TestBody() override; \
+ static ::testing::TestInfo* const test_info_ GTEST_ATTRIBUTE_UNUSED_; \
 }; \
 \
 ::testing::TestInfo* const GTEST_TEST_CLASS_NAME_(test_suite_name, \
",630,92
Define default destructor for test classes," constexpr bool InstantiateTypedTestCase_P_IsDeprecated() { return true; }
 : public parent_class { \
 public: \
 GTEST_TEST_CLASS_NAME_(test_suite_name, test_name)() {} \
+ ~GTEST_TEST_CLASS_NAME_(test_suite_name, test_name)() = default; \
 GTEST_DISALLOW_COPY_AND_ASSIGN_(GTEST_TEST_CLASS_NAME_(test_suite_name, \
 test_name)); \
 GTEST_DISALLOW_MOVE_AND_ASSIGN_(GTEST_TEST_CLASS_NAME_(test_suite_name, \
",630,92
Make move operation noexcept.," typedef struct _RTL_CRITICAL_SECTION GTEST_CRITICAL_SECTION;
 // A macro to disallow move operator=
 // This should be used in the private: declarations for a class.
 #define GTEST_DISALLOW_MOVE_ASSIGN_(type) \
- type& operator=(type &&) = delete
+ type& operator=(type &&) noexcept = delete
 
 // A macro to disallow move constructor and operator=
 // This should be used in the private: declarations for a class.
 #define GTEST_DISALLOW_MOVE_AND_ASSIGN_(type) \
- type(type &&) = delete; \
+ type(type &&) noexcept = delete; \
 GTEST_DISALLOW_MOVE_ASSIGN_(type)
 
 // Tell the compiler to warn about unused return values for functions declared
",644,158
"Googletest export

Use C++11 variadic templates for InvokeArgumentAdl in gmock-generated-actions.h.

Make InvokeArgumentAdl use variadic templates to generate its overloads instead
of using pump.py syntax.

PiperOrigin-RevId: 286148805"," class ActionHelper {
 }
 };
 
+namespace invoke_argument {
+
+// Appears in InvokeArgumentAdl's argument list to help avoid
+// accidental calls to user functions of the same name.
+struct AdlTag {};
+
+// InvokeArgumentAdl - a helper for InvokeArgument.
+// The basic overloads are provided here for generic functors.
+// Overloads for other custom-callables are provided in the
+// internal/custom/gmock-generated-actions.h header.
+
+template <typename R, typename F, typename... Args>
+R InvokeArgumentAdl(AdlTag, F f, Args&&... args) {
+ return f(std::forward<Args>(args)...);
+}
+
+} // namespace invoke_argument
 } // namespace internal
 
 } // namespace testing
",638,109
"Googletest export

Use C++11 variadic templates for InvokeArgumentAdl in gmock-generated-actions.h.

Make InvokeArgumentAdl use variadic templates to generate its overloads instead
of using pump.py syntax.

PiperOrigin-RevId: 286267615"," class ActionHelper {
 }
 };
 
-namespace invoke_argument {
-
-// Appears in InvokeArgumentAdl's argument list to help avoid
-// accidental calls to user functions of the same name.
-struct AdlTag {};
-
-// InvokeArgumentAdl - a helper for InvokeArgument.
-// The basic overloads are provided here for generic functors.
-// Overloads for other custom-callables are provided in the
-// internal/custom/gmock-generated-actions.h header.
-
-template <typename R, typename F, typename... Args>
-R InvokeArgumentAdl(AdlTag, F f, Args&&... args) {
- return f(std::forward<Args>(args)...);
-}
-
-} // namespace invoke_argument
 } // namespace internal
 
 } // namespace testing
",631,108
"Googletest export

Add option (default to disabled) to make C++ type parameterized tests (TYPED_TEST_P) fail when they're not instantiated.

When an un-instantiated TYPED_TEST_P is found, a new test will be inserted that emits a suitable message. For now, that is just a notice, but the hope it to flip the bit to make it fail by default.

PiperOrigin-RevId: 286408038"," INSTANTIATE_TYPED_TEST_SUITE_P(My, FooTest, MyTypes);
 static const char* const GTEST_REGISTERED_TEST_NAMES_( \
 SuiteName) GTEST_ATTRIBUTE_UNUSED_ = \
 GTEST_TYPED_TEST_SUITE_P_STATE_(SuiteName).VerifyRegisteredTestNames( \
- __FILE__, __LINE__, #__VA_ARGS__)
+ GTEST_STRINGIFY_(SuiteName), __FILE__, __LINE__, #__VA_ARGS__)
 
 // Legacy API is deprecated but still available
 #ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_
",35,4
"Googletest export

Explicitly default copy constructor in BoundSecondMatcher

Since C++11, implicit defaulting of copy constructors is deprecated for types
with user-defined copy assignment operators, so we should explicitly default the
copy constructor of BoundSecondMatcher.

PiperOrigin-RevId: 287587847"," class BoundSecondMatcher {
 BoundSecondMatcher(const Tuple2Matcher& tm, const Second& second)
 : tuple2_matcher_(tm), second_value_(second) {}
 
+ BoundSecondMatcher(const BoundSecondMatcher& other) = default;
+
 template <typename T>
 operator Matcher<T>() const {
 return MakeMatcher(new Impl<T>(tuple2_matcher_, second_value_));
",2913,556
"Googletest export

Use C++11 variadic templates for Invoke in gmock-generated-actions.h.

Replace InvokeArgumentAdl with Invoke that uses C++11 variadic templates.

PiperOrigin-RevId: 288449236"," class ActionHelper {
 }
 };
 
+namespace invoke_argument {
+
+// Appears in InvokeArgumentAdl's argument list to help avoid
+// accidental calls to user functions of the same name.
+struct AdlTag {};
+
+// InvokeArgumentAdl - a helper for InvokeArgument.
+// The basic overloads are provided here for generic functors.
+// Overloads for other custom-callables are provided in the
+// internal/custom/gmock-generated-actions.h header.
+template <typename F, typename... Args>
+auto InvokeArgumentAdl(AdlTag, F f, Args... args) -> decltype(f(args...)) {
+ return f(args...);
+}
+
+} // namespace invoke_argument
 } // namespace internal
 
 } // namespace testing
",638,109
"Googletest export

Close #2658
Mark test case destrucors as override.

PiperOrigin-RevId: 288507991"," constexpr bool InstantiateTypedTestCase_P_IsDeprecated() { return true; }
 : public parent_class { \
 public: \
 GTEST_TEST_CLASS_NAME_(test_suite_name, test_name)() {} \
- ~GTEST_TEST_CLASS_NAME_(test_suite_name, test_name)() = default; \
+ ~GTEST_TEST_CLASS_NAME_(test_suite_name, test_name)() override = default; \
 GTEST_DISALLOW_COPY_AND_ASSIGN_(GTEST_TEST_CLASS_NAME_(test_suite_name, \
 test_name)); \
 GTEST_DISALLOW_MOVE_AND_ASSIGN_(GTEST_TEST_CLASS_NAME_(test_suite_name, \
",636,92
"Googletest export

Removing GTEST_API from TrueWithString.
This type is only used in test code on one side of a DLL boundary so it is not
necessary.

PiperOrigin-RevId: 288927929"," struct GTEST_API_ ConstCharPtr {
 
 // Helper for declaring std::string within 'if' statement
 // in pre C++17 build environment.
-struct GTEST_API_ TrueWithString {
+struct TrueWithString {
 TrueWithString() = default;
 explicit TrueWithString(const char* str) : value(str) {}
 explicit TrueWithString(const std::string& str) : value(str) {}
",636,92
fix unit test failure on NoShortCircuitOnFailure and DetectsFlakyShortCircuit when GTEST_HAS_RTTI is 1," TEST_F(PredicateFormatterFromMatcherTest, NoShortCircuitOnFailure) {
 EXPECT_FALSE(result); // Implicit cast to bool.
 std::string expect =
 ""Value of: dummy-name\nExpected: [DescribeTo]\n""
- "" Actual: 1, [MatchAndExplain]"";
+ "" Actual: 1"" + OfType(internal::GetTypeName<Behavior>()) + "", [MatchAndExplain]"";
 EXPECT_EQ(expect, result.message());
 }
 
 TEST_F(PredicateFormatterFromMatcherTest, DetectsFlakyShortCircuit) {
 ""Value of: dummy-name\nExpected: [DescribeTo]\n""
 "" The matcher failed on the initial attempt; but passed when rerun to ""
 ""generate the explanation.\n""
- "" Actual: 2, [MatchAndExplain]"";
+ "" Actual: 2"" + OfType(internal::GetTypeName<Behavior>()) + "", [MatchAndExplain]"";
 EXPECT_EQ(expect, result.message());
 }
 
",5130,716
Use IsReadableTypeName IsReadableTypeName in OfType function in gmock-matchers_test.cc," Matcher<int> GreaterThan(int n) {
 
 std::string OfType(const std::string& type_name) {
 #if GTEST_HAS_RTTI
- return "" (of type "" + type_name + "")"";
+ return IsReadableTypeName(type_name) ? "" (of type "" + type_name + "")"" : """";
 #else
 return """";
 #endif
",5130,717
"Googletest export

Change testing::TempDir() return value for Android

PiperOrigin-RevId: 289102017"," std::string TempDir() {
 else
 return std::string(temp_dir) + ""\\"";
 #elif GTEST_OS_LINUX_ANDROID
- return ""/sdcard/"";
+ const char* temp_dir = internal::posix::GetEnv(""TEST_TMPDIR"");
+ if (temp_dir == nullptr || temp_dir[0] == '\0')
+ return ""/data/local/tmp/"";
+ else
+ return temp_dir;
 #else
 return ""/tmp/"";
 #endif // GTEST_OS_WINDOWS_MOBILE
",3982,959
"Googletest export

Add GTEST_ALLOW_UNINSTANTIATED_PARAMTERIZED_TEST to mark a paramaterized test as allowed to be un-instantiated.

This allows test suites, that are defined in libraries and, for other reasons, get linked in (which should probably be avoided, but isn't always possible) to be marked as allowed to go uninstantiated.

This can also be used to grandfather existing issues and expedite adoption of the checks with regards to new cases before they can be fixed.

PiperOrigin-RevId: 289581573"," internal::CartesianProductHolder<Generator...> Combine(const Generator&... g) {
 &gtest_##prefix##test_suite_name##_EvalGenerateName_, \
 __FILE__, __LINE__)
 
+
+// Allow Marking a Parameterized test class as not needing to be instantiated.
+#define GTEST_ALLOW_UNINSTANTIATED_PARAMTERIZED_TEST(T) \
+ namespace gtest_do_not_use_outside_namespace_scope {} \
+ static const ::testing::internal::MarkAsIgnored gtest_allow_ignore_##T( \
+ GTEST_STRINGIFY_(T))
+
 // Legacy API is deprecated but still available
 #ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_
 #define INSTANTIATE_TEST_CASE_P \
",67,12
"Googletest export

Use GMOCK_PP to generate args boilerplate.

Move common args describing part to separate macroses that uses GMOCK_PP to
generate sequences.

PiperOrigin-RevId: 289655624","
 
 #include ""gmock/internal/gmock-internal-utils.h""
 #include ""gmock/internal/gmock-port.h""
+#include ""gmock/internal/gmock-pp.h""
 
 #ifdef _MSC_VER
 # pragma warning(push)
 auto InvokeArgumentAdl(AdlTag, F f, Args... args) -> decltype(f(args...)) {
 }
 
 } // namespace invoke_argument
+
+#define GMOCK_INTERNAL_ARG_UNUSED(N, data, el) \
+ , const arg##N##_type& arg##N GTEST_ATTRIBUTE_UNUSED_
+#define GMOCK_ACTION_ARG_TYPES_AND_NAMES_UNUSED_ \
+ const args_type& args GTEST_ATTRIBUTE_UNUSED_ GMOCK_PP_REPEAT( \
+ GMOCK_INTERNAL_ARG_UNUSED, , 10)
+
+#define GMOCK_INTERNAL_ARG(N, data, el) , const arg##N##_type& arg##N
+#define GMOCK_ACTION_ARG_TYPES_AND_NAMES_ \
+ const args_type& args GMOCK_PP_REPEAT(GMOCK_INTERNAL_ARG, , 10)
+
+#define GMOCK_INTERNAL_TEMPLATE_ARG(N, data, el) , typename arg##N##_type
+#define GMOCK_ACTION_TEMPLATE_ARGS_NAMES_ \
+ GMOCK_PP_TAIL(GMOCK_PP_REPEAT(GMOCK_INTERNAL_TEMPLATE_ARG, , 10))
+
 } // namespace internal
 
 } // namespace testing
",665,113
"Googletest export

Wire up things to support marking a type paramaterized test as allowed to be un-instantiated.

PiperOrigin-RevId: 289699939"," TEST_P(NotInstantiatedTest, Used) { }
 using OtherName = NotInstantiatedTest;
 GTEST_ALLOW_UNINSTANTIATED_PARAMTERIZED_TEST(OtherName);
 TEST_P(OtherName, Used) { }
+
+// Used but not instantiated, this would fail. but...
+template <typename T>
+class NotInstantiatedTypeTest : public testing::Test {};
+TYPED_TEST_SUITE_P(NotInstantiatedTypeTest);
+// ... we mark is as allowed.
+GTEST_ALLOW_UNINSTANTIATED_PARAMTERIZED_TEST(NotInstantiatedTypeTest);
+
+TYPED_TEST_P(NotInstantiatedTypeTest, Used) { }
+REGISTER_TYPED_TEST_SUITE_P(NotInstantiatedTypeTest, Used);
 } // namespace works_here
 
 int main(int argc, char **argv) {
",734,112
"Googletest export

Correct the spelling of PARAMETERIZED.

PiperOrigin-RevId: 289897278"," internal::CartesianProductHolder<Generator...> Combine(const Generator&... g) {
 
 
 // Allow Marking a Parameterized test class as not needing to be instantiated.
-#define GTEST_ALLOW_UNINSTANTIATED_PARAMTERIZED_TEST(T) \
+#define GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(T) \
 namespace gtest_do_not_use_outside_namespace_scope {} \
 static const ::testing::internal::MarkAsIgnored gtest_allow_ignore_##T( \
 GTEST_STRINGIFY_(T))
",67,12
"Googletest export

Add extra filtering so that the reported message differentiates between the case where INSTANTIATE_TEST_SUITE_P is missing vs. the case where TEST_P is missing.

PiperOrigin-RevId: 290114508"," struct MarkAsIgnored {
 };
 
 GTEST_API_ void InsertSyntheticTestCase(const std::string& name,
- CodeLocation location);
+ CodeLocation location, bool has_test_p);
 
 // INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.
 //
 class ParameterizedTestSuiteInfo : public ParameterizedTestSuiteInfoBase {
 
 if (!generated_instantiations) {
 // There are no generaotrs, or they all generate nothing ...
- InsertSyntheticTestCase(GetTestSuiteName(), code_location_);
+ InsertSyntheticTestCase(GetTestSuiteName(), code_location_,
+ !tests_.empty());
 }
 } // RegisterTests
 
",590,114
"Googletest export

Allow copying of the string in MatchAndExplain.

Otherwise, conversions from std::string_view to std::string will fail as being
explicit

PiperOrigin-RevId: 290301103"," class StrEqualityMatcher {
 template <typename MatcheeStringType>
 bool MatchAndExplain(const MatcheeStringType& s,
 MatchResultListener* /* listener */) const {
- const StringType& s2(s);
+ const StringType s2(s);
 const bool eq = case_sensitive_ ? s2 == string_ :
 CaseInsensitiveStringEquals(s2, string_);
 return expect_eq_ == eq;
",2913,556
"Googletest export

Add missing explicit keyword for gmock_Impl constructor.

When switching to using GMOCK_PP in ACTION* macroses `explicit` keyword was
missed in gmock_Impl constructor causing ClangTidy warnings in ACTION_P macro.

PiperOrigin-RevId: 291159975"," auto InvokeArgumentAdl(AdlTag, F f, Args... args) -> decltype(f(args...)) {
 typedef typename ::testing::internal::Function<F>::Result return_type; \
 typedef \
 typename ::testing::internal::Function<F>::ArgumentTuple args_type; \
- gmock_Impl(GMOCK_ACTION_TYPE_GVALUE_PARAMS_(params)) \
+ explicit gmock_Impl(GMOCK_ACTION_TYPE_GVALUE_PARAMS_(params)) \
 : GMOCK_ACTION_INIT_PARAMS_(params) {} \
 return_type Perform(const args_type& args) override { \
 return ::testing::internal::ActionHelper<return_type, \
",665,113
"Googletest export

Adds missing `#define` guard around `TEST_F(...)`

PiperOrigin-RevId: 291703056"," constexpr bool StaticAssertTypeEq() noexcept {
 // }
 //
 // GOOGLETEST_CM0011 DO NOT DELETE
+#if !GTEST_DONT_DEFINE_TEST
 #define TEST_F(test_fixture, test_name)\
 GTEST_TEST_(test_fixture, test_name, test_fixture, \
 ::testing::internal::GetTypeId<test_fixture>())
+#endif // !GTEST_DONT_DEFINE_TEST
 
 // Returns a path to temporary directory.
 // Tries to determine an appropriate directory for the platform.
",763,129
"Googletest export

Disable warning C4800 for Visual Studio 2019.

The compiler warning C4800 is disabled by default in Visual Studio 2019,
but it can be enabled on the command line. The only version of
Visual Studio that does not support warning C4800 is Visual Studio 2017.

PiperOrigin-RevId: 292624510"," class GTEST_API_ AssertionResult {
 // Used in EXPECT_TRUE/FALSE(assertion_result).
 AssertionResult(const AssertionResult& other);
 
-#if defined(_MSC_VER) && _MSC_VER < 1910
+// C4800 is a level 3 warning in Visual Studio 2015 and earlier.
+// This warning is not emitted in Visual Studio 2017.
+// This warning is off by default starting in Visual Studio 2019 but can be
+// enabled with command-line options.
+#if defined(_MSC_VER) && (_MSC_VER < 1910 || _MSC_VER >= 1920)
 GTEST_DISABLE_MSC_WARNINGS_PUSH_(4800 /* forcing value to bool */)
 #endif
 
 class GTEST_API_ AssertionResult {
 = nullptr)
 : success_(success) {}
 
-#if defined(_MSC_VER) && _MSC_VER < 1910
+#if defined(_MSC_VER) && (_MSC_VER < 1910 || _MSC_VER >= 1920)
 GTEST_DISABLE_MSC_WARNINGS_POP_()
 #endif
 
",763,129
"Googletest export

Fix std::move to std::forward where appropriate to support reference types.

PiperOrigin-RevId: 292923058"," class MatcherBaseImpl<Derived<Ts...>> {
 // conversions.
 template <typename E = std::enable_if<sizeof...(Ts) == 1>,
 typename E::type* = nullptr>
- explicit MatcherBaseImpl(Ts... params) : params_(std::move(params)...) {}
+ explicit MatcherBaseImpl(Ts... params)
+ : params_(std::forward<Ts>(params)...) {}
 template <typename E = std::enable_if<sizeof...(Ts) != 1>,
 typename = typename E::type>
- MatcherBaseImpl(Ts... params) : params_(std::move(params)...) {} // NOLINT
+ MatcherBaseImpl(Ts... params) // NOLINT
+ : params_(std::forward<Ts>(params)...) {}
 
 template <typename F>
 operator ::testing::Matcher<F>() const { // NOLINT(runtime/explicit)
",2947,561
"Googletest export

Get rid of gmock-generated-matchers.h and gmock-generated-matchers.h.pump.

Stop using pump for MATCHER* macroses generation.

PiperOrigin-RevId: 293878808","
 
 // Google Mock - a framework for writing C++ mock classes.
 //
-// This file implements some matchers that depend on gmock-generated-matchers.h.
+// This file implements some matchers that depend on gmock-matchers.h.
 //
 // Note that tests are implemented in gmock-matchers_test.cc rather than
 // gmock-more-matchers-test.cc.

 #ifndef GMOCK_INCLUDE_GMOCK_MORE_MATCHERS_H_
 #define GMOCK_INCLUDE_GMOCK_MORE_MATCHERS_H_
 
-#include ""gmock/gmock-generated-matchers.h""
+#include ""gmock/gmock-matchers.h""
 
 namespace testing {
 
",16,4
"Googletest export

Refactor function GetNextPrime so that the loop precondition is checked before
loop instead of during every loop run. Also by removing the loop condition,
it shows that the only exit from the loop is the return statement.

PiperOrigin-RevId: 293932783"," class OnTheFlyPrimeTable : public PrimeTable {
 }
 
 int GetNextPrime(int p) const override {
- for (int n = p + 1; n > 0; n++) {
+ if (p < 0) return -1;
+
+ for (int n = p + 1;; n++) {
 if (IsPrime(n)) return n;
 }
-
- return -1;
 }
 };
 
",54,21
"Googletest export

Add gmock Matcher<std::string_view> specialization.

PiperOrigin-RevId: 294443240"," TEST(PrintTypeWithGenericStreamingTest, TypeImplicitlyConvertible) {
 EXPECT_EQ(""AllowsGenericStreamingAndImplicitConversionTemplate"", Print(a));
 }
 
-#if GTEST_HAS_ABSL
+#if GTEST_INTERNAL_HAS_STRING_VIEW
 
-// Tests printing ::absl::string_view.
+// Tests printing internal::StringView.
 
 TEST(PrintStringViewTest, SimpleStringView) {
- const ::absl::string_view sp = ""Hello"";
+ const internal::StringView sp = ""Hello"";
 EXPECT_EQ(""\""Hello\"""", Print(sp));
 }
 
 TEST(PrintStringViewTest, UnprintableCharacters) {
 const char str[] = ""NUL (\0) and \r\t"";
- const ::absl::string_view sp(str, sizeof(str) - 1);
+ const internal::StringView sp(str, sizeof(str) - 1);
 EXPECT_EQ(""\""NUL (\\0) and \\r\\t\"""", Print(sp));
 }
 
-#endif // GTEST_HAS_ABSL
+#endif // GTEST_INTERNAL_HAS_STRING_VIEW
 
 // Tests printing STL containers.
 
",1080,179
Add correct line number to TEST_P test cases for gtest_output.," internal::CartesianProductHolder<Generator...> Combine(const Generator&... g) {
 ->AddTestPattern( \
 GTEST_STRINGIFY_(test_suite_name), GTEST_STRINGIFY_(test_name), \
 new ::testing::internal::TestMetaFactory<GTEST_TEST_CLASS_NAME_( \
- test_suite_name, test_name)>()); \
+ test_suite_name, test_name)>(), __LINE__); \
 return 0; \
 } \
 static int gtest_registering_dummy_ GTEST_ATTRIBUTE_UNUSED_; \
",67,12
"Add missing call for gtest_list_output_unittest_ unitTest.
Add unitTest for fixed TEST_P line number.
Use CodeLocation TestInfo struct."," internal::CartesianProductHolder<Generator...> Combine(const Generator&... g) {
 ->AddTestPattern( \
 GTEST_STRINGIFY_(test_suite_name), GTEST_STRINGIFY_(test_name), \
 new ::testing::internal::TestMetaFactory<GTEST_TEST_CLASS_NAME_( \
- test_suite_name, test_name)>(), __LINE__); \
+ test_suite_name, test_name)>(), \
+ ::testing::internal::CodeLocation(__FILE__, __LINE__)); \
 return 0; \
 } \
 static int gtest_registering_dummy_ GTEST_ATTRIBUTE_UNUSED_; \
",67,12
"Googletest export

Allow construction of an Action from a callable of zero args

Action already allows construction from a callable with the same args as the mocked function, without needing to wrap the callable in Invoke. However, if you don't care about the arguments to the mocked function you need to either accept all of them or wrap your callable in InvokeWithoutArgs. This change makes both of those unnecessary, since it allows you to pass a no-args callable to Action directly.

PiperOrigin-RevId: 296117034"," TEST(FunctorActionTest, TypeConversion) {
 EXPECT_EQ(1, s2.Perform(std::make_tuple(""hello"")));
 
 // Also between the lambda and the action itself.
- const Action<bool(std::string)> x = [](Unused) { return 42; };
- EXPECT_TRUE(x.Perform(std::make_tuple(""hello"")));
+ const Action<bool(std::string)> x1 = [](Unused) { return 42; };
+ const Action<bool(std::string)> x2 = [] { return 42; };
+ EXPECT_TRUE(x1.Perform(std::make_tuple(""hello"")));
+ EXPECT_TRUE(x2.Perform(std::make_tuple(""hello"")));
+
+ // Ensure decay occurs where required.
+ std::function<int()> f = [] { return 7; };
+ Action<int(int)> d = f;
+ f = nullptr;
+ EXPECT_EQ(7, d.Perform(std::make_tuple(1)));
+
+ // Ensure creation of an empty action succeeds.
+ Action<void(int)>(nullptr);
 }
 
 TEST(FunctorActionTest, UnusedArguments) {
",1012,155
"Googletest export

Relax the implementation of MatcherCast to allow conversion of `Matcher<T>` to
`Matcher<const T&>`. They have the same match signature.

PiperOrigin-RevId: 297115843"," TEST(SafeMatcherCastTest, FromConstReferenceToReference) {
 
 // Tests that MatcherCast<const T&>(m) works when m is a Matcher<T>.
 TEST(SafeMatcherCastTest, FromNonReferenceToConstReference) {
- Matcher<int> m1 = Eq(0);
- Matcher<const int&> m2 = SafeMatcherCast<const int&>(m1);
- EXPECT_TRUE(m2.Matches(0));
- EXPECT_FALSE(m2.Matches(1));
+ Matcher<std::unique_ptr<int>> m1 = IsNull();
+ Matcher<const std::unique_ptr<int>&> m2 =
+ SafeMatcherCast<const std::unique_ptr<int>&>(m1);
+ EXPECT_TRUE(m2.Matches(std::unique_ptr<int>()));
+ EXPECT_FALSE(m2.Matches(std::unique_ptr<int>(new int)));
 }
 
 // Tests that SafeMatcherCast<T&>(m) works when m is a Matcher<T>.
",5154,721
"Googletest export

Rename internal color enumerators to avoid conflicts with curses.h macro definitions.
Fixes #2685

PiperOrigin-RevId: 297639382"," class GTEST_API_ AssertHelper {
 GTEST_DISALLOW_COPY_AND_ASSIGN_(AssertHelper);
 };
 
-enum GTestColor { COLOR_DEFAULT, COLOR_RED, COLOR_GREEN, COLOR_YELLOW };
+enum class GTestColor { kDefault, kRed, kGreen, kYellow };
 
 GTEST_API_ GTEST_ATTRIBUTE_PRINTF_(2, 3) void ColoredPrintf(GTestColor color,
 const char* fmt,
",763,129
"Googletest export

Simplify the fallback printing logic to have a single sequence of trial printers.

PiperOrigin-RevId: 298621376"," void PrintBytesInObjectToImpl(const unsigned char* obj_bytes, size_t count,
 
 } // namespace
 
-namespace internal2 {
+namespace internal {
 
 // Delegates to PrintBytesInObjectToImpl() to print the bytes in the
 // given object. The delegation simplifies the implementation, which
 void PrintBytesInObjectTo(const unsigned char* obj_bytes, size_t count,
 PrintBytesInObjectToImpl(obj_bytes, count, os);
 }
 
-} // namespace internal2
-
-namespace internal {
-
 // Depending on the value of a char (or wchar_t), we print it in one
 // of three formats:
 // - as is if it's a printable ASCII (e.g. 'a', '2', ' '),
",274,90
"Googletest export

Move internal function out of header because Hyrum's law always wins.

PiperOrigin-RevId: 301446904"," class GTEST_API_ AssertHelper {
 GTEST_DISALLOW_COPY_AND_ASSIGN_(AssertHelper);
 };
 
-enum class GTestColor { kDefault, kRed, kGreen, kYellow };
-
-GTEST_API_ GTEST_ATTRIBUTE_PRINTF_(2, 3) void ColoredPrintf(GTestColor color,
- const char* fmt,
- ...);
-
 } // namespace internal
 
 // The pure interface class that all value-parameterized tests inherit from.
",759,129
"Add tests for MockFunction deduction (#2277)

Add tests checking that ::testing::MockFunction template argument can
be deduced in a function call context. This is a property raised in the
review, however, not checked before by any tests."," TEST(MockMethodMockFunctionTest, AsStdFunctionWithReferenceParameter) {
 }
 
 
+namespace {
+
+template <typename Expected, typename F>
+static constexpr bool IsMockFunctionTemplateArgumentDeducedTo(const MockFunction<F>&) {
+ return std::is_same<F, Expected>::value;
+}
+
+} // namespace
+
+template <typename F>
+class MockMethodMockFunctionSignatureTest : public Test {
+};
+
+using MockMethodMockFunctionSignatureTypes = Types<
+ void(),
+ int(),
+ void(int),
+ int(int),
+ int(bool, int),
+ int(bool, char, int, int, int, int, int, char, int, bool)
+>;
+TYPED_TEST_SUITE(MockMethodMockFunctionSignatureTest, MockMethodMockFunctionSignatureTypes);
+
+TYPED_TEST(MockMethodMockFunctionSignatureTest, IsMockFunctionTemplateArgumentDeduced) {
+ using Argument = TypeParam;
+ MockFunction<Argument> foo;
+ EXPECT_TRUE(IsMockFunctionTemplateArgumentDeducedTo<Argument>(foo));
+}
+
+
 struct MockMethodSizes0 {
 MOCK_METHOD(void, func, ());
 };
",617,53
"Add GTEST_BRIEF option

Only prints failures and a total pass count"," GTEST_DECLARE_bool_(list_tests);
 // in addition to its normal textual output.
 GTEST_DECLARE_string_(output);
 
+// This flags control whether Google Test prints only test failures.
+GTEST_DECLARE_bool_(brief);
+
 // This flags control whether Google Test prints the elapsed time for each
 // test.
 GTEST_DECLARE_bool_(print_time);
",760,129
"Googletest export

Add --gtest_fail_fast support to googletest.

 - Analogous functionality to to golang -test.failfast and python --failfast
 - Stops test execution upon first test failure.
 - Also add support Bazel equivalent env var (TESTBRIDGE_TEST_RUNNER_FAIL_FAST)

PiperOrigin-RevId: 302488880"," GTEST_DECLARE_bool_(catch_exceptions);
 // to let Google Test decide.
 GTEST_DECLARE_string_(color);
 
+// This flag controls whether the test runner should continue execution past
+// first failure.
+GTEST_DECLARE_bool_(fail_fast);
+
 // This flag sets up the filter to select by name using a glob pattern
 // the tests to run. If the filter is not given all tests are executed.
 GTEST_DECLARE_string_(filter);
 class GTEST_API_ TestInfo {
 // deletes it.
 void Run();
 
+ // Skip and records the test result for this object.
+ void Skip();
+
 static void ClearTestResult(TestInfo* test_info) {
 test_info->result_.Clear();
 }
 class GTEST_API_ TestSuite {
 // Runs every test in this TestSuite.
 void Run();
 
+ // Skips the execution of tests under this TestSuite
+ void Skip();
+
 // Runs SetUpTestSuite() for this TestSuite. This wrapper is needed
 // for catching exceptions thrown from SetUpTestSuite().
 void RunSetUpTestSuite() {
",762,129
"Only write "">\n"" once when there is failure and skipped tests."," void XmlUnitTestResultPrinter::OutputXmlTestInfo(::std::ostream* stream,
 for (int i = 0; i < result.total_part_count(); ++i) {
 const TestPartResult& part = result.GetTestPartResult(i);
 if (part.failed()) {
- if (++failures == 1) {
+ if (++failures == 1 && skips == 0) {
 *stream << "">\n"";
 }
 const std::string location =
 void XmlUnitTestResultPrinter::OutputXmlTestInfo(::std::ostream* stream,
 OutputXmlCDataSection(stream, RemoveInvalidXmlCharacters(detail).c_str());
 *stream << ""</failure>\n"";
 } else if (part.skipped()) {
- if (++skips == 1) {
+ if (++skips == 1 && failures == 0) {
 *stream << "">\n"";
 }
 const std::string location =
",4088,984
Fix multiple \n characters in xml file when using GTEST_SKIP.," std::string AppendUserMessage(const std::string& gtest_msg,
 if (user_msg_string.empty()) {
 return gtest_msg;
 }
-
+ if (gtest_msg.empty()) {
+ return user_msg_string;
+ }
 return gtest_msg + ""\n"" + user_msg_string;
 }
 
 static std::string FormatTestSuiteCount(int test_suite_count) {
 static const char * TestPartResultTypeToString(TestPartResult::Type type) {
 switch (type) {
 case TestPartResult::kSkip:
- return ""Skipped"";
+ return ""Skipped\n"";
 case TestPartResult::kSuccess:
 return ""Success"";
 
",4091,985
"Fixed xml unit-tests and added extra tests

The extra tests check that the xml output is correct when a failure occurs before skipping, and that the right skip message is added to the file.

The json file had to be fixed because it's the same executable."," else:
 
 EXPECTED_NON_EMPTY = {
 u'tests':
- 24,
+ 26,
 u'failures':
- 4,
+ 5,
 u'disabled':
 2,
 u'errors':
 EXPECTED_NON_EMPTY = {
 u'name':
 u'SkippedTest',
 u'tests':
- 1,
+ 3,
 u'failures':
- 0,
+ 1,
 u'disabled':
 0,
 u'errors':
 EXPECTED_NON_EMPTY = {
 u'time': u'*',
 u'timestamp': u'*',
 u'classname': u'SkippedTest'
+ }, {
+ u'name': u'SkippedWithMessage',
+ u'status': u'RUN',
+ u'result': u'SKIPPED',
+ u'time': u'*',
+ u'timestamp': u'*',
+ u'classname': u'SkippedTest'
+ }, {
+ u'name': u'SkippedAfterFailure',
+ u'status': u'RUN',
+ u'result': u'COMPLETED',
+ u'time': u'*',
+ u'timestamp': u'*',
+ u'classname': u'SkippedTest',
+u'failures': [{
+ u'failure': u'gtest_xml_output_unittest_.cc:*\n'
+ u'Expected equality of these values:\n'
+ u' 1\n 2' + STACK_TRACE_TEMPLATE,
+ u'type': u''
+ }]
 }]
 }, {
 u'name':
",674,13
"Replace the last instance of `throw()` with `noexcept`. NFC.

Fixes a -Wdeprecated warning.

/home/travis/build/Quuxplusone/googletest/googletest/test/googletest-death-test_ex_test.cc:62:28: error:
 dynamic exception specifications are deprecated [-Werror,-Wdeprecated]
 const char* what() const throw() override { return ""exceptional message""; }
 ^~~~~~~
/home/travis/build/Quuxplusone/googletest/googletest/test/googletest-death-test_ex_test.cc:62:28: note:
 use 'noexcept' instead
 const char* what() const throw() override { return ""exceptional message""; }
 ^~~~~~~
 noexcept"," TEST(CxxExceptionDeathTest, ExceptionIsFailure) {
 
 class TestException : public std::exception {
 public:
- const char* what() const throw() override { return ""exceptional message""; }
+ const char* what() const noexcept override { return ""exceptional message""; }
 };
 
 TEST(CxxExceptionDeathTest, PrintsMessageForStdExceptions) {
",34,8
Fix --gtest_print_time coloring," static const char kColorEncodedHelpMessage[] =
 ""Test Output:\n""
 "" @G--"" GTEST_FLAG_PREFIX_ ""color=@Y(@Gyes@Y|@Gno@Y|@Gauto@Y)@D\n""
 "" Enable/disable colored output. The default is @Gauto@D.\n""
-"" -@G-"" GTEST_FLAG_PREFIX_ ""print_time=0@D\n""
+"" @G--"" GTEST_FLAG_PREFIX_ ""print_time=0@D\n""
 "" Don't print the elapsed time of each test.\n""
 "" @G--"" GTEST_FLAG_PREFIX_ ""output=@Y(@Gjson@Y|@Gxml@Y)[@G:@YDIRECTORY_PATH@G""
 GTEST_PATH_SEP_ ""@Y|@G:@YFILE_PATH]@D\n""
",4071,978
"Googletest export

Do not use std::result_of as it was removed in C++20.

PiperOrigin-RevId: 303783600"," struct InvokeMethodWithoutArgsAction {
 Class* const obj_ptr;
 const MethodPtr method_ptr;
 
- using ReturnType = typename std::result_of<MethodPtr(Class*)>::type;
+ using ReturnType =
+ decltype((std::declval<Class*>()->*std::declval<MethodPtr>())());
 
 template <typename... Args>
 ReturnType operator()(const Args&...) const {
",690,116
"Googletest export

This change updates testing::internal::IsAProtocolMessage to return true not
just for full proto messages but also for lite ones (i.e. those inheriting
directly from MessageLite).

PiperOrigin-RevId: 304286535","
 #define GTEST_STRINGIFY_HELPER_(name, ...) #name
 #define GTEST_STRINGIFY_(...) GTEST_STRINGIFY_HELPER_(__VA_ARGS__, )
 
-namespace proto2 { class Message; }
+namespace proto2 {
+class MessageLite;
+}
 
 namespace testing {
 
 class GTEST_API_ Random {
 typename std::remove_const<typename std::remove_reference<T>::type>::type
 
 // IsAProtocolMessage<T>::value is a compile-time bool constant that's
-// true if and only if T is type proto2::Message or a subclass of it.
+// true if and only if T is type proto2::MessageLite or a subclass of it.
 template <typename T>
 struct IsAProtocolMessage
- : public std::is_convertible<const T*, const ::proto2::Message*> {};
+ : public std::is_convertible<const T*, const ::proto2::MessageLite*> {};
 
 // When the compiler sees expression IsContainerTest<C>(0), if C is an
 // STL-style container class, the first overload of IsContainerTest
",638,92
gtest-unittest-api_test - fix warning in clang build," class UnitTestHelper {
 // name. The caller is responsible for deleting the array.
 static TestSuite const** GetSortedTestSuites() {
 UnitTest& unit_test = *UnitTest::GetInstance();
- auto const** const test_suites =
- new const TestSuite*[unit_test.total_test_suite_count()];
+ auto const** const test_suites = new const TestSuite*[static_cast<size_t>(
+ unit_test.total_test_suite_count())];
 
 for (int i = 0; i < unit_test.total_test_suite_count(); ++i)
 test_suites[i] = unit_test.GetTestSuite(i);
 class UnitTestHelper {
 // sorted by the test name. The caller is responsible for deleting the
 // array.
 static TestInfo const** GetSortedTests(const TestSuite* test_suite) {
- TestInfo const** const tests =
- new const TestInfo*[test_suite->total_test_count()];
+ TestInfo const** const tests = new const TestInfo*[static_cast<size_t>(
+ test_suite->total_test_count())];
 
 for (int i = 0; i < test_suite->total_test_count(); ++i)
 tests[i] = test_suite->GetTestInfo(i);
",225,22
Remove redundant .c_str()," void XmlUnitTestResultPrinter::OutputXmlTestInfo(::std::ostream* stream,
 part.line_number());
 const std::string summary = location + ""\n"" + part.summary();
 *stream << "" <failure message=\""""
- << EscapeXmlAttribute(summary.c_str())
+ << EscapeXmlAttribute(summary)
 << ""\"" type=\""\"">"";
 const std::string detail = location + ""\n"" + part.message();
 OutputXmlCDataSection(stream, RemoveInvalidXmlCharacters(detail).c_str());
",4071,978
fix signed/unsigned comparison issue (on OpenBSD)," size_t GetThreadCount() {
 
 // exclude empty members
 int nthreads = 0;
- for (int i = 0; i < size / mib[4]; i++) {
+ for (size_t i = 0; i < size / mib[4]; i++) {
 if (info[i].p_tid != -1)
 nthreads++;
 }
",880,219
Enable protobuf printing for open-source proto messages.," TEST(IsAProtocolMessageTest, ValueIsTrueWhenTypeIsAProtocolMessage) {
 EXPECT_TRUE(IsAProtocolMessage<::proto2::MessageLite>::value);
 }
 
+TEST(IsAProtocolMessageTest, ValueIsTrueWhenTypeIsAnOpenSourceProtocolMessage) {
+ EXPECT_TRUE(IsAProtocolMessage<::google::protobuf::MessageLite>::value);
+}
+
 // Tests that IsAProtocolMessage<T>::value is false when T is neither
 // ::proto2::Message nor a sub-class of it.
 TEST(IsAProtocolMessageTest, ValueIsFalseWhenTypeIsNotAProtocolMessage) {
",4961,718
"Fix a -Wdeprecated warning.

 gmock-spec-builders.h:503:3: error:
 definition of implicit copy constructor for 'Expectation' is deprecated
 because it has a user-declared destructor [-Werror,-Wdeprecated]
 ~Expectation();
 ^"," class GTEST_API_ Expectation {
 public:
 // Constructs a null object that doesn't reference any expectation.
 Expectation();
-
+ Expectation(Expectation&&) = default;
+ Expectation(const Expectation&) = default;
+ Expectation& operator=(Expectation&&) = default;
+ Expectation& operator=(const Expectation&) = default;
 ~Expectation();
 
 // This single-argument ctor must not be explicit, in order to support the
",1008,155
"Fix a -Wdeprecated warning.

 googletest-port-test.cc:97:11: error:
 definition of implicit copy constructor for 'Base' is deprecated because
 it has a user-declared destructor [-Werror,-Wdeprecated]
 virtual ~Base() {}
 ^"," TEST(IsXDigitTest, ReturnsFalseForWideNonAscii) {
 
 class Base {
 public:
- // Copy constructor and assignment operator do exactly what we need, so we
- // use them.
 Base() : member_(0) {}
 explicit Base(int n) : member_(n) {}
+ Base(const Base&) = default;
+ Base& operator=(const Base&) = default;
 virtual ~Base() {}
 int member() { return member_; }
 
",910,154
"Fix a -Wdeprecated warning.

 googletest-param-test-test.cc:502:8: error:
 definition of implicit copy constructor for
 'NonDefaultConstructAssignString' is deprecated because it has a
 user-declared copy assignment operator [-Werror,-Wdeprecated]
 void operator=(const NonDefaultConstructAssignString&);
 ^"," TEST(CombineTest, CombineWithMaxNumberOfParameters) {
 class NonDefaultConstructAssignString {
 public:
 NonDefaultConstructAssignString(const std::string& s) : str_(s) {}
+ NonDefaultConstructAssignString() = delete;
+ NonDefaultConstructAssignString(const NonDefaultConstructAssignString&) = default;
+ NonDefaultConstructAssignString& operator=(const NonDefaultConstructAssignString&) = delete;
+ ~NonDefaultConstructAssignString() = default;
 
 const std::string& str() const { return str_; }
 
 private:
 std::string str_;
-
- // Not default constructible
- NonDefaultConstructAssignString();
- // Not assignable
- void operator=(const NonDefaultConstructAssignString&);
 };
 
 TEST(CombineTest, NonDefaultConstructAssign) {
",736,112
"Googletest export

Fix comment that describes how to test against nullopt.

PiperOrigin-RevId: 307448375"," inline InnerMatcher AllArgs(const InnerMatcher& matcher) { return matcher; }
 // and is printable using 'PrintToString'. It is compatible with
 // std::optional/std::experimental::optional.
 // Note that to compare an optional type variable against nullopt you should
-// use Eq(nullopt) and not Optional(Eq(nullopt)). The latter implies that the
+// use Eq(nullopt) and not Eq(Optional(nullopt)). The latter implies that the
 // optional value contains an optional itself.
 template <typename ValueMatcher>
 inline internal::OptionalMatcher<ValueMatcher> Optional(
",2952,561
"Googletest export

Rewrite ReturnNew action without using pump.

PiperOrigin-RevId: 308219616"," auto ApplyImpl(F&& f, Tuple&& args, IndexSequence<Idx...>) -> decltype(
 
 // Apply the function to a tuple of arguments.
 template <typename F, typename Tuple>
-auto Apply(F&& f, Tuple&& args)
- -> decltype(ApplyImpl(std::forward<F>(f), std::forward<Tuple>(args),
- MakeIndexSequence<std::tuple_size<Tuple>::value>())) {
+auto Apply(F&& f, Tuple&& args) -> decltype(
+ ApplyImpl(std::forward<F>(f), std::forward<Tuple>(args),
+ MakeIndexSequence<std::tuple_size<
+ typename std::remove_reference<Tuple>::type>::value>())) {
 return ApplyImpl(std::forward<F>(f), std::forward<Tuple>(args),
- MakeIndexSequence<std::tuple_size<Tuple>::value>());
+ MakeIndexSequence<std::tuple_size<
+ typename std::remove_reference<Tuple>::type>::value>());
 }
 
 // Template struct Function<F>, where F must be a function type, contains
",199,2
"Googletest export

Addresses Github issue (https://github.com/google/googletest/issues/2822) by following the Microsoft documention (https://docs.microsoft.com/en-us/windows/win32/api/debugapi/nf-debugapi-isdebuggerpresent) to include capital-W Windows.h before including debugapi.h.

See ""Header	debugapi.h (include Windows.h)""

PiperOrigin-RevId: 309745868","
 
 #elif GTEST_OS_WINDOWS // We are on Windows proper.
 
+# include <Windows.h> // NOLINT
 # include <windows.h> // NOLINT
 # undef min
 
",4072,978
"Remove an explicit include of debugapi.h

The documentation for IsDebuggerPresent says that one just should
include windows.h, as that one is an umbrella header that includes
the header that declares IsDebuggerPresent. In older Windows SDKs,
debugapi.h didn't exist and IsDebuggerPresent was declared in
winbase.h (also included by windows.h).

This should fix issue #2822 properly.","
 
 #ifdef _MSC_VER
 # include <crtdbg.h> // NOLINT
-# include <debugapi.h> // NOLINT
 #endif
 
 # include <io.h> // NOLINT
",4180,1006
"Googletest export

Fixed #2823 - Make it so that a semicolon appearing after an invocation of GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_ does not trigger a redundant semicolon warning.

This works by introducing an else block with a statement that intentionally does not end with a semicolon, forcing users to place the semicolon after the expansion. The approach here is preferred as opposed to removing semicolons that appear after each invocation because complete statements that do not have a visible semicolon or braces confuse users and code formatters, since the macro invocation looks superficially like an expression.

PiperOrigin-RevId: 311327491"," constexpr bool InstantiateTypedTestCase_P_IsDeprecated() { return true; }
 // Suppress MSVC warning 4072 (unreachable code) for the code following
 // statement if it returns or throws (or doesn't return or throw in some
 // situations).
+// NOTE: The ""else"" is important to keep this expansion to prevent a top-level
+// ""else"" from attaching to our ""if"".
 #define GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_(statement) \
- if (::testing::internal::AlwaysTrue()) { statement; }
+ if (::testing::internal::AlwaysTrue()) { \
+ statement; \
+ } else /* NOLINT */ \
+ static_assert(true, """") // User must have a semicolon after expansion.
 
 #define GTEST_TEST_THROW_(statement, expected_exception, fail) \
 GTEST_AMBIGUOUS_ELSE_BLOCKER_ \
",637,92
Use count function instead of handwritten loop," const char* TypedTestSuitePState::VerifyRegisteredTestNames(
 continue;
 }
 
- bool found = false;
- for (RegisteredTestIter it = registered_tests_.begin();
- it != registered_tests_.end();
- ++it) {
- if (name == it->first) {
- found = true;
- break;
- }
- }
-
- if (found) {
+ if (registered_tests_.count(name) != 0) {
 tests.insert(name);
 } else {
 errors << ""No test named "" << name
",58,11
"Googletest export

Fix the ACTION* macros to allow for more than 10 arguments in the action.
Only the first 10 will be passed as individual arguments as `argN`, but the rest
can be accessed from the `args` tuple.

PiperOrigin-RevId: 311542098"," class ActionHelper {
 public:
 template <typename... Ts>
 static Result Perform(Impl* impl, const std::tuple<Ts...>& args) {
- return Apply(impl, args, MakeIndexSequence<sizeof...(Ts)>{},
- MakeIndexSequence<10 - sizeof...(Ts)>{});
+ static constexpr size_t kMaxArgs = sizeof...(Ts) <= 10 ? sizeof...(Ts) : 10;
+ return Apply(impl, args, MakeIndexSequence<kMaxArgs>{},
+ MakeIndexSequence<10 - kMaxArgs>{});
 }
 
 private:
 template <typename... Ts, std::size_t... tuple_ids, std::size_t... rest_ids>
 static Result Apply(Impl* impl, const std::tuple<Ts...>& args,
 IndexSequence<tuple_ids...>, IndexSequence<rest_ids...>) {
- return impl->template gmock_PerformImpl<Ts...>(
+ return impl->template gmock_PerformImpl<
+ typename std::tuple_element<tuple_ids, std::tuple<Ts...>>::type...>(
 args, std::get<tuple_ids>(args)...,
 ((void)rest_ids, ExcessiveArg())...);
 }
",699,119
"Googletest export

Silence MSVC C4100 (unused formal parameter) to fix breakage from recently added testcase. This warning is silenced in many files throughout googletest, but was not needed here until this testcase was added.

PiperOrigin-RevId: 312121200","
 //
 // This file tests the built-in actions.
 
-// Silence C4800 (C4800: 'int *const ': forcing value
-// to bool 'true' or 'false') for MSVC 15
+// Silence C4100 (unreferenced formal parameter) for MSVC
 #ifdef _MSC_VER
-#if _MSC_VER == 1900
 # pragma warning(push)
+# pragma warning(disable:4100)
+#if _MSC_VER == 1900
+// and silence C4800 (C4800: 'int *const ': forcing value
+// to bool 'true' or 'false') for MSVC 15
 # pragma warning(disable:4800)
 #endif
 #endif
",1069,163
"Googletest export

Addresses https://github.com/google/googletest/issues/2848 by using `_wfopen(...)` on Windows

PiperOrigin-RevId: 312198825","
 #endif
 
 #include <iostream> // NOLINT
+#include <locale>
 #include <memory>
 #include <string> // NOLINT
 #include <tuple>
 GTEST_DISABLE_MSC_DEPRECATED_PUSH_()
 inline int ChDir(const char* dir) { return chdir(dir); }
 #endif
 inline FILE* FOpen(const char* path, const char* mode) {
+#if GTEST_OS_WINDOWS
+ std::wstring_convert<std::codecvt<wchar_t, char, std::mbstate_t>> converter;
+ std::wstring wide_path = converter.from_bytes(path);
+ std::wstring wide_mode = converter.from_bytes(mode);
+ return _wfopen(wide_path.c_str(), wide_mode.c_str());
+#else
 return fopen(path, mode);
+#endif // GTEST_OS_WINDOWS
 }
 #if !GTEST_OS_WINDOWS_MOBILE
 inline FILE *FReopen(const char* path, const char* mode, FILE* stream) {
",667,160
"Googletest export

Rollback of warning on unused ACTION result change

PiperOrigin-RevId: 313380971"," auto InvokeArgumentAdl(AdlTag, F f, Args... args) -> decltype(f(args...)) {
 return_type gmock_PerformImpl(GMOCK_ACTION_ARG_TYPES_AND_NAMES_) const; \
 }; \
 }; \
- inline name##Action name() GTEST_MUST_USE_RESULT_; \
 inline name##Action name() { return name##Action(); } \
 template <typename F> \
 template <GMOCK_ACTION_TEMPLATE_ARGS_NAMES_> \
",699,119
"Googletest export

Change 'suite' to 'case' in comments.

PiperOrigin-RevId: 313429487"," class GTEST_API_ Test {
 // The d'tor is virtual as we intend to inherit from Test.
 virtual ~Test();
 
- // Sets up the stuff shared by all tests in this test case.
+ // Sets up the stuff shared by all tests in this test suite.
 //
 // Google Test will call Foo::SetUpTestSuite() before running the first
- // test in test case Foo. Hence a sub-class can define its own
+ // test in test suite Foo. Hence a sub-class can define its own
 // SetUpTestSuite() method to shadow the one defined in the super
 // class.
 static void SetUpTestSuite() {}
 class GTEST_API_ Test {
 // Tears down the stuff shared by all tests in this test suite.
 //
 // Google Test will call Foo::TearDownTestSuite() after running the last
- // test in test case Foo. Hence a sub-class can define its own
+ // test in test suite Foo. Hence a sub-class can define its own
 // TearDownTestSuite() method to shadow the one defined in the super
 // class.
 static void TearDownTestSuite() {}
",763,129
"Googletest export

Fix compile error from protected destructor of std::codecvt

PiperOrigin-RevId: 313584603"," inline int ChDir(const char* dir) { return chdir(dir); }
 #endif
 inline FILE* FOpen(const char* path, const char* mode) {
 #if GTEST_OS_WINDOWS
- std::wstring_convert<std::codecvt<wchar_t, char, std::mbstate_t>> converter;
+ struct wchar_codecvt : public std::codecvt<wchar_t, char, std::mbstate_t> {};
+ std::wstring_convert<wchar_codecvt> converter;
 std::wstring wide_path = converter.from_bytes(path);
 std::wstring wide_mode = converter.from_bytes(mode);
 return _wfopen(wide_path.c_str(), wide_mode.c_str());
",668,160
specialize UniversalPrinter<> for std::optional,"
 
 #if GTEST_HAS_ABSL
 #include ""absl/strings/string_view.h""
-#include ""absl/types/optional.h""
 #endif // GTEST_HAS_ABSL
 
 namespace testing {
 class UniversalPrinter {
 GTEST_DISABLE_MSC_WARNINGS_POP_()
 };
 
-#if GTEST_HAS_ABSL
+#if GTEST_INTERNAL_HAS_OPTIONAL
 
-// Printer for absl::optional
+// Printer for std::optional / absl::optional
 
 template <typename T>
-class UniversalPrinter<::absl::optional<T>> {
+class UniversalPrinter<Optional<T>> {
 public:
- static void Print(const ::absl::optional<T>& value, ::std::ostream* os) {
+ static void Print(const Optional<T>& value, ::std::ostream* os) {
 *os << '(';
 if (!value) {
 *os << ""nullopt"";
 class UniversalPrinter<::absl::optional<T>> {
 }
 };
 
-#endif // GTEST_HAS_ABSL
+#endif // GTEST_INTERNAL_HAS_OPTIONAL
 
 #if GTEST_INTERNAL_HAS_VARIANT
 
",449,76
specialize UniversalPrinter<> for std::any (without support for RTTI)," class UniversalPrinter {
 GTEST_DISABLE_MSC_WARNINGS_POP_()
 };
 
+#if GTEST_INTERNAL_HAS_ANY
+
+// Printer for std::any / absl::any
+
+template <>
+class UniversalPrinter<Any> {
+ public:
+ static void Print(const Any& value, ::std::ostream* os) {
+ if (value.has_value())
+ *os << ""'any' type with value of type "" << GetTypeName();
+ else
+ *os << ""'any' type with no value"";
+ }
+
+ private:
+ static std::string GetTypeName() { return ""the element type""; }
+};
+
+#endif // GTEST_INTERNAL_HAS_ANY
+
 #if GTEST_INTERNAL_HAS_OPTIONAL
 
 // Printer for std::optional / absl::optional
",461,79
make UniversalPrinter<std::any> support RTTI," class UniversalPrinter<Any> {
 public:
 static void Print(const Any& value, ::std::ostream* os) {
 if (value.has_value())
- *os << ""'any' type with value of type "" << GetTypeName();
+ *os << ""'any' type with value of type "" << GetTypeName(value);
 else
 *os << ""'any' type with no value"";
 }
 
 private:
- static std::string GetTypeName() { return ""the element type""; }
+ static std::string GetTypeName(const Any& value) {
+#if GTEST_HAS_RTTI
+ return internal::GetTypeName(value.type());
+#else
+ static_cast<void>(value); // possibly unused
+ return ""the element type"";
+#endif // GTEST_HAS_RTTI
+ }
 };
 
 #endif // GTEST_INTERNAL_HAS_ANY
",465,80
"Googletest export

Adds support for printing the types char8_t, char16_t, and char32_t

This changes prints these types as Unicode code points. It is possible
that there is a better way of printing these types, but that change is
more complex, and the format in which Googletest prints these types is
subject to change if someone implements a better way of printing them.

This fixes the C++20 build, which removed support for printing these types.
https://en.cppreference.com/w/cpp/io/basic_ostream/operator_ltlt2

Fixes #2854

PiperOrigin-RevId: 314826912"," void PrintTo(wchar_t wc, ostream* os) {
 PrintCharAndCodeTo<wchar_t>(wc, os);
 }
 
+void PrintTo(char32_t c, ::std::ostream* os) {
+ *os << std::hex << ""U+"" << std::uppercase << std::setfill('0') << std::setw(4)
+ << c;
+}
+
 // Prints the given array of characters to the ostream. CharType must be either
 // char or wchar_t.
 // The array starts at begin, the length is len, it may include '\0' characters
",278,91
"Fix build issue for MinGW

Fixes #2885"," GTEST_DISABLE_MSC_DEPRECATED_PUSH_()
 inline int ChDir(const char* dir) { return chdir(dir); }
 #endif
 inline FILE* FOpen(const char* path, const char* mode) {
-#if GTEST_OS_WINDOWS
+#if GTEST_OS_WINDOWS && !GTEST_OS_WINDOWS_MINGW
 struct wchar_codecvt : public std::codecvt<wchar_t, char, std::mbstate_t> {};
 std::wstring_convert<wchar_codecvt> converter;
 std::wstring wide_path = converter.from_bytes(path);
",708,160
"Googletest export

Add missing static_cast to char32_t printer

PiperOrigin-RevId: 314925583","
 #include ""gtest/gtest-printers.h""
 #include <stdio.h>
 #include <cctype>
+#include <cstdint>
 #include <cwchar>
 #include <ostream> // NOLINT
 #include <string>
 void PrintTo(wchar_t wc, ostream* os) {
 
 void PrintTo(char32_t c, ::std::ostream* os) {
 *os << std::hex << ""U+"" << std::uppercase << std::setfill('0') << std::setw(4)
- << c;
+ << static_cast<uint32_t>(c);
 }
 
 // Prints the given array of characters to the ostream. CharType must be either
",279,91
"Googletest export

Fail TEST_Ps or TYPED_TEST_Ps that are defined but are not instantiated, as well as the opposite case, where INSTANTIATE_TEST_SUITE_P or INSTANTIATE_TYPED_TEST_SUITE_P is used but without any matching TEST_P or TYPED_TEST_P.

PiperOrigin-RevId: 315255779"," namespace {
 // inserted to report ether an error or a log message.
 //
 // This configuration bit will likely be removed at some point.
-constexpr bool kErrorOnUninstantiatedParameterizedTest = false;
-constexpr bool kErrorOnUninstantiatedTypeParameterizedTest = false;
+constexpr bool kErrorOnUninstantiatedParameterizedTest = true;
+constexpr bool kErrorOnUninstantiatedTypeParameterizedTest = true;
 
 // A test that fails at a given file/line location with a given message.
 class FailureTest : public Test {
",4200,1013
"Googletest export

Make visible ParseInt32 in case users have separate gmock/gtest libraries and hidden-by-default symbols.

This function is still considered an internal implementation detail and is subject to change without notice. It is still unsafe/unsupported to link together libraries built at different commits.

PiperOrigin-RevId: 315405429"," using TimeInMillis = int64_t; // Represents time in milliseconds.
 // Parses 'str' for a 32-bit signed integer. If successful, writes the result
 // to *value and returns true; otherwise leaves *value unchanged and returns
 // false.
-bool ParseInt32(const Message& src_text, const char* str, int32_t* value);
+GTEST_API_ bool ParseInt32(const Message& src_text, const char* str,
+ int32_t* value);
 
 // Parses a bool/int32_t/string from the environment variable
 // corresponding to the given Google Test flag.
",709,160
"remove a duplicated include

Detection of string_view type (whether it's std or Abseil)
is done in googletest/include/gtest/internal/gtest-port.h
with GTEST_INTERNAL_HAS_STRING_VIEW.","
 #include ""gtest/internal/gtest-internal.h""
 #include ""gtest/internal/gtest-port.h""
 
-#if GTEST_HAS_ABSL
-#include ""absl/strings/string_view.h""
-#endif // GTEST_HAS_ABSL
-
 namespace testing {
 
 // Definitions in the internal* namespaces are subject to change without notice.
",441,73
"Googletest export

Adds support for printing pointers of types char8_t, char16_t, and char32_t.

PiperOrigin-RevId: 316112767"," inline void PrintTo(const unsigned char* s, ::std::ostream* os) {
 inline void PrintTo(unsigned char* s, ::std::ostream* os) {
 PrintTo(ImplicitCast_<const void*>(s), os);
 }
+#ifdef __cpp_char8_t
+inline void PrintTo(const char8_t* s, ::std::ostream* os) {
+ PrintTo(ImplicitCast_<const void*>(s), os);
+}
+inline void PrintTo(char8_t* s, ::std::ostream* os) {
+ PrintTo(ImplicitCast_<const void*>(s), os);
+}
+#endif
+inline void PrintTo(const char16_t* s, ::std::ostream* os) {
+ PrintTo(ImplicitCast_<const void*>(s), os);
+}
+inline void PrintTo(char16_t* s, ::std::ostream* os) {
+ PrintTo(ImplicitCast_<const void*>(s), os);
+}
+inline void PrintTo(const char32_t* s, ::std::ostream* os) {
+ PrintTo(ImplicitCast_<const void*>(s), os);
+}
+inline void PrintTo(char32_t* s, ::std::ostream* os) {
+ PrintTo(ImplicitCast_<const void*>(s), os);
+}
 
 // MSVC can be configured to define wchar_t as a typedef of unsigned
 // short. It defines _NATIVE_WCHAR_T_DEFINED when wchar_t is a native
",479,81
"Googletest export

Make sure sanitizers do not tamper with the stack here in StackLowerThanAddress().

PiperOrigin-RevId: 318082465"," static int ExecDeathTestChildMain(void* child_arg) {
 // correct answer.
 static void StackLowerThanAddress(const void* ptr,
 bool* result) GTEST_NO_INLINE_;
+// Make sure sanitizers do not tamper with the stack here.
+// Ideally, we want to use `__builtin_frame_address` instead of a local variable
+// address with sanitizer disabled, but it does not work when the
+// compiler optimizes the stack frame out, which happens on PowerPC targets.
 // HWAddressSanitizer add a random tag to the MSB of the local variable address,
 // making comparison result unpredictable.
+GTEST_ATTRIBUTE_NO_SANITIZE_ADDRESS_
 GTEST_ATTRIBUTE_NO_SANITIZE_HWADDRESS_
 static void StackLowerThanAddress(const void* ptr, bool* result) {
 int dummy;
",978,174
"Googletest export

Update auto_mock to support C++17 nested namespaces

PiperOrigin-RevId: 318192214"," class AstBuilder(object):
 bases, templated_types, body, self.namespace_stack)
 
 def handle_namespace(self):
- token = self._GetNextToken()
 # Support anonymous namespaces.
 name = None
- if token.token_type == tokenize.NAME:
- name = token.name
- token = self._GetNextToken()
+ name_tokens, token = self.GetName()
+ if name_tokens:
+ name = ''.join([t.name for t in name_tokens])
 self.namespace_stack.append(name)
 assert token.token_type == tokenize.SYNTAX, token
 # Create an internal token that denotes when the namespace is complete.
",1277,396
"Fix test failing when simple regex is used

Test MatcherDeathTest.DoesNotBreakBareRegexMatching fails when
googletest uses simple regex instead of posix regex.

This partially fixes #2687"," void DieWithMessage(const char* message) {
 TEST(MatcherDeathTest, DoesNotBreakBareRegexMatching) {
 // googletest tests this, of course; here we ensure that including googlemock
 // has not broken it.
+#if GTEST_USES_POSIX_RE
 EXPECT_DEATH(DieWithMessage(""O, I die, Horatio.""), ""I d[aeiou]e"");
+#else
+ EXPECT_DEATH(DieWithMessage(""O, I die, Horatio.""), ""I di?e"");
+#endif
 }
 
 TEST(MatcherDeathTest, MonomorphicMatcherMatches) {
",964,165
"Googletest export

Improve compatibility with strict compilers targeting Windows

Remove an unnecessary ##, which could result in warnings about invalid preprocessor tokens when pasting to an initial '('

PiperOrigin-RevId: 319277617"," using internal::FunctionMocker;
 GMOCK_INTERNAL_GET_VALUE_CALLTYPE_I( \
 GMOCK_PP_CAT(GMOCK_INTERNAL_IS_CALLTYPE_HELPER_, _arg))
 #define GMOCK_INTERNAL_GET_VALUE_CALLTYPE_I(_arg) \
- GMOCK_PP_CAT(GMOCK_PP_IDENTITY, _arg)
+ GMOCK_PP_IDENTITY _arg
 
 #define GMOCK_INTERNAL_IS_CALLTYPE_HELPER_Calltype
 
",20,2
"Googletest export

Fix mismatch between `int` and `int32_t` in the parse function.
On some platforms, those are different types.

PiperOrigin-RevId: 319991862"," static bool ParseGoogleMockStringFlag(const char* str, const char* flag,
 }
 
 static bool ParseGoogleMockIntFlag(const char* str, const char* flag,
- int* value) {
+ int32_t* value) {
 // Gets the value of the flag as a string.
 const char* const value_str = ParseGoogleMockFlagValue(str, flag, true);
 
",90,25
"Googletest export

Cleanup: Error message grammar fix.
PiperOrigin-RevId: 319992912"," class MockObjectRegistry {
 if (leaked_count > 0) {
 std::cout << ""\nERROR: "" << leaked_count << "" leaked mock ""
 << (leaked_count == 1 ? ""object"" : ""objects"")
- << "" found at program exit. Expectations on a mock object is ""
+ << "" found at program exit. Expectations on a mock object are ""
 ""verified when the object is destructed. Leaking a mock ""
 ""means that its expectations aren't verified, which is ""
 ""usually a test bug. If you really intend to leak a mock, ""
",556,122
fix clang tidy modernize-use-equals-default warnings," class NeverThrown {
 class GTEST_TEST_CLASS_NAME_(test_suite_name, test_name) \
 : public parent_class { \
 public: \
- GTEST_TEST_CLASS_NAME_(test_suite_name, test_name)() {} \
+ GTEST_TEST_CLASS_NAME_(test_suite_name, test_name)() = default; \
 ~GTEST_TEST_CLASS_NAME_(test_suite_name, test_name)() override = default; \
 GTEST_DISALLOW_COPY_AND_ASSIGN_(GTEST_TEST_CLASS_NAME_(test_suite_name, \
 test_name)); \
",647,93
"Googletest export

Stop using ADL for InvokeArgument action.

PiperOrigin-RevId: 323234396"," class ActionImpl<Derived<Ts...>> {
 std::tuple<Ts...> params_;
 };
 
-namespace invoke_argument {
-
-// Appears in InvokeArgumentAdl's argument list to help avoid
-// accidental calls to user functions of the same name.
-struct AdlTag {};
-
-// InvokeArgumentAdl - a helper for InvokeArgument.
+// internal::InvokeArgument - a helper for InvokeArgument action.
 // The basic overloads are provided here for generic functors.
 // Overloads for other custom-callables are provided in the
 // internal/custom/gmock-generated-actions.h header.
 template <typename F, typename... Args>
-auto InvokeArgumentAdl(AdlTag, F f, Args... args) -> decltype(f(args...)) {
+auto InvokeArgument(F f, Args... args) -> decltype(f(args...)) {
 return f(args...);
 }
 
-} // namespace invoke_argument
-
 #define GMOCK_INTERNAL_ARG_UNUSED(i, data, el) \
 , const arg##i##_type& arg##i GTEST_ATTRIBUTE_UNUSED_
 #define GMOCK_ACTION_ARG_TYPES_AND_NAMES_UNUSED_ \
",696,119
Small improvements: code style and property name," ThrowsMessage(const MessageMatcher& messageMatcher) {
 // literals, e.g. ThrowsMessage(""message"").
 return MakePolymorphicMatcher(
 internal::ExceptionMatcherImpl<Err>{
- Property(""description"", &std::exception::what,
+ Property(""what"", &std::exception::what,
 MatcherCast<std::string>(messageMatcher))});
 }
 template <typename Err, typename Message = std::string>
 ThrowsMessageHasSubstr(const internal::StringLike<Message>& message) {
 ""expected an std::exception-derived class"");
 return MakePolymorphicMatcher(
 internal::ExceptionMatcherImpl<Err>{
- Property(""description"", &std::exception::what, HasSubstr(message))});
+ Property(""what"", &std::exception::what, HasSubstr(message))});
 }
 
 #endif // GTEST_HAS_EXCEPTIONS
",2992,575
Add missing documentation piece," class ExceptionMatcherImpl {
 //
 // EXPECT_THAT(
 // []() { throw std::runtime_error(""message""); },
-// Throws
+// Throws<std::runtime_error>(
+// Property(&std::runtime_error::what, HasSubstr(""message""))));
 
 template <typename Err>
 PolymorphicMatcher<internal::ExceptionMatcherImpl<Err>>
",2992,575
"Add a test for duplicate catch clauses in throw matchers, fix a couple of nitpicks."," class ExceptionMatcherImpl {
 ExceptionMatcherImpl(Matcher<const Err&> matcher)
 : matcher_(std::move(matcher)) {}
 
- public:
 void DescribeTo(::std::ostream* os) const {
 *os << ""throws an exception of type "" << GetTypeName<Err>();
 if (matcher_.GetDescriber() != nullptr) {
 class ExceptionMatcherImpl {
 *listener << ""with description \"""" << err.what() << ""\"""";
 return false;
 } catch (...) {
- *listener << ""throws an exception of some other type"";
+ *listener << ""throws an exception of an unknown type"";
 return false;
 }
 *listener << ""does not throw any exception"";
",2991,575
Add a test to ensure that the `Throws` matcher only invokes its argument once.," TEST(ThrowsTest, DoesNotGenerateDuplicateCatchClauseWarning) {
 Throws<std::exception>());
 }
 
+TEST(ThrowsTest, CallableExecutedExactlyOnce) {
+ size_t a = 0;
+
+ EXPECT_THAT(
+ [&a]() { a++; throw 10; },
+ Throws<int>());
+ EXPECT_EQ(a, 1);
+
+ EXPECT_THAT(
+ [&a]() { a++; throw std::runtime_error(""message""); },
+ Throws<std::runtime_error>());
+ EXPECT_EQ(a, 2);
+
+ EXPECT_THAT(
+ [&a]() { a++; throw std::runtime_error(""message""); },
+ ThrowsMessage<std::runtime_error>(HasSubstr(""message"")));
+ EXPECT_EQ(a, 3);
+
+ EXPECT_THAT(
+ [&a]() { a++; throw std::runtime_error(""message""); },
+ ThrowsMessageHasSubstr<std::runtime_error>(""message""));
+ EXPECT_EQ(a, 4);
+
+ EXPECT_THAT(
+ [&a]() { a++; throw std::runtime_error(""message""); },
+ Throws<std::runtime_error>(
+ Property(&std::runtime_error::what, HasSubstr(""message""))));
+ EXPECT_EQ(a, 5);
+}
+
 TEST(ThrowsTest, Describe) {
 Matcher<void (*)()> matcher = Throws<std::runtime_error>();
 std::stringstream ss;
",6230,871
Update tests after changing an error message," TEST(ThrowsTest, FailWrongTypeNonStd) {
 []() { throw 10; }, &listener));
 EXPECT_THAT(
 listener.str(),
- testing::HasSubstr(""throws an exception of some other type""));
+ testing::HasSubstr(""throws an exception of an unknown type""));
 }
 
 TEST(ThrowsTest, FailNoThrow) {
 TEST_P(ThrowsPredicateTest, FailWrongTypeNonStd) {
 []() { throw 10; }, &listener));
 EXPECT_THAT(
 listener.str(),
- testing::HasSubstr(""throws an exception of some other type""));
+ testing::HasSubstr(""throws an exception of an unknown type""));
 }
 
 TEST_P(ThrowsPredicateTest, FailWrongMessage) {
",6230,871
"Googletest export

Fix DoAll to work with move-only sink arguments.

This changes types of the first n - 1 actions so that they only get a readonly
view of the arguments. The last action will accept move only objects.

PiperOrigin-RevId: 324600664"," TEST(DoAllTest, TenActions) {
 EXPECT_EQ('g', g);
 }
 
+TEST(DoAllTest, MoveOnlyArgs) {
+ bool ran_first = false;
+ Action<int(std::unique_ptr<int>)> a =
+ DoAll(InvokeWithoutArgs([&] { ran_first = true; }),
+ [](std::unique_ptr<int> p) { return *p; });
+ EXPECT_EQ(7, a.Perform(std::make_tuple(std::unique_ptr<int>(new int(7)))));
+ EXPECT_TRUE(ran_first);
+}
+
 // The ACTION*() macros trigger warning C4100 (unreferenced formal
 // parameter) in MSVC with -W4. Unfortunately they cannot be fixed in
 // the macro definition, as the warnings are generated when the macro
",727,131
"Googletest export

Fix DoAll to work with move-only sink arguments.

This changes types of the first n - 1 actions so that they only get a readonly
view of the arguments. The last action will accept move only objects.

PiperOrigin-RevId: 324619666"," TEST(DoAllTest, TenActions) {
 EXPECT_EQ('g', g);
 }
 
-TEST(DoAllTest, MoveOnlyArgs) {
- bool ran_first = false;
- Action<int(std::unique_ptr<int>)> a =
- DoAll(InvokeWithoutArgs([&] { ran_first = true; }),
- [](std::unique_ptr<int> p) { return *p; });
- EXPECT_EQ(7, a.Perform(std::make_tuple(std::unique_ptr<int>(new int(7)))));
- EXPECT_TRUE(ran_first);
-}
-
 // The ACTION*() macros trigger warning C4100 (unreferenced formal
 // parameter) in MSVC with -W4. Unfortunately they cannot be fixed in
 // the macro definition, as the warnings are generated when the macro
",719,130
"Googletest export

Fixing exception-safety bug in googletest. Previously, if an exception was
thrown during a call to a mock that would have triggered an error, the error
was discarded.

Fixes #2890

PiperOrigin-RevId: 325017806","
 #include <memory>
 #include <sstream>
 #include <string>
+
 #include ""gmock/gmock.h""
+#include ""gtest/gtest-spi.h""
 #include ""gtest/gtest.h""
 
 namespace testing {
 TEST(ThrowActionTest, ThrowsGivenExceptionInNullaryFunction) {
 EXPECT_THROW(a.Perform(std::make_tuple()), MyException);
 }
 
+class Object {
+ public:
+ virtual ~Object() {}
+ virtual void Func() {}
+};
+
+class MockObject : public Object {
+ public:
+ ~MockObject() override {}
+ MOCK_METHOD(void, Func, (), (override));
+};
+
+TEST(ThrowActionTest, Times0) {
+ EXPECT_NONFATAL_FAILURE(
+ [] {
+ try {
+ MockObject m;
+ ON_CALL(m, Func()).WillByDefault([] { throw ""something""; });
+ EXPECT_CALL(m, Func()).Times(0);
+ m.Func();
+ } catch (...) {
+ // Exception is caught but Times(0) still triggers a failure.
+ }
+ }(),
+ """");
+}
+
 #endif // GTEST_HAS_EXCEPTIONS
 
 // Tests that SetArrayArgument<N>(first, last) sets the elements of the array
",529,102
"Googletest export

Workaround static assert in early versions libc++

The error is ""Attempted to construct a reference element in a tuple with an
rvalue"". We can fix this by putting everything into a non temporary tuple_args
and implitly convert to the other tuple types. This avoids binding an rvalue
reference to an lvalue reference inside the tuple.

PiperOrigin-RevId: 327624990"," struct DoAllAction {
 std::vector<Action<void(NonFinalType<Args>...)>> converted;
 Action<R(Args...)> last;
 R operator()(Args... args) const {
+ auto tuple_args = std::forward_as_tuple(std::forward<Args>(args)...);
 for (auto& a : converted) {
- a.Perform(std::forward_as_tuple(std::forward<Args>(args)...));
+ a.Perform(tuple_args);
 }
- return last.Perform(std::forward_as_tuple(std::forward<Args>(args)...));
+ return last.Perform(std::move(tuple_args));
 }
 };
 return Op{Convert<Action<void(NonFinalType<Args>...)>>(
",700,119
"Googletest export

Replace uses of ACTION_TEMPLATE and ACTION_P with manually written functors.
The latter provide better error diagnostics.
This fixes https://github.com/google/googletest/issues/2729.

PiperOrigin-RevId: 328573022","
 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
-
 // Google Mock - a framework for writing C++ mock classes.
 //
-// This file tests the built-in actions in gmock-more-actions.h.
-
-#include ""gmock/gmock-more-actions.h""
+// This file tests the built-in actions in gmock-actions.h.
 
 #include <functional>
 #include <memory>
 #include <sstream>
 #include <string>
 
+#include ""gmock/gmock-actions.h""
 #include ""gmock/gmock.h""
 #include ""gtest/gtest-spi.h""
 #include ""gtest/gtest.h""
",529,102
"Googletest export

Add millisecond precision to start timestamp in XML/JSON output

- Previous timestamp had format YYYY-MM-DDThh:mm:ss, now YYYY-MM-DDThh:mm:ss.sss
- This conforms to the ISO 8601 standard

PiperOrigin-RevId: 329503623"," class GTestXMLTestCase(gtest_test_utils.TestCase):
 
 if element.tagName in ('testsuites', 'testsuite', 'testcase'):
 timestamp = element.getAttributeNode('timestamp')
- timestamp.value = re.sub(r'^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d$',
+ timestamp.value = re.sub(r'^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d\.\d\d\d$',
 '*', timestamp.value)
 if element.tagName in ('testsuites', 'testsuite', 'testcase'):
 time = element.getAttributeNode('time')
",103,23
"Googletest export

gtest.cc: make ColoredPrintf static

the prototype was removed from gtest.h in cl/301446904; quiets a
-Wmissing-declarations warning

PiperOrigin-RevId: 329569020"," bool ShouldUseColor(bool stdout_is_tty) {
 // This routine must actually emit the characters rather than return a string
 // that would be colored when printed, as can be done on Linux.
 
-void ColoredPrintf(GTestColor color, const char* fmt, ...) {
+static void ColoredPrintf(GTestColor color, const char* fmt, ...) {
 va_list args;
 va_start(args, fmt);
 
",4204,1014
Fix warning maybe-uninitialized," static void StackLowerThanAddress(const void* ptr,
 GTEST_ATTRIBUTE_NO_SANITIZE_ADDRESS_
 GTEST_ATTRIBUTE_NO_SANITIZE_HWADDRESS_
 static void StackLowerThanAddress(const void* ptr, bool* result) {
- int dummy;
+ int dummy = 0;
 *result = (&dummy < ptr);
 }
 
 static void StackLowerThanAddress(const void* ptr, bool* result) {
 GTEST_ATTRIBUTE_NO_SANITIZE_ADDRESS_
 GTEST_ATTRIBUTE_NO_SANITIZE_HWADDRESS_
 static bool StackGrowsDown() {
- int dummy;
+ int dummy = 0;
 bool result;
 StackLowerThanAddress(&dummy, &result);
 return result;
",973,172
"Googletest export

Revision of recent DoubleNearPredFormat change to support more toolchains.

isnan() is a macro in C99, and std::isnan() is a function in C++11. The previous change used `isnan` directly, and broke some tests in open source.

This CL changes it to follow the practice in gmock-matchers.h, and spell uses of isnan as
 (std::isnan)(f)
. The parens around `std::isnan` prevent it from being recognized as a macro in the preprocessor.

PiperOrigin-RevId: 333374377","
 #include ""gtest/gtest-spi.h""
 
 #include <ctype.h>
-#include <math.h>
 #include <stdarg.h>
 #include <stdio.h>
 #include <stdlib.h>

 
 #include <algorithm>
 #include <chrono> // NOLINT
+#include <cmath>
 #include <cstdint>
 #include <iomanip>
 #include <limits>
 AssertionResult DoubleNearPredFormat(const char* expr1,
 // requiring exotic floating-point knowledge.
 // Don't do an epsilon check if abs_error is zero because that implies
 // that an equality check was actually intended.
- if (!isnan(val1) && !isnan(val2) && abs_error > 0 && abs_error < epsilon) {
+ if (!(std::isnan)(val1) && !(std::isnan)(val2) && abs_error > 0 &&
+ abs_error < epsilon) {
 return AssertionFailure()
 << ""The difference between "" << expr1 << "" and "" << expr2 << "" is ""
 << diff << "", where\n""
",4203,1014
"Googletest export

Fix typo

PiperOrigin-RevId: 333745750"," using internal::FunctionMocker;
 ::testing::tuple_size<typename ::testing::internal::Function< \
 __VA_ARGS__>::ArgumentTuple>::value == _N, \
 ""This method does not take "" GMOCK_PP_STRINGIZE( \
- _N) "" arguments. Parenthesize all types with unproctected commas."")
+ _N) "" arguments. Parenthesize all types with unprotected commas."")
 
 #define GMOCK_INTERNAL_ASSERT_VALID_SPEC(_Spec) \
 GMOCK_PP_FOR_EACH(GMOCK_INTERNAL_ASSERT_VALID_SPEC_ELEMENT, ~, _Spec)
",20,2
"Googletest export

Update comment to suggest using SetUpTestSuite and TearDownTestSuite.

PiperOrigin-RevId: 334430329"," class GTEST_API_ Test {
 // class.
 static void TearDownTestSuite() {}
 
- // Legacy API is deprecated but still available
+ // Legacy API is deprecated but still available. Use SetUpTestSuite and
+ // TearDownTestSuite instead.
 #ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_
 static void TearDownTestCase() {}
 static void SetUpTestCase() {}
",763,129
"Googletest export

Fix undefined pointer comparison

PiperOrigin-RevId: 334436975","
 
 #include ""gtest/gtest-death-test.h""
 
+#include <functional>
 #include <utility>
 
 #include ""gtest/internal/gtest-port.h""
 GTEST_ATTRIBUTE_NO_SANITIZE_ADDRESS_
 GTEST_ATTRIBUTE_NO_SANITIZE_HWADDRESS_
 static void StackLowerThanAddress(const void* ptr, bool* result) {
 int dummy = 0;
- *result = (&dummy < ptr);
+ *result = std::less<const void*>()(&dummy, ptr);
 }
 
 // Make sure AddressSanitizer does not tamper with the stack here.
",974,172
Improve FilePath::Normalize method," FilePath FilePath::RemoveTrailingPathSeparator() const {
 // For example, ""bar///foo"" becomes ""bar/foo"". Does not eliminate other
 // redundancies that might be in a pathname involving ""."" or "".."".
 void FilePath::Normalize() {
- std::string normalized_pathname;
- normalized_pathname.reserve(pathname_.length());
+ auto out = pathname_.begin();
 
 for (const char character : pathname_) {
 if (!IsPathSeparator(character)) {
- normalized_pathname.push_back(character);
- } else if (normalized_pathname.empty() ||
- normalized_pathname.back() != kPathSeparator) {
- normalized_pathname.push_back(kPathSeparator);
+ *(out++) = character;
+ } else if (out == pathname_.begin() || *std::prev(out) != kPathSeparator) {
+ *(out++) = kPathSeparator;
 } else {
 continue;
 }
 }
 
- pathname_ = normalized_pathname;
+ pathname_.erase(out, pathname_.end());
 }
 
 } // namespace internal
",179,68
"Googletest export

Add helper methos to internal FlatTuple. Refactor constructors.

PiperOrigin-RevId: 336306681"," internal::ParamGenerator<typename Container::value_type> ValuesIn(
 namespace internal {
 // Used in the Values() function to provide polymorphic capabilities.
 
+#ifdef _MSC_VER
+#pragma warning(push)
+#pragma warning(disable : 4100)
+#endif
+
 template <typename... Ts>
 class ValueArray {
 public:
- ValueArray(Ts... v) : v_{std::move(v)...} {}
+ explicit ValueArray(Ts... v) : v_(std::move(v)...) {}
 
 template <typename T>
 operator ParamGenerator<T>() const { // NOLINT
 class ValueArray {
 FlatTuple<Ts...> v_;
 };
 
+#ifdef _MSC_VER
+#pragma warning(pop)
+#endif
+
 template <typename... T>
 class CartesianProductGenerator
 : public ParamGeneratorInterface<::std::tuple<T...>> {
",594,114
"Googletest export

Fix -Wmismatched-tags error with struct tuple_size vs class tuple_size

PiperOrigin-RevId: 336930166"," constexpr bool InstantiateTypedTestCase_P_IsDeprecated() { return true; }
 namespace std {
 
 template <typename... Ts>
-struct tuple_size<testing::internal::FlatTuple<Ts...>>
- : std::integral_constant<size_t, sizeof...(Ts)> {};
+class tuple_size<testing::internal::FlatTuple<Ts...>>
+ : public std::integral_constant<size_t, sizeof...(Ts)> {};
 
 } // namespace std
 
",698,97
"Googletest export

Disable -Wmismatched-tags warning for struct/class tuple_size

PiperOrigin-RevId: 337087493"," constexpr bool InstantiateTypedTestCase_P_IsDeprecated() { return true; }
 } // namespace testing
 
 namespace std {
-
+// Some standard library implementations use `struct tuple_size` and some use
+// `class tuple_size`. Clang warns about the mismatch.
+// https://reviews.llvm.org/D55466
+#ifdef __clang__
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored ""-Wmismatched-tags""
+#endif
 template <typename... Ts>
-class tuple_size<testing::internal::FlatTuple<Ts...>>
- : public std::integral_constant<size_t, sizeof...(Ts)> {};
-
+struct tuple_size<testing::internal::FlatTuple<Ts...>>
+ : std::integral_constant<size_t, sizeof...(Ts)> {};
+#ifdef __clang__
+#pragma clang diagnostic pop
+#endif
 } // namespace std
 
 #define GTEST_MESSAGE_AT_(file, line, message, result_type) \
",698,97
"Googletest export

Disable warnings on code that intentionally tests a suboptimal syntax

PiperOrigin-RevId: 337138442"," TEST(ImplicitCastTest, CanUseImplicitConstructor) {
 EXPECT_TRUE(converted);
 }
 
+// The following code intentionally tests a suboptimal syntax.
+#ifdef __GNUC__
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored ""-Wdangling-else""
+#pragma GCC diagnostic ignored ""-Wempty-body""
+#pragma GCC diagnostic ignored ""-Wpragmas""
+#endif
 TEST(GtestCheckSyntaxTest, BehavesLikeASingleStatement) {
 if (AlwaysFalse())
 GTEST_CHECK_(false) << ""This should never be executed; ""
 TEST(GtestCheckSyntaxTest, BehavesLikeASingleStatement) {
 else
 GTEST_CHECK_(true) << """";
 }
+#ifdef __GNUC__
+#pragma GCC diagnostic pop
+#endif
 
 TEST(GtestCheckSyntaxTest, WorksWithSwitch) {
 switch (0) {
",910,154
"Googletest export

Add ::testing::FieldsAre matcher for objects that support get<> and structured bindings.
PiperOrigin-RevId: 337165285"," struct DoubleSequence<false, IndexSequence<I...>, sizeofT> {
 // Backport of std::make_index_sequence.
 // It uses O(ln(N)) instantiation depth.
 template <size_t N>
-struct MakeIndexSequence
- : DoubleSequence<N % 2 == 1, typename MakeIndexSequence<N / 2>::type,
+struct MakeIndexSequenceImpl
+ : DoubleSequence<N % 2 == 1, typename MakeIndexSequenceImpl<N / 2>::type,
 N / 2>::type {};
 
 template <>
-struct MakeIndexSequence<0> : IndexSequence<> {};
+struct MakeIndexSequenceImpl<0> : IndexSequence<> {};
+
+template <size_t N>
+using MakeIndexSequence = typename MakeIndexSequenceImpl<N>::type;
+
+template <typename... T>
+using IndexSequenceFor = typename MakeIndexSequence<sizeof...(T)>::type;
 
 template <size_t>
 struct Ignore {
",702,97
"Googletest export

Fixes build warnings from previous CL
Add CMake to internal presubmit to prevent these

PiperOrigin-RevId: 337325504"," auto UnpackStruct(const T& t)
 // The array ensures left-to-right order of evaluation.
 // Usage: VariadicExpand({expr...});
 template <typename T, size_t N>
-void VariadicExpand(const T (&a)[N]) {}
+void VariadicExpand(const T (&)[N]) {}
 
 template <typename Struct, typename StructSize>
 class FieldsAreMatcherImpl;
 class FieldsAreMatcherImpl<Struct, IndexSequence<I...>>
 return good;
 }
 
- int failed_pos = -1;
+ size_t failed_pos = ~size_t{};
 
 std::vector<StringMatchResultListener> inner_listener(sizeof...(I));
 
 VariadicExpand(
- {failed_pos == -1 && !std::get<I>(matchers_).MatchAndExplain(
- std::get<I>(tuple), &inner_listener[I])
+ {failed_pos == ~size_t{} && !std::get<I>(matchers_).MatchAndExplain(
+ std::get<I>(tuple), &inner_listener[I])
 ? failed_pos = I
 : 0 ...});
 if (failed_pos != ~size_t{}) {
",3183,612
"Fix typo ""definedin in"" => ""defined in""

Replace ""definedin in"" by ""defined in"" in files:
- googletest/src/gtest.cc
- googletest/test/googletest-output-test-golden-lin.txt"," void TypeParameterizedTestSuiteRegistry::CheckForInstantiations() {
 ""utilities.)""
 ""\n\n""
 ""To suppress this error for this test suite, insert the following line ""
- ""(in a non-header) in the namespace it is definedin in:""
+ ""(in a non-header) in the namespace it is defined in:""
 ""\n\n""
 ""GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST("" +
 testcase.first + "");"";
",4203,1014
"Googletest export

Remove obsolete comment about non-const references.

They used to be banned by the C++ style guide, but positions shifted, and this comment is no longer up to date.

There's another reference (heh) on lines 816-819 to how gmock is a ""general framework"", with the possible implication that support for non-const references was weird in some way and only there to be ""general"", but I left it alone because I don't really feel I understand what it's saying.

PiperOrigin-RevId: 339323428"," class FloatingEqMatcher {
 // The following 3 type conversion operators allow FloatEq(expected) and
 // NanSensitiveFloatEq(expected) to be used as a Matcher<float>, a
 // Matcher<const float&>, or a Matcher<float&>, but nothing else.
- // (While Google's C++ coding style doesn't allow arguments passed
- // by non-const reference, we may see them in code not conforming to
- // the style. Therefore Google Mock needs to support them.)
 operator Matcher<FloatType>() const {
 return MakeMatcher(
 new Impl<FloatType>(expected_, nan_eq_nan_, max_abs_error_));
",3183,612
"Googletest export

Rewrite InvokeArgument action without using pump.

PiperOrigin-RevId: 340861582"," class ActionImpl<Derived<Ts...>> {
 std::tuple<Ts...> params_;
 };
 
-// internal::InvokeArgument - a helper for InvokeArgument action.
-// The basic overloads are provided here for generic functors.
-// Overloads for other custom-callables are provided in the
-// internal/custom/gmock-generated-actions.h header.
-template <typename F, typename... Args>
-auto InvokeArgument(F f, Args... args) -> decltype(f(args...)) {
- return f(args...);
-}
-
 #define GMOCK_INTERNAL_ARG_UNUSED(i, data, el) \
 , const arg##i##_type& arg##i GTEST_ATTRIBUTE_UNUSED_
 #define GMOCK_ACTION_ARG_TYPES_AND_NAMES_UNUSED_ \
",800,134
"Only save original working directory if death tests are enabled

On a diskless system you cannot get the current directory. So if
death tests are disabled anyway, there is no point trying to
get current directory.

Without this fix, running tests on diskless systems will fail,
even when death tests are disabled."," class GTEST_API_ UnitTestImpl {
 void AddTestInfo(internal::SetUpTestSuiteFunc set_up_tc,
 internal::TearDownTestSuiteFunc tear_down_tc,
 TestInfo* test_info) {
+#if GTEST_HAS_DEATH_TEST
 // In order to support thread-safe death tests, we need to
 // remember the original working directory when the test program
 // was first invoked. We cannot do this in RUN_ALL_TESTS(), as
 class GTEST_API_ UnitTestImpl {
 GTEST_CHECK_(!original_working_dir_.IsEmpty())
 << ""Failed to get the current working directory."";
 }
+#endif
 
 GetTestSuite(test_info->test_suite_name(), test_info->type_param(),
 set_up_tc, tear_down_tc)
",561,96
"Googletest export

GMock: Make Truly explain when it fails

I just wrote a test that had a matcher of the form
 Optional(AllOf(
 SomeMatcher,
 SomeOtherMatcher,
 Truly(SomePredicate)))

The predicate failed, the other two matchers succeeded, and I got a hard-to-interpret message saying that the value in the optional ""didn't match"". Didn't match what?

This change improves situations like that slightly by having Truly explain to its result listener when it fails. When there are multiple Trulys in an AllOf, there will be some ambiguity, but it will at least provide more information than right now.

PiperOrigin-RevId: 341105141"," class TrulyMatcher {
 // interested in the address of the argument.
 template <typename T>
 bool MatchAndExplain(T& x, // NOLINT
- MatchResultListener* /* listener */) const {
+ MatchResultListener* listener) const {
 // Without the if-statement, MSVC sometimes warns about converting
 // a value to bool (warning 4800).
 //
 class TrulyMatcher {
 // having no operator!().
 if (predicate_(x))
 return true;
+ *listener << ""didn't satisfy the given predicate"";
 return false;
 }
 
",3184,612
"Googletest export

Remove unreachable code when GTEST_CUSTOM_TEMPDIR_FUNCTION_ is defined.

PiperOrigin-RevId: 341810264"," void InitGoogleTest() {
 std::string TempDir() {
 #if defined(GTEST_CUSTOM_TEMPDIR_FUNCTION_)
 return GTEST_CUSTOM_TEMPDIR_FUNCTION_();
-#endif
-
-#if GTEST_OS_WINDOWS_MOBILE
+#elif GTEST_OS_WINDOWS_MOBILE
 return ""\\temp\\"";
 #elif GTEST_OS_WINDOWS
 const char* temp_dir = internal::posix::GetEnv(""TEMP"");
",4203,1014
"Googletest export

Fix *_THROW tests under MSVC, which produce slightly different type
names from std::type_info (e.g. ""class std::runtime_error"" instead of
""std::runtime_error"")

PiperOrigin-RevId: 341874178"," TEST_F(SingleEvaluationTest, OtherCases) {
 
 #if GTEST_HAS_RTTI
 
+#ifdef _MSC_VER
+#define ERROR_DESC ""class std::runtime_error""
+#else
 #define ERROR_DESC ""std::runtime_error""
+#endif
 
 #else // GTEST_HAS_RTTI
 
",5159,740
"Googletest export

Use a tagged constructor for FlatTuple instead.
Some versions of MSVC are getting confused with that constructor and generating invalid code.

PiperOrigin-RevId: 342050957"," struct InvokeArgumentAction {
 auto operator()(Args&&... args) const -> decltype(internal::InvokeArgument(
 std::get<index>(std::forward_as_tuple(std::forward<Args>(args)...)),
 std::declval<const Params&>()...)) {
- internal::FlatTuple<Args&&...> args_tuple(std::forward<Args>(args)...);
+ internal::FlatTuple<Args&&...> args_tuple(FlatTupleConstructTag{},
+ std::forward<Args>(args)...);
 return params.Apply([&](const Params&... unpacked_params) {
 auto&& callable = args_tuple.template Get<index>();
 return internal::InvokeArgument(
 template <std::size_t index, typename... Params>
 internal::InvokeArgumentAction<index, typename std::decay<Params>::type...>
 InvokeArgument(Params&&... params) {
 return {internal::FlatTuple<typename std::decay<Params>::type...>(
- std::forward<Params>(params)...)};
+ internal::FlatTupleConstructTag{}, std::forward<Params>(params)...)};
 }
 
 #ifdef _MSC_VER
",35,4
"Googletest export

Use environment variable TEST_TMPDIR in Linux environments
for temporary directory if available otherwise use /tmp/.

Bazel sets the environment variable TEST_TMPDIR when launching tests.

PiperOrigin-RevId: 342058921"," std::string TempDir() {
 return ""\\temp\\"";
 #elif GTEST_OS_WINDOWS
 const char* temp_dir = internal::posix::GetEnv(""TEMP"");
- if (temp_dir == nullptr || temp_dir[0] == '\0')
+ if (temp_dir == nullptr || temp_dir[0] == '\0') {
 return ""\\temp\\"";
- else if (temp_dir[strlen(temp_dir) - 1] == '\\')
+ } else if (temp_dir[strlen(temp_dir) - 1] == '\\') {
 return temp_dir;
- else
+ } else {
 return std::string(temp_dir) + ""\\"";
+ }
 #elif GTEST_OS_LINUX_ANDROID
 const char* temp_dir = internal::posix::GetEnv(""TEST_TMPDIR"");
- if (temp_dir == nullptr || temp_dir[0] == '\0')
+ if (temp_dir == nullptr || temp_dir[0] == '\0') {
 return ""/data/local/tmp/"";
- else
+ } else {
+ return temp_dir;
+ }
+#elif GTEST_OS_LINUX
+ const char* temp_dir = internal::posix::GetEnv(""TEST_TMPDIR"");
+ if (temp_dir == nullptr || temp_dir[0] == '\0') {
+ return ""/tmp/"";
+ } else {
 return temp_dir;
+ }
 #else
 return ""/tmp/"";
 #endif // GTEST_OS_WINDOWS_MOBILE
",4211,1017
"Initialize TestInfo member is_in_another_shard_ in constructor.

Signed-off-by: Vinson Lee <vlee@freedesktop.org>"," TestInfo::TestInfo(const std::string& a_test_suite_name,
 should_run_(false),
 is_disabled_(false),
 matches_filter_(false),
+ is_in_another_shard_(false),
 factory_(factory),
 result_() {}
 
",4212,1017
"Googletest export

Check for a high bit to see if a return value is a signal or an error code in googletest/test.

This is needed because for subprocess under python3 windows, a return value representing a C signal (such as 0x80000003) is represented as a large positive integer rather than a negative one.

PiperOrigin-RevId: 345270460"," class Subprocess:
 else: # os.WIFEXITED(ret_code) should return True here.
 self._return_code = os.WEXITSTATUS(ret_code)
 
- if self._return_code < 0:
+ if bool(self._return_code & 0x80000000):
 self.terminated_by_signal = True
 self.exited = False
- self.signal = -self._return_code
+ self.signal = (~self._return_code & 0x7fffffff) + 1
 else:
 self.terminated_by_signal = False
 self.exited = True
",135,40
"Googletest export

Remove `status` from our internal Subprocess utility.

This facility is unused, so better to just remove it than figure out what its cross-OS semantics should be.

PiperOrigin-RevId: 345279290"," class Subprocess:
 following attributes:
 terminated_by_signal True if and only if the child process has been
 terminated by a signal.
- signal Sygnal that terminated the child process.
 exited True if and only if the child process exited
 normally.
 exit_code The code with which the child process exited.
 class Subprocess:
 if bool(self._return_code & 0x80000000):
 self.terminated_by_signal = True
 self.exited = False
- self.signal = (~self._return_code & 0x7fffffff) + 1
 else:
 self.terminated_by_signal = False
 self.exited = True
",134,40
"Googletest export

Disable a gmock matcher test under MSVC 2015 (version 14) and earlier. It interacts badly with Windows structured exceptions in a way we do not have the resources to investigate. This test passes under MSVC 2017 and SEH.

PiperOrigin-RevId: 345496734"," struct MoveHelper {
 MOCK_METHOD1(Call, void(MoveOnly));
 };
 
+// Disable this test in VS 2015 (version 14), where it fails when SEH is enabled
+#if defined(_MSC_VER) && (_MSC_VER < 1910)
+TEST(ComparisonBaseTest, DISABLED_WorksWithMoveOnly) {
+#else
 TEST(ComparisonBaseTest, WorksWithMoveOnly) {
+#endif
 MoveOnly m{0};
 MoveHelper helper;
 
",6310,198
Fix typo in CLI help message," static const char kColorEncodedHelpMessage[] =
 "" List the names of all tests instead of running them. The name of\n""
 "" TEST(Foo, Bar) is \""Foo.Bar\"".\n""
 "" @G--"" GTEST_FLAG_PREFIX_
- ""filter=@YPOSTIVE_PATTERNS""
+ ""filter=@YPOSITIVE_PATTERNS""
 ""[@G-@YNEGATIVE_PATTERNS]@D\n""
 "" Run only the tests whose name matches one of the positive patterns ""
 ""but\n""
",4212,1017
"Googletest export

Add a `Pointer` matcher as an analog to `Pointee`.

Similar to `Pointee`, `Pointer` works with either raw or smart pointers and
allows creating a matcher like Pointer(Eq(foo)) for smart pointers.

PiperOrigin-RevId: 346164768"," TEST(ConvertIdentifierNameToWordsTest, WorksWhenNameIsMixture) {
 ConvertIdentifierNameToWords(""_Chapter11Section_1_""));
 }
 
-TEST(PointeeOfTest, WorksForSmartPointers) {
- EXPECT_TRUE(
- (std::is_same<int, PointeeOf<std::unique_ptr<int>>::type>::value));
- EXPECT_TRUE(
- (std::is_same<std::string,
- PointeeOf<std::shared_ptr<std::string>>::type>::value));
-}
-
-TEST(PointeeOfTest, WorksForRawPointers) {
- EXPECT_TRUE((std::is_same<int, PointeeOf<int*>::type>::value));
- EXPECT_TRUE((std::is_same<const char, PointeeOf<const char*>::type>::value));
- EXPECT_TRUE((std::is_void<PointeeOf<void*>::type>::value));
-}
-
 TEST(GetRawPointerTest, WorksForSmartPointers) {
 const char* const raw_p1 = new const char('a'); // NOLINT
 const std::unique_ptr<const char> p1(raw_p1);
",498,69
"Googletest export

Introduce a new `Address` matcher to gmock.

PiperOrigin-RevId: 346344591"," TEST(PointerTest, SmartPointerToConst) {
 EXPECT_FALSE(m.Matches(p));
 }
 
+TEST(AddressTest, NonConst) {
+ int n = 1;
+ const Matcher<int> m = Address(Eq(&n));
+
+ EXPECT_TRUE(m.Matches(n));
+
+ int other = 5;
+
+ EXPECT_FALSE(m.Matches(other));
+
+ int& n_ref = n;
+
+ EXPECT_TRUE(m.Matches(n_ref));
+}
+
+TEST(AddressTest, Const) {
+ const int n = 1;
+ const Matcher<int> m = Address(Eq(&n));
+
+ EXPECT_TRUE(m.Matches(n));
+
+ int other = 5;
+
+ EXPECT_FALSE(m.Matches(other));
+}
+
+TEST(AddressTest, MatcherDoesntCopy) {
+ std::unique_ptr<int> n(new int(1));
+ const Matcher<std::unique_ptr<int>> m = Address(Eq(&n));
+
+ EXPECT_TRUE(m.Matches(n));
+}
+
+TEST(AddressTest, Describe) {
+ Matcher<int> matcher = Address(_);
+ EXPECT_EQ(""has address that is anything"", Describe(matcher));
+ EXPECT_EQ(""does not have address that is anything"",
+ DescribeNegation(matcher));
+}
+
 MATCHER_P(FieldIIs, inner_matcher, """") {
 return ExplainMatchResult(inner_matcher, arg.i, result_listener);
 }
",6376,198
[expat] working build & simple fuzzer from chrome.,"
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include <vector>
+#include ""expat.h""
+
+std::vector<const char*> kEncodings = {{""UTF-16"", ""UTF-8"", ""ISO-8859-1"",
+ ""US-ASCII"", ""UTF-16BE"", ""UTF-16LE"",
+ ""INVALIDENCODING""}};
+// Entry point for LibFuzzer.
+extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
+ const char* dataPtr = reinterpret_cast<const char*>(data);
+ for (int use_ns = 0; use_ns <= 1; ++use_ns) {
+ for (auto enc : kEncodings) {
+ XML_Parser parser =
+ use_ns ? XML_ParserCreateNS(enc, '\n') : XML_ParserCreate(enc);
+ XML_Parse(parser, dataPtr, size, true);
+ XML_ParserFree(parser);
+ }
+ }
+ return 0;
+}
",17,4
"zlib fuzzer

contributed by inferno@chromium.org","
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include <stddef.h>
+#include <stdint.h>
+#include <string.h>
+
+#include ""zlib.h""
+
+static Bytef buffer[256 * 1024] = { 0 };
+
+// Entry point for LibFuzzer.
+extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
+ uLongf buffer_length = static_cast<uLongf>(sizeof(buffer));
+ if (Z_OK != uncompress(buffer, &buffer_length, data,
+ static_cast<uLong>(size))) {
+ return 0;
+ }
+ return 0;
+}
",13,2
"[helper] generated build.sh fixes

- fix permissions to allow execute
- add examples to template"," def generate(generate_args):
 with open(os.path.join(args.library_name, 'Dockerfile'), 'w') as f:
 f.write(templates.DOCKER_TEMPLATE % args.library_name)
 
- with open(os.path.join(args.library_name, 'build.sh'), 'w') as f:
+ build_sh_path = os.path.join(args.library_name, 'build.sh')
+ with open(build_sh_path, 'w') as f:
 f.write(templates.BUILD_TEMPLATE % args.library_name)
 
+ os.chmod(build_sh_path, 0755)
 return 0
 
 
",157,32
[helper] git clone recursively," def _checkout(library_name, checkout_dir):
 
 try:
 subprocess.check_call([
- 'git', 'clone', vcs_url, checkout_dir])
+ 'git', 'clone', '--recursive', vcs_url, checkout_dir])
 except subprocess.CalledProcessError:
 print('Failed to git clone.', file=sys.stderr)
 return False
 def _update_checkout(library_name, checkout_dir):
 subprocess.check_call(['git', 'checkout', '.'])
 subprocess.check_call(['git', 'fetch'])
 subprocess.check_call(['git', 'checkout', 'origin/master'])
+
+ if os.path.exists(os.path.join(checkout_dir, '.gitmodules')):
+ subprocess.check_call(['git', 'submodule', 'update', '--recursive'])
+
 except subprocess.CalledProcessError:
 print('Failed to update checkout.', file=sys.stderr)
 result = False
",159,33
"[libchewing] first fuzzer

libchewing is a library for Chinese character input.","
+#include <stddef.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <libgen.h>
+
+static const uint8_t* fuzz_ptr;
+static const uint8_t* fuzz_input;
+static size_t fuzz_size;
+
+int stress_main(int argc, char** argv);
+
+ int LLVMFuzzerInitialize(int* argc, char*** argv) {
+ char* exe_path = (*argv)[0];
+ char* dir = dirname(exe_path);
+ // Assume data files are at the same location as executable.
+ setenv(""CHEWING_PATH"", dir, 0);
+ setenv(""CHEWING_USER_PATH"", dir, 0);
+ return 0;
+ }
+
+int get_fuzz_input() {
+ if (fuzz_ptr - fuzz_input >= fuzz_size)
+ return EOF;
+ return *fuzz_ptr++;
+}
+
+int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
+ fuzz_input = fuzz_ptr = data;
+ fuzz_size = size;
+
+ const char *stress_argv[] = {
+ ""./chewing_fuzzer"",
+ ""-extra"",
+ ""-loop"", ""1"",
+ NULL,
+ };
+ stress_main(4, (char**)stress_argv);
+ return 0;
+}
",33,4
"[infra] fixing build script location (/src/build.sh)

Fixing the location of build.sh gets rid of ENTRYPOINT. Which opens a possibility to implement different commands like:

````bash
docker run -ti expat compile
docker run -ti expat run <fuzzer_name> <input_data>
````

and keep the knowledge of build script location.

This is a breaking change."," def generate(generate_args):
 f.write(templates.JENKINS_TEMPLATE)
 
 with open(os.path.join(args.library_name, 'Dockerfile'), 'w') as f:
- f.write(templates.DOCKER_TEMPLATE % args.library_name)
+ f.write(templates.DOCKER_TEMPLATE)
 
 build_sh_path = os.path.join(args.library_name, 'build.sh')
 with open(build_sh_path, 'w') as f:
",191,40
"[WIP] Add libnss build and 15 fuzzers from crrev.com/1677803002. (#12)

* Add libnss build and 15 fuzzers from crrev.com/1677803002.

* Added missing $LDFLAGS and used /out/*.a.

* Another attempt to link statically. The best one so far.

* Manually linking with nspr/Linux*/pr/src/misc/prlog2.o.

* Cleanup nss/buil.sh script and disable 2 of 15 nss fuzzers for now.

* Fix comments.","
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include <secoid.h>
+#include <stddef.h>
+#include <stdint.h>
+
+#include ""asn1_fuzzer_template.h""
+
+// Entry point for LibFuzzer.
+extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
+ NSSFuzzOneInput<SECAlgorithmID, SEC_QuickDERDecodeItem>(
+ SEC_ASN1_GET(SECOID_AlgorithmIDTemplate), data, size);
+ NSSFuzzOneInput<SECAlgorithmID, SEC_ASN1DecodeItem>(
+ SEC_ASN1_GET(SECOID_AlgorithmIDTemplate), data, size);
+
+ return 0;
+}
",11,1
Add convert_woff2ttf_fuzzer fuzzer for woff2.,"
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include <stddef.h>
+#include <stdint.h>
+
+#include ""woff2_dec.h""
+
+// Entry point for LibFuzzer.
+extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
+ std::string buf;
+ woff2::WOFF2StringOut out(&buf);
+ out.SetMaxSize(30 * 1024 * 1024);
+ woff2::ConvertWOFF2ToTTF(data, size, &out);
+ return 0;
+}
",10,1
"[infra] do not checkout oss-fuzz (#23)

Promising oss-fuzz in /src/oss-fuzz creates lots of confusion about where files come from.
Let's make everything explicit.

Fixes #20"," def shell(shell_args):
 
 command = [
 'docker', 'run', '-i',
- '-v', '%s:/src/oss-fuzz' % OSSFUZZ_DIR,
 '-v', '%s:/src/%s' % (checkout_dir, args.library_name),
 '-v', '%s:/out' % os.path.join(BUILD_DIR, 'out', args.library_name),
 '-t', 'ossfuzz/' + args.library_name,
",190,40
Simple fuzzer for nlohmann/json library (#27)," def build_fuzzers(build_args):
 
 def run_fuzzer(run_args):
 """"""Runs a fuzzer in the container.""""""
- parser = argparse.ArgumentParser('helper.py build_fuzzers')
+ parser = argparse.ArgumentParser('helper.py run_fuzzer')
 parser.add_argument('library_name', help='name of the library')
 parser.add_argument('fuzzer_name', help='name of the fuzzer')
 parser.add_argument('fuzzer_args', help='arguments to pass to the fuzzer',
",190,40
use --pull to build docker images," def build_image(build_args):
 return 1
 
 command = [
- 'docker', 'build', '-t', 'ossfuzz/' + args.library_name,
+ 'docker', 'build', '--pull', '-t', 'ossfuzz/' + args.library_name,
 args.library_name
 ]
 print('Running:', _get_command_string(command))
",190,40
"Fix chewing_fuzzer.

Set CHEWING_USER_PATH to /tmp instead, since the executable directory is
read only on CF. Should fix #13."," int stress_main(int argc, char** argv);
 char* dir = dirname(exe_path);
 // Assume data files are at the same location as executable.
 setenv(""CHEWING_PATH"", dir, 0);
- setenv(""CHEWING_USER_PATH"", dir, 0);
+ setenv(""CHEWING_USER_PATH"", ""/tmp"", 0);
 return 0;
 }
 
",33,4
[icu] icu fuzzers from chrome,"
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+// Fuzzer for NumberFormat::parse.
+
+#include <stddef.h>
+#include <stdint.h>
+#include <memory>
+#include ""fuzzer_utils.h""
+#include ""unicode/numfmt.h""
+
+IcuEnvironment* env = new IcuEnvironment();
+
+extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
+ UErrorCode status = U_ZERO_ERROR;
+
+ auto rng = CreateRng(data, size);
+ const icu::Locale& locale = GetRandomLocale(&rng);
+
+ std::unique_ptr<icu::NumberFormat> fmt(
+ icu::NumberFormat::createInstance(locale, status));
+ if (U_FAILURE(status)) return 0;
+
+ icu::UnicodeString str(UnicodeStringFromUtf8(data, size));
+ icu::Formattable result;
+ fmt->parse(str, result, status);
+
+ return 0;
+}
",18,2
add fuzzer for libteken (#47),"
+#include <stdint.h>
+#include <stdio.h>
+
+#include <teken.h>
+
+static void dummy_bell(void *s) {}
+static void dummy_cursor(void *s, const teken_pos_t *p) {}
+static void dummy_putchar(void *s, const teken_pos_t *p, teken_char_t c,
+ const teken_attr_t *a) {}
+static void dummy_fill(void *s, const teken_rect_t *r, teken_char_t c,
+ const teken_attr_t *a) {}
+static void dummy_copy(void *s, const teken_rect_t *r, const teken_pos_t *p) {}
+static void dummy_param(void *s, int cmd, unsigned int value) {}
+static void dummy_respond(void *s, const void *buf, size_t len) {}
+
+static teken_funcs_t tf = {
+ .tf_bell = dummy_bell,
+ .tf_cursor = dummy_cursor,
+ .tf_putchar = dummy_putchar,
+ .tf_fill = dummy_fill,
+ .tf_copy = dummy_copy,
+ .tf_param = dummy_param,
+ .tf_respond = dummy_respond,
+};
+
+int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
+ teken_t t;
+ teken_init(&t, &tf, NULL);
+ teken_input(&t, data, size);
+ return 0;
+}
",27,8
"Revise chewing fuzzer (#48)

1. Specify unique name for temp userdb. So we can run multiple fuzzers
 at the same time.
2. Reorganized as three fuzzers for different variants. So we can
 prioritize easily (default first, dynamic config last)","
+#include <stdio.h>
+
+#include ""chewing_fuzzer_common.h""
+
+int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
+ fuzz_input = fuzz_ptr = data;
+ fuzz_size = size;
+
+ const char* stress_argv[] = {
+ ""./chewing_fuzzer"", ""-loop"", ""1"", NULL,
+ };
+ stress_main(sizeof(stress_argv) / sizeof(stress_argv[0]) - 1,
+ (char**)stress_argv);
+ return 0;
+}
",12,1
libchewing: modify fuzzing parameter (#51)," int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
 fuzz_size = size;
 
 const char* stress_argv[] = {
- ""./chewing_fuzzer"", ""-loop"", ""1"", ""-init"", ""-extra"", NULL,
+ ""./chewing_fuzzer"", ""-loop"", ""1"", ""-init"", NULL,
 };
 stress_main(sizeof(stress_argv) / sizeof(stress_argv[0]) - 1,
 (char**)stress_argv);
",12,1
"helper.py run should use .options file

It is very unfortunate, but we have to copy the file. I'll think
how it is possible to restructure our images to avoid duplication.

Issue #19"," def run_fuzzer(run_args):
 'docker', 'run', '-i',
 '-v', '%s:/out' % os.path.join(BUILD_DIR, 'out'),
 '-t', 'ossfuzz/libfuzzer-runner',
+ 'run_fuzzer',
 '/out/%s/%s' %(args.target_name, args.fuzzer_name)
 ] + args.fuzzer_args
 
",197,32
file (aka libmagic) fuzzers. Fixes #63,"
+// Copyright 2016 Google Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the ""License"");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an ""AS IS"" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#include <stddef.h>
+#include <stdint.h>
+
+#include <magic.h>
+
+extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
+ if (size < 1)
+ return 0;
+ 
+ magic_t magic = magic_open(MAGIC_NONE);
+ magic_buffer(magic, data, size);
+ magic_close(magic);
+ return 0;
+}
",11,2
folding coverage into base-libfuzzer since target images is where sources are," def coverage(run_args):
 'docker', 'run', '-i',
 '-v', '%s:/out' % os.path.join(BUILD_DIR, 'out', args.target_name),
 '-v', '%s:/cov' % temp_dir,
- '-v', '%s:/scripts' % os.path.join(OSSFUZZ_DIR, 'scripts'),
 '-w', '/cov',
 '-p', '8001:8001',
- '-t', 'ossfuzz/coverage',
- '/src/coverage/coverage', '/out/%s' % args.fuzzer_name,
+ '-t', 'ossfuzz/%s' % args.target_name,
+ 'coverage_report', '/out/%s' % args.fuzzer_name,
 ]
 
 print('Running:', _get_command_string(command))
",196,32
[ots] Add ots_fuzzer with seed corpus from Chromium repository.,"
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include <stddef.h>
+#include <stdint.h>
+
+#include ""opentype-sanitiser.h""
+#include ""ots-memory-stream.h""
+
+static uint8_t buffer[256 * 1024] = { 0 };
+
+// Entry point for LibFuzzer.
+extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
+ ots::OTSContext context;
+ ots::MemoryStream stream(static_cast<void*>(buffer), sizeof(buffer));
+ context.Process(&stream, data, size);
+ return 0;
+}
",11,1
Use the newer python octal literal syntax (#70)," def generate(generate_args):
 with open(build_sh_path, 'w') as f:
 f.write(templates.BUILD_TEMPLATE % args.target_name)
 
- os.chmod(build_sh_path, 0755)
+ os.chmod(build_sh_path, 0o755)
 return 0
 
 
",196,32
Make error handling around already existing directories more precise (#71),"
 
 from __future__ import print_function
 import argparse
+import errno
 import os
 import pipes
 import re
 def generate(generate_args):
 
 try:
 os.mkdir(dir)
- except OSError:
+ except OSError as e:
+ if e.errno != errno.EEXIST:
+ raise
 print(dir, 'already exists.', file=sys.stderr)
 return 1
 
",199,33
libmagic needs magic file to work,"
 
 #include <stddef.h>
 #include <stdint.h>
+#include <stdio.h>
+#include <stdlib.h>
 
 #include <magic.h>
 
+struct Environment {
+ Environment() {
+ magic = magic_open(MAGIC_NONE);
+ if (magic_load(magic, ""magic"")) {
+ fprintf(stderr, ""error loading magic file: %s\n"", magic_error(magic));
+ exit(1);
+ }
+ }
+
+ magic_t magic;
+};
+
+static Environment env;
+
 extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
 if (size < 1)
 return 0;
- 
- magic_t magic = magic_open(MAGIC_NONE);
- magic_buffer(magic, data, size);
- magic_close(magic);
+ magic_buffer(env.magic, data, size);
 return 0;
 }
",22,4
"Add fuzzers for lcms. Fixes #43 (#77)

cmsIT8_load_fuzzer is ported from
https://github.com/google/libfuzzer-bot/tree/master/dockerfiles/lcms2

cms_transform_fuzzer is simplified from pdfium's usage
https://pdfium.googlesource.com/pdfium/+/master/testing/libfuzzer/pdf_codec_icc_fuzzer.cc","
+// Copyright 2016 Google Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the ""License"");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an ""AS IS"" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+////////////////////////////////////////////////////////////////////////////////
+
+#include <stdint.h>
+
+#include ""lcms2.h""
+
+// The main sink
+int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
+ if (size == 0)
+ return 0;
+
+ cmsHANDLE handle = cmsIT8LoadFromMem(0, (void *)data, size);
+ if (handle)
+ cmsIT8Free(handle);
+
+ return 0;
+}
",10,3
[infra] setting current directory to src checkout (#87)," def generate(generate_args):
 
 print('Writing new files to', dir)
 
+ template_args = {
+ 'target_name' : args.target_name
+ }
 with open(os.path.join(dir, 'Jenkinsfile'), 'w') as f:
- f.write(templates.JENKINS_TEMPLATE)
+ f.write(templates.JENKINS_TEMPLATE % template_args)
 
 with open(os.path.join(dir, 'Dockerfile'), 'w') as f:
- f.write(templates.DOCKER_TEMPLATE)
+ f.write(templates.DOCKER_TEMPLATE % template_args)
 
 build_sh_path = os.path.join(dir, 'build.sh')
 with open(build_sh_path, 'w') as f:
- f.write(templates.BUILD_TEMPLATE % args.target_name)
+ f.write(templates.BUILD_TEMPLATE % template_args)
 
 targets_readme_path = os.path.join('targets', 'README.md')
 update_targets_readme(targets_readme_path, args.target_name, dir)
",250,51
auto setup: get libraries list from local checkout instead.," def main():
 
 def get_libraries():
 """"""Return list of libraries for oss-fuzz.""""""
- OSSFUZZ_TREE_URL = ('https://api.github.com/repos/google/oss-fuzz/'
- 'git/trees/master')
- tree = json.loads(urllib2.urlopen(OSSFUZZ_TREE_URL).read())
 libraries = []
-
- targets_url = None
-
- for item in tree['tree']:
- if item['path'] == 'targets':
- targets_url = item['url']
- break
-
- if not targets_url:
- print >>sys.stderr, 'No libraries found.'
- return []
-
- tree = json.loads(urllib2.urlopen(targets_url).read())
- for item in tree['tree']:
- if item['type'] != 'tree':
- continue
-
- libraries.append(item['path'])
+ listing = os.listdir('../targets')
+ for name in listing:
+ if os.path.isdir(name):
+ libraries.append(name)
 
 return libraries
 
",43,9
auto setup: fix listdir path," BUILD_BUCKET = 'clusterfuzz-builds'
 JENKINS_SERVER = ('localhost', 8080)
 
 SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
+OSSFUZZ_DIR = os.path.dirname(os.path.dirname(SCRIPT_DIR))
 
 
 def main():
 def main():
 def get_libraries():
 """"""Return list of libraries for oss-fuzz.""""""
 libraries = []
- listing = os.listdir('../targets')
+ listing = os.listdir(os.path.join(OSSFUZZ_DIR, 'targets'))
 for name in listing:
 if os.path.isdir(name):
 libraries.append(name)
",46,10
auto setup: really fix dir checking," def main():
 def get_libraries():
 """"""Return list of libraries for oss-fuzz.""""""
 libraries = []
- listing = os.listdir(os.path.join(OSSFUZZ_DIR, 'targets'))
- for name in listing:
- if os.path.isdir(name):
+ targets_dir = os.path.join(OSSFUZZ_DIR, 'targets')
+ for name in os.listdir(targets_dir):
+ if os.path.isdir(os.path.join(targets_dir, name)):
 libraries.append(name)
 
 if not libraries:
",46,10
[infra] escape target definition to be passed as string," def sync_jenkins_job(server, library):
 """"""Sync the config with jenkins.""""""
 target_yaml = os.path.join(OSSFUZZ_DIR, 'targets', library, 'target.yaml')
 with open(target_yaml, 'r') as f:
- print json.dumps(yaml.load(f))
+ print json.dumps(json.dumps(yaml.load(f)))
 
 job_name = 'targets/' + library
 if server.job_exists(job_name):
",50,10
[infra] always reconfiguring existing job," def sync_jenkins_job(server, library):
 print json.dumps(json.dumps(yaml.load(f)))
 
 job_name = 'targets/' + library
- if server.job_exists(job_name):
- # Job already set up.
- # TODO(ochang): Also update jobs if the definition is different.
- return
-
 job_definition = ET.parse(os.path.join(SCRIPT_DIR, 'jenkins_config',
 'base_job.xml'))
 jenkinsfile_location = job_definition.findall('.//definition/scriptPath')[0]
 jenkinsfile_location.text = 'targets/%s/Jenkinsfile' % library
+ job_config_xml = ET.tostring(job_definition.getroot())
 
- server.create_job(job_name, ET.tostring(job_definition.getroot()))
- server.build_job(job_name)
+ if server.job_exists(job_name):
+ server.reconfig_job(job_name, job_config_xml)
+ else:
+ server.create_job(job_name, job_config_xml)
+ server.build_job(job_name)
 
 
 if __name__ == '__main__':
",52,10
[infra] do not update jenkinsfile," def sync_jenkins_job(server, library):
 job_name = 'targets/' + library
 job_definition = ET.parse(os.path.join(SCRIPT_DIR, 'jenkins_config',
 'base_job.xml'))
- jenkinsfile_location = job_definition.findall('.//definition/scriptPath')[0]
- jenkinsfile_location.text = 'targets/%s/Jenkinsfile' % library
+ # jenkinsfile_location = job_definition.findall('.//definition/scriptPath')[0]
+ # jenkinsfile_location.text = 'targets/%s/Jenkinsfile' % library
 job_config_xml = ET.tostring(job_definition.getroot())
 
 if server.job_exists(job_name):
",50,10
[infra] specifying default build script," JENKINS_SERVER = ('localhost', 8080)
 SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
 OSSFUZZ_DIR = os.path.dirname(os.path.dirname(SCRIPT_DIR))
 
+SCRIPT_TEMPLATE = """"""
+def libfuzzerBuild = fileLoader.fromGit('infra/libfuzzer-pipeline.groovy',
+ 'https://github.com/google/oss-fuzz.git')
+
+libfuzzerBuild { }
+""""""
 
 def main():
 # Connect to jenkins server.
 def sync_jenkins_job(server, library):
 job_name = 'targets/' + library
 job_definition = ET.parse(os.path.join(SCRIPT_DIR, 'jenkins_config',
 'base_job.xml'))
- # jenkinsfile_location = job_definition.findall('.//definition/scriptPath')[0]
- # jenkinsfile_location.text = 'targets/%s/Jenkinsfile' % library
+ script = job_definition.findall('.//definition/script')[0]
+ script.text = SCRIPT_TEMPLATE
 job_config_xml = ET.tostring(job_definition.getroot())
 
 if server.job_exists(job_name):
",58,10
"Avoid yaml.load, and prefer yaml.safe_load (#95)

yaml.load ought to be named yaml.danger_load: it can execute arbitrary code (http://pyyaml.org/wiki/PyYAMLDocumentation#LoadingYAML)"," def sync_jenkins_job(server, library):
 """"""Sync the config with jenkins.""""""
 target_yaml = os.path.join(OSSFUZZ_DIR, 'targets', library, 'target.yaml')
 with open(target_yaml, 'r') as f:
- target_json_string = json.dumps(json.dumps(yaml.load(f)))
+ target_json_string = json.dumps(json.dumps(yaml.safe_load(f)))
 
 job_name = 'targets/' + library
 job_definition = ET.parse(os.path.join(SCRIPT_DIR, 'jenkins_config',
",56,10
[infra] using project instead of target," def get_build_results(server):
 for job in server.get_jobs(1):
 try:
 name = job['fullname']
- if not name.startswith('targets/'):
+ if not name.startswith('projects/'):
 continue
 
 print name
- library = name[len('targets/'):]
+ library = name[len('projects/'):]
 
 info = server.get_job_info(name)
 last_build_number = info['lastCompletedBuild']['number']
",70,11
[infra] generate project.yaml instead of Jenkinsfile," def generate(generate_args):
 template_args = {
 'project_name' : args.project_name
 }
- with open(os.path.join(dir, 'Jenkinsfile'), 'w') as f:
- f.write(templates.JENKINS_TEMPLATE % template_args)
+ with open(os.path.join(dir, 'project.yaml'), 'w') as f:
+ f.write(templates.PROJECT_YAML_TEMPLATE % template_args)
 
 with open(os.path.join(dir, 'Dockerfile'), 'w') as f:
 f.write(templates.DOCKER_TEMPLATE % template_args)
",210,38
"[infra] project, not library"," def get_build_results(server):
 continue
 
 print name
- library = name[len('projects/'):]
+ project = name[len('projects/'):]
 
 info = server.get_job_info(name)
 last_build_number = info['lastCompletedBuild']['number']
 def get_build_results(server):
 
 if last_build_number == last_failed_builder_number:
 failures.append(Result(
- library,
+ project,
 server.get_build_console_output(name, last_build_number)))
 else:
 successes.append(Result(
- library,
+ project,
 server.get_build_console_output(name, last_build_number)))
 except Exception:
 pass
",70,11
"helper coverage: add message about the command taking a long time.

Also suppresses output from the fuzzer itself."," def coverage(run_args):
 ] + args.fuzzer_args
 
 print('Running:', _get_command_string(command))
- pipe = subprocess.Popen(command)
- pipe.communicate()
+ print('This may take a while (running your fuzzer for %d seconds)...' %
+ args.run_time)
+ with open(os.devnull, 'w') as f:
+ pipe = subprocess.Popen(command, stdout=f, stderr=subprocess.STDOUT)
+ pipe.communicate()
 
 command = [
 'docker', 'run', '-i',
 def generate(generate_args):
 
 template_args = {
 'project_name' : args.project_name
- }
+ }
 with open(os.path.join(dir, 'project.yaml'), 'w') as f:
 f.write(templates.PROJECT_YAML_TEMPLATE % template_args)
 
",213,38
"Add the libyaml fuzzer (#115)

* libyaml fuzzer

* Update for new modern conventions

* added seed corpus

* added a dictionary

* mark myself as the primary contact

* Rename

* --depth on git clone

* rename

* consistency

* Other URL is better","
+#include <stdint.h>
+
+#include <yaml.h>
+
+extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
+ yaml_parser_t parser;
+ yaml_parser_initialize(&parser);
+ yaml_parser_set_input_string(&parser, data, size);
+
+ int done = 0;
+ while (!done) {
+ yaml_event_t event;
+ if (!yaml_parser_parse(&parser, &event)) {
+ break;
+ }
+ done = (event.type == YAML_STREAM_END_EVENT);
+ yaml_event_delete(&event);
+ }
+ yaml_parser_delete(&parser);
+ return 0;
+}
",18,3
Update build_status.py," def get_build_results(server):
 successes.append(Result(
 project,
 server.get_build_console_output(name, last_build_number)))
- except Exception:
- pass
+ except Exception as e:
+ print >>sys.stderr, e
 
 return successes, failures
 
",70,11
"bind mount work dir (#176)

with python infra/helper.py build_fuzzers <PROJECT>

out of the box I get /work as a dir in the docker image root with approx 6 gigs
free after dependencies are installed, i.e.

Filesystem Size Used Avail Use% Mounted on
/dev/mapper/docker-.. 10G 3.9G 6.2G 39% /

which is limiting for a very large project, how about binding /work to the host
like /out already is, eg. for me afterwards, plenty of work space

Filesystem Size Used Avail Use% Mounted on
/dev/sda1 440G 291G 128G 70% /work

(cherry picked from commit fffffb107dc7421b91b884c0019c62e43779c4b1)"," def build_fuzzers(build_args):
 command = [
 'docker', 'run', '--rm', '-i',
 '-v', '%s:/out' % os.path.join(BUILD_DIR, 'out', args.project_name),
+ '-v', '%s:/work' % os.path.join(BUILD_DIR, 'work', args.project_name),
 '-t', 'ossfuzz/' + args.project_name,
 ]
 
 def shell(shell_args):
 command = [
 'docker', 'run', '--rm', '-i',
 '-v', '%s:/out' % os.path.join(BUILD_DIR, 'out', args.project_name),
+ '-v', '%s:/work' % os.path.join(BUILD_DIR, 'work', args.project_name),
 '-t', 'ossfuzz/' + args.project_name,
 '/bin/bash'
 ]
",215,38
[infra] using base-runner for running," def run_fuzzer(run_args):
 command = [
 'docker', 'run', '--rm', '-i',
 '-v', '%s:/out' % os.path.join(BUILD_DIR, 'out', args.project_name),
- '-t', 'ossfuzz/libfuzzer-runner',
+ '-t', 'ossfuzz/base-runner',
 'run_fuzzer',
 '/out/%s' % args.fuzzer_name,
 ] + args.fuzzer_args
",215,38
Fix run_fuzzer to use base-runner image for building. (#178)," def run_fuzzer(run_args):
 if not _check_fuzzer_exists(args.project_name, args.fuzzer_name):
 return 1
 
- if not _build_image('libfuzzer-runner'):
+ if not _build_image('base-runner'):
 return 1
 
 command = [
 def coverage(run_args):
 if not _check_fuzzer_exists(args.project_name, args.fuzzer_name):
 return 1
 
- if not _build_image('libfuzzer-runner'):
+ if not _build_image('base-runner'):
 return 1
 
 temp_dir = tempfile.mkdtemp()
 def coverage(run_args):
 '-v', '%s:/cov' % temp_dir,
 '-w', '/cov',
 '-e', 'ASAN_OPTIONS=coverage=1,detect_leaks=0',
- '-t', 'ossfuzz/libfuzzer-runner',
+ '-t', 'ossfuzz/base-runner',
 '/out/%s' % args.fuzzer_name,
 '-max_total_time=%s' % args.run_time
 ] + args.fuzzer_args
",215,38
"[infra] use $BUILD_UID if it is defined (fixes #30) (#211)

If $BUILD_UID is defined, then compile script will create a user
with a given UID and switch to it prior to calling project's build.sh."," def build_fuzzers(build_args):
 
 command = [
 'docker', 'run', '--rm', '-i', '--cap-add', 'SYS_PTRACE',
+ '-e', 'BUILD_UID=%d' % os.getuid(),
 '-v', '%s:/out' % os.path.join(BUILD_DIR, 'out', args.project_name),
 '-v', '%s:/work' % os.path.join(BUILD_DIR, 'work', args.project_name),
 '-t', 'ossfuzz/' + args.project_name,
",216,38
[infra] unwrap result object," def upload_status(successes, failures):
 """"""Upload main status page.""""""
 env = Environment(loader=FileSystemLoader(os.path.join(SCRIPT_DIR,
 'templates')))
+ failures = [f.name for f in failures]
+ successes = [s.name for s in successes]
+ 
 data = {
 'projects': failures + successes,
 'failures': failures,
",83,13
Don't overflow on multiplication in the libjpeg_turbo fuzzer (#218)," extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
 jpegDecompressor, data, size, &width, &height, &subsamp, &colorspace);
 
 // Bail out if decompressing the headers failed, the width or height is 0,
- // or the image is too large (avoids slowing down too much)
- if (res != 0 || width == 0 || height == 0 || (width * height > (1024 * 1024))) {
+ // or the image is too large (avoids slowing down too much). Cast to size_t to
+ // avoid overflows on the multiplication
+ if (res != 0 || width == 0 || height == 0 || ((size_t)width * height > (1024 * 1024))) {
 tjDestroy(jpegDecompressor);
 return 0;
 }
",19,5
[infra] some builds never fail," def get_build_results(server):
 
 info = server.get_job_info(name)
 last_build_number = info['lastCompletedBuild']['number']
- last_failed_builder_number = info['lastFailedBuild']['number']
+ 
+ if info['lastFailedBuild']:
+ last_failed_builder_number = info['lastFailedBuild']['number']
 
 if last_build_number == last_failed_builder_number:
 failures.append(Result(
",84,14
[info] printing out job info," import codecs
 import datetime
 import json
 import os
+import pprint
 import subprocess
 import sys
 import traceback
 def get_build_results(server):
 project = name[len('projects/'):]
 
 info = server.get_job_info(name)
+ pprint.pprint(info)
 last_build_number = info['lastCompletedBuild']['number']
 
 if info['lastFailedBuild']:
",86,14
[infra] removed debug output," import codecs
 import datetime
 import json
 import os
-import pprint
 import subprocess
 import sys
 import traceback
 def get_build_results(server):
 project = name[len('projects/'):]
 
 info = server.get_job_info(name)
- pprint.pprint(info)
 last_build_number = info['lastCompletedBuild']['number']
 build_result = Result(
 project,
",90,16
[infra] unwrapping value," def upload_status(successes, failures, unstable):
 'templates')))
 failures = [f.name for f in failures]
 successes = [s.name for s in successes]
+ unstable = [p.name for p in unstable]
 
 data = {
 'projects': failures + successes,
",91,17
[infra] missing unstable builds," def upload_status(successes, failures, unstable):
 unstable = [p.name for p in unstable]
 
 data = {
- 'projects': failures + successes,
+ 'projects': failures + successes + unstable,
 'failures': failures,
 'successes': successes,
 'unstable': unstable,
",91,17
Cache-Control: no-cache on build status pages.," def upload_status(successes, failures, unstable):
 with open('status.json', 'w') as f:
 f.write(json.dumps(data))
 
- subprocess.check_output(['gsutil', 'cp', 'status.json', 'gs://' +
- LOGS_BUCKET], stderr=subprocess.STDOUT)
+ subprocess.check_output(['gsutil', '-h', 'Cache-Control: no-cache', 'cp',
+ 'status.json', 'gs://' + LOGS_BUCKET],
+ stderr=subprocess.STDOUT)
 
 
 def upload_build_logs(results):
 def upload_build_logs(results):
 with codecs.open('latest.txt', 'w', encoding='utf-8') as f:
 f.write(result.output)
 
- subprocess.check_output(['gsutil', 'cp', 'latest.txt',
- 'gs://%s/build_logs/%s/' %
- (LOGS_BUCKET, result.name)],
- stderr=subprocess.STDOUT)
+ subprocess.check_output([
+ 'gsutil', '-h', 'Cache-Control: no-cache', 'cp', 'latest.txt',
+ 'gs://%s/build_logs/%s/' % (LOGS_BUCKET, result.name)
+ ], stderr=subprocess.STDOUT)
 
 
 def main():
",92,17
"Prevent argv[0] from being modified in magic and chewing fuzzers. (#303)

dirname() may modify the input argument. Changing argv[0] breaks any
libFuzzer functionality that requires it to invoke itself (e.g.
failure-resistant merge, minimize)."," static Environment* env;
 
 extern ""C"" int LLVMFuzzerInitialize(int* argc, char*** argv) {
 char* exe_path = (*argv)[0];
- char* dir = dirname(exe_path);
+ // dirname() can modify its argument.
+ char* exe_path_copy = strdup(exe_path);
+ char* dir = dirname(exe_path_copy);
 env = new Environment(dir);
+ free(exe_path_copy);
 return 0;
 }
 
",33,5
make two icu fuzz targets more useful (#304)," extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
 break;
 }
 if (U_FAILURE(status)) return 0;
+ bi->setText(str);
 
 for (int32_t p = bi->first(); p != icu::BreakIterator::DONE; p = bi->next())
 if (U_FAILURE(status)) return 0;
",35,9
"[libarchive] correctly exit on read error in libarchive_fuzzer.cc (#305) (#305)

Thanks!
As we are discussing in https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=234#c6
we encourage you to move this file into your repo. 
https://github.com/google/oss-fuzz/blob/master/docs/ideal_integration.md"," ssize_t reader_callback(struct archive *a, void *client_data,
 }
 
 extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t *buf, size_t len) {
+ ssize_t r;
 struct archive *a = archive_read_new();
 
 archive_read_support_filter_all(a);
 extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t *buf, size_t len) {
 std::vector<uint8_t> data_buffer(getpagesize(), 0);
 struct archive_entry *entry;
 while (archive_read_next_header(a, &entry) == ARCHIVE_OK) {
- while (archive_read_data(a, data_buffer.data(), data_buffer.size()) > 0)
+ while ((r = archive_read_data(a, data_buffer.data(),
+ data_buffer.size()) > 0)
 ;
+ if (r == ARCHIVE_FATAL)
+ break;
 }
 
 archive_read_free(a);
",35,5
Fix compile error in libarchive," extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t *buf, size_t len) {
 while (archive_read_next_header(a, &entry) == ARCHIVE_OK) {
 while ((r = archive_read_data(a, data_buffer.data(),
 data_buffer.size()) > 0)
- ;
+ );
 if (r == ARCHIVE_FATAL)
 break;
 }
",35,5
"Allow run_fuzzer command to run with nonlocal docker. (#306)

By setting the DOCKER_HOST environment variable, all docker invocations will be non-local. This allows run_fuzzer to work in such an environment (as will be the case for many OS X and Windows users)."," def _check_project_exists(project_name):
 
 def _check_fuzzer_exists(project_name, fuzzer_name):
 """"""Checks if a fuzzer exists.""""""
- if not os.path.exists(os.path.join(BUILD_DIR, 'out', project_name,
- fuzzer_name)):
+ command = ['docker', 'run', '--rm']
+ command.extend(['-v', '%s:/out' % os.path.join(BUILD_DIR, 'out', project_name)])
+ command.append('ubuntu:16.04')
+
+ command.extend(['/bin/bash', '-c', 'test -f /out/%s' % fuzzer_name])
+
+ try:
+ subprocess.check_call(command)
+ except subprocess.CalledProcessError:
 print(fuzzer_name,
 'does not seem to exist. Please run build_fuzzers first.',
 file=sys.stderr)
",272,48
[libarchive] fix wrongly placed parentheses in 89ae65d (#307)," extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t *buf, size_t len) {
 struct archive_entry *entry;
 while (archive_read_next_header(a, &entry) == ARCHIVE_OK) {
 while ((r = archive_read_data(a, data_buffer.data(),
- data_buffer.size()) > 0)
- );
+ data_buffer.size())) > 0)
+ ;
 if (r == ARCHIVE_FATAL)
 break;
 }
",35,5
Fix breakage due to absolute paths in DockerFile," def run_fuzzer(run_args):
 '-v', '%s:/out' % os.path.join(BUILD_DIR, 'out', args.project_name),
 '-t', 'ossfuzz/base-runner',
 'run_fuzzer',
- '/out/%s' % args.fuzzer_name,
+ args.fuzzer_name,
 ] + args.fuzzer_args
 
 print('Running:', _get_command_string(command))
 def reproduce(run_args):
 '-v', '%s:/testcase' % _get_absolute_path(args.testcase_path),
 '-t', 'ossfuzz/base-runner',
 'reproduce',
- '/out/%s' % args.fuzzer_name,
+ args.fuzzer_name,
 '-runs=100',
 ] + args.fuzzer_args
 
",272,48
"Fixes #225

trace-pc-guard is enabled everywhere, so this is unneeded."," def coverage(run_args):
 '-v', '%s:/out' % os.path.join(BUILD_DIR, 'out', args.project_name),
 '-v', '%s:/cov' % temp_dir,
 '-w', '/cov',
- '-e', 'ASAN_OPTIONS=coverage=1',
 '-t', 'ossfuzz/base-runner',
 '/out/%s' % args.fuzzer_name,
 '-dump_coverage=1',
",271,48
Add fuzzers for libplist (#357),"
+/*
+# Copyright 2016 Google Inc.
+#
+# Licensed under the Apache License, Version 2.0 (the ""License"");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an ""AS IS"" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+################################################################################
+*/
+
+#include <plist/plist.h>
+#include <stdio.h>
+
+extern ""C"" int LLVMFuzzerTestOneInput(const char* data, size_t size)
+{
+plist_t root_node = NULL;
+plist_from_bin(data, size, &root_node);
+plist_free(root_node);
+
+return 0;
+}
",9,1
Fix UBSAN error with function argument casting. (#362),"
 #include <plist/plist.h>
 #include <stdio.h>
 
-extern ""C"" int LLVMFuzzerTestOneInput(const char* data, size_t size)
+extern ""C"" int LLVMFuzzerTestOneInput(const unsigned char* data, size_t size)
 {
 plist_t root_node = NULL;
-plist_from_bin(data, size, &root_node);
+plist_from_bin(reinterpret_cast<const char*>(data), size, &root_node);
 plist_free(root_node);
 
 return 0;
",9,1
"extend libxml2_xml_read_memory_fuzzer to call xmlSaveDoc (#387)

* extend libxml2_xml_read_memory_fuzzer to call xmlSaveDoc","
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include <cassert>
 #include <stddef.h>
 #include <stdint.h>
 
 #include ""libxml/parser.h""
+#include ""libxml/xmlsave.h""
 
 void ignore (void* ctx, const char* msg, ...) {
 // Error handler to avoid spam of error messages from libxml parser.
 extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
 xmlSetGenericErrorFunc(NULL, &ignore);
 
 if (auto doc = xmlReadMemory(reinterpret_cast<const char*>(data),
- static_cast<int>(size), ""noname.xml"", NULL, 0)) {
+ static_cast<int>(size), ""noname.xml"", NULL,
+ 0 /*or:XML_PARSE_RECOVER*/)) {
+ auto buf = xmlBufferCreate();
+ assert(buf);
+ auto ctxt = xmlSaveToBuffer(buf, NULL, 0);
+ xmlSaveDoc(ctxt, doc);
+ xmlSaveClose(ctxt);
 xmlFreeDoc(doc);
+ xmlBufferFree(buf);
 }
 
 return 0;
",22,3
"[icu] Fix broken build due to incomplete result type.

Got broken after http://bugs.icu-project.org/trac/changeset/39684/trunk/icu4c/source/common/unicode/locid.h

With error like the one below:
<...>
In file included from /src/break_iterator_fuzzer.cc:8:
/src/fuzzer_utils.h:37:20: error: incomplete result type 'icu::UnicodeString' in function definition
icu::UnicodeString UnicodeStringFromUtf8(const uint8_t* data, size_t size) {
 ^
/src/icu/source/common/unicode/locid.h:50:7: note: forward declaration of 'icu_59::UnicodeString'
class UnicodeString;
 ^
<...>","
 #include <algorithm>
 #include <random>
 
+#include ""unicode/unistr.h""
+#include ""unicode/strenum.h""
+
 #include ""unicode/locid.h""
 #include ""unicode/uchar.h""
 
",37,6
gcb: set default sanitizers," CONFIGURATIONS = {
 'sanitizer-undefined' : [ 'SANITIZER=undefined' ],
 }
 
+DEFAULT_SANITIZERS = ['address', 'undefined']
+
 
 def usage():
 sys.stderr.write(
 def get_build_steps(project_yaml):
 },
 ]
 
- for sanitizer in project_yaml[""sanitizers""]:
+ sanitizers = project_yaml.get('sanitizers', DEFAULT_SANITIZERS)
+ for sanitizer in sanitizers:
 env = CONFIGURATIONS[""sanitizer-"" + sanitizer]
 out = '/workspace/out/' + sanitizer
 zip_file = name + ""-"" + sanitizer + ""-"" + ts + "".zip""
",103,7
[infra] using setdefault," def load_project_yaml(project_dir):
 project_yaml.setdefault('name', project_name)
 project_yaml.setdefault('image', 
 'gcr.io/clusterfuzz-external/oss-fuzz/' + project_name)
+ project_yaml.setdefault('sanitizers', DEFAULT_SANITIZERS)
 return project_yaml
 
 
 def get_build_steps(project_yaml):
 },
 ]
 
- sanitizers = project_yaml.get('sanitizers', DEFAULT_SANITIZERS)
- for sanitizer in sanitizers:
+ for sanitizer in project_yaml['sanitizers']:
 env = CONFIGURATIONS[""sanitizer-"" + sanitizer]
 out = '/workspace/out/' + sanitizer
 zip_file = name + ""-"" + sanitizer + ""-"" + ts + "".zip""
",103,7
[infra] redirecting srcmap," def get_build_steps(project_yaml):
 },
 {
 'name': image,
- 'args': [ 'srcmap' ],
+ 'args': [ 
+ 'bash',
+ '-c',
+ 'srcmap > /workspace/srcmap.json && cat /workspace/srcmap.json' 
+ ],
 'env': [ 'OSSFUZZ_REVISION=$REVISION_ID' ],
 },
 ]
 def main():
 credentials = GoogleCredentials.get_application_default()
 cloudbuild = build('cloudbuild', 'v1', credentials=credentials)
 pp = pprint.PrettyPrinter(indent=4)
- pp.pprint(build_body)
 pp.pprint(cloudbuild.projects().builds().create(projectId='clusterfuzz-external', body=build_body).execute())
 
 
",106,7
[infra] acking all messages at once," def main():
 status_thread.daemon = True
 status_thread.start()
 
+ # Channel logs
 try:
 log_sub = create_log_subscription(log_topic, build_id)
 while True:
 pulled = log_sub.pull(max_messages=32)
 for ack_id, message in pulled:
 print json.loads(message.data)['textPayload']
- log_sub.acknowledge([ack_id])
+
+ if pulled:
+ log_sub.acknowledge([ack_id for ack_id, message in pulled])
 except KeyboardInterrupt:
 if status:
 print status
",64,16
[infra] handling unicode," def main():
 while True:
 pulled = log_sub.pull(max_messages=32)
 for ack_id, message in pulled:
- print json.loads(message.data)['textPayload']
+ print json.loads(message.data)['textPayload'].encode('utf-8')
 
 if pulled:
 log_sub.acknowledge([ack_id for ack_id, message in pulled])
",64,16
[infra] storing logs to gcs bucket," def main():
 'steps': get_build_steps(project_yaml),
 'timeout': str(4 * 3600) + 's',
 'options': options,
+ 'logsBucket': 'oss-fuzz-gcb-logs',
 'images': [ project_yaml['image'] ],
 }
 
",152,8
[infra] no debug print," def wait_for_build(build_id):
 status = None
 while True:
 build_info = get_build(build_id, cloudbuild)
+
 current_status = build_info['status']
 if current_status != status:
 print datetime.datetime.now(), current_status
 def wait_for_build(build_id):
 if status == 'SUCCESS' or status == 'FAILURE':
 return status == 'SUCCESS'
 
- print build_info['logUrl']
-
 time.sleep(POLL_INTERVAL)
 
 
",42,10
[infra] do not create build topic," def main():
 
 print build_id
 
- # Create pub/sub topic for build logs.
- log_topic = gcb_build.create_log_topic(build_id)
- gcb_build.create_sink(log_topic, build_id)
-
 
 if __name__ == ""__main__"":
 main()
",57,5
[infra] unused import," import yaml
 from oauth2client.client import GoogleCredentials
 from googleapiclient.discovery import build
 
-import build as gcb_build
 
 BASE_IMAGES = [
 'base-image',
",56,5
"Override $OUT in gcb build. (#456)

This prevents a copy from the builder container's /out to /workspace/out/sanitizer. Should hopefully fix ffmpeg's disk space issues."," def get_build_steps(project_yaml):
 ]
 
 for sanitizer in project_yaml['sanitizers']:
- env = CONFIGURATIONS[""sanitizer-"" + sanitizer]
+ env = CONFIGURATIONS[""sanitizer-"" + sanitizer][:]
 out = '/workspace/out/' + sanitizer
 stamped_name = name + '-' + sanitizer + '-' + ts
 zip_file = stamped_name + '.zip'
 def get_build_steps(project_yaml):
 srcmap_url = get_signed_url('/{0}/{1}/{2}'.format(
 UPLOAD_BUCKET, name, stamped_srcmap_file))
 
+ env.append('OUT=' + out)
+
 build_steps.extend([
 # compile
 {'name': image,
 def get_build_steps(project_yaml):
 'args': [
 'bash',
 '-c',
- 'cd /src/{1} && compile && mkdir -p {0} && cp -Rv /out/* {0}/'.format(out, name),
+ 'cd /src/{1} && mkdir -p {0} && compile'.format(out, name),
 ],
 },
 # zip binaries
",153,8
[infra] set cache control on gcb build status," def upload_status(successes, failures, unstable):
 storage_client = storage.Client()
 bucket = storage_client.get_bucket(LOGS_BUCKET)
 
- bucket.blob('status_template.html').upload_from_string(
+ blob = bucket.blob('status.html')
+ blob.cache_control = 'no-cache'
+ blob.upload_from_string(
 env.get_template('status_template.html').render(data),
 content_type='text/html')
 
- bucket.blob('status.json').upload_from_string(
+ blob = bucket.blob('status.json')
+ blob.cache_control = 'no-cache'
+ blob.upload_from_string(
 json.dumps(data),
 content_type='text/html')
 
 def main():
 credentials = GoogleCredentials.get_application_default()
 cloudbuild = gcb_build('cloudbuild', 'v1', credentials=credentials)
 
-
 successes = []
 failures = []
 for project in scan_project_names(projects_dir):
",71,11
[infra] gcb: print log url.," def main():
 build_info = cloudbuild.projects().builds().create(projectId='clusterfuzz-external', body=build_body).execute()
 build_id = build_info['metadata']['build']['id']
 
+ print >>sys.stderr, 'Logs:', build_info['metadata']['build']['logUrl']
 print build_id
 
 
",154,8
Move gcb auto setup to infra/gcb.," def sync_jenkins_job(server, project):
 project_json_string = json.dumps(json.dumps(yaml.safe_load(f)))
 
 job_name = 'projects/' + project
- with open(os.path.join(SCRIPT_DIR, 'jenkins_config', 'base_job_gcb.xml')) as f:
+ with open(os.path.join(SCRIPT_DIR, 'jenkins_config', 'base_job.xml')) as f:
 job_config_xml = f.read()
 
 if server.job_exists(job_name):
",64,15
"[infra] gcb: Build our own logs link.

The one returned by the API uses a text filter on the build id, which is
slow."," def get_build_steps(project_yaml):
 return build_steps
 
 
+def get_logs_url(build_id):
+ URL_FORMAT = ('https://console.developers.google.com/logs/viewer?'
+ 'resource=build%2Fbuild_id%2F{0}&project=clusterfuzz-external')
+ return URL_FORMAT.format(build_id)
+
+
 def main():
 if len(sys.argv) != 2:
 usage()
 def main():
 
 credentials = GoogleCredentials.get_application_default()
 cloudbuild = build('cloudbuild', 'v1', credentials=credentials)
- build_info = cloudbuild.projects().builds().create(projectId='clusterfuzz-external', body=build_body).execute()
+ build_info = cloudbuild.projects().builds().create(
+ projectId='clusterfuzz-external', body=build_body).execute()
 build_id = build_info['metadata']['build']['id']
 
- print >>sys.stderr, 'Logs:', build_info['metadata']['build']['logUrl']
+ print >>sys.stderr, 'Logs:', get_logs_url(build_id)
 print build_id
 
 
",159,9
[infra] gcb: Links to logs in build status," def main():
 last_build = builds[0]
 print last_build['startTime'], last_build['status'], last_build['id']
 if last_build['status'] == 'SUCCESS':
- successes.append(project)
+ successes.append({
+ 'name': project,
+ 'build_id': last_build['id'],
+ })
 else:
- failures.append(project)
+ failures.append({
+ 'name': project,
+ 'build_id': last_build['id'],
+ })
 
 upload_status(successes, failures, [])
 
",77,11
[infra] gcb: Upload builds to production buckets.," EngineInfo = collections.namedtuple(
 
 ENGINE_INFO = {
 'libfuzzer': EngineInfo(
- upload_bucket='clusterfuzz-builds-test',
+ upload_bucket='clusterfuzz-builds',
 supported_sanitizers=['address', 'memory', 'undefined']),
 'afl': EngineInfo(
- upload_bucket='clusterfuzz-builds-afl-test',
+ upload_bucket='clusterfuzz-builds-afl',
 supported_sanitizers=['address']),
 }
 
",180,12
Update wait_for_build.py," def wait_for_build(build_id):
 print datetime.datetime.now(), current_status
 sys.stdout.flush()
 status = current_status
- if status == 'SUCCESS' or status == 'FAILURE':
+ if status == 'SUCCESS' or status == 'FAILURE' or status == 'INTERNAL_ERROR':
 return status == 'SUCCESS'
 
 time.sleep(POLL_INTERVAL)
",43,11
"[infra] gcb: push base images to oss-fuzz registry

Instead of clusterfuzz-external. It looks better."," BASE_IMAGES = [
 'base-runner-debug',
 ]
 
-TAG_PREFIX = 'gcr.io/clusterfuzz-external/oss-fuzz/infra/'
+TAG_PREFIX = 'gcr.io/oss-fuzz/'
 
 
 def get_steps():
",56,5
"[infra] gcb: Add cancel.py

Also recognize CANCELLED status in wait_for_build.","
+#!/usr/bin/python2
+
+""""""Cancels project build on Google Cloud Builder.
+
+Usage: cancel.py <build_id>
+""""""
+
+import base64
+import collections
+import datetime
+import os
+import subprocess
+import sys
+import time
+import urllib
+import yaml
+
+from oauth2client.client import GoogleCredentials
+from oauth2client.service_account import ServiceAccountCredentials
+from googleapiclient.discovery import build
+
+def usage():
+ sys.stderr.write(
+ ""Usage: "" + sys.argv[0] + "" <build_id>\n"")
+ exit(1)
+
+
+def main():
+ if len(sys.argv) != 2:
+ usage()
+
+ build_id = sys.argv[1]
+
+ credentials = GoogleCredentials.get_application_default()
+ cloudbuild = build('cloudbuild', 'v1', credentials=credentials)
+ print cloudbuild.projects().builds().cancel(
+ projectId='clusterfuzz-external', id=build_id, body={}).execute()
+
+
+if __name__ == ""__main__"":
+ main()
",30,3
[infra] Fix builds status to filter on correct image tag.," def main():
 for project in scan_project_names(projects_dir):
 print project
 query_filter = ('(status=""SUCCESS"" OR status=""FAILURE"") AND ' +
- 'images=""gcr.io/clusterfuzz-external/oss-fuzz/{0}""'.format(project))
+ 'images=""gcr.io/oss-fuzz/{0}""'.format(project))
 response = cloudbuild.projects().builds().list(
 projectId='clusterfuzz-external',
 filter=query_filter).execute()
",92,13
[infra] gcb: support experimental sanitizers format," def is_supported_configuration(fuzzing_engine, sanitizer):
 return sanitizer in ENGINE_INFO[fuzzing_engine].supported_sanitizers
 
 
+def get_sanitizers(project_yaml):
+ sanitizers = project_yaml['sanitizers']
+ assert isinstance(sanitizers, list)
+
+ processed_sanitizers = []
+ for sanitizer in sanitizers:
+ if isinstance(sanitizer, basestring):
+ processed_sanitizers.append(sanitizer)
+ elif isinstance(sanitizer, dict):
+ for key in sanitizer.iterkeys():
+ processed_sanitizers.append(key)
+
+ return processed_sanitizers
+
+
 def get_build_steps(project_yaml):
 name = project_yaml['name']
 image = project_yaml['image']
",191,17
[infra] gcb: support experimental sanitizers format.," def get_build_steps(project_yaml):
 ]
 
 for fuzzing_engine in project_yaml['fuzzing_engines']:
- for sanitizer in project_yaml['sanitizers']:
+ for sanitizer in get_sanitizers(project_yaml):
 if not is_supported_configuration(fuzzing_engine, sanitizer):
 continue
 
",191,17
[infra] build base images to oss-fuzz-base," BASE_IMAGES = [
 'base-runner-debug',
 ]
 
-TAG_PREFIX = 'gcr.io/oss-fuzz/'
+TAG_PREFIX = 'gcr.io/oss-fuzz-base/'
 
 
 def get_steps():
 def main():
 'source': {
 'repoSource': {
 'branchName': 'master',
- 'projectId': 'clusterfuzz-external',
+ 'projectId': 'oss-fuzz-base',
 'repoName': 'oss-fuzz',
 },
 },
",56,5
[infra] build base images to oss-fuzz-base.," def main():
 
 credentials = GoogleCredentials.get_application_default()
 cloudbuild = build('cloudbuild', 'v1', credentials=credentials)
- build_info = cloudbuild.projects().builds().create(projectId='clusterfuzz-external', body=build_body).execute()
+ build_info = cloudbuild.projects().builds().create(projectId='oss-fuzz-base', body=build_body).execute()
 build_id = build_info['metadata']['build']['id']
 
 print build_id
",56,5
oss-fuzz/BASE_IMAGE -> oss-fuzz-base/BASE_IMAGE," def run_fuzzer(run_args):
 'docker', 'run', '--rm', '-i', '--cap-add', 'SYS_PTRACE',
 ] + sum([['-e', v] for v in env], []) + [
 '-v', '%s:/out' % os.path.join(BUILD_DIR, 'out', args.project_name),
- '-t', 'gcr.io/oss-fuzz/base-runner',
+ '-t', 'gcr.io/oss-fuzz-base/base-runner',
 'run_fuzzer',
 args.fuzzer_name,
 ] + args.fuzzer_args
 def coverage(run_args):
 '-v', '%s:/out' % os.path.join(BUILD_DIR, 'out', args.project_name),
 '-v', '%s:/cov' % temp_dir,
 '-w', '/cov',
- '-t', 'gcr.io/oss-fuzz/base-runner',
+ '-t', 'gcr.io/oss-fuzz-base/base-runner',
 '/out/%s' % args.fuzzer_name,
 '-dump_coverage=1',
 '-max_total_time=%s' % args.run_time
 def reproduce(run_args):
 'docker', 'run', '--rm', '-i', '--cap-add', 'SYS_PTRACE',
 '-v', '%s:/out' % os.path.join(BUILD_DIR, 'out', args.project_name),
 '-v', '%s:/testcase' % _get_absolute_path(args.testcase_path),
- '-t', 'gcr.io/oss-fuzz/base-runner',
+ '-t', 'gcr.io/oss-fuzz-base/base-runner',
 'reproduce',
 args.fuzzer_name,
 '-runs=100',
",286,51
[infra] Fix helper base image project.," def _build_image(image_name):
 """"""Build image.""""""
 
 if _is_base_image(image_name):
+ image_project = 'oss-fuzz-base'
 dockerfile_dir = os.path.join('infra', 'base-images', image_name)
 else:
+ image_project = 'oss-fuzz'
 if not _check_project_exists(image_name):
 return False
 
 def _build_image(image_name):
 build_args = []
 if not GLOBAL_ARGS.nopull:
 build_args += ['--pull']
- build_args += ['-t', 'gcr.io/oss-fuzz/%s' % image_name, dockerfile_dir ]
+ build_args += ['-t', 'gcr.io/%s/%s' % (image_name, image_project), dockerfile_dir ]
 
 command = [ 'docker', 'build' ] + build_args
 print('Running:', _get_command_string(command))
",288,51
[infra] helper: Actually fix base image name," def _build_image(image_name):
 build_args = []
 if not GLOBAL_ARGS.nopull:
 build_args += ['--pull']
- build_args += ['-t', 'gcr.io/%s/%s' % (image_name, image_project), dockerfile_dir ]
+ build_args += ['-t', 'gcr.io/%s/%s' % (image_project, image_name), dockerfile_dir ]
 
 command = [ 'docker', 'build' ] + build_args
 print('Running:', _get_command_string(command))
",288,51
[infra] Break loudly when a build script incorrectly uses /out instead of $OUT," def get_build_steps(project_yaml):
 'args': [
 'bash',
 '-c',
- 'cd /src/{1} && mkdir -p {0} && compile'.format(out, name),
+ # Remove /out to break loudly when a build script incorrectly uses
+ # /out instead of $OUT.
+ 'rm -r /out && cd /src/{1} && mkdir -p {0} && compile'.format(out, name),
 ],
 },
 # zip binaries
",191,17
[infra] Ugly hack to save disk space after a build.," def get_build_steps(project_yaml):
 '-c',
 # Remove /out to break loudly when a build script incorrectly uses
 # /out instead of $OUT.
- 'rm -r /out && cd /src/{1} && mkdir -p {0} && compile'.format(out, name),
+ # We also remove /work and /src to save disk space after a step.
+ # Container Builder doesn't pass --rm to docker run yet.
+ 'rm -r /out && cd /src/{1} && mkdir -p {0} && compile && rm -rf /work && rm -rf /src'.format(out, name),
 ],
 },
 # zip binaries
",191,17
[infra] Escape $ in gcb builds.," def workdir_from_dockerfile(dockerfile):
 for line in lines:
 match = re.match(WORKDIR_REGEX, line)
 if match:
- return match.group(1)
+ # We need to escape '$' since they're used for subsitutions in Container
+ # Builer builds.
+ return match.group(1).replace('$', '$$')
 
 return None
 
",205,21
fix param name (#516)," def coverage(args):
 docker_run(run_args)
 
 
-def reproduce(run_args):
+def reproduce(args):
 """"""Reproduces a testcase in the container.""""""
 if not _check_project_exists(args.project_name):
 return 1
",276,56
[infra] Change uploader docker image tag," def get_build_steps(project_yaml, dockerfile_path):
 ],
 },
 # upload binaries
- {'name': 'gcr.io/clusterfuzz-external/uploader',
+ {'name': 'gcr.io/oss-fuzz-base/uploader',
 'args': [
 os.path.join(out, zip_file),
 upload_url,
 ],
 },
 # upload srcmap
- {'name': 'gcr.io/clusterfuzz-external/uploader',
+ {'name': 'gcr.io/oss-fuzz-base/uploader',
 'args': [
 '/workspace/srcmap.json',
 srcmap_url,
",205,21
[infra] Change gcb build project," def get_build_steps(project_yaml, dockerfile_path):
 
 def get_logs_url(build_id):
 URL_FORMAT = ('https://console.developers.google.com/logs/viewer?'
- 'resource=build%2Fbuild_id%2F{0}&project=clusterfuzz-external')
+ 'resource=build%2Fbuild_id%2F{0}&project=oss-fuzz')
 return URL_FORMAT.format(build_id)
 
 
 def main():
 'source': {
 'repoSource': {
 'branchName': 'master',
- 'projectId': 'clusterfuzz-external',
+ 'projectId': 'oss-fuzz',
 'repoName': 'oss-fuzz',
 },
 },
 def main():
 credentials = GoogleCredentials.get_application_default()
 cloudbuild = build('cloudbuild', 'v1', credentials=credentials)
 build_info = cloudbuild.projects().builds().create(
- projectId='clusterfuzz-external', body=build_body).execute()
+ projectId='oss-fuzz', body=build_body).execute()
 build_id = build_info['metadata']['build']['id']
 
 print >>sys.stderr, 'Logs:', get_logs_url(build_id)
",205,21
[infra] Work around Container Builder breakage.," TAG_PREFIX = 'gcr.io/oss-fuzz-base/'
 
 
 def get_steps():
- steps = []
+ steps = [{
+ 'args': [
+ 'clone', 'https://github.com/google/oss-fuzz.git',
+ ],
+ 'name': 'gcr.io/cloud-builders/git',
+ }]
 
 for base_image in BASE_IMAGES:
 steps.append({
 def get_steps():
 TAG_PREFIX + base_image,
 '.',
 ],
- 'dir': 'infra/base-images/' + base_image,
+ 'dir': 'oss-fuzz/infra/base-images/' + base_image,
 'name': 'gcr.io/cloud-builders/docker',
 })
 
 def main():
 options = yaml.safe_load(os.environ[""GCB_OPTIONS""])
 
 build_body = {
- 'source': {
- 'repoSource': {
- 'branchName': 'master',
- 'projectId': 'oss-fuzz-base',
- 'repoName': 'oss-fuzz',
- },
- },
 'steps': get_steps(),
 'timeout': str(4 * 3600) + 's',
 'options': options,
",54,5
[infra] Update builds status," def scan_project_names(projects_dir):
 return sorted(projects)
 
 
-def upload_status(successes, failures, unstable):
+def upload_status(successes, failures):
 """"""Upload main status page.""""""
 env = Environment(loader=FileSystemLoader(os.path.join(SCRIPT_DIR,
 'templates')))
 data = {
- 'projects': failures + successes + unstable,
+ 'projects': failures + successes,
 'failures': failures,
 'successes': successes,
 'unstable': unstable,
 def main():
 successes.append({
 'name': project,
 'build_id': last_build['id'],
+ 'finish_time': last_build['finishTime'],
 })
 else:
 failures.append({
 'name': project,
 'build_id': last_build['id'],
+ 'finish_time': last_build['finishTime'],
 })
 
- upload_status(successes, failures, [])
+ upload_status(successes, failures)
 
 
 if __name__ == ""__main__"":
",117,17
Update builds_status.py," def main():
 'name': project,
 'build_id': last_build['id'],
 'finish_time': last_build['finishTime'],
+ 'success': True,
 })
 else:
 failures.append({
 'name': project,
 'build_id': last_build['id'],
 'finish_time': last_build['finishTime'],
+ 'success': False,
 })
 
 upload_status(successes, failures)
",119,17
"libssh: fix key file permissions

Should hopefully fix https://github.com/google/oss-fuzz/pull/418#issuecomment-295277016"," extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
 res = shutdown(socket_fds[1], SHUT_WR);
 assert(res == 0);
 
- int fd = open(""/tmp/libssh_fuzzer_private_key"", O_WRONLY | O_CREAT);
+ int fd = open(""/tmp/libssh_fuzzer_private_key"", O_WRONLY | O_CREAT, S_IRWXU);
 assert(fd >= 0);
 ssize_t write_res = write(fd, kRSAPrivateKeyPEM, strlen(kRSAPrivateKeyPEM));
 assert(write_res == strlen(kRSAPrivateKeyPEM));
",70,4
"Create a separate coverage build.

First part of #191."," CONFIGURATIONS = {
 'sanitizer-address' : [ 'SANITIZER=address' ],
 'sanitizer-memory' : [ 'SANITIZER=memory' ],
 'sanitizer-undefined' : [ 'SANITIZER=undefined' ],
+ 'sanitizer-coverage' : [ 'SANITIZER=coverage' ],
 'engine-libfuzzer' : [ 'FUZZING_ENGINE=libfuzzer' ],
 'engine-afl' : [ 'FUZZING_ENGINE=afl' ],
 }
 EngineInfo = collections.namedtuple(
 ENGINE_INFO = {
 'libfuzzer': EngineInfo(
 upload_bucket='clusterfuzz-builds',
- supported_sanitizers=['address', 'memory', 'undefined']),
+ supported_sanitizers=['address', 'memory', 'undefined', 'coverage']),
 'afl': EngineInfo(
 upload_bucket='clusterfuzz-builds-afl',
 supported_sanitizers=['address']),
",205,21
[infra] Build coverage build by default.," def get_sanitizers(project_yaml):
 for key in sanitizer.iterkeys():
 processed_sanitizers.append(key)
 
+ # Always make a coverage build.
+ if 'coverage' not in processed_sanitizers:
+ processed_sanitizers.append('coverage')
+
 return processed_sanitizers
 
 
",207,22
[helper] Add a prompt to build_image command for pulling base images. (#595)," def docker_pull(image, pull=False):
 
 def build_image(args):
 """"""Build docker image.""""""
+ pull = args.pull
+ if not pull:
+ y_or_n = raw_input('Pull latest base images (compiler/runtime)? (y/N): ')
+ pull = y_or_n.lower() == 'y'
+
+ if pull:
+ print('Pulling latest base images...')
+ else:
+ print('Using cached base images...')
+
 # If build_image is called explicitly, don't use cache.
- if _build_image(args.project_name, no_cache=True, pull=args.pull):
+ if _build_image(args.project_name, no_cache=True, pull=pull):
 return 0
 
 return 1
",317,63
[helper] Add a check for valid project name when generating files.," BASE_IMAGES = [
 'gcr.io/oss-fuzz-base/base-runner-debug',
 ]
 
+VALID_PROJECT_NAME_REGEX = re.compile(r'^[a-zA-Z0-9_-]+$')
+
 
 def main():
 os.chdir(OSSFUZZ_DIR)
 def reproduce(args):
 
 def generate(args):
 """"""Generate empty project files.""""""
+ if not VALID_PROJECT_NAME_REGEX.match(args.project_name):
+ print('Invalid project name.', file=sys.stderr)
+ return 1
+
 dir = os.path.join('projects', args.project_name)
 
 try:
",331,67
add an 'example' project (#603),"
+// Copyright 2017 Google Inc. All Rights Reserved.
+// Licensed under the Apache License, Version 2.0 (the ""License"");
+#include ""my_api.h""
+
+#include <string>
+
+// Simple fuzz target for DoStuff().
+// See http://libfuzzer.info for details.
+extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
+ std::string str(reinterpret_cast<const char *>(data), size);
+ DoStuff(str); // Disregard the output.
+ return 0;
+}
+
",7,1
"[example] Fix a typo in ""example"" project from #603."," extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
 DoStuff(str); // Disregard the output.
 return 0;
 }
-
",7,1
[infra] Make coverage run with dict and options.," def coverage(args):
 temp_dir = tempfile.mkdtemp()
 
 run_args = [
+ '-e', 'FUZZING_ENGINE=libfuzzer',
+ '-e', 'ASAN_OPTIONS=coverage_dir=/cov',
+ '-e', 'MSAN_OPTIONS=coverage_dir=/cov',
+ '-e', 'UBSAN_OPTIONS=coverage_dir=/cov',
 '-v', '%s:/out' % os.path.join(BUILD_DIR, 'out', args.project_name),
 '-v', '%s:/cov' % temp_dir,
 '-w', '/cov',
 '-t', 'gcr.io/oss-fuzz-base/base-runner',
- '/out/%s' % args.fuzzer_name,
+ 'run_fuzzer',
+ args.fuzzer_name,
 '-dump_coverage=1',
 '-max_total_time=%s' % args.run_time
 ] + args.fuzzer_args
 
- print('This may take a while (running your fuzzer for %d seconds)...' %
+ print('This may take a while (running your fuzzer for %s seconds)...' %
 args.run_time)
 docker_run(run_args, print_output=False)
 
",336,67
Support honggfuzz as a FUZZING_ENGINE (#636)," CONFIGURATIONS = {
 'sanitizer-coverage' : [ 'SANITIZER=coverage' ],
 'engine-libfuzzer' : [ 'FUZZING_ENGINE=libfuzzer' ],
 'engine-afl' : [ 'FUZZING_ENGINE=afl' ],
+ 'engine-honggfuzz' : [ 'FUZZING_ENGINE=honggfuzz' ],
 }
 
 EngineInfo = collections.namedtuple(
 ENGINE_INFO = {
 'afl': EngineInfo(
 upload_bucket='clusterfuzz-builds-afl',
 supported_sanitizers=['address']),
+ 'honggfuzz': EngineInfo(
+ upload_bucket='clusterfuzz-builds-honggfuzz',
+ supported_sanitizers=['address', 'memory', 'undefined']),
 }
 
-DEFAULT_ENGINES = ['libfuzzer', 'afl']
+DEFAULT_ENGINES = ['libfuzzer', 'afl', 'honggfuzz']
 DEFAULT_SANITIZERS = ['address', 'undefined']
 
 
",211,22
[infra] helper: don't set BUILD_UID.," def build_fuzzers(args):
 return 1
 
 env = [
- 'BUILD_UID=%d' % os.getuid(),
 'FUZZING_ENGINE=' + args.engine,
 'SANITIZER=' + args.sanitizer
 ]
",335,67
[infra] gcb: recognise TIMEOUT.," def wait_for_build(build_id, project):
 'FAILURE',
 'INTERNAL_ERROR',
 'CANCELLED',
+ 'TIMEOUT',
 ]
 
 status = None
",51,7
"[infra] Execute test_all step (includes bad_build_check) for all builds. (#766)

* [infra] Execute test_all step (includes bad_build_check) for all builds.

* Checkout master branch as usual."," def get_build_steps(project_yaml, dockerfile_path):
 'rm -r /out && cd /src && cd {1} && mkdir -p {0} && compile && rm -rf /work && rm -rf /src'.format(out, workdir),
 ],
 },
+ # test binaries
+ {'name': 'gcr.io/oss-fuzz-base/base-runner',
+ 'env': env,
+ 'args': [
+ 'bash',
+ '-c',
+ # Verify that fuzzers have been built properly and are not broken.
+ # TODO(mmoroz): raise a notification if not passing the tests.
+ 'test_all'
+ ]
+ },
 # zip binaries
 {'name': image,
 'args': [
",219,22
"[infra] Temporarily disable ""test binaries"" build step."," def get_build_steps(project_yaml, dockerfile_path):
 'rm -r /out && cd /src && cd {1} && mkdir -p {0} && compile && rm -rf /work && rm -rf /src'.format(out, workdir),
 ],
 },
- # test binaries
- {'name': 'gcr.io/oss-fuzz-base/base-runner',
- 'env': env,
- 'args': [
- 'bash',
- '-c',
- # Verify that fuzzers have been built properly and are not broken.
- # TODO(mmoroz): raise a notification if not passing the tests.
- 'test_all'
- ]
- },
 # zip binaries
 {'name': image,
 'args': [
",211,22
[infra] builds_status: try to reduce 504s.," import tempfile
 
 import dateutil.parser
 from oauth2client.client import GoogleCredentials
+import googleapiclient
 from googleapiclient.discovery import build as gcb_build
 from google.cloud import logging
 from google.cloud import storage
 def main():
 for project in scan_project_names(projects_dir):
 print project
 query_filter = ('(status=""SUCCESS"" OR status=""FAILURE"") AND ' +
- 'images=""gcr.io/oss-fuzz/{0}""'.format(project))
- response = cloudbuild.projects().builds().list(
- projectId='oss-fuzz',
- filter=query_filter).execute()
+ 'results.images.name=""gcr.io/oss-fuzz/{0}""'.format(project))
+ try:
+ response = cloudbuild.projects().builds().list(
+ projectId='oss-fuzz',
+ pageSize=1,
+ filter=query_filter).execute()
+ except googleapiclient.errors.HttpError:
+ print >>sys.stderr, 'Failed to list builds for', project
+ continue
+
 if not 'builds' in response:
 continue
 
",124,18
[infra] Increase page size of builds list.," def main():
 try:
 response = cloudbuild.projects().builds().list(
 projectId='oss-fuzz',
- pageSize=1,
+ pageSize=2,
 filter=query_filter).execute()
 except googleapiclient.errors.HttpError:
 print >>sys.stderr, 'Failed to list builds for', project
",124,18
[infra] Fix builds query," def main():
 for project in scan_project_names(projects_dir):
 print project
 query_filter = ('(status=""SUCCESS"" OR status=""FAILURE"") AND ' +
- 'results.images.name=""gcr.io/oss-fuzz/{0}""'.format(project))
+ 'images=""gcr.io/oss-fuzz/{0}""'.format(project))
 try:
 response = cloudbuild.projects().builds().list(
 projectId='oss-fuzz',
",124,18
"[infra] Add another coverage build using Clang Source-based Code Coverage. (#804)

* [infra] Add another coverage build using Clang Source-based Code Coverage.

* [infra] Remove redundant compile_coverage script."," CONFIGURATIONS = {
 'sanitizer-memory' : [ 'SANITIZER=memory' ],
 'sanitizer-undefined' : [ 'SANITIZER=undefined' ],
 'sanitizer-coverage' : [ 'SANITIZER=coverage' ],
+ 'sanitizer-profile' : [ 'SANITIZER=profile' ],
 'engine-libfuzzer' : [ 'FUZZING_ENGINE=libfuzzer' ],
 'engine-afl' : [ 'FUZZING_ENGINE=afl' ],
 'engine-honggfuzz' : [ 'FUZZING_ENGINE=honggfuzz' ],
 EngineInfo = collections.namedtuple(
 ENGINE_INFO = {
 'libfuzzer': EngineInfo(
 upload_bucket='clusterfuzz-builds',
- supported_sanitizers=['address', 'memory', 'undefined', 'coverage']),
+ supported_sanitizers=['address', 'memory', 'undefined', 'coverage',
+ 'profile']),
 'afl': EngineInfo(
 upload_bucket='clusterfuzz-builds-afl',
 supported_sanitizers=['address']),
 def get_sanitizers(project_yaml):
 if 'coverage' not in processed_sanitizers:
 processed_sanitizers.append('coverage')
 
+ if 'profile' not in processed_sanitizers:
+ processed_sanitizers.append('profile')
+
 return processed_sanitizers
 
 
",215,23
[infra] upload srcmap first.," def get_build_steps(project_yaml, dockerfile_path):
 'cd {0} && zip -r {1} *'.format(out, zip_file)
 ],
 },
- # upload binaries
+ # upload srcmap
 {'name': 'gcr.io/oss-fuzz-base/uploader',
 'args': [
- os.path.join(out, zip_file),
- upload_url,
+ '/workspace/srcmap.json',
+ srcmap_url,
 ],
 },
- # upload srcmap
+ # upload binaries
 {'name': 'gcr.io/oss-fuzz-base/uploader',
 'args': [
- '/workspace/srcmap.json',
- srcmap_url,
+ os.path.join(out, zip_file),
+ upload_url,
 ],
 },
 # cleanup
",215,23
Adding Project - Tinyxml2 (#813),"
+#if defined( _MSC_VER )
+#if !defined( _CRT_SECURE_NO_WARNINGS )
+#define _CRT_SECURE_NO_WARNINGS// This test file is not intended to be secure.
+#endif
+#endif
+
+#include ""tinyxml2/tinyxml2.h""
+#include <string>
+#include <stddef.h>
+#include <stdint.h>
+
+#if defined( _MSC_VER ) || defined (WIN32)
+#include <crtdbg.h>
+#define WIN32_LEAN_AND_MEAN
+#include <windows.h>
+_CrtMemState startMemState;
+_CrtMemState endMemState;
+#else
+#include <sys/stat.h>
+#include <sys/types.h>
+#endif
+
+using namespace tinyxml2;
+using namespace std;
+
+// Entry point for LibFuzzer.
+extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
+std::string data_string(reinterpret_cast<const char*>(data), size);
+XMLDocument doc;
+doc.Parse( data_string.c_str() );
+
+return 0;
+}
",18,1
"[infra] Enable bad_build_checks without test_all step that runs all the fuzzers. (#814)

* [infra] Enable bad_build_checks without test_all step that runs all the fuzzers.

* [infra] Add COPY step for test_all_for_bad_build script.

* [infra] Use SKIP_TEST_TARGET_RUN=1 to avoid running all fuzz targets during test_all.

* [infra] Invern the condition in test_all script.

* [infra] Finally fix the condition in test_all."," def get_build_steps(project_yaml, dockerfile_path):
 
 env.append('OUT=' + out)
 
+ # To disable running of all fuzz targets while doing |test_all| step.
+ env.append('SKIP_TEST_TARGET_RUN=1')
+
 workdir = workdir_from_dockerfile(dockerfile_path)
 if not workdir:
 workdir = '/src'
 def get_build_steps(project_yaml, dockerfile_path):
 'rm -r /out && cd /src && cd {1} && mkdir -p {0} && compile && rm -rf /work && rm -rf /src'.format(out, workdir),
 ],
 },
+ # test binaries
+ {'name': 'gcr.io/oss-fuzz-base/base-runner',
+ 'env': env,
+ 'args': [
+ 'bash',
+ '-c',
+ # Verify that fuzzers have been built properly and are not broken.
+ # TODO(mmoroz): raise a notification if not passing the tests.
+ 'test_all'
+ ]
+ },
 # zip binaries
 {'name': image,
 'args': [
",224,23
"[expat] Fix fuzz target crashing with MSan on random bytes generation.

This is a fix for https://github.com/google/oss-fuzz/issues/816
and for https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=2603","
 
 #include ""expat.h""
 
+#include <functional>
+#include <string>
+
 const char* kEncoding =
 #if defined(ENCODING_UTF_16)
 ""UTF-16""
 const char* kEncoding =
 
 // Entry point for LibFuzzer.
 extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
+ std::string input(reinterpret_cast<const char*>(data), size);
+ auto hash_salt = std::hash<std::string>()(input);
+
 for (int use_ns = 0; use_ns <= 1; ++use_ns) {
 XML_Parser parser =
 use_ns ? XML_ParserCreateNS(kEncoding, '\n') :
 XML_ParserCreate(kEncoding);
- XML_Parse(parser, reinterpret_cast<const char*>(data), size, true);
+
+ // Set a hash salt to prevent MSan from crashing on random bytes generation.
+ XML_SetHashSalt(parser, hash_salt);
+ XML_Parse(parser, input.c_str(), input.size(), true);
 XML_ParserFree(parser);
 }
 return 0;
",26,3
"[libteken] Add missing initialization in the fuzz target (#821).

Fixes https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=2602
and also resolves https://github.com/google/oss-fuzz/issues/821"," static teken_funcs_t tf = {
 };
 
 int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
- teken_t t;
+ teken_t t = { 0 };
 teken_init(&t, &tf, NULL);
 teken_input(&t, data, size);
 return 0;
",27,8
add boost/regex fuzzer (#851),"
+// From https://svn.boost.org/trac10/ticket/12818
+// This fuzz target can likely be enhanced to exercise more code.
+// The ideal place for this fuzz target is the bost repository.
+#include <boost/regex.hpp>
+extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) {
+ try {
+ std::string str((char *)Data, Size);
+ boost::regex e(str);
+ boost::match_results<std::string::const_iterator> what;
+ boost::regex_match(str, what, e,
+ boost::match_default | boost::match_partial);
+
+ } catch (const std::exception &) {
+ }
+ return 0;
+}
",12,2
increase build timeout to 6 hours (#877)," def main():
 
 build_body = {
 'steps': get_build_steps(project_yaml, dockerfile_path),
- 'timeout': str(4 * 3600) + 's',
+ 'timeout': str(6 * 3600) + 's',
 'options': options,
 'logsBucket': 'oss-fuzz-gcb-logs',
 'images': [ project_yaml['image'] ],
",215,23
Fix workaround for not marking builds as failed when GCS logs are truncated.," def is_build_successful(build):
 logging_client = logging.Client(project='oss-fuzz')
 entries = logging_client.list_entries(
 order_by=logging.DESCENDING,
- page_size=1,
+ page_size=4,
 filter_=(
 'resource.type=""build"" AND '
 'resource.labels.build_id=""{0}""'.format(build_id)))
 
- entry = next(entries.pages)
- entry = list(entry)[0]
- return entry.payload == 'DONE'
+ entries = next(entries.pages)
+ return any(entry.payload == 'DONE' for entry in entries)
 
 
 def find_last_build(builds):
",124,20
Add script for testing sandbox.," def _build_image(image_name, no_cache=False, pull=False):
 
 def docker_run(run_args, print_output=True):
 """"""Call `docker run`.""""""
- command = ['docker', 'run', '--rm', '-i', '--cap-add', 'SYS_PTRACE']
+ command = ['docker', 'run', '--rm', '-i', '--privileged']
 command.extend(run_args)
 
 print('Running:', _get_command_string(command))
 def shell(args):
 if args.e:
 env += args.e
 
+ if _is_base_image(args.project_name):
+ image_project = 'oss-fuzz-base'
+ out_dir = os.path.join(BUILD_DIR, 'out');
+ else:
+ image_project = 'oss-fuzz'
+ out_dir = os.path.join(BUILD_DIR, 'out', args.project_name)
+
 run_args = sum([['-e', v] for v in env], []) + [
- '-v', '%s:/out' % os.path.join(BUILD_DIR, 'out', args.project_name),
+ '-v', '%s:/out' % out_dir,
 '-v', '%s:/work' % os.path.join(BUILD_DIR, 'work', args.project_name),
- '-t', 'gcr.io/oss-fuzz/%s' % args.project_name,
+ '-t', 'gcr.io/%s/%s' % (image_project, args.project_name),
 '/bin/bash'
 ]
 
",341,68
"[libxml2] Disable XML_PARSE_HUGE to avoid stack overflow.

Mirror the change from Chromium version:
https://chromium-review.googlesource.com/c/chromium/src/+/720537

This should fix the following bugs:
- https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=2336
- https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=2731
- https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=2779
- https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=3245"," extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
 const std::size_t data_hash = std::hash<std::string>()(data_string);
 const int max_option_value = std::numeric_limits<int>::max();
 const int random_option_value = data_hash % max_option_value;
+
+ // Disable XML_PARSE_HUGE to avoid stack overflow.
+ random_option_value &= ~XML_PARSE_HUGE;
 const int options[] = {0, random_option_value};
 
 for (const auto option_value : options) {
",32,4
[libxml2] Fix compilation error in the fuzz target.," extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
 std::string data_string(reinterpret_cast<const char*>(data), size);
 const std::size_t data_hash = std::hash<std::string>()(data_string);
 const int max_option_value = std::numeric_limits<int>::max();
- const int random_option_value = data_hash % max_option_value;
+ int random_option_value = data_hash % max_option_value;
 
 // Disable XML_PARSE_HUGE to avoid stack overflow.
 random_option_value &= ~XML_PARSE_HUGE;
",32,4
[infra] Temporarily disable sanitizer=profile build configuration.," CONFIGURATIONS = {
 'sanitizer-memory' : [ 'SANITIZER=memory' ],
 'sanitizer-undefined' : [ 'SANITIZER=undefined' ],
 'sanitizer-coverage' : [ 'SANITIZER=coverage' ],
- 'sanitizer-profile' : [ 'SANITIZER=profile' ],
 'engine-libfuzzer' : [ 'FUZZING_ENGINE=libfuzzer' ],
 'engine-afl' : [ 'FUZZING_ENGINE=afl' ],
 'engine-honggfuzz' : [ 'FUZZING_ENGINE=honggfuzz' ],
 EngineInfo = collections.namedtuple(
 ENGINE_INFO = {
 'libfuzzer': EngineInfo(
 upload_bucket='clusterfuzz-builds',
- supported_sanitizers=['address', 'memory', 'undefined', 'coverage',
- 'profile']),
+ supported_sanitizers=['address', 'memory', 'undefined', 'coverage']),
 'afl': EngineInfo(
 upload_bucket='clusterfuzz-builds-afl',
 supported_sanitizers=['address']),
 def get_sanitizers(project_yaml):
 if 'coverage' not in processed_sanitizers:
 processed_sanitizers.append('coverage')
 
- if 'profile' not in processed_sanitizers:
- processed_sanitizers.append('profile')
-
 return processed_sanitizers
 
 
",211,22
[infra] Remove builds status hack to work around container build bug," def upload_status(successes, failures):
 
 
 def is_build_successful(build):
- if build['status'] == 'SUCCESS':
- return True
-
- build_id = build['id']
- logging_client = logging.Client(project='oss-fuzz')
- entries = logging_client.list_entries(
- order_by=logging.DESCENDING,
- page_size=4,
- filter_=(
- 'resource.type=""build"" AND '
- 'resource.labels.build_id=""{0}""'.format(build_id)))
-
- entries = next(entries.pages)
- return any(entry.payload == 'DONE' for entry in entries)
+ return build['status'] == 'SUCCESS'
 
 
 def find_last_build(builds):
",113,18
"Add priliminary support for ""engine-less"" builds.

Needed for #925."," CONFIGURATIONS = {
 'engine-libfuzzer' : [ 'FUZZING_ENGINE=libfuzzer' ],
 'engine-afl' : [ 'FUZZING_ENGINE=afl' ],
 'engine-honggfuzz' : [ 'FUZZING_ENGINE=honggfuzz' ],
+ 'engine-none' : [ 'FUZZING_ENGINE=none' ],
 }
 
 EngineInfo = collections.namedtuple(
",212,22
Increase build timeout to 10 hours (fix #978)," from oauth2client.client import GoogleCredentials
 from oauth2client.service_account import ServiceAccountCredentials
 from googleapiclient.discovery import build
 
+BUILD_TIMEOUT = 10 * 60 * 60
+
 CONFIGURATIONS = {
 'sanitizer-address' : [ 'SANITIZER=address' ],
 'sanitizer-memory' : [ 'SANITIZER=memory' ],
 def main():
 
 build_body = {
 'steps': get_build_steps(project_yaml, dockerfile_path),
- 'timeout': str(6 * 3600) + 's',
+ 'timeout': str(BUILD_TIMEOUT) + 's',
 'options': options,
 'logsBucket': 'oss-fuzz-gcb-logs',
 'images': [ project_yaml['image'] ],
",216,22
"Setup simple fuzzing for unrar. (#951)

* Get the shared library to build for unrar

* Fuzz by writing temp file and calling CmdExtract::DoExtract()

* Incorporate review feedback

* Incorporate review feedback","
+#include <memory>
+#include <stddef.h>
+#include <string>
+#include <unistd.h>
+
+#include ""rar.hpp""
+
+extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
+ char filename[] = ""mytemp.XXXXXX"";
+ int fd = mkstemp(filename);
+ write(fd, data, size);
+
+ std::unique_ptr<CommandData> cmd_data(new CommandData);
+ cmd_data->ParseArg(const_cast<wchar_t *>(L""-p""));
+ cmd_data->ParseArg(const_cast<wchar_t *>(L""x""));
+ cmd_data->ParseDone();
+ std::wstring wide_filename(filename, filename + strlen(filename));
+ cmd_data->AddArcName(wide_filename.c_str());
+
+ try {
+ CmdExtract extractor(cmd_data.get());
+ extractor.DoExtract();
+ } catch (...) {
+ }
+
+ close(fd);
+ unlink(filename);
+
+ return 0;
+}
",24,2
"[infra] msan builder fixes.

- wrapper: print actual clang invocation to stderr instead.
- add -fPIC -fno-omit-frame-pointer to c/cxxflags
- replace -g with -gline-tables-only"," def GetCompilerArgs(args):
 ])
 
 REMOVED_ARGS = [
+ '-g',
 '-Wl,-z,defs',
 ]
 
- return [arg for arg in compiler_args if arg not in REMOVED_ARGS]
+ args = [arg for arg in compiler_args if arg not in REMOVED_ARGS]
+ args.append('-gline-tables-only')
+ return args
 
 
 def FindRealClang():
 def main(args):
 real_clang += '++'
 
 args = [real_clang] + GetCompilerArgs(args)
- print(args)
+ print(args, file=sys.stderr)
 sys.exit(subprocess.call(args))
 
 
",40,9
"[infra] msan builder: don't print anything extra at all in compiler wrapper.

configure scripts can test for output to stderr as an indication of
error."," def main(args):
 real_clang += '++'
 
 args = [real_clang] + GetCompilerArgs(args)
- print(args, file=sys.stderr)
 sys.exit(subprocess.call(args))
 
 
",39,9
[infra] msan builder: disable all warnings.," def GetCompilerArgs(args):
 
 return compiler_args
 
- # FORTIFY_SOURCE is not supported by sanitizers.
+ compiler_args = RemoveZDefs(compiler_args)
 compiler_args.extend([
+ # FORTIFY_SOURCE is not supported by sanitizers.
 '-U_FORTIFY_SOURCE',
+ # Reduce binary size.
+ '-gline-tables-only',
+ # Disable all warnings.
+ '-w',
 ])
 
- compiler_args = RemoveZDefs(compiler_args)
- # Reduce build size.
- compiler_args.append('-gline-tables-only')
-
 return compiler_args
 
 
",50,12
[infra] msan builder: wrap dpkg-gensymbols.," def SetUpEnvironment(work_dir):
 env['DEB_LDFLAGS_APPEND'] = MSAN_OPTIONS
 env['DPKG_GENSYMBOLS_CHECK_LEVEL'] = '0'
 
+ # debian/rules can set DPKG_GENSYMBOLS_CHECK_LEVEL explicitly, so override it.
+ dpkg_gensymbols_path = os.path.join(bin_dir, 'dpkg-gensymbols')
+ with open(dpkg_gensymbols_path, 'w') as f:
+ f.write(
+ '#!/bin/sh\n'
+ 'export DPKG_GENSYMBOLS_CHECK_LEVEL=0\n'
+ '/usr/bin/dpkg-gensymbols ""$@""\n')
+
+ os.chmod(dpkg_gensymbols_path, 0755)
+
 env['PATH'] = bin_dir + ':' + os.environ['PATH']
 
 # Prevent entire build from failing because of bugs/uninstrumented in tools
",124,26
[infra] msan builder: don't strip.," def SetUpEnvironment(work_dir):
 
 MSAN_OPTIONS = ' '.join(INJECTED_ARGS)
 
- env['DEB_BUILD_OPTIONS'] = 'nocheck'
+ env['DEB_BUILD_OPTIONS'] = 'nocheck nostrip'
 env['DEB_CFLAGS_APPEND'] = MSAN_OPTIONS
 env['DEB_CXXFLAGS_APPEND'] = MSAN_OPTIONS + ' -stdlib=libc++'
 env['DEB_CPPFLAGS_APPEND'] = env['DEB_CXXFLAGS_APPEND']
",124,26
"[infra] msan builder: one more variation of -Wl,-z,defs"," def RemoveZDefs(args):
 filtered = []
 
 for arg in args:
- if arg == '-Wl,-z,defs':
+ if arg == '-Wl,-z,defs' or arg == '-Wl,--no-undefined':
 continue
 
 if arg == '-Wl,defs':
",50,13
"[infra] msan_builder: Add custom build hooks.

Add one for pulseaudio on xenial. ubuntu patches causes build failures
with recent clang.","
+from __future__ import print_function
+import glob
+import os
+import subprocess
+
+import package
+
+
+class Package(package.Package):
+ """"""PulseAudio package.""""""
+
+ def __init__(self):
+ super(Package, self).__init__('pulseaudio')
+
+ def PostDownload(self, source_directory):
+ """"""Remove blacklisted patches.""""""
+ # Fix *droid* patches.
+ bad_patch_path = os.path.join(
+ source_directory, 'debian', 'patches',
+ '0600-droid-sync-with-upstream-for-Android-5-support-and-b.patch')
+ if not os.path.exists(bad_patch_path):
+ return
+
+ print('Applying custom patches.')
+ package.ApplyPatch(source_directory, 'pulseaudio_fix_android.patch')
",17,3
msan_builder: remove unused import.," from __future__ import print_function
 import argparse
 import imp
 import os
-import re
 import shutil
 import subprocess
 import tempfile
",231,52
"msan_builder: Inject MSan flags in wrapper if they don't exist.

Some packages build test binaries that don't use DEB_C(XX)FLAGS and fail
during linking."," import os
 import subprocess
 import sys
 
+import msan_build
+
 
 def Is32Bit(args):
 """"""Return whether or not we're 32-bit.""""""
 def GetCompilerArgs(args):
 '-w',
 ])
 
+ if '-fsanitize=memory' not in args:
+ # If MSan flags weren't added for some reason, add them here.
+ compiler_args.extend(msan_build.INJECTED_ARGS)
+
 return compiler_args
 
 
",53,14
Build msan libs on our builders.," class Package(object):
 
 def InstallBuildDeps(self):
 """"""Install build dependencies for a package.""""""
+ subprocess.check_call(['apt-get', 'update'])
 subprocess.check_call(['apt-get', 'build-dep', '-y', self.name])
 
 def DownloadSource(self, download_directory):
",37,9
msan_builder: fix more issues.," def SetUpEnvironment(work_dir):
 env['DEB_CPPFLAGS_APPEND'] = env['DEB_CXXFLAGS_APPEND']
 env['DEB_LDFLAGS_APPEND'] = MSAN_OPTIONS
 env['DPKG_GENSYMBOLS_CHECK_LEVEL'] = '0'
+ env['FORCE_UNSAFE_CONFIGURE'] = '1'
 
 # debian/rules can set DPKG_GENSYMBOLS_CHECK_LEVEL explicitly, so override it.
 gen_symbols_wrapper = (
 def _CollectDependencies(apt_cache, pkg, cache, dependencies):
 ]
 
 BLACKLISTED_PACKAGES = [
+ 'defconf',
 'multiarch-support',
 ]
 
",265,54
msan_builder: improve dependency detection.," def _CollectDependencies(apt_cache, pkg, cache, dependencies):
 ]
 
 BLACKLISTED_PACKAGES = [
- 'defconf',
 'multiarch-support',
 ]
 
 if pkg.name in BLACKLISTED_PACKAGES:
 return False
 
+ if pkg.section != 'libs':
+ return False
+
 if pkg.name in C_OR_CXX_DEPS:
 return True
 
",266,55
"msan_builder: build openssl without asm, add tar override."," def SetUpEnvironment(work_dir):
 env['DEB_CPPFLAGS_APPEND'] = env['DEB_CXXFLAGS_APPEND']
 env['DEB_LDFLAGS_APPEND'] = MSAN_OPTIONS
 env['DPKG_GENSYMBOLS_CHECK_LEVEL'] = '0'
- env['FORCE_UNSAFE_CONFIGURE'] = '1'
 
 # debian/rules can set DPKG_GENSYMBOLS_CHECK_LEVEL explicitly, so override it.
 gen_symbols_wrapper = (
",265,55
msan_builder: fix typo," import shutil
 import package
 
 
-def AddNoAsmArg(origconfig_path):
+def AddNoAsmArg(config_path):
 """"""Add --no-asm to config scripts.""""""
 shutil.move(config_path, config_path + '.real')
 with open(config_path, 'w') as f:
",17,3
msan_builder: use -fno-integrated-as to fix libffi build.," import sys
 import msan_build
 
 
+def InvokedAsGcc():
+ """"""Return whether or not we're pretending to be GCC.""""""
+ return sys.argv[0].endswith('gcc') or sys.argv[0].endswith('g++')
+
+
 def Is32Bit(args):
 """"""Return whether or not we're 32-bit.""""""
 M32_BIT_ARGS = [
 def GetCompilerArgs(args):
 '-w',
 ])
 
+ if InvokedAsGcc():
+ compiler_args.extend([
+ # For better compatibility with flags passed via -Wa,...
+ '-fno-integrated-as',
+ ])
+
 if '-fsanitize=memory' not in args:
 # If MSan flags weren't added for some reason, add them here.
 compiler_args.extend(msan_build.INJECTED_ARGS)
",79,26
msan_builder: include libraries under universe section.," def FindPackageDebs(package_name, work_directory):
 
 # Also include -dev packages that depend on the runtime package.
 pkg = cache[deb.pkgname]
- if pkg.section != 'libdevel':
+ if pkg.section != 'libdevel' and pkg.section != 'universe/libdevel':
 continue
 
 # But ignore -dbg packages.
 def _CollectDependencies(apt_cache, pkg, cache, dependencies):
 if pkg.name in BLACKLISTED_PACKAGES:
 return False
 
- if pkg.section != 'libs':
+ if pkg.section != 'libs' and pkg.section != 'universe/libs':
 return False
 
 if pkg.name in C_OR_CXX_DEPS:
",280,64
[infra] Reland profile configuration needed for new code coverage. (#1050)," CONFIGURATIONS = {
 'sanitizer-memory' : [ 'SANITIZER=memory' ],
 'sanitizer-undefined' : [ 'SANITIZER=undefined' ],
 'sanitizer-coverage' : [ 'SANITIZER=coverage' ],
+ 'sanitizer-profile' : [ 'SANITIZER=profile' ],
 'engine-libfuzzer' : [ 'FUZZING_ENGINE=libfuzzer' ],
 'engine-afl' : [ 'FUZZING_ENGINE=afl' ],
 'engine-honggfuzz' : [ 'FUZZING_ENGINE=honggfuzz' ],
 EngineInfo = collections.namedtuple(
 ENGINE_INFO = {
 'libfuzzer': EngineInfo(
 upload_bucket='clusterfuzz-builds',
- supported_sanitizers=['address', 'memory', 'undefined', 'coverage']),
+ supported_sanitizers=['address', 'memory', 'undefined', 'coverage',
+ 'profile']),
 'afl': EngineInfo(
 upload_bucket='clusterfuzz-builds-afl',
 supported_sanitizers=['address']),
 def get_sanitizers(project_yaml):
 if 'coverage' not in processed_sanitizers:
 processed_sanitizers.append('coverage')
 
+ if 'profile' not in processed_sanitizers:
+ processed_sanitizers.append('profile')
+
 return processed_sanitizers
 
 
",220,23
"Revert of ""[infra] Reland profile configuration needed for new code coverage."".

See more information in comments for PR #1050."," CONFIGURATIONS = {
 'sanitizer-memory' : [ 'SANITIZER=memory' ],
 'sanitizer-undefined' : [ 'SANITIZER=undefined' ],
 'sanitizer-coverage' : [ 'SANITIZER=coverage' ],
- 'sanitizer-profile' : [ 'SANITIZER=profile' ],
 'engine-libfuzzer' : [ 'FUZZING_ENGINE=libfuzzer' ],
 'engine-afl' : [ 'FUZZING_ENGINE=afl' ],
 'engine-honggfuzz' : [ 'FUZZING_ENGINE=honggfuzz' ],
 EngineInfo = collections.namedtuple(
 ENGINE_INFO = {
 'libfuzzer': EngineInfo(
 upload_bucket='clusterfuzz-builds',
- supported_sanitizers=['address', 'memory', 'undefined', 'coverage',
- 'profile']),
+ supported_sanitizers=['address', 'memory', 'undefined', 'coverage']),
 'afl': EngineInfo(
 upload_bucket='clusterfuzz-builds-afl',
 supported_sanitizers=['address']),
 def get_sanitizers(project_yaml):
 if 'coverage' not in processed_sanitizers:
 processed_sanitizers.append('coverage')
 
- if 'profile' not in processed_sanitizers:
- processed_sanitizers.append('profile')
-
 return processed_sanitizers
 
 
",216,22
"[imagemagick] Imagemagick support (#1040)

* implement imagemagick fuzzing

* Compile one fuzzer per encoder

* oops, need this

* formatting!

* make the fuzzer per encoder work :)

* use ADD

* sizeof all teh things!

* oops

* add dirk as the primary contact

* use Degrees here

* extract just the images we want for the seed corpus (corpi?)

* use Width where possible

* add all sanitizers

* fix a foolish bug

* move the corpus gen to the end of build.sh","
+#include <cstdint>
+
+#include <Magick++/Blob.h>
+#include <Magick++/Image.h>
+
+extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) {
+ uint16_t Width;
+ uint16_t Height;
+ if (Size < (sizeof(Width) + sizeof(Height))) {
+ return 0;
+ }
+ Width = *reinterpret_cast<const uint16_t *>(Data);
+ Height = *reinterpret_cast<const uint16_t *>(Data + sizeof(Width));
+ const Magick::Blob blob(Data + sizeof(Width) + sizeof(Height),
+ Size - (sizeof(Width) + sizeof(Height)));
+ Magick::Image image;
+ try {
+ image.read(blob);
+ } catch (Magick::Exception &e) {
+ return 0;
+ }
+ image.crop(Magick::Geometry(Width, Height));
+ return 0;
+}
",22,3
msan_builder: overwrite existing files on extraction," def SetUpEnvironment(work_dir):
 print('Real clang at', env['REAL_CLANG_PATH'])
 compiler_wrapper_path = os.path.join(SCRIPT_DIR, 'compiler_wrapper.py')
 
- # Symlink binaries into TMP/bin
+ # 
+ binaries into TMP/bin
 bin_dir = os.path.join(work_dir, 'bin')
 os.mkdir(bin_dir)
 
 def ExtractLibraries(deb_paths, work_directory, output_directory):
 
 target_file_path = os.path.join(output_directory, rel_file_path)
 extracted.append(target_file_path)
+ 
+ if os.path.exists(target_file_path):
+ os.remove(target_file_path)
 
 if os.path.islink(file_path):
 link_path = os.readlink(file_path)
",283,65
Remove unwanted change from last commit," def SetUpEnvironment(work_dir):
 print('Real clang at', env['REAL_CLANG_PATH'])
 compiler_wrapper_path = os.path.join(SCRIPT_DIR, 'compiler_wrapper.py')
 
- # 
- binaries into TMP/bin
+ # Symlink binaries into TMP/bin
 bin_dir = os.path.join(work_dir, 'bin')
 os.mkdir(bin_dir)
 
",282,65
msan_builder: fix permission of patch_build.py," def get_build_steps(project_yaml, dockerfile_path):
 'args': [
 'bash',
 '-c',
- 'patch_build.py {0}'.format(out),
+ # TODO(ochang): Replace with just patch_build.py once permission in
+ # image is fixed.
+ 'python /usr/local/bin/patch_build.py {0}'.format(out),
 ],
 })
 
",235,23
Update patch_build.py," def Ldd(binary_path):
 
 def FindLib(path):
 """"""Find instrumented version of lib.""""""
+ candidate_path = os.path.join(MSAN_LIBS_PATH, path[1:])
+ if os.path.exists(candidate_path):
+ return candidate_path
+ 
 for lib_dir in os.listdir(MSAN_LIBS_PATH):
 candidate_path = os.path.join(MSAN_LIBS_PATH, lib_dir, path[1:])
 if os.path.exists(candidate_path):
",84,22
[infra] Increase copyright year in the templates automatically.,"
 
 from __future__ import print_function
 import argparse
+import datetime
 import errno
 import os
 import pipes
 def generate(args):
 print('Writing new files to', dir)
 
 template_args = {
- 'project_name' : args.project_name
+ 'project_name' : args.project_name,
+ 'year': datetime.datetime.now().year
 }
 with open(os.path.join(dir, 'project.yaml'), 'w') as f:
 f.write(templates.PROJECT_YAML_TEMPLATE % template_args)
",344,68
"[infra] Allow passing environment variables to run_fuzzer (#1075)

This allows setting additional sanitizer options, for example:

 run_fuzzer -e ASAN_OPTIONS=-allocator_may_return_null=0"," def main():
 run_fuzzer_parser = subparsers.add_parser(
 'run_fuzzer', help='Run a fuzzer.')
 _add_engine_args(run_fuzzer_parser)
+ _add_environment_args(run_fuzzer_parser)
 run_fuzzer_parser.add_argument('project_name', help='name of the project')
 run_fuzzer_parser.add_argument('fuzzer_name', help='name of the fuzzer')
 run_fuzzer_parser.add_argument('fuzzer_args', help='arguments to pass to the fuzzer',
 def run_fuzzer(args):
 return 1
 
 env = ['FUZZING_ENGINE=' + args.engine]
+ if args.e:
+ env += args.e
 
 run_args = sum([['-e', v] for v in env], []) + [
 '-v', '%s:/out' % os.path.join(BUILD_DIR, 'out', args.project_name),
",347,69
"Fix bug in -Wl,--no-undefined removal"," def FilterWlArg(arg):
 
 filtered = []
 for part in parts:
- if part == 'defs' or part == '--no-undefined':
+ if part == 'defs':
 removed = filtered.pop()
 assert removed == '-z'
 continue
 
+ if part == '--no-undefined':
+ continue
+ 
 filtered.append(part)
 
 if filtered:
 def RemoveZDefs(args):
 filtered = []
 
 for arg in args:
- if arg == '-Wl,defs' or arg == '-Wl,--no-undefined':
+ if arg == '-Wl,defs':
 _RemoveLastMatching(filtered, '-Wl,-z')
 continue
+ 
+ if arg == '-Wl,--no-undefined':
+ continue
 
 if arg.startswith('-Wl,'):
 arg = FilterWlArg(arg)
",83,26
msan-builder: Add hack to disable more tests during build.," def SetUpEnvironment(work_dir):
 
 env['PATH'] = bin_dir + ':' + os.environ['PATH']
 
+ # nocheck doesn't disable override_dh_auto_test. So we have this hack to try
+ # to disable ""make check"" or ""make test"" invocations.
+ make_wrapper = (
+ '#!/bin/bash\n'
+ 'if [ ""$1"" = ""test"" ] || [ ""$1"" = ""check"" ]; then\n'
+ ' exit 0\n'
+ 'fi\n'
+ '/usr/bin/make ""$@""\n')
+ wrapper_utils.InstallWrapper(bin_dir, 'make',
+ make_wrapper)
+
 # Prevent entire build from failing because of bugs/uninstrumented in tools
 # that are part of the build.
 msan_log_dir = os.path.join(work_dir, 'msan')
",290,65
"Projects: Include libsodium (#1051)

Add libsodium fuzzers.

Add secret_key_auth_fuzzer and secretbox_easy_fuzzer targets from libsodium.","
+#include <assert.h>
+#include <sodium.h>
+
+#include ""fake_random.h""
+
+extern ""C"" int LLVMFuzzerTestOneInput(const unsigned char *data, size_t size) {
+ int initialized = sodium_init();
+ assert(initialized >= 0);
+
+ setup_fake_random(data, size);
+
+ unsigned char key[crypto_auth_KEYBYTES];
+ unsigned char mac[crypto_auth_BYTES];
+
+ // this uses a deterministic generator
+ crypto_auth_keygen(key);
+
+ crypto_auth(mac, data, size, key);
+ crypto_auth_verify(mac, data, size, key);
+ return 0;
+}
",14,1
msan-builder: fix boost build.," def RemoveZDefs(args):
 return filtered
 
 
-def GetCompilerArgs(args):
+def GetCompilerArgs(args, is_cxx):
 """"""Generate compiler args.""""""
 compiler_args = args[1:]
 
 def GetCompilerArgs(args):
 # If MSan flags weren't added for some reason, add them here.
 compiler_args.extend(msan_build.INJECTED_ARGS)
 
+ if is_cxx:
+ compiler_args.append('-stdlib=libc++')
+
 return compiler_args
 
 
 def main(args):
 if is_cxx:
 real_clang += '++'
 
- args = [real_clang] + GetCompilerArgs(args)
+ args = [real_clang] + GetCompilerArgs(args, is_cxx)
 debug_log_path = os.getenv('WRAPPER_DEBUG_LOG_PATH')
 if debug_log_path:
 with open(debug_log_path, 'a') as f:
",85,27
"[mupdf] Fix fuzzer (#1091)

Without the document handlers registered, nothing gets fuzzed!","
 
 extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
 fz_context *ctx = fz_new_context(nullptr, nullptr, FZ_STORE_DEFAULT);
+ fz_register_document_handlers(ctx);
 
 fz_stream *stream = fz_open_memory(ctx, data, size);
 fz_matrix ctm;
",21,2
"msan-builder: disable libcapnp-0.5.3

multiple compile failures with clang."," def _CollectDependencies(apt_cache, pkg, cache, dependencies):
 ]
 
 BLACKLISTED_PACKAGES = [
+ 'libcapnp-0.5.3', # fails to compile on newer clang.
 'multiarch-support',
 ]
 
",292,65
msan-builder: upload libs as zip.,"
 Usage: build_base_images.py
 """"""
 
+import datetime
 import os
 import yaml
 
 def main():
 if ""GCB_OPTIONS"" in os.environ:
 options = yaml.safe_load(os.environ[""GCB_OPTIONS""])
 
+ image = 'gcr.io/oss-fuzz-base/msan-builder'
+ steps = build_base_images.get_steps(['msan-builder'])
+ ts = datetime.datetime.utcnow().strftime('%Y%m%d%H%M')
+ upload_name = 'msan-libs-' + ts + '.zip'
+
+ steps.extend([{
+ 'name': image,
+ 'args': [
+ 'bash',
+ '-c',
+ 'cd /msan && zip -r /workspace/libs.zip .',
+ ],
+ }, {
+ 'name': 'gcr.io/cloud-builders/gsutil',
+ 'args': [
+ 'cp',
+ '/workspace/libs.zip',
+ 'gs://oss-fuzz-msan-libs/' + upload_name,
+ ],
+ }])
+
 build_body = {
- 'steps': build_base_images.get_steps(['msan-builder']),
+ 'steps': steps,
 'timeout': str(6 * 3600) + 's',
 'options': options,
 'images': [
- 'gcr.io/oss-fuzz-base/msan-builder',
- ],
+ image,
+ ],
 }
 
 credentials = GoogleCredentials.get_application_default()
",48,2
[mupdf] Ensure document is always freed (#1094)," extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
 
 fz_stream *stream = fz_open_memory(ctx, data, size);
 fz_matrix ctm;
- fz_pixmap *pix;
+ fz_pixmap *pix = NULL;
+ fz_document *doc = NULL;
 fz_try(ctx) {
- fz_document *doc = fz_open_document_with_stream(ctx, ""pdf"", stream);
+ doc = fz_open_document_with_stream(ctx, ""pdf"", stream);
 for (int i = 0; i < fz_count_pages(ctx, doc); i++) {
 pix = fz_new_pixmap_from_page_number(ctx, doc, i, &ctm, fz_device_rgb(ctx), 0);
 fz_drop_pixmap(ctx, pix);
 }
- fz_drop_document(ctx, doc);
 }
 fz_catch(ctx) {}
 
+ if (doc) {
+ fz_drop_document(ctx, doc);
+ }
 fz_drop_stream(ctx, stream);
 fz_drop_context(ctx);
 
",24,3
[mupdf] Ensure ctm variable is initialized (#1102)," extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
 fz_register_document_handlers(ctx);
 
 fz_stream *stream = fz_open_memory(ctx, data, size);
- fz_matrix ctm;
+ fz_matrix ctm = fz_identity;
 fz_pixmap *pix = NULL;
 fz_document *doc = NULL;
 fz_try(ctx) {
",24,3
msan-builder: properly disable asm for gnutls and libgcrypt," import os
 import shutil
 
 import package
-
-
-def AddNoAsmArg(config_path):
- """"""Add --no-asm to config scripts.""""""
- shutil.move(config_path, config_path + '.real')
- with open(config_path, 'w') as f:
- f.write(
- '#!/bin/sh\n'
- '%s.real --disable-asm ""$@""\n' % config_path)
- os.chmod(config_path, 0755)
+import wrapper_utils
 
 
 class Package(package.Package):
 class Package(package.Package):
 super(Package, self).__init__('libgcrypt20', apt_version)
 
 def PreBuild(self, source_directory, env, custom_bin_dir):
- AddNoAsmArg(os.path.join(source_directory, 'configure'))
+ configure_wrapper = (
+ '#!/bin/bash\n'
+ '/usr/bin/dh_auto_configure ""$@"" --disable-asm')
+
+ wrapper_utils.InstallWrapper(
+ custom_bin_dir, 'dh_auto_configure', configure_wrapper)
",14,2
msan_builder: one more way to disable FORTIFY_SOURCE.," def GetCompilerArgs(args, is_cxx):
 compiler_args.extend([
 # FORTIFY_SOURCE is not supported by sanitizers.
 '-U_FORTIFY_SOURCE',
+ '-Wp,-U_FORTIFY_SOURCE',
 # Reduce binary size.
 '-gline-tables-only',
 # Disable all warnings.
",86,27
"coverage: docs and infra/helper.py fix. (#1126)

While trying to get a coverage report for a new project (Envoy),
building with the coverage sanitizer seemed necessary to get the
coverage files dumped.

Signed-off-by: Harvey Tuch <htuch@google.com>"," def _add_engine_args(parser):
 def _add_sanitizer_args(parser):
 """"""Add common sanitizer args.""""""
 parser.add_argument('--sanitizer', default='address',
- choices=['address', 'memory', 'undefined'])
+ choices=['address', 'memory', 'undefined', 'coverage'])
 
 
 def _add_environment_args(parser):
",347,69
"infra/helper: persist /root directory via bind mount. (#1125)

For Bazel builds, this preserves the Bazel cache across multiple
invocations of build_fuzzers, which significantly speeds up the build
and reduces the debug cycle for new projects.

Signed-off-by: Harvey Tuch <htuch@google.com>"," def build_fuzzers(args):
 '%s:/src/%s' % (_get_absolute_path(args.source_path), args.project_name)
 ]
 command += [
+ '-v', '%s:/root' % os.path.join(BUILD_DIR, 'root', project_name),
 '-v', '%s:/out' % os.path.join(BUILD_DIR, 'out', project_name),
 '-v', '%s:/work' % os.path.join(BUILD_DIR, 'work', project_name),
 '-t', 'gcr.io/oss-fuzz/%s' % project_name
",348,69
[infra] Update upload URL timeout to be the same as build timeout (#1112)," def load_project_yaml(project_dir):
 
 
 def get_signed_url(path):
- timestamp = int(time.time() + 60 * 60 * 5)
+ timestamp = int(time.time() + BUILD_TIMEOUT)
 blob = 'PUT\n\n\n{0}\n{1}'.format(
 timestamp, path)
 
",235,23
"[json-c] Add project (#1123)

* Add a fuzzer for json_tokener_parse_ex. detect_leaks=0

* remove comments, add email

* remove options file

* free the object; the fuzzer was responsible for the leak

* remove control characters

* make the dict match the fuzzer for the convention to load the dict

* decl and use

* fix signature, reinterpret

* add hawicz's email","
+#include <stdint.h>
+
+#include <json.h>
+
+extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
+ const char *data1 = reinterpret_cast<const char *>(data);
+ json_tokener *tok = json_tokener_new();
+ json_object *obj = json_tokener_parse_ex(tok, data1, size);
+
+ json_object_put(obj);
+ json_tokener_free(tok);
+ return 0;
+}
",10,1
msan-builder: support building without origin tracking.," def RemoveZDefs(args):
 if arg == '-Wl,defs':
 _RemoveLastMatching(filtered, '-Wl,-z')
 continue
- 
+
 if arg == '-Wl,--no-undefined':
 continue
 
 def GetCompilerArgs(args, is_cxx):
 
 if '-fsanitize=memory' not in args:
 # If MSan flags weren't added for some reason, add them here.
- compiler_args.extend(msan_build.INJECTED_ARGS)
+ compiler_args.extend(msan_build.GetInjectedFlags())
 
 if is_cxx:
 compiler_args.append('-stdlib=libc++')
",86,27
msan-builder: Set MSAN_NO_TRACK_ORIGINS in child environment too.," def GetBuildList(package_name):
 class MSanBuilder(object):
 """"""MSan builder.""""""
 
- def __init__(self, debug=False, log_path=None, work_dir=None):
+ def __init__(self, debug=False, log_path=None, work_dir=None, no_track_origins=False):
 self.debug = debug
 self.log_path = log_path
 self.work_dir = work_dir
+ self.no_track_origins = no_track_origins
 self.env = None
 
 def __enter__(self):
 class MSanBuilder(object):
 if self.debug and self.log_path:
 self.env['WRAPPER_DEBUG_LOG_PATH'] = self.log_path
 
+ if self.no_track_origins:
+ self.env['MSAN_NO_TRACK_ORIGINS'] = '1'
+
 return self
 
 def __exit__(self, exc_type, exc_value, traceback):
 def main():
 print('\t', package_name)
 
 with MSanBuilder(debug=args.debug, log_path=args.log_path,
- work_dir=args.work_dir) as builder:
+ work_dir=args.work_dir,
+ no_track_origins=args.no_track_origins) as builder:
 for package_name in package_names:
 builder.Build(package_name, args.output_dir, args.create_subdirs)
 
",312,70
Discontinue in-memory fuzzing for unrar (#1169),"
+#include <fstream>
 #include <memory>
+#include <sstream>
 #include <string>
 #include <unistd.h>
 

 
 extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
 static const std::string filename = ""temp.rar"";
+ std::ofstream file(filename,
+ std::ios::binary | std::ios::out | std::ios::trunc);
+ if (!file.is_open()) {
+ return 0;
+ }
+ file.write(reinterpret_cast<const char *>(data), size);
+ file.close();
 
 std::unique_ptr<CommandData> cmd_data(new CommandData);
 cmd_data->ParseArg(const_cast<wchar_t *>(L""-p""));
 cmd_data->ParseArg(const_cast<wchar_t *>(L""x""));
 cmd_data->ParseDone();
 std::wstring wide_filename(filename.begin(), filename.end());
- cmd_data->SetArcInMem(const_cast<unsigned char *>(data), size);
 cmd_data->AddArcName(wide_filename.c_str());
 
 try {
 extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
 } catch (...) {
 }
 
+ unlink(filename.c_str());
 return 0;
 }
",29,3
"[infra] Install deps in base-image, and separate out base-msan-builder.","
+#!/usr/bin/env python
+# Copyright 2017 Google Inc.
+#
+# Licensed under the Apache License, Version 2.0 (the ""License"");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an ""AS IS"" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+################################################################################
+
+import package
+
+
+class Package(package.Package):
+ """"""mesa package.""""""
+
+ def __init__(self, apt_version):
+ super(Package, self).__init__('mesa', apt_version)
+
+ def PreBuild(self, source_directory, env, custom_bin_dir):
+ env['DEB_CXXFLAGS_APPEND'] += ' -std=c++11'
",7,2
msan_builder: Don't build indep packages.," class Package(object):
 """"""Build .deb packages.""""""
 self.PreBuild(source_directory, env, custom_bin_dir)
 subprocess.check_call(
- ['dpkg-buildpackage', '-us', '-uc', '-b'],
+ ['dpkg-buildpackage', '-us', '-uc', '-B'],
 cwd=source_directory, env=env)
 self.PostBuild(source_directory, env, custom_bin_dir)
 
",37,9
msan_builder: reload apt package after update.," class Package(object):
 subprocess.check_call(['apt-get', 'update'])
 subprocess.check_call(['apt-get', 'build-dep', '-y', self.name])
 
+ # Reload package after update.
+ self.apt_version = (
+ apt.Cache()[self.apt_version.package.name].candidate)
+
 def DownloadSource(self, download_directory):
 """"""Download the source for a package.""""""
 self.PreDownload(download_directory)
",39,9
msan_builder: override -flto," def GetCompilerArgs(args, is_cxx):
 '-gline-tables-only',
 # Disable all warnings.
 '-w',
+ # LTO isn't supported.
+ '-fno-lto',
 ])
 
 if InvokedAsGcc():
",87,27
"msan_builder: fall back to GCC in rare cases.

e.g. when -aux-info is passed."," import sys
 
 import msan_build
 
+GCC_ONLY_ARGS = [
+ '-aux-info',
+]
+
 
 def InvokedAsGcc():
 """"""Return whether or not we're pretending to be GCC.""""""
 def FindRealClang():
 return os.environ['REAL_CLANG_PATH']
 
 
+def FallbackToGcc(args):
+ """"""Check whether if we should fall back to GCC.""""""
+ if not InvokedAsGcc():
+ return False
+
+ return any(arg in GCC_ONLY_ARGS for arg in args[1:])
+
+
 def main(args):
+ if FallbackToGcc(args):
+ sys.exit(subprocess.call(['/usr/bin/' + os.path.basename(args[0])] +
+ args[1:]))
+
 is_cxx = args[0].endswith('++')
 real_clang = FindRealClang()
 
",97,31
Add base-msan-builder to base images build.," BASE_IMAGES = [
 'base-builder',
 'base-runner',
 'base-runner-debug',
+ 'base-msan-builder',
 ]
 
 TAG_PREFIX = 'gcr.io/oss-fuzz-base/'
",55,5
msan-builder: suppress pixman false positive," class Package(package.Package):
 'sed s/support_for_gcc_vector_extensions=yes/'
 'support_for_gcc_vector_extensions=no/ -i %s/configure.ac' %
 source_directory)
+
+ def PreBuild(self, source_directory, env, custom_bin_dir):
+ blacklist_flag = ' -fsanitize-blacklist=' + os.path.join(
+ os.path.dirname(os.path.abspath(__file__)),
+ 'pixman_blacklist.txt')
+ env['DEB_CXXFLAGS_APPEND'] += blacklist_flag
+ env['DEB_CFLAGS_APPEND'] += blacklist_flag
",18,3
fix pixman msan blacklist.," def main():
 options = yaml.safe_load(os.environ[""GCB_OPTIONS""])
 
 image = 'gcr.io/oss-fuzz-base/msan-builder'
- steps = build_base_images.get_steps(['msan-builder'])
+ steps = build_base_images.get_steps(['base-msan-builder', 'msan-builder'])
 ts = datetime.datetime.utcnow().strftime('%Y%m%d%H%M')
 upload_name = 'msan-libs-' + ts + '.zip'
 
 def main():
 'timeout': str(6 * 3600) + 's',
 'options': options,
 'images': [
+ 'gcr.io/oss-fuzz-base/base-msan-builder',
 image,
 ],
 }
",49,2
"helper: use return code from docker run for reproduce, run_fuzzer.

Fixes #1246."," def docker_run(run_args, print_output=True):
 
 try:
 subprocess.check_call(command, stdout=stdout, stderr=subprocess.STDOUT)
- except subprocess.CalledProcessError:
- return False
+ except subprocess.CalledProcessError as e:
+ return e.returncode
 
- return True
+ return 0
 
 
 def docker_build(build_args, pull=False):
 def run_fuzzer(args):
 args.fuzzer_name,
 ] + args.fuzzer_args
 
- docker_run(run_args)
+ return docker_run(run_args)
 
 
 def coverage(args):
 def reproduce(args):
 '-runs=100',
 ] + args.fuzzer_args
 
- docker_run(run_args)
+ return docker_run(run_args)
 
 
 def generate(args):
",347,69
"[libexif] add libexif (#1285)

* add libexif

* make the fuzzer parse a bit more

* review feedback, be less confusing with Data and data vars

* added primary contact","
+#include <stdio.h>
+#include <stdint.h>
+#include <libexif/exif-loader.h>
+
+
+void content_func(ExifEntry *entry, void *user_data) {
+ char buf[10000];
+ exif_entry_get_value(entry, buf, sizeof(buf));
+}
+
+void data_func(ExifContent *content, void *user_data) {
+ exif_content_foreach_entry(content, content_func, NULL);
+}
+
+extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
+ ExifLoader *loader = exif_loader_new();
+ ExifData *exif_data;
+ if (!loader) {
+ return 0;
+ }
+ exif_loader_write(loader, const_cast<unsigned char*>(data), size);
+ exif_data = exif_loader_get_data(loader);
+ if(!exif_data) {
+ exif_loader_unref(loader);
+ return 0;
+ }
+ exif_data_foreach_content(exif_data, data_func, NULL);
+ exif_loader_unref(loader);
+ exif_data_unref(exif_data);
+ return 0;
+}
",27,5
Allow passing environment variables to reproducer (#1312)," def main():
 reproduce_parser.add_argument('testcase_path', help='path of local testcase')
 reproduce_parser.add_argument('fuzzer_args', help='arguments to pass to the fuzzer',
 nargs=argparse.REMAINDER)
+ _add_environment_args(reproduce_parser)
 
 shell_parser = subparsers.add_parser(
 'shell', help='Run /bin/bash in an image.')
 def reproduce(args):
 image_name = 'base-runner-debug'
 env += ['DEBUGGER=' + debugger]
 
+ if args.e:
+ env += args.e
+
 run_args = sum([['-e', v] for v in env], []) + [
 '-v', '%s:/out' % os.path.join(BUILD_DIR, 'out', args.project_name),
 '-v', '%s:/testcase' % _get_absolute_path(args.testcase_path),
",350,70
"Add msgpack-c (#1313)

Add fuzzer for pack and unpack functions","
+#include <msgpack.hpp>
+
+extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
+ try {
+ // NOTE(derwolfe): by default the limits are set at 2^32-1 length. I'm
+ // setting these at far smaller values to avoid OOMs
+ const int test_limit = 10000;
+ msgpack::object_handle unpacked = msgpack::unpack(reinterpret_cast<const char *>(data),
+ size,
+ nullptr,
+ nullptr,
+ msgpack::unpack_limit(test_limit,
+ test_limit,
+ test_limit,
+ test_limit));
+ msgpack::sbuffer sbuf;
+ msgpack::pack(sbuf, unpacked.get());
+ } catch (...) {
+ }
+ return 0;
+}
",18,2
[augeas] Fix fuzz target that was crashing on a startup (fixes #1326).,"
 int escape_match(const uint8_t *data, size_t size){
 augeas *aug = aug_init(NULL, NULL, AUG_NONE);
 std::string data_string(reinterpret_cast<const char*>(data), size);
- char *out;
+ char *out = NULL;
 aug_escape_name(aug, data_string.c_str(), &out);
 if (out != NULL){
 aug_match(aug, out, NULL);
 int escape_match(const uint8_t *data, size_t size){
 aug_match(aug, data_string.c_str(), NULL);
 }
 aug_close(aug);
- delete[] out;
+ free(out);
 return 0;
 }
 
",21,3
"[infra] Invoke run_fuzzer from bad_build_check for regression testing (fixes #1355). (#1357)

* [infra] Invoke run_fuzzer from bad_build_check for regression testing (fixes #1355).

* Address review comments."," def get_build_steps(project_yaml, dockerfile_path):
 env.append('OUT=' + out)
 env.append('MSAN_LIBS_PATH=/workspace/msan')
 
- # To disable running of all fuzz targets while doing |test_all| step, as
- # that step is currently being used for performing bad build checks only.
- env.append('SKIP_TEST_TARGET_RUN=1')
-
 workdir = workdir_from_dockerfile(dockerfile_path)
 if not workdir:
 workdir = '/src'
",244,23
[poppler] ignore locked documents (#1437)," extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
 poppler::set_debug_error_function(nop_func, nullptr);
 
 poppler::document *doc = poppler::document::load_from_raw_data((const char *)data, size);
- if (!doc) {
+ if (!doc || doc->is_locked()) {
 return 0;
 }
 
",24,6
[poppler] ensure doc doesn't leak when locked (#1438)," extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
 
 poppler::document *doc = poppler::document::load_from_raw_data((const char *)data, size);
 if (!doc || doc->is_locked()) {
+ delete doc;
 return 0;
 }
 
",25,6
[infra] Bring 'profile' configuration back to helper.py for testing coverage.," def _add_engine_args(parser):
 def _add_sanitizer_args(parser):
 """"""Add common sanitizer args.""""""
 parser.add_argument('--sanitizer', default='address',
- choices=['address', 'memory', 'undefined', 'coverage'])
+ choices=['address', 'memory', 'undefined', 'coverage', 'profile'])
 
 
 def _add_environment_args(parser):
",407,80
Add MSAn instrumented libraries steps to build_fuzzers (#1419). (#1482)," import subprocess
 import sys
 
 INSTRUMENTED_LIBRARIES_DIRNAME = 'instrumented_libraries'
-MSAN_LIBS_PATH = '/msan'
+MSAN_LIBS_PATH = os.getenv('MSAN_LIBS_PATH', '/msan')
 
 
 def IsElf(file_path):
 def PatchBuild(output_directory):
 """"""Patch build to use msan libs.""""""
 instrumented_dir = os.path.join(output_directory,
 INSTRUMENTED_LIBRARIES_DIRNAME)
- os.mkdir(instrumented_dir)
+ if not os.path.exists(instrumented_dir):
+ os.mkdir(instrumented_dir)
 
 for root_dir, _, filenames in os.walk(output_directory):
 for filename in filenames:
",85,23
"libcoap: OSS-Fuzz integration (#1496)

* libcoap: OSS-Fuzz integration

* libcoap: Addressed comments by @inferno-chromium","
+/*
+# Copyright 2018 Google Inc.
+#
+# Licensed under the Apache License, Version 2.0 (the ""License"");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an ""AS IS"" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+################################################################################
+*/
+
+#include <coap.h>
+
+int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size)
+{
+ coap_pdu_t *pdu = coap_pdu_init(0, 0, 0, size);
+ if (!pdu) return 0;
+ 
+ coap_pdu_parse(COAP_PROTO_UDP, data, size, pdu);
+ coap_delete_pdu(pdu);
+ return 0;
+}
",9,2
"[libwebp] preparation for more fuzz targets (#1499)

* replace wget with ADD

* no C++ in libwebp

* move common to header","
+#include <stdint.h>
+#include <stdlib.h>
+
+// Arbitrary limit to prevent OOM, timeout, or slow execution.
+static const size_t fuzz_px_limit = 1024 * 1024;
+
+// Reads and sums (up to) 128 spread-out bytes.
+static uint8_t fuzz_hash(const uint8_t* data, size_t size) {
+ uint8_t value = 0;
+ size_t incr = size / 128;
+ if (!incr) incr = 1;
+ for (size_t i = 0; i < size; i += incr)
+ value += data[i];
+ return value;
+}
",11,3
"Don't allow project names longer than 26 characters. (#1507)

This is required to have service accounts with name of the form
bot-<project_name> which needs to be within 30 characters."," BASE_IMAGES = [
 ]
 
 VALID_PROJECT_NAME_REGEX = re.compile(r'^[a-zA-Z0-9_-]+$')
+MAX_PROJECT_NAME_LENGTH = 26
 
 
 def main():
 def reproduce(args):
 
 def generate(args):
 """"""Generate empty project files.""""""
+ if len(args.project_name) > MAX_PROJECT_NAME_LENGTH:
+ print('Project name needs to be less than or equal to %d characters.' %
+ MAX_PROJECT_NAME_LENGTH, file=sys.stderr)
+ return 1
+
 if not VALID_PROJECT_NAME_REGEX.match(args.project_name):
 print('Invalid project name.', file=sys.stderr)
 return 1
",429,80
[libaom] Add a threaded mode for the fuzzer. (#1509),"
 #include ""aom_ports/mem_ops.h""
 #include ""aom/common/ivfdec.h""
 
-// TODO(urvang): Create a 2nd fuzz target that defines DECODE_MODE_threaded.
-#define DECODE_MODE_serial
-
 static const char *const kIVFSignature = ""DKIF"";
 
 extern ""C"" void usage_exit(void) { exit(EXIT_FAILURE); }
",49,10
libaom: Remove fuzzer name suffix for serial mode. (#1511)," extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
 
 aom_codec_ctx_t codec;
 
-#if defined(DECODE_MODE_serial)
+#if defined(DECODE_MODE)
 const int threads = 1;
 #elif defined(DECODE_MODE_threaded)
 const int threads = 16;
 #else
-#error define one of DECODE_MODE_(serial|threaded)
+#error define one of DECODE_MODE or DECODE_MODE_threaded
 #endif
 aom_codec_dec_cfg_t cfg = {threads, 0, 0};
 if (aom_codec_dec_init(&codec, decoder->codec_interface(), &cfg, 0)) {
",49,10
Refs #799 -- use python to listdir instead of shelling out to find (#1519)," def check_build(args):
 
 def _get_fuzz_targets(project_name):
 """"""Return names of fuzz targest build in the project's /out directory.""""""
- command = [
- 'find',
- _get_output_dir(project_name),
- '-maxdepth',
- '1',
- '-type',
- 'f',
- '-executable'
+ return [
+ p
+ for p in os.listdir(_get_output_dir(project_name))
+ if os.access(p, os.X_OK)
 ]
- output = subprocess.check_output(command)
- return [os.path.basename(path) for path in output.split()]
 
 
 def _get_latest_corpus(project_name, fuzz_target, base_corpus_dir):
",542,100
[infra] profile: do not run fuzz targets if corpus downloading has failed.," def download_corpus(project_name):
 def _download_for_single_target(fuzz_target):
 try:
 _get_latest_corpus(project_name, fuzz_target, corpus_dir)
+ return True
 except Exception as e:
 print('ERROR: corpus download for %s failed: %s' % (fuzz_target, str(e)),
 file=sys.stderr)
+ return False
 
 print('Downloading corpus for %s project' % project_name)
 thread_pool = ThreadPool(multiprocessing.cpu_count())
- thread_pool.map(_download_for_single_target, fuzz_targets)
- return True
+ return not False in thread_pool.map(_download_for_single_target, fuzz_targets)
 
 
 def profile(args):
",562,104
[infra] helper.py profile: do not append project name prefix to fuzz target name if it is there.," if sys.version_info[0] >= 3:
 
 CORPUS_URL_FORMAT = (
 'gs://{project_name}-corpus.clusterfuzz-external.appspot.com/libFuzzer/'
- '{project_name}_{fuzz_target}/')
+ '{fuzz_target}/')
 CORPUS_BACKUP_URL_FORMAT = (
 'gs://{project_name}-backup.clusterfuzz-external.appspot.com/corpus/'
- 'libFuzzer/{project_name}_{fuzz_target}/')
+ 'libFuzzer/{fuzz_target}/')
 
 
 def main():
 def _get_latest_corpus(project_name, fuzz_target, base_corpus_dir):
 if not os.path.exists(corpus_dir):
 os.makedirs(corpus_dir)
 
+ if not fuzz_target.startswith(project_name):
+ fuzz_target = '%s_%s' % (project_name, fuzz_target)
+
 corpus_backup_url = CORPUS_BACKUP_URL_FORMAT.format(project_name=project_name,
 fuzz_target=fuzz_target)
 command = [
",564,105
"[infra] helper.py: rewrite conditional to be more readable and idiomatic (#1534)

* Rewerite conditional to be more readable and idiomatic

* In fact, simplify further"," def download_corpus(project_name):
 
 print('Downloading corpus for %s project' % project_name)
 thread_pool = ThreadPool(multiprocessing.cpu_count())
- return not False in thread_pool.map(_download_for_single_target, fuzz_targets)
+ return all(thread_pool.map(_download_for_single_target, fuzz_targets))
 
 
 def profile(args):
",564,105
"Add support for running perffuzz in infra/helper.py (#1540)

* Add support for running perffuzz in infra/helper.py
https://github.com/carolemieux/perffuzz

* Update compile_perffuzz

* Update run_fuzzer"," def _get_work_dir(project_name=''):
 def _add_engine_args(parser):
 """"""Add common engine args.""""""
 parser.add_argument('--engine', default='libfuzzer',
- choices=['libfuzzer', 'afl', 'honggfuzz', 'none'])
+ choices=['libfuzzer', 'afl', 'honggfuzz', 'perffuzz',
+ 'none'])
 
 
 def _add_sanitizer_args(parser):
",588,112
"[libaom] av1_dec_fuzzer.cc: correct ivfdec.h include (#1541)

ivfdec.h is under common/, remove the aom prefix which would require an include path to $SRC in addition to $SRC/aom for the others.","
 #include ""aom/aom_decoder.h""
 #include ""aom/aomdx.h""
 #include ""aom_ports/mem_ops.h""
-#include ""aom/common/ivfdec.h""
+#include ""common/ivfdec.h""
 
 static const char *const kIVFSignature = ""DKIF"";
 
",49,10
[Openvswitch] Project integration (#1553),"
+/*
+# Copyright 2018 Google Inc.
+#
+# Licensed under the Apache License, Version 2.0 (the ""License"");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an ""AS IS"" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+################################################################################
+*/
+
+#include ""flow.h""
+#include ""dp-packet.h""
+
+int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size)
+{
+ struct dp_packet packet;
+ struct flow flow;
+
+ dp_packet_use_const(&packet, data, size);
+ flow_extract(&packet, &flow);
+ return 0;
+}
\ No newline at end of file
",10,1
"Ovs syslog clean disable (#1558)

* Openvswitch: Disable logging only once","
 
 int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size)
 {
+ static bool isInit = false;
 struct ofpbuf b;
 if (size < sizeof(struct ofp_header)) return 0;
 
- vlog_set_verbosity(""off"");
+ if (!isInit) {
+vlog_set_verbosity(""off"");
+isInit = true;
+ }
 
 ofpbuf_use_const(&b, data, size);
 for (;;) {
",30,7
"[libwebp] more targets (#1552)

* new target: advanced decoding api

* new target: animation decoding api

* new target: (de)mux API

* prefer copying dict to using options files","
 #include <stdint.h>
 #include <stdlib.h>
 
-// Arbitrary limit to prevent OOM, timeout, or slow execution.
+// Arbitrary limits to prevent OOM, timeout, or slow execution.
+//
+// The decoded image size, and for animations additionally the canvas size.
 static const size_t fuzz_px_limit = 1024 * 1024;
+// Demuxed or decoded animation frames.
+static const int fuzz_frame_limit = 3;
 
 // Reads and sums (up to) 128 spread-out bytes.
 static uint8_t fuzz_hash(const uint8_t* data, size_t size) {
",12,3
"Revert ""Add support for running perffuzz in infra/helper.py (#1540)"" (#1578)

This reverts commit 7f26e2fd92b427931d15cf7e243a09e89fb3fd27."," def _get_work_dir(project_name=''):
 def _add_engine_args(parser):
 """"""Add common engine args.""""""
 parser.add_argument('--engine', default='libfuzzer',
- choices=['libfuzzer', 'afl', 'honggfuzz', 'perffuzz',
- 'none'])
+ choices=['libfuzzer', 'afl', 'honggfuzz', 'none'])
 
 
 def _add_sanitizer_args(parser):
",587,112
"libaom: call codec_destroy at the end. (#1583)

This call was mistakenly missing earlier.

BUG=oss-fuzz:8849
BUG=oss-fuzz:8853"," extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
 ++frame_out_cnt;
 }
 }
-
+ aom_codec_destroy(&codec);
 fclose(file);
 free(buffer);
 return 0;
",50,10
"[mupdf] Adapt to recent API change, so test compiles again. (#1601)"," extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
 fz_register_document_handlers(ctx);
 
 fz_stream *stream = fz_open_memory(ctx, data, size);
- fz_matrix ctm = fz_identity;
 fz_pixmap *pix = NULL;
 fz_document *doc = NULL;
 fz_try(ctx) {
 doc = fz_open_document_with_stream(ctx, ""pdf"", stream);
 for (int i = 0; i < fz_count_pages(ctx, doc); i++) {
- pix = fz_new_pixmap_from_page_number(ctx, doc, i, &ctm, fz_device_rgb(ctx), 0);
+ pix = fz_new_pixmap_from_page_number(ctx, doc, i, fz_identity, fz_device_rgb(ctx), 0);
 fz_drop_pixmap(ctx, pix);
 }
 }
",23,3
[firefox] add used attribute to magic string,"
 #define STRINGIFY(S) STRINGLIT(S)
 
 // Required for oss-fuzz to consider the binary a target.
-static const char* magic = ""LLVMFuzzerTestOneInput"";
+static const char* magic __attribute__((used)) = ""LLVMFuzzerTestOneInput"";
 
 int main(int argc, char* argv[]) {
 char path[PATH_MAX] = {0};
",57,11
pyformat python code in gcb dir.,"
 #!/usr/bin/python2
-
 """"""Cancels project build on Google Cloud Builder.
 
 Usage: cancel.py <build_id>
 from oauth2client.client import GoogleCredentials
 from oauth2client.service_account import ServiceAccountCredentials
 from googleapiclient.discovery import build
 
+
 def usage():
- sys.stderr.write(
- ""Usage: "" + sys.argv[0] + "" <build_id>\n"")
+ sys.stderr.write('Usage: ' + sys.argv[0] + ' <build_id>\n')
 exit(1)
 
 
 def main():
 projectId='oss-fuzz', id=build_id, body={}).execute()
 
 
-if __name__ == ""__main__"":
+if __name__ == '__main__':
 main()
",29,3
gcb: add env to targets_list step," def get_build_steps(project_yaml, dockerfile_path):
 {
 'name':
 'gcr.io/oss-fuzz-base/base-runner',
+ 'env': env,
 'args': [
 'bash',
 '-c',
",276,24
[infra] Print logs URL for base images and msan libs. (#1666)," Usage: build_base_images.py
 """"""
 
 import os
+import sys
 import yaml
 
 from oauth2client.client import GoogleCredentials
 def get_steps(images):
 return steps
 
 
+def get_logs_url(build_id):
+ URL_FORMAT = ('https://console.developers.google.com/logs/viewer?'
+ 'resource=build%2Fbuild_id%2F{0}&project=oss-fuzz-base')
+ return URL_FORMAT.format(build_id)
+
+
 def main():
 options = {}
 if 'GCB_OPTIONS' in os.environ:
 def main():
 projectId='oss-fuzz-base', body=build_body).execute()
 build_id = build_info['metadata']['build']['id']
 
+ print >> sys.stderr, 'Logs:', get_logs_url(build_id)
 print build_id
 
 
",61,6
[GLib] Integration (#1670),"
+#include ""glib/glib.h""
+#include <stdint.h>
+
+int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
+ g_autoptr(GBookmarkFile) bookmarkfile = g_bookmark_file_new();
+ g_bookmark_file_load_from_data(bookmarkfile, (const gchar*)data, size, NULL);
+ return 0;
+}
",7,1
firefox: Try setting fake HOME (#1462)," int main(int argc, char* argv[]) {
 perror(""Error setting fuzzing variables"");
 exit(1);
 }
+ 
+ if (setenv(""HOME"", ""/tmp"", 0)) {
+ perror(""Error setting HOME"");
+ exit(1);
+ }
 
 // Temporary (or permanent?) work-around for a bug in the fuzzing interface.
 // https://bugzilla.mozilla.org/show_bug.cgi?id=1466021#c9
",61,12
"[glib] GLib: more targets (#1695)

* better seed corpus for fuzz_key

* new target: fuzz_variant_text

* new target: fuzz_dbus_message

* get ninja from pip

* remove target: fuzz_markup

* new target: fuzz_variant_binary","
+#include ""gio/gio.h""
+#include <stdint.h>
+
+static GDBusCapabilityFlags flags = G_DBUS_CAPABILITY_FLAGS_UNIX_FD_PASSING;
+
+int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
+ gssize bytes = g_dbus_message_bytes_needed((guchar*)data, size, NULL);
+ if (bytes <= 0 || bytes > (100 << 20))
+ return 0;
+
+ g_autoptr(GDBusMessage) msg =
+ g_dbus_message_new_from_blob((guchar*)data, size, flags, NULL);
+ if (!msg)
+ return 0;
+
+ gsize msg_size;
+ g_autofree guchar* blob = g_dbus_message_to_blob(msg, &msg_size, flags, NULL);
+ return 0;
+}
",15,4
[infra] Prevent mounting local checkout to $SRC + clean up Dockerfiles (#1699). (#1700)," def _env_to_docker_args(env_list):
 return sum([['-e', v] for v in env_list], [])
 
 
-def _workdir_from_dockerfile(dockerfile_path):
- """"""Parse WORKDIR from the Dockerfile.""""""
- WORKDIR_REGEX = re.compile(r'\s*WORKDIR\s*([^\s]+)')
+def _workdir_from_dockerfile(project_name):
+ """"""Parse WORKDIR from the Dockerfile for the given project.""""""
+ WORKDIR_REGEX = re.compile(r'\s*WORKDIR\s*(\$SRC/[^\s]+)')
+ dockerfile_path = _get_dockerfile_path(project_name)
 
 with open(dockerfile_path) as f:
 lines = f.readlines()
 def build_fuzzers(args):
 command += [
 '-v',
 '%s:%s' % (_get_absolute_path(args.source_path),
- _workdir_from_dockerfile(
- _get_dockerfile_path(args.project_name))),
+ _workdir_from_dockerfile(args.project_name)),
 ]
 command += [
 '-v', '%s:/out' % project_out_dir,
",609,118
"[glib] GLib: remove names from dictionary (#1706)

* consistency

* remove names from dictionary","
 int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
 g_autoptr(GVariant) variant = g_variant_new_from_data(
 G_VARIANT_TYPE_VARIANT, data, size, FALSE, NULL, NULL);
- if (variant) {
- g_variant_get_normal_form(variant);
- g_variant_get_data(variant);
- }
+ if (!variant)
+ return 0;
+ g_variant_get_normal_form(variant);
+ g_variant_get_data(variant);
 return 0;
 }
",11,2
"[infra] profile command: do not fail hard if some fuzz targets have no corpus. (#1719)

* [infra] profile command: do not fail hard if some fuzz targets have no corpus.

* Change listing to corpus_listing to be more explicit.

* Address review comment from Abhishek"," def _get_latest_corpus(project_name, fuzz_target, base_corpus_dir):
 'ls',
 corpus_backup_url
 ]
- output = subprocess.check_output(command).splitlines()
+
+ corpus_listing = subprocess.Popen(
+ command, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
+ output, error = corpus_listing.communicate()
+
+ # Some fuzz targets (e.g. new ones) may not have corpus yet, just skip those.
+ if corpus_listing.returncode:
+ print('WARNING: corpus for {0} not found:\n{1}'.format(fuzz_target, error),
+ file=sys.stderr)
+ return
+
 if output:
- latest_backup_url = output[-1]
+ latest_backup_url = output.splitlines()[-1]
 archive_path = corpus_dir + '.zip'
 command = [
 'gsutil',
",618,120
"firefox: fix LD_LIBRARY_PATH (#1734)

* sync internal libFuzzer to HEAD

* fix LD_LIBRARY_PATH set by previous call in same run"," int main(int argc, char* argv[]) {
 strcpy(ff_path, path);
 strcat(ff_path, ""/firefox/firefox"");
 
- if (getenv(""LD_LIBRARY_PATH"")) {
- // Shouldn't be set. Code can be changed to append if it ever is.
- fprintf(stderr, ""LD_LIBRARY_PATH unexpectedly set\n"");
- exit(1);
- }
+ // Expects LD_LIBRARY_PATH to not also be set by oss-fuzz.
+ // If it ever is, this has to be replaced with more complex code.
 if (setenv(""LD_LIBRARY_PATH"", ld_path, 0)) {
 perror(""Error setting LD_LIBRARY_PATH"");
 exit(1);
",62,14
[infra] Do not mark coverage job as failed when there are no targets list (follow-up for #1547).," def get_build_steps(project_dir):
 fuzz_targets = get_targets_list(project_name)
 if not fuzz_targets:
 sys.stderr.write('No fuzz targets found for project ""%s"".\n' % project_name)
- sys.exit(1)
+
+ # Exit with 0 not to mark code coverage job as failed in a case when project
+ # did not have any successful builds and there are no fuzz targets recorded.
+ exit(0)
 
 project_yaml = build_project.load_project_yaml(project_dir)
 dockerfile_path = os.path.join(project_dir, 'Dockerfile')
",137,11
"[infra] Fix check for qualified target name: include ""_"" (follow-up #1547)."," def get_build_steps(project_dir):
 download_corpus_args = []
 for binary_name in fuzz_targets[i : i+CORPUS_DOWNLOAD_BATCH_SIZE]:
 qualified_name = binary_name
- if not binary_name.startswith(project_name):
- qualified_name = '%s_%s' % (project_name, binary_name)
+ qualified_name_prefix = '%s_' % project_name
+ if not binary_name.startswith(qualified_name_prefix):
+ qualified_name = qualified_name_prefix + binary_name
 
 url = build_project.get_signed_url(
 CORPUS_BACKUP_URL.format(project_name, qualified_name), method='GET')
",138,11
[infra] Add missing targets_list_filename calculation in build_project.py (follow-up #1547).," def get_build_steps(project_dir):
 zip_file))
 srcmap_url = get_signed_url(UPLOAD_URL_FORMAT.format(bucket, name,
 stamped_srcmap_file))
+ targets_list_filename = get_targets_list_filename(sanitizer)
 targets_list_url = get_signed_url(
 get_targets_list_url(bucket, name, sanitizer))
 
 def get_logs_url(build_id):
 return URL_FORMAT.format(build_id)
 
 
+def get_targets_list_filename(sanitizer):
+ return TARGETS_LIST_BASENAME + '.' + sanitizer
+
+
 def get_targets_list_url(bucket, project, sanitizer):
- filename = TARGETS_LIST_BASENAME + '.' + sanitizer
+ filename = get_targets_list_filename(sanitizer)
 url = UPLOAD_URL_FORMAT.format(bucket, project, filename)
 return url
 
",287,27
"[infra] Skip coverage job for projects w/o fuzz targets (fix #1743, follow-up #1547). (#1744)

* [infra] Skip coverage job for projects w/o fuzz targets (fix #1743, follow-up #1547).

* Use build_id=0 and a more generic message."," def get_build_steps(project_dir):
 
 # Exit with 0 not to mark code coverage job as failed in a case when project
 # did not have any successful builds and there are no fuzz targets recorded.
+ # The script should print build_id, print '0' as a special value.
+ print '0'
 exit(0)
 
 project_yaml = build_project.load_project_yaml(project_dir)
",139,11
"[infra] Skip code coverage job for projects that are disabled (#1743, #1547). (#1745)

* [infra] Skip code coverage job for projects that are disabled.

* Remove unintentional change.

* Address review feedback."," def load_project_yaml(project_dir):
 project_yaml_path = os.path.join(project_dir, 'project.yaml')
 with open(project_yaml_path) as f:
 project_yaml = yaml.safe_load(f)
+ project_yaml.setdefault('disabled', False)
 project_yaml.setdefault('name', project_name)
 project_yaml.setdefault('image', 'gcr.io/oss-fuzz/' + project_name)
 project_yaml.setdefault('sanitizers', DEFAULT_SANITIZERS)
",288,27
"[infra] Use 'coverage' and 'fuzzing' tags to filter builds (follow-up #1547). (#1751)

* [infra] Use 'coverage' and 'fuzzing' tags to filter builds (follow-up #1547).

* Remove unintentional print call.

* Remove a variable that is not used anympre."," CORPUS_BACKUP_URL = ('/{0}-backup.clusterfuzz-external.appspot.com/corpus/'
 # Cloud Builder has a limit of 100 build steps and 100 arguments for each step.
 CORPUS_DOWNLOAD_BATCH_SIZE = 100
 
+COVERAGE_BUILD_TAG = 'coverage'
+
 # Needed for reading public target.list.* files.
 GCS_URL_BASENAME = 'https://storage.googleapis.com/'
 
 def main():
 
 project_dir = sys.argv[1].rstrip(os.path.sep)
 steps, image = get_build_steps(project_dir)
- build_project.run_build(steps, image)
+ build_project.run_build(steps, image, COVERAGE_BUILD_TAG)
 
 
 if __name__ == ""__main__"":
",144,13
"[infra] Support extra coverage args in project.yaml (fix #1726, follow-up #1547). (#1774)

* [infra] Support extra coverage args in project.yaml (fix #1726, follow-up #1547).

* Update the documentation page.

* Fix review comments by Jonathan."," def get_build_steps(project_dir):
 # Unpack the corpus and run coverage script.
 {
 'name': 'gcr.io/oss-fuzz-base/base-runner',
- 'env': env + ['HTTP_PORT=', 'COVERAGE_EXTRA_ARGS='],
+ 'env': env + [
+ 'HTTP_PORT=',
+ 'COVERAGE_EXTRA_ARGS=%s' % project_yaml['coverage_extra_args']
+ ],
 'args': [
 'bash',
 '-c',
",156,13
"[mupdf] Plug memory leaks in fuzzer itself. (oss-fuzz #5497) (#1778)

If mupdf throws an exception (extremely likely in when fuzzing),
none of the resources such as the rendered pixmap, document or
stream were reclaimed before exiting causing memory leaks. These
leaks were blamed on the software itself, when it actually was
the fuzzer implementation that leaked.

Fix this by always cleaning up all resources.","
 
 extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
 fz_context *ctx = fz_new_context(nullptr, nullptr, FZ_STORE_DEFAULT);
- fz_register_document_handlers(ctx);
 
- fz_stream *stream = fz_open_memory(ctx, data, size);
- fz_pixmap *pix = NULL;
+ fz_stream *stream = NULL;
 fz_document *doc = NULL;
+ fz_pixmap *pix = NULL;
+
+ fz_var(stream);
+ fz_var(doc);
+ fz_var(pix);
+
 fz_try(ctx) {
+ fz_register_document_handlers(ctx);
+ stream = fz_open_memory(ctx, data, size);
 doc = fz_open_document_with_stream(ctx, ""pdf"", stream);
 for (int i = 0; i < fz_count_pages(ctx, doc); i++) {
 pix = fz_new_pixmap_from_page_number(ctx, doc, i, fz_identity, fz_device_rgb(ctx), 0);
 fz_drop_pixmap(ctx, pix);
+ pix = NULL;
 }
 }
- fz_catch(ctx) {}
-
- if (doc) {
+ fz_always(ctx) {
+ fz_drop_pixmap(ctx, pix);
 fz_drop_document(ctx, doc);
+ fz_drop_stream(ctx, stream);
+ }
+ fz_catch(ctx) {
 }
- fz_drop_stream(ctx, stream);
+
 fz_drop_context(ctx);
 
 return 0;
",30,2
"[infra] Code Coverage latest report info to be picked up by CF (follow-up #1547). (#1781)

* [infra] Code Coverage latest report info to be picked up by CF (follow-up #1547).

* Remove unintentional change.

* Remove unnecessary empty lines."," def load_project_yaml(project_dir):
 return project_yaml
 
 
-def get_signed_url(path, method='PUT'):
+def get_signed_url(path, method='PUT', content_type=''):
 timestamp = int(time.time() + BUILD_TIMEOUT)
- blob = '{0}\n\n\n{1}\n{2}'.format(method, timestamp, path)
+ blob = '{0}\n\n{1}\n{2}\n{3}'.format(method, content_type, timestamp, path)
 
 creds = ServiceAccountCredentials.from_json_keyfile_name(
 os.environ['GOOGLE_APPLICATION_CREDENTIALS'])
",292,27
allow folded style for coverage_extra_args (#1786)," def get_build_steps(project_dir):
 'name': 'gcr.io/oss-fuzz-base/base-runner',
 'env': env + [
 'HTTP_PORT=',
- 'COVERAGE_EXTRA_ARGS=%s' % project_yaml['coverage_extra_args']
+ 'COVERAGE_EXTRA_ARGS=%s' % project_yaml['coverage_extra_args'].strip()
 ],
 'args': [
 'bash',
",195,13
"[infra] Do not fail coverage job if corpus download failed (#1798, follow-up #1547)."," def get_build_steps(project_dir):
 method='GET')
 
 corpus_archive_path = os.path.join('/corpus', binary_name + '.zip')
- download_corpus_args.append('%s %s' % (corpus_archive_path, url))
+ download_corpus_args.append('\'%s %s\'' % (corpus_archive_path, url))
 
 # Download corpus.
 build_steps.append(
 {
 'name': 'gcr.io/oss-fuzz-base/base-runner',
- 'entrypoint': 'download_corpus',
- 'args': download_corpus_args,
+ 'args': [
+ 'bash',
+ '-c',
+ 'download_corpus %s || true' % ' '.join(download_corpus_args),
+ ],
 'volumes': [{'name': 'corpus', 'path': '/corpus'}],
 }
 )
",201,13
[infra] Code Coverage: update download_corpus script and revert #1798.," def get_build_steps(project_dir):
 
 # Split fuzz targets into batches of CORPUS_DOWNLOAD_BATCH_SIZE.
 for i in xrange(0, len(fuzz_targets), CORPUS_DOWNLOAD_BATCH_SIZE):
- download_corpus_args = []
 for binary_name in fuzz_targets[i : i+CORPUS_DOWNLOAD_BATCH_SIZE]:
 qualified_name = binary_name
 qualified_name_prefix = '%s_' % project_name
 def get_build_steps(project_dir):
 method='GET')
 
 corpus_archive_path = os.path.join('/corpus', binary_name + '.zip')
- download_corpus_args.append('\'%s %s\'' % (corpus_archive_path, url))
+ download_corpus_args.append('%s %s' % (corpus_archive_path, url))
 
 # Download corpus.
 build_steps.append(
 {
 'name': 'gcr.io/oss-fuzz-base/base-runner',
- 'args': [
- 'bash',
- '-c',
- 'download_corpus %s || true' % ' '.join(download_corpus_args),
- ],
+ 'entrypoint': 'download_corpus',
+ 'args': download_corpus_args,
 'volumes': [{'name': 'corpus', 'path': '/corpus'}],
 }
 )
",197,13
[infra] Code Coverage: fix build_and_run_coverage.py.," def get_build_steps(project_dir):
 
 # Split fuzz targets into batches of CORPUS_DOWNLOAD_BATCH_SIZE.
 for i in xrange(0, len(fuzz_targets), CORPUS_DOWNLOAD_BATCH_SIZE):
+ download_corpus_args = []
 for binary_name in fuzz_targets[i : i+CORPUS_DOWNLOAD_BATCH_SIZE]:
 qualified_name = binary_name
 qualified_name_prefix = '%s_' % project_name
",198,13
av1_dec_fuzzer: rm unused variables (#1816),"
 #include ""aom_ports/mem_ops.h""
 #include ""common/ivfdec.h""
 
-static const char *const kIVFSignature = ""DKIF"";
-
 static void close_file(FILE *file) { fclose(file); }
 
 extern ""C"" void usage_exit(void) { exit(EXIT_FAILURE); }
 extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
 return 0;
 }
 
- int frame_in_cnt = 0;
- int frame_out_cnt = 0;
 uint8_t *buffer = nullptr;
 size_t buffer_size = 0;
 size_t frame_size = 0;
 extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
 nullptr)) {
 const aom_codec_err_t err =
 aom_codec_decode(&codec, buffer, frame_size, nullptr);
- ++frame_in_cnt;
+ static_cast<void>(err);
 aom_codec_iter_t iter = nullptr;
 aom_image_t *img = nullptr;
 while ((img = aom_codec_get_frame(&codec, &iter)) != nullptr) {
- ++frame_out_cnt;
 }
 }
 aom_codec_destroy(&codec);
",48,11
"av1_dec_fuzzer: set cfg.allow_lowbitdepth to CONFIG_LOWBITDEPTH (#1818)

If cfg.allow_lowbitdepth is 0, then seq_params->use_highbitdepth is
unconditionally set to 1 by the following code in av1_read_color_config():

seq_params->use_highbitdepth =
seq_params->bit_depth > AOM_BITS_8 || !allow_lowbitdepth;

aomdec.c sets cfg.allow_lowbitdepth to CONFIG_LOWBITDEPTH. (We usually
pass -DCONFIG_LOWBITDEPTH=1 to cmake.) Chromium defines
CONFIG_LOWBITDEPTH as 1 and sets cfg.allow_lowbitdepth to 1:
https://chromium-review.googlesource.com/c/chromium/src/+/1178938

Our fuzzing test binary should match the behavior of aomdec and Chromium.","
 #include <string.h>
 #include <memory>
 
+#include ""config/aom_config.h""
 #include ""aom/aom_decoder.h""
 #include ""aom/aomdx.h""
 #include ""aom_ports/mem_ops.h""
 extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
 #else
 #error define one of DECODE_MODE or DECODE_MODE_threaded
 #endif
- aom_codec_dec_cfg_t cfg = {threads, 0, 0};
+ aom_codec_dec_cfg_t cfg = {threads, 0, 0, CONFIG_LOWBITDEPTH};
 if (aom_codec_dec_init(&codec, decoder->codec_interface(), &cfg, 0)) {
 return 0;
 }
",49,11
"webp_enc_dec: Fix timeout by skipping crusher (#1831)

* webp_enc_dec: Fix timeout by skipping crasher

The target fuzz_webp_enc_dec with msan crashes (timeout)
on a 128*128px image encoding with max compression (crusher).
Reduce crusher encoding to 16*16px and below.
Bug report 10423"," extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t* const data, size_t size) {
 
 // Skip the cruncher except on small images, it's likely to timeout.
 if (config.lossless && config.quality == 100. && config.method == 6 &&
- pic.width * pic.height >= 16384) {
+ pic.width * pic.height >= 16 * 16) {
 config.lossless = 0;
 }
 
",200,40
"[infra] Remove sancov and rename ""profile"" to ""coverage"". (#1839)

* [infra] Remove sancov and rename ""profile"" to ""coverage"".

* Bring coverage flags back.

* Update projects files that rely on SANITIZER=""profile""."," import urlparse
 
 import build_project
 
-SANITIZER = 'profile'
+SANITIZER = 'coverage'
 CONFIGURATION = ['FUZZING_ENGINE=libfuzzer', 'SANITIZER=%s' % SANITIZER]
 PLATFORM = 'linux'
 
",198,13
"[libwebp] webp_enc_dec: Limit alpha_quality to 99 when method is 6 (#1860)

webp_enc_dec: Limit alpha_quality to 99 when method is 6

The target fuzz_webp_enc_dec with asan crashes (timeout)
during encoding with heavy alpha compression.
Clamp alpha compression parameters for images bigger than 16*16.
Bug report 10838"," extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t* const data, size_t size) {
 config.quality = 99.0f;
 }
 }
+ if (config.alpha_quality == 100 && config.method == 6) {
+ config.alpha_quality = 99;
+ }
 }
 
 // Encode.
",211,44
[infra] Add srcmap step to code coverage job (follow-up #1547). (#1868)," def get_build_steps(project_dir):
 ],
 'dir': 'oss-fuzz/projects/' + name,
 },
+ {
+ 'name':
+ image,
+ 'args': [
+ 'bash', '-c',
+ 'srcmap > /workspace/srcmap.json && cat /workspace/srcmap.json'
+ ],
+ 'env': ['OSSFUZZ_REVISION=$REVISION_ID'],
+ },
 ]
 
 env = CONFIGURATION[:]
 def get_build_steps(project_dir):
 }
 )
 
+ # Upload srcmap.
+ srcmap_upload_url = UPLOAD_URL_FORMAT.format(
+ project=project_name, type='srcmap', date=report_date)
+ srcmap_upload_url = srcmap_upload_url.rstrip('/') + '.json'
+ build_steps.append(
+ {
+ 'name': 'gcr.io/cloud-builders/gsutil',
+ 'args': [
+ 'cp',
+ '/workspace/srcmap.json',
+ srcmap_upload_url,
+ ],
+ }
+ )
+
 # Update the latest report information file for ClusterFuzz.
 latest_report_info_url = build_project.get_signed_url(
 LATEST_REPORT_INFO_URL.format(project=project_name),
",220,13
"bzip2: Bug fixes (#1894)

* bzip2: Bug fixes; added citations

* bzip2: Bump bzip2 version to 1.0.6

* bzip2: Variable blockSize100k, workFactor, and small

* bzip2: Remove hardcoded buffer sizes; fix nZ (compressor) to point to real buffer size

* bzip: Remove ubsan from project.yaml beacuse of start-up crash google/oss-fuzz#1887"," extern int BZ2_bzBuffToBuffDecompress(char* dest,
 int
 LLVMFuzzerTestOneInput(const uint8_t *data, size_t size)
 {
- int r;
+ int r, small;
 unsigned int nZ, nOut;
 
+ // See: https://github.com/google/bzip2-rpc/blob/master/unzcrash.c#L39
 nOut = size*2;
 char *outbuf = malloc(nOut);
- r = BZ2_bzBuffToBuffDecompress(outbuf, &nOut, (char *)data, size, 0, 0);
+ small = size % 2;
+ r = BZ2_bzBuffToBuffDecompress(outbuf, &nOut, (char *)data, size,
+ small, /*verbosity=*/0);
 
 if (r != BZ_OK) {
 #ifdef __DEBUG__
 fprintf(stdout, ""Decompression error: %d\n"", r);
 #endif
- free(outbuf);
- return 0;
 }
-
- assert(nOut == size);
- assert(memcmp(data, outbuf, size) == 0);
 free(outbuf);
 return 0;
 }
\ No newline at end of file
",27,3
"[infra]: place the findings of fuzzers run with `helper.py run_fuzzer` in $OUT (#1922)

When `libFuzzer` is used as a fuzzing engine it conveniently puts
everything it finds into its working directory, which happens to
be $OUT. When any other engine is used, the output is sent to /tmp,
which disappears as soon as the container stops. That makes it
unnecessarily hard to extract reproducers found by afl for further analysis
without joining the mount namespace of a running container and
almost impossible with `honggfuzz`, that exits immediately after a crash."," def main():
 run_fuzzer_parser = subparsers.add_parser(
 'run_fuzzer', help='Run a fuzzer.')
 _add_engine_args(run_fuzzer_parser)
+ _add_sanitizer_args(run_fuzzer_parser)
 _add_environment_args(run_fuzzer_parser)
 run_fuzzer_parser.add_argument('project_name', help='name of the project')
 run_fuzzer_parser.add_argument('fuzzer_name', help='name of the fuzzer')
 def run_fuzzer(args):
 if not _check_fuzzer_exists(args.project_name, args.fuzzer_name):
 return 1
 
- env = ['FUZZING_ENGINE=' + args.engine]
+ env = [
+ 'FUZZING_ENGINE=' + args.engine,
+ 'SANITIZER=' + args.sanitizer,
+ 'RUN_FUZZER_MODE=interactive',
+ ]
+
 if args.e:
 env += args.e
 
",589,117
"Add support for tags field in project.yaml (#1974) (#1980)

* Add support for tags field in project.yaml (#1974)

Also add ""sundew"" label to libxml2_xml_reader_for_file_fuzzer.

These add additional labels in filed bugs.","
+#!/usr/bin/python3
+
+import os
+import json
+import sys
+
+def main():
+ if len(sys.argv) != 3:
+ print('Usage: write_labels.py labels_json out_dir', file=sys.stderr)
+ sys.exit(1)
+
+ labels_by_target = json.loads(sys.argv[1])
+ out = sys.argv[2]
+
+ for target_name, labels in labels_by_target.items():
+ with open(os.path.join(out, target_name + '.labels'), 'w') as f:
+ f.write('\n'.join(labels))
+
+
+if __name__ == '__main__':
+ main()
",14,3
Integrate opencv and add two fuzz targets. (#2034),"
+#include <opencv2/opencv.hpp>
+#include <opencv2/imgcodecs/legacy/constants_c.h>
+
+extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
+ std::vector<uint8_t> image_data = {data, data + size};
+ // TODO: Try other image types than CV_8UC1.
+ cv::Mat data_matrix =
+ cv::Mat(1, image_data.size(), CV_8UC1, image_data.data());
+ try {
+ cv::Mat decoded_matrix = cv::imdecode(data_matrix, CV_LOAD_IMAGE_UNCHANGED);
+ } catch (cv::Exception e) {
+ // Do nothing.
+ }
+ return 0;
+}
+
",12,2
Integrate libsass and add a fuzz target. (#2039),"
+#include ""sass.h""
+
+extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
+ char* sass_data = (char*) malloc(sizeof(char) * size + 1);
+ if (sass_data == NULL) return 0;
+
+ memcpy(sass_data, data, size);
+ sass_data[size] = '\0';
+
+ struct Sass_Data_Context* ctx = sass_make_data_context(sass_data);
+ if (ctx == NULL) {
+ free(sass_data);
+ return 0;
+ }
+
+ struct Sass_Options* options = sass_make_options();
+ if (options == NULL) {
+ sass_delete_data_context(ctx);
+ return 0;
+ }
+
+ sass_option_set_output_style(options, SASS_STYLE_NESTED);
+ sass_option_set_precision(options, 5);
+
+ sass_data_context_set_options(ctx, options);
+ sass_compile_data_context(ctx);
+
+ sass_delete_data_context(ctx);
+ sass_delete_options(options);
+
+ return 0;
+}
",24,4
"libpng-proto: don't use vector, use a plain array instead","
 #include <string>
 #include <sstream>
 #include <fstream>
-#include <vector>
 #include <zlib.h> // for crc32
 
 #include ""libprotobuf-mutator/src/libfuzzer/libfuzzer_macro.h""
 std::string ProtoToPng(const PngProto &png_proto) {
 auto &other_chunk = chunk.other_chunk();
 char type[5] = {0};
 if (other_chunk.has_known_type()) {
- static const std::vector<const char *> known_chunks = {
+ static const char * known_chunks[] = {
 ""bKGD"", ""cHRM"", ""dSIG"", ""eXIf"", ""gAMA"", ""hIST"", ""iCCP"",
 ""iTXt"", ""pHYs"", ""sBIT"", ""sPLT"", ""sRGB"", ""sTER"", ""tEXt"",
 ""tIME"", ""tRNS"", ""zTXt"", ""sCAL"", ""pCAL"", ""oFFs"",
 };
- size_t chunk_idx = other_chunk.known_type() % known_chunks.size();
+ size_t known_chunks_size =
+ sizeof(known_chunks) / sizeof(known_chunks[0]);
+ size_t chunk_idx = other_chunk.known_type() % known_chunks_size;
 memcpy(type, known_chunks[chunk_idx], 4);
 } else if (other_chunk.has_unknown_type()) {
 uint32_t unknown_type_int = other_chunk.unknown_type();
",78,12
[qpdf] Initial integration for qpdf. (#2050),"
+#include ""qpdf/qpdf-c.h""
+
+#include <cstddef>
+#include <cstdint>
+#include <cstdlib>
+#include <string>
+#include <vector>
+
+extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
+ _qpdf_data* qpdf = qpdf_init();
+ const char* buffer = reinterpret_cast<const char*>(data);
+ qpdf_read_memory(qpdf, /*description=*/"""", buffer, size, /*password=*/"""");
+ qpdf_cleanup(&qpdf);
+ return 0;
+}
",13,1
"Add libldac for LDAC codec (#2051)

* Add libldac for LDAC codec

* Fix primary email casing","
+// Copyright 2019 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include <stdint.h>
+#include <stddef.h>
+#include ""ldacBT.h""
+
+#define TESTFUNC_TYPE extern ""C"" int
+
+TESTFUNC_TYPE
+LLVMFuzzerTestOneInput(const uint8_t *buf, size_t size)
+{
+ if (size == 0) {
+ return 0;
+ }
+ HANDLE_LDAC_BT hLdacBt;
+ int pcm_used, stream_sz, frame_num;
+ unsigned char p_stream[1024];
+
+ hLdacBt = ldacBT_get_handle();
+
+ ldacBT_init_handle_encode(
+ hLdacBt,
+ 679,
+ LDACBT_EQMID_SQ,
+ LDACBT_CHANNEL_MODE_DUAL_CHANNEL,
+ LDACBT_SMPL_FMT_S16,
+ 48000);
+
+ ldacBT_encode(
+ hLdacBt,
+ (void *)(&buf + 44),
+ &pcm_used,
+ p_stream,
+ &stream_sz,
+ &frame_num);
+
+ ldacBT_get_sampling_freq(hLdacBt);
+ ldacBT_get_bitrate(hLdacBt);
+ ldacBT_get_version();
+
+ ldacBT_close_handle(hLdacBt);
+ ldacBT_free_handle(hLdacBt);
+
+ return 0;
+}
",34,2
"[qpdf] Limiting the number of bytes the read_memory_fuzzer handles. (#2056)

* [qpdf] Limiting the number of bytes the read_memory_fuzzer handles.

* Raising the limit to 64 KiB.","
 #include ""qpdf/qpdf-c.h""
 
+#include <algorithm>
 #include <cstddef>
 #include <cstdint>
 #include <cstdlib>
-#include <string>
-#include <vector>
 
 extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
+ constexpr size_t kMaxSize = 64 * 1024; // 64 KiB
+ size = std::min(size, kMaxSize);
 _qpdf_data* qpdf = qpdf_init();
 const char* buffer = reinterpret_cast<const char*>(data);
 qpdf_read_memory(qpdf, /*description=*/"""", buffer, size, /*password=*/"""");
",14,1
[libxml2] Fix std::string use in the fuzz targets: avoid it when possible.," class ByteStream {
 ByteStream(const ByteStream&) = delete;
 ByteStream& operator=(const ByteStream&) = delete;
 
+ // Returns a pointer to the chunk of data of |size| bytes, where |size| is
+ // either a requested value or all the bytes that are available. If the
+ // requested |size| is 0, return all the bytes that are available.
+ const uint8_t* GetNextChunk(size_t* size);
+
 // Returns a string. Strings are obtained from the byte stream by reading a
 // size_t N followed by N char elements. If there are fewer than N bytes left
 // in the stream, this returns as many bytes as are available.
 class ByteStream {
 size_t position_;
 };
 
+inline const uint8_t* ByteStream::GetNextChunk(size_t* size) {
+ if (*size)
+ *size = std::min(*size, capacity());
+ else
+ *size = capacity();
+
+ return UncheckedConsume(*size);
+}
+
 inline std::string ByteStream::GetNextString() {
 const size_t requested_size = GetNextSizeT();
 const size_t consumed_size = std::min(requested_size, capacity());
",76,19
oss-fuzz/12299: fix build error due to change in interface for fast crc32 (#2082)," int LLVMFuzzerTestOneInput(const uint8_t *data, size_t dataLen) {
 /* Checksum with a buffer of size equal to the first byte in the input. */
 uint32_t buffSize = data[0];
 uint32_t offset = 0;
- z_crc_t op[32];
+ uint32_t op;
 
 /* Discard inputs larger than 1Mb. */
 static size_t kMaxSize = 1024 * 1024;
 int LLVMFuzzerTestOneInput(const uint8_t *data, size_t dataLen) {
 ++buffSize;
 
 /* CRC32 */
- crc32_combine_gen(op, buffSize);
+ op = crc32_combine_gen(buffSize);
 for (offset = 0; offset + buffSize <= dataLen; offset += buffSize) {
 uint32_t crc3 = crc32_z(crc0, data + offset, buffSize);
 uint32_t crc4 = crc32_combine_op(crc1, crc3, op);
 int LLVMFuzzerTestOneInput(const uint8_t *data, size_t dataLen) {
 crc32_combine(crc1, crc1, dataLen));
 
 /* Fast CRC32 combine. */
- crc32_combine_gen(op, dataLen);
+ op = crc32_combine_gen(dataLen);
 assert(crc32_combine_op(crc1, crc2, op) ==
 crc32_combine_op(crc2, crc1, op));
 assert(crc32_combine(crc1, crc2, dataLen) ==
",49,6
[libpng-proto] extend the example proto fuzz target with explicit support for iCCP PNG chunk," std::string ProtoToPng(const PngProto &png_proto) {
 WriteChunk(all, ""PLTE"", chunk.plte().data());
 } else if (chunk.has_idat()) {
 WriteChunk(all, ""IDAT"", chunk.idat().data(), true);
+ } else if (chunk.has_iccp()) {
+ std::stringstream iccp_str;
+ iccp_str << chunk.iccp().name();
+ WriteByte(iccp_str, 0);
+ WriteByte(iccp_str, 0);
+ auto compressed_data = Compress(chunk.iccp().data());
+ iccp_str.write(compressed_data.data(), compressed_data.size());
+ WriteChunk(all, ""iCCP"", iccp_str.str());
 } else if (chunk.has_other_chunk()) {
 auto &other_chunk = chunk.other_chunk();
 char type[5] = {0};
",99,15
[libpng-proto] simplify the target a bit further: remove a field that don't really need to be mutaed," std::string ProtoToPng(const PngProto &png_proto) {
 WriteChunk(all, ""IDAT"", chunk.idat().data(), true);
 } else if (chunk.has_iccp()) {
 std::stringstream iccp_str;
- iccp_str << chunk.iccp().name();
+ iccp_str << ""xyz""; // don't fuzz iCCP name field.
 WriteByte(iccp_str, 0);
 WriteByte(iccp_str, 0);
 auto compressed_data = Compress(chunk.iccp().data());
",99,15
[openh264] Add to corpus and enable ASM for non-MSAN (#2113)," extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size)
 int32_t i;
 int32_t iBufPos = 0;
 int32_t iEndOfStreamFlag;
+ int iLevelSetting = (int) WELS_LOG_QUIET; // disable logging while fuzzing
 int32_t iSliceSize;
 ISVCDecoder *pDecoder;
 SDecodingParam sDecParam = {0};
 extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size)
 
 // TODO: is this the best/fastest ERROR_CON to use?
 sDecParam.eEcActiveIdc = ERROR_CON_SLICE_COPY;
- // TODO: should we also fuzz VIDEO_BITSTREAM_SVC
+ // TODO: should we also fuzz VIDEO_BITSTREAM_SVC?
 sDecParam.sVideoProperty.eVideoBsType = VIDEO_BITSTREAM_AVC;
 
 WelsCreateDecoder (&pDecoder);
 pDecoder->Initialize (&sDecParam);
+ pDecoder->SetOption (DECODER_OPTION_TRACE_LEVEL, &iLevelSetting);
 
 while (1) {
 if (iBufPos >= size) {
",62,16
poppler: exercise the text extraction code (#2121)," extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
 continue;
 }
 r.render_page(p);
+ p->text_list();
 delete p;
 }
 
",26,6
[libpng-proto] suppress leak reports until https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=12716 is fixed," extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
 png_image_free(&image);
 return 0;
 }
+
+extern ""C"" const char *__asan_default_options() {
+ // TODO: remove this once
+ // https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=12716
+ // is fixed.
+ return ""detect_leaks=0"";
+}
",108,19
kimageformats: Also exercise the canRead() codepath (#2128)," extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size)
 b.setData((const char *)data, size);
 b.open(QIODevice::ReadOnly);
 h->setDevice(&b);
+ h->canRead();
 h->read(&i);
 }
 qDeleteAll(handlers);
",35,2
"Add fuzzer for Unbound's parse_packet. (#2149)

* Add fuzzer for Unbound's parse_packet.","
+#include ""config.h""
+#include ""util/regional.h""
+#include ""util/fptr_wlist.h""
+#include ""sldns/sbuffer.h""
+
+struct regional * region = NULL;
+
+int LLVMFuzzerTestOneInput(const uint8_t *buf, size_t len)
+{
+if (!region) {
+region = regional_create();
+if (!region) {
+abort();
+}
+}
+sldns_buffer pktbuf;
+sldns_buffer_init_frm_data(&pktbuf, (void*)buf, len);
+
+struct msg_parse prs;
+memset(&prs, 0, sizeof(prs));
+parse_packet(&pktbuf, &prs, region);
+return 0;
+}
",20,3
"reenable leak detection now that the leak is fixed

report: https://github.com/glennrp/libpng/issues/274#issuecomment-458021367
fix: https://github.com/sboukortt/libpng/commit/3c0b79b4d80b33022aeff27309a4e5ecf08abaea"," extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
 png_image_free(&image);
 return 0;
 }
-
-extern ""C"" const char *__asan_default_options() {
- // TODO: remove this once
- // https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=12716
- // is fixed.
- return ""detect_leaks=0"";
-}
",105,18
"revert the previous change: the leak is actually not fixed yet

https://github.com/glennrp/libpng/pull/279
https://github.com/glennrp/libpng/issues/274"," extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
 png_image_free(&image);
 return 0;
 }
+
+extern ""C"" const char *__asan_default_options() {
+ // TODO: remove this once
+ // https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=12716
+ // is fixed.
+ return ""detect_leaks=0"";
+}
",108,19
[infra] Bump build timeout from 10h to 12h. (#2227)," from oauth2client.client import GoogleCredentials
 from oauth2client.service_account import ServiceAccountCredentials
 from googleapiclient.discovery import build
 
-BUILD_TIMEOUT = 10 * 60 * 60
+BUILD_TIMEOUT = 12 * 60 * 60
 
 FUZZING_BUILD_TAG = 'fuzzing'
 
",300,27
[infra] Disable honggfuzz builds by default (follow up for #2227).," ENGINE_INFO = {
 supported_sanitizers=['address']),
 }
 
-DEFAULT_ENGINES = ['libfuzzer', 'afl', 'honggfuzz']
+DEFAULT_ENGINES = ['libfuzzer', 'afl']
 DEFAULT_SANITIZERS = ['address', 'undefined']
 
 TARGETS_LIST_BASENAME = 'targets.list'
",300,27
"Remove image pushing step from build (#2232)

They aren't used and pushing them appears to be flaky."," def get_build_steps(project_dir):
 ],
 }
 )
- return build_steps, image
+ return build_steps
 
 
 def get_targets_list(project_name):
 def main():
 usage()
 
 project_dir = sys.argv[1].rstrip(os.path.sep)
- steps, image = get_build_steps(project_dir)
- build_project.run_build(steps, image, COVERAGE_BUILD_TAG)
+ steps = get_build_steps(project_dir)
+ build_project.run_build(steps, COVERAGE_BUILD_TAG)
 
 
 if __name__ == ""__main__"":
",220,13
Add a project tag to builds for filtering (#2263). (#2264)," def get_targets_list_url(bucket, project, sanitizer):
 return url
 
 
-def run_build(build_steps, tag):
+def run_build(build_steps, project_name, tag):
 options = {}
 if 'GCB_OPTIONS' in os.environ:
 options = yaml.safe_load(os.environ['GCB_OPTIONS'])
 def run_build(build_steps, tag):
 'timeout': str(BUILD_TIMEOUT) + 's',
 'options': options,
 'logsBucket': GCB_LOGS_BUCKET,
- 'tags': [ tag ],
+ 'tags': [
+ project_name,
+ tag,
+ ],
 }
 
 credentials = GoogleCredentials.get_application_default()
 def main():
 
 project_dir = sys.argv[1].rstrip(os.path.sep)
 steps = get_build_steps(project_dir)
- run_build(steps, FUZZING_BUILD_TAG)
+
+ project_name = os.path.basename(project_dir)
+ run_build(steps, project_name, FUZZING_BUILD_TAG)
 
 
 if __name__ == '__main__':
",303,27
"[kimageformats] Include ora and kra handlers (#2277)

This pulls karchive that pulls, ecm and libzip and libzip pulls zlib","
 #include <QCoreApplication>
 #include <QImage>
 
+#include ""kra.h""
+#include ""ora.h""
 #include ""pcx_p.h""
 #include ""pic_p.h""
 #include ""psd_p.h""
 extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size)
 QCoreApplication a(argc, nullptr);
 
 const QVector<QImageIOHandler*> handlers = {
+ new KraHandler(),
+ new OraHandler(),
 new PCXHandler(),
 new SoftimagePICHandler(),
 new PSDHandler(),
",39,2
[infra] Fix code coverage builder script (regressed after #2264).," def main():
 usage()
 
 project_dir = sys.argv[1].rstrip(os.path.sep)
+ project_name = os.path.basename(project_dir)
 steps = get_build_steps(project_dir)
- build_project.run_build(steps, COVERAGE_BUILD_TAG)
+ build_project.run_build(steps, project_name, COVERAGE_BUILD_TAG)
 
 
 if __name__ == ""__main__"":
",221,13
"Use a single tag for builds. (#2284)

Filtering on multiple tags doesn't seem to work."," def run_build(build_steps, project_name, tag):
 'options': options,
 'logsBucket': GCB_LOGS_BUCKET,
 'tags': [
- project_name,
- tag,
+ project_name + '-' + tag,
 ],
 }
 
",302,27
Address comments from https://github.com/google/oss-fuzz/pull/2285. (#2287)," def find_last_build(builds, project, build_tag_suffix):
 
 builds = builds.get(tag)
 if not builds:
+ print >>sys.stderr, 'Failed to find builds with tag', tag
 return None
 
 for build in builds:
 def get_builds(cloudbuild):
 projectId='oss-fuzz', pageSize=page_size, pageToken=next_page_token))
 
 if not 'builds' in response:
- print >> sys.stderr, 'Invalid response', response
+ print >> sys.stderr, 'Invalid response from builds list:', response
 return None
 
 ungrouped_builds.extend(response['builds'])
",143,27
[mupdf] Update to latest version of API provided by MuPDF. (#2294)," extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
 doc = fz_open_document_with_stream(ctx, ""pdf"", stream);
 
 for (int i = 0; i < fz_count_pages(ctx, doc); i++) {
- pix = fz_new_pixmap_from_page_number(ctx, doc, i, fz_identity, fz_device_rgb(ctx), 0);
+ pix = fz_new_pixmap_from_page_number(ctx, doc, i, fz_identity, fz_device_rgb(ctx), NULL, 0);
 fz_drop_pixmap(ctx, pix);
 pix = NULL;
 }
",95,15
"[infra] Enabling DataFlow build configuration (#1632). (#2292)

* [infra] Enabling DataFlow build configuration (#1632).

* Copy all data flow scripts from the libFuzzer repo."," GCB_LOGS_BUCKET = 'oss-fuzz-gcb-logs'
 
 CONFIGURATIONS = {
 'sanitizer-address': ['SANITIZER=address'],
+ 'sanitizer-dataflow': ['SANITIZER=dataflow'],
 'sanitizer-memory': ['SANITIZER=memory'],
 'sanitizer-undefined': ['SANITIZER=undefined'],
 'engine-libfuzzer': ['FUZZING_ENGINE=libfuzzer'],
 'engine-afl': ['FUZZING_ENGINE=afl'],
 'engine-honggfuzz': ['FUZZING_ENGINE=honggfuzz'],
+ 'engine-dataflow': ['FUZZING_ENGINE=dataflow'],
 'engine-none': ['FUZZING_ENGINE=none'],
 }
 
 ENGINE_INFO = {
 EngineInfo(
 upload_bucket='clusterfuzz-builds-honggfuzz',
 supported_sanitizers=['address', 'memory', 'undefined']),
+ 'dataflow':
+ EngineInfo(
+ upload_bucket='clusterfuzz-builds-dataflow',
+ supported_sanitizers=['dataflow']),
 'none':
 EngineInfo(
 upload_bucket='clusterfuzz-builds-no-engine',
",308,27
"[mupdf] Update to latest version of API provided by MuPDF. (#2362)

This reverts commit 7fa021dfbecf30aa04613d8497954f6a482dbb09
because the corresponding API was reverted in the upstream project."," extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
 doc = fz_open_document_with_stream(ctx, ""pdf"", stream);
 
 for (int i = 0; i < fz_count_pages(ctx, doc); i++) {
- pix = fz_new_pixmap_from_page_number(ctx, doc, i, fz_identity, fz_device_rgb(ctx), NULL, 0);
+ pix = fz_new_pixmap_from_page_number(ctx, doc, i, fz_identity, fz_device_rgb(ctx), 0);
 fz_drop_pixmap(ctx, pix);
 pix = NULL;
 }
",95,15
"[unrar] Use std::error_code in calls to fs::current_path and fs::remove_all (#2394)

* Use std::error_code in calls to fs::current_path and fs::remove_all

* Fuzzers must always return 0"," extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
 // in the current working directory.
 std::error_code code, ok;
 fs::path original_path = fs::current_path(code);
- if (code != ok) return code.value();
+ if (code != ok) return 0;
 
 fs::path out_path = original_path / ""o"";
 bool created = fs::create_directory(out_path, code);
- if (code != ok) return code.value();
+ if (code != ok) return 0;
 
 fs::current_path(out_path, code);
- if (code != ok) return code.value();
+ if (code != ok) return 0;
 
 static const std::string filename = ""temp.rar"";
 std::ofstream file(filename,
 extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
 
 // 'cd' back to the original directory and delete 'o' along with
 // all its contents.
- fs::current_path(original_path);
- fs::remove_all(out_path);
+ fs::current_path(original_path, code);
+ if (code != ok) return 0;
+ fs::remove_all(out_path, code);
+ if (code != ok) return 0;
 return 0;
 }
",45,8
[travis] Dont build the same project multiple times (#2399)," def get_modified_projects():
 output = subprocess.check_output(['git', 'diff', 'origin/master',
 '--name-status'])
 projects_regex = '.*projects/(?P<name>.*)/.*\n'
- return re.findall(projects_regex, output)
+ return set(re.findall(projects_regex, output))
 
 
 def get_oss_fuzz_root():
",60,15
[travis] Add requirements file for travis and fix diff command (#2406)," DEFAULT_SANITIZERS = ['address', 'undefined']
 
 def get_modified_projects():
 """"""Get a list of all the projects modified in this commit.""""""
- output = subprocess.check_output(['git', 'diff', 'origin/master',
- '--name-status'])
+ master_head_sha = subprocess.check_output(
+ ['git', 'merge-base', 'HEAD', 'FETCH_HEAD']).decode().strip()
+ output = subprocess.check_output(
+ ['git', 'diff', '--name-only', 'HEAD', master_head_sha]).decode()
 projects_regex = '.*projects/(?P<name>.*)/.*\n'
 return set(re.findall(projects_regex, output))
 
",64,15
"[i386] Improve linking and bad build check (#2410)

Improve linking by copying i386 libs instead of adding `-L` to `CXXFLAGS`
Get bad_build_check working for i386 binaries and add architecture check."," def build_fuzzers(args):
 env = [
 'FUZZING_ENGINE=' + args.engine,
 'SANITIZER=' + args.sanitizer,
- 'ARCHITECTURE=' + args.architecture
+ 'ARCHITECTURE=' + args.architecture,
 ]
 if args.e:
 env += args.e
 def check_build(args):
 
 env = [
 'FUZZING_ENGINE=' + args.engine,
- 'SANITIZER=' + args.sanitizer
+ 'SANITIZER=' + args.sanitizer,
+ 'ARCHITECTURE=' + args.architecture,
 ]
 if args.e:
 env += args.e
 def shell(args):
 
 env = [
 'FUZZING_ENGINE=' + args.engine,
- 'SANITIZER=' + args.sanitizer
+ 'SANITIZER=' + args.sanitizer,
+ 'ARCHITECTURE=' + args.architecture,
 ]
 
 if args.e:
",605,119
"[libarchive] process archive_read_next_header() return codes like bsdtar (#2427)

ARCHIVE_EOF and ARCHIVE_FATAL are the only valid exit codes
ARCHIVE_RETRY should read to re-entering the loop
All other codes (ARCHIVE_OK, ARCHIVE_WARN, ARCHIVE_FAILED) do not prohibit
the caller from reading data and next headers.

This behavior is identical with bsdtar (tar/read.c) and enables better
discovery of possible bugs by fuzzing."," ssize_t reader_callback(struct archive *a, void *client_data,
 }
 
 extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t *buf, size_t len) {
+ int ret;
 ssize_t r;
 struct archive *a = archive_read_new();
 
 extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t *buf, size_t len) {
 
 std::vector<uint8_t> data_buffer(getpagesize(), 0);
 struct archive_entry *entry;
- while (archive_read_next_header(a, &entry) == ARCHIVE_OK) {
+ while(1) {
+ ret = archive_read_next_header(a, &entry);
+ if (ret == ARCHIVE_EOF || ret == ARCHIVE_FATAL)
+ break;
+ if (ret == ARCHIVE_RETRY)
+ continue;
 while ((r = archive_read_data(a, data_buffer.data(),
 data_buffer.size())) > 0)
 ;
",41,8
karchive: Also exercise the compressed tar codepaths (#2439),"
 #include <KF5/KArchive/ktar.h>
 #include <KF5/KArchive/kzip.h>
 #include <KF5/KArchive/kar.h>
+#include <KF5/KArchive/kcompressiondevice.h>
 
 extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size)
 {
 extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size)
 QBuffer b;
 b.setData((const char *)data, size);
 
+ std::unique_ptr<KCompressionDevice> gzipKD(new KCompressionDevice(&b, false, KCompressionDevice::GZip));
+ std::unique_ptr<KCompressionDevice> bzipKD(new KCompressionDevice(&b, false, KCompressionDevice::BZip2));
+ std::unique_ptr<KCompressionDevice> xzKD(new KCompressionDevice(&b, false, KCompressionDevice::Xz));
+
 const QVector<KArchive*> handlers = {
 new K7Zip(&b),
 new KTar(&b),
+ new KTar(gzipKD.get()),
+ new KTar(bzipKD.get()),
+ new KTar(xzKD.get()),
 new KZip(&b),
 new KAr(&b)
 };
 
 for (KArchive *h : handlers) {
+ b.reset();
 h->open(QIODevice::ReadOnly);
 h->close();
 }
",34,2
Gnupg: avoids filling disk with logs (#2453)," int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) {
 public_key_list (ctrlGlobal, sl, 0);
 free_strlist(sl);
 //no output for stderr
- log_set_file(""/tmp/fuzzdecrypt.log"");
+ log_set_file(""/dev/null"");
 gcry_set_log_handler (my_gcry_logger, NULL);
 gnupg_initialize_compliance (GNUPG_MODULE_NAME_GPG);
 //overwrite output file
",121,18
"infra: skip files whose names start with afl while looking for fuzz targets (#2445)

This should help to get rid of the ""WARNING: corpus for systemd_afl-showmap not found:""
messages (that are harmless but confusing a bit). In general _get_fuzz_targets
should probably be in sync with ./infra/base-images/base-runner/test_all (where a file
is considered a fuzz target if grep can find ""ELF"" in it and so on)."," def _get_fuzz_targets(project_name):
 """"""Return names of fuzz targest build in the project's /out directory.""""""
 fuzz_targets = []
 for name in os.listdir(_get_output_dir(project_name)):
+ if name.startswith('afl-'):
+ continue
+
 path = os.path.join(_get_output_dir(project_name), name)
 if os.path.isfile(path) and os.access(path, os.X_OK):
 fuzz_targets.append(name)
",607,120
[njs] Null terminate the script string.," lvlhsh_pool_free(void *pool, void *p, size_t size)
 int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
 if (size == 0) return 0;
 
- char* input = malloc(size);
+ char* input = malloc(size + 1);
 memcpy(input, data, size);
+ input[size] = 0;
 nxt_str_t line = {size, input};
 
 njs_vm_t *vm;
",520,65
"[njs] Revert ""Null terminate the script string."", as the API accepts size value."," lvlhsh_pool_free(void *pool, void *p, size_t size)
 int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
 if (size == 0) return 0;
 
- char* input = malloc(size + 1);
+ char* input = malloc(size);
 memcpy(input, data, size);
- input[size] = 0;
 nxt_str_t line = {size, input};
 
 njs_vm_t *vm;
",519,65
"Qpdf ownership (#2496)

* example project: fix minor problems with standalone fuzzer

* typo: ""successfull"" -> ""successful""
* main should explicitly return 0 on success

* example project: fix minor problems with Makefile

* make ""all"" the first target
* use LIB_FUZZING_ENGINE to reference fuzzer in all places

* example project: fix typos in README

* Add upstream qpdf maintainer as auto_cc for qpdf

I am adding myself (using my Google account) as an auto_cc in
preparation for taking over ownership of the qpdf project and doing a
full integration with oss-fuzz."," int main(int argc, char **argv) {
 assert(in);
 LLVMFuzzerTestOneInput(reinterpret_cast<const uint8_t *>(bytes.data()),
 bytes.size());
- std::cout << ""Execution successfull"" << std::endl;
+ std::cout << ""Execution successful"" << std::endl;
 }
+ return 0;
 }
",21,2
"[infra] Run tests on the builder after patching MSan libraries. (#2497)

* [WORK IN PROGRESS] Debug Travis failure when doing build check for MSan build.

* Change order of ""MSan patch libraries"" and ""build check"" steps."," def get_build_steps(project_dir):
 ],
 })
 
- if run_tests:
- build_steps.append(
- # test binaries
- {
- 'name': 'gcr.io/oss-fuzz-base/base-runner',
- 'env': env,
- 'args': ['bash', '-c', 'test_all'],
- })
-
 if sanitizer == 'memory':
 # Patch dynamic libraries to use instrumented ones.
 build_steps.append({
 def get_build_steps(project_dir):
 ],
 })
 
+ if run_tests:
+ build_steps.append(
+ # test binaries
+ {
+ 'name': 'gcr.io/oss-fuzz-base/base-runner',
+ 'env': env,
+ 'args': ['bash', '-c', 'test_all'],
+ })
+
 if project_yaml['labels']:
 # write target labels
 build_steps.append({
",326,32
"Two fixes for ghostcript (#2562)

* [ghostscript] Fix ininitialized pointer

Passing an invalid pointer causes a crash in gs_new_instance.

* [ghostscript] Add seed corpus

Use the examples distributed with ghostcript as a seed corpus."," static int gs_stdout(void *inst, const char *buf, int len)
 static int gs_to_raster_fuzz(const unsigned char *buf, size_t size)
 {
 int ret;
-void *gs;
+void *gs = NULL;
 
 /* Mostly stolen from cups-filters gstoraster. */
 char *args[] = {
",70,10
"[gnupg] Updates fuzz targets for gnupg (#2576)

Adding an arugment to public_key_list"," int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) {
 }
 //populate /tmp/fuzzdirdecrypt/ as homedir ~/.gnupg
 strlist_t sl = NULL;
- public_key_list (ctrlGlobal, sl, 0);
+ public_key_list (ctrlGlobal, sl, 0, 0);
 free_strlist(sl);
 //no output for stderr
 log_set_file(""/dev/null"");
",121,18
"[infra] Use gsutil ""cp"" instead of ""rsync"" for coverage job (#2585). (#2625)"," def get_build_steps(project_dir):
 {
 'name': 'gcr.io/cloud-builders/gsutil',
 'args': [
- '-m', 'rsync', '-r', '-d',
+ '-m', 'cp', '-r',
 os.path.join(out, 'report'),
 upload_report_url,
 ],
 def get_build_steps(project_dir):
 {
 'name': 'gcr.io/cloud-builders/gsutil',
 'args': [
- '-m', 'rsync', '-r', '-d',
+ '-m', 'cp', '-r',
 os.path.join(out, 'fuzzer_stats'),
 upload_fuzzer_stats_url,
 ],
 def get_build_steps(project_dir):
 {
 'name': 'gcr.io/cloud-builders/gsutil',
 'args': [
- '-m', 'rsync', '-r', '-d',
+ '-m', 'cp', '-r',
 os.path.join(out, 'logs'),
 UPLOAD_URL_FORMAT.format(
 project=project_name, type='logs', date=report_date),
",221,13
[spdlog] Add spdlog support to oss-fuzz as a starting point (#2629),"
+#include <cstddef>
+
+#include ""FuzzedDataProvider.h""
+#include ""spdlog/spdlog.h""
+
+extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
+ if (size == 0) {
+ return 0;
+ }
+ FuzzedDataProvider stream(data, size);
+
+ const size_t size_arg = stream.ConsumeIntegral<size_t>();
+ const int int_arg = stream.ConsumeIntegral<int>();
+ const std::string string_arg = stream.ConsumeRandomLengthString(size);
+ const std::string format_string = stream.ConsumeRemainingBytesAsString();
+ spdlog::info(format_string.c_str(), size_arg, int_arg, string_arg);
+
+ return 0;
+}
",15,2
"[mpg123] silence library error messages (#2642)

* mpg123/read_fuzzer: disable error messages from libmpg123

This shall remove any error messages libmpg123 prints out during fuzzing,
leaving only the crash trace at the inevitable end."," extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
 return 0;
 }
 
- ret = mpg123_open_feed(handle);
+ ret = mpg123_param(handle, MPG123_ADD_FLAGS, MPG123_QUIET, 0.);
+ if(ret == MPG123_OK)
+ ret = mpg123_open_feed(handle);
 if (ret != MPG123_OK) {
 mpg123_delete(handle);
 return 0;
",52,10
"[mysql] Initial integration for mysql server (#2593)

* Initial integration for mysql server","
+#include <stdint.h>
+#include <stdlib.h>
+#include <stdio.h>
+
+extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size);
+
+int main(int argc, char** argv)
+{
+ FILE * fp;
+ uint8_t *Data;
+ size_t Size;
+
+ if (argc != 2) {
+ return 1;
+ }
+ //opens the file, get its size, and reads it into a buffer
+ fp = fopen(argv[1], ""rb"");
+ if (fp == NULL) {
+ return 2;
+ }
+ if (fseek(fp, 0L, SEEK_END) != 0) {
+ fclose(fp);
+ return 2;
+ }
+ Size = ftell(fp);
+ if (Size == (size_t) -1) {
+ fclose(fp);
+ return 2;
+ }
+ if (fseek(fp, 0L, SEEK_SET) != 0) {
+ fclose(fp);
+ return 2;
+ }
+ Data = (uint8_t*)malloc(Size*sizeof(uint8_t));
+ if (Data == NULL) {
+ fclose(fp);
+ return 2;
+ }
+ if (fread(Data, Size, 1, fp) != 1) {
+ fclose(fp);
+ free(Data);
+ return 2;
+ }
+
+ //lauch fuzzer
+ LLVMFuzzerTestOneInput(Data, Size);
+ free(Data);
+ fclose(fp);
+ return 0;
+}
",44,8
"[mysql] Adds project mysql (#2650)

* Initial integration for mysql server

* Adds patch

* Code review takes into account","
+#include <stdint.h>
+#include <stdlib.h>
+#include <stdio.h>
+
+extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size);
+
+int main(int argc, char** argv)
+{
+ FILE * fp;
+ uint8_t *Data;
+ size_t Size;
+
+ if (argc != 2) {
+ return 1;
+ }
+ //opens the file, get its size, and reads it into a buffer
+ fp = fopen(argv[1], ""rb"");
+ if (fp == NULL) {
+ return 2;
+ }
+ if (fseek(fp, 0L, SEEK_END) != 0) {
+ fclose(fp);
+ return 2;
+ }
+ Size = ftell(fp);
+ if (Size == (size_t) -1) {
+ fclose(fp);
+ return 2;
+ }
+ if (fseek(fp, 0L, SEEK_SET) != 0) {
+ fclose(fp);
+ return 2;
+ }
+ Data = (uint8_t*)malloc(Size*sizeof(uint8_t));
+ if (Data == NULL) {
+ fclose(fp);
+ return 2;
+ }
+ if (fread(Data, Size, 1, fp) != 1) {
+ fclose(fp);
+ free(Data);
+ return 2;
+ }
+
+ //lauch fuzzer
+ LLVMFuzzerTestOneInput(Data, Size);
+ free(Data);
+ fclose(fp);
+ return 0;
+}
",44,8
libjpeg-turbo: enable i386 architecture and improve fuzzer regarding msan (#2680)," extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
 return 0;
 }
 
- std::unique_ptr<unsigned char[]> buf(new unsigned char[width * height * 3]);
+ const int buffer_size = width * height * 3;
+ std::unique_ptr<unsigned char[]> buf(new unsigned char[buffer_size]);
 tjDecompress2(
 jpegDecompressor, data, size, buf.get(), width, 0, height, TJPF_RGB, 0);
 
+ // For memory sanitizer, test each output byte
+ const unsigned char* raw_buf = buf.get();
+ int count = 0;
+ for( int i = 0; i < buffer_size; i++ )
+ {
+ if (raw_buf[i])
+ {
+ count ++;
+ }
+ }
+ if (count == buffer_size)
+ {
+ // Do something with side effect, so that all the above tests don't
+ // get removed by the optimizer.
+ free(malloc(1));
+ }
+
 tjDestroy(jpegDecompressor);
 
 return 0;
",33,8
[spidermonkey-ufi] Add spidermonkey-ufi project (#2676),"
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+#define STRINGLIT(S) #S
+#define STRINGIFY(S) STRINGLIT(S)
+
+// Required for oss-fuzz to consider the binary a target.
+static const char* magic __attribute__((used)) = ""LLVMFuzzerTestOneInput"";
+
+int main(int argc, char* argv[]) {
+ setenv(""HOME"", ""/tmp"", 0);
+ setenv(""LIBFUZZER"", ""1"", 1);
+ setenv(""FUZZER"", STRINGIFY(FUZZ_TARGET), 1);
+
+ char* options = getenv(""ASAN_OPTIONS"");
+ if (options) {
+ char* ptr;
+ char* new_options = strdup(options);
+
+ // https://bugzilla.mozilla.org/1477846
+ ptr = strstr(new_options, ""detect_stack_use_after_return=1"");
+ if (ptr) ptr[30] = '0';
+
+ // https://bugzilla.mozilla.org/1477844
+ ptr = strstr(new_options, ""detect_leaks=1"");
+ if (ptr) ptr[13] = '0';
+
+ setenv(""ASAN_OPTIONS"", new_options, 1);
+ free(new_options);
+ }
+
+ int ret = execv(""./fuzz-tests"", argv);
+ if (ret)
+ perror(""execv"");
+ return ret;
+}
+
",25,5
Fix exception in updating badges on build status page," import build_project
 
 STATUS_BUCKET = 'oss-fuzz-build-logs'
 SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
-BADGE_DIR = 'badges/'
+BADGE_DIR = 'badges'
 RETRY_COUNT = 3
 RETRY_WAIT = 5
 MAX_BUILD_RESULTS = 2000
 def update_build_badges(builds, projects, build_tag, coverage_tag):
 badge=badge, extension=extension)
 # Retrieve the image relative to this script's location
 badge_file = os.path.join(
- SCRIPT_DIR, 'badge_images', image_directory, badge_name)
+ SCRIPT_DIR, 'badge_images', badge_name)
 
 # The uploaded blob name should look like `badges/project.png`
- blob_name = '{badge_dir}{project_name}.{extension}'.format(
+ blob_name = '{badge_dir}/{project_name}.{extension}'.format(
 badge_dir=BADGE_DIR, project_name=project,
 extension=extension)
 
",175,34
"Use ""x86"" instead of ""i386"" for better name recognition. (#2685)

It seems more people understand x86 than i386, use this term instead."," ENGINE_INFO = {
 EngineInfo(
 upload_bucket='clusterfuzz-builds',
 supported_sanitizers=['address', 'memory', 'undefined'],
- supported_architectures=['x86_64', 'i386']),
+ supported_architectures=['x86_64', 'x86']),
 'afl':
 EngineInfo(
 upload_bucket='clusterfuzz-builds-afl',
 def get_signed_url(path, method='PUT', content_type=''):
 
 def is_supported_configuration(fuzzing_engine, sanitizer, architecture):
 fuzzing_engine_info = ENGINE_INFO[fuzzing_engine]
- if architecture == 'i386' and sanitizer != 'address':
+ if architecture == 'x86' and sanitizer != 'address':
 return False
 return (sanitizer in fuzzing_engine_info.supported_sanitizers and
 architecture in fuzzing_engine_info.supported_architectures)
",326,32
"Revert ""Use ""x86"" instead of ""i386"" for better name recognition. (#2685)"" (#2687)

This reverts commit 0c6cc5cae8ac393fb7158ae50e9988d0a37a4d82."," ENGINE_INFO = {
 EngineInfo(
 upload_bucket='clusterfuzz-builds',
 supported_sanitizers=['address', 'memory', 'undefined'],
- supported_architectures=['x86_64', 'x86']),
+ supported_architectures=['x86_64', 'i386']),
 'afl':
 EngineInfo(
 upload_bucket='clusterfuzz-builds-afl',
 def get_signed_url(path, method='PUT', content_type=''):
 
 def is_supported_configuration(fuzzing_engine, sanitizer, architecture):
 fuzzing_engine_info = ENGINE_INFO[fuzzing_engine]
- if architecture == 'x86' and sanitizer != 'address':
+ if architecture == 'i386' and sanitizer != 'address':
 return False
 return (sanitizer in fuzzing_engine_info.supported_sanitizers and
 architecture in fuzzing_engine_info.supported_architectures)
",326,32
"[minizinc] License header and enable bug filing MSan (#2694)

* [minizinc] Add license header in the fuzzer and set experimental flag to False for the MemorySanitizer

* Enable MSan the right way","
+/*
+# Copyright 2019 Google Inc.
+#
+# Licensed under the Apache License, Version 2.0 (the ""License"");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an ""AS IS"" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+################################################################################
+*/
+
 #include <minizinc/solver.hh>
 
 using namespace std;
",43,13
Make gif data little endian (#2712)," void ProtoConverter::writeByte(uint8_t x)
 
 void ProtoConverter::writeWord(uint16_t x)
 {
-x = __builtin_bswap16(x);
 m_output.write((char *)&x, sizeof(x));
 }
 
 void ProtoConverter::writeInt(uint32_t x)
 {
-x = __builtin_bswap32(x);
 m_output.write((char *)&x, sizeof(x));
 }
 
 void ProtoConverter::writeLong(uint64_t x)
 {
-x = __builtin_bswap64(x);
 m_output.write((char *)&x, sizeof(x));
 }
 
",204,43
"[zopfli] Fix timeout and use FuzzedDataProvider from the system location. (#2763)

* [zopfli] Use FuzzedDataProvider from the system location.

* add missing size check","
 #include <cstdlib>
 #include <string>
 
+#include <fuzzer/FuzzedDataProvider.h>
+
 #include ""zopfli.h""
-#include ""FuzzedDataProvider.h""
 
 extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
+ if (size > 8192)
+ return 0;
+
 FuzzedDataProvider stream(data, size);
 
 ZopfliOptions options;
",25,3
[matio] Add more API calls for matio (#2779)," extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
 if (matfd == nullptr) {
 return 0;
 }
- // TODO(https://github.com/google/oss-fuzz/pull/2761): use more complicated APIs
- // such as Mat_VarReadDataAll, Mat_VarReadDataLinear, Mat_VarReadNext, etc. 
+
+ size_t n = 0;
+ Mat_GetDir(matfd, &n);
+ Mat_Rewind(matfd);
+
+ matvar_t* matvar = nullptr;
+ while ((matvar = Mat_VarReadNextInfo(matfd)) != nullptr) {
+ Mat_VarReadDataAll(matfd, matvar);
+ Mat_VarGetSize(matvar);
+ Mat_VarFree(matvar);
+ }
+
 Mat_Close(matfd);
 
 return 0;
",25,3
Add SPIRV projects for blackbox fuzzing with GraphicsFuzz (#2812)," def build_project(project):
 
 print('Building project', project)
 build_fuzzers(project, engine, sanitizer, architecture)
- check_build(project, engine, sanitizer, architecture)
+ if engine != 'none':
+ check_build(project, engine, sanitizer, architecture)
 
 
 def main():
",85,19
[infra] Skip code coverage job for gofuzz projects (#2714). (#2818)," LATEST_REPORT_INFO_URL = (
 # Link where to upload code coverage report files to.
 UPLOAD_URL_FORMAT = 'gs://' + COVERAGE_BUCKET_NAME + '/{project}/{type}/{date}'
 
+# TODO(#2817): gofuzz projects to skip code coverage job for.
+GO_FUZZ_PROJECTS = ['golang', 'syzkaller']
+
 
 def skip_build(message):
 """"""Exit with 0 code not to mark code coverage job as failed.""""""
 def get_build_steps(project_dir):
 if project_yaml['disabled']:
 skip_build('Project ""%s"" is disabled.' % project_name)
 
+ if project_name in GO_FUZZ_PROJECTS:
+ skip_build('Project ""%s"" uses gofuzz, coverage is not supported yet.' %
+ project_name)
+
 fuzz_targets = get_targets_list(project_name)
 if not fuzz_targets:
 skip_build('No fuzz targets found for project ""%s"".' % project_name)
",225,14
[Firefox] Remove redundant environment variables (#2822)," int main(int argc, char* argv[]) {
 // Expects LD_LIBRARY_PATH to not also be set by oss-fuzz.
 setenv(""LD_LIBRARY_PATH"", ld_path, 0);
 setenv(""HOME"", ""/tmp"", 0);
- setenv(""MOZ_RUN_GTEST"", ""1"", 1);
- setenv(""LIBFUZZER"", ""1"", 1);
 setenv(""FUZZER"", STRINGIFY(FUZZ_TARGET), 1);
 
 // ContentParentIPC
",51,8
"mpg123: limit fuzzer runtime (#2832)

* mpg123: limit runtime of decode_fuzzer

To avoid spurious timeout reports, the test shall end after 10000 MPEG frames
or 1 MiB of data, which should both be reasonable numbers. The timeout
report motivating this had 500K with 140k bad frames. The limit of
10000 frames corresponds to a normal radio song as MP3 stream.

* mpg123: limit runtime of read_fuzzer

This applies the same logic as the decode fuzzer: stop decoding after
10000 MPEG frames or 1 MiB of input data. We could debate a bigger
limit on the data size, but we do want compact testcases, right?"," extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
 FuzzedDataProvider provider(data, size);
 while ((decode_ret != MPG123_ERR)) {
 if (decode_ret == MPG123_NEED_MORE) {
- if (provider.remaining_bytes() == 0) {
+ if (provider.remaining_bytes() == 0
+ || mpg123_tellframe(handle) > 10000
+ || mpg123_tell_stream(handle) > 1<<20) {
 break;
 }
 const size_t next_size = provider.ConsumeIntegralInRange<size_t>(
",53,12
[ghostscript] Limit ghostscript memory usage to 1Gbyte. (#2890)," static int gs_to_raster_fuzz(const unsigned char *buf, size_t size)
 
 /* Mostly stolen from cups-filters gstoraster. */
 char *args[] = {
+""-K1048576"",
 ""-r200x200"",
 ""-dMediaPosition=1"",
 ""-dcupsColorSpace=1"", /* RGB */
",71,10
"[infra] Use more generic approach to skip code coverage for Go projects. (#2953)

* [infra] Use more generic approach to skip code coverage for Go projects.

* address review comments"," LATEST_REPORT_INFO_URL = (
 # Link where to upload code coverage report files to.
 UPLOAD_URL_FORMAT = 'gs://' + COVERAGE_BUCKET_NAME + '/{project}/{type}/{date}'
 
-# TODO(#2817): gofuzz projects to skip code coverage job for.
-GO_FUZZ_PROJECTS = ['golang', 'syzkaller']
+# TODO(#2817): Support code coverage for Go projects.
+GO_FUZZ_BUILD = 'go-fuzz-build -libfuzzer'
 
 
 def skip_build(message):
 def get_build_steps(project_dir):
 if project_yaml['disabled']:
 skip_build('Project ""%s"" is disabled.' % project_name)
 
- if project_name in GO_FUZZ_PROJECTS:
- skip_build('Project ""%s"" uses gofuzz, coverage is not supported yet.' %
- project_name)
+ build_script_path = os.path.join(project_dir, 'build.sh')
+ with open(build_script_path) as fh:
+ if GO_FUZZ_BUILD in fh.read():
+ skip_build('Project ""%s"" uses go-fuzz, coverage is not supported yet.' %
+ project_name)
 
 fuzz_targets = get_targets_list(project_name)
 if not fuzz_targets:
",227,14
"Adds project mysql (#2922)

* Initial integration for mysql server

* Patch for mysql 8.0.18

* Adds include

* Adds argument to run_bootstrap_thread

* build -Dprotobuf_BUILD_SHARED_LIBS=OFF

* olwercase port option

* use different socket files","
+#include <stdint.h>
+#include <stdlib.h>
+#include <stdio.h>
+
+extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size);
+
+int main(int argc, char** argv)
+{
+ FILE * fp;
+ uint8_t *Data;
+ size_t Size;
+
+ if (argc != 2) {
+ return 1;
+ }
+ //opens the file, get its size, and reads it into a buffer
+ fp = fopen(argv[1], ""rb"");
+ if (fp == NULL) {
+ return 2;
+ }
+ if (fseek(fp, 0L, SEEK_END) != 0) {
+ fclose(fp);
+ return 2;
+ }
+ Size = ftell(fp);
+ if (Size == (size_t) -1) {
+ fclose(fp);
+ return 2;
+ }
+ if (fseek(fp, 0L, SEEK_SET) != 0) {
+ fclose(fp);
+ return 2;
+ }
+ Data = (uint8_t*)malloc(Size*sizeof(uint8_t));
+ if (Data == NULL) {
+ fclose(fp);
+ return 2;
+ }
+ if (fread(Data, Size, 1, fp) != 1) {
+ fclose(fp);
+ free(Data);
+ return 2;
+ }
+
+ //lauch fuzzer
+ LLVMFuzzerTestOneInput(Data, Size);
+ free(Data);
+ fclose(fp);
+ return 0;
+}
",44,8
[bisect_clang] Add comment on testing (#2957)," def find_culprit_commit(test_command, good_commit, bad_commit):
 
 
 def main():
- """"""Finds the culprit LLVM commit that introduced a clang regression.""""""
+ """"""Finds the culprit LLVM commit that introduced a clang regression.
+ Can be tested using this command in a libsodium shell:
+ python3 bisect_clang.py ""cd /src/libsodium; make clean; cd -; compile && /out/secret_key_auth_fuzzer -runs=100"" \
+ f7e52fbdb5a7af8ea0808e98458b497125a5eca1 \
+ 8288453f6aac05080b751b680455349e09d49825
+ """"""
 # TODO(metzman): Sanity check CFLAGS for things like
 # -fsanitize=fuzzer-no-link.
 # TODO(metzman): Allow test_command to be optional and for just build.sh to be
",132,35
[gnupg] Limit size for gnupg decrypt target (#2962)," static void rmrfdir(char *path)
 }
 }
 
+// 65kb should be enough ;-)
+#define MAX_LEN 0x10000
+
 int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) {
 
 if (! initialized) {
 int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) {
 
 memset(ctrlGlobal, 0, sizeof(*ctrlGlobal));
 ctrlGlobal->magic = SERVER_CONTROL_MAGIC;
+ if (Size > MAX_LEN) {
+ // limit maximum size to avoid long computing times
+ Size = MAX_LEN;
+ }
 
 if (ftruncate(fd, Size) == -1) {
 return 0;
",124,19
Uses different directories for different mysql fuzz targets (#2971)," extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) {
 /* first init was run with
 * mysqld --user=root --initialize-insecure --log-error-verbosity=5 --datadir=/out/mysql/data/ --basedir=/out/mysql/
 */
- system(""rm -Rf /tmp/mysql"");
+ system(""rm -Rf /tmp/mysqld"");
 char command[MAX_SIZE];
 char argbase[MAX_SIZE];
 char arginitfile[MAX_SIZE];
- snprintf(command, MAX_SIZE-1, ""cp -r %s/mysql/data /tmp/mysql"", filepath);
+ snprintf(command, MAX_SIZE-1, ""cp -r %s/mysql/data /tmp/mysqld"", filepath);
 //unsafe
 system(command);
 
 extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) {
 const_cast<char *>(""--event-scheduler=DISABLED""),
 const_cast<char *>(""--performance_schema=OFF""),
 const_cast<char *>(""--thread_stack=1048576""),
- const_cast<char *>(""--datadir=/tmp/mysql/""),
+ const_cast<char *>(""--datadir=/tmp/mysqld/""),
 const_cast<char *>(""--port=3303""),
 const_cast<char *>(""--socket=/tmp/mysqld.sock""),
 const_cast<char *>(argbase),
",117,14
Implement a fuzz target for uncompress2 in zlib. (#2976),"
+#include <stddef.h>
+#include <stdint.h>
+#include <string.h>
+
+#include ""zlib.h""
+
+static Bytef buffer[256 * 1024] = { 0 };
+
+// Entry point for LibFuzzer.
+extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
+ uLongf buffer_length = static_cast<uLongf>(sizeof(buffer));
+ uLong buf_size = static_cast<uLong>(size);
+ // Ignore return code.
+ uncompress2(buffer, &buffer_length, data, &buf_size);
+ return 0;
+}
",11,1
Limits input size for gnupg list fuzz target (#2987)," static void rmrfdir(char *path)
 }
 }
 
+// 65kb should be enough ;-)
+#define MAX_LEN 0x10000
+
 int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) {
 IOBUF a;
 armor_filter_context_t *afx = NULL;
 int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) {
 initialized = true;
 }
 
+ if (Size > MAX_LEN) {
+ // limit maximum size to avoid long computing times
+ Size = MAX_LEN;
+ }
+
 memset(ctrlGlobal, 0, sizeof(*ctrlGlobal));
 ctrlGlobal->magic = SERVER_CONTROL_MAGIC;
 
",142,23
Adds gonids project (#2995),"
+package gonidsfuzz
+
+import (
+""github.com/google/gonids""
+)
+
+func Fuzz(data []byte) int {
+r, err := gonids.ParseRule(string(data))
+if err != nil {
+// Handle parse error
+return 0
+}
+r.OptimizeHTTP()
+return 1
+}
",12,2
Debugs mysql server fuzz targets (#3012)," extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) {
 char arginitfile[MAX_SIZE];
 snprintf(command, MAX_SIZE-1, ""cp -r %s/mysql/data /tmp/mysql_initfile"", filepath);
 //unsafe
- system(command);
+ if (system(command) < 0) {
+ printf(""failed command %s\n"", command);
+ }
+ snprintf(arginitfile, MAX_SIZE-1, ""%s/initnopw.sql"", filepath);
+ FILE *ftest = fopen(arginitfile, ""r"");
+ if (ftest) {
+ fclose(ftest);
+ } else {
+ printf(""missing file %s\n"", arginitfile);
+ }
 
 snprintf(argbase, MAX_SIZE-1, ""--basedir=%s/mysql/"", filepath);
 snprintf(arginitfile, MAX_SIZE-1, ""--init-file=%s/initnopw.sql"", filepath);
",101,12
do not analyze too long inpus for gnupg list fuzz target (#3007)," int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) {
 
 if (Size > MAX_LEN) {
 // limit maximum size to avoid long computing times
- Size = MAX_LEN;
+ return 0;
 }
 
 memset(ctrlGlobal, 0, sizeof(*ctrlGlobal));
",142,23
[wabt] Add project (#3035),"
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the ""License"");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an ""AS IS"" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#include ""wabt/src/binary-reader-ir.h""
+#include ""wabt/src/binary-reader.h""
+#include ""wabt/src/common.h""
+#include ""wabt/src/ir.h""
+
+extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
+ wabt::ReadBinaryOptions options;
+ wabt::Errors errors;
+ wabt::Module module;
+ wabt::ReadBinaryIr(""dummy filename"", data, size, options, &errors, &module);
+ return 0;
+}
+
",11,1
mysql fuzz targets use custom rm and cp (#3046),"
 #include ""sql/sql_parse.h""
 #include ""mysql/psi/mysql_socket.h""
 #include ""violite.h""
+#include ""util_fuzz.h""
 #include <stdlib.h>
 #include <libgen.h>
 
 extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) {
 /* first init was run with
 * mysqld --user=root --initialize-insecure --log-error-verbosity=5 --datadir=/out/mysql/data/ --basedir=/out/mysql/
 */
- system(""rm -Rf /tmp/mysql_docommand"");
+ utilfuzz_rmrf(""/tmp/mysql_docommand"");
 char command[MAX_SIZE];
 char argbase[MAX_SIZE];
 char arginitfile[MAX_SIZE];
- snprintf(command, MAX_SIZE-1, ""cp -r %s/mysql/data /tmp/mysql_docommand"", filepath);
- //unsafe
- system(command);
+ snprintf(command, MAX_SIZE-1, ""%s/mysql/data"", filepath);
+ utilfuzz_cpr(command, ""/tmp/mysql_docommand"");
 
 snprintf(argbase, MAX_SIZE-1, ""--basedir=%s/mysql/"", filepath);
 snprintf(arginitfile, MAX_SIZE-1, ""--init-file=%s/initnopw.sql"", filepath);
",137,15
Fix fuzz targets in mysql (#3052)," size_t globallen = 0;
 #define CP_BUF_SIZE 4096
 static int cp_cb(const char *fpath, const struct stat *sb, int typeflag, struct FTW *ftwbuf) {
 char newname[CP_NAME_MAX_SIZE];
- char buf[BUF_SIZE];
+ char buf[CP_BUF_SIZE];
 int rv = 2;
 snprintf(newname, CP_NAME_MAX_SIZE-1, ""%s%s"", globalto, fpath+globallen);
 if (FTW_D == typeflag) {
",44,7
Fuzzer for avahi's core DNS parser (#3098),"
+#include <stdint.h>
+#include <string.h>
+
+extern ""C"" {
+#include <avahi-common/malloc.h>
+#include <avahi-core/dns.h>
+#include <avahi-core/log.h>
+}
+
+void log_function(AvahiLogLevel level, const char *txt) {}
+
+struct AvahiState {
+ AvahiState() {
+ avahi_set_log_function(log_function);
+ }
+};
+
+AvahiState kGlobalSate;
+
+extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
+ AvahiDnsPacket* packet = avahi_dns_packet_new(size + AVAHI_DNS_PACKET_EXTRA_SIZE);
+ memcpy(AVAHI_DNS_PACKET_DATA(packet), data, size);
+ packet->size = size;
+ AvahiKey* key = avahi_dns_packet_consume_key(packet, nullptr);
+ if (key) {
+ avahi_key_is_valid(key);
+ char *s = avahi_key_to_string(key);
+ avahi_free(s);
+ avahi_key_unref(key);
+ }
+ avahi_dns_packet_free(packet);
+
+ return 0;
+}
\ No newline at end of file
",28,4
"Removes binutils patch, applied upstream (#3109)"," int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) {
 if (disasfunc != NULL) {
 disassemble_init_for_target(&disasm_info);
 disasfunc(0x1000, &disasm_info);
- disassemble_release(&disasm_info);
+ disassemble_free_target(&disasm_info);
 }
 }
 
",61,7
Add initial integration xerces-c (#3083),"
+/*
+#
+# Licensed under the Apache License, Version 2.0 (the ""License"");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an ""AS IS"" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+################################################################################
+*/
+#include ""xerces_fuzz_common.h""
+
+#include ""xercesc/framework/MemBufInputSource.hpp""
+#include ""xercesc/parsers/SAXParser.hpp""
+#include ""xercesc/util/OutOfMemoryException.hpp""
+
+using namespace xercesc_3_2;
+
+extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) {
+ parseInMemory(Data, Size);
+ return 0;
+}
",9,1
Remove trailing whitespace (#3135)," def build_fuzzers_impl(project_name, clean, engine, sanitizer, architecture,
 'ARCHITECTURE=' + architecture,
 ]
 if env_to_add:
- env += env_to_add 
+ env += env_to_add
 
 project_work_dir = _get_work_dir(project_name)
 
",620,116
[infra] Add support for Bisecting Git Commits Introducing Crashes(#3119)," class RepoManager(object):
 self._run_command(['git', 'fetch', '--unshallow'],
 self.repo_dir,
 check_result=True)
- self._run_command(['git', 'checkout', '-f', commit], self.repo_dir)
+ self._run_command(['git', 'checkout', '-f', commit],
+ self.repo_dir,
+ check_result=True)
+ self._run_command(['git', 'clean', '-fxd'],
+ self.repo_dir,
+ check_result=True)
 if self.get_current_commit() != commit:
 raise RepoManagerError('Error checking out commit %s' % commit)
 
",99,27
"[easywsclient] Add easywsclient project (#3126)

* add easywsclient project

* Update build.sh

* modified fuzzer

* Indent fixes","
+// Copyright 2019 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the ""License"");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an ""AS IS"" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#include <stddef.h>
+#include <stdint.h>
+#include <string.h>
+
+#include ""easywsclient.hpp""
+#include <fuzzer/FuzzedDataProvider.h>
+
+extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
+ std::string str(reinterpret_cast<const char*>(data), size);
+ easywsclient::WebSocket::from_url(str);
+ return 0;
+}
",10,1
[mysql] Fix misalign in mysql fuzz target (#3160)," extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) {
 if (logfile == NULL) {
 logfile = fopen(""/dev/null"", ""w"");
 }
- flags = * ((unsigned long *) (Data + Size - sizeof(unsigned long)));
+ memcpy(&flags, Data + Size - sizeof(unsigned long), sizeof(unsigned long));
 mysql_init(&mysql);
 mysql_options(&mysql, MYSQL_ENABLE_CLEARTEXT_PLUGIN, &opt_cleartext);
 mysql_options(&mysql, MYSQL_OPT_SSL_MODE, &opt_ssl);
",93,16
xml proto converter: Fix ossfuzz issue 19507 (no return value). (#3167)," private:
 
 void visit(XmlDocument const&);
 
+template <typename T>
+bool isValid(T const& messageType) {
+return T::Type_IsValid(messageType.type());
+}
+
 std::string removeNonAscii(std::string const&);
 std::string getUri(Element_Id _x);
 std::string getPredefined(Element_Id _x, std::string const&);
",50,1
[infra] Do not skip coverage build if there is no build.sh file (#3185). (#3189)," def get_build_steps(project_dir):
 skip_build('Project ""%s"" is disabled.' % project_name)
 
 build_script_path = os.path.join(project_dir, 'build.sh')
- with open(build_script_path) as fh:
- if GO_FUZZ_BUILD in fh.read():
- skip_build('Project ""%s"" uses go-fuzz, coverage is not supported yet.' %
- project_name)
+ if os.path.exists(build_script_path):
+ with open(build_script_path) as fh:
+ if GO_FUZZ_BUILD in fh.read():
+ skip_build('Project ""%s"" uses go-fuzz, coverage is not supported yet.' %
+ project_name)
 
 fuzz_targets = get_targets_list(project_name)
 if not fuzz_targets:
",228,15
Make bad_build_check more likely to catch hardcoding /out (#3180)," def check_build(args):
 
 if args.fuzzer_name:
 run_args += [
- 'bad_build_check',
+ 'test_one',
 os.path.join('/out', args.fuzzer_name)
 ]
 else:
",623,117
"Revert ""Make bad_build_check more likely to catch hardcoding /out (#3180)"" (#3197)

Revert so that we don't get two errors in a row.

This reverts commit 14bdd9332c0ae144dd24c9d09139c55a397f902d."," def check_build(args):
 
 if args.fuzzer_name:
 run_args += [
- 'test_one',
+ 'bad_build_check',
 os.path.join('/out', args.fuzzer_name)
 ]
 else:
",629,117
"Reland Make bad_build_check more likely to catch hardcoding /out (#3180) (#3205)

This reverts commit 689c3f4b65b77ca27e882de828b4e741121238fc."," def check_build(args):
 
 if args.fuzzer_name:
 run_args += [
- 'bad_build_check',
+ 'test_one',
 os.path.join('/out', args.fuzzer_name)
 ]
 else:
",629,117
"[infra] Print additional information for build/coverage failures on GCB (#3104). (#3208)

* [infra] Explicily print failing build config in the GCB log (#3104).

* add trailing ""false"" command + add a message for misisng coprus backups in code coverage build

* improve the coverage message and behavior

* fix exit command

* use .format() for a single argument format string too

* fix typo"," def get_build_steps(project_dir):
 'args': [
 'bash',
 '-c',
- 'for f in /corpus/*.zip; do unzip -q $f -d ${f%%.*}; done && coverage',
+ ('for f in /corpus/*.zip; do unzip -q $f -d ${f%%.*} || '
+ 'echo ""Failed to unpack the corpus for $(basename ${f%%.*}). '
+ 'This usually means that corpus backup for a particular fuzz '
+ 'target does not exist. If a fuzz target was added in the last '
+ '24 hours, please wait one more day. Otherwise, something is '
+ 'wrong with the fuzz target or the infrastructure, and corpus '
+ 'pruning task does not finish successfully."" && exit 1; '
+ 'done && coverage')
 ],
 'volumes': [{'name': 'corpus', 'path': '/corpus'}],
 }
",235,15
[infra] Add parens to ensure correct execution order (#3104). (#3213)," def get_build_steps(project_dir):
 'args': [
 'bash',
 '-c',
- ('for f in /corpus/*.zip; do unzip -q $f -d ${f%%.*} || '
+ ('for f in /corpus/*.zip; do unzip -q $f -d ${f%%.*} || ('
 'echo ""Failed to unpack the corpus for $(basename ${f%%.*}). '
 'This usually means that corpus backup for a particular fuzz '
 'target does not exist. If a fuzz target was added in the last '
 '24 hours, please wait one more day. Otherwise, something is '
 'wrong with the fuzz target or the infrastructure, and corpus '
- 'pruning task does not finish successfully."" && exit 1; '
- 'done && coverage')
+ 'pruning task does not finish successfully."" && exit 1'
+ '); done && coverage')
 ],
 'volumes': [{'name': 'corpus', 'path': '/corpus'}],
 }
",235,15
[infra] Fix env variable in the helper.py repoduce command (#3230)," def run_fuzzer(args):
 
 def reproduce(args):
 """"""Reproduce a specific test case from a specific project.""""""
- return reproduce_impl(args.project_name, args.fuzzer_name, args.valgrind, args.env_to_add,
+ return reproduce_impl(args.project_name, args.fuzzer_name, args.valgrind, args.e,
 args.fuzzer_args, args.testcase_path)
 
 
",629,117
"Fix presubmit parsing issue with emails. (#3234)

* Fix presubmit parsing issue with emails.

* Fix"," class ProjectYamlChecker:
 """"""Check that emails are valid looking.""""""
 # Get email addresses.
 email_addresses = []
- for section in ['auto_ccs', 'primary_contact']:
- email_addresses.extend(self.data.get(section, []))
+ primary_contact = self.data.get('primary_contact')
+ if primary_contact:
+ email_addresses.append(primary_contact)
+ auto_ccs = self.data.get('auto_ccs')
+ if auto_ccs:
+ email_addresses.extend(auto_ccs)
 
 # Sanity check them.
 for email_address in email_addresses:
 _CHECK_LICENSE_EXTENSIONS = [
 '.sh',
 '.yaml',
 ]
+_CHECK_LICENSE_EXCLUSIONS = ['project.yaml']
 _LICENSE_STRING = 'http://www.apache.org/licenses/LICENSE-2.0'
 
 
 def check_license(paths):
 success = True
 for path in paths:
 filename = os.path.basename(path)
+ if filename in _CHECK_LICENSE_EXCLUSIONS:
+ continue
+
 extension = os.path.splitext(path)[1]
 if (filename not in _CHECK_LICENSE_FILENAMES and
 extension not in _CHECK_LICENSE_EXTENSIONS):
",191,64
[infra] Presubmit: remove license check for all .yaml files. (#3235)," _CHECK_LICENSE_EXTENSIONS = [
 '.proto',
 '.py',
 '.sh',
- '.yaml',
 ]
-_CHECK_LICENSE_EXCLUSIONS = ['project.yaml']
+
 _LICENSE_STRING = 'http://www.apache.org/licenses/LICENSE-2.0'
 
 
 def check_license(paths):
 success = True
 for path in paths:
 filename = os.path.basename(path)
- if filename in _CHECK_LICENSE_EXCLUSIONS:
- continue
-
 extension = os.path.splitext(path)[1]
 if (filename not in _CHECK_LICENSE_FILENAMES and
 extension not in _CHECK_LICENSE_EXTENSIONS):
",187,63
[infra] helper: fix regression introducing attribute error when reproducing crashes (#3246)," def run_fuzzer(args):
 def reproduce(args):
 """"""Reproduce a specific test case from a specific project.""""""
 return reproduce_impl(args.project_name, args.fuzzer_name, args.valgrind,
- args.env_to_add, args.fuzzer_args, args.testcase_path)
+ args.e, args.fuzzer_args, args.testcase_path)
 
 
 def reproduce_impl( # pylint: disable=too-many-arguments
",647,113
"[infra] Collect dataflow traces on the builder (#1632). (#3238)

* [infra] Skeleton of the changes needed for collecting DFT on the builder (#1632).

* move ENGINE_INFO to the helper as well

* make collect_dft +x

* syntax fixes

* add actual dataflow tracer script

* format

* more refactoring and cleanup

* format

* address Oliver's feedback

* format

* more fixes

* format

* do not redirect stderr to stdout

* add exit at the end of main

* address feedback from Oliver"," import urllib
 import yaml
 
 from oauth2client.client import GoogleCredentials
-from oauth2client.service_account import ServiceAccountCredentials
 from googleapiclient.discovery import build
 
 
 def main():
 
 credentials = GoogleCredentials.get_application_default()
 cloudbuild = build('cloudbuild', 'v1', credentials=credentials)
- print cloudbuild.projects().builds().cancel(
- projectId='oss-fuzz', id=build_id, body={}).execute()
+ print cloudbuild.projects().builds().cancel(projectId='oss-fuzz',
+ id=build_id,
+ body={}).execute()
 
 
 if __name__ == '__main__':
",29,3
"[infra] Add env variable to the DF collection GCB step (#1632). (#3250)

* [infra] Add env variable to the DF collection GCB step (#1632).

* format"," def get_build_steps(project_dir):
 })
 
 if sanitizer == 'dataflow' and fuzzing_engine == 'dataflow':
- dataflow_steps = dataflow_post_build_steps(name)
+ dataflow_steps = dataflow_post_build_steps(name, env)
 if dataflow_steps:
 build_steps.extend(dataflow_steps)
 else:
 def get_build_steps(project_dir):
 return build_steps
 
 
-def dataflow_post_build_steps(project_name):
+def dataflow_post_build_steps(project_name, env):
 steps = []
 download_corpora_step = build_lib.download_corpora_step(project_name)
 if not download_corpora_step:
 def dataflow_post_build_steps(project_name):
 steps = [download_corpora_step]
 steps.append({
 'name': 'gcr.io/oss-fuzz-base/base-runner',
+ 'env': env,
 'args': [
 'bash', '-c',
 ('for f in /corpus/*.zip; do unzip -q $f -d ${f%%.*}; done && '
",326,34
"[infra] Prioritize short files when collecting dataflow traces (#1632). (#3254)

* [infra] Prioritize short files when collecting dataflow traces (#1632).

* remove debug print

* rename files and sizes dict"," def collect_traces(binary, corpus_dir, dft_dir):
 'failed': 0,
 }
 
+ files_and_sizes = {}
 for f in _list_dir(corpus_dir):
 stats['total'] += 1
 size = os.path.getsize(f)
 def collect_traces(binary, corpus_dir, dft_dir):
 stats['long'] += 1
 print('Skipping large file ({size}b): {path}'.format(size=size, path=f))
 continue
+ files_and_sizes[f] = size
 
+ for f in sorted(files_and_sizes, key=files_and_sizes.get):
 output_path = os.path.join(dft_dir, _sha1(f))
 try:
 result = _run([binary, f, output_path], timeout=_timeout(size))
",97,24
"[infra] Add fuzzing_engines section for the project.yaml. (#3267)

* [infra] Add fuzzing_engines section for the project.yaml.

* Update presubmit.py

* Update presubmit.py

* Update presubmit.py"," class ProjectYamlChecker:
 SECTIONS_AND_CONSTANTS = {
 'sanitizers': {'address', 'none', 'memory', 'undefined', 'dataflow'},
 'architectures': {'i386', 'x86_64'},
- 'engines': {'afl', 'libfuzzer', 'honggfuzz', 'dataflow'}
+ 'fuzzing_engines': {'afl', 'libfuzzer', 'honggfuzz', 'dataflow'}
 }
 
 # Note: this list must be updated when we allow new sections.
 VALID_SECTION_NAMES = [
- 'homepage', 'primary_contact', 'auto_ccs', 'sanitizers', 'architectures',
- 'disabled', 'view_restrictions', 'coverage_extra_args', 'vendor_ccs'
+ 'architectures',
+ 'auto_ccs',
+ 'coverage_extra_args',
+ 'disabled',
+ 'fuzzing_engines',
+ 'homepage',
+ 'primary_contact',
+ 'sanitizers',
+ 'vendor_ccs',
+ 'view_restrictions',
 ]
 
 # Note that some projects like boost only have auto-ccs. However, forgetting
",195,63
[cifuzz][bisection] Make BuildData a namedtuple (#3282)," def main():
 help='The default is ""address"".')
 parser.add_argument('--architecture', default='x86_64')
 args = parser.parse_args()
- build_data = build_specified_commit.BuildData()
- build_data.project_name = args.project_name
- build_data.engine = args.engine
- build_data.sanitizer = args.sanitizer
- build_data.architecture = args.architecture
+
+ build_data = build_specified_commit.BuildData(project_name=args.project_name,
+ engine=args.engine,
+ sanitizer=args.sanitizer,
+ architecture=args.architecture)
+
 error_sha = bisect(args.commit_old, args.commit_new, args.testcase,
 args.fuzz_target, build_data)
 if not error_sha:
",109,10
[Infra] Update print statements (#3305)," seperated by a space.
 
 """"""
 import argparse
+import logging
 import os
 import subprocess
 
 def main():
 if args.repo_name and check_for_repo_name(full_path, args.repo_name):
 print('Detected repo:', get_repo(full_path), full_path)
 return
- print('No git repos with specific commit: %s found in %s' %
- (args.example_commit, src_dir))
+ logging.error('No git repos with specific commit: %s found in %s',
+ args.example_commit, src_dir)
 
 
 def get_repo(repo_path):
",80,23
"[infra] Introduce ""language"" attribute in the project.yaml (#3297). (#3299)

* [infra] Introduce ""language"" attribute in the project.yaml (#3297).

* follow up

* enable the attribute for more projects

* trailing newline"," def load_project_yaml(project_dir):
 project_yaml.setdefault('run_tests', True)
 project_yaml.setdefault('coverage_extra_args', '')
 project_yaml.setdefault('labels', {})
+ project_yaml.setdefault('language', 'cpp')
 return project_yaml
 
 
",327,34
"[CIFuzz] Prevent action from failing option (#3315)

* Adding opt to workflow to prevent failures

* fclose bug

* Undoing double negitive

* Undoing double negitive

* Undoing double negitive

* Syntax and formatting

* Olivers comments

* Presubmit fix

* Trying boolean argument

* cleaning

* cleaning fuzz disassembles

* Maxs comments pt.2

* Updating dry_run parse

* Comments added

* Formatting

* Olivers comments"," class BuildFuzzersIntegrationTest(unittest.TestCase):
 cifuzz.build_fuzzers(EXAMPLE_PROJECT,
 'oss-fuzz',
 tmp_dir,
- pr_ref='refs/pull/3310/merge'))
+ pr_ref='refs/pull/1757/merge'))
 self.assertTrue(os.path.exists(os.path.join(out_path, 'do_stuff_fuzzer')))
 
 def test_invalid_pull_request(self):
",111,11
[CIFuzz] Add seed and len control to fuzzer arguments (#3321)," import subprocess
 import sys
 
 # pylint: disable=wrong-import-position
+# pylint: disable=import-error
 sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
 import utils
 
 logging.basicConfig(
 format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
 level=logging.DEBUG)
 
+LIBFUZZER_OPTIONS = '-seed=1337 -len_control=0'
+
 
 class FuzzTarget:
 """"""A class to manage a single fuzz target.
 class FuzzTarget:
 command += [
 '-e', 'FUZZING_ENGINE=libfuzzer', '-e', 'SANITIZER=address', '-e',
 'RUN_FUZZER_MODE=interactive', 'gcr.io/oss-fuzz-base/base-runner',
- 'bash', '-c', 'run_fuzzer {0}'.format(self.target_name)
+ 'bash', '-c', 'run_fuzzer {fuzz_target} {options}'.format(
+ fuzz_target=self.target_name, options=LIBFUZZER_OPTIONS)
 ]
 logging.info('Running command: %s', ' '.join(command))
 process = subprocess.Popen(command,
",64,7
[Infra] Update execute function in utils.py (#3319)," def detect_main_repo(project_name, repo_name=None, commit=None):
 command_to_run.extend(['--repo_name', repo_name])
 else:
 command_to_run.extend(['--example_commit', commit])
- out, _ = utils.execute(command_to_run)
+ out, _, _ = utils.execute(command_to_run)
 match = re.search(r'\bDetected repo: ([^ ]+) ([^ ]+)', out.rstrip())
 if match and match.group(1) and match.group(2):
 return match.group(1), match.group(2)
",51,11
[infra] Generate full coverage JSONs for dataflow enabled targets (#1632). (#3325)," def get_build_steps(project_dir):
 '*' * 80).format(name=name)
 
 # Unpack the corpus and run coverage script.
+ coverage_env = env + [
+ 'HTTP_PORT=',
+ 'COVERAGE_EXTRA_ARGS=%s' % project_yaml['coverage_extra_args'].strip(),
+ ]
+ if 'dataflow' in project_yaml['fuzzing_engines']:
+ coverage_env.append('FULL_SUMMARY_PER_TARGET=1')
+
 build_steps.append({
- 'name':
- 'gcr.io/oss-fuzz-base/base-runner',
- 'env':
- env + [
- 'HTTP_PORT=',
- 'COVERAGE_EXTRA_ARGS=%s' %
- project_yaml['coverage_extra_args'].strip()
- ],
+ 'name': 'gcr.io/oss-fuzz-base/base-runner',
+ 'env': coverage_env,
 'args': [
 'bash', '-c',
 ('for f in /corpus/*.zip; do unzip -q $f -d ${f%%.*} || ('
",225,11
[infra] Make travis_build presubmit clean (#3334)," from __future__ import print_function
 
 import os
 import re
+import sys
 import subprocess
 import yaml
 
 def build_project(project):
 variables (TRAVIS_SANITIZER, TRAVIS_ENGINE, and TRAVIS_ARCHITECTURE).""""""
 root = get_oss_fuzz_root()
 project_yaml_path = os.path.join(root, 'projects', project, 'project.yaml')
- with open(project_yaml_path) as fp:
- project_yaml = yaml.safe_load(fp)
+ with open(project_yaml_path) as file_handle:
+ project_yaml = yaml.safe_load(file_handle)
 
 if project_yaml.get('disabled', False):
 print('Project {0} is disabled, skipping build.'.format(project))
 def build_project(project):
 
 
 def main():
+ """"""Build modified projects on travis.""""""
 projects = get_modified_buildable_projects()
 failed_projects = []
 for project in projects:
 def main():
 
 if failed_projects:
 print('Failed projects:', ' '.join(failed_projects))
- exit(1)
+ return 1
+
+ return 0
 
 
 if __name__ == '__main__':
- main()
+ sys.exit(main())
",87,19
"[infra] Travis: rely on the presence of Dockerfile to identify buildable projects. (#3328)

* [infra] Travis: rely on the presese of Dockerfile to identify buildable projects.

* fix the comment"," def get_modified_buildable_projects():
 projects_regex = '.*projects/(?P<name>.*)/.*\n'
 modified_projects = set(re.findall(projects_regex, output))
 projects_dir = os.path.join(get_oss_fuzz_root(), 'projects')
- # Filter out projects without build.sh files since new projects and reverted
+ # Filter out projects without Dockerfile files since new projects and reverted
 # projects frequently don't have them. In these cases we don't want Travis's
 # builds to fail.
 modified_buildable_projects = []
 for project in modified_projects:
- if not os.path.exists(os.path.join(projects_dir, project, 'build.sh')):
- print('Project {0} does not have a build.sh. skipping build.'.format(
+ if not os.path.exists(os.path.join(projects_dir, project, 'Dockerfile')):
+ print('Project {0} does not have Dockerfile. skipping build.'.format(
 project))
 continue
 modified_buildable_projects.append(project)
",87,19
Move detect_repo.py script into /opt (#3337)," def detect_main_repo(project_name, repo_name=None, commit=None):
 docker_image_name = 'gcr.io/oss-fuzz/' + project_name
 command_to_run = [
 'docker', 'run', '--rm', '-t', docker_image_name, 'python3',
- os.path.join('/src', 'detect_repo.py')
+ os.path.join('/opt', 'cifuzz', 'detect_repo.py')
 ]
 if repo_name:
 command_to_run.extend(['--repo_name', repo_name])
",51,11
"Improves binutils fuzz target (#3343)

Support disassembly of testcases containing more than one
 insn"," int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) {
 struct disassemble_info disasm_info;
 SFILE s;
 
- if (Size < 10) {
+ if (Size < 10 || Size > 16394) {
 // 10 bytes for options
+ // 16394 limit code to prevent timeouts
 return 0;
 }
 
 int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) {
 disassembler_ftype disasfunc = disassembler(disasm_info.arch, 0, disasm_info.mach, NULL);
 if (disasfunc != NULL) {
 disassemble_init_for_target(&disasm_info);
- disasfunc(0x1000, &disasm_info);
+ while (1) {
+ int octets = disasfunc(0x1000, &disasm_info);
+ if (octets < 0)
+ break;
+ if (disasm_info.buffer_length <= (size_t) octets)
+ break;
+ disasm_info.buffer += octets;
+ disasm_info.buffer_vma += octets / disasm_info.octets_per_byte;
+ disasm_info.buffer_length -= octets;
+ }
 disassemble_free_target(&disasm_info);
 }
 }
",66,10
[CIFuzz] Fix .strip bug. (#3349)," class BisectIntegrationTests(unittest.TestCase):
 def test_bisect(self):
 """"""Test the bisect method on example projects.""""""
 for test_repo in test_repos.TEST_REPOS:
- build_data = build_specified_commit.BuildData(
- project_name=test_repo.project_name,
- engine='libfuzzer',
- sanitizer='address',
- architecture='x86_64')
- error_sha = bisector.bisect(test_repo.old_commit, test_repo.new_commit,
- test_repo.test_case_path,
- test_repo.fuzz_target, build_data)
- self.assertEqual(error_sha, test_repo.intro_commit)
+ if test_repo.new_commit:
+ build_data = build_specified_commit.BuildData(
+ project_name=test_repo.project_name,
+ engine='libfuzzer',
+ sanitizer='address',
+ architecture='x86_64')
+ error_sha = bisector.bisect(test_repo.old_commit, test_repo.new_commit,
+ test_repo.test_case_path,
+ test_repo.fuzz_target, build_data)
+ self.assertEqual(error_sha, test_repo.intro_commit)
 
 
 if __name__ == '__main__':
",41,4
"[CIFuzz] Separate build and run actions (#3336)

* Separating actions into build and run

* Formatting

* Formatting

* Removing project-name from run action

* Jonathan comments

* Maxs comments pt.1

* Updating example_main.yml

* Switch 1 0 to true false

* Add base Dockerfile for CIFuzz

* Adding license to dockerfile"," class FuzzTarget:
 """"""A class to manage a single fuzz target.
 
 Attributes:
- project_name: The name of the OSS-Fuzz project the target is associated.
 target_name: The name of the fuzz target.
 duration: The length of time in seconds that the target should run.
 target_path: The location of the fuzz target binary.
 """"""
 
- def __init__(self, project_name, target_path, duration, out_dir):
+ def __init__(self, target_path, duration, out_dir):
 """"""Represents a single fuzz target.
 
 Args:
- project_name: The OSS-Fuzz project of this target.
 target_path: The location of the fuzz target binary.
 duration: The length of time in seconds the target should run.
 out_dir: The location of where the output from crashes should be stored.
 """"""
 self.target_name = os.path.basename(target_path)
 self.duration = duration
- self.project_name = project_name
 self.target_path = target_path
 self.out_dir = out_dir
 
",62,7
"[CIFuzz] Go support (#3352)

* Add go support to detecting the main repo

* Go support test update

* Format

* Format

* Removing debug statment

* Format"," class BuildImageIntegrationTests(unittest.TestCase):
 repo_origin, repo_name = build_specified_commit.detect_main_repo(
 example_repo.project_name, repo_name=example_repo.git_repo_name)
 self.assertEqual(repo_origin, example_repo.git_url)
- self.assertEqual(repo_name,
- os.path.join('/src', example_repo.oss_repo_name))
+ self.assertEqual(
+ repo_name,
+ os.path.join(example_repo.image_location, example_repo.oss_repo_name))
 
 repo_origin, repo_name = build_specified_commit.detect_main_repo(
 test_repos.INVALID_REPO.project_name,
",70,6
"[infra] Fix broken batching in the corpora download helper (#3351). (#3353)

* [infra] Fix broken batching in the corpora download helper (#3351).

* one more"," def get_build_steps(project_dir):
 ],
 })
 
- download_corpora_step = build_lib.download_corpora_step(project_name)
- if not download_corpora_step:
+ download_corpora_steps = build_lib.download_corpora_steps(project_name)
+ if not download_corpora_steps:
 skip_build(""Skipping code coverage build for %s.\n"" % project_name)
 
- build_steps.append(download_corpora_step)
+ build_steps.extend(download_corpora_steps)
 
 failure_msg = ('*' * 80 + '\nCode coverage report generation failed.\n'
 'To reproduce, run:\n'
",225,11
Fixes target for binutils project (#3357)," static int objdump_sprintf (void *vf, const char *format, ...)
 va_start (args, format);
 if (f->pos >= MAX_TEXT_SIZE){
 printf(""buffer needs more space\n"");
+ //reset
+ f->pos=0;
 return 0;
 }
 n = vsnprintf (f->buffer + f->pos, MAX_TEXT_SIZE - f->pos, format, args);
 //vfprintf(stdout, format, args);
 va_end (args);
 f->pos += n;
-
+ //reset to keep just one line
+ if (f->pos != 0 && f->buffer[f->pos - 1] == '\n')
+ f->pos = 0;
 return n;
 }
 
 int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) {
 if (disasfunc != NULL) {
 disassemble_init_for_target(&disasm_info);
 while (1) {
- int octets = disasfunc(0x1000, &disasm_info);
- if (octets < 0)
+ int octets = disasfunc(disasm_info.buffer_vma, &disasm_info);
+ if (octets < (int) disasm_info.octets_per_byte)
 break;
 if (disasm_info.buffer_length <= (size_t) octets)
 break;
",69,12
Fix overflow in binutils fuzz target (#3363)," static int objdump_sprintf (void *vf, const char *format, ...)
 va_end (args);
 f->pos += n;
 //reset to keep just one line
- if (f->pos != 0 && f->buffer[f->pos - 1] == '\n')
+ if (f->pos != 0 && f->buffer[f->pos - 1] == '\n' && f->pos <= MAX_TEXT_SIZE)
 f->pos = 0;
 return n;
 }
",69,13
"Revert ""Fix overflow in binutils fuzz target (#3363)"" (#3364)

This reverts commit 3f808990afc5cd988f08012da56b37eabd16cc37."," static int objdump_sprintf (void *vf, const char *format, ...)
 va_end (args);
 f->pos += n;
 //reset to keep just one line
- if (f->pos != 0 && f->buffer[f->pos - 1] == '\n' && f->pos <= MAX_TEXT_SIZE)
+ if (f->pos != 0 && f->buffer[f->pos - 1] == '\n')
 f->pos = 0;
 return n;
 }
",69,12
[CIFuzz] Add parse fuzzer output functionality (#3342)," def main():
 # If the file does not exist, the action will crash attempting to upload it.
 # The dry run needs this file because it is set to upload a test case both
 # on successful runs and on failures.
- out_dir = os.path.join(workspace, 'out')
+ out_dir = os.path.join(workspace, 'out', 'bug_report')
 os.makedirs(out_dir, exist_ok=True)
- file_handle = open(os.path.join(out_dir, 'testcase'), 'w')
- file_handle.write('No bugs detected.')
- file_handle.close()
 
 # Sets the default return code on error to success.
 error_code = 0
",32,6
"Fix binutils fuzzer

Don't try to reset the line buffer pos by detecting '\n' output as
that's ineffective. Reset before each disasfunc call instead."," static int objdump_sprintf (void *vf, const char *format, ...)
 //vfprintf(stdout, format, args);
 va_end (args);
 f->pos += n;
- //reset to keep just one line
- if (f->pos != 0 && f->buffer[f->pos - 1] == '\n')
- f->pos = 0;
 return n;
 }
 
 int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) {
 if (disasfunc != NULL) {
 disassemble_init_for_target(&disasm_info);
 while (1) {
+ s.pos = 0;
 int octets = disasfunc(disasm_info.buffer_vma, &disasm_info);
 if (octets < (int) disasm_info.octets_per_byte)
 break;
",68,10
[CIFuzz] Change 'bug_report' directory to 'artifacts'. (#3369)," def main():
 # If the file does not exist, the action will crash attempting to upload it.
 # The dry run needs this file because it is set to upload a test case both
 # on successful runs and on failures.
- out_dir = os.path.join(workspace, 'out', 'bug_report')
+ out_dir = os.path.join(workspace, 'out', 'artifacts')
 os.makedirs(out_dir, exist_ok=True)
 
 # Sets the default return code on error to success.
",32,6
"[infra] Upload latest.version metadata file for most recent build. (#3379)

* [infra] Upload latest.version metadata file for most recent build.

* move common functionality into build_lib

* pass content_type to get_signed_url

* format"," def download_corpora_steps(project_name):
 })
 
 return steps
+
+
+def http_upload_step(data, signed_url, content_type):
+ """"""Returns a GCB step to upload data to the given URL via GCS HTTP API.""""""
+ step = {
+ 'name':
+ 'gcr.io/cloud-builders/curl',
+ 'args': [
+ '-H',
+ 'Content-Type: ' + content_type,
+ '-X',
+ 'PUT',
+ '-d',
+ data,
+ signed_url,
+ ],
+ }
+ return step
",116,11
[infra] Use wildcard in gsutil cp command as it lacks -T option. (#3396)," def get_build_steps(project_dir):
 '-m',
 'cp',
 '-r',
- os.path.join(out, 'report'),
+ os.path.join(out, 'report', '*'),
 upload_report_url,
 ],
 })
 def get_build_steps(project_dir):
 '-m',
 'cp',
 '-r',
- os.path.join(out, 'fuzzer_stats'),
+ os.path.join(out, 'fuzzer_stats', '*'),
 upload_fuzzer_stats_url,
 ],
 })
 def get_build_steps(project_dir):
 '-m',
 'cp',
 '-r',
- os.path.join(out, 'logs'),
+ os.path.join(out, 'logs', '*'),
 UPLOAD_URL_FORMAT.format(project=project_name,
 type='logs',
 date=report_date),
",216,11
"[infra] Perform ""gsutil rm -rf"" if we need to overwrite coverage data. (#3404)

* [infra] Perform ""gsutil rm -rf"" if we need to overwrite coverage data.

* format"," def http_upload_step(data, signed_url, content_type):
 ],
 }
 return step
+
+
+def gsutil_rm_rf_step(url):
+ """"""Returns a GCB step to recursively delete the object with given GCS url.""""""
+ step = {
+ 'name': 'gcr.io/cloud-builders/gsutil',
+ 'args': [
+ '-m',
+ 'rm',
+ '-rf',
+ url,
+ ],
+ }
+ return step
",127,12
"[CIFuzz] log bug fix (#3407)

* Fixing log bug

* Fixing log bug"," class FuzzTarget:
 err_str = err.decode('ascii')
 test_case = self.get_test_case(err_str)
 if not test_case:
- logging.error('No test case found in stack trace.', file=sys.stderr)
+ logging.error('No test case found in stack trace. %s.', sys.stderr)
 return None, None
 if self.is_reproducible(test_case):
 return test_case, err_str
",78,11
"[infra] GSB: ignore failing ""gsutil rm -rf"" step. (#3412)"," def gsutil_rm_rf_step(url):
 """"""Returns a GCB step to recursively delete the object with given GCS url.""""""
 step = {
 'name': 'gcr.io/cloud-builders/gsutil',
+ 'entrypoint': 'sh',
 'args': [
- '-m',
- 'rm',
- '-rf',
- url,
+ '-c',
+ 'gsutil -m rm -rf %s || exit 0' % url,
 ],
 }
 return step
",126,12
"[CIFuzz] Check crash on most recent OSS-Fuzz build (#3385)

Adds functionality to check if a crash exists in the most recent OSS-Fuzz build. This is necessary to determine if a crash was introduced in the current pull request or existed in the project already. Crashes that are surfaced to the user will be both reproducible and novel to the OSS-Fuzz project."," def main():
 the directory: ${GITHUB_WORKSPACE}/out
 
 Required environment variables:
- PROJECT_NAME: The name of OSS-Fuzz project.
+ OSS_FUZZ_PROJECT_NAME: The name of OSS-Fuzz project.
 GITHUB_REPOSITORY: The name of the Github repo that called this script.
 GITHUB_SHA: The commit SHA that triggered this script.
 GITHUB_REF: The pull request reference that triggered this script.
 def main():
 Returns:
 0 on success or 1 on Failure.
 """"""
- oss_fuzz_project_name = os.environ.get('PROJECT_NAME')
+ oss_fuzz_project_name = os.environ.get('OSS_FUZZ_PROJECT_NAME')
 github_repo_name = os.path.basename(os.environ.get('GITHUB_REPOSITORY'))
 pr_ref = os.environ.get('GITHUB_REF')
 commit_sha = os.environ.get('GITHUB_SHA')
",37,7
"[infra] Loose the limits for dataflow traces collection (#1632). (#3411)

* [infra] Loose the limits for dataflow traces collection (#1632).

* format"," def dataflow_post_build_steps(project_name, env):
 return None
 
 steps.append({
- 'name': 'gcr.io/oss-fuzz-base/base-runner',
- 'env': env,
+ 'name':
+ 'gcr.io/oss-fuzz-base/base-runner',
+ 'env':
+ env + [
+ 'COLLECT_DFT_TIMEOUT=2h',
+ 'DFT_FILE_SIZE_LIMIT=65535',
+ 'DFT_MIN_TIMEOUT=2.0',
+ 'DFT_TIMEOUT_RANGE=6.0',
+ ],
 'args': [
 'bash', '-c',
 ('for f in /corpus/*.zip; do unzip -q $f -d ${f%%.*}; done && '
",342,34
"[Infra] Add tests to presubmit (#3405)

Adds unit/integration tests to travis presubmit."," import test_repos
 TEST_DIR_PATH = os.path.dirname(os.path.realpath(__file__))
 
 
+@unittest.skip('Test is too long to be run with presubmit.')
 class BisectIntegrationTests(unittest.TestCase):
 """"""Class to test the functionality of bisection method.""""""
 
",42,4
"[CIFuzz] Use backup corpus for fuzzing (#3380)

This allows fuzzing using fuzz target's backup corpora. It will make fuzzing more efficient for targets that have a backup OSS-Fuzz corpus avaliable to the public. It will not effect targets that don't have backups."," class RunFuzzersIntegrationTest(unittest.TestCase):
 
 def test_new_bug_found(self):
 """"""Test run_fuzzers with a valid build.""""""
- # Setting the first return value to True, then the second to False to
+ # Set the first return value to True, then the second to False to
 # emulate a bug existing in the current PR but not on the downloaded
 # OSS-Fuzz build.
 with unittest.mock.patch.object(fuzz_target.FuzzTarget,
",155,18
"[CIFuzz] Check fuzzers (#3419)

Checks that the fuzzer build was a success in the build action."," def main():
 logging.error('Error building fuzzers for project %s with pull request %s.',
 oss_fuzz_project_name, pr_ref)
 return error_code
- return 0
+ out_dir = os.path.join(workspace, 'out')
+ if cifuzz.check_fuzzer_build(out_dir):
+ return 0
+ return 1
 
 
 if __name__ == '__main__':
",40,8
"[ghostscript] Add place holder program name. (#3438)

The first element in the argument array to gsapi_new_instance()
is ignored since it normally is the program name. This means that
the commit introducing the ""-K"" argument to limit memory usage did
not have its intended effect since the ""-K"" argument was ignored.
Moreover, prior to that the resolution argument ""-r200x200"" was
being unintentionally ignored. By introducing a place holder program
name all arguments are taken into account and the reader is reminded
that the first argument is the program name."," static int gs_to_raster_fuzz(const unsigned char *buf, size_t size)
 
 /* Mostly stolen from cups-filters gstoraster. */
 char *args[] = {
+""gs"",
 ""-K1048576"",
 ""-r200x200"",
 ""-dMediaPosition=1"",
",72,10
"[Infra] Add git diff to repo manager class (#3427)

This adds the functionality of git diff --name-only to the repo manager module. This functionality will be used for the affected fuzzer feature of CIFuzz. Associated tests have also been added."," a python API and manage the current state of the git repo.
 r_man = RepoManager('https://github.com/google/oss-fuzz.git')
 r_man.checkout('5668cc422c2c92d38a370545d3591039fb5bb8d4')
 """"""
+import logging
 import os
 import shutil
 
 class RepoManager:
 self.repo_dir)
 return not err_code
 
+ def get_git_diff(self):
+ """"""Gets a list of files that have changed from the repo head.
+
+ Returns:
+ A list of changed file paths or None on Error.
+ """"""
+ self.fetch_unshallow()
+ out, err_msg, err_code = utils.execute(
+ ['git', 'diff', '--name-only', 'origin...'], self.repo_dir)
+ if err_code:
+ logging.error('Git diff failed with error message %s.', err_msg)
+ return None
+ if not out:
+ logging.error('No diff was found.')
+ return None
+ return [line for line in out.splitlines() if line]
+
 def get_current_commit(self):
 """"""Gets the current commit SHA of the repo.
 
",108,30
"[CIFuzz] Adding dry_run mode to check_build (#3444)

Prevents crash from surfacing when dry run mode is enabled and check fuzzers fails."," def main():
 dry_run = (os.environ.get('DRY_RUN').lower() == 'true')
 
 # The default return code when an error occurs.
- error_code = 1
+ returncode = 1
 if dry_run:
 # A testcase file is required in order for CIFuzz to surface bugs.
 # If the file does not exist, the action will crash attempting to upload it.
 def main():
 os.makedirs(out_dir, exist_ok=True)
 
 # Sets the default return code on error to success.
- error_code = 0
+ returncode = 0
 
 if not workspace:
 logging.error('This script needs to be run in the Github action context.')
- return error_code
+ return returncode
 # Run the specified project's fuzzers from the build.
 run_status, bug_found = cifuzz.run_fuzzers(fuzz_seconds, workspace,
 oss_fuzz_project_name)
 if not run_status:
 logging.error('Error occured while running in workspace %s.', workspace)
- return error_code
+ return returncode
 if bug_found:
 logging.info('Bug found.')
 if not dry_run:
",34,6
"[gnupg] Adds sqlite as gnupg dependency (#3223)

* Adds sqlie as gnupg dependency

* downloads latest sqlite for gnupg

* Adds lsqlite3 to gnupg fuzz targets

* remove sqlite package for gnupg

* Gnupg fuzz targets need INCLUDED_BY_MAIN_MODULE

* Remove sqlite

* Add license to gnupg fuzz targets","
+/* Copyright 2020 Google Inc.
+
+Licensed under the Apache License, Version 2.0 (the ""License"");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+ http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an ""AS IS"" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
 #include <stdint.h>
 #include <stddef.h>
 #include <stdlib.h>

 #include <stdbool.h>
 #include <ftw.h>
 
+#define INCLUDED_BY_MAIN_MODULE 1
 #include ""config.h""
 #include ""gpg.h""
 #include ""../common/types.h""
",124,19
"[infra] Presubmit fix - test (#3443)

Fixes issue that presubmit test was not returning failure even when a test failed."," class IsFuzzTargetLocalUnitTest(unittest.TestCase):
 """"""Checks is_fuzz_target_local function with a valid filepath.""""""
 
 is_local = utils.is_fuzz_target_local(
- os.path.join(TEST_OUT_DIR, 'do_stuff_fuzzer'))
+ os.path.join(TEST_OUT_DIR, 'example_crash_fuzzer'))
 self.assertTrue(is_local)
 is_local = utils.is_fuzz_target_local(TEST_OUT_DIR)
 self.assertFalse(is_local)
 class GetFuzzTargetsUnitTest(unittest.TestCase):
 def test_valid_filepath(self):
 """"""Tests that fuzz targets can be retrieved once the fuzzers are built.""""""
 fuzz_targets = utils.get_fuzz_targets(TEST_OUT_DIR)
+ crash_fuzzer_path = os.path.join(TEST_OUT_DIR, 'example_crash_fuzzer')
+ nocrash_fuzzer_path = os.path.join(TEST_OUT_DIR, 'example_nocrash_fuzzer')
 self.assertCountEqual(fuzz_targets,
- [os.path.join(TEST_OUT_DIR, 'do_stuff_fuzzer')])
+ [crash_fuzzer_path, nocrash_fuzzer_path])
 fuzz_targets = utils.get_fuzz_targets(
 os.path.join(helper.OSSFUZZ_DIR, 'infra'))
 self.assertFalse(fuzz_targets)
",74,6
"[infra] helper: Add possibility to pass source directory to gdb/shell commands to ease local debugging (#3465)

Signed-off-by: Jakub Jelen <jjelen@redhat.com>"," def main(): # pylint: disable=too-many-branches,too-many-return-statements,too-
 shell_parser = subparsers.add_parser(
 'shell', help='Run /bin/bash within the builder container.')
 shell_parser.add_argument('project_name', help='name of the project')
+ shell_parser.add_argument('source_path',
+ help='path of local source',
+ nargs='?')
 _add_architecture_args(shell_parser)
 _add_engine_args(shell_parser)
 _add_sanitizer_args(shell_parser)
 def shell(args):
 image_project = 'oss-fuzz'
 out_dir = _get_output_dir(args.project_name)
 
- run_args = _env_to_docker_args(env) + [
+ run_args = _env_to_docker_args(env)
+ if args.source_path:
+ run_args.extend([
+ '-v',
+ '%s:%s' % (_get_absolute_path(args.source_path), '/src'),
+ ])
+
+ run_args.extend([
 '-v',
 '%s:/out' % out_dir, '-v',
 '%s:/work' % _get_work_dir(args.project_name), '-t',
 'gcr.io/%s/%s' % (image_project, args.project_name), '/bin/bash'
- ]
+ ])
 
 docker_run(run_args)
 return 0
",656,114
"[infra] Change language attribute from ""cpp"" to ""c++"" in build scripts. (#3493)

* [infra] Change language attribute from ""cpp"" to ""c++"" in coverage job runner.

Should've done this in https://github.com/google/oss-fuzz/pull/3477. Good news is that nothing failed, the coverage job was just skipped for pretty much all projects.

* also remove default value from build_project script"," LATEST_REPORT_INFO_CONTENT_TYPE = 'application/json'
 UPLOAD_URL_FORMAT = 'gs://' + COVERAGE_BUCKET_NAME + '/{project}/{type}/{date}'
 
 # Languages from project.yaml that have code coverage support.
-LANGUAGES_WITH_COVERAGE_SUPPORT = ['c', 'cpp']
+LANGUAGES_WITH_COVERAGE_SUPPORT = ['c', 'c++']
 
 
 def skip_build(message):
",220,11
"Affected fuzzer fix (#3494)

Fixing json decode error with affected fuzzer functionality."," def get_json_from_url(url):
 logging.error('HTTP error with url %s.', url)
 return None
 try:
- result_json = json.load(response)
- except ValueError as excp:
+ # read().decode() fixes compatability issue with urllib response object.
+ result_json = json.loads(response.read().decode())
+ except (ValueError, TypeError, json.JSONDecodeError) as excp:
 logging.error('Loading json from url %s failed with: %s.', url, str(excp))
 return None
 return result_json
",242,30
"[CIFuzz] Dynamic fuzzer scheduling (#3453)

Allocates time for fuzzers based on amount of fuzzing time left. This is beneficial when a fuzzer fails early in its allotted time because of a reproducible OSS-Fuzz bug. It will then give the remaining portion of its allotted time to the following fuzzers."," class RunFuzzersIntegrationTest(unittest.TestCase):
 
 def test_invalid_out_dir(self):
 """"""Tests run_fuzzers with an invalid out directory.""""""
- run_success, bug_found = cifuzz.run_fuzzers(100, 'not/a/valid/path',
+ run_success, bug_found = cifuzz.run_fuzzers(10, 'not/a/valid/path',
 EXAMPLE_PROJECT)
 self.assertFalse(run_success)
 self.assertFalse(bug_found)
",301,36
"[CIFuzz] Logging updates (#3503)

Provide some simple logging updates to assert that affected fuzzers is running correctly.
Also prevents the clouding of longs when the reproduction script runs."," def remove_unaffected_fuzzers(project_name, out_dir, files_changed,
 logging.error('Could not download latest coverage report.')
 return
 affected_fuzzers = []
+ logging.info('Files changed in PR:\n%s', '\n'.join(files_changed))
 for fuzzer in fuzzer_paths:
+ fuzzer_name = os.path.basename(fuzzer)
 covered_files = get_files_covered_by_target(latest_cov_report_info,
- os.path.basename(fuzzer),
- src_in_docker)
+ fuzzer_name, src_in_docker)
+ logging.info('Fuzzer %s has affected files:\n%s', fuzzer_name,
+ '\n'.join(covered_files))
 if not covered_files:
 # Assume a fuzzer is affected if we can't get its coverage from OSS-Fuzz.
 affected_fuzzers.append(os.path.basename(fuzzer))
",294,39
"OSSFUZZ to OSS_FUZZ (#3535)

Changing the helper variable OSSFUZZ_DIR name to OSS_FUZZ_DIR as per request in #3516."," import subprocess
 import sys
 import templates
 
-OSSFUZZ_DIR = os.path.dirname(os.path.dirname(os.path.realpath(__file__)))
-BUILD_DIR = os.path.join(OSSFUZZ_DIR, 'build')
+OSS_FUZZ_DIR = os.path.dirname(os.path.dirname(os.path.realpath(__file__)))
+BUILD_DIR = os.path.join(OSS_FUZZ_DIR, 'build')
 
 BASE_IMAGES = [
 'gcr.io/oss-fuzz-base/base-image',
 CORPUS_BACKUP_URL_FORMAT = (
 
 def main(): # pylint: disable=too-many-branches,too-many-return-statements,too-many-statements
 """"""Get subcommand from program arguments and do it.""""""
- os.chdir(OSSFUZZ_DIR)
+ os.chdir(OSS_FUZZ_DIR)
 if not os.path.exists(BUILD_DIR):
 os.mkdir(BUILD_DIR)
 
 def _get_command_string(command):
 
 def _get_project_dir(project_name):
 """"""Returns path to the project.""""""
- return os.path.join(OSSFUZZ_DIR, 'projects', project_name)
+ return os.path.join(OSS_FUZZ_DIR, 'projects', project_name)
 
 
 def get_dockerfile_path(project_name):
",656,114
"Fix behavior in quickjs fuzz target (#3543)

* Fix behavior in quickjs fuzz target

* Includes stdbool.h in quickjs fuzz target

* Right include","
 */
 
 #include ""quickjs-libc.h""
+#include ""cutils.h""
 
 #include <stdint.h>
 #include <stdio.h>
 int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) {
 return 0;
 }
 obj = JS_ReadObject(ctx, bytecode, bytecode_size, JS_READ_OBJ_BYTECODE);
- JS_FreeValue(ctx, obj);
+ if (JS_IsException(obj)) {
+ return 0;
+ }
 nbinterrupts = 0;
- //this needs patching so as not to exit on JS exception
- js_std_eval_binary(ctx, bytecode, bytecode_size, 0);
+ /* this is based on
+ * js_std_eval_binary(ctx, bytecode, bytecode_size, 0);
+ * modified so as not to exit on JS exception
+ */
+ JSValue val;
+ if (JS_VALUE_GET_TAG(obj) == JS_TAG_MODULE) {
+ if (JS_ResolveModule(ctx, obj) < 0) {
+ JS_FreeValue(ctx, obj);
+ return 0;
+ }
+ js_module_set_import_meta(ctx, obj, FALSE, TRUE);
+ }
+ val = JS_EvalFunction(ctx, obj);
+ if (JS_IsException(val)) {
+ js_std_dump_error(ctx);
+ return 0;
+ }
+ JS_FreeValue(ctx, val);
 js_std_loop(ctx);
 js_free(ctx, bytecode);
 }
",73,11
"Remove walk from utils.py (#3561)

Removing useless os.walk from utils.py."," def get_fuzz_targets(path):
 if not os.path.exists(path):
 return []
 fuzz_target_paths = []
- for root, _, _ in os.walk(path):
- for filename in os.listdir(path):
- file_path = os.path.join(root, filename)
+ for root, _, fuzzers in os.walk(path):
+ for fuzzer in fuzzers:
+ file_path = os.path.join(root, fuzzer)
 if is_fuzz_target_local(file_path):
 fuzz_target_paths.append(file_path)
 
",60,22
"Added xpdf project. (#3565)

* Added xpdf project.

* Tried linking with cxx.

* Since the executables build are not needed for the fuzzer build to succeed we can ignore the case where some test-apps are not build on the oss-fuzz platform.

* Ignore errors that dont impact the fuzzers.

* Updated the project file with language field.","
+/* Copyright 2020 Google Inc.
+
+Licensed under the Apache License, Version 2.0 (the ""License"");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+ http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an ""AS IS"" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+#include <stdlib.h>
+#include <string.h>
+#include <stdint.h>
+#include ""Zoox.h""
+
+extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
+ char *ss = (char*)malloc(size+1);
+ memcpy(ss, data, size);
+ ss[size] = '\0';
+
+ ZxDoc Z1;
+ ZxDoc *new_doc = Z1.loadMem(ss, size);
+ if (new_doc != NULL)
+ delete new_doc;
+
+ free(ss);
+
+ return 0; 
+}
",15,2
Fix incorrect variable name in bisector.py (#3581)," This is done with the following steps:
 
 Typical usage example:
 python3 infra/bisector.py
- --commit_old 1e403e9259a1abedf108ab86f711ba52c907226d
- --commit_new f79be4f2330f4b89ea2f42e1c44ca998c59a0c0f
+ --old_commit 1e403e9259a1abedf108ab86f711ba52c907226d
+ --new_commit f79be4f2330f4b89ea2f42e1c44ca998c59a0c0f
 --fuzz_target rules_fuzzer
 --project_name yara
 --testcase infra/yara_testcase
 def main():
 error_sha = bisect(args.old_commit, args.new_commit, args.test_case_path,
 args.fuzz_target, build_data)
 if not error_sha:
- logging.error('No error was found in commit range %s:%s', args.commit_old,
- args.commit_new)
+ logging.error('No error was found in commit range %s:%s', args.old_commit,
+ args.new_commit)
 return 1
- if error_sha == args.commit_old:
+ if error_sha == args.old_commit:
 logging.error(
 'Bisection Error: Both the first and the last commits in'
 'the given range have the same behavior, bisection is not possible. ')
",110,9
"[jbig2dec] Limit allocations to 1Gbyte. (#3583)

Apparently the maximum memory usage is 2.5Gbyte so a limit of 3Gbyte
is to liberal. Set limit to 1Gbyte to make sure that any extra memory
used by the fuzzer is allowed. 1Gbyte ought to be enough for most real
world images decoded by jbig2dec.","
 #define ALIGNMENT 16
 #define MBYTE (1024 * 1024)
 #define GBYTE (1024 * MBYTE)
-#define MAX_ALLOCATION (3 * GBYTE)
+#define MAX_ALLOCATION (1 * GBYTE)
 
 static uint64_t total = 0;
 static uint64_t peak = 0;
",100,25
"Add honggfuzz build in travis. (#3589)

* Add honggfuzz build in travis.
* Skip check_build for honggfuzz, only build."," import subprocess
 import yaml
 
 DEFAULT_ARCHITECTURES = ['x86_64']
-DEFAULT_ENGINES = ['afl', 'libfuzzer']
+DEFAULT_ENGINES = ['afl', 'honggfuzz', 'libfuzzer']
 DEFAULT_SANITIZERS = ['address', 'undefined']
 
 
 def build_project(project):
 
 print('Building project', project)
 build_fuzzers(project, engine, sanitizer, architecture)
- if engine != 'none':
+
+ # TODO(https://github.com/google/oss-fuzz/issues/3592): Re-enable after
+ # Honggfuzz is supported in check_build.
+ if engine not in ['none', 'honggfuzz']:
 check_build(project, engine, sanitizer, architecture)
 
 
",87,19
"Add check_build for Honggfuzz targets, enable in travis. (#3596)"," def main(): # pylint: disable=too-many-branches,too-many-return-statements,too-
 check_build_parser = subparsers.add_parser(
 'check_build', help='Checks that fuzzers execute without errors.')
 _add_architecture_args(check_build_parser)
- _add_engine_args(check_build_parser, choices=['libfuzzer', 'afl', 'dataflow'])
+ _add_engine_args(check_build_parser,
+ choices=['libfuzzer', 'afl', 'honggfuzz', 'dataflow'])
 _add_sanitizer_args(check_build_parser,
 choices=['address', 'memory', 'undefined', 'dataflow'])
 _add_environment_args(check_build_parser)
",657,114
Log output when we fail to detect main repo. (#3599)," def detect_main_repo(project_name, repo_name=None, commit=None):
 match = re.search(r'\bDetected repo: ([^ ]+) ([^ ]+)', out.rstrip())
 if match and match.group(1) and match.group(2):
 return match.group(1), match.group(2)
+
+ logging.error('Failed to detect repo:\n%s', out)
 return None, None
",52,11
"[ghostscript] Make sure that all state kept in memory. (#3619)

The default setting allows for state to be temporarily saved to disk.
This is likely to interfere with the fuzzer's knowledge about state of data."," static int gs_to_raster_fuzz(const unsigned char *buf, size_t size)
 ""gs"",
 ""-K1048576"",
 ""-r200x200"",
+""-sBandListStorage=memory"",
 ""-dMaxBitmap=0"",
 ""-dBufferSpace=450k"",
 ""-dMediaPosition=1"",
",75,10
"Bisector fixes. (#3601)

- Copy /src from host instead of checking out repo on host. This fixes
 issues with dependencies in the main repo.
- Add some more logging."," def build_fuzzers_impl( # pylint: disable=too-many-arguments
 command = ['--cap-add', 'SYS_PTRACE'] + _env_to_docker_args(env)
 if source_path:
 workdir = _workdir_from_dockerfile(project_name)
- if workdir == '/src':
- print('Cannot use local checkout with ""WORKDIR: /src"".', file=sys.stderr)
- return 1
- if not mount_location:
+ if mount_location:
 command += [
 '-v',
- '%s:%s' % (_get_absolute_path(source_path), workdir),
+ '%s:%s' % (_get_absolute_path(source_path), mount_location),
 ]
 else:
+ if workdir == '/src':
+ print('Cannot use local checkout with ""WORKDIR: /src"".',
+ file=sys.stderr)
+ return 1
+
 command += [
 '-v',
- '%s:%s' % (_get_absolute_path(source_path), mount_location),
+ '%s:%s' % (_get_absolute_path(source_path), workdir),
 ]
 
 command += [
",658,114
"Allow bisecting with no old commit. (#3641)

Fixes #3598."," class RepoManagerGetCommitListUnitTest(unittest.TestCase):
 '97dee00a3c4ce95071c3e061592f5fd577dea886',
 '04ea24ee15bbe46a19e5da6c5f022a2ffdfbdb3b'
 ]
- result_list = test_repo_manager.get_commit_list(old_commit, new_commit)
+ result_list = test_repo_manager.get_commit_list(new_commit, old_commit)
 self.assertListEqual(commit_list, result_list)
 
 def test_invalid_commit_list(self):
 class RepoManagerGetCommitListUnitTest(unittest.TestCase):
 test_repo_manager.get_commit_list(new_commit, 'fakecommit')
 with self.assertRaises(RuntimeError):
 # pylint: disable=arguments-out-of-order
- test_repo_manager.get_commit_list(new_commit, old_commit)
+ test_repo_manager.get_commit_list(old_commit, new_commit)
 
 
 class GitDiffUnitTest(unittest.TestCase):
",123,12
[eigen] Remove unnecessary static_cast from FDP calls (follow up #3563). (#3648)," static constexpr Eigen::Index kEigenIndexOne = static_cast<Eigen::Index>(1);
 
 template <typename T>
 T ConsumeValue(FuzzedDataProvider* stream) {
- return static_cast<T>(stream->ConsumeIntegral<T>());
+ return stream->ConsumeIntegral<T>();
 }
 
 template <>
 float ConsumeValue(FuzzedDataProvider* stream) {
- return static_cast<float>(stream->ConsumeFloatingPoint<float>());
+ return stream->ConsumeFloatingPoint<float>();
 }
 
 template <>
 double ConsumeValue(FuzzedDataProvider* stream) {
- return static_cast<double>(stream->ConsumeFloatingPoint<double>());
+ return stream->ConsumeFloatingPoint<double>();
 }
 
 template <>
 long double ConsumeValue(FuzzedDataProvider* stream) {
- return static_cast<long double>(stream->ConsumeFloatingPoint<long double>());
+ return stream->ConsumeFloatingPoint<long double>();
 }
 
 template <>
",156,15
"bisector: Preserve file metadata when copying /src to host. (#3649)

Otherwise changed timestamps may cause build issues."," def copy_src_from_docker(project_name, host_dir):
 image_name,
 'cp',
 '-r',
+ '-p',
 '/src',
 '/out',
 ]
",66,12
"bisector: raise exceptions when building new or old commit fails. (#3653)

Let build failures continue during the actual bisection for now to keep
the bisection going. A future PR can improve the logic of that when it
happens."," def build_fuzzers_from_commit(commit, build_repo_manager, host_src_path,
 0 on successful build or error code on failure.
 """"""
 build_repo_manager.checkout_commit(commit)
- return helper.build_fuzzers_impl(project_name=build_data.project_name,
- clean=True,
- engine=build_data.engine,
- sanitizer=build_data.sanitizer,
- architecture=build_data.architecture,
- env_to_add=None,
- source_path=host_src_path,
- mount_location=os.path.join('/src'))
+ result = helper.build_fuzzers_impl(project_name=build_data.project_name,
+ clean=True,
+ engine=build_data.engine,
+ sanitizer=build_data.sanitizer,
+ architecture=build_data.architecture,
+ env_to_add=None,
+ source_path=host_src_path,
+ mount_location=os.path.join('/src'))
+ return result == 0
 
 
 def detect_main_repo(project_name, repo_name=None, commit=None):
",67,12
bisector: Don't clean when checking out commits. (#3652)," def build_fuzzers_from_commit(commit, build_repo_manager, host_src_path,
 Returns:
 0 on successful build or error code on failure.
 """"""
- build_repo_manager.checkout_commit(commit)
+ build_repo_manager.checkout_commit(commit, clean=False)
 result = helper.build_fuzzers_impl(project_name=build_data.project_name,
 clean=True,
 engine=build_data.engine,
",67,12
"[infra] Improve srcmap support for Go projects (#3355, #2714). (#3664)

* [infra] Improve srcmap support for Go projects (#3355, #2714).

* address review feedback"," def get_build_steps(project_dir):
 dockerfile_path = os.path.join(project_dir, 'Dockerfile')
 name = project_yaml['name']
 image = project_yaml['image']
+ language = project_yaml['language']
 report_date = datetime.datetime.now().strftime('%Y%m%d')
 
- build_steps = [
- {
- 'args': [
- 'clone',
- 'https://github.com/google/oss-fuzz.git',
- ],
- 'name': 'gcr.io/cloud-builders/git',
- },
- {
- 'name': 'gcr.io/cloud-builders/docker',
- 'args': [
- 'build',
- '-t',
- image,
- '.',
- ],
- 'dir': 'oss-fuzz/projects/' + name,
- },
- {
- 'name': image,
- 'args': [
- 'bash', '-c',
- 'srcmap > /workspace/srcmap.json && cat /workspace/srcmap.json'
- ],
- 'env': ['OSSFUZZ_REVISION=$REVISION_ID'],
- },
- ]
+ build_steps = build_lib.project_image_steps(name, image, language)
 
 env = CONFIGURATION[:]
 out = '/workspace/out/' + SANITIZER
",195,11
Remove unused MSan and UBSan from Honggfuzz configurations. (#3667)," ENGINE_INFO = {
 supported_architectures=['x86_64']),
 'honggfuzz':
 EngineInfo(upload_bucket='clusterfuzz-builds-honggfuzz',
- supported_sanitizers=['address', 'memory', 'undefined'],
+ supported_sanitizers=['address'],
 supported_architectures=['x86_64']),
 'dataflow':
 EngineInfo(upload_bucket='clusterfuzz-builds-dataflow',
",155,13
Fix leaks in quickjs targets (#3669)," int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) {
 }
 obj = JS_ReadObject(ctx, bytecode, bytecode_size, JS_READ_OBJ_BYTECODE);
 if (JS_IsException(obj)) {
+ js_free(ctx, bytecode);
 return 0;
 }
 nbinterrupts = 0;
 int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) {
 if (JS_VALUE_GET_TAG(obj) == JS_TAG_MODULE) {
 if (JS_ResolveModule(ctx, obj) < 0) {
 JS_FreeValue(ctx, obj);
+ js_free(ctx, bytecode);
 return 0;
 }
 js_module_set_import_meta(ctx, obj, FALSE, TRUE);
 int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) {
 val = JS_EvalFunction(ctx, obj);
 if (JS_IsException(val)) {
 js_std_dump_error(ctx);
- return 0;
+ } else {
+ js_std_loop(ctx);
 }
 JS_FreeValue(ctx, val);
- js_std_loop(ctx);
 js_free(ctx, bytecode);
 }
 
",75,11
Return main repo URL in bisector result. (#3672)," class BisectIntegrationTests(unittest.TestCase):
 engine='libfuzzer',
 sanitizer='address',
 architecture='x86_64')
- error_sha = bisector.bisect(test_repo.old_commit, test_repo.new_commit,
- test_repo.test_case_path,
- test_repo.fuzz_target, build_data)
- self.assertEqual(error_sha, test_repo.intro_commit)
+ result = bisector.bisect(test_repo.old_commit, test_repo.new_commit,
+ test_repo.test_case_path,
+ test_repo.fuzz_target, build_data)
+ self.assertEqual(result.commit, test_repo.intro_commit)
 
 
 if __name__ == '__main__':
",42,4
Fix bisector commandline invocation. (#3692)," def main():
 sanitizer=args.sanitizer,
 architecture=args.architecture)
 
- error_sha = bisect(args.old_commit, args.new_commit, args.test_case_path,
+ result = bisect(args.old_commit, args.new_commit, args.test_case_path,
 args.fuzz_target, build_data)
- if not error_sha:
+ if not result.commit:
 logging.error('No error was found in commit range %s:%s', args.old_commit,
 args.new_commit)
 return 1
- if error_sha == args.old_commit:
+ if result.commit == args.old_commit:
 logging.error(
 'Bisection Error: Both the first and the last commits in'
 'the given range have the same behavior, bisection is not possible. ')
 return 1
- print('Error was introduced at commit %s' % error_sha)
+ print('Error was introduced at commit %s' % result.commit)
 return 0
 
 
",129,13
"Fix fuzz_readelf.c compile error (#3705) (#3706)

Upstream binutils commit 978c4450511 broke this target. What's more,
the use-after-free issue had been fixed quite some time ago. So,
don't reference symtab_shndx_list."," LLVMFuzzerTestOneInput(const uint8_t *data, size_t size)
 free (dump_ctf_strtab_name);
 free (dump_ctf_parent_name);
 
-// Unless we set this global variable to NULL, then we will run 
-// into a use-after-free error after a certain set of iterations. 
-// I have applied this patch because the authors of binutils
-// prefer to think of their applications as ""one-use-only"" as written
- // here: https://github.com/google/oss-fuzz/pull/2617
-symtab_shndx_list = NULL;
-
 return 0;
 }
",31,2
bisector: Don't attempt to checkout old OSS-Fuzz revision if it does not exist. (#3707)," def build_fuzzers_from_commit(commit, build_repo_manager, host_src_path,
 ],
 check_result=True)
 oss_fuzz_commit = oss_fuzz_commit.strip()
+ if not oss_fuzz_commit:
+ logging.warning('No suitable earlier OSS-Fuzz commit found.')
+ break
 
 logging.info('Build failed. Retrying on earlier OSS-Fuzz commit %s.',
 oss_fuzz_commit)
",118,18
Address comment from last commit. (#3714)," def build_fuzzers_from_commit(commit, build_repo_manager, host_src_path,
 oss_fuzz_commit = oss_fuzz_commit.strip()
 if not oss_fuzz_commit:
 logging.warning('No suitable earlier OSS-Fuzz commit found.')
- break
+ return False
 
 logging.info('Build failed. Retrying on earlier OSS-Fuzz commit %s.',
 oss_fuzz_commit)
",118,18
Use base-builder close to commit date. (#3715)," class BaseRepoManager:
 """"""
 out, _, _ = self.git(['show', '-s', '--format=%ct', commit],
 check_result=True)
- return datetime.datetime.fromtimestamp(int(out))
+ return datetime.datetime.fromtimestamp(int(out), tz=datetime.timezone.utc)
 
 def get_git_diff(self):
 """"""Gets a list of files that have changed from the repo head.
",117,38
[CIFuzz] Support ALLOWED_BROKEN_TARGETS_PERCENTAGE," def check_fuzzer_build(out_dir, sanitizer='address'):
 Returns:
 True if fuzzers are correct.
 """"""
+
 if not os.path.exists(out_dir):
 logging.error('Invalid out directory: %s.', out_dir)
 return False
 def check_fuzzer_build(out_dir, sanitizer='address'):
 '--cap-add', 'SYS_PTRACE', '-e', 'FUZZING_ENGINE=' + DEFAULT_ENGINE, '-e',
 'SANITIZER=' + sanitizer, '-e', 'ARCHITECTURE=' + DEFAULT_ARCHITECTURE
 ]
+
+ allowed_broken_targets_percentage = os.getenv(
+ 'ALLOWED_BROKEN_TARGETS_PERCENTAGE')
+ if allowed_broken_targets_percentage is not None:
+ set_env_var_arg = ('ALLOWED_BROKEN_TARGETS_PERCENTAGE=' +
+ allowed_broken_targets_percentage)
+ command += ['-e', set_env_var_arg]
+
 container = utils.get_container_name()
 if container:
 command += ['-e', 'OUT=' + out_dir, '--volumes-from', container]
",321,36
"Revert ""[CIFuzz] Support ALLOWED_BROKEN_TARGETS_PERCENTAGE""

This reverts commit 6f1a7f79115a949c8954ccd76bca1baa66e686f6."," def check_fuzzer_build(out_dir, sanitizer='address'):
 Returns:
 True if fuzzers are correct.
 """"""
-
 if not os.path.exists(out_dir):
 logging.error('Invalid out directory: %s.', out_dir)
 return False
 def check_fuzzer_build(out_dir, sanitizer='address'):
 '--cap-add', 'SYS_PTRACE', '-e', 'FUZZING_ENGINE=' + DEFAULT_ENGINE, '-e',
 'SANITIZER=' + sanitizer, '-e', 'ARCHITECTURE=' + DEFAULT_ARCHITECTURE
 ]
-
- allowed_broken_targets_percentage = os.getenv(
- 'ALLOWED_BROKEN_TARGETS_PERCENTAGE')
- if allowed_broken_targets_percentage is not None:
- set_env_var_arg = ('ALLOWED_BROKEN_TARGETS_PERCENTAGE=' +
- allowed_broken_targets_percentage)
- command += ['-e', set_env_var_arg]
-
 container = utils.get_container_name()
 if container:
 command += ['-e', 'OUT=' + out_dir, '--volumes-from', container]
",315,35
helper: Clean /work as well if --clean is specified. (#3738)," def build_fuzzers_impl( # pylint: disable=too-many-arguments
 return 1
 
 project_out_dir = _get_output_dir(project_name)
+ project_work_dir = _get_work_dir(project_name)
+
 if clean:
 print('Cleaning existing build artifacts.')
 
 def build_fuzzers_impl( # pylint: disable=too-many-arguments
 'gcr.io/oss-fuzz/%s' % project_name, '/bin/bash', '-c', 'rm -rf /out/*'
 ])
 
+ docker_run([
+ '-v',
+ '%s:/work' % project_work_dir, '-t',
+ 'gcr.io/oss-fuzz/%s' % project_name, '/bin/bash', '-c', 'rm -rf /work/*'
+ ])
+
 else:
 print('Keeping existing build artifacts as-is (if any).')
 env = [
 def build_fuzzers_impl( # pylint: disable=too-many-arguments
 if env_to_add:
 env += env_to_add
 
- project_work_dir = _get_work_dir(project_name)
-
 # Copy instrumented libraries.
 if sanitizer == 'memory':
 docker_run([
",663,114
bisector: Sort by timestamp order when getting base-builder tags. (#3740)," def _load_base_builder_repo():
 return None
 
 result, _, _ = utils.execute([
- gcloud_path, 'container', 'images', 'list-tags',
- 'gcr.io/oss-fuzz-base/base-builder', '--format=json'
+ gcloud_path,
+ 'container',
+ 'images',
+ 'list-tags',
+ 'gcr.io/oss-fuzz-base/base-builder',
+ '--format=json',
+ '--sort-by=timestamp',
 ],
 check_result=True)
 result = json.loads(result)
",167,17
"Raise exception if old_commit has the same behaviour as new_commit. (#3749)

Ignoring it and trying to bisect the entire range up to new_commit is
too slow and does not work well in practice."," def _bisect(old_commit, new_commit, test_case_path, fuzz_target, build_data): #
 if expected_error_code == helper.reproduce_impl(build_data.project_name,
 fuzz_target, False, [],
 [], test_case_path):
- logging.warning(
- 'old_commit has the same result as new_commit, ignoring.')
- commit_list = bisect_repo_manager.get_commit_list(new_commit)
- old_idx = len(commit_list) - 1
+ raise RuntimeError('old_commit had same result as new_commit')
 
 while old_idx - new_idx > 1:
 curr_idx = (old_idx + new_idx) // 2
",164,17
bisector: Increase rsync performance. (#3757)," def copy_src_from_docker(project_name, host_dir):
 host_dir + ':/out',
 image_name,
 'rsync',
- '-az',
+ '-aW',
 '--delete',
 '/src',
 '/out',
",151,26
Add a better check for crash during bisection. (#3758)," def reproduce(args):
 
 
 def reproduce_impl( # pylint: disable=too-many-arguments
- project_name, fuzzer_name, valgrind, env_to_add, fuzzer_args,
- testcase_path):
+ project_name,
+ fuzzer_name,
+ valgrind,
+ env_to_add,
+ fuzzer_args,
+ testcase_path,
+ runner=docker_run,
+ err_result=1):
 """"""Reproduces a testcase in the container.""""""
 if not check_project_exists(project_name):
- return 1
+ return err_result
 
 if not _check_fuzzer_exists(project_name, fuzzer_name):
- return 1
+ return err_result
 
 debugger = ''
 env = []
 def reproduce_impl( # pylint: disable=too-many-arguments
 '-runs=100',
 ] + fuzzer_args
 
- return docker_run(run_args)
+ return runner(run_args)
 
 
 def generate(args):
",669,114
"bisector: Properly detect MSan issues as well. (#3762)

Adopt a similar start/end marker approach to CF."," import utils
 
 Result = collections.namedtuple('Result', ['repo_url', 'commit'])
 
-CRASH_MARKERS = [
+START_MARKERS = [
 '==ERROR',
+ '==WARNING',
+]
+
+END_MARKERS = [
 'SUMMARY:',
 ]
 
 def _check_for_crash(project_name, fuzz_target, test_case_path):
 
 logging.info('stdout =\n%s', out)
 logging.info('stderr =\n%s', err)
+
 # pylint: disable=unsupported-membership-test
- return all(marker in out or marker in err for marker in CRASH_MARKERS)
+ has_start_marker = any(
+ marker in out or marker in err for marker in START_MARKERS)
+ has_end_marker = any(marker in out or marker in err for marker in END_MARKERS)
+ return has_start_marker and has_end_marker
 
 
 # pylint: disable=too-many-locals
",204,17
bisector: always reset projects/ even when we exception out. (#3769)," def bisect(bisect_type, old_commit, new_commit, test_case_path, fuzz_target,
 Raises:
 ValueError: when a repo url can't be determine from the project.
 """"""
- result = _bisect(bisect_type, old_commit, new_commit, test_case_path,
+ try:
+ return _bisect(bisect_type, old_commit, new_commit, test_case_path,
 fuzz_target, build_data)
-
- # Clean up projects/ as _bisect may have modified it.
- oss_fuzz_repo_manager = repo_manager.BaseRepoManager(helper.OSS_FUZZ_DIR)
- oss_fuzz_repo_manager.git(['reset', 'projects'])
- oss_fuzz_repo_manager.git(['checkout', 'projects'])
- oss_fuzz_repo_manager.git(['clean', '-fxd', 'projects'])
-
- return result
+ finally:
+ # Clean up projects/ as _bisect may have modified it.
+ oss_fuzz_repo_manager = repo_manager.BaseRepoManager(helper.OSS_FUZZ_DIR)
+ oss_fuzz_repo_manager.git(['reset', 'projects'])
+ oss_fuzz_repo_manager.git(['checkout', 'projects'])
+ oss_fuzz_repo_manager.git(['clean', '-fxd', 'projects'])
 
 
 if __name__ == '__main__':
",219,21
"[CIFuzz] Support ALLOWED_BROKEN_TARGETS_PERCENTAGE (#3726)

Currently we use Github action's inputs as inputs to cifuzz.
This means we need to do an extra step to convert each input into
an env var so our scripts can actually use it.
This is pretty bug prone and unnecessary, we should probably
get rid of this abstraction and switch to encouraging devs to set
the env vars directly."," def check_fuzzer_build(out_dir):
 'SANITIZER=' + DEFAULT_SANITIZER, '-e',
 'ARCHITECTURE=' + DEFAULT_ARCHITECTURE
 ]
+
+ # Set ALLOWED_BROKEN_TARGETS_PERCENTAGE in docker if specified by user.
+ allowed_broken_targets_percentage = os.getenv(
+ 'ALLOWED_BROKEN_TARGETS_PERCENTAGE')
+ if allowed_broken_targets_percentage is not None:
+ command += [
+ '-e',
+ ('ALLOWED_BROKEN_TARGETS_PERCENTAGE=' +
+ allowed_broken_targets_percentage)
+ ]
+
 container = utils.get_container_name()
 if container:
 command += ['-e', 'OUT=' + out_dir, '--volumes-from', container]
",304,32
Quick fix for helper.py build_fuzzers. (#3832)," def build_fuzzers_impl( # pylint: disable=too-many-arguments
 print('Keeping existing build artifacts as-is (if any).')
 env = [
 'FUZZING_ENGINE=' + engine,
+ 'FUZZING_LANGUAGE=c++', # TODO: Replace with actual language.
 'SANITIZER=' + sanitizer,
 'ARCHITECTURE=' + architecture,
 ]
",670,114
Add FUZZING_LANGUAGE to build step. (#3835)," def project_image_steps(name, image, language):
 '.',
 ],
 'dir': 'oss-fuzz/projects/' + name,
+ 'env': ['FUZZING_LANGUAGE=%s' % language],
 }, {
 'name':
 image,
",156,13
Add fuzzing language correctly during compile step. (#3837)," def project_image_steps(name, image, language):
 '.',
 ],
 'dir': 'oss-fuzz/projects/' + name,
- 'env': ['FUZZING_LANGUAGE=%s' % language],
 }, {
 'name':
 image,
",155,13
Fix missing FUZZING_LANGUAGE in coverage build. (#3843)," def skip_build(message):
 sys.stderr.write('%s\n' % message)
 
 # Since the script should print build_id, print '0' as a special value.
- print '0'
+ print('0')
 exit(0)
 
 
 def get_build_steps(project_dir):
 env = CONFIGURATION[:]
 out = '/workspace/out/' + SANITIZER
 env.append('OUT=' + out)
+ env.append('FUZZING_LANGUAGE=' + language)
 
 workdir = build_project.workdir_from_dockerfile(dockerfile_path)
 if not workdir:
",196,11
[poppler] Exercise a few more methods (#3857),"
 
 #include <cstdint>
 
+#include <poppler-destination.h>
 #include <poppler-global.h>
 #include <poppler-document.h>
 #include <poppler-page.h>
 extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
 delete doc;
 return 0;
 }
+ doc->metadata();
+ doc->create_destination_map();
+ doc->embedded_files();
+ doc->fonts();
 
 poppler::page_renderer r;
 for (int i = 0; i < doc->pages(); i++) {
 extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
 continue;
 }
 r.render_page(p);
- p->text_list();
+ p->text_list(poppler::page::text_list_include_font);
 delete p;
 }
 
",31,6
"build_specified_commit: revert to using cp. (#3871)


rsync seems to have disappeared in the latest images somehow, and we
can't rely on it always existing."," import os
 import collections
 import logging
 import re
+import shutil
 
 import helper
 import repo_manager
 def copy_src_from_docker(project_name, host_dir):
 """"""Copy /src from docker to the host.""""""
 # Copy /src to host.
 image_name = 'gcr.io/oss-fuzz/' + project_name
+ src_dir = os.path.join(host_dir, 'src')
+ if os.path.exists(src_dir):
+ shutil.rmtree(src_dir, ignore_errors=True)
+
 docker_args = [
 '-v',
 host_dir + ':/out',
 image_name,
- 'rsync',
- '-aW',
- '--delete',
+ 'cp',
+ '-r',
+ '-p',
 '/src',
 '/out',
 ]
 def copy_src_from_docker(project_name, host_dir):
 
 # Submodules can have gitdir entries which point to absolute paths. Make them
 # relative, as otherwise we can't do operations on the checkout on the host.
- src_dir = os.path.join(host_dir, 'src')
 _make_gitdirs_relative(src_dir)
-
 return src_dir
 
 
",154,27
"Fix CIFuzz issue where targets assumed in OSS-Fuzz build if exists (#3817)

Make some other changes:
1. Refactor fuzz_target.py and fuzz_target_test.py
2. Introduce pyfakefs and parameterized as dependencies and use them
in tests.
3. Fix infra-tests in CI so that they use installed dependencies"," def run_tests():
 for file in get_changed_files():
 changed_dirs.add(os.path.dirname(file))
 
- # TODO(metzman): This approach for running tests is probably flawed since
- # tests can fail even if their directory isn't changed. Figure out if it is
- # needed (to save time) and remove it if it isn't.
+ # TODO(metzman): This approach for running tests is flawed since tests can
+ # fail even if their directory isn't changed. Figure out if it is needed (to
+ # save time) and remove it if it isn't.
 suite_list = []
 for change_dir in changed_dirs:
 suite_list.append(unittest.TestLoader().discover(change_dir,
 pattern='*_test.py'))
- full_suite = unittest.TestSuite(suite_list)
- result = unittest.TextTestRunner().run(full_suite)
- return not result.failures
+ suite = unittest.TestSuite(suite_list)
+ result = unittest.TextTestRunner().run(suite)
+ return not result.failures and not result.errors
 
 
 def main():
",241,75
[haproxy] Minor fix (#3928),"
 * #
 * ################################################################################
 * */
+
+#define HPACK_STANDALONE
+
 #include <stdint.h>
 #include <string.h>
 #include <stdlib.h>

 #include <common/chunk.h>
 #include <common/hpack-dec.h>
 #include <common/mini-clist.h>
-#define HPACK_STANDALONE
 
 #define MAX_RQ_SIZE 65536
 #define MAX_HDR_NUM 1000
",47,5
"[Nodejs] initial integration. (#3860)

* Nodejs initial integration.

* Added headers to fix Travis.

* A lot of simplifications to build script. LDFLAGS is the key here.

* More simplifications to build script.

* Fix Travis.

* Remove msan.

* Generalise and simplify build script.

* utilise all cores and a bit nicer structure in build.","
+/* Copyright 2020 Google Inc.
+
+Licensed under the Apache License, Version 2.0 (the ""License"");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+ http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an ""AS IS"" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+#include <stdlib.h>
+
+#include ""node.h""
+#include ""node_internals.h""
+#include ""node_url.h""
+
+extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
+ node::url::URL url2((char*)data, size);
+
+ return 0;
+} 
",8,1
"Increase coverage of libraw fuzzing (#3962)

* Increase coverage

* Respond to PR feedback

* Move corpuses to cloud

Co-authored-by: Jamie Pinheiro <pinheirojamie@google.com>"," limitations under the License.
 
 #include <libraw.h>
 
+enum InterpolationOptions {
+ Linear = 0,
+ Vng = 1, 
+ Ppg = 2,
+ Ahd = 3,
+ Dcb = 4,
+ Dht = 11,
+ AhdModified = 12
+};
+
 extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
- // Input less than 10mb
- if (size > 10000000) {
+ // Input less than 15mb
+ if (size > 15000000) {
 return 0;
 }
 
 extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
 return 0;
 }
 
- result = lib_raw.dcraw_process();
- if (result != LIBRAW_SUCCESS) {
- return 0;
+ InterpolationOptions options[] = {Linear, Vng, Ppg, Ahd, Dcb, Dht, AhdModified};
+
+ for (int i = 0; i < sizeof(options); i++) {
+ lib_raw.output_params_ptr()->user_qual = static_cast<int>(options[i]);
+
+ result = lib_raw.dcraw_process();
+ if (result != LIBRAW_SUCCESS) {
+ return 0;
+ }
 }
 
 return 0;
",37,6
"Fix array bounds (#3990)

Co-authored-by: Jamie Pinheiro <pinheirojamie@google.com>"," extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
 
 InterpolationOptions options[] = {Linear, Vng, Ppg, Ahd, Dcb, Dht, AhdModified};
 
- for (int i = 0; i < sizeof(options); i++) {
+ for (int i = 0; i < sizeof(options)/sizeof(*options); i++) {
 lib_raw.output_params_ptr()->user_qual = static_cast<int>(options[i]);
 
 result = lib_raw.dcraw_process();
",37,6
"[Haproxy] Simplify build script and update to latest code (#4000)

* Updated hpack to work with new build.

* Required minimium length.","
 int
 LLVMFuzzerTestOneInput(const uint8_t *data, size_t size)
 {
+ if (size < 50)
+ return 0;
+
 char filename[256];
 sprintf(filename, ""/tmp/libfuzzer.%d"", getpid());
 
",19,3
"[util-linux] cover mnt_table_parse_stream (#4032)

* [util-linux] cover mnt_table_parse_stream

Waiting for https://github.com/karelzak/util-linux/pull/1068

* temporarily point OSS-Fuzz to evverx/util-linux

* make sure it can be built with sanitizer=coverage"," def build_project(project):
 sanitizer = os.getenv('SANITIZER')
 architecture = os.getenv('ARCHITECTURE')
 
- if not should_build(project_yaml):
+ if sanitizer != 'coverage' and not should_build(project_yaml):
 print(('Specified build: engine: {0}, sanitizer: {1}, architecture: {2} '
 'not enabled for this project: {3}. skipping build.').format(
 engine, sanitizer, architecture, project))
 def build_project(project):
 print('Building project', project)
 build_fuzzers(project, engine, sanitizer, architecture)
 
- if engine != 'none':
+ if engine != 'none' and sanitizer != 'coverage':
 check_build(project, engine, sanitizer, architecture)
 
 
",84,21
Fix memory leak in libevent parse_query_fuzzer,"
 extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
 std::string fuzz_string(reinterpret_cast<const char *>(data), size);
 struct evkeyvalq headers;
- evhttp_parse_query(fuzz_string.c_str(), &headers);
+ if (evhttp_parse_query(fuzz_string.c_str(), &headers) == 0) {
+ evhttp_clear_headers(&headers);
+ }
 return 0;
 }
",14,2
"Added deploy file and restructured cloud function directory (#4057)

* Adding deploy.sh and restructuring directory

* Integrating review changes

* Passed project id as an argument to each command

Co-authored-by: Kabeer Seth <kabeerseth@google.com>"," import threading
 
 from google.cloud import ndb
 
-from sync import sync_projects
-from sync import get_projects
-from sync import get_access_token
-from sync import Project
+from main import sync_projects
+from main import get_projects
+from main import get_access_token
+from main import Project
 
 _EMULATOR_TIMEOUT = 20
 _DATASTORE_READY_INDICATOR = b'is now running'
",129,22
[util-linux] move the fuzz target to the OSS-Fuzz repository (#4063),"
+/* Copyright 2020 Google Inc.
+
+Licensed under the Apache License, Version 2.0 (the ""License"");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+ http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an ""AS IS"" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+#include ""mountP.h""
+
+#include <stddef.h>
+#include <stdint.h>
+
+int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
+ struct libmnt_table *tb = NULL;
+ FILE *f = NULL;
+
+ if (size == 0)
+ return 0;
+
+ tb = mnt_new_table();
+ assert(tb);
+
+ f = fmemopen((char*) data, size, ""re"");
+ assert(f);
+
+ (void) mnt_table_parse_stream(tb, f, ""mountinfo"");
+
+ mnt_unref_table(tb);
+ fclose(f);
+
+ return 0;
+}
",17,2
"Skip coverage build in CI for non C/C++ projects. (#4075)

* Skip coverage build in CI for non C/C++ projects.

Fixes https://github.com/google/oss-fuzz/issues/4074

* Test wasmtime."," DEFAULT_ARCHITECTURES = ['x86_64']
 DEFAULT_ENGINES = ['afl', 'honggfuzz', 'libfuzzer']
 DEFAULT_SANITIZERS = ['address', 'undefined']
 
+# Languages from project.yaml that have code coverage support.
+LANGUAGES_WITH_COVERAGE_SUPPORT = ['c', 'c++']
+
 
 def get_modified_buildable_projects():
 """"""Returns a list of all the projects modified in this commit that have a
 def build_project(project):
 engine = os.getenv('ENGINE')
 sanitizer = os.getenv('SANITIZER')
 architecture = os.getenv('ARCHITECTURE')
+ language = project_yaml.get('language')
+
+ if (sanitizer == 'coverage' and
+ language not in LANGUAGES_WITH_COVERAGE_SUPPORT):
+ print(('Project ""{project}"" is written in ""{language}"", '
+ 'coverage is not supported yet.').format(project=project,
+ language=language))
+ return
 
 if sanitizer != 'coverage' and not should_build(project_yaml):
 print(('Specified build: engine: {0}, sanitizer: {1}, architecture: {2} '
",92,23
"Don't traverse symlinks in patch_build.py (#4086)

Should fix https://github.com/google/oss-fuzz/issues/4003"," def PatchBuild(output_directory):
 for root_dir, _, filenames in os.walk(output_directory):
 for filename in filenames:
 file_path = os.path.join(root_dir, filename)
+
+ if os.path.islink(file_path):
+ continue
+
 if not IsElf(file_path):
 continue
 
",87,24
"Renaming schedule variable to builds_per_day for new feature (#4091)

* Renaming schedule variable to builds_per_day for new feature

* Minor formatting change

Co-authored-by: Kabeer Seth <kabeerseth@google.com>"," def get_schedule(project_contents):
 if content_file.name != 'project.yaml':
 continue
 project_yaml = yaml.safe_load(content_file.decoded_content.decode('utf-8'))
- times_per_day = project_yaml.get('schedule', DEFAULT_BUILDS_PER_DAY)
- if not isinstance(times_per_day, int) or times_per_day not in range(
+ builds_per_day = project_yaml.get('builds_per_day', DEFAULT_BUILDS_PER_DAY)
+ if not isinstance(builds_per_day, int) or builds_per_day not in range(
 1, MAX_BUILDS_PER_DAY + 1):
 raise ProjectYamlError('Parameter is not an integer in range [1-4]')
 
 # Starting at 6:00 am, next build schedules are added at 'interval' slots
 # Example for interval 2, hours = [6, 18] and schedule = '0 6,18 * * *'
 
- interval = 24 // times_per_day
+ interval = 24 // builds_per_day
 hours = []
 for hour in range(6, 30, interval):
 hours.append(hour % 24)
",139,33
bisector: try older commits if old_commit has the same result as new_commit (#4096)," class BaseRepoManager:
 The current active commit SHA.
 """"""
 out, _, _ = self.git(['rev-parse', 'HEAD'], check_result=True)
- return out.strip('\n')
+ return out.strip()
+
+ def get_parent(self, commit, count):
+ """"""Gets the count'th parent of the given commit.
+
+ Returns:
+ The parent commit SHA.
+ """"""
+ self.fetch_unshallow()
+ out, _, err_code = self.git(['rev-parse', commit + '~' + str(count)],
+ check_result=False)
+ if err_code:
+ return None
+
+ return out.strip()
 
 def get_commit_list(self, newest_commit, oldest_commit=None):
 """"""Gets the list of commits(inclusive) between the old and new commits.
",124,40
"CIFuzz: switch to systemd-detect-virt to detect docker (#4101)

Closes https://github.com/google/oss-fuzz/issues/4093"," def get_fuzz_targets(path):
 
 def get_container_name():
 """"""Gets the name of the current docker container you are in.
- /proc/self/cgroup can be used to check control groups e.g. Docker.
- See: https://docs.docker.com/config/containers/runmetrics/ for more info.
 
 Returns:
 Container name or None if not in a container.
 """"""
- with open('/proc/self/cgroup') as file_handle:
- if 'docker' not in file_handle.read():
- return None
+ result = subprocess.run(['systemd-detect-virt', '-c'],
+ stdout=subprocess.PIPE).stdout
+ if b'docker' not in result:
+ return None
 with open('/etc/hostname') as file_handle:
 return file_handle.read().strip()
 
",61,22
Fix infra tests. (#4097)," EXAMPLE_NOCRASH_FUZZER = 'example_nocrash_fuzzer'
 # A fuzzer to be built in build_fuzzers integration tests.
 EXAMPLE_BUILD_FUZZER = 'do_stuff_fuzzer'
 
-MEMORY_FUZZER_DIR = os.path.join(TEST_FILES_PATH, 'out', 'memory')
+MEMORY_FUZZER_DIR = os.path.join(TEST_FILES_PATH, 'memory')
 MEMORY_FUZZER = 'curl_fuzzer_memory'
 
-UNDEFINED_FUZZER_DIR = os.path.join(TEST_FILES_PATH, 'out', 'undefined')
+UNDEFINED_FUZZER_DIR = os.path.join(TEST_FILES_PATH, 'undefined')
 UNDEFINED_FUZZER = 'curl_fuzzer_undefined'
 
 # pylint: disable=no-self-use
",425,54
"utils: ignore subprocess-run-check (#4102)

""check"" is omitted intentionally there.

A follow-up to https://github.com/google/oss-fuzz/pull/4101"," def get_container_name():
 Returns:
 Container name or None if not in a container.
 """"""
- result = subprocess.run(['systemd-detect-virt', '-c'],
- stdout=subprocess.PIPE).stdout
+ result = subprocess.run( # pylint: disable=subprocess-run-check
+ ['systemd-detect-virt', '-c'],
+ stdout=subprocess.PIPE).stdout
 if b'docker' not in result:
 return None
 with open('/etc/hostname') as file_handle:
",62,22
[infra] Do not pass empty port value to docker. (#4110)," def coverage(args):
 run_args.extend([
 '-v',
 '%s:/out' % _get_output_dir(args.project_name),
- '-p',
- '%s:%s' % (args.port, args.port),
 '-t',
 'gcr.io/oss-fuzz-base/base-runner',
 ])
 
+ if args.port:
+ run_args.extend([
+ '-p',
+ '%s:%s' % (args.port, args.port),
+ ])
+
 run_args.append('coverage')
 if args.fuzz_target:
 run_args.append(args.fuzz_target)
",690,119
"[libexif] Add new fuzzer (#4045)

* added draco integration files

* wrote build file and Dockerfile for Draco

* added new fuzzer, placed license header in existing fuzzer","
+// Copyright 2020 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the ""License"");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an ""AS IS"" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
 #include <stdio.h>
 #include <stdint.h>
 #include <libexif/exif-loader.h>
",50,9
"[binutils] Add new fuzzer (#4128)

* cleaned up Dockerfile, added new fuzzer, updated build script

* added license header to fuzz_demangle.c","
+// Copyright 2020 Google LLC
+//
+// Licensed under the Apache License, Version 2.0 (the ""License"");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an ""AS IS"" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#include <stdint.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include ""demangle.h""
+
+int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
+ char *name = malloc(sizeof(char) * (size + 1));
+ memcpy(name, data, size);
+ name[size] = '\0'; // NUL-terminate
+ char *demangled = cplus_demangle(name, DMGL_AUTO);
+ if (demangled) free(demangled);
+ free(name);
+ return 0;
+}
",13,2
"[spdlog] Added new fuzzers, modifed existing ones (#4008)

* Homepage updated, added auto ccs to project.yaml

* Fixed project.yaml

* [spdlog] Added new fuzzers, modifed existing ones

* Revert ""[spdlog] Added new fuzzers, modifed existing ones""

This reverts commit 1e7f14a81d36818a252b10b18682d4c8bf62a0e7.

* Modified existing fuzzer

* Added new fuzzer for backtrace

* Added new fuzzer for formatter

* Added new fuzzer for set_pattern

* Added new fuzzer for log_levels

* Moved fuzzers to upstream repo

* Moved fuzzers back to oss-fuzz

* fixed fuzzers

* Update years","
-// Copyright 2019 Google LLC
+// Copyright 2020 Google LLC
 //
 // Licensed under the Apache License, Version 2.0 (the ""License"");
 // you may not use this file except in compliance with the License.
 extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
 
 FuzzedDataProvider stream(data, size);
 
- const size_t size_arg = stream.ConsumeIntegral<size_t>();
- const int int_arg = stream.ConsumeIntegral<int>();
- const std::string string_arg = stream.ConsumeRandomLengthString(size);
- const std::string format_string = stream.ConsumeRemainingBytesAsString();
- spdlog::info(format_string.c_str(), size_arg, int_arg, string_arg);
+ const uint16_t size_arg = stream.ConsumeIntegral<uint16_t>();
 
+ spdlog::enable_backtrace(size_arg);
+ for(int i=0; i<size_arg; i++){
+ spdlog::debug(stream.ConsumeRandomLengthString(size));
+ }
+ spdlog::dump_backtrace();
 return 0;
 }
",22,4
"Adding build coverage cloud function, and refactoring test_utils.py (#4151)

* Adding build coverage cloud function, and refactoring test_utils.py

* Multiple changes will add a comment.

* Catching sys.exit() exception and removing useless wrapper build_steps function

* Comment update

* Comment update

* Comment formatting","
 """"""Cloud functions for build infrastructure.""""""
 
 import base_images
-import sync
+import project_sync
 import request_build
+import request_coverage_build
 
 
 def build_project(event, context):
 def build_project(event, context):
 request_build.request_build(event, context)
 
 
-def project_sync(event, context):
+def sync(event, context):
 """"""Entry point for cloud function that syncs projects from github.""""""
- sync.sync(event, context)
+ project_sync.sync(event, context)
 
 
 def build_base_images(event, context):
 """"""Entry point for cloud function that builds base images.""""""
 base_images.base_builder(event, context)
+
+
+def coverage_build(event, context):
+ """"""Entry point for cloud function to build coverage reports.""""""
+ request_coverage_build.request_coverage_build(event, context)
",13,4
"Updates patch for mysql 8.21 (#4162)

* Updates patch for mysql 8.21

* Fixup 8.21

* Disabkes fuzz_docommand to keep going with other targets for now

* do not even compile fuzz_docommand

* Adding license

* FIXMEs

* no longer compiled

* nits","
+/* Copyright 2020 Google Inc.
+
+Licensed under the Apache License, Version 2.0 (the ""License"");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+ http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an ""AS IS"" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
 //#include <stdint.h>
 //#include <stdlib.h>
 //#include <stdio.h>
 extern ""C"" int LLVMFuzzerInitialize(const int* argc, char*** argv) {
 }
 
 
+// FIXME: Fix this buffer with succesful authenticated connection for mysql 8.21.
 const uint8_t startConn[] =
 ""\xa6\x00\x00\x01\x85\xa6\xff\x01\x00\x00\x00\x01\x2d\x00\x00\x00"" \
 ""\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"" \
",137,15
"[uriparser] Fix null dereference in uri_dissect_query_malloc_fuzzer (#4174)

* fixed null dereference in uri_dissect_query_malloc_fuzzer

* removed unused include

* initialized chars_required, freed query_list if check unsuccessful, and used buf.data() instead of &buf[0]"," extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
 if (query_list == nullptr || result != URI_SUCCESS || item_count < 0)
 return 0;
 
- int chars_required;
+ int chars_required = 0;
 if (uriComposeQueryCharsRequiredA(query_list, &chars_required) != URI_SUCCESS)
 return 0;
- 
+
+ if (!chars_required) {
+ uriFreeQueryListA(query_list);
+ return 0;
+ }
+
 std::vector<char> buf(chars_required, 0);
 int written = -1;
- char *dest = &buf[0];
 // Reverse the process of uriDissectQueryMallocA.
- result = uriComposeQueryA(dest, query_list, chars_required, &written);
+ result = uriComposeQueryA(buf.data(), query_list, chars_required, &written);
 
 uriFreeQueryListA(query_list);
-
 return 0;
 }
",30,6
Initial integration of builds_status (#4175)," import base_images
 import project_sync
 import request_build
 import request_coverage_build
+import update_build_status
 
 
 def build_project(event, context):
 def build_base_images(event, context):
 def coverage_build(event, context):
 """"""Entry point for cloud function to build coverage reports.""""""
 request_coverage_build.request_coverage_build(event, context)
+
+
+def builds_status(event, context):
+ """"""Entry point for builds status cloud function.""""""
+ update_build_status.update_status(event, context)
",16,5
"[infra] Rename base-msan-builder image to base-sanitizer-libs-builder (#3388). (#4187)

* [infra] Rename base-msan-builder image to base-sanitizer-builder (#3388).

* rename to base-sanitizer-libs-builder"," BASE_IMAGES = [
 'base-builder',
 'base-runner',
 'base-runner-debug',
- 'base-msan-builder',
+ 'base-sanitizer-libs-builder',
 ]
 
 TAG_PREFIX = 'gcr.io/oss-fuzz-base/'
",62,6
"[infra] Rename msan-builder to msan-libs-builder (#3388). (#4190)

* [infra] Rename msan-builder to msan-libs-builder and add (broken) dfsan-libs-builder (#3388).

* remove dfsan-libs-builder for now

* presubmit format"," def main():
 if 'GCB_OPTIONS' in os.environ:
 options = yaml.safe_load(os.environ['GCB_OPTIONS'])
 
- image = 'gcr.io/oss-fuzz-base/msan-builder'
- steps = build_base_images.get_steps(
- [
- 'base-sanitizer-libs-builder',
- 'msan-builder',
- ]
- )
+ image = 'gcr.io/oss-fuzz-base/msan-libs-builder'
+ steps = build_base_images.get_steps([
+ 'base-sanitizer-libs-builder',
+ 'msan-libs-builder',
+ ])
 ts = datetime.datetime.utcnow().strftime('%Y%m%d%H%M')
 upload_name = 'msan-libs-' + ts + '.zip'
 
 def main():
 
 credentials = GoogleCredentials.get_application_default()
 cloudbuild = build('cloudbuild', 'v1', credentials=credentials)
- build_info = cloudbuild.projects().builds().create(
- projectId='oss-fuzz-base', body=build_body).execute()
+ build_info = cloudbuild.projects().builds().create(projectId='oss-fuzz-base',
+ body=build_body).execute()
 build_id = build_info['metadata']['build']['id']
 
 print >> sys.stderr, 'Logs:', build_base_images.get_logs_url(build_id)
",56,2
"build: Project sync fixes. (#4194)

- Add some more logging.
- Use GitHub client ID/secret rather than personal access token.
- Fix function deploy wrt ""--project"" argument."," import unittest
 from google.cloud import ndb
 
 from datastore_entities import Project
-from project_sync import get_access_token
+from project_sync import get_github_creds
 from project_sync import get_projects
 from project_sync import ProjectMetadata
 from project_sync import sync_projects
 class TestDataSync(unittest.TestCase):
 
 self.assertEqual(get_projects(repo), {})
 
- def test_get_access_token(self):
- """"""Testing get_access_token().""""""
+ def test_get_github_creds(self):
+ """"""Testing get_github_creds().""""""
 with ndb.Client().context():
- self.assertRaises(RuntimeError, get_access_token)
+ self.assertRaises(RuntimeError, get_github_creds)
 
 @classmethod
 def tearDownClass(cls):
",199,34
"Disable coverage job sync. (#4195)

Migrating to new infratructure for requesting coverage jobs."," JENKINS_SERVER = ('localhost', 8080)
 
 JOB_TEMPLATES = [
 {'prefix': 'projects/', 'config': 'base_job.xml'},
- {'prefix': 'coverage/', 'config': 'coverage_job.xml'},
 ]
 
 SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
",68,16
"move Header constructor inside try/catch (#4208)

Signed-off-by: Cary Phillips <seabeepea@gmail.com>"," static void readFile(T *inpart) {
 
 static void readFileSingle(IStream& is, uint64_t width, uint64_t height) {
 DeepScanLineInputFile *file = NULL;
- Header header(width, height);
 try {
+ Header header(width, height);
 file = new DeepScanLineInputFile(header, &is, EXR_VERSION, 0);
 } catch (...) {
 return;
",128,21
"Many build infra fixes. (#4209)

- Remove base image project argument from deploy.sh. Deploy all
 functions to the main oss-fuzz image.
- Reduce max instances of functions to 1 to avoid rate limiting issues.
- Fix missing ndb context initialization in request_build.py
- Fix incorrect tags in BuildHistory entities. ""-"" was doubled.
- Fix base build deployment with incorrect schedule variable.
- Add scripts for requesting builds locally."," class TestRequestBuilds(unittest.TestCase):
 Project(name='test-project',
 project_yaml_contents=project_yaml_contents,
 dockerfile_contents='test line').put()
-
- build_steps = get_build_steps('test-project', image_project,
- base_images_project)
+ build_steps = get_build_steps('test-project', image_project,
+ base_images_project)
 self.assertEqual(build_steps, expected_build_steps)
 
 def test_get_build_steps_no_project(self):
 class TestRequestBuilds(unittest.TestCase):
 """"""Testing build history.""""""
 with ndb.Client().context():
 BuildsHistory(id='test-project-fuzzing',
- build_tag_suffix='fuzzing',
+ build_tag='fuzzing',
 project='test-project',
 build_ids=[str(i) for i in range(1, 65)]).put()
 update_build_history('test-project', '65', '-fuzzing')
",74,10
Fix an Python 3 exception in build_project.py. (#4210)," def get_sanitizers(project_yaml):
 if isinstance(sanitizer, six.string_types):
 processed_sanitizers.append(sanitizer)
 elif isinstance(sanitizer, dict):
- for key in sanitizer.iterkeys():
+ for key in sanitizer.keys():
 processed_sanitizers.append(key)
 
 return processed_sanitizers
",329,23
"Add queueTtl argument to cloud build request. (#4211)

To prevent expiry of queued builds."," DEFAULT_SANITIZERS = ['address', 'undefined']
 LATEST_VERSION_FILENAME = 'latest.version'
 LATEST_VERSION_CONTENT_TYPE = 'text/plain'
 
+QUEUE_TTL_SECONDS = 60 * 60 * 24 # 24 hours.
+
 
 def usage():
 """"""Exit with code 1 and display syntax to use this file.""""""
 def run_build(build_steps, project_name, tag):
 'options': options,
 'logsBucket': GCB_LOGS_BUCKET,
 'tags': [project_name + '-' + tag,],
+ 'queueTtl': str(QUEUE_TTL_SECONDS) + 's',
 }
 
 credentials = GoogleCredentials.get_application_default()
",331,23
Fixing missing dash in datastore query (#4213)," MAX_BUILD_HISTORY_LENGTH = 64
 
 def update_build_history(project_name, build_id, build_tag):
 """"""Update build history of project.""""""
- project_key = ndb.Key(BuildsHistory, project_name + build_tag)
+ project_key = ndb.Key(BuildsHistory, project_name + '-' + build_tag)
 project = project_key.get()
 
 if not project:
",71,9
build: Add queueTtl argument to one more place. (#4219)," from datastore_entities import Project
 
 BASE_PROJECT = 'oss-fuzz-base'
 MAX_BUILD_HISTORY_LENGTH = 64
+QUEUE_TTL_SECONDS = 60 * 60 * 24 # 24 hours.
 
 
 def update_build_history(project_name, build_id, build_tag):
 def run_build(project_name, image_project, build_steps, credentials, tag):
 },
 'logsBucket': build_project.GCB_LOGS_BUCKET,
 'tags': [project_name + tag,],
+ 'queueTtl': str(QUEUE_TTL_SECONDS) + 's',
 }
 
 cloudbuild = build('cloudbuild',
",73,9
Add missing dash to build tag. (#4221)," def run_build(project_name, image_project, build_steps, credentials, tag):
 'machineType': 'N1_HIGHCPU_32'
 },
 'logsBucket': build_project.GCB_LOGS_BUCKET,
- 'tags': [project_name + tag,],
+ 'tags': [project_name + '-' + tag,],
 'queueTtl': str(QUEUE_TTL_SECONDS) + 's',
 }
 
",73,9
"Fix build status update. (#4224)

Check for valid statuses rather than only excluding the WORKING status.
There are other failure statuses that need to be accounted for (e.g.
EXPIRED)."," def get_last_build(build_ids):
 for build_id in reversed(build_ids):
 project_build = cloudbuild.projects().builds().get(projectId=image_project,
 id=build_id).execute()
- if project_build['status'] == 'WORKING':
+ if project_build['status'] not in ('SUCCESS', 'FAILURE', 'TIMEOUT'):
 continue
 
 if not builds_status.upload_log(build_id):
",95,13
"Create individual schedulers for requesting coverage builds. (#4237)

The single function for requesting all coverage builds was timing out."," def get_project_data(project_name):
 def get_build_steps(project_name, image_project, base_images_project):
 """"""Retrieve build steps.""""""
 project_yaml_contents, dockerfile_lines = get_project_data(project_name)
- build_steps = build_project.get_build_steps(project_name,
- project_yaml_contents,
- dockerfile_lines, image_project,
- base_images_project)
- return build_steps
+ return build_project.get_build_steps(project_name, project_yaml_contents,
+ dockerfile_lines, image_project,
+ base_images_project)
 
 
 # pylint: disable=no-member
",71,9
"Adding msan builder to gcp (#4234)

* Adding msan builder to gcp

* Formatting changes

* Refactoring and reducing redundancy

* Moving msan builder entry point into base_images"," def coverage_build(event, context):
 def builds_status(event, context):
 """"""Entry point for builds status cloud function.""""""
 update_build_status.update_status(event, context)
+
+
+def build_msan(event, context):
+ """"""Entry point for base msan builder.""""""
+ base_images.base_msan_builder(event, context)
",18,6
Fix a typo from previous MSan function addition. (#4241)," def run_build(steps, images):
 'v1',
 credentials=credentials,
 cache_discovery=False)
- build_info = cloudbuild.projects().builds().create(project_id=BASE_PROJECT,
+ build_info = cloudbuild.projects().builds().create(projectId=BASE_PROJECT,
 body=build_body).execute()
 build_id = build_info['metadata']['build']['id']
 logging.info('Build ID: %s', build_id)
",44,4
"Skipping fuzzing build when project is disabled (#4239)

* Skipping fuzzing build when project is disabled

* Removing skip build and making it better"," def request_build(event, context):
 with ndb.Client().context():
 credentials, image_project = google.auth.default()
 build_steps = get_build_steps(project_name, image_project, BASE_PROJECT)
+ if not build_steps:
+ return
 run_build(project_name, image_project, build_steps, credentials,
 build_project.FUZZING_BUILD_TAG)
",73,10
"More build infra cleanup. (#4252)

- Deleted unused code.
- Consolidate some modules."," class MockGetBuild:
 
 @mock.patch('google.auth.default', return_value=['temp', 'temp'])
 @mock.patch('update_build_status.build', return_value='cloudbuild')
-@mock.patch('builds_status.upload_log')
+@mock.patch('update_build_status.upload_log')
 class TestGetBuildHistory(unittest.TestCase):
 """"""Unit tests for get_build_history.""""""
 
 class TestUpdateBuildStatus(unittest.TestCase):
 # pylint: disable=no-self-use
 @mock.patch('google.auth.default', return_value=['temp', 'temp'])
 @mock.patch('update_build_status.build', return_value='cloudbuild')
- @mock.patch('builds_status.upload_log')
+ @mock.patch('update_build_status.upload_log')
 def test_update_build_status(self, mocked_upload_log, mocked_cloud_build,
 mocked_google_auth):
 """"""Testing update build status as a whole.""""""
",232,19
"Catch all exceptions via (...) rather than by explicit type (#4260)

The purpose of the fuzzer is to very that an exception is thrown, not
to validate that the correct *type* of exception is thrown. That is
the responsibility of the project's traditional test suite. Therefore,
the exception type is inconsequential.

Signed-off-by: Cary Phillips <seabeepea@gmail.com>"," static void readFileSingle(IStream& is, uint64_t width, uint64_t height) {
 
 try {
 readFile(file);
- } catch (std::exception &e) {
+ } catch (...) {
 }
 
 delete file;
 static void readFileMulti(IStream& is) {
 }
 try {
 readFile(inpart);
- } catch (std::exception &e) {
+ } catch (...) {
 }
 delete inpart;
 }
",128,21
"Revert ""[CIFuzz] Allow supplying a manual source checkout (#4250)"" (#4263)

This reverts commit 55d9a81cd799f34ffbd688766aef5f463c9aac73.

Closes https://github.com/google/oss-fuzz/issues/4262"," def main():
 
 out_dir = os.path.join(workspace, 'out')
 if cifuzz.check_fuzzer_build(out_dir, sanitizer=sanitizer):
- returncode = 0
-
+ return 0
 return returncode
 
 
",51,8
"Reland 55d9a81. (#4269)

The issue with 55d9a81 that caused it to be reverted by 3370f8f
was probably due to the build trigger on GCB being stale. I've
updated it so this commit should stick."," def main():
 
 out_dir = os.path.join(workspace, 'out')
 if cifuzz.check_fuzzer_build(out_dir, sanitizer=sanitizer):
- return 0
+ returncode = 0
+
 return returncode
 
 
",51,8
Add |builds_per_day| to supported section in project.yaml. (#4291)," class ProjectYamlChecker:
 VALID_SECTION_NAMES = [
 'architectures',
 'auto_ccs',
+ 'builds_per_day',
 'coverage_extra_args',
 'disabled',
 'fuzzing_engines',
+ 'help_url',
 'homepage',
+ 'language',
+ 'labels', # For internal use only, hard to lint as it uses fuzzer names.
 'primary_contact',
 'sanitizers',
+ 'selective_unpack',
 'vendor_ccs',
 'view_restrictions',
- 'language',
- 'help_url',
- 'labels', # For internal use only, hard to lint as it uses fuzzer names.
- 'selective_unpack',
 ]
 
 LANGUAGES_SUPPORTED = [
",242,75
"Fix typo in project_sync.py (#4296)

* Fix typo in project_sync.py

* line length

* format"," def update_scheduler(cloud_scheduler_client, project, schedule):
 }
 
 update_mask = {'schedule': schedule}
- cloud_scheduler_client.update(job, update_mask)
+ cloud_scheduler_client.update_job(job, update_mask)
 
 
 # pylint: disable=too-many-branches
",163,37
"[infra][docs] Be more explicit about code coverage being supported for C/C++ only (#4284). (#4303)

* [infra][docs] Be more explicit about code coverage being supported for C/C++ only (#4284).

* fix typos and pass env variable"," CORPUS_BACKUP_URL_FORMAT = (
 
 PROJECT_LANGUAGE_REGEX = re.compile(r'\s*language\s*:\s*([^\s]+)')
 
+# Languages from project.yaml that have code coverage support.
+LANGUAGES_WITH_COVERAGE_SUPPORT = ['c', 'c++']
+
 
 def main(): # pylint: disable=too-many-branches,too-many-return-statements,too-many-statements
 """"""Get subcommand from program arguments and do it.""""""
 def coverage(args):
 if not check_project_exists(args.project_name):
 return 1
 
+ project_language = _get_project_language(args.project_name)
+ if project_language not in LANGUAGES_WITH_COVERAGE_SUPPORT:
+ print(
+ 'ERROR: Project is written in %s, coverage for it is not supported yet.'
+ % project_language,
+ file=sys.stderr)
+ return 1
+
 if not args.no_corpus_download and not args.corpus_dir:
 if not download_corpora(args):
 return 1
 
 env = [
 'FUZZING_ENGINE=libfuzzer',
+ 'FUZZING_LANGUAGE=%s' % project_language,
 'PROJECT=%s' % args.project_name,
 'SANITIZER=coverage',
 'HTTP_PORT=%s' % args.port,
",714,122
"[libavif] Cut down on post-decode combinations to avoid timeouts (#4308)

Co-authored-by: Joe Drago <jdrago@netflix.com>","
 #include ""avif/avif.h""
 
 extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) {
- static avifRGBFormat rgbFormats[] = {
- AVIF_RGB_FORMAT_RGB, AVIF_RGB_FORMAT_RGBA, AVIF_RGB_FORMAT_ARGB,
- AVIF_RGB_FORMAT_BGR, AVIF_RGB_FORMAT_BGRA, AVIF_RGB_FORMAT_ABGR};
+ static avifRGBFormat rgbFormats[] = {AVIF_RGB_FORMAT_RGB,
+ AVIF_RGB_FORMAT_RGBA};
 static size_t rgbFormatsCount = sizeof(rgbFormats) / sizeof(rgbFormats[0]);
 
 static avifChromaUpsampling upsamplings[] = {AVIF_CHROMA_UPSAMPLING_BILINEAR,
 AVIF_CHROMA_UPSAMPLING_NEAREST};
 static size_t upsamplingsCount = sizeof(upsamplings) / sizeof(upsamplings[0]);
 
- static uint32_t rgbDepths[] = {8, 10, 12, 16};
+ static uint32_t rgbDepths[] = {8, 10};
 static size_t rgbDepthsCount = sizeof(rgbDepths) / sizeof(rgbDepths[0]);
 
- static uint32_t yuvDepths[] = {8, 10, 12};
+ static uint32_t yuvDepths[] = {8, 10};
 static size_t yuvDepthsCount = sizeof(yuvDepths) / sizeof(yuvDepths[0]);
 
 avifROData raw;
",62,12
[openexr] fix memleak in scanlinefuzzer with wide images (#4356)," static void readMulti(IStream& is) {
 int w = dw.max.x - dw.min.x + 1;
 int dx = dw.min.x;
 
- if (w > (1 << 24)) return;
-
+ if (w > (1 << 24))
+ {
+ throw std::logic_error(""ignoring - very wide datawindow\n"");
+ }
 Array<Rgba> pixels(w);
 FrameBuffer i;
 i.insert(""R"", Slice(HALF, (char *)&(pixels[-dx].r), sizeof(Rgba), 0));
",77,13
"[presubmit] Allow 'none' as a fuzzing engine (#4370)

'none' is used by projects like spidermonkey that use the JS fuzzer."," class ProjectYamlChecker:
 SECTIONS_AND_CONSTANTS = {
 'sanitizers': {'address', 'none', 'memory', 'undefined', 'dataflow'},
 'architectures': {'i386', 'x86_64'},
- 'fuzzing_engines': {'afl', 'libfuzzer', 'honggfuzz', 'dataflow'},
+ 'fuzzing_engines': {'afl', 'libfuzzer', 'honggfuzz', 'dataflow', 'none'},
 }
 
 # Note: this list must be updated when we allow new sections.
",242,75
"[openexr] fix memleak in readSingle with wide images (#4380)

Signed-off-by: Peter Hillman <peter@pedro.kiwi>"," using IMATH_NAMESPACE::Box2i;
 namespace {
 
 static void readSingle(IStream& is) {
- RgbaInputFile *in = NULL;
- try {
- in = new RgbaInputFile(is);
- } catch (...) {
- return;
- }
+ try { 
 
- try {
- const Box2i &dw = in->dataWindow();
+ RgbaInputFile in(is);
+
+ const Box2i &dw = in.dataWindow();
 
 int w = dw.max.x - dw.min.x + 1;
 int dx = dw.min.x;
 static void readSingle(IStream& is) {
 if (w > (1 << 24)) return;
 
 Array<Rgba> pixels(w);
- in->setFrameBuffer(&pixels[-dx], 1, 0);
+ in.setFrameBuffer(&pixels[-dx], 1, 0);
 
- for (int y = dw.min.y; y <= dw.max.y; ++y) in->readPixels(y);
+ for (int y = dw.min.y; y <= dw.max.y; ++y) in.readPixels(y);
 } catch (...) {
 }
-
- delete in;
 }
 
 static void readMulti(IStream& is) {
",71,12
[Postgresql] Added initialization parts to fuzzers (#4357),"
 #include ""postgres.h""
 #include ""common/jsonapi.h""
 #include ""mb/pg_wchar.h""
+#include ""miscadmin.h""
 #include ""utils/memutils.h""
 #include ""utils/memdebug.h""
 
 const char *progname = ""progname"";
 ** fuzzed input.
 */
 int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
-MemoryContextInit();
 sigjmp_buf local_sigjmp_buf;
-char *buffer = (char *) calloc(size+1, sizeof(char));
+char *buffer;
+JsonSemAction sem;
+JsonLexContext *lex;
+
+buffer = (char *) calloc(size+1, sizeof(char));
 memcpy(buffer, data, size);
-JsonSemAction sem = nullSemAction;
-JsonLexContext *lex = makeJsonLexContextCstringLen(buffer, size+1, PG_UTF8, true);
+
+MemoryContextInit();
+set_stack_base();
+sem = nullSemAction;
+lex = makeJsonLexContextCstringLen(buffer, size+1, PG_UTF8, true);
+
 if(!sigsetjmp(local_sigjmp_buf,0)){
 error_context_stack = NULL;
 PG_exception_stack = &local_sigjmp_buf;
",31,2
[Nginx] Fixed fuzzer startup crash (#4399)," extern ""C"" {
 #include ""libprotobuf-mutator/src/libfuzzer/libfuzzer_macro.h""
 
 static char configuration[] =
+""user root;\n""
 ""error_log stderr emerg;\n""
 ""events {\n""
 "" use epoll;\n""
",246,19
"Add a blackbox field to project.yaml (#4405)

This is needed for CF to determine whether or not to allocate the
project on a higher end bot to run the blackbox fuzzer.

Previously this was keyed on the ""none"" entry under fuzzing_engines,
which wasn't very descriptive. This change also lets us do both blackbox
and greybox fuzzing in the same project, which will be done for quickjs."," class ProjectYamlChecker:
 VALID_SECTION_NAMES = [
 'architectures',
 'auto_ccs',
+ 'blackbox',
 'builds_per_day',
 'coverage_extra_args',
 'disabled',
",243,75
"[PostgreSQL] Fixed fuzzers (#4398)

* Fixed fuzzers

* Tar database

* New file with common initialization part

* Fixed argc/argv

* Added set_stack_base

* Fixed fuzzer_initialize.c","
 // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 // See the License for the specific language governing permissions and
 // limitations under the License.
+//
+///////////////////////////////////////////////////////////////////////////////
 
 #include ""postgres.h""
+
 #include ""common/jsonapi.h""
 #include ""mb/pg_wchar.h""
-#include ""miscadmin.h""
 #include ""utils/memutils.h""
 #include ""utils/memdebug.h""
 
-const char *progname = ""progname"";
+int __attribute__((constructor)) Initialize(void) {
+ FuzzerInitialize(""json_db"");
+ return 0;
+}
 
 /*
 ** Main entry point. The fuzzer invokes this function with each
",33,3
Remove get_username (#4418),"
 const char *progname;
 static MemoryContext row_description_context = NULL;
 static StringInfoData row_description_buf;
-static const char *username = NULL;
-
-static void fuzzer_exit(){
- if(username)
- pfree((void *) username);
-}
+static const char *username = ""username"";
 
 int FuzzerInitialize(char *dbname){
 char *argv[5];
 int FuzzerInitialize(char *dbname){
 progname = get_progname(argv[0]);
 MemoryContextInit();
 
- username = strdup(get_user_name_or_exit(progname));
- 
 InitStandaloneProcess(argv[0]);
 SetProcessingMode(InitProcessing);
 InitializeGUCOptions();
 int FuzzerInitialize(char *dbname){
 PgStartTime = GetCurrentTimestamp();
 whereToSendOutput = DestNone;
 Log_destination = 0;
- atexit(fuzzer_exit);
 return 0;
 }
",70,1
Add wrappers for getpwnam and getgrnam (#4419),"
 ////////////////////////////////////////////////////////////////////////////////
 #include <sys/socket.h>
 #include <sys/types.h>
+#include <grp.h>
+#include <pwd.h>
 
 int __wrap_connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen) {
 return 0;
 int __wrap_setsockopt(int fd, int level, int optname, const void *optval,
 socklen_t optlen) {
 return 0;
 }
+
+struct passwd *__wrap_getpwnam(const char *name){
+ struct passwd *pwd = (struct passwd *) calloc(1, sizeof(struct passwd));
+ pwd->pw_uid = 1;
+ return pwd;
+}
+
+struct group *__wrap_getgrnam(const char *name){
+ struct group *grp = (struct group *) calloc(1, sizeof(struct group));
+ grp->gr_gid = 1;
+ return grp;
+}
",26,7
"[Nginx] fixing startup crashes (#4425)

* fixing startup crashes

* Removed whitespaces"," extern ""C"" {
 #include ""libprotobuf-mutator/src/libfuzzer/libfuzzer_macro.h""
 
 static char configuration[] =
-""user root;\n""
 ""error_log stderr emerg;\n""
 ""events {\n""
 "" use epoll;\n""
",245,19
"[nginx] Fix startup crashes (#4433)

* Fix startup crashes

* Clean-up fuzzer"," static char arg1[] = {0, 0xA, 0};
 
 extern char **environ;
 
-static const char *config_file = ""http_config.conf"";
+static const char *config_file = ""/tmp/http_config.conf"";
 
 struct fuzzing_data {
 const uint8_t *data;
 DEFINE_PROTO_FUZZER(const HttpProto &input) {
 
 // Will redirect to http parser
 ngx_http_init_connection(c);
-
- // Clean-up in case of error
- if (req_reply && upstream && upstream->cleanup) {
- (*(upstream->cleanup))(req_reply);
- if (!c->destroyed)
- ngx_http_close_connection(c);
- } else if (!c->destroyed) {
- ngx_http_request_t *r = (ngx_http_request_t *)(c->data);
- ngx_http_free_request(r, 0);
- ngx_http_close_connection(c);
- }
 }
",236,14
[PostgreSQL] Fix startup crashes (#4430),"
 #include ""utils/memutils.h""
 #include ""utils/memdebug.h""
 
-int __attribute__((constructor)) Initialize(void) {
- FuzzerInitialize(""json_db"");
- return 0;
+int LLVMFuzzerInitialize(int *argc, char ***argv) {
+FuzzerInitialize(""json_db"", argv);
+return 0;
 }
 
 /*
",33,3
"[openexr] rewind streams between readSingle and readMulti (#4443)

Signed-off-by: Peter Hillman <peter@pedro.kiwi>"," extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
 std::vector<char> buffer = stream.ConsumeRemainingBytes<char>();
 
 const std::string s(buffer.data(), buffer.size());
- StdISStream is;
- is.str(s);
 
- readFileSingle(is, width, height);
- readFileMulti(is);
+ {
+ StdISStream is;
+ is.str(s);
+ readFileSingle(is, width, height);
+ }
+ {
+ StdISStream is;
+ is.str(s);
+ readFileMulti(is);
+ }
 return 0;
 }
",134,21
"bisector: early exit when old_commit == new_commit. (#4458)

But do this after computing repo_url as that's still useful information."," def _bisect(bisect_type, old_commit, new_commit, test_case_path, fuzz_target,
 if not repo_url or not repo_path:
 raise ValueError('Main git repo can not be determined.')
 
+ if old_commit == new_commit:
+ raise BisectError('old_commit is the same as new_commit', repo_url)
+
 # Copy /src from the built Docker container to ensure all dependencies
 # exist. This will be mounted when running them.
 host_src_dir = build_specified_commit.copy_src_from_docker(
",215,19
"[openexr] fix reading extra EXR channels in readMulti (#4461)

Signed-off-by: Peter Hillman <peter@pedro.kiwi>"," static void readMulti(IStream& is) {
 const ChannelList& channelList = in->header().channels();
 for (ChannelList::ConstIterator c = channelList.begin() ; c != channelList.end() ; ++c )
 {
- i.insert(c.name(),Slice(HALF, (char*)&otherChannels[0] , sizeof(half) , 0 ));
+ i.insert(c.name(),Slice(HALF, (char*)&otherChannels[-dx] , sizeof(half) , 0 ));
 } 
 
 // always try to read RGBA even if not present in file
",89,13
Set main repo for clamav. (#4466)," class ProjectYamlChecker:
 'homepage',
 'language',
 'labels', # For internal use only, hard to lint as it uses fuzzer names.
+ 'main_repo',
 'primary_contact',
 'sanitizers',
 'selective_unpack',
",244,75
"libavif: Update to the new avifIO reader API (#4472)

Fix a build failure.

BUG=25877"," extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) {
 raw.size = Size;
 
 avifDecoder *decoder = avifDecoderCreate();
- avifResult result = avifDecoderParse(decoder, &raw);
+ avifResult result = avifDecoderSetIOMemory(decoder, &raw);
+ if (result == AVIF_RESULT_OK) {
+ result = avifDecoderParse(decoder);
+ }
 if (result == AVIF_RESULT_OK) {
 for (int loop = 0; loop < 2; ++loop) {
 while (avifDecoderNextImage(decoder) == AVIF_RESULT_OK) {
",65,13
"Update to new prototype of avifDecoderSetIOMemory (#4512)

avifDecoderSetIOMemory() has been changed to take the buffer data
pointer and buffer size as input parameters."," extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) {
 static uint32_t yuvDepths[] = {8, 10};
 static size_t yuvDepthsCount = sizeof(yuvDepths) / sizeof(yuvDepths[0]);
 
- avifROData raw;
- raw.data = Data;
- raw.size = Size;
-
 avifDecoder *decoder = avifDecoderCreate();
- avifResult result = avifDecoderSetIOMemory(decoder, &raw);
+ avifResult result = avifDecoderSetIOMemory(decoder, Data, Size);
 if (result == AVIF_RESULT_OK) {
 result = avifDecoderParse(decoder);
 }
",62,13
"[CIFuzz] Don't assume fuzzer output is ASCII (#4537)

[CIFuzz] Don't assume fuzzer output is ascii

This is wrong because the output can be arbitrary. Instead change
code that deals with the output to deal with bytes. The testcase,
which is derived from the output can be decoded as UTF-8 since it
will be a unix path."," class ParseOutputUnitTest(unittest.TestCase):
 'example_crash_fuzzer_output.txt')
 test_summary_path = os.path.join(TEST_FILES_PATH, 'bug_summary_example.txt')
 with tempfile.TemporaryDirectory() as tmp_dir:
- with open(test_output_path, 'r') as test_fuzz_output:
+ with open(test_output_path, 'rb') as test_fuzz_output:
 cifuzz.parse_fuzzer_output(test_fuzz_output.read(), tmp_dir)
 result_files = ['bug_summary.txt']
 self.assertCountEqual(os.listdir(tmp_dir), result_files)
 class ParseOutputUnitTest(unittest.TestCase):
 def test_parse_invalid_output(self):
 """"""Checks that no files are created when an invalid input was given.""""""
 with tempfile.TemporaryDirectory() as tmp_dir:
- cifuzz.parse_fuzzer_output('not a valid output_string', tmp_dir)
+ cifuzz.parse_fuzzer_output(b'not a valid output_string', tmp_dir)
 self.assertEqual(len(os.listdir(tmp_dir)), 0)
 
 
",372,48
"[infra] Add code coverage report generation for Go projects (#3142)

* Golang coverage report

* Enables golang coverage report for gonids and go-dns

* Generates summary for golang coverage reports

* Performance profile for golang projects"," CORPUS_BACKUP_URL_FORMAT = (
 PROJECT_LANGUAGE_REGEX = re.compile(r'\s*language\s*:\s*([^\s]+)')
 
 # Languages from project.yaml that have code coverage support.
-LANGUAGES_WITH_COVERAGE_SUPPORT = ['c', 'c++']
+LANGUAGES_WITH_COVERAGE_SUPPORT = ['c', 'c++', 'go']
 
 
 def main(): # pylint: disable=too-many-branches,too-many-return-statements,too-many-statements
",714,122
"Initial support for ujson (as a Python fuzzing sample). (#4657)

* Initial support for ujson (as a Python fuzzing sample).

* Add python to supported languages.

* Fix TODO.

* Update presubmit to ignore python in projects.

* Format

* Remove explicit addition of -fsanitize=fuzzer-no-link

* Only fuzz using libFuzzer.

Co-authored-by: Martin Barbella <mbarbella@google.com>"," class ProjectYamlChecker:
 'c',
 'c++',
 'go',
+ 'python',
 'rust',
 ]
 
 def bool_to_returncode(success):
 return 1
 
 
-def is_python(path):
+def is_nonfuzzer_python(path):
 """"""Returns True if |path| ends in .py.""""""
- return os.path.splitext(path)[1] == '.py'
+ return os.path.splitext(path)[1] == '.py' and '/projects/' not in path
 
 
 def lint(paths):
 """"""Run python's linter on |paths| if it is a python file. Return False if it
 fails linting.""""""
- paths = [path for path in paths if is_python(path)]
+ paths = [path for path in paths if is_nonfuzzer_python(path)]
 if not paths:
 return True
 
 def yapf(paths, validate=True):
 """"""Do yapf on |path| if it is Python file. Only validates format if
 |validate| otherwise, formats the file. Returns False if validation
 or formatting fails.""""""
- paths = [path for path in paths if is_python(path)]
+ paths = [path for path in paths if is_nonfuzzer_python(path)]
 if not paths:
 return True
 
",245,76
"[infra] Allow coverage for Go project on GCB (#2817, #2714). (#4668)"," LATEST_REPORT_INFO_CONTENT_TYPE = 'application/json'
 UPLOAD_URL_FORMAT = 'gs://' + COVERAGE_BUCKET_NAME + '/{project}/{type}/{date}'
 
 # Languages from project.yaml that have code coverage support.
-LANGUAGES_WITH_COVERAGE_SUPPORT = ['c', 'c++']
+LANGUAGES_WITH_COVERAGE_SUPPORT = ['c', 'c++', 'go']
 
 
 def usage():
",198,4
"Fix test_all breakage (#4673)

Specify fuzzing language.
Intended to fix https://github.com/google/oss-fuzz/issues/4672"," def check_fuzzer_build(out_dir, sanitizer='address'):
 'SANITIZER=' + sanitizer,
 '-e',
 'ARCHITECTURE=' + DEFAULT_ARCHITECTURE,
+ '-e',
+ 'FUZZING_LANGUAGE=c++', # FIXME: Add proper support.
 ]
 
 # Set ALLOWED_BROKEN_TARGETS_PERCENTAGE in docker if specified by user.
",339,29
"Python fuzzing fixes - disable leak checking, remove flags in atheris. (#4681)

* Python fuzzing fixes - disable leak checking, remove flags in atheris.

* Fix flags printing.

* Dont export, use directly.

* Try unset.

* Unset flags when python was built."," build_install_ujson.sh), and the Python fuzzer should be executed under ASAN.
 As an example:
 LD_PRELOAD=""/usr/lib/llvm-9/lib/clang/9.0.1/lib/linux/libclang_rt.asan-x86_64.so
 $(python3 -c ""import atheris; print(atheris.path())"")"" python3
- ./ujson_fuzzer.py -detect_leaks=0
+ ./json_differential_fuzzer.py -detect_leaks=0
 
 This fuzzer has found a bug with inconsistent handling of integers with
 too-high magnitude. uJSON sometimes refuses to process numbers that are too far
",58,10
"Golang project uses compile_go_fuzzer script (#4685)

* Golang project uses compile_go_fuzzer script

* Kubernetes project uses compile_go_fuzzer script

* Adds golang to ci covergae builds

* fixup

* Golang coverage with go modules

cf coredns project"," DEFAULT_ENGINES = ['afl', 'honggfuzz', 'libfuzzer']
 DEFAULT_SANITIZERS = ['address', 'undefined']
 
 # Languages from project.yaml that have code coverage support.
-LANGUAGES_WITH_COVERAGE_SUPPORT = ['c', 'c++']
+LANGUAGES_WITH_COVERAGE_SUPPORT = ['c', 'c++', 'go']
 
 
 def get_changed_files():
",148,38
[cifuzz] disable failing test (#4700)," TEST_DIR_PATH = os.path.dirname(os.path.realpath(__file__))
 class BuildImageIntegrationTests(unittest.TestCase):
 """"""Testing if an image can be built from different states e.g. a commit.""""""
 
+ @unittest.skip('Test is failing (spuriously?).')
 def test_build_fuzzers_from_commit(self):
 """"""Tests if the fuzzers can build at a specified commit.
 
",74,6
"[CIFuzz] Set CIFUZZ env var when building/checking/running CIFuzz fuzzers. (#4699)

Fixes https://github.com/google/oss-fuzz/issues/4604"," def build_fuzzers( # pylint: disable=too-many-arguments,too-many-locals
 '-e',
 'ARCHITECTURE=' + DEFAULT_ARCHITECTURE,
 '-e',
+ 'CIFUZZ=True',
+ '-e',
 'FUZZING_LANGUAGE=c++', # FIXME: Add proper support.
 ]
 container = utils.get_container_name()
 def check_fuzzer_build(out_dir, sanitizer='address'):
 '-e',
 'ARCHITECTURE=' + DEFAULT_ARCHITECTURE,
 '-e',
+ 'CIFUZZ=True',
+ '-e',
 'FUZZING_LANGUAGE=c++', # FIXME: Add proper support.
 ]
 
",343,29
[infra] Add retry decorator and use it. (#4702)," import logging
 import re
 import shutil
 import tempfile
-import time
 
 import helper
 import repo_manager
+import retry
 import utils
 
 BuildData = collections.namedtuple(
 BuildData = collections.namedtuple(
 
 _GIT_DIR_MARKER = 'gitdir: '
 _IMAGE_BUILD_TRIES = 3
-_IMAGE_BUILD_RETRY_SLEEP = 30.0
 
 
 class BaseBuilderRepo:
 def copy_src_from_docker(project_name, host_dir):
 return src_dir
 
 
+@retry.wrap(_IMAGE_BUILD_TRIES, 2,
+ 'infra.build_specified_commit._build_image_with_retries')
 def _build_image_with_retries(project_name):
 """"""Build image with retries.""""""
-
- for _ in range(_IMAGE_BUILD_TRIES):
- result = helper.build_image_impl(project_name)
- if result:
- return result
-
- time.sleep(_IMAGE_BUILD_RETRY_SLEEP)
-
- return result
+ return helper.build_image_impl(project_name)
 
 
 def get_required_post_checkout_steps(dockerfile_path):
",259,41
Fix ujson project and infra/ for python atheris. (#4706)," def TestOneInput(input_bytes):
 original = fdp.ConsumeUnicode(sys.maxsize)
 
 try:
- json_data = json.loads(original)
 ujson_data = ujson.loads(original)
+ json_data = json.loads(original)
 except Exception as e:
 # It would be interesting to enforce that if one of the libraries throws an
 # exception, the other does too. However, uJSON accepts many invalid inputs
",58,10
"leveldb: fix memory leak in fuzzer. (#4712)

* leveldb: fix memory leak in fuzzer.

* leveldb: remove old code."," extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
 options.create_if_missing = true;
 leveldb::Status status = leveldb::DB::Open(options, ""/tmp/testdb"", &db);
 
- // for random string generation
- const uint8_t *curr_offset = data; 
- size_t curr_size = size;
-
 std::string value;
 
 // perform a sequence of calls on our db instance
 extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
 snapshot_options.snapshot = db->GetSnapshot();
 leveldb::Iterator* it = db->NewIterator(snapshot_options);
 db->ReleaseSnapshot(snapshot_options.snapshot);
+ delete it;
 } 
 else if(c == 6) { // Open and close DB
 delete db;
",68,13
Make json_differential_fuzzer produce known bugs (#4758)," def TestOneInput(input_bytes):
 
 # Uncomment these lines to ignore the errors described in the docstring of
 # this file.
- json_data = ClearAllIntegers(json_data)
- ujson_data = ClearAllIntegers(ujson_data)
+ # json_data = ClearAllIntegers(json_data)
+ # ujson_data = ClearAllIntegers(ujson_data)
 
 json_dumped = json.dumps(json_data)
 ujson_dumped = json.dumps(ujson_data)
",56,10
"[test_all] Rewrite in Python (#4769)

Rewrite test_all in python.
Bash is quite annoying to write and test.
One issue with bash is it is even worse than Python for parallelism (which may be causing #4707).
Rewrite test_all in python and optimize base-runner/Dockerfile for fast development.
Also, combine some docker layers."," def check_fuzzer_build(out_dir, sanitizer='address'):
 command += ['-e', 'OUT=' + out_dir, '--volumes-from', container]
 else:
 command += ['-v', '%s:/out' % out_dir]
- command.extend(['-t', 'gcr.io/oss-fuzz-base/base-runner', 'test_all'])
+ command.extend(['-t', 'gcr.io/oss-fuzz-base/base-runner', 'test_all.py'])
 exit_code = helper.docker_run(command)
 if exit_code:
 logging.error('Check fuzzer build failed.')
",343,29
[test_all] Fix issue where CIFuzz may use an empty string for ALLOWED_BROKEN_TARGETS_PERCENTAGE (#4778)," def get_allowed_broken_targets_percentage():
 """"""Returns the value of the environment value
 'ALLOWED_BROKEN_TARGETS_PERCENTAGE' as an int or returns a reasonable
 default.""""""
- return int(os.getenv('ALLOWED_BROKEN_TARGETS_PERCENTAGE', '10'))
+ return int(os.getenv('ALLOWED_BROKEN_TARGETS_PERCENTAGE') or '10')
 
 
 def main():
",123,32
"build_specified_commit: fallback to oldest integration commit. (#4779)

When we fail a build, we attempt to identify the first OSS-Fuzz commit
prior to the upstream commit date.

If this does not exist, we bailed out. This commit changes it such that
we at least try on the oldest integration commit."," def build_fuzzers_from_commit(commit,
 check_result=True)
 oss_fuzz_commit = oss_fuzz_commit.strip()
 if not oss_fuzz_commit:
- logging.warning('No suitable earlier OSS-Fuzz commit found.')
+ logging.info(
+ 'Could not find first OSS-Fuzz commit prior to upstream commit. '
+ 'Falling back to oldest integration commit.')
+
+ # Find the oldest commit.
+ oss_fuzz_commit, _, _ = oss_fuzz_repo_manager.git(
+ ['log', '--reverse', '--format=%H', projects_dir], check_result=True)
+
+ oss_fuzz_commit = oss_fuzz_commit.splitlines()[0].strip()
+
+ if not oss_fuzz_commit:
+ logging.error('Failed to get oldest integration commit.')
 break
 
 logging.info('Build failed. Retrying on earlier OSS-Fuzz commit %s.',
",266,41
"s/test_all/test_all.py for google cloud build. (#4783)

Fixes https://github.com/google/oss-fuzz/issues/4781"," def get_build_steps(project_name, project_yaml_file, dockerfile_lines,
 env,
 'args': [
 'bash', '-c',
- 'test_all || (echo ""{0}"" && false)'.format(failure_msg)
+ 'test_all.py || (echo ""{0}"" && false)'.format(failure_msg)
 ],
 })
 
",335,23
"Fix msan build breakage. (#4787)

Regression from
https://github.com/google/oss-fuzz/pull/4694"," def set_up_environment(work_dir):
 os.mkdir(bin_dir)
 
 dpkg_host_architecture = wrapper_utils.dpkg_host_architecture()
- wrapper_utils.CreateSymlinks(
+ wrapper_utils.create_symlinks(
 compiler_wrapper_path,
 bin_dir,
 [
 def set_up_environment(work_dir):
 msan_log_dir = os.path.join(work_dir, 'msan')
 os.mkdir(msan_log_dir)
 msan_log_path = os.path.join(msan_log_dir, 'log')
- env['MSAN_OPTIONS'] = 'halt_on_error=0:exitcode=0:report_umrs=0:log_path=' + msan_log_path
+ env['MSAN_OPTIONS'] = ('halt_on_error=0:exitcode=0:report_umrs=0:log_path=' +
+ msan_log_path)
 
 # Increase maximum stack size to prevent tests from failing.
 limit = 128 * 1024 * 1024
",314,70
"Revert msan patch (#4788)

* Revert ""Fix msan build breakage. (#4787)""

This reverts commit 8f4d1b237d55eeb6a098719f3602f89bd032b2b3.

* Revert ""Clean up MemorySanitizer library warnings (#4694)""

This reverts commit 6fc050ec9ec29534ad079c83ef4bc2f709c083df.","
 # limitations under the License.
 #
 ################################################################################
-""""""Custom options for boost1.58.""""""
+
 import package
 
 
-class Package(package.Package): # pylint: disable=too-few-public-methods
+class Package(package.Package):
 """"""boost1.58 package.""""""
 
 def __init__(self, apt_version):
 super(Package, self).__init__('boost1.58', apt_version)
 
- def pre_build(self, _source_directory, env, _custom_bin_dir): # pylint: disable=no-self-use
- """"""Pre-build configuration for boost1.58.""""""
+ def PreBuild(self, source_directory, env, custom_bin_dir):
 # Otherwise py_nonblocking.cpp fails to build.
 env['DEB_CXXFLAGS_APPEND'] += ' -std=c++98'
",7,2
"Fix helper.py (#4793)

Recently some python3-only code was added. Make code compatible with
Python2. Fixes https://github.com/google/oss-fuzz/issues/4792"," def _get_corpus_dir(project_name=''):
 """"""Creates and returns path to /corpus directory for the given project (if
 specified).""""""
 directory = os.path.join(BUILD_DIR, 'corpus', project_name)
- os.makedirs(directory, exist_ok=True)
+ if not os.path.exists(directory):
+ os.makedirs(directory)
 
 return directory
 
 def _get_output_dir(project_name=''):
 """"""Creates and returns path to /out directory for the given project (if
 specified).""""""
 directory = os.path.join(BUILD_DIR, 'out', project_name)
- os.makedirs(directory, exist_ok=True)
+ if not os.path.exists(directory):
+ os.makedirs(directory)
 
 return directory
 
 def _get_work_dir(project_name=''):
 """"""Creates and returns path to /work directory for the given project (if
 specified).""""""
 directory = os.path.join(BUILD_DIR, 'work', project_name)
- os.makedirs(directory, exist_ok=True)
+ if not os.path.exists(directory):
+ os.makedirs(directory)
 
 return directory
 
",728,126
"Make test_all.py return nonzero when there are no fuzzers. (#4796)

Make test_all.py return nonzero when there are no fuzzers.

This matches the previous behavior.
Fixes https://github.com/google/oss-fuzz/issues/4795"," def test_all(out, fuzzing_language, allowed_broken_targets_percentage):
 """"""Do bad_build_check on all fuzz targets.""""""
 # TODO(metzman): Refactor so that we can convert test_one to python.
 fuzz_targets = find_fuzz_targets(out, fuzzing_language)
+ if not fuzz_targets:
+ print('ERROR: No fuzz targets found.')
+ return False
+
 pool = multiprocessing.Pool()
 bad_build_results = pool.map(do_bad_build_check, fuzz_targets)
 broken_targets = get_broken_fuzz_targets(bad_build_results, fuzz_targets)
",126,33
"Cifuzz external build (#4656)

* Support building fuzzers for projects outside of OSS-Fuzz
* Use retry wrapper
* Fix some tests."," def copy_src_from_docker(project_name, host_dir):
 return src_dir
 
 
-@retry.wrap(_IMAGE_BUILD_TRIES, 2,
- 'infra.build_specified_commit._build_image_with_retries')
+@retry.wrap(_IMAGE_BUILD_TRIES, 2)
 def _build_image_with_retries(project_name):
 """"""Build image with retries.""""""
 return helper.build_image_impl(project_name)
",265,41
"Use print for printing stacktrace instead of using log.

This makes stacktrace more legible.

Fixes https://github.com/google/oss-fuzz/issues/4649"," def run_fuzzers( # pylint: disable=too-many-arguments,too-many-locals
 if not testcase or not stacktrace:
 logging.info('Fuzzer %s, finished running.', target.target_name)
 else:
- logging.info(b'Fuzzer %s, detected error: %s.', target.target_name,
- stacktrace)
+ utils.print(b'Fuzzer %s, detected error: %s.' % (
+ bytes(target.target_name, 'utf-8'),
+ stacktrace))
 shutil.move(testcase, os.path.join(artifacts_dir, 'test_case'))
 parse_fuzzer_output(stacktrace, artifacts_dir)
 return True, True
",441,49
"Revert ""Use print for printing stacktrace instead of using log.""

This reverts commit ecffb3f662086420d829a060bef6e11b95c586b8.

Commit should not have been committed to master."," def run_fuzzers( # pylint: disable=too-many-arguments,too-many-locals
 if not testcase or not stacktrace:
 logging.info('Fuzzer %s, finished running.', target.target_name)
 else:
- utils.print(b'Fuzzer %s, detected error: %s.' % (
- bytes(target.target_name, 'utf-8'),
- stacktrace))
+ logging.info(b'Fuzzer %s, detected error: %s.', target.target_name,
+ stacktrace)
 shutil.move(testcase, os.path.join(artifacts_dir, 'test_case'))
 parse_fuzzer_output(stacktrace, artifacts_dir)
 return True, True
",440,49
"Rename BaseRepoManager -> RepoManager. (#4800)

This was renamed in b0b99d5ccdf5e2e49cfe3138fbcf64e6fef6ea7f"," def _bisect(bisect_type, old_commit, new_commit, test_case_path, fuzz_target,
 host_src_dir = build_specified_commit.copy_src_from_docker(
 build_data.project_name, tmp_dir)
 
- bisect_repo_manager = repo_manager.BaseRepoManager(
+ bisect_repo_manager = repo_manager.RepoManager(
 os.path.join(host_src_dir, os.path.basename(repo_path)))
 commit_list = bisect_repo_manager.get_commit_list(new_commit, old_commit)
 
 def bisect(bisect_type, old_commit, new_commit, test_case_path, fuzz_target,
 fuzz_target, build_data)
 finally:
 # Clean up projects/ as _bisect may have modified it.
- oss_fuzz_repo_manager = repo_manager.BaseRepoManager(helper.OSS_FUZZ_DIR)
+ oss_fuzz_repo_manager = repo_manager.RepoManager(helper.OSS_FUZZ_DIR)
 oss_fuzz_repo_manager.git(['reset', 'projects'])
 oss_fuzz_repo_manager.git(['checkout', 'projects'])
 oss_fuzz_repo_manager.git(['clean', '-fxd', 'projects'])
",215,19
"Use print for printing stacktrace instead of using log. (#4799)

Use print for printing stacktrace instead of using log.
This makes stacktrace more legible.
Fixes https://github.com/google/oss-fuzz/issues/4649"," def run_fuzzers( # pylint: disable=too-many-arguments,too-many-locals
 if not testcase or not stacktrace:
 logging.info('Fuzzer %s, finished running.', target.target_name)
 else:
- logging.info(b'Fuzzer %s, detected error: %s.', target.target_name,
- stacktrace)
+ utils.binary_print(b'Fuzzer %s, detected error: %s.' %
+ (target.target_name.encode(), stacktrace))
 shutil.move(testcase, os.path.join(artifacts_dir, 'test_case'))
 parse_fuzzer_output(stacktrace, artifacts_dir)
 return True, True
",440,49
"[CIFuzz] Fix issue where copied repo is named incorrectly. (#4813)

[CIFuzz] Fix issue where copied repo is named incorrectly.

Make sure the cloned repo is copied correctly to the docker container
E.g. https://github.com/OpenSC/OpenSC should be coiped to $SRC/opensc.

Fixes https://github.com/google/oss-fuzz/issues/4810

Add unittest"," class InternalGithubBuilder(BaseBuilder):
 git_workspace = os.path.join(self.workspace, 'storage')
 os.makedirs(git_workspace, exist_ok=True)
 
+ # Use the same name used in the docker image so we can overwrite it.
+ image_repo_name = os.path.basename(self.image_repo_path)
+
 # Checkout project's repo in the shared volume.
 self.repo_manager = repo_manager.clone_repo_and_get_manager(
- inferred_url, git_workspace, repo_name=self.project_repo_name)
+ inferred_url, git_workspace, repo_name=image_repo_name)
 
 self.host_repo_path = self.repo_manager.repo_dir
 
 def build_fuzzers( # pylint: disable=too-many-arguments,too-many-locals
 
 Args:
 project_name: The name of the OSS-Fuzz project being built.
- project_repo_name: The name of the projects repo.
+ project_repo_name: The name of the project's repo.
 workspace: The location in a shared volume to store a git repo and build
 artifacts.
 pr_ref: The pull request reference to be built.
",441,49
"Populate a bunch of main_repo values. (#4815)

Also enforce this for future integrations."," class ProjectYamlChecker:
 'labels', # For internal use only, hard to lint as it uses fuzzer names.
 'main_repo',
 'primary_contact',
+ 'run_tests',
 'sanitizers',
 'selective_unpack',
 'vendor_ccs',
 class ProjectYamlChecker:
 
 # Note that some projects like boost only have auto-ccs. However, forgetting
 # primary contact is probably a mistake.
- REQUIRED_SECTIONS = ['primary_contact']
+ REQUIRED_SECTIONS = ['primary_contact', 'main_repo']
 
 def __init__(self, filename):
 self.filename = filename
",246,76
Fix atheris integration. (#4824)," values that are too big or too small is techincally fine; however,
 misinterpreting them is not.
 """"""
 
-import atheris
+import atheris_no_libfuzzer as atheris
 import json
 import ujson
 import sys
",56,10
"Fix pillow with new atheris changes. (#4826)

* Fix pillow with new atheris changes.

* Fix pillow in ubsan.","
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
-import atheris
+import atheris_no_libfuzzer as atheris
 import sys
 import os
 import io
",28,4
Added all the i386 syscalls as of 2.6.16rc3," char opmode= MODE_UNDEFINED;
 
 #ifdef __i386__
 
-# define NR_SYSCALLS 274
+# define NR_SYSCALLS 310
 
 # define __syscall_return(type, res) \
 do { \
",241,58
Native x86-64 support.,"
 #include <sys/time.h>
 #include <sys/types.h>
 #include <sys/wait.h>
+#include <sys/syscall.h>
 
 extern char *syscall_names[];
 
 long call5 (int nr, long a1, long a2, long a3, long a4, long a5)
 __syscall_return(long,__res);
 return __res;
 }
+#endif
 
+#ifdef __x86_64__
+#define NR_SYSCALLS 272
+long call5 (int nr, long a1, long a2, long a3, long a4, long a5)
+{
+return(syscall(nr, a1, a2, a3, a4, a5));
+}
 #endif
 
 void sighandler (int sig)
 retry:
 switch (cl) {
 case __NR_exit:
 case __NR_fork:
+#ifdef __i386__
 case __NR_sigsuspend:
-case __NR_select:
 case __NR_sigreturn:
+#endif
+case __NR_select:
 case __NR_clone:
 case __NR_rt_sigreturn:
 case __NR_exit_group:
",246,60
Use syscall() directly instead of fugly asm," char opmode= MODE_UNDEFINED;
 
 #ifdef __i386__
 # define NR_SYSCALLS 310
-
-# define __syscall_return(type, res) \
-do { \
-if ((unsigned long)(res) >= (unsigned long)(-125)) { \
-errno = -(res); \
-res = -1; \
-} \
-return (type) (res); \
-} while (0)
-
-long call5(int nr, long a1, long a2, long a3, long a4, long a5)
-{
-long __res;
-__asm__ volatile (""int $0x80""
- : ""=a"" (__res)
- : ""0"" (nr),""b"" ((long)(a1)),""c"" ((long)(a2)),
- ""d"" ((long)(a3)), ""S"" ((long)(a4)),
- ""D"" ((long)(a5)));
-__syscall_return(long,__res);
-return __res;
-}
 #endif
-
 #ifdef __x86_64__
 #define NR_SYSCALLS 272
-long call5(int nr, long a1, long a2, long a3, long a4, long a5)
-{
-return(syscall(nr, a1, a2, a3, a4, a5));
-}
 #endif
 
 void sighandler(int sig)
 long mkcall (int call)
 fflush (stdout);
 
 if (call != __NR_exit && call != __NR_pause)
-ret = call5 (call, a1, a2, a3, a4, a5);
+ret = syscall(call, a1, a2, a3, a4, a5);
 printf (""= %ld"", ret);
 
 if (ret < 0)
",244,64
Abstract some things out to per-arch header files to clean up main source.,"
 #include <sys/types.h>
 #include <sys/wait.h>
 #include <sys/syscall.h>
+#ifdef __x86_64__
+#include ""x86-64.h""
+#endif
+#ifdef __i386__
+#include ""i386.h""
+#endif
 
 extern char *syscall_names[];
 
 char *structptr=NULL;
 
 char opmode= MODE_UNDEFINED;
 
-#ifdef __i386__
-# define NR_SYSCALLS 310
-#endif
-#ifdef __x86_64__
-#define NR_SYSCALLS 272
-#endif
-
 void sighandler(int sig)
 {
 printf (""%s "", strsignal (sig));
 int main (int argc, char* argv[])
 /* Pass in address of kernel text */
 case 'k':
 opmode = MODE_REGVAL;
-#ifdef __x86_64__
-regval = 0xffffffff80100f18;
-#endif
-#ifdef __i386__
-regval = 0xc0100220;
-#endif
+regval = KERNEL_ADDR;
 break;
 
 /* Pause after each syscall */
",245,62
"Make syscall naming per-arch.
Now x86-64 resolves to the correct syscalls.","
 #ifdef __i386__
 #include ""i386.h""
 #endif
+#include ""scrashme.h""
 
-extern char *syscall_names[];
+struct syscalltable *syscalls;
 
 long res=0;
 long specificsyscall=0;
 long mkcall (int call)
 if (call >= NR_SYSCALLS)
 printf (""%d"", call);
 else
-printf (""%s"", syscall_names[call]);
+printf (""%s"", syscalls[call].name);
 printf (""(0x%lx,0x%lx,0x%lx,0x%lx,0x%lx,0x%lx) "", a1, a2, a3, a4, a5, a6);
 
 fflush (stdout);
 int main (int argc, char* argv[])
 volatile char randomtime;
 int structmode=0;
 
+#ifdef __x86_64__
+syscalls = syscalls_x86_64;
+#else
+syscalls = syscalls_i386;
+#endif
+
+
 progname = argv[0];
 
 while ((c = getopt(argc, argv, ""b:c:fjknprs:tx:z"")) != -1) {
",248,63
"Add framework for sanitising arguments before we do the syscall.
(Added an empty splice() sanitiser for now, which doesn't do
 anything particularly useful)","
+void sanitise_splice(
+unsigned long *a1,
+unsigned long *a2,
+unsigned long *a3,
+unsigned long *a4,
+unsigned long *a5,
+unsigned long *a6)
+{
+*a1 = 1;
+*a2 = 2;
+*a3 = 3;
+*a4 = 4;
+*a5 = 5;
+*a6 = 6;
+}
",15,1
Create some fd's to pass into syscalls when sanitised.,"
+#include <stdlib.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <stdio.h>
+
+/* TODO:
+ * socket fds
+ */
+static int file_user = 0;
+static int file_no_write = 0;
+
+void setup_fds(void)
+{
+if (!file_user)
+file_user = open(""tmp/testfile"", O_RDWR);
+if (file_user < 0) {
+perror(""couldn't open testfile"");
+exit(0);
+}
+if (!file_no_write)
+file_no_write = open(""tmp/testfile2"", O_RDONLY);
+if (file_no_write < 0) {
+perror(""couldn't open testfile2"");
+exit(0);
+}
+}
+
+void close_fds(void)
+{
+close(file_user);
+close(file_no_write);
+file_user = 0;
+file_no_write = 0;
+}
+
+
+int get_random_fd()
+{
+int i = rand();
+int fd = 0;
+
+switch (i & 1) {
+case 0:fd = file_user;
+break;
+case 1:fd = file_no_write;
+break;
+}
+return fd;
+}
+
",42,9
"Improve file handling.
Add primitive sanitise() to sys_read / sys_write"," static int file_no_write = 0;
 void setup_fds(void)
 {
 if (!file_user)
-file_user = open(""tmp/testfile"", O_RDWR);
+file_user = open(""tmp/testfile"", O_RDWR | O_TRUNC);
 if (file_user < 0) {
 perror(""couldn't open testfile"");
 exit(0);
 int get_random_fd()
 int i = rand();
 int fd = 0;
 
+close_fds();
+setup_fds();
+
 switch (i & 1) {
 case 0:fd = file_user;
 break;
",44,9
"Fix incorrect register setting, and loop if still 0."," void sanitise_splice(
 *a2 = get_random_fd();
 
 /* Returns 0 if !len */
-if (*a3 == 0)
-*a1 = rand();
-
+retry:
+if (*a3 == 0) {
+*a3 = rand();
+goto retry;
+}
 }
",75,9
sys_splice changed its prototype.," retry_tasksize_end:
 
 /*
 * asmlinkage long sys_splice(int fdin, int fdout, size_t len, unsigned int flags)
+ * asmlinkage long sys_splice(int fd_in, loff_t __user *off_in, int fd_out, loff_t __user *off_out, size_t len, unsigned int flags)
+ *
 * : len must be > 0
 * : fdin & fdout must be file handles
 *
 */
 void sanitise_splice(
 unsigned long *a1,
-unsigned long *a2,
-__attribute((unused)) unsigned long *a3,
+__attribute((unused)) unsigned long *a2,
+unsigned long *a3,
 __attribute((unused)) unsigned long *a4,
 __attribute((unused)) unsigned long *a5,
 __attribute((unused)) unsigned long *a6)
 void sanitise_splice(
 *a1 = get_random_fd();
 
 /* second param is fdout */
-*a2 = get_random_fd();
+*a3 = get_random_fd();
 
 /* Returns 0 if !len */
 retry:
",272,36
Make debug stuff easier to turn on/off," long mkcall (int call)
 
 if (intelligence == 1) {
 if (syscalls[call].sanitise) {
+#if 1
 printf (""\n\tSanitising options.\n\tBefore:\t"");
-printf (""(0x%lx,0x%lx,0x%lx,0x%lx,0x%lx,0x%lx)\n"", a1, a2, a3, a4, a5, a6);
+printf (""(0x%lx,0x%lx,0x%lx,0x%lx,0x%lx,0x%lx)\n\tAfter:\t"", a1, a2, a3, a4, a5, a6);
+#endif
 syscalls[call].sanitise(&a1, &a2, &a3, &a4, &a5, &a6);
-printf(""\tAfter:\t(0x%lx,0x%lx,0x%lx,0x%lx,0x%lx,0x%lx) "", a1, a2, a3, a4, a5, a6);
 }
 }
 printf (""(0x%lx,0x%lx,0x%lx,0x%lx,0x%lx,0x%lx) "", a1, a2, a3, a4, a5, a6);
",264,67
make -z and -c work together.," int main (int argc, char* argv[])
 break;
 
 case MODE_ZEROREGS:
-if (rep == NR_SYSCALLS) {
-/* Pointless running > once. */
+if (do_specific_syscall == 1) {
+zeromask++;
 if (zeromask == (1<<6)-1)
 goto done;
-rep = 0;
-zeromask++;
+} else {
+if (rep == NR_SYSCALLS) {
+/* Pointless running > once. */
+if (zeromask == (1<<6)-1)
+goto done;
+rep = 0;
+zeromask++;
+}
 }
 break;
 
",270,69
Fix several off-by-ones," long mkcall (int call)
 a6 = getrand();
 break;
 }
-if (call >= NR_SYSCALLS)
+if (call > NR_SYSCALLS)
 printf (""%d"", call);
 else
 printf (""%s"", syscalls[call].name);
 int main (int argc, char* argv[])
 for (;;) {
 switch (opmode) {
 case MODE_REGVAL:
-if (rep == NR_SYSCALLS)
+if (rep > NR_SYSCALLS)
 goto done;
 break;
 
 int main (int argc, char* argv[])
 if (zeromask == (1<<6)-1)
 goto done;
 } else {
-if (rep == NR_SYSCALLS) {
+if (rep > NR_SYSCALLS) {
 /* Pointless running > once. */
 if (zeromask == (1<<6)-1)
 goto done;
 int main (int argc, char* argv[])
 structptr[i]= rand();
 break;
 }
-if (rep == NR_SYSCALLS)
+if (rep > NR_SYSCALLS)
 goto done;
 break;
 }
",270,69
"Add a missing flush, which fixes output when redirected."," long mkcall (int call)
 printf ("" %s\n"", strerror (errno));
 else
 printf (""\n"");
+fflush (stdout);
 return ret;
 }
 
",271,69
Fix up a bunch of splint warnings.," void setup_fds(void)
 }
 }
 
-void close_fds(void)
+static void close_fds(void)
 {
-close(file_user);
-close(file_no_write);
+if (close(file_user)==-1) {
+perror(""close file_user"");
+exit(EXIT_FAILURE);
+}
+if (close(file_no_write)==-1) {
+perror(""close file_nowrite"");
+exit(EXIT_FAILURE);
+}
 file_user = 0;
 file_no_write = 0;
 }
",50,11
Fix up implicit declaration,"
 #include <stdlib.h>
 #include <unistd.h>
 #include <limits.h>
+#include <string.h>
 #include ""files.h""
+
 #ifdef __x86_64__
 #define TASK_SIZE (0x800000000000UL - 4096)
 #endif
",286,37
Fix up prototype that sparse warned about," static void close_fds(void)
 }
 
 
-int get_random_fd()
+int get_random_fd(void)
 {
 int i = rand();
 int fd = 0;
",50,11
sync_file_range sanitisation," void sanitise_tee(
 *a2 = get_random_fd();
 }
 
+/*
+ * asmlinkage long sys_sync_file_range(int fd, loff_t offset, loff_t nbytes, unsigned int flags)
+ * flags must be part of VALID_FLAGS (SYNC_FILE_RANGE_WAIT_BEFORE|SYNC_FILE_RANGE_WRITE| SYNC_FILE_RANGE_WAIT_AFTER)
+ */
+
+#define SYNC_FILE_RANGE_WAIT_BEFORE 1
+#define SYNC_FILE_RANGE_WRITE 2
+#define SYNC_FILE_RANGE_WAIT_AFTER 4
+
+#define VALID_SFR_FLAGS (SYNC_FILE_RANGE_WAIT_BEFORE|SYNC_FILE_RANGE_WRITE|SYNC_FILE_RANGE_WAIT_AFTER)
+
+void sanitise_sync_file_range(
+unsigned long *fd,
+long *offset,
+long *nbytes,
+unsigned long *flags,
+__unused unsigned long *a5,
+__unused unsigned long *a6)
+{
+*fd = get_random_fd();
+
+retry_flags:
+if (*flags & ~VALID_SFR_FLAGS) {
+*flags = rand() & VALID_SFR_FLAGS;
+goto retry_flags;
+}
+
+retry_offset:
+if (*offset < 0) {
+*offset = rand();
+goto retry_offset;
+}
+
+if (*offset+*nbytes < 0)
+goto retry_offset;
+
+if (*offset+*nbytes < *offset)
+goto retry_offset;
+}
+
",310,42
Make some vars unsigned," static struct syscalltable *syscalls;
 static long res=0;
 static long specificsyscall=0;
 static long regval=0;
-static char zeromask=0;
 static char *progname=NULL;
-static char dopause=0;
-static char intelligence=0;
 static char *structptr=NULL;
-static char do_specific_syscall=0;
+static unsigned char zeromask=0;
+static unsigned char dopause=0;
+static unsigned char intelligence=0;
+static unsigned char do_specific_syscall=0;
 
 #define MODE_UNDEFINED 0
 #define MODE_RANDOM 1
",290,75
Remove some pointless checks that actually broke things.," int main (int argc, char* argv[])
 usage();
 }
 
-seteuid(65536);
-seteuid(65536);
-if (setgid(65536) == -1) {
-perror(""setgid"");
-exit(EXIT_FAILURE);
-}
-seteuid(65536);
-
-for (i=0; i<512; i++) {
+for (i=1; i<512; i++) {
 struct sigaction sa;
 sigset_t ss;
 
 int main (int argc, char* argv[])
 sa.sa_flags = SA_RESTART;
 sa.sa_handler = sighandler;
 sa.sa_mask = ss;
-if (sigaction(i, &sa, NULL) == -1) {
-perror(""sigaction"");
-exit(EXIT_FAILURE);
-}
+(void)(sigaction(i, &sa, NULL) == -1);
 }
 (void)signal(SIGCHLD, SIG_IGN);
 
",280,73
Remove some more crap.," int main (int argc, char* argv[])
 struct sigaction sa;
 sigset_t ss;
 
-if (sigfillset(&ss) == -1) {
-perror(""sigfillset"");
-exit(EXIT_FAILURE);
-}
+(void)sigfillset(&ss);
 sa.sa_flags = SA_RESTART;
 sa.sa_handler = sighandler;
 sa.sa_mask = ss;
-(void)(sigaction(i, &sa, NULL) == -1);
+(void)sigaction(i, &sa, NULL);
 }
 (void)signal(SIGCHLD, SIG_IGN);
 
",277,72
re-add the priv dropping in case we get run as root.," int main (int argc, char* argv[])
 usage();
 }
 
+seteuid(65536);
+seteuid(65536);
+(void)setgid(65536);
+seteuid(65536);
+
 for (i=1; i<512; i++) {
 struct sigaction sa;
 sigset_t ss;
",281,72
PowerPC Support from Jarod Wilson.,"
 #ifdef __i386__
 #include ""i386.h""
 #endif
+#ifdef __ppc__
+#include ""ppc.h""
+#endif
 #include ""scrashme.h""
 #include ""files.h""
 
",282,72
More PowerPC fixes from Jarod.,"
 * default 0x40000000 if VMSPLIT_1G
 */
 #endif
+#ifdef __powerpc__
+#define PAGE_OFFSET 0xC0000000
+#define TASK_SIZE (PAGE_OFFSET)
+#endif
 
 static char * filebuffer = NULL;
 static unsigned long filebuffersize = 0;
",310,42
Fix sigsuspend hang on ppc.," retry:
 switch (cl) {
 case __NR_exit:
 case __NR_fork:
-#ifdef __i386__
+#ifndef __x86_64__
 case __NR_sigsuspend:
 case __NR_sigreturn:
 #endif
",283,72
Add vmsplice sanitisation," retry_offset:
 goto retry_offset;
 }
 
+/*
+ * asmlinkage long sys_vmsplice(int fd, const struct iovec __user *iov,
+ * unsigned long nr_segs, unsigned int flags)
+ */
+
+void sanitise_vmsplice(
+unsigned long *fd,
+__unused unsigned long *a2,
+__unused unsigned long *a3,
+__unused unsigned long *a4,
+__unused unsigned long *a5,
+__unused unsigned long *a6)
+{
+*fd = get_random_fd();
+}
",320,43
sanitise set_robust_list," retry_offset:
 goto retry_offset;
 }
 
+/*
+ * asmlinkage long sys_set_robust_list(struct robust_list_head __user *head,
+ * size_t len)
+*/
+struct robust_list {
+struct robust_list *next;
+};
+struct robust_list_head {
+struct robust_list list;
+long futex_offset;
+struct robust_list *list_op_pending;
+};
+
+void sanitise_set_robust_list(
+__unused unsigned long *a1,
+unsigned long *len,
+__unused unsigned long *a3,
+__unused unsigned long *a4,
+__unused unsigned long *a5,
+__unused unsigned long *a6)
+{
+*len = sizeof(struct robust_list_head);
+}
+
+
 /*
 * asmlinkage long sys_vmsplice(int fd, const struct iovec __user *iov,
 * unsigned long nr_segs, unsigned int flags)
",338,44
"Vastly simplify the file handling for -i
Now only uses a single file per-process."," retry:
 switch (cl) {
 case __NR_exit:
 case __NR_fork:
+case __NR_vfork:
 #ifndef __x86_64__
 case __NR_sigsuspend:
 case __NR_sigreturn:
 int main (int argc, char* argv[])
 printf (""%i: "", rep);
 (void)alarm(1);
 do_call(rep);
+if (intelligence==1)
+close_fds();
 _exit(0);
 }
 (void)waitpid(-1, NULL, 0);
",277,72
Add some more -C flags for x86-64," int main (int argc, char* argv[])
 if (rep > NR_SYSCALLS)
 goto done;
 if (syscalls[rep].flags & CAPABILITY_CHECK) {
-if (do_syscall(rep) != -EPERM) {
+int r;
+r = do_syscall(rep);
+if (r != -EPERM)
 printf (""Didn't return EPERM!\n"");
-}
 }
 break;
 
",301,79
"Flush after doing the syscall
(Stuff was getting lost, especially when running multiple copies
at the same time)"," static long mkcall(int call)
 printf("" %s\n"", strerror (errno));
 else
 printf(""\n"");
+(void)fflush(stdout);
 return ret;
 }
 
",302,79
IA64 support from Jarod Wilson.,"
 #define PAGE_OFFSET 0xC0000000
 #define TASK_SIZE (PAGE_OFFSET)
 #endif
+#ifdef __ia64__
+#define PAGE_OFFSET 0xe000000000000000
+#define TASK_SIZE 0xa000000000000000
+#endif
 
 static char * filebuffer = NULL;
 static unsigned long filebuffersize = 0;
",338,44
Clean up the per-arch 'skip this syscall' handling.," static int do_syscall(int cl)
 retry:
 cl = rand() / (RAND_MAX/NR_SYSCALLS);
 
-switch (cl) {
-case __NR_exit:
-#ifndef __ia64__
-case __NR_fork:
-case __NR_vfork:
-#ifndef __x86_64__
-case __NR_sigsuspend:
-case __NR_sigreturn:
-#endif
-#endif
-case __NR_select:
-case __NR_clone:
-case __NR_rt_sigreturn:
-case __NR_exit_group:
-goto retry;
-default:
-break;
-}
+if (syscalls[cl].flags & AVOID_SYSCALL)
+goto retry;
+
 (void)alarm(2);
 
 if (do_specific_syscall != 0)
",293,73
"PAGE_MASK may not be in the headers, work it out by hand."," void sanitise_mprotect(
 __unused unsigned long *a6)
 {
 unsigned long end;
+unsigned long mask = ~ (getpagesize() -1);
 int grows;
 
 retry_prot:
 retry_prot:
 }
 
 retry_start:
-if (*a1 & ~PAGE_MASK) {
-*a1 &= PAGE_MASK;
+if (*a1 & ~mask) {
+*a1 &= mask;
 goto retry_start;
 }
 
 void sanitise_mremap(
 unsigned long *a5,
 __unused unsigned long *a6)
 {
+unsigned long mask = ~ (getpagesize() -1);
+
 retry_flags:
 if (*a4 & ~(MREMAP_FIXED | MREMAP_MAYMOVE)) {
 *a4 = rand();
 retry_flags:
 }
 
 retry_addr:
-if (*a1 & ~PAGE_MASK) {
-*a1 &= PAGE_MASK;
+if (*a1 & ~mask) {
+*a1 &= mask;
 goto retry_addr;
 }
 
 retry_newlen:
 }
 
 if (*a4 & MREMAP_FIXED) {
-*a5 &= PAGE_MASK;
+*a5 &= mask;
 
 if (!(*a4 & MREMAP_MAYMOVE))
 *a4 &= ~MREMAP_MAYMOVE;
",340,44
Remove unneeded checks now that this is done by .flags," static long mkcall(int call)
 
 (void)fflush(stdout);
 
-#ifndef __ia64__
-if (call != __NR_exit && call != __NR_pause)
-#else
-if (call != __NR_exit)
-#endif
-ret = syscall(call, a1, a2, a3, a4, a5);
+ret = syscall(call, a1, a2, a3, a4, a5);
 printf(""= %ld"", ret);
 
 if (ret < 0)
",291,70
IA64 syscalls start at 1024 for god knows what reason.," static long mkcall(int call)
 
 (void)fflush(stdout);
 
+/* IA64 is retarde^Wspecial. */
+#ifdef __ia64__
+call += 1024;
+#endif
+
 ret = syscall(call, a1, a2, a3, a4, a5);
 printf(""= %ld"", ret);
 
",292,71
"Initial sparc port.

Signed-off-by: David S. Miller <davem@davemloft.net>","
 #define PAGE_OFFSET 0xe000000000000000
 #define TASK_SIZE 0xa000000000000000
 #endif
+#ifdef __sparc__
+#ifdef __arch64__
+#define TASK_SIZE ~0UL
+#else
+#define TASK_SIZE 0xF0000000UL
+#endif
+#endif
 
 static char * filebuffer = NULL;
 static unsigned long filebuffersize = 0;
",340,44
Don't use max. syscallcount unless it is specified. <bag it>," int main (int argc, char* argv[])
 }
 rep++;
 execcount++;
-if (execcount >= syscallcount)
+if (syscallcount && (execcount >= syscallcount))
 break;
 }
 
",317,76
"Remove unnecessary volatile.
Noted by Randy Dunlap."," static void do_syscall_from_child(int cl)
 
 int main (int argc, char* argv[])
 {
-volatile int rep=0;
+int rep=0;
 int c=0, i;
 int structmode=0;
 
",317,76
Make sure we always pass a struct of page size.,"
 #include <limits.h>
 #include <string.h>
 #include ""files.h""
+#include ""scrashme.h""
 
 #ifdef __x86_64__
 #define TASK_SIZE (0x800000000000UL - 4096)
 void sanitise_mprotect(
 __unused unsigned long *a6)
 {
 unsigned long end;
-unsigned long mask = ~ (getpagesize() -1);
+unsigned long mask = ~(page_size-1);
 int grows;
 
 retry_prot:
 void sanitise_mremap(
 unsigned long *a5,
 __unused unsigned long *a6)
 {
-unsigned long mask = ~ (getpagesize() -1);
+unsigned long mask = ~(page_size-1);
 
 retry_flags:
 if (*a4 & ~(MREMAP_FIXED | MREMAP_MAYMOVE)) {
",341,44
Don't repeatedly call ni_syscall," static long mkcall(int call)
 else
 printf(""\n"");
 (void)fflush(stdout);
+
+/* If the syscall doesn't exist don't bother calling it next time. */
+if (ret == -ENOSYS)
+syscalls[call].flags |= AVOID_SYSCALL;
+
 return ret;
 }
 
",354,84
Return a pipe where necessary.,"
 * socket fds
 */
 static int file_user = 0;
+static int pipes[2];
 
 void setup_fds(void)
 {
 retry:
 file_user = mkstemp(filename);
 if (!file_user)
 goto retry;
+
+if (pipe(pipes) < 0) {
+perror(""pipe fail.\n"");
+exit(EXIT_FAILURE);
+}
 }
 
 void close_fds(void)
 void close_fds(void)
 
 int get_random_fd(void)
 {
-return file_user;
+int i = random();
+
+switch (i % 3) {
+case 0:return pipes[0];
+case 1:return pipes[1];
+case 2:
+case 3:return file_user;
+}
+
+return 0;
 }
 
+int get_pipe_fd(void)
+{
+if (random() % 1)
+return pipes[0];
+else
+return pipes[1];
+}
",44,11
Accept a syscall name as an argument to -c," static void parse_args (int argc, char *argv[])
 case 'c':
 do_specific_syscall = 1;
 specificsyscall = strtol(optarg, NULL, 10);
+if (specificsyscall == 0) {
+/* If we get here, it wasn't a numeric syscall.
+ * Perhaps someone is passing a syscall name.
+ * Try and match. */
+
+for (i=0; i<NR_SYSCALLS; i++) {
+if (strcmp(optarg, syscalls[i].name) == 0) {
+printf(""Found %s at %d\n"", syscalls[i].name, i);
+specificsyscall = i;
+break;
+}
+}
+if (i==NR_SYSCALLS) {
+printf (""Unable to parse syscall number\n"");
+exit(1);
+}
+}
 break;
 
 case 'C':
",367,88
"sanitise_vmsplice improvements.
- pass a pipe
- limit iovec size"," void sanitise_vmsplice(
 __unused unsigned long *a5,
 __unused unsigned long *a6)
 {
-*fd = get_random_fd();
+new_a3:*a3 = random();
+if (*a3 > 1024)/* UIO_MAXIOV */
+goto new_a3;
+
+*fd = get_pipe_fd();
 }
",344,45
Remove unnecessary (and bogus) include," void sanitise_mmap(
 * sys_mprotect(unsigned long start, size_t len, unsigned long prot)
 */
 #include <sys/mman.h>
-#include <asm/page.h>
 #define PROT_SEM 0x8
 
 void sanitise_mprotect(
",343,45
Beginnings of some sendto fuzzing.," new_a3:*a3 = random();
 
 *fd = get_pipe_fd();
 }
+
+#include <sys/types.h>
+#include <sys/socket.h>
+void sanitise_sendto(unsigned long *fd,
+__unused unsigned long *buff,
+__unused unsigned long *len,
+__unused unsigned long *flags,
+__unused unsigned long *addr,
+__unused unsigned long *addr_len)
+{
+int domain, type, protocol;
+retry:
+domain = random() % 34;
+type = random() % 10;
+protocol = random();
+
+*fd = socket(domain, type, protocol);
+if (*fd == -1UL)
+goto retry;
+
+*addr_len = random() % 10;
+}
+
",362,47
pass useraddr to sanitise_sendto," void sanitise_sendto(unsigned long *fd,
 __unused unsigned long *buff,
 __unused unsigned long *len,
 __unused unsigned long *flags,
-__unused unsigned long *addr,
-__unused unsigned long *addr_len)
+unsigned long *addr,
+unsigned long *addr_len)
 {
 int domain, type, protocol;
 retry:
 retry:
 if (*fd == -1UL)
 goto retry;
 
-*addr_len = random() % 10;
-}
+*addr = (unsigned long)useraddr;
 
+*addr_len = random() % 128;// MAX_SOCK_ADDR
+}
",363,47
Set the alarm once. Also increase it slightly.," retry:
 if (syscalls[cl].flags & AVOID_SYSCALL)
 goto retry;
 
-(void)alarm(2);
+(void)alarm(3);
 
 if (do_specific_syscall != 0)
 cl = specificsyscall;
 static void do_syscall_from_child(int cl)
 {
 if (fork() == 0) {
 printf (""%i: "", cl);
-(void)alarm(1);
 
 do_syscall(cl);
 if (intelligence==1)
",387,93
Update syscall lists to 2.6.26rc3," void sanitise_read(
 __unused unsigned long *a5,
 __unused unsigned long *a6)
 {
-unsigned long newsize = ((unsigned int) *a3) >>8;
+unsigned long newsize = (unsigned int) *a3 >> 16;
 
 *a1 = get_random_fd();
 
",363,47
Add --list for debugging purposes.," static void do_syscall_from_child(int cl)
 (void)waitpid(-1, NULL, 0);
 }
 
+static void syscall_list()
+{
+int i;
+
+for (i=0; i<=NR_SYSCALLS; i++) {
+ printf(""%i: %s\n"", i, syscalls[i].name);
+}
+}
+
 static void parse_args(int argc, char *argv[])
 {
 int i;
 int opt;
 
 struct option longopts[] = {
+{ ""list"", optional_argument, NULL, 'L' },
 { ""help"", no_argument, NULL, 'h' },
 { ""mode"", required_argument, NULL, 'm' },
 { NULL, 0, NULL, 0 } };
 
-while ((opt = getopt_long(argc, argv, ""b:c:hikN:m:pPs:S:ux:z"", longopts, NULL)) != -1) {
+while ((opt = getopt_long(argc, argv, ""b:c:hikLN:m:pPs:S:ux:z"", longopts, NULL)) != -1) {
 switch (opt) {
 default:
 case '\0':
 static void parse_args(int argc, char *argv[])
 setup_fds();
 break;
 
+case 'L':
+syscall_list();
+exit(EXIT_SUCCESS);
+break;
+
 /* Pass in address of kernel text */
 case 'k':
 passed_type = TYPE_VALUE;
",452,105
Fix some off by one errors," static void parse_args(int argc, char *argv[])
  * Perhaps someone is passing a syscall name.
  * Try and match. */
 
-for (i=0; i<NR_SYSCALLS; i++) {
+for (i=0; i<=NR_SYSCALLS; i++) {
 if (strcmp(optarg, syscalls[i].name) == 0) {
 printf(""Found %s at %d\n"", syscalls[i].name, i);
 specificsyscall = i;
 break;
 }
 }
-if (i==NR_SYSCALLS) {
+if (i==NR_SYSCALLS+1) {
 printf (""Unable to parse syscall number\n"");
 exit(1);
 }
",452,105
"Check poison /after/ doing the syscall, duh."," static long mkcall(int call)
 printf(""(0x%lx,0x%lx,0x%lx,0x%lx,0x%lx,0x%lx) "", a1, a2, a3, a4, a5, a6);
 (void)fflush(stdout);
 
+/* IA64 is retarde^Wspecial. */
+#ifdef __ia64__
+call += 1024;
+#endif
+
+ret = syscall(call, a1, a2, a3, a4, a5);
+printf(""= %ld"", ret);
+
+if (ret < 0)
+printf("" %s\n"", strerror (errno));
+else
+printf(""\n"");
+(void)fflush(stdout);
+
 if (check_poison==1) {
 for (i = 0; i < 4096; i++) {
 if (userbuffer[i]!=poison)
 static long mkcall(int call)
 }
 }
 
-/* IA64 is retarde^Wspecial. */
-#ifdef __ia64__
-call += 1024;
-#endif
-
-ret = syscall(call, a1, a2, a3, a4, a5);
-printf(""= %ld"", ret);
-
-if (ret < 0)
-printf("" %s\n"", strerror (errno));
-else
-printf(""\n"");
-(void)fflush(stdout);
 
 /* If the syscall doesn't exist don't bother calling it next time. */
 if (ret == -ENOSYS)
",452,105
Check during startup that all ni_syscall's actually return ENOSYS," done: ;
 
 int main(int argc, char* argv[])
 {
+int i;
+int ret;
+
 #ifdef __x86_64__
 syscalls = syscalls_x86_64;
 #elif __powerpc__
 int main(int argc, char* argv[])
 
 progname = argv[0];
 
+/* Sanity test. All NI_SYSCALL's should return ENOSYS. */
+for (i=0; i<=NR_SYSCALLS; i++) {
+if (syscalls[i].flags & NI_SYSCALL) {
+ret = syscall(i);
+if (ret == -1) {
+if (errno != ENOSYS) {
+printf(""syscall %d (%s) should be ni_syscall, but returned %d(%s) !\n"",
+i, syscalls[i].name, errno, strerror(errno));
+exit(EXIT_FAILURE);
+}
+}
+}
+}
+
 if (argc==1)
 usage();
 
+
 init_buffer();
 
 parse_args(argc, argv);
",508,122
Step 1 of generic sanitisation,"
 #include ""scrashme.h""
 #include ""files.h""
 
-static struct syscalltable *syscalls;
+struct syscalltable *syscalls;
 
 static int rep=0;
 static long res=0;
 static long mkcall(int call)
 }
 
 if (intelligence == 1) {
+generic_sanitise(call, &a1, &a2, &a3, &a4, &a5, &a6);
 if (syscalls[call].sanitise) {
 #if 1
 printf(""\n\tSanitising options.\n\tBefore:\t"");
 static long mkcall(int call)
 
 ret = syscall(call, a1, a2, a3, a4, a5);
 
-#define RED""[1;31m""
-#define GREEN""[1;32m""
-#define WHITE""[1;37m""
-
 if (ret < 0) {
 printf(RED "" %s\n"" WHITE, strerror (errno));
 shm->failures++;
",541,126
exit child with the return code from the syscall," retry:
 
 static void do_syscall_from_child(int cl)
 {
+int ret;
+
 if (fork() == 0) {
 printf (""%i: "", cl);
 
-do_syscall(cl);
+ret = do_syscall(cl);
 if (intelligence==1)
 close_fds();
-_exit(EXIT_SUCCESS);
+_exit(ret);
 }
 (void)waitpid(-1, NULL, 0);
 }
",542,126
ignore window changed signals," static void run_setup(void)
 sa.sa_mask = ss;
 (void)sigaction(i, &sa, NULL);
 }
+(void)signal(SIGWINCH, SIG_IGN);
 (void)signal(SIGCHLD, SIG_IGN);
 (void)signal(SIGINT, ctrlc);
 
",572,135
don't bruteforce ni_syscall," retry_same:
 
 /* Brute force the same syscall until it succeeds */
 if ((opmode == MODE_RANDOM) && (intelligence == 1) && (bruteforce == 1)) {
+// Don't bother trying to bruteforce ni_syscall
+if (res == -ENOSYS)
+goto failed_repeat;
+
 if (retrycount == 100) {
 //printf(""100 retries done without success. moving on\n"");
 goto failed_repeat;
",574,136
always print out the pre/post sanitised options," static long mkcall(int call)
 }
 
 if (intelligence == 1) {
+printf(""\n\tSanitising options.\n\tBefore:\t""
+""(0x%lx,0x%lx,0x%lx,0x%lx,0x%lx,0x%lx)\n"", a1, a2, a3, a4, a5, a6);
+
 generic_sanitise(call, &a1, &a2, &a3, &a4, &a5, &a6);
-if (syscalls[call].sanitise) {
-#if 1
-printf(""\n\tSanitising options.\n\tBefore:\t"");
-printf(""(0x%lx,0x%lx,0x%lx,0x%lx,0x%lx,0x%lx)\n\tAfter:\t"", a1, a2, a3, a4, a5, a6);
-#endif
+if (syscalls[call].sanitise)
 syscalls[call].sanitise(&a1, &a2, &a3, &a4, &a5, &a6);
-}
+
+printf(""\tAfter:\t""
+""(0x%lx,0x%lx,0x%lx,0x%lx,0x%lx,0x%lx)\n"", a1, a2, a3, a4, a5, a6);
 }
 
 if (syscalls[call].num_args == 1)
",575,135
Remove the length setting (now set generically)," retry_start:
 goto retry_start;
 }
 
-/* len must be >0 */
-retry_len:
-if (*a2 == 0) {
-*a2 = rand();
-goto retry_len;
-}
-
 /* End must be after start */
 retry_end:
 end = *a1 + *a2;
 void sanitise_mremap(
 
 *addr &= mask;
 
-if (!*new_len)
-*new_len = rand();
-
 i=0;
 if (*flags & MREMAP_FIXED) {
 *flags &= ~MREMAP_MAYMOVE;
 void sanitise_splice(
 
 /* third param is fdout */
 *a3 = get_pipe_fd();
-
-/* Returns 0 if !len */
-retry:
-if (*a5 == 0) {
-*a5 = rand();
-goto retry;
-}
 }
 
 
 retry:
 
 *addr = (unsigned long)useraddr;
 
-*addr_len = random() % 128;// MAX_SOCK_ADDR
+*addr_len %= 128;// MAX_SOCK_ADDR
 }
",327,68
"Add ARG_ADDRESS

This required a bunch of assorted cleanups, including some header
file reorganisation.","
 #include <sys/ipc.h>
 #include <sys/shm.h>
 
-#ifdef __x86_64__
-#include ""x86-64.h""
-#endif
-#ifdef __i386__
-#include ""i386.h""
-#endif
-#ifdef __powerpc__
-#include ""ppc.h""
-#endif
-#ifdef __ia64__
-#include ""ia64.h""
-#endif
-#ifdef __sparc__
-#include ""sparc.h""
-#endif
+#include ""arch.h""
+#include ""arch-syscalls.h""
 #include ""scrashme.h""
 #include ""files.h""
 
",572,135
"reseed the random generator in the child

otherwise every child gets the same sequence of random ints."," static void sighandler(int sig)
 static unsigned long getrand()
 {
 unsigned long r;
+
 r = (unsigned long)rand();
 r *= (unsigned long)rand();
 return r;
 static void usage(void)
 exit(EXIT_SUCCESS);
 }
 
-
-static int do_syscall(int cl)
+static void seed_from_tod()
 {
 struct timeval t;
-int retrycount = 0;
 
 gettimeofday(&t, 0);
 seed = t.tv_sec * t.tv_usec;
 srand(seed);
+}
+
+static int do_syscall(int cl)
+{
+int retrycount = 0;
+
+seed_from_tod();
 
 if (opmode == MODE_RANDOM)
 retry:
 failed_repeat:
 return res;
 }
 
-
 static void do_syscall_from_child(int cl)
 {
 int ret;
 static void do_syscall_from_child(int cl)
 if (fork() == 0) {
 printf (""%i: "", cl);
 
+seed_from_tod();
 ret = do_syscall(cl);
 if (intelligence==1)
 close_fds();
",603,142
"duh, we don't need to do it twice."," static void do_syscall_from_child(int cl)
 if (fork() == 0) {
 printf (""%i: "", cl);
 
-seed_from_tod();
 ret = do_syscall(cl);
 if (intelligence==1)
 close_fds();
",602,142
"things are getting cluttered in some modes, add a newline after each syscall"," static long mkcall(int call)
 if (ret == -ENOSYS)
 syscalls[call].flags |= AVOID_SYSCALL;
 
+printf(""\n"");
 return ret;
 }
 
",596,141
fanotify_mark wants a 32bit mask," retry:
 
 *addr_len %= 128;// MAX_SOCK_ADDR
 }
+
+void sanitise_fanotify_mark(
+__unused unsigned long *a1,
+__unused unsigned long *a2,
+unsigned long *a3,
+__unused unsigned long *a4,
+__unused unsigned long *a5,
+__unused unsigned long *a6)
+{
+*a3 &= 0xffffffff;
+}
",335,72
increase the random range so we use all the switch cases.," static unsigned long get_interesting_value()
 {
 int i;
 
-i = rand() & 10;
+i = rand() & 20;
 
 switch (i) {
 /* 32 bit */
",335,72
fix the prot argument of mprotect if GROWSUP and GROWSDOWN are both set.," void sanitise_mprotect(
 {
 unsigned long end;
 unsigned long mask = ~(page_size-1);
+int grows;
 
 *a1 &= mask;
 
 retry_end:
 goto retry_end;
 }
 
+retry_prot:
 *a3 &= ((PROT_GROWSDOWN|PROT_GROWSUP) | ~(PROT_READ | PROT_WRITE | PROT_EXEC | PROT_SEM));
+
+grows = *a3 & (PROT_GROWSDOWN|PROT_GROWSUP);
+
+if (grows == (PROT_GROWSDOWN|PROT_GROWSUP)) { /* can't be both */
+*a3 &= rand();
+goto retry_prot;
+}
 }
 
 
",342,73
pass pids to args that want them.," static unsigned long get_address()
 }
 
 
+static unsigned int get_pid()
+{
+int i;
+i = rand() % 2;
+
+switch (i) {
+case 0:return getpid();
+case 1:return rand();
+case 2: break;
+}
+return 0;
+}
+
+
 static unsigned long fill_arg(int argtype)
 {
 int fd;
 static unsigned long fill_arg(int argtype)
 return get_interesting_value();
 case ARG_ADDRESS:
 return get_address();
+case ARG_PID:
+return get_pid();
 }
 
 return 0x5a5a5a5a;/* Should never happen */
",355,78
syscall()'s retval is an int," static long mkcall(int call)
 {
 unsigned long olda1=0, olda2=0, olda3=0, olda4=0, olda5=0, olda6=0;
 unsigned long a1=0, a2=0, a3=0, a4=0, a5=0, a6=0;
-long ret = 0;
+int ret = 0;
 int i, j;
 int poisoned = 0;
 
 static long mkcall(int call)
 ret = syscall(call, a1, a2, a3, a4, a5);
 
 if (ret < 0) {
-printf(RED "" %s\n"" WHITE, strerror (errno));
+printf(RED ""= %d (%s)\n"" WHITE, ret, strerror(errno));
 shm->failures++;
 } else {
-printf(GREEN ""= %ld\n"" WHITE, ret);
+printf(GREEN ""= %d\n"" WHITE, ret);
 shm->successes++;
 }
 (void)fflush(stdout);
",635,152
"First attempt at making 32bit syscalls work in 64bit.

Danger: ugly hacks.

Doesn't actually work properly yet either.
- 6 arg 32bit syscalls missing.
- needs structure updates"," static unsigned long get_interesting_value()
 {
 int i;
 
+#ifdef __64bit__
 i = rand() & 20;
+#else
+i = rand() & 6;
+#endif
 
 switch (i) {
 /* 32 bit */
 static unsigned long get_interesting_value()
 case 5:return 0xff000000;
 case 6:return 0xffffffff;
 
+#ifdef __64bit__
 /* 64 bit */
 case 7:return 0x0000000100000000;
 case 8:return 0x0000000100000001;
 static unsigned long get_interesting_value()
 case 18:return 0xffffffff7fffffff;
 case 19:return 0xfffffff7ffffffff;
 case 20:return 0xffffffffffffffff;
+#endif
 }
 /* Should never be reached. */
 return 0;
",366,82
add syscall table for i386," int main(int argc, char* argv[])
 
 
 /* Sanity test. All NI_SYSCALL's should return ENOSYS. */
+/* disable for now, breaks with 32bit calls.
 for (i=0; i<= max_nr_syscalls; i++) {
 if (syscalls[i].flags & NI_SYSCALL) {
 ret = syscall(i);
 int main(int argc, char* argv[])
 }
 }
 }
+*/
 
 run_setup();
 
",663,154
"oops, accidentally had the 'do the 32bit call' code commented out."," static long call_syscall(__unused int num_args, unsigned int call,
 if (!do_32bit)
 return syscall(call, a1, a2, a3, a4, a5, a6);
 
-#ifdef __i386__
 if (num_args < 6) {
 long __res;
 __asm__ volatile (""int $0x80""
 static long call_syscall(__unused int num_args, unsigned int call,
 return __res;
 }
 /* TODO: 6 arg 32bit syscall goes here.*/
-#endif
 
 return 0;
 
 done: ;
 
 int main(int argc, char* argv[])
 {
-unsigned int i;
-int ret;
+//unsigned int i;
+//int ret;
+
 int shmid;
 key_t key;
 
",661,153
dumb random thinkos picked up by 'Ross' and others on lwn.net," static unsigned long get_interesting_value()
 int i;
 
 #ifdef __64bit__
-i = rand() & 20;
+i = rand() % 21;
 #else
-i = rand() & 6;
+i = rand() % 7;
 #endif
 
 switch (i) {
 static unsigned long get_address()
 {
 int i;
 
-i = rand() % 2;
+i = rand() % 3;
 switch (i) {
 case 0:return KERNEL_ADDR;
 case 1:return (unsigned long) useraddr;
",366,82
Count retries from --bruteforce in the summary," static int ctrlc_hit = 0;
 struct shm_s {
 unsigned long successes;
 unsigned long failures;
+unsigned long retries;
 };
 struct shm_s *shm;
 
 retry_same:
 if (res < 0) {
 //printf (""syscall failed. Retrying\n"");
 retrycount++;
+shm->retries++;
 goto retry_same;
 }
 }
 int main(int argc, char* argv[])
 if (structptr!=NULL)
 free(structptr);
 
-printf(""\nRan %lld syscalls. Successes: %ld Failures: %ld\n"",
-execcount, shm->successes, shm->failures);
+printf(""\nRan %lld syscalls (%ld retries). Successes: %ld Failures: %ld\n"",
+execcount, shm->retries, shm->successes, shm->failures);
 
 exit(EXIT_SUCCESS);
 }
",695,161
"Some more random fixes.

Use rand64 where necessary. Elsewhere, just plain rand()
Fix up some masking, and remove some redundant looping."," void close_fds(void)
 
 int get_random_fd(void)
 {
-int i = random();
+int i = rand();
 
 switch (i % 3) {
 case 0:return pipes[0];
 case 1:return pipes[1];
-case 2:
-case 3:return file_user;
+case 2:return file_user;
 }
 
 return 0;
 int get_random_fd(void)
 
 int get_pipe_fd(void)
 {
-if (random() % 1)
+if (rand() % 1)
 return pipes[0];
 else
 return pipes[1];
",43,10
add in some x86-64 addresses," static unsigned long get_interesting_value()
 
 low = get_interesting_32bit_value();
 
-i = rand() % 10;
+i = rand() % 13;
 
 switch (i) {
 /* 64 bit */
 static unsigned long get_interesting_value()
 case 7:return low | 0x7fffffff00000000;
 case 8:return low | 0x8000000000000000;
 case 9:return low | 0xffffffff00000000;
+case 10: return low & 0xffffff | 0xffffffff81000000;// x86-64 kernel text address
+case 11: return low & 0x0fffff | 0xffffffffff600000;// x86-64 vdso
+case 12: return low & 0xffffff | 0xffffffffa0000000;// x86-64 module space
 }
 /* Should never be reached. */
 return 0;
",378,84
"Improve the random fd code.

files code largely stolen from an ioctl fuzzer by Ilja van Sprundel."," void sanitise_splice(
 __unused unsigned long *a6)
 {
 /* first param is fdin */
-*a1 = get_pipe_fd();
+*a1 = get_random_fd();
 
 /* third param is fdout */
-*a3 = get_pipe_fd();
+*a3 = get_random_fd();
 }
 
 
 void sanitise_vmsplice(
 __unused unsigned long *a5,
 __unused unsigned long *a6)
 {
-*fd = get_pipe_fd();
+*fd = get_random_fd();
 *a3 = rand() % 1024;/* UIO_MAXIOV */
 }
 
",378,84
"Add back the pipe creation.
Bias the number of sockets created."," static void open_sockets()
 {
 int fd;
 int socks=0;
+int nr_to_create = 500;
+
+if (fd_idx < 500)
+nr_to_create = fd_idx;
+if (nr_to_create < 100)
+nr_to_create = 100;
 
 printf(""Creating sockets.\n"");
 
-while (socks < 500) {
+while (socks < nr_to_create) {
 fd = socket(rand() % PF_MAX, rand() % TYPE_MAX, rand() % PROTO_MAX);
 if (fd > -1) {
 fds[fd_idx++] = fd;
 static void open_sockets()
 printf(""\ncreated %d sockets\n"", socks);
 }
 
+static int pipes[2];
 
 void setup_fds(void)
 {
 fd_idx = 0;
 
+printf(""Creating pipes\n"");
+if (pipe(pipes) < 0) {
+perror(""pipe fail.\n"");
+exit(EXIT_FAILURE);
+}
+fds[0] = pipes[0];
+fds[1] = pipes[1];
+fd_idx += 2;
+
 printf(""Opening fds\n"");
 open_fds(""/dev"");
 open_fds(""/sys"");
",132,34
"ioctl sanitiser

needs more work."," void sanitise_fanotify_mark(
 {
 *a3 &= 0xffffffff;
 }
+
+void sanitise_ioctl(
+__unused unsigned long *a1,
+__unused unsigned long *a2,
+unsigned long *a3,
+__unused unsigned long *a4,
+__unused unsigned long *a5,
+__unused unsigned long *a6)
+{
+int i;
+
+*a2 = rand() % 0xffff;
+i = rand() % 3;
+if (i == 1)
+*a2 |= 0x80044000;
+if (i == 2)
+*a2 |= 0xc0044000;
+
+*a3 = (rand() & 0xffffffff);
+i = rand() % 4;
+if (i == 1)
+*a3 &= 0xffff;
+if (i == 2)
+*a3 &= 0xffffff;
+if (i == 3)
+*a3 = get_interesting_32bit_value();
+
+}
",402,90
Remove some sanity stuff that is now done (better) generically.," void sanitise_set_robust_list(
 */
 
 void sanitise_vmsplice(
-unsigned long *fd,
+__unused unsigned long *fd,
 __unused unsigned long *a2,
-__unused unsigned long *a3,
+unsigned long *a3,
 __unused unsigned long *a4,
 __unused unsigned long *a5,
 __unused unsigned long *a6)
 {
-*fd = get_random_fd();
 *a3 = rand() % 1024;/* UIO_MAXIOV */
 }
 
 #include <sys/types.h>
 #include <sys/socket.h>
-void sanitise_sendto(unsigned long *fd,
+void sanitise_sendto(__unused unsigned long *fd,
 __unused unsigned long *buff,
 __unused unsigned long *len,
 __unused unsigned long *flags,
-unsigned long *addr,
+__unused unsigned long *addr,
 unsigned long *addr_len)
 {
-int domain, type, protocol;
-retry:
-domain = rand64() % 34;
-type = rand64() % 10;
-protocol = rand64();
-
-*fd = socket(domain, type, protocol);
-if (*fd == -1UL)
-goto retry;
-
-*addr = (unsigned long)useraddr;
-
 *addr_len %= 128;// MAX_SOCK_ADDR
 }
 
",392,89
limit random pids to pid_max," static unsigned int get_pid()
 
 switch (i) {
 case 0:return getpid();
-case 1:return rand();
+case 1:return rand() & 32768;
 case 2: break;
 }
 return 0;
",392,89
give a 50/50 chance whether the fd is a file or a socket.,"
 #include <sys/socket.h>
 
 static int fds[1024];
+static int socket_fds[500];
 static int fd_idx;
+static int socks=0;
 
 static int ignore_files(char *file)
 {
 static void open_fds(char *dir)
 static void open_sockets()
 {
 int fd;
-int socks=0;
 int nr_to_create = 500;
 
 if (fd_idx < 500)
 static void open_sockets()
 while (socks < nr_to_create) {
 fd = socket(rand() % PF_MAX, rand() % TYPE_MAX, rand() % PROTO_MAX);
 if (fd > -1) {
-fds[fd_idx++] = fd;
+socket_fds[socks++] = fd;
 socks++;
 printf(""(%d sockets created)\r"", socks);
 fflush(stdout);
 void setup_fds(void)
 
 int get_random_fd(void)
 {
-return fds[rand() % fd_idx];
+int i;
+
+i = rand() % 2;
+if (i == 0)
+return fds[rand() % fd_idx];
+if (i == 1)
+return socket_fds[rand() % socks];
+
+// should never get here.
+printf(""oops! %s:%d\n"", __FILE__, __LINE__);
+exit(-1);
 }
",140,36
"A bunch of dumb bugs found with splint

including a missing syscall on x86-64. Duh."," static void open_fds(char *dir)
 return;
 }
 while ((de = readdir(d))) {
+memset(&buf, 0, sizeof(struct stat));
 snprintf(b, sizeof(b), ""%s/%s"", dir, de->d_name);
 if (ignore_files(de->d_name))
 continue; /*""."", "".."", everything that's not a regular file or directory !*/
 static void open_sockets()
 {
 int fd;
 int nr_to_create = 500;
+int domain, type, protocol;
 
 if (fd_idx < 500)
 nr_to_create = fd_idx;
 static void open_sockets()
 printf(""Creating sockets.\n"");
 
 while (socks < nr_to_create) {
-fd = socket(rand() % PF_MAX, rand() % TYPE_MAX, rand() % PROTO_MAX);
+domain = rand() % PF_MAX;
+type = rand() % TYPE_MAX;
+protocol = rand() % PROTO_MAX;
+fd = socket(domain, type, protocol);
 if (fd > -1) {
 socket_fds[socks++] = fd;
 socks++;
 int get_random_fd(void)
 
 // should never get here.
 printf(""oops! %s:%d\n"", __FILE__, __LINE__);
-exit(-1);
+exit(EXIT_FAILURE);
 }
",145,36
Reduce some of the extraneous output," void sanitise_read(
 
 if (filebuffer == NULL) {
 retry:
-printf(""Trying to allocate %lu bytes\n"", newsize);
 filebuffer = malloc(newsize);
 if (filebuffer == NULL) {
 newsize >>= 1;
",391,89
fd is provided generically.," retry_tasksize_end:
 // We already check for overlap in do_mremap()
 }
 
-/*
- * asmlinkage long sys_splice(int fd_in, loff_t __user *off_in, int fd_out, loff_t __user *off_out, size_t len, unsigned int flags)
- *
- * : len must be > 0
- * : fdin & fdout must be file handles
- *
- */
-void sanitise_splice(
-unsigned long *a1,
-__unused unsigned long *a2,
-unsigned long *a3,
-__unused unsigned long *a4,
-__unused unsigned long *a5,
-__unused unsigned long *a6)
-{
-/* first param is fdin */
-*a1 = get_random_fd();
-
-/* third param is fdout */
-*a3 = get_random_fd();
-}
-
 
 /*
 * asmlinkage long sys_sync_file_range(int fd, loff_t offset, loff_t nbytes, unsigned int flags)
",380,88
rough start to sanitiser for remap_file_pages," void sanitise_fanotify_mark(
 *a3 &= 0xffffffff;
 }
 
+void sanitise_remap_file_pages(
+long *start,
+unsigned long *size,
+__unused unsigned long *a3,
+__unused unsigned long *a4,
+unsigned long *pgoff,
+__unused unsigned long *a6)
+{
+
+*start = *start & PAGE_MASK;
+*size = *size & PAGE_MASK;
+
+
+retry_size:
+if (*start + *size <= *start) {
+*size = get_interesting_32bit_value() & PAGE_MASK;
+goto retry_size;
+}
+
+retry_pgoff:
+if (*pgoff + (*size >> PAGE_SHIFT) < *pgoff) {
+*pgoff = get_interesting_value();
+goto retry_pgoff;
+}
+
+retry_pgoff_bits:
+if (*pgoff + (*size >> PAGE_SHIFT) >= (1UL << PTE_FILE_MAX_BITS)) {
+*pgoff = (*pgoff >> 1);
+goto retry_pgoff_bits;
+}
+}
+
+
+
+
 void sanitise_ioctl(
 __unused unsigned long *a1,
 __unused unsigned long *a2,
",406,92
add back an unsigned that got lost along the way.," void sanitise_fanotify_mark(
 }
 
 void sanitise_remap_file_pages(
-long *start,
+unsigned long *start,
 unsigned long *size,
 __unused unsigned long *a3,
 __unused unsigned long *a4,
",406,92
"some includes use __unused as struct members, so define our local typedef as something else."," do { \
 return (type) (res); \
 } while (0)
 
-static long call_syscall(__unused int num_args, unsigned int call,
+static long call_syscall(__unused__ int num_args, unsigned int call,
 unsigned long a1, unsigned long a2, unsigned long a3,
 unsigned long a4, unsigned long a5, unsigned long a6)
 {
",687,160
remove some debug code that crept in.," no_sys32:
 case 'i':
 intelligence = 1;
 setup_fds();
-exit(1);
 break;
 
 case 'L':
",687,160
"log the socket fd's as an fd count, not an array count."," static void open_sockets()
 fd = socket(domain, type, protocol);
 if (fd > -1) {
 socket_fds[socks] = fd;
-writelog(""socket_fd[%i] = domain:%i type:%i protocol:%i\n"",
-socks, domain, type, protocol);
+writelog(""fd[%i] = domain:%i type:%i protocol:%i\n"",
+socks+fd_idx, domain, type, protocol);
 socks++;
 printf(""(%d sockets created)\r"", socks);
 fflush(stdout);
",151,36
improve userspace struct passing in get_address," static unsigned long get_address()
 {
 int i;
 
-i = rand() % 3;
+i = rand() % 4;
 switch (i) {
 case 0:return KERNEL_ADDR;
-case 1:return (unsigned long) useraddr;
-case 2:return get_interesting_value();
+case 1:return (unsigned long) page_zeros;
+case 2:return (unsigned long) page_0xff;
+case 3:return get_interesting_value();
 }
 
 return 0;
",468,112
separate the generic sanitise routines from the per syscall functions.,"
+#include ""scrashme.h""
+
+void sanitise_fanotify_mark(
+__unused__ unsigned long *a1,
+__unused__ unsigned long *a2,
+unsigned long *a3,
+__unused__ unsigned long *a4,
+__unused__ unsigned long *a5,
+__unused__ unsigned long *a6)
+{
+*a3 &= 0xffffffff;
+}
",11,1
sometimes return a length that is < page sized," static unsigned long fill_arg(int call, int argnum)
 //printf (YELLOW ""DBG: %x"" WHITE ""\n"", fd);
 return fd;
 case ARG_LEN:
-return get_interesting_value();
+if ((rand() % 2) == 0)
+return rand() % page_size;
+else
+return get_interesting_value();
 case ARG_ADDRESS:
 return get_address();
 case ARG_PID:
",187,70
finish annotating mmap," void sanitise_mmap(
 __unused__ unsigned long *a3,
 __unused__ unsigned long *a4,
 __unused__ unsigned long *a5,
-unsigned long *a6)
+unsigned long *offset)
 {
-*a6 &= ~PAGE_MASK;
+*offset &= ~PAGE_MASK;
 }
",12,1
"annotate mprotect.

remove prot randomiser, as it's now done by ARG_LIST","
 */
 
 void sanitise_mprotect(
-unsigned long *a1,
-unsigned long *a2,
-unsigned long *a3,
+unsigned long *start,
+unsigned long *len,
+__unused__ unsigned long *prot,
 __unused__ unsigned long *a4,
 __unused__ unsigned long *a5,
 __unused__ unsigned long *a6)
 {
 unsigned long end;
 unsigned long mask = ~(page_size-1);
-int grows;
 
-*a1 &= mask;
+*start &= mask;
 
 retry_end:
-end = *a1 + *a2;
-if (*a2 == 0) {
-*a2 = rand64();
+end = *start + *len;
+if (*len == 0) {
+*len = rand64();
 goto retry_end;
 }
 
 /* End must be after start */
-if (end <= *a1) {
-*a2 = rand64();
+if (end <= *start) {
+*len = rand64();
 goto retry_end;
 }
-
-retry_prot:
-*a3 &= ((PROT_GROWSDOWN|PROT_GROWSUP) | ~(PROT_READ | PROT_WRITE | PROT_EXEC | PROT_SEM));
-
-grows = *a3 & (PROT_GROWSDOWN|PROT_GROWSUP);
-
-if (grows == (PROT_GROWSDOWN|PROT_GROWSUP)) { /* can't be both */
-*a3 &= rand64();
-goto retry_prot;
-}
 }
",25,3
ARG_LIST was only returning one bit. Or a few of them.," static unsigned long fill_arg(int call, int argnum)
 {
 int fd;
 unsigned long i;
+unsigned int bits;
+unsigned long mask=0;
 unsigned long low=0, high=0;
 unsigned int num=0;
 unsigned int *values=NULL;
 static unsigned long fill_arg(int call, int argnum)
 values = syscalls[call].arg6list.values;
 break;
 }
-i = rand() % num;
-return values[i];
+bits = rand() % num;/* num of bits to OR */
+for (i=0; i<bits; i++)
+mask |= values[rand() % num];
+return mask;
 }
 
 return 0x5a5a5a5a;/* Should never happen */
",194,74
slightly improve ioctl. needs lots more work.," unsigned long get_interesting_value()
 }
 
 
-static unsigned long get_address()
+unsigned long get_address()
 {
 int i;
 
",194,74
return a pointer to the random page sometimes," unsigned long get_address()
 {
 int i;
 
-i = rand() % 4;
+i = rand() % 5;
 switch (i) {
 case 0:return KERNEL_ADDR;
 case 1:return (unsigned long) page_zeros;
 case 2:return (unsigned long) page_0xff;
-case 3:return get_interesting_value();
+case 3:return (unsigned long) page_rand;
+case 4:return get_interesting_value();
 }
 
 return 0;
",195,75
"return the random struct instead of mangled addresses in ioctl

probably has more chance of success."," void sanitise_ioctl(
 *cmd |= 1L << (rand() % 32);
 
 /* the argument could mean anything, because ioctl sucks like that. */
-i = rand() % 2;
-switch (i) {
-case 0: *arg = get_interesting_32bit_value();
-break;
-case 1: *arg = get_address();
-break;
-}
+if (!(rand() % 3))
+*arg = get_interesting_32bit_value();
+else
+*arg = (unsigned long)page_rand;
 }
",20,3
micro-optimise socket creation," static void open_sockets()
 fd = socket(domain, type, protocol);
 if (fd > -1) {
 socket_fds[socks] = fd;
-writelog(""fd[%i] = domain:%i type:%i protocol:%i\n"",
+writelog_nosync(""fd[%i] = domain:%i type:%i protocol:%i\n"",
 socks+fd_idx, domain, type, protocol);
 socks++;
 
 static void open_sockets()
 }
 }
 }
-fflush(stdout);
 }
 done:
 
",160,40
"Fail with an error when run as root.

Also remove the pointless chroot call that will always fail when
run as non-root."," static void run_setup(void)
 (void)signal(SIGINT, ctrlc);
 
 srand(seed);
-
-chroot(""tmp"");
 }
 
 static void run_mode(void)
 int main(int argc, char* argv[])
 int shmid;
 key_t key;
 
+if (getuid() == 0) {
+printf(""Don't run as root.\n"");
+exit(EXIT_FAILURE);
+}
+
 #ifdef __x86_64__
 syscalls32 = syscalls_i386;
 syscalls = syscalls_x86_64;
",692,160
"remove more of the uid munging stuff.

remnants of an older time when we cared about being run as root."," static void ctrlc(__attribute((unused)) int sig)
 ctrlc_hit=1;
 }
 
-static void run_setup(void)
+static void mask_signals(void)
 {
 int i;
 
-seteuid(65536);
-seteuid(65536);
-(void)setgid(65536);
-seteuid(65536);
-
 for (i=1; i<512; i++) {
 struct sigaction sa;
 sigset_t ss;
 static void run_setup(void)
 (void)signal(SIGWINCH, SIG_IGN);
 (void)signal(SIGCHLD, SIG_IGN);
 (void)signal(SIGINT, ctrlc);
-
-srand(seed);
 }
 
 static void run_mode(void)
 int main(int argc, char* argv[])
 }
 */
 
-run_setup();
+mask_signals();
+
+srand(seed);
 
 sigsetjmp(ret_jump, 1);
 
",688,160
cut & paste braino in mmap sanitiser," void sanitise_mmap(
 __unused__ unsigned long *a5,
 unsigned long *offset)
 {
-*offset &= ~PAGE_MASK;
+*offset &= PAGE_MASK;
 }
",12,1
"another braino, this time in mremap sanitiser"," void sanitise_mremap(
 unsigned long mask = ~(page_size-1);
 int i;
 
-*flags = rand64() & ~(MREMAP_FIXED | MREMAP_MAYMOVE);
+*flags = rand64() & (MREMAP_FIXED | MREMAP_MAYMOVE);
 
 *addr &= mask;
 
 i=0;
 if (*flags & MREMAP_FIXED) {
+// Can't be fixed, and maymove.
 *flags &= ~MREMAP_MAYMOVE;
+
 *new_len &= TASK_SIZE-*new_len;
 retry_addr:
 *new_addr &= mask;
",40,7
"rt_sigaction improvements

act/oact can be null sometimes.","
 #include <signal.h>
+#include <stdlib.h>
 #include ""scrashme.h""
 
 /*
 void sanitise_rt_sigaction(
 __unused__ unsigned long *a5,
 __unused__ unsigned long *a6)
 {
+if ((rand() % 2) == 0)
+*a2 = 0;
+
+if ((rand() % 2) == 0)
+*a3 = 0;
+
 *a4 = sizeof(sigset_t);
 }
",17,3
"some safety for when we run outside the harness.

also put the logfile in the source dir, not the junk dir"," int main(int argc, char* argv[])
 #endif
 
 if (logfilename == NULL)
-logfilename = strdup(""scrashme.log"");
+logfilename = strdup(""../scrashme-cpu0.log"");
 unlink(logfilename);
 
 progname = argv[0];
 int main(int argc, char* argv[])
 
 mask_signals();
 
+/* just in case we're not using the test.sh harness. */
+chdir(""tmp/"");
+
 sigsetjmp(ret_jump, 1);
 
 do_main_loop();
",627,139
"Rename project to 'Trinity'.

scrashme was too generic.","
 #include <sys/stat.h>
 #include <sys/socket.h>
 
-#include ""scrashme.h""
+#include ""trinity.h""
 
 static int fds[1024];
 static int socket_fds[500];
 static void open_fds(char *dir)
 static int spin=0;
 static char spinner[]=""-\\|/"";
 
-static char *cachefilename=""scrashme.socketcache"";
+static char *cachefilename=""trinity.socketcache"";
 
 #define TYPE_MAX 128
 #define PROTO_MAX 256
",208,46
Don't let -c call AVOID_SYSCALL annotated syscalls," static void parse_args(int argc, char *argv[])
 for (i=0; i<=max_nr_syscalls; i++) {
 if (strcmp(optarg, syscalls[i].name) == 0) {
 printf(""Found %s at %u\n"", syscalls[i].name, i);
+if (syscalls[i].flags &= AVOID_SYSCALL) {
+printf(""%s is marked AVOID_SYSCALL (probably for good reason)\n"", syscalls[i].name);
+exit(EXIT_FAILURE);
+}
 specific_syscall = i;
 break;
 }
 static void parse_args(int argc, char *argv[])
 /* Try looking in the 32bit table. */
 for (i=0; i<=max_nr_syscalls32; i++) {
 if (strcmp(optarg, syscalls32[i].name) == 0) {
+if (syscalls32[i].flags &= AVOID_SYSCALL) {
+printf(""%s is marked AVOID_SYSCALL (probably for good reason)\n"", syscalls32[i].name);
+exit(EXIT_FAILURE);
+}
 printf(""Found in the 32bit syscall table %s at %u\n"", syscalls32[i].name, i);
 specific_syscall = i;
 printf(""Forcing into 32bit mode.\n"");
",384,71
"beginnings of ioctl sanitiser.

For now, we're focussing on the sg ioctls until things are fleshed out.
(as such only ioctls/scsi-generic.h is included right now)

(in order) plan of attack:
- Flesh out sanitising for scsi-generic
- Add more sanitisers for the rest of the ioctls currently in ioctls/
- split up pending-ioctls into more per-ioctl files in ioctls/
 and then eventually be removed.","
 
 #include ""ioctls.h""
 
-void sanitise_ioctl(
+static void generic_sanitise_ioctl(
 __unused__ unsigned long *fd,
 unsigned long *cmd,
 unsigned long *arg,
 void sanitise_ioctl(
 unsigned int nr_elements;
 unsigned int *ptr;
 
-/* To begin, we choose from one of the known ioctls*/
-*cmd = ioctllist[rand() % NR_IOCTLS].request;
-
 /* One time in 50, mangle it. */
 if ((rand() % 50)==0) {
 
 void sanitise_ioctl(
 break;
 }
 }
+
+void sanitise_ioctl(
+__unused__ unsigned long *fd,
+unsigned long *cmd,
+unsigned long *arg,
+__unused__ unsigned long *a4,
+__unused__ unsigned long *a5,
+__unused__ unsigned long *a6)
+{
+int ioctlnr;
+
+ioctlnr = rand() % NR_IOCTLS;
+*cmd = ioctllist[ioctlnr].request;
+
+if (ioctllist[ioctlnr].sanitise)
+ioctllist[ioctlnr].sanitise(fd, cmd, arg, a4, a5, a6);
+else
+generic_sanitise_ioctl(fd, cmd, arg, a4, a5, a6);
+}
",61,12
"fix logging.

because we were closing/reopening the file with every logging attempt,
we ended up writing half of it to one dir, and half to the other.

Things will be a lot simpler if we just leave the file open.
The fflush/fsync should ensure that things still hit the disk."," int main(int argc, char* argv[])
 progname = argv[0];
 
 if (logfilename == NULL)
-logfilename = strdup(""../trinity-cpu0.log"");
+logfilename = strdup(""trinity-cpu0.log"");
 unlink(logfilename);
+logfile = fopen(logfilename, ""a"");
+if (!logfile) {
+perror(""couldn't open logfile\n"");
+exit(EXIT_FAILURE);
+}
 
 parse_args(argc, argv);
 if (argc==1)
",389,72
document --32bit in help," static unsigned long fill_arg(int call, int argnum)
 for (i=0; i<bits; i++)
 mask |= values[rand() % num];
 return mask;
+
+case ARG_RANDPAGE:
+return (unsigned long) page_rand;
 }
 
 return 0x5a5a5a5a;/* Should never happen */
",197,76
"add a primitive to sync the logfile

and call it after we've been writing unsynced"," static void open_sockets()
 socks++;
 }
 printf(""(%d sockets created based on info from socket cachefile.)\n"", socks);
+synclog();
 
 close(cachefile);
 }
",212,47
make --list with in 32bit mode," unsigned char check_poison = 0;
 unsigned char bruteforce = 0;
 unsigned char poison = 0x55;
 unsigned char nofork = 0;
+unsigned char show_syscall_list = 0;
 int do_32bit = 0;
 
 unsigned int max_nr_syscalls;
 static void parse_args(int argc, char *argv[])
 break;
 
 case 'L':
-syscall_list();
-exit(EXIT_SUCCESS);
+show_syscall_list = 1;
+break;
 
 /* Pass in address of kernel text */
 case 'k':
 static void parse_args(int argc, char *argv[])
 }
 }
 
+if (show_syscall_list == 1)
+return;
+
 if (bruteforce == 1) {
 if (opmode != MODE_RANDOM) {
 printf(""Brute-force only works in --mode=random\n"");
 int main(int argc, char* argv[])
 if (do_specific_syscall == 1)
 find_specific_syscall();
 
+if (show_syscall_list == 1) {
+syscall_list();
+exit(EXIT_SUCCESS);
+}
+
 page_size = getpagesize();
 
 if (!seed)
",407,77
"fix --logfile parameter being ignored

Logfile was created before arguments are parsed, so anything passed
to -l --logfile was always ignored. Arg parsing moved couple of lines up."," int main(int argc, char* argv[])
 
 progname = argv[0];
 
+parse_args(argc, argv);
+if (argc==1)
+usage();
+
 if (logfilename == NULL)
 logfilename = strdup(""trinity-cpu0.log"");
 unlink(logfilename);
 int main(int argc, char* argv[])
 exit(EXIT_FAILURE);
 }
 
-parse_args(argc, argv);
-if (argc==1)
-usage();
-
 max_nr_syscalls = NR_SYSCALLS;
 
 
",407,77
"make -c1 work again

the work to make it parse syscall names broke the case where
you just pass a syscall number."," static void find_specific_syscall()
 {
 unsigned int i;
 
+if (specific_syscall != 0)
+return;
+
 if (do_32bit == 1)
 goto force_32bit;
 
",409,78
"Don't munge the nr_args in --rotate

We're better off not doing this.
Because we don't do 6-arg syscalls yet on 32bit, we were always
doing no actual work when testing."," static long mkcall(unsigned int call)
 
 #define COLOR_ARG(ARGNUM, NAME, BIT, OLDREG, REG)\
 if (syscalls[call].num_args >= ARGNUM) {\
+if (!NAME)\
+goto args_done;\
 if (ARGNUM != 1)\
 printf(WHITE "", "");\
 if (NAME)\
 static long mkcall(unsigned int call)
 COLOR_ARG(4, syscalls[call].arg4name, 1<<2, olda4, a4);
 COLOR_ARG(5, syscalls[call].arg5name, 1<<1, olda5, a5);
 COLOR_ARG(6, syscalls[call].arg6name, 1<<0, olda6, a6);
-
+args_done:
 printf(WHITE "") "");
 
 
 void do_main_loop(void)
 switch (opmode) {
 case MODE_ROTATE:
 /* It's easier to just use all regs for now. */
-for (i=0; i<=max_nr_syscalls; i++) {
-syscalls[i].num_args = 6;
-}
+//for (i=0; i<=max_nr_syscalls; i++) {
+//syscalls[i].num_args = 6;
+//}
 
 if (do_specific_syscall == 1) {
 rotate_mask++;
",264,70
"improve the random page generator

instead of just random crap, make it look kinda like a struct."," unsigned long get_address()
 return 0;
 }
 
+void regenerate_random_page()
+{
+unsigned int i, j;
+
+for (i = 0; i < page_size; i++) {
+j = rand() % 4;
+switch (j) {
+case 0: page_rand[i] = get_interesting_32bit_value();
+i += sizeof(unsigned long);
+break;
+case 1: page_rand[i] = get_interesting_value();
+i += sizeof(unsigned long long);
+break;
+case 2: page_rand[i] = get_address();
+i += sizeof(void *);
+break;
+case 3: page_rand[i] = (unsigned int) rand() % page_size;
+i += sizeof(unsigned int);
+break;
+}
+}
+}
 
 static unsigned int get_pid()
 {
",218,82
return trash in the random page sometimes," void regenerate_random_page()
 {
 unsigned int i, j;
 
+/* sometimes return a page of complete trash */
+if (rand() % 2 == 0) {
+for (i = 0; i < page_size; i++)
+page_rand[i++] = (unsigned char)rand();
+return;
+}
+
+/* sometimes return a page that looks kinda like a struct */
 for (i = 0; i < page_size; i++) {
 j = rand() % 4;
 switch (j) {
",223,84
remove double increment," void regenerate_random_page()
 /* sometimes return a page of complete trash */
 if (rand() % 2 == 0) {
 for (i = 0; i < page_size; i++)
-page_rand[i++] = (unsigned char)rand();
+page_rand[i] = (unsigned char)rand();
 return;
 }
 
",223,84
"replace __64bit__ with __WORDSIZE

I'm not sure, where __64bit__ comes from, but it's not present
on RHEL6 x86_64, RHEL6 i686.

Using __WORDSIZE should be as good, it has support in glibc and uClibc."," unsigned long get_interesting_32bit_value()
 
 unsigned long get_interesting_value()
 {
-int i;
-unsigned long low;
 
-#ifndef __64bit__
+/* /usr/include/bits/wordsize.h */
+#if __WORDSIZE == 32
+#pragma message(""__WORDSIZE == 32"")
 return get_interesting_32bit_value();
-#endif
+#else
+#pragma message(""__WORDSIZE == 64"")
+int i;
+unsigned long low;
 
 low = get_interesting_32bit_value();
 
 unsigned long get_interesting_value()
 }
 /* Should never be reached. */
 return 0;
+#endif
 }
 
 
",223,85
"generate the sockets first

this should solve the sporadic 'too many files' error while generating
the sockets cachefile."," void setup_fds(void)
 writelog(""fd[1] = pipe\n"");
 
 printf(""Opening fds\n"");
+open_sockets();
 open_fds(""/dev"");
 open_fds(""/sys"");
 open_fds(""/proc"");
-open_sockets();
 
 printf(""done getting fds [idx:%d]\n"", fd_idx);
 if (!fd_idx) {
",211,45
Fix off by two bug in rand() usage," unsigned long filebuffersize = 0;
 unsigned long get_interesting_32bit_value()
 {
 int i;
-i = rand() % 13;
+i = rand() % 15;
 
 switch (i) {
 /* 32 bit */
",223,85
ignore all the cgroup junk that systemd created," static int ignore_files(char *file)
 ""oom_adj"", ""oom_score_adj"",
 ""clear_refs"", ""loginuid"", ""sched"", ""comm"", ""mem"",
 ""task"",
+/* ignore cgroup stuff*/
+""cgroup"",
 NULL};
 
 for(i = 0; ignored_files[i]; i++) {
",234,46
ignore the autogroup crap," static int ignore_files(char *file)
 ""current"", ""coredump_filter"", ""make-it-fail"",
 ""oom_adj"", ""oom_score_adj"",
 ""clear_refs"", ""loginuid"", ""sched"", ""comm"", ""mem"",
-""task"",
+""task"", ""autogroup"",
 /* ignore cgroup stuff*/
 ""cgroup"",
 NULL};
",234,46
log how the file was opened.," static void open_fds(char *dir)
 DIR *d = opendir(dir);
 struct dirent *de;
 struct stat buf;
+char *modestr;
 
 if (!d) {
 printf(""cant open %s\n"", dir);
 static void open_fds(char *dir)
 fd = open(b, openflag | O_NONBLOCK);
 if (fd < 0)
 continue;
-printf(""%s/%s\n"", dir, de->d_name);
-writelog(""fd[%i] = %s\n"", fd_idx, b);
+switch (openflag) {
+case O_RDONLY:modestr = ""read-only"";break;
+case O_WRONLY:modestr = ""write-only"";break;
+case O_RDWR:modestr = ""read-write"";break;
+}
+printf(""%s/%s (%s)\n"", dir, de->d_name, modestr);
+writelog(""fd[%i] = %s (%s)\n"", fd_idx, b, modestr);
 fds[fd_idx++] = fd;
 }
 if (fd_idx > (MAX_FDS / 2))
",240,49
return small values most the time in the 64bit path too," unsigned long get_interesting_value()
 
 low = get_interesting_32bit_value();
 
+i = rand() % 10;
+if (i > 3)
+/* return small values 70% of the time */
+return low;
+
+
 i = rand() % 13;
 
 switch (i) {
",233,87
won't need this any more," void do_main_loop(void)
 
 switch (opmode) {
 case MODE_ROTATE:
-/* It's easier to just use all regs for now. */
-//for (i=0; i<=max_nr_syscalls; i++) {
-//syscalls[i].num_args = 6;
-//}
-
 if (do_specific_syscall == 1) {
 rotate_mask++;
 if (rotate_mask == (1<<6)-1)
",264,70
"remove the capcheck feature.

it was unfinished, and unlikely to be."," void do_main_loop(void)
 do_syscall_from_child(rep);
 break;
 
-case MODE_CAPCHECK:
-if (rep > max_nr_syscalls)
-goto done;
-if (syscalls[rep].flags & CAPABILITY_CHECK) {
-int r;
-printf (""%i: "", rep);
-r = do_syscall(rep);
-if (r != -EPERM)
-printf (""Didn't return EPERM!\n"");
-}
-break;
-
 case MODE_RANDOM:
 do_syscall_from_child(rep);
 break;
",253,66
clean up the rotate path," void do_main_loop(void)
 
 switch (opmode) {
 case MODE_ROTATE:
-if (do_specific_syscall == 1) {
-rotate_mask++;
+/* Reset syscall nr, unless we asked to do a specific one */
+if (rep == max_nr_syscalls) {
+/* Pointless running > once. */
 if (rotate_mask == (1<<6)-1)
 goto done;
-} else {
-if (rep == max_nr_syscalls) {
-/* Pointless running > once. */
-if (rotate_mask == (1<<6)-1)
-goto done;
-rep = 0;
-rotate_mask++;
-}
+rep = 0;
+rotate_mask++;
 }
 do_syscall_from_child(rep);
 break;
",250,65
nix that useless comment," void do_main_loop(void)
 
 switch (opmode) {
 case MODE_ROTATE:
-/* Reset syscall nr, unless we asked to do a specific one */
 if (rep == max_nr_syscalls) {
 /* Pointless running > once. */
 if (rotate_mask == (1<<6)-1)
",250,65
now done in the struct def," void sanitise_mremap(
 unsigned long mask = ~(page_size-1);
 int i;
 
-*flags = rand64() & (MREMAP_FIXED | MREMAP_MAYMOVE);
-
 *addr &= mask;
 
 i=0;
",39,7
Parse /proc/self/maps and return a random map occasionally as ARG_ADDRESS," static void generic_sanitise_ioctl(
 unsigned int i, j;
 unsigned int nr_elements;
 unsigned int *ptr;
+void *addr;
 
 /* One time in 50, mangle it. */
 if ((rand() % 50)==0) {
 static void generic_sanitise_ioctl(
 case 0: *ptr = get_interesting_32bit_value();
 ptr+= sizeof(unsigned int);
 break;
-case 1:*ptr = get_address();
+case 1:addr = get_address();
+*ptr = (unsigned long) (addr);
 ptr+= sizeof(unsigned long);
 break;
 }
",63,12
"don't stomp on the shm segment.

It might be a better idea to generate a linked-list of maps on startup
rather than keep doing this over and over."," static void * get_map()
 unsigned int i, j=0;
 unsigned int maps=0;
 
+retry:
 f = fopen(""/proc/self/maps"", ""r"");
 if (f) {
 /* first, count how many maps we have. */
 static void * get_map()
 fclose(f);
 }
 
+// Avoid the shm segment, or we might corrupt it.
+if (startaddr == shm)
+goto retry;
+
 //printf(""return map %p\n"", startaddr);
 return startaddr;
 }
",263,94
"Generate a list of maps on startup

Pick something random out of the linked list, instead of scanning
for something over and over."," unsigned long get_interesting_value()
 #endif
 }
 
-static void * get_map()
-{
-FILE *f;
-void *startaddr, *endaddr;
-unsigned int i, j=0;
-unsigned int maps=0;
-
-retry:
-f = fopen(""/proc/self/maps"", ""r"");
-if (f) {
-/* first, count how many maps we have. */
-do {
-fscanf(f, ""%p-%p %*[^\n]\n"", &startaddr, &endaddr);
-maps++;
-} while (!feof(f));
-
-/* now return a random one */
-rewind(f);
-i = rand() % maps;
-do {
-fscanf(f, ""%p-%p %*[^\n]\n"", &startaddr, &endaddr);
-j++;
-if (i == j)
-break;
-} while (!feof(f));
-fclose(f);
-}
-
-// Avoid the shm segment, or we might corrupt it.
-if (startaddr == shm)
-goto retry;
-
-//printf(""return map %p\n"", startaddr);
-return startaddr;
-}
-
-
 void * get_address()
 {
 int i;
",236,88
"increase logbuffer

With all the ANSI codes etc, we easily blow past the end of the buffer."," static long mkcall(unsigned int call)
 unsigned long olda1=0, olda2=0, olda3=0, olda4=0, olda5=0, olda6=0;
 unsigned long a1=0, a2=0, a3=0, a4=0, a5=0, a6=0;
 int ret = 0;
-char string[120], *sptr=string;
+char string[512], *sptr=string;
 
 switch (opmode) {
 case MODE_ROTATE:
",212,53
destroy the shm on exit," int main(int argc, char* argv[])
 printf(""\nRan %lld syscalls (%ld retries). Successes: %ld Failures: %ld\n"",
 execcount, shm->retries, shm->successes, shm->failures);
 
+shmdt(shm);
+
 exit(EXIT_SUCCESS);
 }
",405,79
"as there are way more files in sys, do this after we scan proc"," void setup_fds(void)
 printf(""Opening fds\n"");
 open_sockets();
 open_fds(""/dev"");
-open_fds(""/sys"");
 open_fds(""/proc"");
+open_fds(""/sys"");
 
 printf(""done getting fds [idx:%d]\n"", fd_idx);
 if (!fd_idx) {
",253,50
"abort fuzzing specific syscalls when passed numerically too.

we already did this when we passed '-c exit_group' for eg."," static void find_specific_syscall()
 {
 unsigned int i;
 
-if (specific_syscall != 0)
+if (specific_syscall != 0) {
+i = specific_syscall;
+if (syscalls[i].flags &= AVOID_SYSCALL) {
+printf(""%s is marked AVOID_SYSCALL (probably for good reason)\n"", syscalls[i].name);
+exit(EXIT_FAILURE);
+}
 return;
+}
 
 if (do_32bit == 1)
 goto force_32bit;
",411,80
"better handling of -F

If we segfaulted when running in -F mode, we would exit the fuzzer.
Now, we always have at least one child process for calling syscalls."," void display_opmode(void)
 (void)fflush(stdout);
 }
 
-void do_main_loop(void)
+void main_loop(void)
 {
 for (;;) {
 
 void do_main_loop(void)
 done: ;
 }
 
+
+void do_main_loop(void)
+{
+if (opmode != MODE_RANDOM) {
+main_loop();
+return;
+}
+
+/* By default, MODE_RANDOM will do one syscall per child,
+ * unless -F is passed.
+ */
+if (nofork == 0) {
+main_loop();
+return;
+} else {
+/* if we opt to not fork for each syscall, we still need
+ to fork once, in case calling the syscall segfaults. */
+while (1) {
+sigsetjmp(ret_jump, 1);
+printf(""forking new child.\n"");
+sleep(1);
+if (fork() == 0) {
+mask_signals();
+main_loop();
+if (ctrlc_hit == 1)
+_exit(EXIT_SUCCESS);
+}
+(void)waitpid(-1, NULL, 0);
+if (ctrlc_hit == 1)
+return;
+}
+}
+}
+
 void syscall_list()
 {
 unsigned int i;
",238,60
"move execcount into the shm.

necessary due to the new forking code."," void main_loop(void)
 }
 
 rep++;
-execcount++;
-if (syscallcount && (execcount >= syscallcount))
+shm->execcount++;
+if (syscallcount && (shm->execcount >= syscallcount))
 break;
 
 regenerate_random_page();
",238,60
"use a different seed in every child, or we do the same syscalls over and over."," void do_main_loop(void)
 printf(""forking new child.\n"");
 sleep(1);
 if (fork() == 0) {
+seed_from_tod();
 mask_signals();
 main_loop();
 if (ctrlc_hit == 1)
",239,60
"clear -F when in rotate mode.

Because we can't carry on where we left off in the new child."," int main(int argc, char* argv[])
 exit(EXIT_SUCCESS);
 }
 
+/* rotate doesn't work with nofork. */
+if (opmode == MODE_ROTATE)
+nofork = 0;
+
 page_size = getpagesize();
 
 if (!seed)
",408,80
regenerate socket cache if something doesn't look right.," static void open_sockets()
 socks+fd_idx, domain, type, protocol);
 socks++;
 }
+if (socks < MAX_FDS/2) {
+printf(""Insufficient sockets in cachefile. Regenerating.\n"");
+generate_sockets(MAX_FDS/2);
+return;
+}
+
 printf(""(%d sockets created based on info from socket cachefile.)\n"", socks);
 synclog();
 
",258,51
chmod the tmp dir before we use it,"
 #include <setjmp.h>
 #include <asm/unistd.h>
 #include <sys/time.h>
+#include <sys/stat.h>
 #include <sys/types.h>
 #include <sys/wait.h>
 #include <sys/syscall.h>
 int main(int argc, char* argv[])
 mask_signals();
 
 /* just in case we're not using the test.sh harness. */
+chmod(""tmp/"", 0755);
 chdir(""tmp/"");
 
 sigsetjmp(ret_jump, 1);
",410,80
"when passing -N and -F, we need to check the syscall count in another place."," void do_main_loop(void)
 main_loop();
 if (ctrlc_hit == 1)
 _exit(EXIT_SUCCESS);
+if (syscallcount && (shm->execcount >= syscallcount))
+_exit(EXIT_SUCCESS);
 }
 (void)waitpid(-1, NULL, 0);
+
 if (ctrlc_hit == 1)
 return;
+if (syscallcount && (shm->execcount >= syscallcount))
+return;
 }
 }
 }
",243,64
the mqdes args are file descriptors," args_done:
 writelog(""%s"", string);
 sptr = string;
 
+synclog();
 (void)fflush(stdout);
 
+if (dopause == 1)
+sleep(1);
+
 /* IA64 is retarde^Wspecial. */
 #ifdef __ia64__
 call += 1024;
 args_done:
 writelog(""%s"", string);
 sptr = string;
 
+synclog();
 (void)fflush(stdout);
 
 /* If the syscall doesn't exist don't bother calling it next time. */
 retry_same:
 
 failed_repeat:
 
-if (dopause==1)
-(void)sleep(1);
-
 skip_syscall:
 return res;
 }
",245,64
play with the file/dir bias a little.," static void open_fds(char *dir)
 //continue;
 if (S_ISDIR(buf.st_mode)) {
 /* probability of adding a directory to the list. */
-chance = 30;
+chance = 5;
 openflag = O_RDONLY;
 if (buf.st_uid != getuid()) {
 /* We don't own the dir, is it group/other readable ? */
 static void open_fds(char *dir)
 if ((openflag & O_RDONLY) && (openflag & O_WRONLY))
 openflag = O_RDWR;
 // for files, increase the probability of success
-chance = 40;
+chance = 10;
 openit:
 fd = add_fd(chance, b, openflag);
 if (fd == -1)
",258,51
remove duplicate define,"
 
 #include ""trinity.h""
 
-#define MAX_FDS 750
-
 unsigned int socket_fds[MAX_FDS];
 unsigned int socks=0;
 
",96,12
remove the other redefinitions too,"
 
 #include ""trinity.h""
 
-#define MAX_FDS 750
-
 unsigned int fds[1024];
 unsigned int fd_idx;
 
",49,6
remove some unneeded includes,"
 #include <stdio.h>
 #include <stdlib.h>
-#include <string.h>
 #include <unistd.h>
-#include <fcntl.h>
-#include <dirent.h>
-#include <errno.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <sys/socket.h>
 
 #include ""trinity.h""
 
",42,6
"several fixes for the stale socket handling code.

- If we opened any sockets from the cachefile, close them before we start over.
- after regeneration, don't drop through to the code that assumes
 cachefile success."," void open_sockets()
 int cachefile;
 unsigned int domain, type, protocol;
 unsigned int buffer[3];
+unsigned int i;
 int bytesread=-1;
 int fd;
 
 void open_sockets()
 fd = socket(domain, type, protocol);
 if (fd < 0) {
 printf(""Cachefile is stale. Need to regenerate.\n"");
+close(cachefile);
 unlink(cachefilename);
+
+for (i = 0; i < socks; i++) {
+close(socket_fds[i]);
+socket_fds[i] = 0;
+fd_idx--;
+}
+socks = 0;
+
 generate_sockets(MAX_FDS/2);
+return;
 }
 socket_fds[socks] = fd;
 writelog_nosync(""fd[%i] = domain:%i type:%i protocol:%i\n"",
",117,17
use the same socket regeneration code for both codepaths.," void open_sockets()
 fd = socket(domain, type, protocol);
 if (fd < 0) {
 printf(""Cachefile is stale. Need to regenerate.\n"");
+regenerate:
 close(cachefile);
 unlink(cachefilename);
 
 void open_sockets()
 }
 if (socks < MAX_FDS/2) {
 printf(""Insufficient sockets in cachefile (%d). Regenerating.\n"", socks);
-generate_sockets(MAX_FDS/2);
-return;
+goto regenerate;
 }
 
 printf(""(%d sockets created based on info from socket cachefile.)\n"", socks);
",117,17
"improve logfile code.

log to stdout and a file, which allows to remove some duplicate outputs.
This will later allow for --disable-logging to work, and also
some other improvements."," void setup_fds(void)
 fds[0] = pipes[0];
 fds[1] = pipes[1];
 fd_idx += 2;
-writelog(""fd[0] = pipe\n"");
-writelog(""fd[1] = pipe\n"");
+output(""fd[0] = pipe\n"");
+output(""fd[1] = pipe\n"");
 
 printf(""Opening fds\n"");
 open_sockets();
",42,6
close the sockets when we exit.," no_sys32:
 int main(int argc, char* argv[])
 {
 int shmid;
+unsigned int i;
 key_t key;
 
 if (getuid() == 0) {
 int main(int argc, char* argv[])
 
 shmdt(shm);
 
+for (i = 0; i < socks; i++)
+close(socket_fds[i]);
+
 exit(EXIT_SUCCESS);
 }
",411,81
output socketcache used info to logfile," regenerate:
 goto regenerate;
 }
 
-printf(""(%d sockets created based on info from socket cachefile.)\n"", socks);
+output(""(%d sockets created based on info from socket cachefile.)\n"", socks);
 
 close(cachefile);
 }
",117,17
print the actual fd's," void setup_fds(void)
 fds[0] = pipes[0];
 fds[1] = pipes[1];
 fd_idx += 2;
-output(""fd[0] = pipe\n"");
-output(""fd[1] = pipe\n"");
+output(""fd[%d] = pipe\n"", fds[0]);
+output(""fd[%d] = pipe\n"", fds[1]);
 
 printf(""Opening fds\n"");
 open_sockets();
",42,6
close the logfile on exit," int main(int argc, char* argv[])
 for (i = 0; i < socks; i++)
 close(socket_fds[i]);
 
+fclose(logfile);
+
 exit(EXIT_SUCCESS);
 }
",412,81
"several fd table fixes.

- we were overwriting already existing fd entries
- print the actual fd, not the array index.
- fix a hard to hit segfault that happens when a file open failed.","
 unsigned int fds[1024];
 unsigned int fd_idx;
 
+unsigned int fds_left_to_create = MAX_FDS;
+
 static int pipes[2];
 
 void setup_fds(void)
 void setup_fds(void)
 fds[0] = pipes[0];
 fds[1] = pipes[1];
 fd_idx += 2;
+fds_left_to_create-=2;
 output(""fd[%d] = pipe\n"", fds[0]);
 output(""fd[%d] = pipe\n"", fds[1]);
 
-printf(""Opening fds\n"");
 open_sockets();
 open_fds(""/dev"");
 open_fds(""/proc"");
",43,6
log the syscall count," static long mkcall(unsigned int call)
 int ret = 0;
 char string[512], *sptr=string;
 
+sptr += sprintf(sptr, ""%lu: "", shm->execcount);
+
 switch (opmode) {
 case MODE_ROTATE:
 a1 = a2 = a3 = a4 = a5 = a6 = regval;
",246,64
remove duplicate print," static int do_syscall(int callnr)
 goto skip_syscall;
 }
 
-printf (""%i: "", callnr);
-
 retry_same:
 (void)alarm(3);
 
",245,64
"avoid returning stdin/stdout/logfile when asked for a random fd

otherwise we spew garbage to same."," void setup_fds(void)
 
 int get_random_fd(void)
 {
-int i;
+unsigned int i;
+unsigned int fd = 0;
 
+retry:
 i = rand() % 2;
 if (i == 0)
-return fds[rand() % fd_idx];
+fd = fds[rand() % fd_idx];
 if (i == 1)
-return socket_fds[rand() % socks];
+fd = socket_fds[rand() % socks];
 
-// should never get here.
-printf(""oops! %s:%d\n"", __FILE__, __LINE__);
-exit(EXIT_FAILURE);
+/* retry if we hit stdin/stdout/logfile */
+if (fd < fds[0])
+goto retry;
+
+return fd;
 }
",46,7
sockets code shouldn't mess with fd index. (which is for the files fd's only)," void setup_fds(void)
 open_fds(""/sys"");
 
 printf(""done getting fds [idx:%d]\n"", fd_idx);
-if (!fd_idx) {
-printf(""couldn't open any files\n"");
-exit(0);
-}
 }
 
 
",42,6
make the fd / socket buffers appropriately sized.,"
 
 #include ""trinity.h""
 
-unsigned int fds[1024];
+unsigned int fds[MAX_FDS/2];
 unsigned int fd_idx;
 
 unsigned int fds_left_to_create = MAX_FDS;
",42,6
don't write past end of array when creating sockets.," void setup_fds(void)
 output(""fd[%d] = pipe\n"", fds[1]);
 
 open_sockets();
+
 open_fds(""/dev"");
 open_fds(""/proc"");
 open_fds(""/sys"");
",42,6
output what the addresses point to in the register dumper," static long mkcall(unsigned int call)
 else\
 sptr += sprintf(sptr, CYAN ""0x%lx"" WHITE, REG);\
 }\
+if (REG == (unsigned long)page_zeros)\
+sptr += sprintf(sptr, ""[page_zeros]"");\
+if (REG == (unsigned long)page_rand)\
+sptr += sprintf(sptr, ""[page_rand]"");\
+if (REG == (unsigned long)page_0xff)\
+sptr += sprintf(sptr, ""[page_0xff]"");\
 }
 
 sptr += sprintf(sptr, WHITE ""("");
",245,64
print numbers < 1024 as decimal in the register dumper," static long mkcall(unsigned int call)
 sptr += sprintf(sptr, YELLOW ""0x%lx"" WHITE, REG);\
 else {\
 if (OLDREG == REG)\
-sptr += sprintf(sptr, WHITE ""0x%lx"", REG);\
+sptr += sprintf(sptr, WHITE);\
 else\
-sptr += sprintf(sptr, CYAN ""0x%lx"" WHITE, REG); \
+sptr += sprintf(sptr, CYAN);\
+if (REG > 1024)\
+sptr += sprintf(sptr, ""0x%lx"" WHITE, REG);\
+else\
+sptr += sprintf(sptr, ""%ld"" WHITE, REG);\
 }\
 } else {\
 if (OLDREG == REG)\
-sptr += sprintf(sptr, WHITE ""0x%lx"", REG);\
+sptr += sprintf(sptr, WHITE);\
+else\
+sptr += sprintf(sptr, CYAN);\
+if (REG > 1024)\
+sptr += sprintf(sptr, ""0x%lx"" WHITE, REG);\
 else\
-sptr += sprintf(sptr, CYAN ""0x%lx"" WHITE, REG);\
+sptr += sprintf(sptr, ""%ld"" WHITE, REG);\
 }\
 if (REG == (unsigned long)page_zeros)\
 sptr += sprintf(sptr, ""[page_zeros]"");\
",245,64
build with -D_FORTIFY_SOURCE=2 (add assorted small warning fixes)," void setup_maps()
 FILE *f;
 void *startaddr, *endaddr;
 struct map *tmpmap;
+unsigned int ret;
 
 f = fopen(""/proc/self/maps"", ""r"");
 if (!f) {
 void setup_maps()
 
 tmpmap = maps_list = alloc_map();
 do {
-fscanf(f, ""%p-%p %*[^\n]\n"", &startaddr, &endaddr);
+ret = fscanf(f, ""%p-%p %*[^\n]\n"", &startaddr, &endaddr);
+if (ret == 0) {
+printf(""/proc/maps parsing failure\n"");
+exit(EXIT_FAILURE);
+}
 
 /* skip over the shm, in case we corrupt it*/
 if (startaddr == shm)
",66,11
introduce sync_output() to flush tty & logfile.," openit:
 fds_left_to_create--;
 }
 }
-synclog();
+
+sync_output();
 closedir(d);
 }
",135,33
start counting execcount from 1. Fix off-by-one's," args_done:
 if (ret == -ENOSYS)
 syscalls[call].flags |= AVOID_SYSCALL;
 
+shm->execcount++;
+
 return ret;
 }
 
 void main_loop(void)
 }
 
 rep++;
-shm->execcount++;
 if (syscallcount && (shm->execcount >= syscallcount))
 break;
 
 done: ;
 
 void do_main_loop(void)
 {
+shm->execcount = 1;
+
 if (opmode != MODE_RANDOM) {
 main_loop();
 return;
",244,64
fix another off-by-one. This time in -N," static void parse_args(int argc, char *argv[])
 
 /* Set syscall loop counter */
 case 'N':
-syscallcount = strtoll(optarg, NULL, 10);
+syscallcount = strtoll(optarg, NULL, 10) + 1;
 break;
 
 /* Pause after each syscall */
",414,82
"Fix buffer overrun during file opening.

This didn't happen every time, so was a pain to track down.
We need to do the check before we try and open anything else
and add to the array."," void open_fds(char *dir)
 return;
 }
 while ((de = readdir(d))) {
-if (fds_left_to_create == 0)
-break;
-
 memset(&buf, 0, sizeof(struct stat));
 snprintf(b, sizeof(b), ""%s/%s"", dir, de->d_name);
 if (ignore_files(de->d_name))
 void open_fds(char *dir)
 // for files, increase the probability of success
 chance = 10;
 openit:
+if (fds_left_to_create == 0)
+break;
+
 fd = add_fd(chance, b, openflag);
 if (fd == -1)
 continue;
",135,33
"only do fd avoiding for file fd's, not sockets."," int get_random_fd(void)
 unsigned int i;
 unsigned int fd = 0;
 
-retry:
 i = rand() % 2;
-if (i == 0)
-fd = fds[rand() % fd_idx];
-if (i == 1)
+switch (i) {
+case 0:
+retry:fd = fds[rand() % fd_idx];
+/* retry if we hit stdin/stdout/logfile */
+if (fd < fds[0])
+goto retry;
+break;
+
+case 1:
 fd = socket_fds[rand() % socks];
-
-/* retry if we hit stdin/stdout/logfile */
-if (fd < fds[0])
-goto retry;
+break;
+}
 
 return fd;
 }
",45,6
Change the pipe generation to use its own array," openit:
 sync_output();
 closedir(d);
 }
+
+void open_files()
+{
+open_fds(""/dev"");
+open_fds(""/proc"");
+open_fds(""/sys"");
+}
+
+void close_files()
+{
+unsigned int i;
+
+for (i = 0; i < fd_idx; i++) {
+close(fds[i]);
+fds[i] = 0;
+fds_left_to_create++;
+}
+fd_idx = 0;
+}
",151,36
"every 25000 calls, regenerate the fd's."," retry_same:
 }
 }
 
+if (!shm->regenerate_fds) {
+close_files();
+open_files();
+shm->regenerate_fds = FD_REGENERATION_POINT - 1;
+}
+shm->regenerate_fds--;
+
+
 failed_repeat:
 
 skip_syscall:
",250,65
change the random page generation to return 'structs' more often.," void regenerate_random_page()
 void *addr;
 
 /* sometimes return a page of complete trash */
-if (rand() % 2 == 0) {
+if ((rand() % 100) < 20) {
 for (i = 0; i < page_size; i++)
 page_rand[i] = (unsigned char)rand();
 return;
",236,88
fix a missing colour code setting.," static long mkcall(unsigned int call)
 sptr += sprintf(sptr, ""%s="", NAME);\
 if (opmode == MODE_ROTATE) {\
 if (rotate_mask & (BIT))\
-sptr += sprintf(sptr, YELLOW ""0x%lx"" WHITE, REG);\
+if (OLDREG == REG)\
+sptr += sprintf(sptr, YELLOW ""0x%lx"" WHITE, REG);\
+else\
+sptr += sprintf(sptr, CYAN ""0x%lx"" WHITE, REG);\
 else {\
 if (OLDREG == REG)\
 sptr += sprintf(sptr, WHITE);\
",250,65
log the start/end of each mapping," void setup_maps()
 tmpmap->next = alloc_map();
 tmpmap = tmpmap->next;
 
+output(""mapping[%d]: %p-%p\n"", num_mappings - 1, startaddr, endaddr);
+
 } while (!feof(f));
 
 /* free the empty map on the end */
",67,11
Log the owner of the mappings we pass.," int main(int argc, char* argv[])
 
 shmdt(shm);
 
+destroy_maps();
+
 for (i = 0; i < socks; i++)
 close(socket_fds[i]);
 
",416,82
skip to EOL when we find the shm address," void setup_maps()
 }
 
 /* skip over the shm, in case we corrupt it*/
-if (startaddr == shm)
+if (startaddr == shm) {
+do {
+ch = getc(f);
+} while ((ch != EOF) && (ch != '\n'));
 continue;
+}
 
 // search forward until we reach a name or eol
 do {
 void setup_maps()
 break;
 name[strlen(name) - 1] = '\0';
 tmpmap->name = strdup(name);
-printf(""found %s\n"", name);
 }
 
 tmpmap->ptr = startaddr;
",99,24
reset number of mappings on destruction," void destroy_maps()
 free(thismap);
 thismap = next;
 }
+num_mappings = 0;
 }
",100,24
"regenerate mappings periodically.

(only really useful with -F)"," retry_same:
 if (!shm->regenerate_fds) {
 close_files();
 open_files();
+
+destroy_maps();
+setup_maps();
+
 shm->regenerate_fds = FD_REGENERATION_POINT - 1;
 }
 shm->regenerate_fds--;
",252,65
cast the pid we return in generic-sanity," static unsigned long fill_arg(int call, int argnum)
 case ARG_ADDRESS:
 return (unsigned long)get_address();
 case ARG_PID:
-return get_pid();
+return (unsigned long)get_pid();
 case ARG_RANGE:
 switch (argnum) {
 case 1:low = syscalls[call].low1range;
",236,88
"skip adjacent mappings of the shm

some syscalls will scribble on things > PAGE_SIZE, so the nearby
mappings will cause us to scribble over the shm.","
 #include <unistd.h>
 
 #include ""trinity.h""
+#include ""arch.h""
 
 static unsigned int num_mappings = 0;
 
 void setup_maps()
 exit(EXIT_FAILURE);
 }
 
-/* skip over the shm, in case we corrupt it*/
-if (startaddr == shm) {
+/* skip over the shm (and any nearby mappings), in case we corrupt it*/
+if ((startaddr > (void *) shm - (PAGE_SIZE * 8)) &&
+ (startaddr < (void *) shm + (PAGE_SIZE * 8))) {
 do {
 ch = getc(f);
 } while ((ch != EOF) && (ch != '\n'));
",102,25
Move fanotify_mark sanitise into syscall def,"
+/*
+ * SYSCALL_DEFINE(fanotify_mark)(int fanotify_fd, unsigned int flags,
+__u64 mask, int dfd, const char __user * pathname)
+ */
+#include ""trinity.h""
+#include ""sanitise.h""
 
 /* flags used for fanotify_modify_mark() */
 #define FAN_MARK_ADD 0x00000001

 #define FAN_EVENT_ON_CHILD 0x08000000 /* interested in child events */
 #define FAN_CLOSE (FAN_CLOSE_WRITE | FAN_CLOSE_NOWRITE) /* close */
 
-
-/*
- * SYSCALL_DEFINE(fanotify_mark)(int fanotify_fd, unsigned int flags,
-__u64 mask, int dfd, const char __user * pathname)
- */
-#include ""trinity.h""
-#include ""sanitise.h""
+static void sanitise_fanotify_mark(
+__unused__ unsigned long *a1,
+__unused__ unsigned long *a2,
+unsigned long *a3,
+__unused__ unsigned long *a4,
+__unused__ unsigned long *a5,
+__unused__ unsigned long *a6)
+{
+*a3 &= 0xffffffff;
+}
 
 struct syscall syscall_fanotify_mark = {
 .name = ""fanotify_mark"",
",38,1
move mmap sanitise into syscall def,"
 
 #include ""trinity.h""
 #include ""sanitise.h""
+#include ""arch.h""
 
+void sanitise_mmap(
+__unused__ unsigned long *a1,
+__unused__ unsigned long *a2,
+__unused__ unsigned long *a3,
+__unused__ unsigned long *a4,
+__unused__ unsigned long *a5,
+unsigned long *offset)
+{
+*offset &= PAGE_MASK;
+}
 struct syscall syscall_mmap = {
 .name = ""mmap"",
 .num_args = 6,
",41,1
move mprotect sanitise into syscall def,"
 /*
- * SYSCALL_DEFINE3(mprotect, unsigned long, start, size_t, len, unsigned long, prot)
+ * sys_mprotect(unsigned long start, size_t len, unsigned long prot)
 */
 #include <asm/mman.h>
 
 #include ""trinity.h""
 #include ""sanitise.h""
 
+static void sanitise_mprotect(
+unsigned long *start,
+unsigned long *len,
+__unused__ unsigned long *prot,
+__unused__ unsigned long *a4,
+__unused__ unsigned long *a5,
+__unused__ unsigned long *a6)
+{
+unsigned long end;
+unsigned long mask = ~(page_size-1);
+
+*start &= mask;
+
+retry_end:
+end = *start + *len;
+if (*len == 0) {
+*len = rand64();
+goto retry_end;
+}
+
+/* End must be after start */
+if (end <= *start) {
+*len = rand64();
+goto retry_end;
+}
+}
+
 struct syscall syscall_mprotect = {
 .name = ""mprotect"",
 .num_args = 3,
",40,3
move pread64 sanity into syscall def,"
 #include ""trinity.h""
 #include ""sanitise.h""
 
+static void sanitise_pread64(
+__unused__ unsigned long *a1,
+__unused__ unsigned long *a2,
+__unused__ unsigned long *a3,
+unsigned long *a4,
+__unused__ unsigned long *a5,
+__unused__ unsigned long *a6)
+{
+
+retry_pos:
+if ((int)*a4 < 0) {
+*a4 = rand64();
+goto retry_pos;
+}
+}
+
 struct syscall syscall_pread64 = {
 .name = ""pread64"",
 .num_args = 4,
",27,2
move pwrite64 sanity into syscall def,"
 #include ""trinity.h""
 #include ""sanitise.h""
 
+static void sanitise_pwrite64(
+__unused__ unsigned long *a1,
+__unused__ unsigned long *a2,
+__unused__ unsigned long *a3,
+unsigned long *a4,
+__unused__ unsigned long *a5,
+__unused__ unsigned long *a6)
+{
+
+retry_pos:
+if ((int)*a4 < 0) {
+*a4 = rand64();
+goto retry_pos;
+}
+}
+
 struct syscall syscall_pwrite64 = {
 .name = ""pwrite64"",
 .num_args = 4,
",27,2
move read sanity into syscall def,"
 * SYSCALL_DEFINE3(read, unsigned int, fd, char __user *, buf, size_t, count)
 */
 
+#include <stdlib.h>
+#include <string.h>
 #include ""trinity.h""
 #include ""sanitise.h""
 
+/*
+ * asmlinkage ssize_t sys_read(unsigned int fd, char __user * buf, size_t count)
+ */
+static void sanitise_read(
+__unused__ unsigned long *a1,
+unsigned long *a2,
+unsigned long *a3,
+__unused__ unsigned long *a4,
+__unused__ unsigned long *a5,
+__unused__ unsigned long *a6)
+{
+unsigned long newsize = (unsigned int) *a3 >> 16;
+
+if (filebuffer != NULL) {
+if (filebuffersize < newsize) {
+free(filebuffer);
+filebuffersize = 0;
+filebuffer = NULL;
+}
+}
+
+if (filebuffer == NULL) {
+retry:
+filebuffer = malloc(newsize);
+if (filebuffer == NULL) {
+newsize >>= 1;
+goto retry;
+}
+filebuffersize = newsize;
+}
+*a2 = (unsigned long) filebuffer;
+*a3 = newsize;
+memset(filebuffer, 0, newsize);
+}
+
 struct syscall syscall_read = {
 .name = ""read"",
 .num_args = 3,
",43,5
move remap_file_pages sanity into syscall def,"
 
 #include ""trinity.h""
 #include ""sanitise.h""
+#include ""arch.h""
+
+static void sanitise_remap_file_pages(
+unsigned long *start,
+unsigned long *size,
+__unused__ unsigned long *a3,
+__unused__ unsigned long *a4,
+unsigned long *pgoff,
+__unused__ unsigned long *a6)
+{
+
+*start = *start & PAGE_MASK;
+*size = *size & PAGE_MASK;
+
+
+retry_size:
+if (*start + *size <= *start) {
+*size = get_interesting_32bit_value() & PAGE_MASK;
+goto retry_size;
+}
+
+retry_pgoff:
+if (*pgoff + (*size >> PAGE_SHIFT) < *pgoff) {
+*pgoff = get_interesting_value();
+goto retry_pgoff;
+}
+
+retry_pgoff_bits:
+if (*pgoff + (*size >> PAGE_SHIFT) >= (1UL << PTE_FILE_MAX_BITS)) {
+*pgoff = (*pgoff >> 1);
+goto retry_pgoff_bits;
+}
+}
 
 struct syscall syscall_remap_file_pages = {
 .name = ""remap_file_pages"",
",47,4
move rt_sigaction sanity into syscall def,"
 size_t, sigsetsize)
 */
 #include <signal.h>
+#include <stdlib.h>
 
 #include ""trinity.h""
 #include ""sanitise.h""
 
+void sanitise_rt_sigaction(
+__unused__ unsigned long *a1,
+__unused__ unsigned long *a2,
+__unused__ unsigned long *a3,
+unsigned long *a4,
+__unused__ unsigned long *a5,
+__unused__ unsigned long *a6)
+{
+if ((rand() % 2) == 0)
+*a2 = 0;
+
+if ((rand() % 2) == 0)
+*a3 = 0;
+
+*a4 = sizeof(sigset_t);
+}
+
 struct syscall syscall_rt_sigaction = {
 .name = ""rt_sigaction"",
 .num_args = 4,
",32,3
move rt_sigprocmask sanity into syscall def,"
 * SYSCALL_DEFINE4(rt_sigprocmask, int, how, sigset_t __user *, set,
 sigset_t __user *, oset, size_t, sigsetsize)
 */
+#include <signal.h>
 #include ""trinity.h""
 #include ""sanitise.h""
 
+static void sanitise_rt_sigprocmask(
+__unused__ unsigned long *a1,
+__unused__ unsigned long *a2,
+__unused__ unsigned long *a3,
+unsigned long *a4,
+__unused__ unsigned long *a5,
+__unused__ unsigned long *a6)
+{
+*a4 = sizeof(sigset_t);
+}
+
 struct syscall syscall_rt_sigprocmask = {
 .name = ""rt_sigprocmask"",
 .num_args = 4,
",24,1
move sendto sanity into syscall def,"
 #include ""trinity.h""
 #include ""sanitise.h""
 
+void sanitise_sendto(__unused__ unsigned long *fd,
+__unused__ unsigned long *buff,
+__unused__ unsigned long *len,
+__unused__ unsigned long *flags,
+__unused__ unsigned long *addr,
+unsigned long *addr_len)
+{
+*addr_len %= 128;// MAX_SOCK_ADDR
+}
+
 struct syscall syscall_sendto = {
 .name = ""sendto"",
 .num_args = 6,
",36,1
move set_robust_list sanity into syscall def,"
 /*
 * SYSCALL_DEFINE2(set_robust_list, struct robust_list_head __user *, head, size_t, len)
 */
+#include <linux/futex.h>
 #include ""trinity.h""
 #include ""sanitise.h""
 
+static void sanitise_set_robust_list(
+__unused__ unsigned long *a1,
+unsigned long *len,
+__unused__ unsigned long *a3,
+__unused__ unsigned long *a4,
+__unused__ unsigned long *a5,
+__unused__ unsigned long *a6)
+{
+*len = sizeof(struct robust_list_head);
+}
+
 struct syscall syscall_set_robust_list = {
 .name = ""set_robust_list"",
 .num_args = 2,
",22,1
move sync_file_range sanity into syscall def,"
 /*
 * SYSCALL_DEFINE(sync_file_range)(int fd, loff_t offset, loff_t nbytes, unsigned int flags)
 */
+#define _GNU_SOURCE
 #include <linux/fs.h>
+#include <fcntl.h>
+#include <stdlib.h>
 
 #include ""trinity.h""
 #include ""sanitise.h""
+#include ""arch.h""
+
+static void sanitise_sync_file_range(__unused__ unsigned long *fd,
+unsigned long *offset,
+__unused__ unsigned long *nbytes,
+__unused__ unsigned long *a4,
+__unused__ unsigned long *a5,
+__unused__ unsigned long *a6)
+{
+unsigned long endbyte;
+
+retry:
+*offset = rand() & 0xfffffff;
+*nbytes = rand() & 0xfffffff;
+
+endbyte = *offset + *nbytes;
+
+if (endbyte < *offset)
+goto retry;
+
+if (*offset >= (0x100000000ULL << PAGE_SHIFT))
+goto retry;
+
+}
 
 struct syscall syscall_sync_file_range = {
 .name = ""sync_file_range"",
",39,3
move vmsplice sanity into syscall def,"
 */
 #define _GNU_SOURCE
 #include <fcntl.h>
+#include <sys/uio.h>
+#include <stdlib.h>
 
 #include ""trinity.h""
 #include ""sanitise.h""
 
+static void sanitise_vmsplice(
+__unused__ unsigned long *fd,
+__unused__ unsigned long *a2,
+unsigned long *a3,
+__unused__ unsigned long *a4,
+__unused__ unsigned long *a5,
+__unused__ unsigned long *a6)
+{
+*a3 = rand() % UIO_MAXIOV;
+}
+
 struct syscall syscall_vmsplice = {
 .name = ""vmsplice"",
 .num_args = 4,
",32,1
move writre sanity into syscall def,"
 /*
 * SYSCALL_DEFINE3(write, unsigned int, fd, const char __user *, buf, size_t, count)
 */
-
+#include <stdlib.h>
 #include ""trinity.h""
 #include ""sanitise.h""
 
+/*
+ * asmlinkage ssize_t sys_write(unsigned int fd, char __user * buf, size_t count)
+ */
+static void sanitise_write(
+__unused__ unsigned long *a1,
+unsigned long *a2,
+unsigned long *a3,
+__unused__ unsigned long *a4,
+__unused__ unsigned long *a5,
+__unused__ unsigned long *a6)
+{
+unsigned long newsize = *a3 & 0xffff;
+void *newbuffer;
+
+retry:
+newbuffer = malloc(newsize);
+if (newbuffer == NULL) {
+newsize >>= 1;
+goto retry;
+}
+
+free(filebuffer);
+filebuffer = newbuffer;
+filebuffersize = newsize;
+
+*a2 = (unsigned long) filebuffer;
+*a3 = newsize;
+}
+
 struct syscall syscall_write = {
 .name = ""write"",
 .num_args = 3,
",35,2
pass -1 to mmap 50% of the time when mapping MAP_ANONYMOUS,"
 unsigned long, prot, unsigned long, flags,
 unsigned long, fd, unsigned long, off)
 */
+#include <stdlib.h>
 #include <asm/mman.h>
 
 #ifndef MAP_UNINITIALIZED

 #include ""arch.h""
 
 void sanitise_mmap(
-__unused__ unsigned long *a1,
-__unused__ unsigned long *a2,
-__unused__ unsigned long *a3,
-__unused__ unsigned long *a4,
-__unused__ unsigned long *a5,
+__unused__ unsigned long *addr,
+__unused__ unsigned long *len,
+__unused__ unsigned long *prot,
+__unused__ unsigned long *flags,
+__unused__ unsigned long *fd,
 unsigned long *offset)
 {
+unsigned int i;
+
 *offset &= PAGE_MASK;
+
+if (*flags & MAP_ANONYMOUS) {
+i = rand() % 100;
+if (i > 50)
+*fd = -1;
+}
 }
+
 struct syscall syscall_mmap = {
 .name = ""mmap"",
 .num_args = 6,
",48,3
add a command line arg to force all sockets created to use a specific protocol.," static char spinner[]=""-\\|/"";
 
 static char *cachefilename=""trinity.socketcache"";
 
-#define TYPE_MAX 128
-#define PROTO_MAX 256
-
 #define MAX_PER_DOMAIN 5
 #define MAX_TRIES_PER_DOMAIN 10
 static char sockarray[PF_MAX];
 void generate_sockets(unsigned int nr_to_create)
 
 domain = i;
 type = rand() % TYPE_MAX;
-protocol = rand() % PROTO_MAX;
+
+if (do_specific_proto == 1)
+protocol = specific_proto;
+else
+protocol = rand() % PROTO_MAX;
 
 printf(""%c (%d sockets created. needed:%d) [domain:%d type:%d proto:%d] \r"",
 spinner[spin++], socks, nr_to_create,
",127,19
close maps file once we've read it.," void setup_maps()
 
 } while (!feof(f));
 
+fclose(f);
+
 /* free the empty map on the end */
 free(tmpmap);
 
",103,25
"if we pass -P, then ignore the cachefile."," void open_sockets()
 int bytesread=-1;
 int fd;
 
+if (do_specific_proto == 1) {
+printf(""ignoring socket cachefile due to specific protocol request.\n"");
+generate_sockets(fds_left_to_create/2);
+return;
+}
+
 cachefile = open(cachefilename, O_RDONLY);
 if (cachefile < 0) {
 printf(""Couldn't find socket cachefile. Regenerating.\n"");
",132,20
log that we're skipping mappings.," void setup_maps()
 /* skip over the shm (and any nearby mappings), in case we corrupt it*/
 if ((startaddr > (void *) shm - (PAGE_SIZE * 8)) &&
  (startaddr < (void *) shm + (PAGE_SIZE * 8))) {
+output(""skipping mapping at %p -> %p (too close to shm at %p)\n"", startaddr, endaddr, shm);
 do {
 ch = getc(f);
 } while ((ch != EOF) && (ch != '\n'));
",136,29
"move the zeropage mappings further away from the shm.

do this by creating a bunch of useless mmaps that will just take up VA space."," void * alloc_zero_map(struct map *map, int prot, char *name)
 sprintf(tmpmap->name, ""/dev/zero(%s)"", name);
 num_mappings++;
 
+output(""mapping[%d]: (zeropage %s) %p\n"", num_mappings - 1, name, tmpmap->ptr);
+
 close(fd);
 return tmpmap;
 }
 void setup_maps()
 FILE *f;
 void *startaddr, *endaddr;
 struct map *tmpmap;
-unsigned int ret;
+unsigned int ret, fd, i;
 char name[80];
 char ch;
 
 void setup_maps()
 fclose(f);
 output(""Added %d mappings from /proc/self\n"", num_mappings);
 
+/* Make sure our zero page mappings are nowhere near the shm. */
+fd = open(""/dev/zero"", O_RDWR);
+for (i = 0; i < 50; i++)
+mmap(NULL, PAGE_SIZE, PROT_READ, MAP_PRIVATE, fd, 0);
+close(fd);
+
 /* Add a bunch of /dev/zero mappings */
 tmpmap->next = alloc_zero_map(tmpmap, PROT_READ | PROT_WRITE, ""PROT_READ | PROT_WRITE"");
 tmpmap = tmpmap->next;
",141,30
Fix segv when passing an unknown protocol.," struct protocol {
 unsigned int proto;
 };
 
-static struct protocol protocols[PROTO_MAX] = {
+static struct protocol protocols[] = {
 { ""PF_UNSPEC"", 0 },
 { ""PF_LOCAL"", 1 },
 { ""PF_UNIX"", PF_LOCAL },
 static void find_specific_proto()
 
 if (specific_proto == 0) {
 /* we were passed a string */
-for (i = 0; i < PROTO_MAX; i++) {
+for (i = 0; i < (sizeof(protocols) / sizeof(struct protocol)); i++) {
 if (strcmp(specific_proto_optarg, p[i].name) == 0) {
 specific_proto = p[i].proto;
 break;
",499,91
"Address family should get passed in domain, not in proto.

TODO: Limit type/proto based on passed domain."," void generate_sockets(unsigned int nr_to_create)
 if (sockarray[i] == MAX_PER_DOMAIN)
 break;
 
-domain = i;
-type = rand() % TYPE_MAX;
-
 if (do_specific_proto == 1)
-protocol = specific_proto;
+domain = specific_proto;
 else
-protocol = rand() % PROTO_MAX;
+domain = i;
+
+type = rand() % TYPE_MAX;
+protocol = rand() % PROTO_MAX;
 
 printf(""%c (%d sockets created. needed:%d) [domain:%d type:%d proto:%d] \r"",
 spinner[spin++], socks, nr_to_create,
",132,20
"Reduce the range of the type arg, to speed up searching."," void generate_sockets(unsigned int nr_to_create)
 domain = i;
 
 type = rand() % TYPE_MAX;
+if ((rand() % 100) < 25)
+type |= SOCK_CLOEXEC;
+if ((rand() % 100) < 25)
+type |= SOCK_NONBLOCK;
+
 protocol = rand() % PROTO_MAX;
 
-printf(""%c (%d sockets created. needed:%d) [domain:%d type:%d proto:%d] \r"",
+printf(""%c (%d sockets created. needed:%d) [domain:%d type:0x%x proto:%d] \r"",
 spinner[spin++], socks, nr_to_create,
 domain, type, protocol);
 if (spin == 4)
 void generate_sockets(unsigned int nr_to_create)
 if (fd > -1) {
 socket_fds[socks] = fd;
 
-output(""fd[%i] = domain:%i type:%i protocol:%i\n"",
+output(""fd[%i] = domain:%i type:0x%x protocol:%i\n"",
 fd, domain, type, protocol);
 
 sockarray[i]++;
",136,22
"if we pass --proto, assume we only care about sockets."," int get_random_fd(void)
 unsigned int i;
 unsigned int fd = 0;
 
-i = rand() % 3;
+if (do_specific_proto == 1)
+i = 1;
+else
+i = rand() % 3;
+
 switch (i) {
 case 0:
 retry:fd = fds[rand() % fd_idx];
",52,10
"the --proto case is slow, so we want to use the cachefile where possible."," void open_sockets()
 int bytesread=-1;
 int fd;
 
-if (do_specific_proto == 1) {
-printf(""ignoring socket cachefile due to specific protocol request.\n"");
-generate_sockets(fds_left_to_create/2);
-return;
-}
-
 cachefile = open(cachefilename, O_RDONLY);
 if (cachefile < 0) {
 printf(""Couldn't find socket cachefile. Regenerating.\n"");
 void open_sockets()
 type = buffer[1];
 protocol = buffer[2];
 
+if (do_specific_proto == 1) {
+if (domain != specific_proto) {
+printf(""ignoring socket cachefile due to specific protocol request, and stale data in cachefile.\n"");
+generate_sockets(fds_left_to_create/2);
+return;
+}
+}
+
 fd = socket(domain, type, protocol);
 if (fd < 0) {
 printf(""Cachefile is stale. Need to regenerate.\n"");
",138,23
display possible values for -P," static void find_specific_proto()
 }
 
 if (i > PF_MAX) {
-printf(""Protocol unknown, or out of range [0-%d]\n"", PF_MAX);
+printf(""Protocol unknown. Pass a numeric value [0-%d] or one of "", PF_MAX);
+for (i = 0; i < (sizeof(protocols) / sizeof(struct protocol)); i++)
+printf(""%s "", p[i].name);
+printf(""\n"");
+
 exit(EXIT_FAILURE);
 }
 
",502,92
speed up ipv6 socket creation," void generate_sockets(unsigned int nr_to_create)
 domain = i;
 
 type = rand() % TYPE_MAX;
+protocol = rand() % PROTO_MAX;
+
+switch (domain) {
+
+case AF_INET6:
+if (type == SOCK_STREAM)
+protocol = 0;
+break;
+
+default:
+;;
+}
+
 if ((rand() % 100) < 25)
 type |= SOCK_CLOEXEC;
 if ((rand() % 100) < 25)
 type |= SOCK_NONBLOCK;
 
-protocol = rand() % PROTO_MAX;
-
 printf(""%c (%d sockets created. needed:%d) [domain:%d type:0x%x proto:%d] \r"",
 spinner[spin++], socks, nr_to_create,
 domain, type, protocol);
",146,25
remove references to old modes that have been removed.," static void parse_args(int argc, char *argv[])
 if (opmode == MODE_UNDEFINED) {
 if (optarg != NULL)
 fprintf(stderr, ""Unrecognised mode \'%s\'\n"", optarg);
-fprintf(stderr, ""--mode must be one of random, rotate, regval, ""
-""or struct\n\n"");
+fprintf(stderr, ""--mode must be either random or rotate\n\n"");
 usage();
 exit(EXIT_FAILURE);
 }
",502,93
exit if the option parser fails.," static void parse_args(int argc, char *argv[])
 while ((opt = getopt_long(argc, argv, ""b:Bc:Fhikl:LN:m:P:ps:S:ux:z"", longopts, NULL)) != -1) {
 switch (opt) {
 default:
+if (opt == '?')
+exit(EXIT_FAILURE);
+else
+printf(""opt:%c\n"", opt);
+
 case '\0':
 return;
 
",506,94
"Remove the remnants of the struct mode.

This is better done in the sanitise code to pass structs
that actually look semi-sensible."," static void do_syscall_from_child(int cl)
 
 void display_opmode(void)
 {
-printf(""trinity mode: %s\n"", opmodename[opmode]);
+output(""trinity mode: %s\n"", opmodename[opmode]);
 
-switch (opmode) {
-
-case MODE_ROTATE:
-switch (passed_type) {
-case TYPE_STRUCT:
-printf(""struct mode = %s\n"", structmodename[structmode]);
-if (structmode == STRUCT_CONST)
-printf(""struct fill value is 0x%x\n"", (int)struct_fill);
-break;
-}
-
-printf(""Rotating value %lx though all registers\n"", regval);
-break;
-}
-
-(void)fflush(stdout);
+if (opmode == MODE_ROTATE)
+output(""Rotating value %lx though all registers\n"", regval);
 }
 
 void main_loop(void)
 void main_loop(void)
 regenerate_random_page();
 
 /* If we're passing userspace addresses, mess with alignment */
-if ((passed_type == TYPE_VALUE) &&
- ((regval & ~0xf) == (unsigned long)page_zeros))
+if ((regval & ~0xf) == (unsigned long)page_zeros)
 regval = (unsigned long)page_zeros+(rand() & 0xf);
 
 }
",240,62
"Remove alignment special case for rotate mode

This is done in the generic sanitise code."," void main_loop(void)
 break;
 
 regenerate_random_page();
-
-/* If we're passing userspace addresses, mess with alignment */
-if ((regval & ~0xf) == (unsigned long)page_zeros)
-regval = (unsigned long)page_zeros+(rand() & 0xf);
-
 }
 done: ;
 }
",238,61
add missing format string.," void output(const char *fmt, ...)
 }
 printf(""%s"", outputbuf);
 
-fprintf(logfile, outputbuf);
+fprintf(logfile, ""%s"", outputbuf);
 }
",30,4
Don't use output() before we opened the logfile.," static void parse_args(int argc, char *argv[])
 /* Set seed */
 case 's':
 seed = strtol(optarg, NULL, 10);
-output(""Setting random seed to %d\n"", seed);
 srand(seed);
 break;
 
 int main(int argc, char* argv[])
 
 if (!seed)
 seed_from_tod();
+output(""Setting random seed to %d\n"", seed);
 
 key = rand64();
 if ((shmid = shmget(key, sizeof(struct shm_s), IPC_CREAT | 0666)) < 0) {
",458,85
"be defensive in output()

this should hopefully prevent the previous bug from reoccuring.","
 #include <stdio.h>
+#include <stdlib.h>
 #include <stdarg.h>
 #include <unistd.h>
 
 void output(const char *fmt, ...)
 }
 printf(""%s"", outputbuf);
 
+if (logfile == NULL) {
+printf(""Logfile not open!\n"");
+exit(EXIT_FAILURE);
+}
 fprintf(logfile, ""%s"", outputbuf);
 }
",35,5
output seed in hex (and only when passed -s)," int main(int argc, char* argv[])
 
 if (!seed)
 seed_from_tod();
-output(""Setting random seed to %d\n"", seed);
+else
+output(""Setting random seed to 0x%x\n"", seed);
 
 key = rand64();
 if ((shmid = shmget(key, sizeof(struct shm_s), IPC_CREAT | 0666)) < 0) {
",459,85
"actually, log it in both bases"," void seed_from_tod()
 gettimeofday(&t, 0);
 seed = t.tv_sec * t.tv_usec;
 srand(seed);
-output(""Randomness reseeded to 0x%x\n"", seed);
+output(""Randomness reseeded to %d (0x%x)\n"", seed, seed);
 }
 
 
 int main(int argc, char* argv[])
 if (!seed)
 seed_from_tod();
 else
-output(""Setting random seed to 0x%x\n"", seed);
+output(""Setting random seed to %d (0x%x)\n"", seed, seed);
 
 key = rand64();
 if ((shmid = shmget(key, sizeof(struct shm_s), IPC_CREAT | 0666)) < 0) {
",459,85
"Fix -c 0 parsing

The check for 'was the parameter numeric' was pretty bogus, and failed if
the number passed was 0."," static void find_specific_syscall()
 {
 unsigned int i;
 
-if (specific_syscall != 0) {
+if (isdigit(*specific_syscall_optarg)) {
 i = specific_syscall;
 if (syscalls[i].entry->flags &= AVOID_SYSCALL) {
 printf(""%s is marked AVOID_SYSCALL (probably for good reason)\n"", syscalls[i].entry->name);
",459,85
"not pretty, but this works."," force_32bit:
 specific_syscall = i;
 printf(""Forcing into 32bit mode.\n"");
 do_32bit = 1;
+syscalls = syscalls_i386;
+max_nr_syscalls = NR_I386_SYSCALLS;
 break;
 }
 }
",461,85
a new page to pass around. a page of pointers.," void * get_address()
 {
 int i;
 
-i = rand() % 6;
+i = rand() % 7;
 switch (i) {
 case 0:return (void *) KERNEL_ADDR;
 case 1:return page_zeros;
 case 2:return page_0xff;
 case 3:return page_rand;
-case 4:return (void *) get_interesting_value();
-case 5: return get_map();
+case 4: return page_allocs;
+case 5:return (void *) get_interesting_value();
+case 6: return get_map();
 }
 
 return 0;
 static unsigned long fill_arg(int call, int argnum)
 return mask;
 
 case ARG_RANDPAGE:
-return (unsigned long) page_rand;
+if ((rand() % 2) == 0)
+return (unsigned long) page_allocs;
+else
+return (unsigned long) page_rand;
 }
 
 return 0x5a5a5a5a;/* Should never happen */
",240,90
use different data sizes in random page.," void regenerate_random_page()
 void *addr;
 
 /* sometimes return a page of complete trash */
-if ((rand() % 100) < 20) {
-for (i = 0; i < page_size; i++)
-page_rand[i] = (unsigned char)rand();
-return;
+if ((rand() % 100) < 50) {
+unsigned int type = rand() % 3;
+
+switch (type) {
+case 0:/* bytes */
+for (i = 0; i < page_size; i++)
+page_rand[i++] = (unsigned char)rand();
+return;
+
+case 1:/* ints */
+for (i = 0; i < (page_size / 2); i++) {
+page_rand[i++] = 0;
+page_rand[i++] = (unsigned char)rand();
+}
+return;
+
+case 2:/* longs */
+for (i = 0; i < (page_size / 4); i++) {
+page_rand[i++] = 0;
+page_rand[i++] = 0;
+page_rand[i++] = 0;
+page_rand[i++] = (unsigned char)rand();
+}
+return;
+}
 }
 
 /* sometimes return a page that looks kinda like a struct */
",258,95
don't log the mode over and over," void display_opmode(void)
 
 if (opmode == MODE_ROTATE)
 output(""Rotating value %lx though all registers\n"", regval);
+
+sync_output();
 }
 
 void main_loop(void)
",221,57
make sure we always log before doing the syscall.," static long mkcall(unsigned int call)
 args_done:
 sptr += sprintf(sptr, WHITE "") "");
 
-if (!quiet) {
-output(""%s"", string);
-sptr = string;
-
-sync_output();
-}
+output(""%s"", string);
+sptr = string;
+sync_output();
 
 if (dopause == 1)
 sleep(1);
",228,59
speed up X25 packet creation," void generate_sockets(unsigned int nr_to_create)
 
 switch (domain) {
 
+case AF_X25:
+type = SOCK_SEQPACKET;
+break;
+
 case AF_INET6:
 if (type == SOCK_STREAM)
 protocol = 0;
",150,26
"fix pid randomisation in generic-sanitise.

I noticed, the get_pid() function in generic-sanitise.c
seems to have too small a value for the rand()/% call, and
the pid mask (if that's what it's supposed to be) is doing a 0 or
1^16 setting, not masking at all."," void regenerate_random_page()
 static unsigned int get_pid()
 {
 int i;
-i = rand() % 2;
+i = rand() % 3;
 
 switch (i) {
 case 0:return getpid();
-case 1:return rand() & 32768;
+case 1:return rand() & 32767;
 case 2: break;
 }
 return 0;
",258,95
"Add perf_event_open() sanitise

I was looking to extend trinity to be better at finding perf_event bugs,
as I spend a non-trivial amount of time bisecting kernel DoS caused by
perf_event.

Below is a start of a sanitise function."," static unsigned int get_pid()
 return 0;
 }
 
+static unsigned int get_cpu()
+{
+int i;
+i = rand() % 3;
+
+switch (i) {
+case 0: return -1;
+case 1: return rand() & 4095;
+case 2: return rand() & 15;
+}
+return 0;
+}
 
 static unsigned long fill_arg(int call, int argnum)
 {
 static unsigned long fill_arg(int call, int argnum)
 return (unsigned long) page_allocs;
 else
 return (unsigned long) page_rand;
+
+case ARG_CPU:
+return (unsigned long) get_cpu();
 }
 
 return 0x5a5a5a5a;/* Should never happen */
",271,100
"Check /proc/sys/kernel/tainted after each syscall.
Stop fuzzing if we find the kernel has become tainted.","
 #include <ctype.h>
 #include <unistd.h>
 #include <getopt.h>
+#include <fcntl.h>
 #include <asm/unistd.h>
 #include <sys/time.h>
 #include <sys/types.h>

 #include <sys/syscall.h>
 #include <sys/ipc.h>
 #include <sys/shm.h>
+#include <sys/stat.h>
 
 #include ""arch.h""
 #include ""trinity.h""
 void display_opmode(void)
 sync_output();
 }
 
+
+static int check_tainted(void)
+{
+int fd;
+int ret;
+char buffer[4];
+
+fd = open(""/proc/sys/kernel/tainted"", O_RDONLY);
+if (!fd)
+return -1;
+ret = read(fd, buffer, 3);
+close(fd);
+ret = atoi(buffer);
+
+return ret;
+}
+
+
 void main_loop(void)
 {
+int ret;
+
 for (;;) {
 
 if (ctrlc_hit == 1)
 void main_loop(void)
 break;
 
 regenerate_random_page();
+
+ret = check_tainted();
+if (ret != 0) {
+output(""kernel became tainted! (%d)\n"", ret);
+ctrlc_hit = 1;
+return;
+}
 }
 done: ;
 }
",250,62
"Fix ridiculously stupid bug that broke the actual syscall.

This is up there in the top 10 'stupid bugs I wrote'.
We were only ever fuzzing lstat for the last four months."," args_done:
 call += 1024;
 #endif
 
-ret = syscall(syscalls[call].entry->num_args, call, a1, a2, a3, a4, a5, a6);
+ret = syscall(call, a1, a2, a3, a4, a5, a6);
 
 if (ret < 0) {
 sptr +=sprintf(sptr, RED ""= %d (%s)"" WHITE, ret, strerror(errno));
",250,62
"If the kernel was tainted on startup, run anyway.","
 //#include ""files.h""
 #include ""sanitise.h""
 
+unsigned char do_check_tainted;
+
 static long res = 0;
 
 static long mkcall(unsigned int call)
 void display_opmode(void)
 }
 
 
-static int check_tainted(void)
+int check_tainted(void)
 {
 int fd;
 int ret;
 void main_loop(void)
 
 regenerate_random_page();
 
-ret = check_tainted();
-if (ret != 0) {
-output(""kernel became tainted! (%d)\n"", ret);
-ctrlc_hit = 1;
-return;
+/* Only check taint if it was zero on startup */
+if (do_check_tainted == 0) {
+ret = check_tainted();
+if (ret != 0) {
+output(""kernel became tainted! (%d)\n"", ret);
+ctrlc_hit = 1;
+return;
+}
 }
 }
 done: ;
",253,63
"Fix double increment.

Spotted by Sasha Levin."," static void init_buffers()
 exit(EXIT_FAILURE);
 
 for (i = 0; i < (page_size / sizeof(unsigned long *)); i++)
-allocs[i++] = (unsigned long) malloc(page_size);
+allocs[i] = (unsigned long) malloc(page_size);
 
 setup_maps();
 }
",460,84
pass some 0-0xff bytes around.," unsigned long get_interesting_32bit_value()
 
 if (i > 3) {
 /* common case, return small values*/
-i = rand() % 6;
+i = rand() % 7;
 
 switch (i) {
 case 0:return 0x00000001;
-case 1:return 0x00000fff;// 4095
-case 2:return 0x00001000;// 4096
-case 3:return 0x00001001;// 4097
-case 4:return 0x00008000;
-case 5:return 0x0000ffff;
+case 1:return rand() % 256;
+case 2:return 0x00000fff;// 4095
+case 3:return 0x00001000;// 4096
+case 4:return 0x00001001;// 4097
+case 5:return 0x00008000;
+case 6:return 0x0000ffff;
 }
 
 } else {
",272,101
make 0 an interesting 32 bit number too," unsigned long get_interesting_32bit_value()
 
 if (i > 3) {
 /* common case, return small values*/
-i = rand() % 7;
+i = rand() % 8;
 
 switch (i) {
-case 0:return 0x00000001;
-case 1:return rand() % 256;
-case 2:return 0x00000fff;// 4095
-case 3:return 0x00001000;// 4096
-case 4:return 0x00001001;// 4097
-case 5:return 0x00008000;
-case 6:return 0x0000ffff;
+case 0:return 0x00000000;
+case 1:return 0x00000001;
+case 2:return rand() % 256;
+case 3:return 0x00000fff;// 4095
+case 4:return 0x00001000;// 4096
+case 5:return 0x00001001;// 4097
+case 6:return 0x00008000;
+case 7:return 0x0000ffff;
 }
 
 } else {
",273,102
"Some random files tweaks

- Add debugfs files to the mix
- Decrease the likelyhood of a file being added
- Keep scanning for files until we have enough."," static int add_fd(unsigned int chance, char *b, int flags)
 {
 int fd = -1;
 
-if ((unsigned int)(rand() % 100) < chance) {
+if ((unsigned int)(rand() % 5000) < chance) {
 fd = open(b, flags | O_NONBLOCK);
 if (fd < 0)
 return -1;
 openit:
 
 void open_files()
 {
+more:
+open_fds(""/sys/kernel/debug"");
 open_fds(""/dev"");
 open_fds(""/proc"");
 open_fds(""/sys"");
+if (fds_left_to_create > 0)
+goto more;
 }
 
 void close_files()
",155,37
"FD regeneration should happen in the parent, not the child."," retry_same:
 }
 }
 
+failed_repeat:
+
+skip_syscall:
+return res;
+}
+
+static void do_syscall_from_child(int cl)
+{
+int ret;
+
 if (!shm->regenerate_fds) {
 close_files();
 open_files();
 retry_same:
 shm->regenerate_fds--;
 
 
-failed_repeat:
-
-skip_syscall:
-return res;
-}
-
-static void do_syscall_from_child(int cl)
-{
-int ret;
-
 if (nofork==1) {
 ret = do_syscall(cl);
 return;
",253,63
Handle ctrl-c properly during the file scan.," void open_fds(char *dir)
 return;
 }
 while ((de = readdir(d))) {
+
+if (ctrlc_hit == 1)
+exit(EXIT_SUCCESS);
+
 memset(&buf, 0, sizeof(struct stat));
 snprintf(b, sizeof(b), ""%s/%s"", dir, de->d_name);
 if (ignore_files(de->d_name))
",157,38
Add a sanitise function to mbind to eliminate hard coded PAGE_SIZE usage,"
 #include ""trinity.h""
 #include ""sanitise.h""
 
+static void sanitise_mbind(
+__unused__ unsigned long *a0,
+__unused__ unsigned long *a1,
+__unused__ unsigned long *a2,
+__unused__ unsigned long *a3,
+unsigned long *maxnode,
+__unused__ unsigned long *a5)
+{
+
+retry_maxnode:
+if (*maxnode < 2 || (*maxnode) > (page_size * 8)) {
+*maxnode = get_interesting_value();
+goto retry_maxnode;
+}
+}
+
+
+
 struct syscall syscall_mbind = {
 .name = ""mbind"",
 .num_args = 6,
 struct syscall syscall_mbind = {
 
 .arg5name = ""maxnode"",
 .arg5type = ARG_RANGE,
-.low5range = 2,
-.hi5range = PAGE_SIZE * 8,
 
 .arg6name = ""flags"",
 .arg6type = ARG_LIST,
 struct syscall syscall_mbind = {
 .num = 2,
 .values = { MPOL_F_STATIC_NODES, MPOL_F_RELATIVE_NODES },
 },
+.sanitise = sanitise_mbind
 };
",40,3
"Remove some noise when using --quiet with trinity

cut down on some of the console noise when using the --quiet option."," void generate_sockets(unsigned int nr_to_create)
 if ((rand() % 100) < 25)
 type |= SOCK_NONBLOCK;
 
-printf(""%c (%d sockets created. needed:%d) [domain:%d type:0x%x proto:%d] \r"",
+output(""%c (%d sockets created. needed:%d) [domain:%d type:0x%x proto:%d] \r"",
 spinner[spin++], socks, nr_to_create,
 domain, type, protocol);
 if (spin == 4)
",150,26
"sendmsg sanitisation.

* Fabricrate a fake msghdr struct to pass to the syscall

* Beginning of some infrastructure here to allocate objects.
 For now, don't worry about freeing them.
 As the allocations all happen in a child process that exits,
 this shouldn't be a big deal."," void * get_address()
 {
 int i;
 
-i = rand() % 7;
+i = rand() % 8;
 switch (i) {
 case 0:return (void *) KERNEL_ADDR;
 case 1:return page_zeros;
 void * get_address()
 case 4: return page_allocs;
 case 5:return (void *) get_interesting_value();
 case 6: return get_map();
+case 7: return malloc(page_size);
 }
 
 return 0;
 static unsigned int get_cpu()
 return 0;
 }
 
+unsigned long get_len()
+{
+int i;
+
+i = get_interesting_value();
+
+switch(rand() % 4) {
+
+case 0:return (i & 0xff);
+case 1:return (i & 0xffff);
+case 2:return (i & 0xffffff);
+case 3:return (i & 0xffffffff);
+}
+
+return i;
+}
+
 static unsigned long fill_arg(int call, int argnum)
 {
 int fd;
 static unsigned long fill_arg(int call, int argnum)
 //printf (YELLOW ""DBG: %x"" WHITE ""\n"", fd);
 return fd;
 case ARG_LEN:
-if ((rand() % 2) == 0)
-return rand() % page_size;
-else
-return get_interesting_value();
+return (unsigned long)get_len();
+
 case ARG_ADDRESS:
 return (unsigned long)get_address();
 case ARG_PID:
",283,107
remove annoying pragma's," unsigned long get_interesting_32bit_value()
 
 unsigned long get_interesting_value()
 {
-
-/* /usr/include/bits/wordsize.h */
 #if __WORDSIZE == 32
-#pragma message(""__WORDSIZE == 32"")
 return get_interesting_32bit_value();
 #else
-#pragma message(""__WORDSIZE == 64"")
 int i;
 unsigned long low;
 
",283,107
sanitise function for socket(),"
 /*
 * SYSCALL_DEFINE3(socket, int, family, int, type, int, protocol)
 */
+
+#include <stdlib.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+
 #include ""trinity.h""
 #include ""sanitise.h""
 
+/* note: will eventually also be called from sanitise_socketcall, and generate_sockets() */
+void sanitise_socket(
+ unsigned long *family,
+ unsigned long *type,
+ unsigned long *protocol,
+ __unused__ unsigned long *a4,
+ __unused__ unsigned long *a5,
+ __unused__ unsigned long *a6)
+{
+*family = rand() % PF_MAX;
+*type = rand() % TYPE_MAX;
+*protocol = rand() % PROTO_MAX;
+
+switch (*family) {
+
+case AF_X25:
+*type = SOCK_SEQPACKET;
+break;
+
+case AF_INET6:
+if (*type == SOCK_STREAM)
+*protocol = 0;
+break;
+}
+}
+
 struct syscall syscall_socket = {
 .name = ""socket"",
 .num_args = 3,
 .arg1name = ""family"",
 .arg2name = ""type"",
 .arg3name = ""protocol"",
+.sanitise = sanitise_socket,
 };
",34,4
add ->socket to socketcall sanitiser,"
 #include ""sanitise.h""
 
 static void sanitise_socketcall(
-__unused__ unsigned long *call,
+unsigned long *call,
 unsigned long *argptr,
 __unused__ unsigned long *a3,
 __unused__ unsigned long *a4,
 static void sanitise_socketcall(
 __unused__ unsigned long *a6)
 {
 unsigned long *args;
-
 args = malloc(6 * sizeof(unsigned long));
 
 *call = rand() % 20;
 
 switch (*call) {
 case SYS_SOCKET:
+sanitise_socket(&args[0], &args[1], &args[2], NULL, NULL, NULL);
 break;
 case SYS_BIND:
 break;
 static void sanitise_socketcall(
 case SYS_SENDMMSG:
 break;
 }
-*argptr = (unsigned long) &args;
+*argptr = (unsigned long) args;
 }
 
 struct syscall syscall_socketcall = {
",68,21
"remove duplicate random socket code from sockets.c

use the code from the sanitise function of socket()","
 #include ""trinity.h""
 #include ""sanitise.h""
 
-/* note: will eventually also be called from sanitise_socketcall, and generate_sockets() */
+/* note: also called from generate_sockets() & sanitise_socketcall() */
 void sanitise_socket(
 unsigned long *family,
 unsigned long *type,
 void sanitise_socket(
 *protocol = 0;
 break;
 }
+
+if ((rand() % 100) < 25)
+*type |= SOCK_CLOEXEC;
+if ((rand() % 100) < 25)
+*type |= SOCK_NONBLOCK;
 }
 
 struct syscall syscall_socket = {
",38,6
"Fix memory leak.

We can't call regenerate_random_page() from the parent, because we don't
track the memory it may allocate, which leads to leaking massive amounts
of memory when we regenerate every syscall.

* Do the regeneration in the child.
* Don't regenerate the page every syscall (unless we're fuzzing just one specific syscall)"," static void do_syscall_from_child(int cl)
 }
 
 if (fork() == 0) {
+if (!shm->regenerate_fds)
+regenerate_random_page();
+if (do_specific_syscall == 1)
+regenerate_random_page();
 ret = do_syscall(cl);
 _exit(ret);
 }
 void main_loop(void)
 break;
 
 case MODE_RANDOM:
+rep = rand();
 do_syscall_from_child(rep);
 break;
 }
 void main_loop(void)
 if (syscallcount && (shm->execcount >= syscallcount))
 break;
 
-regenerate_random_page();
-
 /* Only check taint if it was zero on startup */
 if (do_check_tainted == 0) {
 ret = check_tainted();
",257,65
"rename the regeneration variable

it regenerates more than just the fd's."," static void do_syscall_from_child(int cl)
 {
 int ret;
 
-if (!shm->regenerate_fds) {
+if (!shm->regenerate) {
 close_files();
 open_files();
 
 destroy_maps();
 setup_maps();
 
-shm->regenerate_fds = FD_REGENERATION_POINT - 1;
+shm->regenerate = REGENERATION_POINT - 1;
 }
-shm->regenerate_fds--;
+shm->regenerate--;
 
 
 if (nofork==1) {
 static void do_syscall_from_child(int cl)
 }
 
 if (fork() == 0) {
-if (!shm->regenerate_fds)
+if (!shm->regenerate)
 regenerate_random_page();
 if (do_specific_syscall == 1)
 regenerate_random_page();
",257,65
add some infrastructure for making versioned releases.," int main(int argc, char* argv[])
 unsigned int i;
 key_t key;
 
+printf(""Trinity v"" __stringify(VERSION) "" Dave Jones <davej@redhat.com> 2012\n"");
+
 #ifdef __x86_64__
 syscalls = syscalls_x86_64;
 max_nr_syscalls = NR_X86_64_SYSCALLS;
",463,85
Fix an occasional fp exception on startup.," static void init_buffers()
 page_rand = malloc(page_size);
 if (!page_rand)
 exit(EXIT_FAILURE);
-regenerate_random_page();
 
 page_allocs = malloc(page_size);
 allocs = (void *)page_allocs;
 static void init_buffers()
 allocs[i] = (unsigned long) malloc(page_size);
 
 setup_maps();
+
+// regenerate_random_page may end up using maps, so has to be last.
+regenerate_random_page();
 }
 
 static void sighandler(int sig)
",463,85
log the pid of the child making the syscall.," static long mkcall(unsigned int call)
 int ret = 0;
 char string[512], *sptr=string;
 
-sptr += sprintf(sptr, ""%lu: "", shm->execcount);
+sptr += sprintf(sptr, ""[%d] %lu: "", getpid(), shm->execcount);
 
 switch (opmode) {
 case MODE_ROTATE:
",257,65
"split syscall.c into main.c

The mainloop code should live in its own file as it doesn't do anything
with syscalls directly.","
 /*
 * SYSCALL_DEFINE(sync_file_range)(int fd, loff_t offset, loff_t nbytes, unsigned int flags)
 */
-#define _GNU_SOURCE
 #include <linux/fs.h>
 #include <fcntl.h>
 #include <stdlib.h>
",41,3
Fix up some splint warnings," char *opmodename[] = {
 [MODE_ROTATE] = ""rotate"",
 };
 
-char *userbuffer;
 char *page_zeros;
 char *page_0xff;
 char *page_rand;
 static char *specific_proto_optarg;
 static void init_buffers()
 {
 unsigned int i;
-unsigned long *allocs;
-
-userbuffer = malloc(page_size);
-if (!userbuffer)
-exit(EXIT_FAILURE);
 
 page_zeros = malloc(page_size);
 if (!page_zeros)
 static void init_buffers()
 page_rand = malloc(page_size);
 if (!page_rand)
 exit(EXIT_FAILURE);
+memset(page_rand, 0x55, page_size);/* overwritten below */
 
 page_allocs = malloc(page_size);
-allocs = (void *)page_allocs;
 if (!page_allocs)
 exit(EXIT_FAILURE);
+memset(page_allocs, 0xff, page_size);
 
 for (i = 0; i < (page_size / sizeof(unsigned long *)); i++)
-allocs[i] = (unsigned long) malloc(page_size);
+page_allocs[i] = (unsigned long) malloc(page_size);
 
 setup_maps();
 
 static void parse_args(int argc, char *argv[])
 exit(EXIT_FAILURE);
 else
 printf(""opt:%c\n"", opt);
+return;
 
 case '\0':
 return;
",459,84
"Do multiple syscalls per child

- By default do 5 syscalls per child forked
- Change the -F parameter to override the number of syscalls.
 (The old ""don't fork"" behaviour of -F was broken, and no longer applies)"," skip_syscall:
 
 void do_syscall_from_child(int cl)
 {
-int ret;
+int ret = 0;
 
 if (!shm->regenerate) {
 close_files();
 void do_syscall_from_child(int cl)
 }
 shm->regenerate--;
 
+if (fork() == 0) {
+while (syscalls_per_child > 0) {
 
-if (nofork==1) {
-ret = do_syscall(cl);
-return;
-}
+if (!shm->regenerate)
+regenerate_random_page();
+if (do_specific_syscall == 1)
+regenerate_random_page();
+
+ret = do_syscall(cl);
+
+syscalls_per_child--;
+
+if (ctrlc_hit == 1)
+break;
+}
 
-if (fork() == 0) {
-if (!shm->regenerate)
-regenerate_random_page();
-if (do_specific_syscall == 1)
-regenerate_random_page();
-ret = do_syscall(cl);
 _exit(ret);
 }
 (void)waitpid(-1, NULL, 0);
 }
-
",148,37
annotate VM syscalls as belong to GROUP_VM," struct syscall syscall_mbind = {
 .num = 2,
 .values = { MPOL_F_STATIC_NODES, MPOL_F_RELATIVE_NODES },
 },
-.sanitise = sanitise_mbind
+.sanitise = sanitise_mbind,
+.group = GROUP_VM,
 };
",41,3
"Call the right syscall when in group mode.

Because we reconstruct the syscall table, we can't use a syscalls
position in it as its syscall number."," args_done:
 call += 1024;
 #endif
 
-ret = syscall(call, a1, a2, a3, a4, a5, a6);
+ret = syscall(syscalls[call].entry->number, a1, a2, a3, a4, a5, a6);
 
 if (ret < 0) {
 sptr +=sprintf(sptr, RED ""= %d (%s)"" WHITE, ret, strerror(errno));
",148,37
"sanitise mlock[all]

Passing 0 to this just EINVAL's.","
 /*
 * SYSCALL_DEFINE2(mlock, unsigned long, start, size_t, len)
 */
+#include <stdlib.h>
 #include ""trinity.h""
 #include ""sanitise.h""
 
+#define MCL_CURRENT1
+#define MCL_FUTURE2
+
+static void sanitise_mlock(unsigned long *flags,
+__unused__ unsigned long *a2,
+__unused__ unsigned long *a3,
+__unused__ unsigned long *a4,
+__unused__ unsigned long *a5,
+__unused__ unsigned long *a6)
+{
+if (*flags != 0)
+return;
+
+if ((rand() % 2) == 0)
+*flags = MCL_CURRENT;
+else
+*flags = MCL_FUTURE;
+}
+
 struct syscall syscall_mlock = {
 .name = ""mlock"",
 .num_args = 2,
 struct syscall syscall_mlock = {
 .arg2name = ""len"",
 .arg2type = ARG_LEN,
 .group = GROUP_VM,
+.sanitise = sanitise_mlock,
 };
",26,3
annotate addr param of mlock/munlock," static void sanitise_mlock(unsigned long *flags,
 struct syscall syscall_mlock = {
 .name = ""mlock"",
 .num_args = 2,
-.arg1name = ""start"",
+.arg1name = ""addr"",
+.arg1type = ARG_ADDRESS,
 .arg2name = ""len"",
 .arg2type = ARG_LEN,
 .group = GROUP_VM,
",27,3
"remove the rotate mode.

There's really no good reason to have this mode, now that coverage
with random mode has improved so much.

With random being the only mode left, remove the --mode code too."," void syscall_list()
  printf(""%u: %s\n"", i, syscalls[i].entry->name);
 }
 
-void display_opmode(void)
-{
-output(""trinity mode: %s\n"", opmodename[opmode]);
-
-if (opmode == MODE_ROTATE)
-output(""Rotating value %lx though all registers\n"", regval);
-
-sync_output();
-}
-
 void main_loop(void)
 {
 int ret;
 void main_loop(void)
 if (ctrlc_hit == 1)
 return;
 
-switch (opmode) {
-case MODE_ROTATE:
-if (rep == max_nr_syscalls) {
-/* Pointless running > once. */
-if (rotate_mask == (1<<6)-1)
-goto done;
-rep = 0;
-rotate_mask++;
-}
-do_syscall_from_child(rep);
-break;
-
-case MODE_RANDOM:
-rep = rand();
-do_syscall_from_child(rep);
-break;
-}
+rep = rand();
+do_syscall_from_child(rep);
 
 rep++;
 if (syscallcount && (shm->execcount >= syscallcount))
 void main_loop(void)
 }
 }
 }
-done: ;
 }
 
 void do_main_loop(void)
 {
 shm->execcount = 1;
 
-if (opmode != MODE_RANDOM) {
-main_loop();
-return;
-}
-
 while (1) {
 sigsetjmp(ret_jump, 1);
 printf(""forking new child.\n"");
",71,20
remove unnecessary initialisation," static long res = 0;
 
 static long mkcall(unsigned int call)
 {
-unsigned long olda1=0, olda2=0, olda3=0, olda4=0, olda5=0, olda6=0;
-unsigned long a1=0, a2=0, a3=0, a4=0, a5=0, a6=0;
+unsigned long olda1, olda2, olda3, olda4, olda5, olda6;
+unsigned long a1, a2, a3, a4, a5, a6;
 int ret = 0;
 char string[512], *sptr=string;
 
 sptr += sprintf(sptr, ""[%d] %lu: "", getpid(), shm->execcount);
 
-a1 = rand64();
-a2 = rand64();
-a3 = rand64();
-a4 = rand64();
-a5 = rand64();
-a6 = rand64();
+olda1 = a1 = rand64();
+olda2 = a2 = rand64();
+olda3 = a3 = rand64();
+olda4 = a4 = rand64();
+olda5 = a5 = rand64();
+olda6 = a6 = rand64();
 
 if (call > max_nr_syscalls)
 sptr += sprintf(sptr, ""%u"", call);
 else
 sptr += sprintf(sptr, ""%s"", syscalls[call].entry->name);
 
-olda1=a1; olda2=a2; olda3=a3; olda4=a4; olda5=a5; olda6=a6;
-
 if (intelligence == 1) {
 generic_sanitise(call, &a1, &a2, &a3, &a4, &a5, &a6);
 if (syscalls[call].entry->sanitise)
",132,27
favor adding writable files to the fd table," void open_fds(char *dir)
 
 if ((openflag & O_RDONLY) && (openflag & O_WRONLY))
 openflag = O_RDWR;
-// for files, increase the probability of success
-chance = 10;
+
+/* files have a higher probability of success than directories
+ * also, writable files are probably more 'fun' */
+switch (openflag) {
+case O_RDONLY:chance = 10; break;
+case O_WRONLY:chance = 100; break;
+case O_RDWR:chance = 100; break;
+}
 openit:
 if (fds_left_to_create == 0)
 break;
",161,41
lets throw remap_file_pages in with the vm group too," struct syscall syscall_remap_file_pages = {
 .num = 1,
 .values = { MAP_NONBLOCK },
 },
+.group = GROUP_VM,
 };
",48,4
"improve coverage of mmap sanitiser

this seems to be occasionally causing malloc pool corruption.
Probably needs some boundary checking like the maps code."," void sanitise_mmap(
 {
 unsigned int i;
 
+/* page align inputs */
+*addr &= PAGE_MASK;
+*len &= PAGE_MASK;
 *offset &= PAGE_MASK;
 
+if (*len == 0)
+*len = page_size;
+
+
 if (*flags & MAP_ANONYMOUS) {
 i = rand() % 100;
 if (i > 50)
 struct syscall syscall_mmap = {
 .arg5name = ""fd"",
 .arg5type = ARG_FD,
 .arg6name = ""off"",
+.arg6type = ARG_LEN,
 .group = GROUP_VM,
 };
",54,4
add a switch to disable logging.," FILE *logfile;
 
 void synclog()
 {
+if (logging == 0)
+return;
+
 (void)fflush(logfile);
 fsync(fileno(logfile));
 }
 void output(const char *fmt, ...)
 if (!quiet)
 printf(""%s"", outputbuf);
 
+if (logging == 0)
+return;
+
 if (logfile == NULL) {
 printf(""Logfile not open!\n"");
 exit(EXIT_FAILURE);
",41,8
"fix inverted logic

derp"," int main(int argc, char* argv[])
 }
 }
 
-if (logging == 0) {
+if (logging == 1) {
 if (logfilename == NULL)
 logfilename = strdup(""trinity-cpu0.log"");
 unlink(logfilename);
",460,89
"Do unconditional PTRACE_CONT before exiting child.

If we randomly did a PTRACE_TRACEME, the child will hang on exit,
and the parent doesn't know that it needs to do anything.","
 #include <unistd.h>
 #include <sys/types.h>
 #include <sys/wait.h>
+#include <sys/ptrace.h>
 
 #include ""arch.h""
 #include ""trinity.h""
 void do_syscall_from_child(int cl)
 break;
 }
 
+/* In case we randomly did a PTRACE_TRACEME */
+ptrace(PTRACE_CONT, getpid(), NULL, NULL);
+
 _exit(ret);
 }
 (void)waitpid(-1, NULL, 0);
",134,27
"Rewrite a lot of the parent/child model.

We had an extraneous fork() in there, and a whole bunch
of code which was confused about where it belonged."," void main_loop(void)
 {
 int ret;
 
-for (;;) {
+shm->execcount = 1;
 
-if (ctrlc_hit == 1)
-return;
+while (1) {
+sigsetjmp(ret_jump, 1);
 
-rep = rand();
-do_syscall_from_child(rep);
+do_syscall_from_child();
 
-rep++;
 if (syscallcount && (shm->execcount >= syscallcount))
 break;
 
 void main_loop(void)
 return;
 }
 }
-}
-}
-
-void do_main_loop(void)
-{
-shm->execcount = 1;
-
-while (1) {
-sigsetjmp(ret_jump, 1);
-printf(""forking new child.\n"");
-sleep(1);
-if (fork() == 0) {
-seed_from_tod();
-mask_signals();
-main_loop();
-if (ctrlc_hit == 1)
-_exit(EXIT_SUCCESS);
-if (syscallcount && (shm->execcount >= syscallcount))
-_exit(EXIT_SUCCESS);
-}
-(void)waitpid(-1, NULL, 0);
 
 if (ctrlc_hit == 1)
-return;
+_exit(EXIT_SUCCESS);
 if (syscallcount && (shm->execcount >= syscallcount))
-return;
+_exit(EXIT_SUCCESS);
 }
 }
",50,13
Move the regeneration code to the same place.," void do_syscall_from_child()
 setup_maps();
 
 shm->regenerate = REGENERATION_POINT - 1;
+
+regenerate_random_page();
 }
 shm->regenerate--;
 
+if (do_specific_syscall == 1)
+regenerate_random_page();
+
 if (fork() == 0) {
 
 seed_from_tod();
 void do_syscall_from_child()
 
 while (syscalls_per_child > 0) {
 
-if (!shm->regenerate)
-regenerate_random_page();
-if (do_specific_syscall == 1)
-regenerate_random_page();
-
 ret = do_syscall(rand() % max_nr_syscalls);
 
 syscalls_per_child--;
",135,26
Remove unnecessary 'pick random syscall' duplicate.," static int do_syscall(int callnr)
 unsigned int syscallnr = callnr;
 int retrycount = 0;
 
-syscallnr = rand() / (RAND_MAX/max_nr_syscalls);
-
 if (do_specific_syscall != 0)
 syscallnr = specific_syscall;
 else {
",134,26
"remove the bruteforce code.

Just use '-c syscall' instead."," args_done:
 static int do_syscall(int callnr)
 {
 unsigned int syscallnr = callnr;
-int retrycount = 0;
 
 if (do_specific_syscall != 0)
 syscallnr = specific_syscall;
 static int do_syscall(int callnr)
 goto skip_syscall;
 }
 
-retry_same:
 (void)alarm(3);
 
 res = mkcall(syscallnr);
 
-/* Brute force the same syscall until it succeeds */
-if ((intelligence == 1) && (bruteforce == 1)) {
-// Don't bother trying to bruteforce ni_syscall
-if (res == -ENOSYS)
-goto failed_repeat;
-
-if (retrycount == 100) {
-//printf(""100 retries done without success. moving on\n"");
-goto failed_repeat;
-}
-
-if (res < 0) {
-//printf (""syscall failed. Retrying\n"");
-retrycount++;
-shm->retries++;
-goto retry_same;
-}
-}
-
-failed_repeat:
-
 skip_syscall:
 return res;
 }
",119,21
-i is now the default.," static long mkcall(unsigned int call)
 else
 sptr += sprintf(sptr, ""%s"", syscalls[call].entry->name);
 
-if (intelligence == 1) {
-generic_sanitise(call, &a1, &a2, &a3, &a4, &a5, &a6);
-if (syscalls[call].entry->sanitise)
-syscalls[call].entry->sanitise(&a1, &a2, &a3, &a4, &a5, &a6);
-}
+generic_sanitise(call, &a1, &a2, &a3, &a4, &a5, &a6);
+if (syscalls[call].entry->sanitise)
+syscalls[call].entry->sanitise(&a1, &a2, &a3, &a4, &a5, &a6);
 
 #define COLOR_ARG(ARGNUM, NAME, BIT, OLDREG, REG)\
 if (syscalls[call].entry->num_args >= ARGNUM) {\
",112,19
Launch five children from each process.," skip_syscall:
 
 void do_syscall_from_child()
 {
-int ret = 0;
+unsigned int i;
 
 if (!shm->regenerate) {
 close_files();
 void do_syscall_from_child()
 if (do_specific_syscall == 1)
 regenerate_random_page();
 
-if (fork() == 0) {
-ret = child_process();
-_exit(ret);
+for (i = 0; i < 5; i++) {
+if (fork() == 0) {
+int ret = 0;
+
+ret = child_process();
+_exit(ret);
+}
 }
 (void)waitpid(-1, NULL, 0);
 }
",121,21
"lock the logfile before writing.

Multiple children writing to the same logfile without locking == mess.","
 #include <stdlib.h>
 #include <stdarg.h>
 #include <unistd.h>
+#include <fcntl.h>
 #include ""trinity.h""
 
 static char outputbuf[1024];
 void sync_output()
 
 void output(const char *fmt, ...)
 {
+struct flock fl = { F_WRLCK, SEEK_SET, 0, 0, 0 };
 va_list args;
 int n;
 
 void output(const char *fmt, ...)
 
 if (n < 0) {
 printf(""Something went wrong in output() [%d]\n"", n);
-return;
+exit(EXIT_FAILURE);
 }
+
 if (!quiet)
 printf(""%s"", outputbuf);
 
 if (logging == 0)
 return;
 
+fl.l_pid = getpid();
+if (fcntl(fileno(logfile), F_SETLKW, &fl) == -1) {
+perror(""fcntl F_SETLKW"");
+exit(EXIT_FAILURE);
+}
+
 if (logfile == NULL) {
-printf(""Logfile not open!\n"");
+perror(""Logfile not open!\n"");
 exit(EXIT_FAILURE);
 }
 fprintf(logfile, ""%s"", outputbuf);
+
+fl.l_type = F_UNLCK;
+if (fcntl(fileno(logfile), F_SETLK, &fl) == -1) {
+perror(""fcntl F_SETLK"");
+exit(EXIT_FAILURE);
+}
 }
",53,10
fork nr CPUs children," skip_syscall:
 void do_syscall_from_child()
 {
 unsigned int i;
+unsigned int nr_CPUs = sysconf(_SC_NPROCESSORS_ONLN);
 
 if (!shm->regenerate) {
 close_files();
 void do_syscall_from_child()
 if (do_specific_syscall == 1)
 regenerate_random_page();
 
-for (i = 0; i < 5; i++) {
+for (i = 0; i < nr_CPUs; i++) {
 if (fork() == 0) {
 int ret = 0;
 
",122,21
Send PTRACE_CONT from the parent," skip_syscall:
 break;
 }
 
-/* In case we randomly did a PTRACE_TRACEME */
-ptrace(PTRACE_CONT, getpid(), NULL, NULL);
-
 return ret;
 }
 
 
 void do_syscall_from_child()
 {
+unsigned int pids[64];
 unsigned int i;
-unsigned int nr_CPUs = sysconf(_SC_NPROCESSORS_ONLN);
+unsigned int nr_childs = min(64, sysconf(_SC_NPROCESSORS_ONLN));
 
 if (!shm->regenerate) {
 close_files();
 void do_syscall_from_child()
 if (do_specific_syscall == 1)
 regenerate_random_page();
 
-for (i = 0; i < nr_CPUs; i++) {
-if (fork() == 0) {
+for (i = 0; i < nr_childs; i++) {
+pids[i] =fork();
+if (pids[i] == 0) {
 int ret = 0;
 
 ret = child_process();
 void do_syscall_from_child()
 }
 }
 (void)waitpid(-1, NULL, 0);
+
+for (i = 0; i < nr_childs; i++) {
+/* In case we randomly did a PTRACE_TRACEME */
+ptrace(PTRACE_CONT, pids[i], NULL, NULL);
+}
 }
",126,22
lock the logfile across both halves of the syscall output.," static long mkcall(unsigned int call)
 args_done:
 sptr += sprintf(sptr, WHITE "") "");
 
+lock_logfile();
 output(""%s"", string);
 sptr = string;
+
+/* This sync is here halfway through just in case the syscall crashes. */
 sync_output();
 
 if (dopause == 1)
 args_done:
 output(""%s"", string);
 sptr = string;
 sync_output();
+unlock_logfile();
 
 if (quiet) {
 if (shm->execcount % 1000 == 0) {
",128,22
"change default logfile name.

Now that we launch multiple threads, cpu0 is meaningless."," int main(int argc, char* argv[])
 
 if (logging == 1) {
 if (logfilename == NULL)
-logfilename = strdup(""trinity-cpu0.log"");
+logfilename = strdup(""trinity.log"");
 unlink(logfilename);
 logfile = fopen(logfilename, ""a"");
 if (!logfile) {
",435,82
Log the pid when reseeding," void seed_from_tod()
 gettimeofday(&t, 0);
 seed = t.tv_sec * t.tv_usec;
 srand(seed);
-output(""Random seed: %u (0x%x)\n"", seed, seed);
+output(""[%d] Random seed: %u (0x%x)\n"", getpid(), seed, seed);
 }
 
 
",435,82
"only do explicit log locking.

locking doesn't nest, and output() unlocks."," void output(const char *fmt, ...)
 perror(""Logfile not open!\n"");
 exit(EXIT_FAILURE);
 }
-
-lock_logfile();
 fprintf(logfile, ""%s"", outputbuf);
-unlock_logfile();
 }
",64,14
further locking improvements," void generate_sockets(unsigned int nr_to_create)
 
 output(""taking writer lock for cachefile\n"");
 fl.l_pid = getpid();
+fl.l_type = F_WRLCK;
 if (fcntl(cachefile, F_SETLKW, &fl) == -1) {
-perror(""fcntl F_SETLKW"");
+perror(""fcntl F_WRLCK F_SETLKW"");
 exit(EXIT_FAILURE);
 }
 
 void open_sockets()
 fl.l_pid = getpid();
 fl.l_type = F_RDLCK;
 if (fcntl(cachefile, F_SETLKW, &fl) == -1) {
-perror(""fcntl reader F_SETLKW"");
+perror(""fcntl F_RDLCK F_SETLKW"");
 exit(1);
 }
 output(""took reader lock for cachefile\n"");
 regenerate:
 
 output(""(%d sockets created based on info from socket cachefile.)\n"", socks);
 
+fl.l_pid = getpid();
 fl.l_type = F_UNLCK;
 if (fcntl(cachefile, F_SETLK, &fl) == -1) {
-perror(""fcntl reader F_SETLK "");
+perror(""fcntl F_UNLCK F_SETLK "");
 exit(1);
 }
 
",166,25
"prevent heap corruption.

The whole generate mappings thing needs to be rewritten tbh"," void setup_maps()
 
 tmpmap = maps_list = alloc_map();
 do {
+retry:
 ret = fscanf(f, ""%p-%p"", &startaddr, &endaddr);
 if (ret == 0) {
 printf(""/proc/maps parsing failure\n"");
 void setup_maps()
 break;
 name[strlen(name) - 1] = '\0';
 tmpmap->name = strdup(name);
+
+if (!strcmp(tmpmap->name, ""[heap]"")) {
+output(""skipping heap (%p-%p)\n"", startaddr, endaddr);
+free(tmpmap->name);
+goto retry;
+}
 }
 
 tmpmap->ptr = startaddr;
",147,31
wait for ALL children to exit before exiting," skip_syscall:
 
 void do_syscall_from_child()
 {
-unsigned int pids[64];
+int pids[64];
 unsigned int i;
 unsigned int nr_childs = min(64, sysconf(_SC_NPROCESSORS_ONLN));
 
 void do_syscall_from_child()
 regenerate_random_page();
 
 for (i = 0; i < nr_childs; i++) {
-pids[i] =fork();
+pids[i] = fork();
 if (pids[i] == 0) {
 int ret = 0;
 
 void do_syscall_from_child()
 _exit(ret);
 }
 }
-(void)waitpid(-1, NULL, 0);
+for (i = 0; i < nr_childs; i++) {
+(void)waitpid(pids[i], NULL, 0);
+pids[i] = -1;
+}
 
 for (i = 0; i < nr_childs; i++) {
-/* In case we randomly did a PTRACE_TRACEME */
-ptrace(PTRACE_CONT, pids[i], NULL, NULL);
+if (pids[i] != -1) {
+/* In case we randomly did a PTRACE_TRACEME */
+ptrace(PTRACE_CONT, pids[i], NULL, NULL);
+(void)waitpid(pids[i], NULL, 0);
+pids[i] = -1;
+}
 }
 }
",135,24
"send the PTRACE_CONT, then waitpid."," void do_syscall_from_child()
 }
 }
 for (i = 0; i < nr_childs; i++) {
+/* In case we randomly did a PTRACE_TRACEME */
+ptrace(PTRACE_CONT, pids[i], NULL, NULL);
 (void)waitpid(pids[i], NULL, 0);
-pids[i] = -1;
-}
-
-for (i = 0; i < nr_childs; i++) {
-if (pids[i] != -1) {
-/* In case we randomly did a PTRACE_TRACEME */
-ptrace(PTRACE_CONT, pids[i], NULL, NULL);
-(void)waitpid(pids[i], NULL, 0);
-pids[i] = -1;
-}
 }
 }
",128,22
change number of syscalls to do in child to a ulong," unsigned int page_size;
 unsigned char dopause = 0;
 unsigned char do_specific_syscall = 0;
 unsigned char do_specific_proto = 0;
-unsigned char syscalls_per_child = 5;
+unsigned long syscalls_per_child = 5;
 unsigned char show_syscall_list = 0;
 unsigned char quiet = 0;
 static unsigned char dangerous = 0;
 static void parse_args(int argc, char *argv[])
 
 case 'F':
 syscalls_per_child = strtol(optarg, NULL, 10);
+printf(""doing %ld syscalls per child\n"", syscalls_per_child);
 break;
 
 case 'g':
",436,82
log pid in signal handler," static void parse_args(int argc, char *argv[])
 
 static void sighandler(int sig)
 {
-output(""signal: %s\n"", strsignal (sig));
+output(""[%d] signal: %s\n"", getpid(), strsignal(sig));
 (void)fflush(stdout);
 (void)signal(sig, sighandler);
 if (sig == SIGALRM)
-output(""Alarm clock.\n"");
+output(""[%d] Alarm clock.\n"", getpid());
 _exit(0);
 }
 
",436,82
"don't modify the syscalls_per_child parameter.

create a local, and modify that instead."," int child_process(void)
 {
 int ret = 0;
 unsigned int syscallnr;
+unsigned int left_to_do = syscalls_per_child;
 
 seed_from_tod();
 mask_signals();
 
-while (syscalls_per_child > 0) {
+while (left_to_do > 0) {
 
 syscallnr = rand() % max_nr_syscalls;
 
 int child_process(void)
 ret = mkcall(syscallnr);
 
 skip_syscall:
-syscalls_per_child--;
+left_to_do--;
 
 if (ctrlc_hit == 1)
 break;
",129,22
Turn off alarm after return from syscall.," int child_process(void)
 
 ret = mkcall(syscallnr);
 
+(void)alarm(0);
+
 skip_syscall:
 left_to_do--;
 
",130,22
"set the return for setjmp just before we do the syscall.

This is a better place to reenter."," void main_loop(void)
 shm->execcount = 1;
 
 while (1) {
-sigsetjmp(ret_jump, 1);
-
 do_syscall_from_child();
 
 if (syscallcount && (shm->execcount >= syscallcount))
",49,13
"factor out the regenerate code

also, decrement the count in the children."," skip_syscall:
 return ret;
 }
 
-
-void do_syscall_from_child()
+static void regenerate()
 {
-int pids[64];
-unsigned int i;
-unsigned int nr_childs = min(64, sysconf(_SC_NPROCESSORS_ONLN));
-
 if (!shm->regenerate) {
 close_files();
 open_files();
 void do_syscall_from_child()
 
 regenerate_random_page();
 }
-shm->regenerate--;
+}
+
+void do_syscall_from_child()
+{
+int pids[64];
+unsigned int i;
+unsigned int nr_childs = min(64, sysconf(_SC_NPROCESSORS_ONLN));
 
+regenerate();
 if (do_specific_syscall == 1)
 regenerate_random_page();
 
 void do_syscall_from_child()
 int ret = 0;
 
 ret = child_process();
+shm->regenerate--;
 _exit(ret);
 }
 }
",135,23
"Send a kill after the SIGCONT

It might be stuck for reasons other than ptrace."," void do_syscall_from_child()
 break;
 
 } else if (WIFSTOPPED(childstatus)) {
-debug(""Child was stopped. Sending CONT\n"");
+debug(""Child was stopped by %d."", WSTOPSIG(childstatus));
+debug(""Sending PTRACE_CONT (and then KILL)\n"");
 ptrace(PTRACE_CONT, childpid, NULL, NULL);
+kill(childpid, SIGKILL);
+for (i = 0; i < nr_childs; i++) {
+if (pids[i] == childpid) {
+debug(""Removing %d from pidmap\n"", pids[i]);
+pids[i] = -1;
+running_childs--;
+break;
+}
+}
 } else {
 output(""erk, wtf\n"");
 }
",223,46
log the regeneration.," skip_syscall:
 static void regenerate()
 {
 if (!shm->regenerate) {
+output(""Regenerating random pages, fd's etc.\n"");
 close_files();
 open_files();
 
",226,47
"Rewrite signal handling entirely.

* state machine variables about the child status/pidmap now in shm
* Don't ignore SIGCHLD
* Be explicit about which signals we choose to mask out (just SIGSEGV/SIGFPE for now)
* Don't mask signals in child, we want them propagated up to the parent
* parent now sleeps in waitpid() instead of spinning and sleep(1)'ing
* no longer trap ctrl-c, we didn't do anything special with it.

More improvement to come, but this is a clean place to stop for the week."," void open_fds(char *dir)
 }
 while ((de = readdir(d))) {
 
-if (ctrlc_hit == 1)
-exit(EXIT_SUCCESS);
-
 memset(&buf, 0, sizeof(struct stat));
 snprintf(b, sizeof(b), ""%s/%s"", dir, de->d_name);
 if (ignore_files(de->d_name))
",159,40
"by default, do 1000 syscalls per child.

5 per child isn't really pushing things hard enough, and we waste
too much time exiting/forking."," unsigned int page_size;
 unsigned char dopause = 0;
 unsigned char do_specific_syscall = 0;
 unsigned char do_specific_proto = 0;
-unsigned long syscalls_per_child = 5;
+unsigned long syscalls_per_child = DEFAULT_SYSCALLS_PER_CHILD;
 unsigned char show_syscall_list = 0;
 unsigned char quiet = 0;
 static unsigned char dangerous = 0;
",425,79
"ignore SIGBUS

Otherwise we see stuff like this in the logs..

trinity[29203] trap stack segment ip:36da87fc49 sp:7fffc355ac10 error:0

which isn't too interesting"," static void mask_signals(void)
 sa.sa_mask = ss;
 (void)sigaction(SIGSEGV, &sa, NULL);
 (void)sigaction(SIGFPE, &sa, NULL);
+(void)sigaction(SIGBUS, &sa, NULL);
 }
 
 static void find_specific_syscall()
",433,81
Release all child pids if all children have already exited.," void do_syscall_from_child()
 case -1:
 if (errno == ECHILD) {
 debugf(""All children exited!\n"");
+for (i = 0; i < shm->nr_childs; i++) {
+if (shm->pids[i] != -1) {
+debugf(""Removing %d from pidmap\n"", shm->pids[i]);
+shm->pids[i] = -1;
+shm->running_childs--;
+}
+}
 return;
 }
 output(""error! (%s)\n"", strerror(errno));
",209,42
"ignore SIGABRT.

glibc can send us this if we corrupt the malloc pool with an mmap."," void do_syscall_from_child()
 case SIGKILL:
 case SIGALRM:
 case SIGPIPE:
+case SIGABRT:
 debugf(""Child got a signal (%d)\n"", WTERMSIG(childstatus));
 reap_child(childpid);
 break;
",210,43
Remove the shm when the last attach point is detached," int main(int argc, char* argv[])
 int shmid, ret;
 unsigned int i;
 key_t key;
+struct shmid_ds shmid_ds;
 
 printf(""Trinity v"" __stringify(VERSION) "" Dave Jones <davej@redhat.com> 2012\n"");
 
 int main(int argc, char* argv[])
 perror(""shmat"");
 exit(EXIT_FAILURE);
 }
+shmctl(key, IPC_RMID, &shmid_ds);
 shm->successes = 0;
 shm->failures = 0;
 shm->regenerate = REGENERATION_POINT - 1;
",435,81
"Introduce a ->post method for syscalls

Used for tearing down any allocations that may have occurred.
First user: shm segments.

We were hitting the shm limit pretty quickly when there were quite
a few children running simultaneously."," args_done:
 
 shm->execcount++;
 
+if (syscalls[call].entry->post)
+ syscalls[call].entry->post(ret);
 return ret;
 }
 
",212,44
"setitimer interferes with alarm(), so don't call it"," int main(int argc, char* argv[])
 shm->failures = 0;
 shm->regenerate = REGENERATION_POINT - 1;
 memset(shm->pids, -1, sizeof(shm->pids));
-shm->nr_childs = min(64, sysconf(_SC_NPROCESSORS_ONLN));
+shm->nr_childs = 64;
 
 init_buffers();
 
",436,81
don't call alarm either," int child_process(void)
 unsigned int syscallnr;
 unsigned int left_to_do = syscalls_per_child;
 
+(void)alarm(0);
+
 seed_from_tod();
 
 while (left_to_do > 0) {
",213,44
revert some accidental debugging," int child_process(void)
 unsigned int syscallnr;
 unsigned int left_to_do = syscalls_per_child;
 
-(void)alarm(0);
-
 seed_from_tod();
 
 while (left_to_do > 0) {
 void do_syscall_from_child()
 output(""pid map full!\n"");
 exit(EXIT_FAILURE);
 }
+(void)alarm(0);
 pid = fork();
 if (pid != 0)
 shm->pids[i] = pid;
",213,44
just set the nr childs to the nr CPUs," int main(int argc, char* argv[])
 shm->failures = 0;
 shm->regenerate = REGENERATION_POINT - 1;
 memset(shm->pids, -1, sizeof(shm->pids));
-shm->nr_childs = min(64, sysconf(_SC_NPROCESSORS_ONLN));
+shm->nr_childs = sysconf(_SC_NPROCESSORS_ONLN);
 
 init_buffers();
 
",436,81
start annotating more return types," struct syscall syscall_fanotify_mark = {
 .arg5name = ""pathname"",
 .arg5type = ARG_ADDRESS,
 .sanitise = sanitise_fanotify_mark,
+.rettype = RET_ZERO_SUCCESS,
 };
-
-
",39,1
"now that main_loop does everything, we want to stay in it, not return"," void main_loop()
 shm->running_childs--;
 }
 }
-return;
+break;
 }
 output(""error! (%s)\n"", strerror(errno));
 break;
",151,36
"compile fix

check_tainted is also used on startup"," static void regenerate()
 
 unsigned char do_check_tainted;
 
-static int check_tainted(void)
+int check_tainted(void)
 {
 int fd;
 int ret;
",151,36
find_logfile_handle can be static," void close_logfiles()
 fclose(shm->logfiles[i]);
 }
 
-FILE * find_logfile_handle()
+static FILE * find_logfile_handle()
 {
 pid_t pid;
 unsigned int i;
",121,23
move all shm init into same function," int create_shm()
 return -1;
 }
 shmctl(key, IPC_RMID, &shmid_ds);
+
 shm->successes = 0;
 shm->failures = 0;
 shm->regenerate = REGENERATION_POINT - 1;
-memset(shm->pids, -1, sizeof(shm->pids));
 
+shm->nr_childs = sysconf(_SC_NPROCESSORS_ONLN);
+if (shm->nr_childs > MAX_NR_CHILDREN) {
+printf(""Increase MAX_NR_CHILDREN!\n"");
+exit(EXIT_FAILURE);
+}
+memset(shm->pids, -1, sizeof(shm->pids));
 return 0;
 }
 
 int main(int argc, char* argv[])
 if (create_shm())
 exit(EXIT_FAILURE);
 
-shm->nr_childs = sysconf(_SC_NPROCESSORS_ONLN);
-if (shm->nr_childs > MAX_NR_CHILDREN) {
-printf(""Increase MAX_NR_CHILDREN!\n"");
-exit(EXIT_FAILURE);
-}
 if (logging != 0)
 open_logfiles(shm->nr_childs);
 
",438,82
open_logfiles doesn't take a parameter," int main(int argc, char* argv[])
 exit(EXIT_FAILURE);
 
 if (logging != 0)
-open_logfiles(shm->nr_childs);
+open_logfiles();
 
 max_nr_syscalls = NR_SYSCALLS;
 for (i = 0; i < max_nr_syscalls; i++)
",438,82
"Clear the shm on initialisation

This fixes a stupid bug introduced in 63ce0518f0c1a611eac91b8254a0fc3b85a0b4b5
that afaict was always there, but we got lucky before."," int create_shm()
 }
 shmctl(key, IPC_RMID, &shmid_ds);
 
-shm->successes = 0;
-shm->failures = 0;
+memset(shm, 0, sizeof(struct shm_s));
 shm->regenerate = REGENERATION_POINT - 1;
 
 shm->nr_childs = sysconf(_SC_NPROCESSORS_ONLN);
",437,82
remove logfile locking now that there's no contention.," void sync_output()
 synclog();
 }
 
-void lock_logfile()
-{
-struct flock logfilelock;
-FILE *handle;
-
-if (logging == 0)
-return;
-
-logfilelock.l_type = F_WRLCK;
-logfilelock.l_whence = SEEK_SET;
-logfilelock.l_start = 0;
-logfilelock.l_len = 0;
-logfilelock.l_pid = getpid();
-
-handle = find_logfile_handle();
-
-if (fcntl(fileno(handle), F_SETLKW, &logfilelock) == -1) {
-printf(""[%d] "", getpid());
-perror(""fcntl lock F_SETLKW"");
-exit(EXIT_FAILURE);
-}
-}
-
-void unlock_logfile()
-{
-struct flock logfilelock;
-FILE *handle;
-
-if (logging == 0)
-return;
-
-logfilelock.l_type = F_UNLCK;
-logfilelock.l_whence = SEEK_SET;
-logfilelock.l_start = 0;
-logfilelock.l_len = 0;
-logfilelock.l_pid = getpid();
-
-handle = find_logfile_handle();
-
-if (fcntl(fileno(handle), F_SETLKW, &logfilelock) == -1) {
-printf(""[%d] "", getpid());
-perror(""fcntl unlock F_SETLKW\n"");
-exit(EXIT_FAILURE);
-}
-}
-
 void output(const char *fmt, ...)
 {
 va_list args;
",85,17
don't log the overall execcount. it's meaningless in the child.," static long mkcall(unsigned int call)
 
 sigsetjmp(ret_jump, 1);
 
-sptr += sprintf(sptr, ""[%d] %lu: "", getpid(), shm->execcount);
+sptr += sprintf(sptr, ""[%d] "", getpid());
 
 olda1 = a1 = rand64();
 olda2 = a2 = rand64();
",98,16
"relax the fsync'ing on the logs.

in some rare cases, we might get incomplete logs, but
this makes things so much faster."," openit:
 fds_left_to_create--;
 }
 }
-
-sync_output();
 closedir(d);
 }
 
",158,40
print an extra \n to demark the new child in the log," void seed_from_tod()
 gettimeofday(&t, 0);
 seed = t.tv_sec * t.tv_usec;
 srand(seed);
-output(""[%d] Random seed: %u (0x%x)\n"", getpid(), seed, seed);
+output(""\n\n[%d] Random seed: %u (0x%x)\n"", getpid(), seed, seed);
 }
 
 
 int main(int argc, char* argv[])
 if (!seed)
 seed_from_tod();
 else
-output(""Random seed: %u (0x%x)\n"", seed, seed);
+output(""[%d] Random seed: %u (0x%x)\n"", getpid(), seed, seed);
 
 
 init_buffers();
",437,82
"actually, init this to 1, so we don't print out iterations: 0

but move it to be with the rest of the shm init."," int create_shm()
 shmctl(key, IPC_RMID, &shmid_ds);
 
 memset(shm, 0, sizeof(struct shm_s));
+
+shm->execcount = 1;
 shm->regenerate = REGENERATION_POINT - 1;
 
 shm->nr_childs = sysconf(_SC_NPROCESSORS_ONLN);
",438,82
"relax the fsyncing even more.

Only sync the logs every hundred iterations"," void main_loop()
 
 if (syscallcount && (shm->execcount >= syscallcount))
 exit(EXIT_SUCCESS);
-synclogs();
+
+if (shm->execcount % 100 == 0)
+synclogs();
 }
 }
",161,39
bind child processes to a cpu,"
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
+#include <sched.h>
 #include <sys/types.h>
 #include <sys/wait.h>
 
 args_done:
 
 int child_process(void)
 {
+cpu_set_t set;
+pid_t pid = getpid();
 int ret = 0;
 unsigned int syscallnr;
+unsigned int cpu;
 unsigned int left_to_do = syscalls_per_child;
 
 seed_from_tod();
+for (cpu = 0; cpu < shm->nr_childs; cpu++) {
+if (shm->pids[cpu] == pid)
+break;
+}
+
+if (sched_getaffinity(pid, sizeof(set), &set) == 0) {
+CPU_ZERO(&set);
+CPU_SET(cpu, &set);
+sched_setaffinity(getpid(), sizeof(set), &set);
+output(""bound child %d to cpu %d\n"", pid, cpu);
+}
 
 while (left_to_do > 0) {
 
",110,19
relax syncing even more," void main_loop()
 if (syscallcount && (shm->execcount >= syscallcount))
 exit(EXIT_SUCCESS);
 
-if (shm->execcount % 100 == 0)
+if (shm->execcount % 1000 == 0)
 synclogs();
 }
 }
",161,39
put the parent pid in the logfile names.," void open_logfiles()
 char *logfilename;
 
 parentpid = getpid();
-logfilename = strdup(""trinity.log"");
+logfilename = malloc(25);
+sprintf(logfilename, ""trinity-%d.log"", parentpid);
 unlink(logfilename);
 parentlogfile = fopen(logfilename, ""a"");
 if (!parentlogfile) {
 void open_logfiles()
 }
 
 for (i = 0; i < shm->nr_childs; i++) {
-logfilename = malloc(20);
-sprintf(logfilename, ""trinity-child%d.log"", i);
+logfilename = malloc(25);
+sprintf(logfilename, ""trinity-%d-child%d.log"", parentpid, i);
 unlink(logfilename);
 shm->logfiles[i] = fopen(logfilename, ""a"");
 if (!shm->logfiles[i]) {
 void open_logfiles()
 exit(EXIT_FAILURE);
 }
 }
+free(logfilename);
 }
 
 void close_logfiles()
",85,17
"The SHM must be private.

We used to be able to share it between unrelated processes when
we weren't using it for things like the pidmap.

Now this causes state corruption, because there's no locking."," int create_shm()
 key_t key;
 struct shmid_ds shmid_ds;
 
-key = rand64();
+key = IPC_PRIVATE;
 if ((shmid = shmget(key, sizeof(struct shm_s), IPC_CREAT | 0666)) < 0) {
 perror(""shmget"");
 return -1;
",438,82
use a null instead of a nasty cast to -1," static FILE * find_logfile_handle()
 if (shm->pids[i] == pid)
 return shm->logfiles[i];
 }
-return (void *) -1;
+return NULL;
 }
 
 void synclogs()
",85,17
"disable pipe generation for now, while debugging"," void open_pipes(void)
 
 void setup_fds(void)
 {
-open_pipes();
+//open_pipes();
 open_sockets();
 open_files();
 }
",51,10
"clear & reset buffer after syscall.

(mostly for debugging purposes)"," static long mkcall(unsigned int call)
 unsigned long olda1, olda2, olda3, olda4, olda5, olda6;
 unsigned long a1, a2, a3, a4, a5, a6;
 int ret = 0;
-char string[512], *sptr=string;
+char string[512], *sptr;
 
 sigsetjmp(ret_jump, 1);
 
+sptr = string;
+memset(string, 0, sizeof(string));
+
 sptr += sprintf(sptr, ""[%d] "", getpid());
 
 olda1 = a1 = rand64();
 args_done:
 sptr += sprintf(sptr, WHITE "") "");
 
 output(""%s"", string);
-sptr = string;
 
 if (dopause == 1)
 sleep(1);
 args_done:
 
 ret = syscall(syscalls[call].entry->number, a1, a2, a3, a4, a5, a6);
 
+sptr = string;
+memset(string, 0, sizeof(string));
+
 if (ret < 0) {
 sptr +=sprintf(sptr, RED ""= %d (%s)"" WHITE, ret, strerror(errno));
 shm->failures++;
",113,19
on SIGALRM jump back to child," static void sighandler(int sig)
 printf(""[%d] signal: %s\n"", getpid(), strsignal(sig));
 (void)fflush(stdout);
 }
-(void)signal(sig, sighandler);
+
+if (sig == SIGALRM) {
+(void)signal(sig, sighandler);
+siglongjmp(ret_jump, 1);
+}
+
 _exit(0);
 }
 
",441,83
"Don't give out stdin/stdout/stderr to syscalls.

things get messy when we randomly do a huge write to stdout,
or read from stdin etc.."," static unsigned long fill_arg(int call, int argnum)
 
 switch (argtype) {
 case ARG_FD:
+retry_fd:
 fd = get_random_fd();
+if (fd < 3)
+goto retry_fd;
 //printf (YELLOW ""DBG: %x"" WHITE ""\n"", fd);
 return fd;
 case ARG_LEN:
",287,109
"don't do anything with pts files.

dilemma. This is annoying because it causes scribbles over ssh sessions,
but at the same time, we're now going to miss out on some potential tty bugs."," static int ignore_files(char *file)
 /* boring stuff in /dev */
 ""dmmidi0"", ""dmmidi1"",""dmmidi2"",""dmmidi3"",
 ""midi00"", ""midi01"",""midi02"",""midi03"",
-"".udev"",
+"".udev"", ""pts"",
 /* Ignore per-process stuff. */
 ""keycreate"", ""sockcreate"", ""fscreate"", ""exec"",
 ""current"", ""coredump_filter"", ""make-it-fail"",
",158,40
"don't use strsignal in the sighandler.

This occasionally segfaults in some locale code in glibc.
My guess is the environment has been corrupted, and glibc has no
idea what language we're wanting translations in.

Just use the array directly, and use english at all times."," static void parse_args(int argc, char *argv[])
 }
 
 
+extern const char * const sys_siglist[];
+
 static void sighandler(int sig)
 {
 if (debug == 1) {
-printf(""[%d] signal: %s\n"", getpid(), strsignal(sig));
+printf(""[%d] signal: %s\n"", getpid(), sys_siglist[sig]);
 (void)fflush(stdout);
 }
 
",442,83
"don't flush stdout from sighandler.

it segfaults a lot"," extern const char * const sys_siglist[];
 
 static void sighandler(int sig)
 {
-if (debug == 1) {
+if (debug == 1)
 printf(""[%d] signal: %s\n"", getpid(), sys_siglist[sig]);
-(void)fflush(stdout);
-}
 
 if (sig == SIGALRM) {
 (void)signal(sig, sighandler);
",440,83
"avoid using libraries as mappings.

This might be causing some of the stranger child segfaults if these
get corrupted somehow"," retry:
 free(tmpmap->name);
 goto retry;
 }
+
+if (strstr(tmpmap->name, ""lib"")) {
+output(""skipping library (%p-%p) %s\n"", startaddr, endaddr, tmpmap->name);
+free(tmpmap->name);
+goto retry;
+}
 }
 
+
 tmpmap->ptr = startaddr;
 num_mappings++;
 
",152,32
do as little work as possible in the signal handler.," static void handle_children()
 case SIGALRM:
 case SIGPIPE:
 case SIGABRT:
-debugf(""[%d] Child got a signal (%d)\n"", getpid(), WTERMSIG(childstatus));
+debugf(""[%d] got a signal (%s)\n"", getpid(), strsignal(WTERMSIG(childstatus)));
 reap_child(childpid);
 break;
 default:
",161,39
"resurrect an old idea of doing the actual syscall in yet another child.

Another debugging idea. Some syscalls might be corrupting our
internal state enough that we're segfaulting. If we segv in
these 'throwaway' children, things aren't as severe."," unsigned char show_syscall_list = 0;
 unsigned char quiet = 0;
 static unsigned char dangerous = 0;
 unsigned char logging = 1;
+unsigned char extrafork = 0;
 
 static unsigned char desired_group = GROUP_NONE;
 
 static void parse_args(int argc, char *argv[])
 { ""debug"", no_argument, NULL, 'D' },
 { NULL, 0, NULL, 0 } };
 
-while ((opt = getopt_long(argc, argv, ""c:dDF:g:hkl:LN:m:P:pqs:Sux:z"", longopts, NULL)) != -1) {
+while ((opt = getopt_long(argc, argv, ""c:dDfF:g:hkl:LN:m:P:pqs:Sux:z"", longopts, NULL)) != -1) {
 switch (opt) {
 default:
 if (opt == '?')
 static void parse_args(int argc, char *argv[])
 debug = 1;
 break;
 
+case 'f':
+extrafork = 1;
+break;
+
 case 'F':
 syscalls_per_child = strtol(optarg, NULL, 10);
 printf(""doing %ld syscalls per child\n"", syscalls_per_child);
",441,83
"Revert ""don't do anything with pts files.""

This reverts commit 83215d444ec76b2829abbb08330bfba6a739ad67.

The value of finding tty bugs is worth putting up with the hassle of
garbage on the screen."," static int ignore_files(char *file)
 /* boring stuff in /dev */
 ""dmmidi0"", ""dmmidi1"",""dmmidi2"",""dmmidi3"",
 ""midi00"", ""midi01"",""midi02"",""midi03"",
-"".udev"", ""pts"",
+"".udev"",
 /* Ignore per-process stuff. */
 ""keycreate"", ""sockcreate"", ""fscreate"", ""exec"",
 ""current"", ""coredump_filter"", ""make-it-fail"",
",158,40
enable a bunch more warnings (and fix them up)," retry:fd = fds[rand() % fd_idx];
 case 2:
 fd = pipe_fds[rand() % MAX_PIPE_FDS];
 break;
+default:
+break;
 }
 
 return fd;
",53,10
Log the addresses of the pages we setup," static void init_buffers()
 if (!page_zeros)
 exit(EXIT_FAILURE);
 memset(page_zeros, 0, page_size);
+output(""page_zeros @ %p\n"", page_zeros);
 
 page_0xff = malloc(page_size);
 if (!page_0xff)
 exit(EXIT_FAILURE);
 memset(page_0xff, 0xff, page_size);
+output(""page_0xff @ %p\n"", page_0xff);
 
 page_rand = malloc(page_size);
 if (!page_rand)
 exit(EXIT_FAILURE);
 memset(page_rand, 0x55, page_size);/* overwritten below */
+output(""page_rand @ %p\n"", page_rand);
 
 page_allocs = malloc(page_size);
 if (!page_allocs)
 exit(EXIT_FAILURE);
 memset(page_allocs, 0xff, page_size);
+output(""page_allocs @ %p\n"", page_allocs);
 
 for (i = 0; i < (page_size / sizeof(unsigned long *)); i++)
 page_allocs[i] = (unsigned long) malloc(page_size);
",432,79
Mask off the possible offsets to print the correct name.," static long mkcall(unsigned int call)
 else\
 sptr += sprintf(sptr, ""%ld"" WHITE, REG);\
 \
-if (REG == (unsigned long)page_zeros)\
+if (REG == (((unsigned long)page_zeros) & PAGE_MASK))\
 sptr += sprintf(sptr, ""[page_zeros]"");\
-if (REG == (unsigned long)page_rand)\
+if (REG == (((unsigned long)page_rand) & PAGE_MASK))\
 sptr += sprintf(sptr, ""[page_rand]"");\
-if (REG == (unsigned long)page_0xff)\
+if (REG == (((unsigned long)page_0xff) & PAGE_MASK))\
 sptr += sprintf(sptr, ""[page_0xff]"");\
-if (REG == (unsigned long)page_allocs)\
+if (REG == (((unsigned long)page_allocs) & PAGE_MASK))\
 sptr += sprintf(sptr, ""[page_allocs]"");\
 }
 
",157,27
page align the pages we pass.,"
 #include <unistd.h>
 #include <getopt.h>
 #include <setjmp.h>
+#include <malloc.h>
 #include <asm/unistd.h>
 #include <sys/time.h>
 #include <sys/stat.h>
 static void init_buffers()
 {
 unsigned int i;
 
-page_zeros = malloc(page_size);
+page_zeros = memalign(page_size, page_size);
 if (!page_zeros)
 exit(EXIT_FAILURE);
 memset(page_zeros, 0, page_size);
 output(""page_zeros @ %p\n"", page_zeros);
 
-page_0xff = malloc(page_size);
+page_0xff = memalign(page_size, page_size);
 if (!page_0xff)
 exit(EXIT_FAILURE);
 memset(page_0xff, 0xff, page_size);
 output(""page_0xff @ %p\n"", page_0xff);
 
-page_rand = malloc(page_size);
+page_rand = memalign(page_size, page_size);
 if (!page_rand)
 exit(EXIT_FAILURE);
 memset(page_rand, 0x55, page_size);/* overwritten below */
 output(""page_rand @ %p\n"", page_rand);
 
-page_allocs = malloc(page_size);
+page_allocs = memalign(page_size, page_size);
 if (!page_allocs)
 exit(EXIT_FAILURE);
 memset(page_allocs, 0xff, page_size);
",433,79
"Add a buffer page after our special pages, in case something scribbles past the end of the page."," static void init_buffers()
 {
 unsigned int i;
 
-page_zeros = memalign(page_size, page_size);
+page_zeros = memalign(page_size, page_size * 2);
 if (!page_zeros)
 exit(EXIT_FAILURE);
 memset(page_zeros, 0, page_size);
 output(""page_zeros @ %p\n"", page_zeros);
 
-page_0xff = memalign(page_size, page_size);
+page_0xff = memalign(page_size, page_size * 2);
 if (!page_0xff)
 exit(EXIT_FAILURE);
 memset(page_0xff, 0xff, page_size);
 output(""page_0xff @ %p\n"", page_0xff);
 
-page_rand = memalign(page_size, page_size);
+page_rand = memalign(page_size, page_size * 2);
 if (!page_rand)
 exit(EXIT_FAILURE);
 memset(page_rand, 0x55, page_size);/* overwritten below */
 output(""page_rand @ %p\n"", page_rand);
 
-page_allocs = memalign(page_size, page_size);
+page_allocs = memalign(page_size, page_size * 2);
 if (!page_allocs)
 exit(EXIT_FAILURE);
 memset(page_allocs, 0xff, page_size);
",433,79
Move fds into the shm,"
 
 #include ""trinity.h""
 
-#define MAX_PIPE_FDS 10
-unsigned int pipe_fds[MAX_PIPE_FDS*2];
-
-unsigned int fds[MAX_FDS/2];
 unsigned int fd_idx = 0;
 
 unsigned int fds_left_to_create = MAX_FDS;
 void open_pipes(void)
 perror(""pipe fail.\n"");
 exit(EXIT_FAILURE);
 }
-pipe_fds[i] = pipes[0];
-pipe_fds[i+1] = pipes[1];
+shm->pipe_fds[i] = pipes[0];
+shm->pipe_fds[i+1] = pipes[1];
 
-output(""fd[%d] = pipe\n"", pipe_fds[i]);
-output(""fd[%d] = pipe\n"", pipe_fds[i+1]);
+output(""fd[%d] = pipe\n"", shm->pipe_fds[i]);
+output(""fd[%d] = pipe\n"", shm->pipe_fds[i+1]);
 }
 }
 
 int get_random_fd(void)
 
 switch (i) {
 case 0:
-retry:fd = fds[rand() % fd_idx];
+retry:fd = shm->fds[rand() % fd_idx];
 /* retry if we hit stdin/stdout/logfile */
-if (fd < fds[0])
+if (fd < shm->fds[0])
 goto retry;
 break;
 
 retry:fd = fds[rand() % fd_idx];
 break;
 
 case 2:
-fd = pipe_fds[rand() % MAX_PIPE_FDS];
+fd = shm->pipe_fds[rand() % MAX_PIPE_FDS];
 break;
 default:
 break;
",51,10
move socket_fds into the shm," retry:fd = shm->fds[rand() % fd_idx];
 break;
 
 case 1:
-fd = socket_fds[rand() % socks];
+fd = shm->socket_fds[rand() % socks];
 break;
 
 case 2:
",51,10
use defines instead of numbers," static void sighandler(int sig)
 siglongjmp(ret_jump, 1);
 }
 
-_exit(0);
+_exit(EXIT_SUCCESS);
 }
 
 static void mask_signals(void)
 static void mask_signals(void)
 limit.rlim_max = 0;
 if (setrlimit(RLIMIT_CORE, &limit) != 0) {
 perror( ""setrlimit(RLIMIT_CORE)"" );
-exit( 1 );
+exit(EXIT_FAILURE);
 }
 }
 
",440,80
"Introduce fd lifetimes.

Instead of getting a different fd every time, return the same one a few times.
This might increase the chances of races appearing if two threads operate on
the same fd."," void setup_fds(void)
 open_files();
 }
 
-
-int get_random_fd(void)
+static int get_random_fd(void)
 {
 unsigned int i;
 unsigned int fd = 0;
 retry:fd = shm->fds[rand() % fd_idx];
 
 return fd;
 }
+
+int get_fd(void)
+{
+if (shm->fd_lifetime == 0) {
+shm->current_fd = get_random_fd();
+shm->fd_lifetime = MAX_NR_CHILDREN;
+} else
+shm->fd_lifetime--;
+
+return shm->current_fd;
+}
",60,12
introduce some randomness into the fd lifetime rules," int get_fd(void)
 {
 if (shm->fd_lifetime == 0) {
 shm->current_fd = get_random_fd();
-shm->fd_lifetime = MAX_NR_CHILDREN;
+shm->fd_lifetime = rand() % MAX_NR_CHILDREN;
 } else
 shm->fd_lifetime--;
 
",60,12
"disable the 32bit code by default for now

It still has some issues, which seem to cause all processes to just lock up.
They seem to wake up immediately when straced. Needs further debugging."," int child_process(void)
  * 10% possibility of a 32bit syscall
  */
 shm->do32bit = FALSE;
-if (rand() % 100 < 10)
-shm->do32bit = TRUE;
+//if (rand() % 100 < 10)
+//shm->do32bit = TRUE;
 
 if (shm->do32bit == TRUE) {
 syscalls = syscalls_64bit;
",188,34
split up trinity.h a little,"
 #include <unistd.h>
 
 #include ""trinity.h""
+#include ""shm.h""
 
 unsigned int fd_idx = 0;
 
",61,12
split out the syscall tables to its own header,"
 #include ""arch.h""
 #include ""trinity.h""
 #include ""sanitise.h""
-
+#include ""syscall.h""
 
 char * filebuffer = NULL;
 unsigned long filebuffersize = 0;
",332,115
"rename variable

'b' is an awful name."," static int ignore_files(char *file)
 return 0;
 }
 
-static int add_fd(unsigned int chance, char *b, int flags)
+static int add_fd(unsigned int chance, char *pathname, int flags)
 {
 int fd = -1;
 
 if ((unsigned int)(rand() % 5000) < chance) {
-fd = open(b, flags | O_NONBLOCK);
+fd = open(pathname, flags | O_NONBLOCK);
 if (fd < 0)
 return -1;
-//printf(""Added: %s\n"", b);
+//printf(""Added: %s\n"", pathname);
 }
 return fd;
 }
",161,40
"Set /proc/self/make-it-fail in the child process

Idea from Sasha to invoke the kernels fault-injection features when making syscalls.","
 * Functions for actually doing the system calls.
 */
 
+#include <fcntl.h>
 #include <errno.h>
 #include <stdlib.h>
 #include <string.h>

 #include ""shm.h""
 #include ""syscall.h""
 
+static void set_make_it_fail()
+{
+int fd;
+const char *buf = ""1"";
+
+fd = open(""/proc/self/make-it-fail"", O_WRONLY);
+if (fd != -1)
+return;
+
+if (write(fd, buf, 1) == -1) {
+printf(""writing to /proc/self/make-it-fail failed!\n"");
+}
+
+close(fd);
+}
+
+
 #define __syscall_return(type, res) \
 do { \
 if ((unsigned long)(res) >= (unsigned long)(-125)) { \
 static unsigned long do_syscall(unsigned int num_args, int nr, unsigned long a1,
 /* Do the actual syscall in another child. */
 childpid = fork();
 if (childpid == 0) {
+set_make_it_fail();
 (void)alarm(3);
 ret = syscall(nr, a1, a2, a3, a4, a5, a6);
 (void)alarm(0);
 int child_process(void)
 output(""bound child %d to cpu %d\n"", pid, cpu);
 }
 
+if (extrafork == FALSE)
+set_make_it_fail();
+
 while (left_to_do > 0) {
 
 if (biarch == TRUE) {
",206,38
Do some FP math sometimes in the children," void set_make_it_fail()
 close(fd);
 }
 
+/*
+ * We call this occasionally to set some FPU state, in the hopes that we
+ * might tickle some weird FPU/scheduler related bugs
+ */
+static void use_fpu(void)
+{
+double x = 0;
+asm volatile("""":""+m"" (x));
+x += 1;
+asm volatile("""":""+m"" (x));
+}
+
 
 int child_process(void)
 {
 int child_process(void)
 output(""bound child %d to cpu %d\n"", pid, cpu);
 }
 
-if (extrafork == FALSE)
+if (extrafork == FALSE) {
 set_make_it_fail();
+if (rand() % 100 < 50)
+use_fpu();
+}
 
 while (left_to_do > 0) {
 
",80,17
"Improve the rand64 function

Steal an idea from iknowthis to distribute the randomness a little."," static void init_buffers()
 
 unsigned long rand64()
 {
-unsigned long r;
+unsigned long r = 0;
+
+switch (rand() % 3) {
+case 0:
+r = (unsigned long)rand() & rand();
+#if __WORDSIZE == 64
+r <<= 32;
+r |= (unsigned long)rand() & rand();
+#endif
+break;
+
+case 1:
+r = (unsigned long)rand() | rand();
+#if __WORDSIZE == 64
+r <<= 32;
+r |= (unsigned long)rand() | rand();
+#endif
+break;
 
-r = (unsigned long)rand();
-r *= (unsigned long)rand();
+case 2:
+r = (unsigned long)rand();
+#if __WORDSIZE == 64
+r <<= 32;
+r |= (unsigned long)rand();
+#endif
+break;
+
+default:
+break;
+}
 return r;
 }
 
",483,91
"remove 'return 32bit' special case

This is handled in the switch statement below."," unsigned long get_interesting_value()
 
 low = get_interesting_32bit_value();
 
-i = rand() % 10;
-if (i > 3)
-/* return small values 70% of the time */
-return low;
-
-
 i = rand() % 14;
 
 switch (i) {
",329,114
simplify regenerate function," void syscall_list()
 
 static void regenerate()
 {
-if (!shm->regenerate) {
-output(""[%d] Regenerating random pages, fd's etc.\n"", getpid());
-close_files();
-open_files();
+output(""[%d] Regenerating random pages, fd's etc.\n"", getpid());
+close_files();
+open_files();
 
-destroy_maps();
-setup_maps();
+destroy_maps();
+setup_maps();
 
-shm->regenerate = REGENERATION_POINT - 1;
+shm->regenerate = REGENERATION_POINT - 1;
 
-regenerate_random_page();
-}
+regenerate_random_page();
 }
 
 unsigned char do_check_tainted;
 static void handle_children()
 
 void main_loop()
 {
-regenerate();
+if (!shm->regenerate)
+regenerate();
+
 if (do_specific_syscall == 1)
 regenerate_random_page();
 
",162,39
"introduce function to perform per-child initialisation

should reduce some duplication in the 'extra fork' case.","
 #include ""syscall.h""
 #include ""shm.h""
 
-void set_make_it_fail()
+static void set_make_it_fail()
 {
 int fd;
 const char *buf = ""1"";
 static void use_fpu(void)
 asm volatile("""":""+m"" (x));
 }
 
+void init_child(void)
+{
+set_make_it_fail();
+if (rand() % 100 < 50)
+use_fpu();
+}
 
 int child_process(void)
 {
 int child_process(void)
 sched_setaffinity(getpid(), sizeof(set), &set);
 output(""bound child %d to cpu %d\n"", pid, cpu);
 }
-
-if (extrafork == FALSE) {
-set_make_it_fail();
-if (rand() % 100 < 50)
-use_fpu();
-}
+if (extrafork == FALSE)
+init_child();
 
 while (left_to_do > 0) {
 
",82,18
return < page size as a length sometimes.," unsigned long get_len()
 
 i = get_interesting_value();
 
-switch(rand() % 4) {
+switch(rand() % 5) {
 
 case 0:return (i & 0xff);
-case 1:return (i & 0xffff);
-case 2:return (i & 0xffffff);
-case 3:return (i & 0xffffffff);
+case 1: return (i & page_size);
+case 2:return (i & 0xffff);
+case 3:return (i & 0xffffff);
+case 4:return (i & 0xffffffff);
 default:/* unreachable */
 break;
 }
",330,115
-c and biarch are a problem right now.," int child_process(void)
 //if (rand() % 100 < 10)
 //shm->do32bit = TRUE;
 
+
+
+// FIXME: if we passed -c, we call the wrong syscall in 32bit mode.
+// For now, force it to be 64bit always in that case.
+if (do_specific_syscall == 1)
+shm->do32bit = FALSE;
+
+
 if (shm->do32bit == TRUE) {
 syscalls = syscalls_64bit;
 max_nr_syscalls = max_nr_64bit_syscalls;
",84,19
"silence make-it-fail failures.

Also, after the first EPERM failure, don't bother retrying.","
 
 static void set_make_it_fail()
 {
+static char failed = 0;
 int fd;
 const char *buf = ""1"";
 
+/* If we failed last time, don't bother trying in future. */
+if (failed == 1)
+return;
+
 fd = open(""/proc/self/make-it-fail"", O_WRONLY);
 if (fd == -1)
 return;
 
-if (write(fd, buf, 1) == -1)
-printf(""writing to /proc/self/make-it-fail failed! (%s)\n"", strerror(errno));
-
+if (write(fd, buf, 1) == -1) {
+if (errno != EPERM)
+printf(""writing to /proc/self/make-it-fail failed! (%s)\n"", strerror(errno));
+else
+failed = 1;
+}
 close(fd);
 }
 
",91,21
"Flesh out ARG_PATHNAME

Gather some random paths during the fd scan, and hand them out when asked.","
 
 #include ""trinity.h""
 #include ""shm.h""
+#include ""constants.h""
 
 static int ignore_files(char *file)
 {
 static int ignore_files(char *file)
 return 0;
 }
 
+char *pathnames[NR_PATHNAMES];
+unsigned int pathname_idx = 0;
+
 static int add_fd(unsigned int chance, char *pathname, int flags)
 {
 int fd = -1;
 
+if ((unsigned int)(rand() % 5000) < chance)
+if (pathname_idx < NR_PATHNAMES)
+pathnames[pathname_idx++] = strdup(pathname);
+
 if ((unsigned int)(rand() % 5000) < chance) {
 fd = open(pathname, flags | O_NONBLOCK);
 if (fd < 0)
",167,42
regenerate the filename list too," static int add_fd(unsigned int chance, char *pathname, int flags)
 {
 int fd = -1;
 
-if ((unsigned int)(rand() % 5000) < chance)
-if (pathname_idx < NR_PATHNAMES)
+if ((unsigned int)(rand() % 5000) < chance) {
+if (pathname_idx != NR_PATHNAMES) {
+
+if (pathnames[pathname_idx] != NULL)
+free(pathnames[pathname_idx]);
+
 pathnames[pathname_idx++] = strdup(pathname);
+}
+}
 
 if ((unsigned int)(rand() % 5000) < chance) {
 fd = open(pathname, flags | O_NONBLOCK);
 void close_files()
 }
 fd_idx = 0;
 }
+
+void regenerate_fds(void)
+{
+close_files();
+pathname_idx = 0;
+open_files();
+}
",177,44
avoid handing out the logfile fd's," void setup_fds(void)
 static int get_random_fd(void)
 {
 unsigned int i;
-unsigned int fd = 0;
+int fd = 0;
 
 if (do_specific_proto == 1)
 i = 1;
 static int get_random_fd(void)
 switch (i) {
 case 0:
 retry:fd = shm->fds[rand() % fd_idx];
-/* retry if we hit stdin/stdout/logfile */
-if (fd < shm->fds[0])
+/* retry if we hit stdin/stdout/logfiles */
+if (fd <= fileno(shm->logfiles[shm->nr_childs]))
 goto retry;
 break;
 
",61,12
"Don't ever return 0 as an fd.

This happens sometimes, probably because of the currently disabled pipe fd code."," retry:fd = shm->fds[rand() % fd_idx];
 
 int get_fd(void)
 {
+regen:
 if (shm->fd_lifetime == 0) {
 shm->current_fd = get_random_fd();
 shm->fd_lifetime = rand() % MAX_NR_CHILDREN;
 } else
 shm->fd_lifetime--;
 
+if (shm->current_fd == 0) {
+printf(""shm->lifetime = %d\n"", shm->fd_lifetime);
+shm->fd_lifetime = 0;
+goto regen;
+}
+
 return shm->current_fd;
 }
",67,13
Add more ARG_PATHNAME annotations," struct syscall syscall_fanotify_mark = {
 .arg4name = ""dfd"",
 .arg4type = ARG_FD,
 .arg5name = ""pathname"",
-.arg5type = ARG_ADDRESS,
+.arg5type = ARG_PATHNAME,
 .sanitise = sanitise_fanotify_mark,
 .rettype = RET_ZERO_SUCCESS,
 };
",39,1
rewrite to not use goto," openit:
 
 void open_files()
 {
-more:
-open_fds(""/sys/kernel/debug"");
-open_fds(""/dev"");
-open_fds(""/proc"");
-open_fds(""/sys"");
-if (fds_left_to_create > 0)
-goto more;
+while (fds_left_to_create > 0) {
+open_fds(""/sys/kernel/debug"");
+open_fds(""/dev"");
+open_fds(""/proc"");
+open_fds(""/sys"");
+}
 }
 
 void close_files()
",176,44
"print out pids in decimal.

Also change the hex/dec cutoff to 8k"," long mkcall(unsigned int call)
 case ARG_PATHNAME:\
 sptr += sprintf(sptr, ""\""%s\"""", (char *) REG);\
 break;\
+case ARG_PID:\
 case ARG_FD:\
+sptr += sprintf(sptr, ""%ld"" WHITE, REG);\
+break;\
 case ARG_LEN:\
 case ARG_ADDRESS:\
-case ARG_PID:\
 case ARG_RANGE:\
 case ARG_LIST:\
-case ARG_RANDPAGE:\
+case ARG_RANDPAGE:\
 case ARG_CPU:\
 default:\
-if (REG > 1024)\
+if (REG > 8 * 1024)\
 sptr += sprintf(sptr, ""0x%lx"" WHITE, REG);\
 else\
 sptr += sprintf(sptr, ""%ld"" WHITE, REG);\
",144,23
"avoid giving out pids for the trinity processes.

This should stop children sending weird signals.","
 #include ""trinity.h""
 #include ""sanitise.h""
 #include ""syscall.h""
+#include ""shm.h""
 
 char * filebuffer = NULL;
 unsigned long filebuffersize = 0;
 void regenerate_random_page()
 
 static unsigned int get_pid()
 {
-int i;
-i = rand() % 3;
+int i, pid = 0;
+retry:
+i = rand() % 2;
 
 switch (i) {
-case 0:return getpid();
-case 1:return rand() & 32767;
-case 2: break;
+case 0:pid = getpid();
+break;
+case 1:pid = rand() & 32767;
+break;
 default:/* unreachable */
 break;
 }
-return 0;
+for (i = 0; i < MAX_NR_CHILDREN; i++) {
+if (pid == shm->pids[i])
+goto retry;
+}
+if (pid == parentpid)
+goto retry;
+
+return pid;
 }
 
 static unsigned int get_cpu()
",336,117
build fix -- dupe variable,"
 
 static char outputbuf[1024];
 FILE *parentlogfile;
-static int parentpid;
 
 void open_logfiles()
 {
 unsigned int i;
 char *logfilename;
 
-parentpid = getpid();
 logfilename = malloc(25);
 sprintf(logfilename, ""trinity-%d.log"", parentpid);
 unlink(logfilename);
",84,17
constify the parts of the syscall struct that don't change," static unsigned long fill_arg(int call, int argnum)
 unsigned long mask=0;
 unsigned long low=0, high=0;
 unsigned int num=0;
-unsigned int *values=NULL;
+const unsigned int *values = NULL;
 enum argtype argtype = 0;
 
 switch (argnum) {
",336,117
"Duh, the alarm handler wasn't being set."," static void mask_signals(void)
 sa.sa_flags = SA_RESTART;
 sa.sa_handler = sighandler;
 sa.sa_mask = ss;
+(void)sigaction(SIGALRM, &sa, NULL);
 (void)sigaction(SIGSEGV, &sa, NULL);
 (void)sigaction(SIGFPE, &sa, NULL);
 (void)sigaction(SIGBUS, &sa, NULL);
",506,96
things seem to work better right now if we just exit when we get SIGALRM," static void parse_args(int argc, char *argv[])
 return;
 }
 
-static void sighandler(int sig)
+static void sighandler(__unused__ int sig)
 {
-if (sig == SIGALRM) {
-(void)signal(sig, sighandler);
-siglongjmp(ret_jump, 1);
-}
+//if (sig == SIGALRM) {
+//(void)signal(sig, sighandler);
+//siglongjmp(ret_jump, 1);
+//}
 
 _exit(EXIT_SUCCESS);
 }
",502,95
introduce find_pid_slot helper.," void close_logfiles()
 static FILE * find_logfile_handle()
 {
 pid_t pid;
-unsigned int i;
+int i;
 
 pid = getpid();
 if (pid == parentpid)
 return parentlogfile;
 
-for (i = 0; i < shm->nr_childs; i++) {
-if (shm->pids[i] == pid)
-return shm->logfiles[i];
-}
+i = find_pid_slot(pid);
+if (i != -1)
+return shm->logfiles[i];
 return NULL;
 }
 
",83,16
"maintain some statistics on how many syscalls a child did, and print them on exit"," static void use_fpu(void)
 
 void init_child(void)
 {
+int i;
+
+i = find_pid_slot(getpid());
+shm->total_syscalls[i] = 0;
+
 set_make_it_fail();
 if (rand() % 100 < 50)
 use_fpu();
",94,21
"add explicit continue in dirwalk.

just for clarity, shouldn't change anything, as the rest of the loop is empty anyway."," void open_fds(const char *dir, unsigned char add_all)
 continue;
 if (S_ISFIFO(buf.st_mode))
 continue;
-//if (S_ISREG(buf.st_mode))
-//continue;
+
 if (S_ISDIR(buf.st_mode)) {
 /* probability of adding a directory to the list. */
 chance = 5;
 void open_fds(const char *dir, unsigned char add_all)
 open_fds(b, add_all);
 goto openit;
 }
+continue;
 } else {
 /* We own this dir. */
 open_fds(b, add_all);
 goto openit;
 }
+// unreachable.
+
 } else {
 int mode_was_set = 0;
 
",181,46
ARG_RANGE without specifying the range causes segfaults.," struct syscall syscall_mbind = {
 
 .arg5name = ""maxnode"",
 .arg5type = ARG_RANGE,
+.low5range = 0,
+.hi5range = 32,
 
 .arg6name = ""flags"",
 .arg6type = ARG_LIST,
",43,3
might as well sync when we sleep for a second," args_done:
 
 output(""%s"", string);
 
-if (dopause == 1)
+if (dopause == 1) {
+synclogs();
 sleep(1);
+}
 
 /* IA64 is retarde^Wspecial. */
 #ifdef __ia64__
",150,24
remove some unnecessary code," args_done:
 sptr = string;
 
 if (quiet) {
-if (shm->execcount % 1000 == 0) {
-sptr = string;
-sptr += sprintf(sptr, ""%ld"", shm->execcount);
-printf(""%s iterations.\n"", string);
-}
+if (shm->execcount % 1000 == 0)
+printf(""%ld iterations.\n"", shm->execcount);
 }
 
 /* If the syscall doesn't exist don't bother calling it next time. */
",147,24
we only want coredumping disabled in the children.," static void mask_signals(void)
 {
 struct sigaction sa;
 sigset_t ss;
-struct rlimit limit;
 
 (void)sigfillset(&ss);
 sa.sa_flags = SA_RESTART;
 static void mask_signals(void)
 (void)sigaction(SIGBUS, &sa, NULL);
 (void)sigaction(SIGILL, &sa, NULL);
 (void)sigaction(SIGXCPU, &sa, NULL);
-
-/* Disable dumping core */
-limit.rlim_cur = 0;
-limit.rlim_max = 0;
-if (setrlimit(RLIMIT_CORE, &limit) != 0) {
-perror( ""setrlimit(RLIMIT_CORE)"" );
-exit(EXIT_FAILURE);
-}
 }
 
 static int search_syscall_table(struct syscalltable *table, unsigned int nr_syscalls)
",519,99
improve coredump limit restoration.," static void disable_coredumps()
 
 static void reenable_coredumps()
 {
-if (setrlimit(RLIMIT_CORE, &oldrlimit) != 0) {
-printf(""Error restoring rlimits to cur:%d max:%d\n"",
-(unsigned int) oldrlimit.rlim_cur,
-(unsigned int) oldrlimit.rlim_max);
+struct rlimit limit;
+
+getrlimit(RLIMIT_CORE, &limit);
+limit.rlim_cur = oldrlimit.rlim_cur;
+
+if (setrlimit(RLIMIT_CORE, &limit) != 0) {
+printf(""Error restoring rlimits to cur:%d max:%d (%s)\n"",
+(unsigned int) limit.rlim_cur,
+(unsigned int) limit.rlim_max,
+strerror(errno));
 exit(EXIT_FAILURE);
 }
 }
",123,25
Add --nocolors option," unsigned char do_specific_proto = 0;
 unsigned long syscalls_per_child = DEFAULT_SYSCALLS_PER_CHILD;
 unsigned char show_syscall_list = 0;
 unsigned char quiet = 0;
+unsigned char no_colors = 0;
 static unsigned char dangerous = 0;
 unsigned char logging = 1;
 unsigned char extrafork = 0;
 static void parse_args(int argc, char *argv[])
 { ""dangerous"", no_argument, NULL, 'd' },
 { ""group"", required_argument, NULL, 'g' },
 { ""debug"", no_argument, NULL, 'D' },
+{ ""nocolors"", no_argument, NULL, 'C' },
 { NULL, 0, NULL, 0 } };
 
-while ((opt = getopt_long(argc, argv, ""c:dDfF:g:hl:LN:m:P:pqs:SV:"", longopts, NULL)) != -1) {
+while ((opt = getopt_long(argc, argv, ""c:CdDfF:g:hl:LN:m:P:pqs:SV:"", longopts, NULL)) != -1) {
 switch (opt) {
 default:
 if (opt == '?')
 static void parse_args(int argc, char *argv[])
 specific_syscall_optarg = optarg;
 break;
 
+case 'C':
+no_colors = TRUE;
+break;
+
 case 'd':
 dangerous = 1;
 break;
",524,101
"buildfix for F14

(Because Linus hates gnome3)","
 #include <stdlib.h>
 #include <linux/perf_event.h>
 
+/* For the F14 die-hards. */
+#ifndef PERF_COUNT_HW_STALLED_CYCLES_FRONTEND
+#define PERF_COUNT_HW_STALLED_CYCLES_FRONTEND 7
+#endif
+#ifndef PERF_COUNT_HW_STALLED_CYCLES_BACKEND
+#define PERF_COUNT_HW_STALLED_CYCLES_BACKEND 8
+#endif
+#ifndef PERF_COUNT_HW_REF_CPU_CYCLES
+#define PERF_COUNT_HW_REF_CPU_CYCLES 9
+#endif
+
 static void sanitise_perf_event_open(
 unsigned long *a1,
 __unused__ unsigned long *a2,
",99,28
output the log files in monochrome.,"
 #include ""shm.h""
 
 static char outputbuf[1024];
+static char monobuf[1024];
 FILE *parentlogfile;
 
 void open_logfiles()
 void output(const char *fmt, ...)
 va_list args;
 int n;
 FILE *handle;
+unsigned int len, i, j;
 
 va_start(args, fmt);
 n = vsnprintf(outputbuf, sizeof(outputbuf), fmt, args);
 void output(const char *fmt, ...)
 if (logging == 0)
 return;
 
+len = strlen(outputbuf);
+for (i = 0, j = 0; i < len; i++) {
+if (outputbuf[i] == '')
+i += 6;
+else {
+monobuf[j] = outputbuf[i];
+j++;
+}
+}
+monobuf[j] = '\0';
+
 handle = find_logfile_handle();
-fprintf(handle, ""%s"", outputbuf);
+fprintf(handle, ""%s"", monobuf);
 }
",95,18
fix two off-by-one's in switch statements," void sanitise_socket(
 else
 *protocol = IPPROTO_UDP;
 break;
-case 3:*type = SOCK_RAW;
+case 2:*type = SOCK_RAW;
 break;
 default:break;
 }
 void sanitise_socket(
 else
 *protocol = IPPROTO_UDP;
 break;
-case 3:*type = SOCK_RAW;
+case 2:*type = SOCK_RAW;
 break;
 default:break;
 }
",101,25
"Make the 'specific syscall' code handle 32/64 bit tables.

Before it assumed 64bit."," int child_process(void)
 //if (rand() % 100 < 10)
 //shm->do32bit = TRUE;
 
-
-
-// FIXME: if we passed -c, we call the wrong syscall in 32bit mode.
-// For now, force it to be 64bit always in that case.
-if (do_specific_syscall == 1)
-shm->do32bit = FALSE;
-
-
 if (shm->do32bit == FALSE) {
 syscalls = syscalls_64bit;
 max_nr_syscalls = max_nr_64bit_syscalls;
 int child_process(void)
 syscallnr = rand() % max_nr_syscalls;
 
 if (do_specific_syscall != 0)
-syscallnr = specific_syscall;
+if (shm->do32bit == TRUE)
+syscallnr = specific_syscall32;
+else
+syscallnr = specific_syscall64;
 else {
 
 if (syscalls[syscallnr].entry->num_args == 0)
",124,25
"Document --victims in helptext

Remove long-gone options."," static void usage(void)
 fprintf(stderr, "" --monochrome,-m: don't output ANSI codes\n"");
 fprintf(stderr, "" --proto,-P: specify specific network protocol for sockets.\n"");
 fprintf(stderr, "" --quiet,-q: less output.\n"");
+fprintf(stderr, "" --victims,-V: path to victim files.\n"");
 fprintf(stderr, ""\n"");
-fprintf(stderr, "" -c#: target syscall # only.\n"");
+fprintf(stderr, "" -c#: target specific syscall (takes syscall name as parameter).\n"");
 fprintf(stderr, "" -k: pass kernel addresses as arguments.\n"");
 fprintf(stderr, "" -N#: do # syscalls then exit.\n"");
 fprintf(stderr, "" -p: pause after syscall.\n"");
 fprintf(stderr, "" -s#: use # as random seed.\n"");
-fprintf(stderr, "" -u: pass userspace addresses as arguments.\n"");
-fprintf(stderr, "" -x#: use value as register arguments.\n"");
-fprintf(stderr, "" -z: use all zeros as register parameters.\n"");
 exit(EXIT_SUCCESS);
 }
 
",528,101
"remove --childcalls

This was only really useful for debugging when rewriting the parent/child code."," int child_process(void)
 int ret = 0;
 unsigned int syscallnr;
 unsigned int cpu;
-unsigned int left_to_do = syscalls_per_child;
+unsigned int left_to_do = DEFAULT_SYSCALLS_PER_CHILD;
 
 seed_from_tod();
 
",124,25
Fix the monochrome option.," static void parse_args(int argc, char *argv[])
 { ""victims"", required_argument, NULL, 'V' },
 { NULL, 0, NULL, 0 } };
 
-while ((opt = getopt_long(argc, argv, ""c:CdDfg:hl:LN:mP:pqs:SV:x:"", longopts, NULL)) != -1) {
+while ((opt = getopt_long(argc, argv, ""c:dDfg:hl:LN:mP:pqs:SV:x:"", longopts, NULL)) != -1) {
 switch (opt) {
 default:
 if (opt == '?')
 static void parse_args(int argc, char *argv[])
 specific_syscall_optarg = optarg;
 break;
 
-case 'C':
-monochrome = TRUE;
-break;
-
 case 'd':
 dangerous = 1;
 break;
 static void parse_args(int argc, char *argv[])
 show_syscall_list = 1;
 break;
 
+case 'm':
+monochrome = TRUE;
+break;
+
 /* Set number of syscalls to do */
 case 'N':
 syscallcount = strtoll(optarg, NULL, 10) + 1;
",521,100
"small optimisation for logging

If we passed -m, we don't need to do the ANSI code stripping."," void output(const char *fmt, ...)
 if (logging == 0)
 return;
 
+handle = find_logfile_handle();
+
+if (monochrome == TRUE) {
+fprintf(handle, ""%s"", outputbuf);
+return;
+}
+
 len = strlen(outputbuf);
 for (i = 0, j = 0; i < len; i++) {
 if (outputbuf[i] == '')
 void output(const char *fmt, ...)
 }
 monobuf[j] = '\0';
 
-handle = find_logfile_handle();
 fprintf(handle, ""%s"", monobuf);
 }
",99,19
Fix off by one that caused a segv," static int get_random_fd(void)
 case 0:
 retry:fd = shm->fds[rand() % fd_idx];
 /* retry if we hit stdin/stdout/logfiles */
-if (fd <= fileno(shm->logfiles[shm->nr_childs]))
+if (fd <= fileno(shm->logfiles[shm->nr_childs-1]))
 goto retry;
 break;
 
",66,13
"Check for failure of fileno

This would have saved us before if we were checking it.","
+#include <errno.h>
 #include <stdio.h>
 #include <stdlib.h>
+#include <string.h>
 #include <unistd.h>
 
 #include ""trinity.h""
 static int get_random_fd(void)
 {
 unsigned int i;
 int fd = 0;
+int ret;
 
 if (do_specific_proto == 1)
 i = 1;
 static int get_random_fd(void)
 case 0:
 retry:fd = shm->fds[rand() % fd_idx];
 /* retry if we hit stdin/stdout/logfiles */
-if (fd <= fileno(shm->logfiles[shm->nr_childs-1]))
+ret = fileno(shm->logfiles[shm->nr_childs-1]);
+if (ret == -1) {
+printf(""%s:%s: fileno failed! %s\n"", __FILE__, __func__, strerror(errno));
+exit(EXIT_FAILURE);
+}
+if (fd <= ret)
 goto retry;
 break;
 
",74,14
"when regenerating, close the fd before zeroing it.

Should prevent racing with children"," void open_files()
 void close_files()
 {
 unsigned int i;
+int fd;
 
 for (i = 0; i < fd_idx; i++) {
-close(shm->fds[i]);
+fd = shm->fds[i];
 shm->fds[i] = 0;
+close(fd);
 fds_left_to_create++;
 }
 fd_idx = 0;
",195,52
"Add a buffer to the other side of the randomly alloc'd page.

When we return an address near the end of the page, we might end up
writing into unmapped memory, causing a segfault."," void * get_address()
 break;
 case 7: addr = get_map();
 break;
-case 8: addr = malloc(page_size);
+case 8: addr = malloc(page_size * 2);
 break;
 default: /* unreachable*/
 break;
",339,118
check for failed mallocs," static void sanitise_move_pages(unsigned long *pid,
 }
 
 page_alloc = malloc(page_size);
+if (page_alloc == NULL)
+return;
 
 *nr_pages = rand() % (page_size / sizeof(void *));
 
 for (i = 0; i < *nr_pages; i++) {
 page_alloc[i] = (unsigned long) malloc(page_size);
+if (!page_alloc[i])
+return;// FIXME: MEMORY LEAK
 page_alloc[i] &= PAGE_MASK;
 }
 
",51,6
Enable segfaults when we are in debug mode.,"
 
 #include <fcntl.h>
 #include <errno.h>
+#include <signal.h>
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
 static void disable_coredumps()
 {
 struct rlimit limit;
 
+if (debug == TRUE) {
+(void)signal(SIGSEGV, SIG_DFL);
+return;
+}
+
 getrlimit(RLIMIT_CORE, &oldrlimit);
 
 limit.rlim_cur = 0;
 static void reenable_coredumps()
 {
 struct rlimit limit;
 
+if (debug == TRUE)
+return;
+
 getrlimit(RLIMIT_CORE, &limit);
 limit.rlim_cur = oldrlimit.rlim_cur;
 
",131,27
Some error checking for log.c,"
+#include <errno.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <stdarg.h>
 static FILE * find_logfile_handle()
 void synclogs()
 {
 unsigned int i;
+int fd, ret;
 
 if (logging == 0)
 return;
 
 for (i = 0; i < shm->nr_childs; i++) {
-(void)fflush(shm->logfiles[i]);
-(void)fsync(fileno(shm->logfiles[i]));
+ret = fflush(shm->logfiles[i]);
+if (ret == EOF) {
+printf(""logfile flushing failed! %s\n"", strerror(errno));
+continue;
+}
+
+fd = fileno(shm->logfiles[i]);
+if (fd != -1) {
+ret = fsync(fd);
+if (ret != 0)
+printf(""fsyncing logfile %d failed. %s\n"", i, strerror(errno));
+}
 }
 
 (void)fflush(parentlogfile);
 void output(const char *fmt, ...)
 return;
 
 handle = find_logfile_handle();
+if (!handle) {
+printf(""child logfile handle was null logging to main!\n"");
+handle = parentlogfile;
+return;
+}
 
 if (monochrome == TRUE) {
 fprintf(handle, ""%s"", outputbuf);
",115,23
"Move log buffers onto stack

multiple threads could write to the buffers when they were global.","
 #include ""trinity.h""
 #include ""shm.h""
 
-static char outputbuf[1024];
-static char monobuf[1024];
 FILE *parentlogfile;
 
 void open_logfiles()
 void output(const char *fmt, ...)
 int n;
 FILE *handle;
 unsigned int len, i, j;
+char outputbuf[1024];
+char monobuf[1024];
 
 va_start(args, fmt);
 n = vsnprintf(outputbuf, sizeof(outputbuf), fmt, args);
",115,23
Make the parent segfault in debug mode too," static void mask_signals(void)
 }
 (void)signal(SIGCHLD, SIG_DFL);
 (void)signal(SIGFPE, SIG_IGN);
+if (debug == TRUE)
+(void)signal(SIGSEGV, SIG_DFL);
 }
 
 static int find_specific_syscall(char *arg)
",523,101
Print the syscall we had problems parsing," static int find_specific_syscall(char *arg)
 /* 32bit only, also fall through from above 64bit failure.*/
 i = search_syscall_table(syscalls_32bit, max_nr_32bit_syscalls, arg);
 if (i == -1) {
-printf(""No idea what syscall was asked for.\n"");
+printf(""No idea what syscall (%s) is.\n"", arg);
 exit(EXIT_FAILURE);
 }
 specific_syscall32 = i;
",523,101
Don't print the headers out when we run -L," int main(int argc, char* argv[])
 syscalls = newsyscalls;
 }
 
+if (show_syscall_list == 1) {
+syscall_list();
+exit(EXIT_SUCCESS);
+}
 
 if (!do_specific_syscall) {
 if (biarch == TRUE)
 int main(int argc, char* argv[])
 if (do_specific_proto == 1)
 find_specific_proto();
 
-if (show_syscall_list == 1) {
-syscall_list();
-exit(EXIT_SUCCESS);
-}
-
 page_size = getpagesize();
 
 if (!seed)
",523,101
"Add a watchdog routine to ensure children are making progress.

Only enabled in debug mode."," static unsigned long do_syscall(unsigned int num_args, int nr, unsigned long a1,
 (void)alarm(0);
 
 i = find_pid_slot(getpid());
-if (i != -1)
+if (i != -1) {
 shm->total_syscalls[i]++;
+(void)gettimeofday(&shm->tv[i], NULL);
+}
 
 return ret;
 }
",155,24
Check logfile was opened before trying to close it," void close_logfiles()
 unsigned int i;
 
 for (i = 0; i < shm->nr_childs; i++)
-fclose(shm->logfiles[i]);
+if (shm->logfiles[i] != NULL)
+fclose(shm->logfiles[i]);
 }
 
 static FILE * find_logfile_handle()
",116,24
"More specific cleanups.

In the random case, instead of skipping, retry, rather than potentially
incur the overhead of more forking."," int child_process(void)
 }
 }
 
-syscallnr = rand() % max_nr_syscalls;
-
-if (do_specific_syscall != 0)
+if (do_specific_syscall == TRUE)
 if (shm->do32bit == TRUE)
 syscallnr = specific_syscall32;
 else
 syscallnr = specific_syscall64;
 else {
+retry:
+/* We're doing something random. */
+syscallnr = rand() % max_nr_syscalls;
 
 if (syscalls[syscallnr].entry->num_args == 0)
-goto skip_syscall;
+goto retry;
 
 if (syscalls[syscallnr].entry->flags & AVOID_SYSCALL)
-goto skip_syscall;
+goto retry;
 
 if (syscalls[syscallnr].entry->flags & NI_SYSCALL)
-goto skip_syscall;
+goto retry;
 }
 
 ret = mkcall(syscallnr);
 
-skip_syscall:
 left_to_do--;
 }
 reenable_coredumps();
",131,27
"If we passed a 32bit only syscall as -c, we should only do 32bit calls."," int child_process(void)
 }
 }
 
-if (do_specific_syscall == TRUE)
+if (do_specific_syscall == TRUE) {
+/* If we asked for a 32bit only syscall, force 32bit mode. */
+if (specific_syscall64 == -1) {
+shm->do32bit = TRUE;
+syscalls = syscalls_32bit;
+max_nr_syscalls = max_nr_32bit_syscalls;
+}
+
 if (shm->do32bit == TRUE)
 syscallnr = specific_syscall32;
 else
 syscallnr = specific_syscall64;
-else {
+} else {
 retry:
 /* We're doing something random. */
 syscallnr = rand() % max_nr_syscalls;
",136,28
Make the 64-bit only message the same as 32-bit only one.," static int find_specific_syscall(char *arg)
 printf(""Couldn't find %s in 64-bit table, but found in 32bit at %ld.\n"", arg, specific_syscall32);
 
 if (specific_syscall32 == -1)
-printf(""Couldn't find %s in 32-bit table.\n"", arg);
+printf(""Couldn't find %s in 32-bit table, but found in 64bit at %ld.\n"", arg, specific_syscall64);
 
 return TRUE;
 }
",565,117
"Don't exit after 1000 syscalls.

Just keep going. We'll eventually find a reason to exit some other way (ie, segfault)"," int child_process(void)
 int ret = 0;
 unsigned int syscallnr;
 unsigned int cpu;
-unsigned int left_to_do = DEFAULT_SYSCALLS_PER_CHILD;
 
 seed_from_tod();
 
 int child_process(void)
 if (extrafork == FALSE)
 init_child();
 
-while (left_to_do > 0) {
+while (1) {
 
 if (biarch == TRUE) {
 /*
 retry:
 }
 
 ret = mkcall(syscallnr);
-
-left_to_do--;
 }
+
+// never reached.
+
 reenable_coredumps();
 
 return ret;
",134,28
"Move the regenerate decrement

We were only regenerating every 25000 forks, rather than every 25k syscalls."," static void fork_children()
 int ret = 0;
 
 ret = child_process();
-shm->regenerate--;
+/* We should never get here. */
 output(""child %d exitting\n"", getpid());
 
 _exit(ret);
",221,55
"Last commit broke -N, fix it."," retry:
 }
 
 ret = mkcall(syscallnr);
+
+if (syscallcount) {
+if (shm->execcount >= syscallcount)
+goto out;
+}
 }
 
-// never reached.
+out:
 
 reenable_coredumps();
 
",139,30
This comment isn't necessarily true if passed -N," static void fork_children()
 int ret = 0;
 
 ret = child_process();
-/* We should never get here. */
+
 output(""child %d exitting\n"", getpid());
 
 _exit(ret);
",221,55
Missing logfile debugging.," static FILE * find_logfile_handle()
 {
 pid_t pid;
 int i;
+unsigned int j;
 
 pid = getpid();
 if (pid == parentpid)
 static FILE * find_logfile_handle()
 i = find_pid_slot(pid);
 if (i != -1)
 return shm->logfiles[i];
+else {
+printf(""Couldn't find logfile for pid %d\n"", pid);
+printf(""pids: "");
+for (j = 0; j < shm->nr_childs; j++)
+printf(""%d "", shm->pids[j]);
+printf(""\n"");
+printf(""Logfiles for pids: "");
+for (j = 0; j < shm->nr_childs; j++)
+printf(""%p "", shm->logfiles[j]);
+printf(""\n"");
+}
 return NULL;
 }
 
",128,26
"Make the watchdog be a separate process.

Move the progress output there.
This gives more accuracy, rather than each child potentially racing."," int child_process(void)
 if (extrafork == FALSE)
 init_child();
 
-while (1) {
+while (exit_now == FALSE) {
 
 if (biarch == TRUE) {
 /*
",139,30
"output() calls from watchdog thread got to the parent log file.

Also some extra debugging for when we can't find the pidslot"," static FILE * find_logfile_handle()
 if (pid == parentpid)
 return parentlogfile;
 
+if (pid == watchdog_pid)
+return parentlogfile;
+
 i = find_pid_slot(pid);
 if (i != -1)
 return shm->logfiles[i];
",130,27
comment out some excessive watchdog debugging," void watchdog(void)
 shm->tv[i].tv_sec = now;
 continue;
 }
-if (diff > 3)
-printf(""pid slot %d [%d]: old:%ld now:%ld diff= %d\n"", i, pid, old, now, diff);
+//if (diff > 3)
+//printf(""pid slot %d [%d]: old:%ld now:%ld diff= %d\n"", i, pid, old, now, diff);
 
 if (diff > 30) {
 output(""pid %d hasn't made progress in 30 seconds! (last:%ld now:%ld diff:%d) Killing.\n"",
",70,17
Make some debug messages easier to grep for.," static void handle_children()
 if (WIFEXITED(childstatus)) {
 slot = find_pid_slot(childpid);
 if (slot == -1) {
-printf(""Couldn't find pid slot for %d\n"", childpid);
+printf(""## Couldn't find pid slot for %d\n"", childpid);
 exit_now = TRUE;
 } else
 debugf(""[%d] Child %d exited after %d syscalls.\n"", getpid(), childpid, shm->total_syscalls[slot]);
",180,41
Want the watchdog to dump core if we segv.," void watchdog(void)
 static unsigned long lastcount;
 
 prctl(PR_SET_NAME, (unsigned long) &watchdogname);
+(void)signal(SIGSEGV, SIG_DFL);
 
 while (exit_now == FALSE) {
 
",71,17
Child needs to wait for parent to set the pidslot entry.," static void fork_children()
 else {
 int ret = 0;
 
+/* Wait for parent to set our pidslot */
+while (shm->pids[pidslot] != getpid());
+
 ret = child_process();
 
 output(""child %d exitting\n"", getpid());
",184,41
Move exit_now into the shm," int child_process(void)
 if (extrafork == FALSE)
 init_child();
 
-while (exit_now == FALSE) {
+while (shm->exit_now == FALSE) {
 
 if (biarch == TRUE) {
 /*
",139,30
distinguish between the watchdog exiting and children," static void handle_children()
 debugf(""[%d] Something happened to pid %d\n"", getpid(), childpid);
 if (WIFEXITED(childstatus)) {
 
+if (childpid == watchdog_pid) {
+if (shm->exit_now == FALSE)
+printf(""## OMG the watchdog exited!\n"");
+shm->exit_now = TRUE;
+break;
+}
+
 slot = find_pid_slot(childpid);
 if (slot == -1) {
 printf(""[%d] ## Couldn't find pid slot for %d\n"", getpid(), childpid);
",190,43
Remove \n to make test script work better," void syscall_list()
 for (i=0; i < max_nr_32bit_syscalls; i++)
  printf(""%u: %s\n"", i, syscalls_32bit[i].entry->name);
 
-printf(""\n64bit:\n"");
+printf(""64bit:\n"");
 for (i=0; i < max_nr_64bit_syscalls; i++)
  printf(""%u: %s\n"", i, syscalls_64bit[i].entry->name);
 } else {
",190,43
"When -l off is passed, don't need to avoid shm->logfiles."," void setup_fds(void)
 static int get_random_fd(void)
 {
 unsigned int i;
+FILE *file;
 int fd = 0;
 int ret;
 
 static int get_random_fd(void)
 switch (i) {
 case 0:
 retry:fd = shm->fds[rand() % fd_idx];
-/* retry if we hit stdin/stdout/logfiles */
-ret = fileno(shm->logfiles[shm->nr_childs-1]);
-if (ret == -1) {
-printf(""%s:%s: fileno failed! %s\n"", __FILE__, __func__, strerror(errno));
-exit(EXIT_FAILURE);
+
+/* avoid stdin/stdout/stderr */
+if (logging == FALSE)
+ret = fileno(stderr);
+
+/* get highest logfile fd if logging is enabled */
+else {
+file = shm->logfiles[shm->nr_childs-1];
+if (file == NULL) {
+printf(""## WTF, logfile was null!\n"");
+printf(""## logfiles: "");
+for (i = 0; i < shm->nr_childs; i++)
+printf(""%p "", shm->logfiles[i]);
+printf(""\n"");
+exit(EXIT_FAILURE);
+}
+ret = fileno(file);
+if (ret == -1) {
+printf(""%s:%s: fileno failed! %s\n"", __FILE__, __func__, strerror(errno));
+exit(EXIT_FAILURE);
+}
 }
+
+
 if (fd <= ret)
 goto retry;
 break;
",88,17
Move watchdog_pid into the shm," static FILE * find_logfile_handle()
 if (pid == parentpid)
 return parentlogfile;
 
-if (pid == watchdog_pid)
+if (pid == shm->watchdog_pid)
 return parentlogfile;
 
 i = find_pid_slot(pid);
",130,27
"Clear up the watchdog exiting.

Make sure the watchdog is the first process to die.
Also wait until it's started before we start forking children."," out:
 
 reenable_coredumps();
 
+/* Let the watchdog process die before the children. */
+while (shm->watchdog_pid != 0);
+
 return ret;
 }
",140,31
Log why the watchdog sets exit_now," void watchdog(void)
 }
 }
 
-if (syscallcount && (shm->execcount >= syscallcount))
+if (syscallcount && (shm->execcount >= syscallcount)) {
+output(""Reached limit %d. Telling children to start exiting\n"", syscallcount);
 shm->exit_now = TRUE;
+}
 
 if (shm->execcount % 1000 == 0)
 synclogs();
",79,18
only set shm->exit_now if it wasn't set already when the watchdog has quit (unexpectedly)," static void handle_children()
 if (WIFEXITED(childstatus)) {
 
 if (childpid == shm->watchdog_pid) {
-if (shm->exit_now == FALSE)
+if (shm->exit_now == FALSE) {
 printf(""## OMG the watchdog exited unexpectedly!\n"");
-shm->exit_now = TRUE;
+shm->exit_now = TRUE;
+}
 shm->watchdog_pid = 0;
 break;
 }
",196,45
"Sleep in children when waiting for the watchdog to exit.

Also set exit_now when we reach the max syscall count."," retry:
 goto retry;
 }
 
-ret = mkcall(syscallnr);
-
 if (syscallcount) {
-if (shm->execcount >= syscallcount)
-goto out;
+if (shm->execcount >= syscallcount) {
+shm->exit_now = TRUE;
+printf(""[%d] Reached maximum syscall count %ld\n"", getpid(), shm->execcount);
+}
 }
-}
 
-out:
+ret = mkcall(syscallnr);
+}
 
 reenable_coredumps();
 
 /* Let the watchdog process die before the children. */
-while (shm->watchdog_pid != 0);
+while (shm->watchdog_pid != 0) {
+printf(""Waiting for watchdog at %d to die\n"", shm->watchdog_pid);
+sleep(1);
+}
 
 return ret;
 }
",144,31
"-L shouldn't open log files.

Also cleanup the shm afterwards."," void setup_syscall_tables(void)
 
 int main(int argc, char* argv[])
 {
-int ret;
+int ret = EXIT_SUCCESS;
 unsigned int i;
 
 printf(""Trinity v"" __stringify(VERSION) "" Dave Jones <davej@redhat.com> 2012\n"");
 int main(int argc, char* argv[])
 if (create_shm())
 exit(EXIT_FAILURE);
 
+if (show_syscall_list == TRUE) {
+syscall_list();
+goto cleanup_shm;
+}
+
 if (logging != 0)
 open_logfiles();
 
 int main(int argc, char* argv[])
 syscalls = newsyscalls;
 }
 
-if (show_syscall_list == 1) {
-syscall_list();
-exit(EXIT_SUCCESS);
-}
-
 if (!do_specific_syscall) {
 if (biarch == TRUE)
 output(""Fuzzing %d 32-bit syscalls & %d 64-bit syscalls.\n"",
 cleanup:
 if (logging != 0)
 close_logfiles();
 
+cleanup_shm:
+
 shmdt(shm);
 
 exit(ret);
",570,118
"Use waitpid to wait for watchdog to die, not sleep."," retry:
 
 reenable_coredumps();
 
-/* Let the watchdog process die before the children. */
-while (shm->watchdog_pid != 0) {
-printf(""Waiting for watchdog at %d to die\n"", shm->watchdog_pid);
-sleep(1);
-}
+wait_for_watchdog_to_exit();
 
 return ret;
 }
",137,30
Set child thread names," int find_pid_slot(pid_t mypid)
 static void fork_children()
 {
 int pidslot;
+static char childname[17];
 
 /* Generate children*/
 
 static void fork_children()
 printf(""[%d] ## Pid map was full!\n"", getpid());
 exit(EXIT_FAILURE);
 }
+
 (void)alarm(0);
 pid = fork();
 if (pid != 0)
 shm->pids[pidslot] = pid;
 else {
 int ret = 0;
+memset(childname, 0, sizeof(childname));
+sprintf(childname, ""trinity-child%d"", pidslot);
+prctl(PR_SET_NAME, (unsigned long) &childname);
 
 /* Wait for parent to set our pidslot */
 while (shm->pids[pidslot] != getpid());
",200,45
Don't give out the watchdog pid as ARG_PID," retry:
 if (pid == parentpid)
 goto retry;
 
+if (pid == shm->watchdog_pid)
+goto retry;
+
 return pid;
 }
 
",341,119
Fix pipe buffer setup," unsigned int fds_left_to_create = MAX_FDS;
 
 void open_pipes(void)
 {
-int pipes[2];
+int pipes[MAX_PIPE_FDS * 2];
 unsigned int i;
 
-for (i = 0; i < MAX_PIPE_FDS; i++) {
+for (i = 0; i < MAX_PIPE_FDS; i+=2) {
 if (pipe(pipes) < 0) {
 perror(""pipe fail.\n"");
 exit(EXIT_FAILURE);
",88,17
"Fix segfault on --exclude some_syscall_with_large_index

$ ./trinity -x get_robust_list
Trinity v1.0 Dave Jones <davej@redhat.com> 2012
[15094] Marking 64-bit syscall 274 (get_robust_list) as AVOID
[15094] Marking 32-bit syscall 312 (get_robust_list) as AVOID
[1] 15094 segmentation fault ./trinity -x get_robust_list

Signed-off-by: Fengguang Wu <fengguang.wu@intel.com>"," static void parse_args(int argc, char *argv[])
 printf(""Couldn't find %s in 32-bit syscall table.\n"", optarg);
 else {
 printf(""[%d] Marking 32-bit syscall %d (%s) as AVOID\n"", getpid(), i, optarg);
-syscalls_64bit[i].entry->flags |= AVOID_SYSCALL;
+syscalls_32bit[i].entry->flags |= AVOID_SYSCALL;
 }
 }
 }
",567,117
"the pipe code seems to work now, enable it."," void open_pipes(void)
 
 void setup_fds(void)
 {
-//open_pipes();
+open_pipes();
 open_sockets();
 open_files();
 }
",89,17
Set some 'count' args to ARG_LEN," struct syscall syscall_pread64 = {
 .arg2name = ""buf"",
 .arg2type = ARG_ADDRESS,
 .arg3name = ""count"",
+.arg3type = ARG_LEN,
 .arg4name = ""pos"",
 };
",28,2
Remove double test. Add comments.," static int add_fd(unsigned int chance, char *pathname, int flags, unsigned char
 DIR *d = NULL;
 
 if ((unsigned int)(rand() % FD_LIKELYHOOD) < chance) {
+/* Add it to the list of filenames */
 if (pathname_idx != NR_PATHNAMES) {
 
 if (pathnames[pathname_idx] != NULL)
 static int add_fd(unsigned int chance, char *pathname, int flags, unsigned char
 
 pathnames[pathname_idx++] = strdup(pathname);
 }
-}
 
-if ((unsigned int)(rand() % FD_LIKELYHOOD) < chance) {
+/* Add it to the list of fd's */
 if (is_dir == TRUE) {
 d = opendir(pathname);
 if (d != NULL)
",193,51
Add '.' '..' and '/' to the file list.," unsigned int pathname_idx = 0;
 
 #define FD_LIKELYHOOD 5000
 
-static int add_fd(unsigned int chance, char *pathname, int flags, unsigned char is_dir)
+static int add_fd(unsigned int chance, const char *pathname, int flags, unsigned char is_dir)
 {
 int fd = -1;
 DIR *d = NULL;
 openit:
 
 void open_files()
 {
+int fd;
+
+const char dir1[]=""/"";
+const char dir2[]=""."";
+const char dir3[]="".."";
+
 while (fds_left_to_create > 0) {
+
+fd = add_fd(-1, dir1, O_RDONLY, TRUE);
+if (fd < 0) {
+perror(""fd1"");
+exit(EXIT_FAILURE);
+}
+
+fd = add_fd(-1, dir2, O_RDWR, TRUE);
+if (fd < 0) {
+perror(""fd2"");
+exit(EXIT_FAILURE);
+}
+
+fd = add_fd(-1, dir3, O_RDWR, TRUE);
+if (fd < 0) {
+perror(""fd3"");
+exit(EXIT_FAILURE);
+}
+
 if (victim_path != NULL)
 open_fds(victim_path, TRUE);
 
",212,54
"Don't bother clearing out the output buffer

We're over-writing it all anyway, so just null-terminate it
before passing it to output()"," long mkcall(unsigned int call)
 sigsetjmp(ret_jump, 1);
 
 sptr = string;
-memset(string, 0, sizeof(string));
 
 sptr += sprintf(sptr, ""[%d] "", getpid());
 if (shm->do32bit == TRUE)
 long mkcall(unsigned int call)
 args_done:
 WHITE
 sptr += sprintf(sptr, "") "");
+*sptr = '\0';
 
 output(""%s"", string);
 
 args_done:
 ret = do_syscall(syscalls[call].entry->num_args, syscalls[call].entry->number, a1, a2, a3, a4, a5, a6);
 
 sptr = string;
-memset(string, 0, sizeof(string));
 
 if (ret < 0) {
 RED
 args_done:
 sptr += sprintf(sptr, "" [T:%ld F:%ld S:%ld]"", shm->execcount, shm->failures, shm->successes);
 sptr += sprintf(sptr, ""\n"");
 
+*sptr = '\0';
+
 output(""%s"", string);
 sptr = string;
 
",152,22
"rework how -c and -x work

* Now supports multiple -c's

Instead of passing an explicit syscall # around, we just mark the syscall table
entries as enabled/disabled as necessary.

TODO: Compact the syscall table, so that we can lower the rand(nr_syscalls).
Should reduce the number of retries in child_process() when passing -c"," void main_loop()
 if (!shm->regenerate)
 regenerate();
 
-if (do_specific_syscall == 1)
-regenerate_random_page();
-
 pid = fork();
 if (pid == 0)
 watchdog();// Never returns.
",198,44
"This can fail (usually -EPERM)

Just ignore failures."," openit:
 
 void open_files()
 {
-int fd;
-
 const char dir1[]=""/"";
 const char dir2[]=""."";
 const char dir3[]="".."";
 
 while (fds_left_to_create > 0) {
 
-fd = add_fd(-1, dir1, O_RDONLY, TRUE);
-if (fd < 0) {
-perror(""fd1"");
-exit(EXIT_FAILURE);
-}
-
-fd = add_fd(-1, dir2, O_RDWR, TRUE);
-if (fd < 0) {
-perror(""fd2"");
-exit(EXIT_FAILURE);
-}
-
-fd = add_fd(-1, dir3, O_RDWR, TRUE);
-if (fd < 0) {
-perror(""fd3"");
-exit(EXIT_FAILURE);
-}
+(void)add_fd(-1, dir1, O_RDONLY, TRUE);
+(void)add_fd(-1, dir2, O_RDWR, TRUE);
+(void)add_fd(-1, dir3, O_RDWR, TRUE);
 
 if (victim_path != NULL)
 open_fds(victim_path, TRUE);
",199,51
Remove extraneous output," static void parse_args(int argc, char *argv[])
 
 do_exclude_syscall = TRUE;
 toggle_syscall(optarg, FALSE);
-
-printf(""Disabling syscall %s\n"", optarg);
 }
 }
 
",518,116
"be silent about file open failure

this happens with . and .. sometimes (when trinity has screwed up dir perms)
We still have them added to the filelist, so that's ok."," static int add_fd(unsigned int chance, const char *pathname, int flags, unsigned
 }
 
 if (fd < 0) {
-printf(""Couldn't open %s : %s\n"", pathname, strerror(errno));
+//printf(""Couldn't open %s : %s\n"", pathname, strerror(errno));
 return -1;
 }
 //printf(""Added: %s\n"", pathname);
",198,51
add an \0 string as a pathname.," void open_files()
 const char dir1[]=""/"";
 const char dir2[]=""."";
 const char dir3[]="".."";
+const char dir4[]="""";
 
 while (fds_left_to_create > 0) {
 
 (void)add_fd(-1, dir1, O_RDONLY, TRUE);
 (void)add_fd(-1, dir2, O_RDWR, TRUE);
 (void)add_fd(-1, dir3, O_RDWR, TRUE);
+(void)add_fd(-1, dir4, O_RDWR, TRUE);
 
 if (victim_path != NULL)
 open_fds(victim_path, TRUE);
",200,51
remove pointless test," void parse_args(int argc, char *argv[])
 toggle_syscall(optarg, FALSE);
 }
 }
-
-if (show_syscall_list == 1)
-return;
 }
",147,28
add 2MB as an interesting value.," unsigned long get_interesting_32bit_value()
 
 } else {
 /* less common case, go crazy */
-i = rand() % 9;
+i = rand() % 10;
 
 switch (i) {
 case 0:return 0x00010000;
-case 1:return 0x7fffffff;
-case 2:return 0x80000000;
-case 3:return 0x80000001;
-case 4:return 0x8fffffff;
-case 5:return 0xf0000000;
-case 6:return 0xff000000;
-case 7:return 0xffffff00 | (rand() % 256);
-case 8:return 0xffffffff;
+case 1:return 0x40000000;
+case 2:return 0x7fffffff;
+case 3:return 0x80000000;
+case 4:return 0x80000001;
+case 5:return 0x8fffffff;
+case 6:return 0xf0000000;
+case 7:return 0xff000000;
+case 8:return 0xffffff00 | (rand() % 256);
+case 9:return 0xffffffff;
 default: /* unreachable*/
 return 0;
 }
",342,120
"Fix up the syscall group code

On bi-arch, use the 32bit syscalls too."," int main(int argc, char* argv[])
 if (create_shm())
 exit(EXIT_FAILURE);
 
+if (desired_group != GROUP_NONE)
+ret = setup_syscall_group(desired_group);
+if (ret == FALSE) {
+ret = EXIT_FAILURE;
+goto cleanup_shm;
+}
+
 if (show_syscall_list == TRUE) {
 dump_syscall_tables();
 goto cleanup_shm;
 int main(int argc, char* argv[])
 if (logging != 0)
 open_logfiles();
 
-if (desired_group == GROUP_VM) {
-struct syscalltable *newsyscalls;
-int count = 0, j = 0;
-
-for (i = 0; i < max_nr_syscalls; i++) {
-if (syscalls[i].entry->group == GROUP_VM)
-count++;
-}
-
-newsyscalls = malloc(count * sizeof(struct syscalltable));
-if (newsyscalls == NULL)
-exit(EXIT_FAILURE);
-
-for (i = 0; i < max_nr_syscalls; i++) {
-if (syscalls[i].entry->group == GROUP_VM)
-newsyscalls[j++].entry = syscalls[i].entry;
-}
-
-max_nr_syscalls = count;
-syscalls = newsyscalls;
-}
 
 if (!do_specific_syscall) {
 if (biarch == TRUE)
",223,41
list the entry point number," void dump_syscall_tables(void)
 
 if (biarch == TRUE) {
 for (i = 0; i < max_nr_32bit_syscalls; i++) {
-printf(""32bit %s : "", syscalls_32bit[i].entry->name);
+printf(""32 bit entrypoint %d %s : "", syscalls_32bit[i].entry->number, syscalls_32bit[i].entry->name);
 if (syscalls_32bit[i].entry->flags & ACTIVE)
 printf(""Enabled\n"");
 else
 printf(""Disabled\n"");
 }
 for (i = 0; i < max_nr_64bit_syscalls; i++) {
-printf(""64bit %s : "", syscalls_64bit[i].entry->name);
+printf(""64 bit entrypoint %d %s : "", syscalls_64bit[i].entry->number, syscalls_64bit[i].entry->name);
 if (syscalls_64bit[i].entry->flags & ACTIVE)
 printf(""Enabled\n"");
 else
",202,58
missing braces broke non-group behaviour.," int main(int argc, char* argv[])
 if (create_shm())
 exit(EXIT_FAILURE);
 
-if (desired_group != GROUP_NONE)
+if (desired_group != GROUP_NONE) {
 ret = setup_syscall_group(desired_group);
 if (ret == FALSE) {
 ret = EXIT_FAILURE;
 goto cleanup_shm;
 }
+}
 
 if (show_syscall_list == TRUE) {
 dump_syscall_tables();
",224,41
output number of syscalls," void dump_syscall_tables(void)
 unsigned int i;
 
 if (biarch == TRUE) {
+printf(""32bit syscalls: %d\n"", max_nr_32bit_syscalls);
+printf(""64bit syscalls: %d\n"", max_nr_64bit_syscalls);
+
 for (i = 0; i < max_nr_32bit_syscalls; i++) {
 printf(""32 bit entrypoint %d %s : "", syscalls_32bit[i].entry->number, syscalls_32bit[i].entry->name);
 if (syscalls_32bit[i].entry->flags & ACTIVE)
 void dump_syscall_tables(void)
 printf(""Disabled\n"");
 }
 } else {
+printf(""syscalls: %d\n"", max_nr_syscalls);
 for (i = 0; i < max_nr_syscalls; i++) {
 printf(""%s : "", syscalls[i].entry->name);
 if (syscalls[i].entry->flags & ACTIVE)
",205,58
change boolean tests to use TRUE/FALSE instead of 1/0," static void reenable_coredumps()
 }
 static void set_make_it_fail()
 {
-static char failed = 0;
+static char failed = FALSE;
 int fd;
 const char *buf = ""1"";
 
 /* If we failed last time, don't bother trying in future. */
-if (failed == 1)
+if (failed == TRUE)
 return;
 
 fd = open(""/proc/self/make-it-fail"", O_WRONLY);
 static void set_make_it_fail()
 if (errno != EPERM)
 printf(""writing to /proc/self/make-it-fail failed! (%s)\n"", strerror(errno));
 else
-failed = 1;
+failed = TRUE;
 }
 close(fd);
 }
",127,28
remove unused function,"
 #include ""files.h""
 #include ""syscall.h""
 
-void syscall_list()
-{
-unsigned int i;
-
-if (biarch == TRUE) {
-printf(""32bit:\n"");
-for (i=0; i < max_nr_32bit_syscalls; i++)
- printf(""%u: %s\n"", i, syscalls_32bit[i].entry->name);
-
-printf(""64bit:\n"");
-for (i=0; i < max_nr_64bit_syscalls; i++)
- printf(""%u: %s\n"", i, syscalls_64bit[i].entry->name);
-} else {
-for (i=0; i < max_nr_syscalls; i++)
- printf(""%u: %s\n"", i, syscalls[i].entry->name);
-}
-}
-
 static void regenerate()
 {
 output(""[%d] Regenerating random pages, fd's etc.\n"", getpid());
",183,39
Proper detection of -ENOSYS," args_done:
 sptr = string;
 
 /* If the syscall doesn't exist don't bother calling it next time. */
-if (ret == -ENOSYS)
+if ((ret == -1) && (errno == ENOSYS)) {
+output(""%s returned ENOSYS, marking as avoid.\n"", syscalls[call].entry->name);
 syscalls[call].entry->flags |= AVOID_SYSCALL;
+}
 
 shm->execcount++;
 
",154,23
"Make sure at least one syscall is enabled before we start main loop

And adjust biarch path to only call per-arch functions if we have any enabled
on that arch."," int child_process(void)
 while (shm->exit_now == FALSE) {
 
 if (biarch == TRUE) {
-/*
- * 10% possibility of a 32bit syscall
- */
-shm->do32bit = FALSE;
-//if (rand() % 100 < 10)
-//shm->do32bit = TRUE;
+
+if ((use_64bit == TRUE) && (use_32bit == TRUE)) {
+/*
+ * 10% possibility of a 32bit syscall
+ */
+shm->do32bit = FALSE;
+//if (rand() % 100 < 10)
+//shm->do32bit = TRUE;
+}
+
 
 if (shm->do32bit == FALSE) {
 syscalls = syscalls_64bit;
",129,30
"Limit search to PF_MAX, not PROTO_MAX"," void find_specific_proto(char *protoarg)
 }
 } else {
 /* we were passed a numeric arg. */
-for (i = 0; i < PROTO_MAX; i++) {
+for (i = 0; i < PF_MAX; i++) {
 if (specific_proto == p[i].proto)
 break;
 }
",238,33
add NFC to search list," static struct protocol protocols[] = {
 { ""PF_IEEE802154"", 36 },
 { ""PF_CAIF"", 37 },
 { ""PF_ALG"", 38 },
+{ ""PF_NFC"", 39 },
 };
 
 void find_specific_proto(char *protoarg)
",239,33
make the default case pick from just the known socket types," void sanitise_socket(
 }
 break;
 
-default: break;
+default:
+switch (rand() % 6) {
+case 0:*type = SOCK_DGRAM;break;
+case 1:*type = SOCK_STREAM;break;
+case 2:*type = SOCK_SEQPACKET;break;
+case 3:*type = SOCK_RAW;break;
+case 4:*type = SOCK_RDM;break;
+case 5:*type = SOCK_PACKET;break;
+default: break;
+}
+
+break;
 }
 
 if ((rand() % 100) < 25)
",120,34
"Remove the spinning thing when generating sockets.

It just uglies up the display, and it's pretty fast now anyway.","
 
 unsigned int socks=0;
 
-static int spin=0;
-static char spinner[]=""-\\|/"";
-
 static const char *cachefilename=""trinity.socketcache"";
 
 #define MAX_PER_DOMAIN 5
 void generate_sockets(unsigned int nr_to_create)
 else
 domain = i;
 
-output(""%c (%d sockets created. needed:%d) [domain:%d type:0x%x proto:%d] \r"",
-spinner[spin++], socks, nr_to_create,
+output(""(%d sockets created. needed:%d) [domain:%d type:0x%x proto:%d]\n"",
+socks, nr_to_create,
 domain, type, protocol);
-if (spin == 4)
-spin = 0;
 
 fd = socket(domain, type, protocol);
 if (fd > -1) {
",235,32
centralise the backward compatablity ifdefs,"
 #include <stdlib.h>
 #include <asm/mman.h>
 
-#ifndef MAP_UNINITIALIZED
-#define MAP_UNINITIALIZED 0x4000000
-#endif
-
-#ifndef PROT_SEM
-#define PROT_SEM 0x8
-#endif
-
-#ifndef MAP_HUGETLB
-#define MAP_HUGETLB 0x40000
-#endif
-
-#ifndef MAP_STACK
-#define MAP_STACK 0x20000
-#endif
-
 #include ""trinity.h""
 #include ""sanitise.h""
 #include ""arch.h""
+#include ""compat.h""
 
 void sanitise_mmap(
 __unused__ unsigned long *addr,
",55,4
"dump pidslots when we can't find a space.

This still occasionally fails, so add some debugging."," static void handle_children()
 if (slot == -1) {
 printf(""[%d] ## Couldn't find pid slot for %d\n"", getpid(), childpid);
 shm->exit_now = TRUE;
+
+for (i = 0; i < shm->nr_childs; i++)
+printf(""slot%d: %d\n"", i, shm->pids[i]);
 } else
 debugf(""[%d] Child %d exited after %d syscalls.\n"", getpid(), childpid, shm->total_syscalls[slot]);
 reap_child(childpid);
",185,40
don't mremap zero page," static void sanitise_mremap(
 {
 unsigned long mask = ~(page_size-1);
 
+retry_addr:
 *addr &= mask;
 
+if (*addr == 0)
+*addr = (unsigned long) get_address();
+goto retry_addr;
+
 if (*flags & MREMAP_FIXED) {
 // Can't be fixed, and maymove.
 *flags &= ~MREMAP_MAYMOVE;
",44,3
"Avoid mprotect for now.

This needs some thought. We don't want to end up marking things like
page_rand as read-only, or we'll segfault when we pass them to something else.

Not sure what the answer to this is going to be yet."," struct syscall syscall_mprotect = {
 },
 .sanitise = sanitise_mprotect,
 .group = GROUP_VM,
+
+.flags = AVOID_SYSCALL,// hopefully temporary.
 };
",42,3
"don't reseed randomness in the child.

This probably isn't making things any easier for reproducability if every thread
has a different seed."," int child_process(void)
 unsigned int syscallnr;
 unsigned int cpu;
 
-seed_from_tod();
-
 disable_coredumps();
 
 for (cpu = 0; cpu < shm->nr_childs; cpu++) {
",128,30
identify where the seed came from in the log," void seed_from_tod()
 gettimeofday(&t, 0);
 seed = t.tv_sec * t.tv_usec;
 srand(seed);
-output(""\n\n[%d] Random seed: %u (0x%x)\n"", getpid(), seed, seed);
+output(""\n\n[%d] Random seed from time of day: %u (0x%x)\n"", getpid(), seed, seed);
 }
 
 static void sighandler(__unused__ int sig)
 int main(int argc, char* argv[])
 if (!seed)
 seed_from_tod();
 else
-output(""[%d] Random seed: %u (0x%x)\n"", getpid(), seed, seed);
+output(""[%d] Using user passed random seed: %u (0x%x)\n"", getpid(), seed, seed);
 
 
 init_buffers();
",230,42
"Add support for logging to syslog.

Based on patch from Jan Stancek <jstancek@redhat.com>","
 #include <unistd.h>
 #include <setjmp.h>
 #include <malloc.h>
+#include <syslog.h>
 #include <asm/unistd.h>
 #include <sys/time.h>
 #include <sys/stat.h>
 void seed_from_tod()
 seed = t.tv_sec * t.tv_usec;
 srand(seed);
 output(""\n\n[%d] Random seed from time of day: %u (0x%x)\n"", getpid(), seed, seed);
+if (do_syslog == FALSE)
+return;
+
+fprintf(stderr, ""Randomness reseeded to 0x%x\n"", seed);
+openlog(""trinity"", LOG_CONS|LOG_PERROR, LOG_USER);
+syslog(LOG_CRIT, ""Randomness reseeded to 0x%x\n"", seed);
+closelog();
 }
 
 static void sighandler(__unused__ int sig)
",237,43
"consume some randomness before each fork.

Because the parent wasn't consuming any randomness, it was possible
for all the child processes to end up doing the same syscalls, with
the same values. Side-effect of trinity no longer have per-child reseeding."," static void fork_children()
 exit(EXIT_FAILURE);
 }
 
+/*
+ * consume some randomness. otherwise each child starts
+ * with the same random seed, and ends up doing identical syscalls.
+ */
+(void) rand();
+
 (void)alarm(0);
 pid = fork();
 if (pid != 0)
",186,40
"add a get_non_null_address function

this removes the need for loops like we had in the mremap sanitise"," unsigned long get_interesting_value()
 #endif
 }
 
-void * get_address()
+static void * _get_address(unsigned char null_allowed)
 {
 int i;
 void *addr = NULL;
 
-i = rand() % 9;
+if (null_allowed == TRUE)
+i = rand() % 9;
+else
+i = (rand() % 8) + 1;
+
+
 switch (i) {
 case 0: addr = NULL;
 break;
 void * get_address()
 }
 }
 
+void * get_address()
+{
+return _get_address(TRUE);
+}
+
+void * get_non_null_address()
+{
+return _get_address(FALSE);
+}
+
+
+
 void regenerate_random_page()
 {
 unsigned int i, j;
 static unsigned long fill_arg(int call, int argnum)
 
 case ARG_ADDRESS:
 return (unsigned long)get_address();
+case ARG_NON_NULL_ADDRESS:
+return (unsigned long)get_non_null_address();
 case ARG_PID:
 return (unsigned long)get_pid();
 case ARG_RANGE:
",355,124
only print out sockets that we successfully opened," void generate_sockets(unsigned int nr_to_create)
 else
 domain = i;
 
-output(""(%d sockets created. needed:%d) [domain:%d type:0x%x proto:%d]\n"",
-socks, nr_to_create,
-domain, type, protocol);
-
 fd = socket(domain, type, protocol);
 if (fd > -1) {
 shm->socket_fds[socks] = fd;
",232,32
"rework the interesting number function

introduce possibility for single bits."," unsigned long filebuffersize = 0;
 
 unsigned long get_interesting_32bit_value()
 {
-int i;
+int i, bit;
 
 i = rand() % 10;
 
-if (i > 3) {
-/* common case, return small values*/
+switch (i) {
+
+/* rare case, single bit. */
+case 0:
+bit = rand() % 63;
+return (1 << bit);
+
+/* common case, return small values*/
+case 1 ... 7:
 i = rand() % 8;
 
 switch (i) {
 unsigned long get_interesting_32bit_value()
 default: /* unreachable*/
 return 0;
 }
+break;
 
-} else {
+case 8 ... 10:
 /* less common case, go crazy */
 i = rand() % 10;
 
 unsigned long get_interesting_32bit_value()
 default: /* unreachable*/
 return 0;
 }
+break;
+
+default:
+break;
 }
 
 /* Should never be reached. */
",363,126
"report the 'should never happen' cases.

This should save some head-scratching if I ever miss adding a case:"," retry:fd = shm->fds[rand() % fd_idx];
 }
 ret = fileno(file);
 if (ret == -1) {
-printf(""%s:%s: fileno failed! %s\n"", __FILE__, __func__, strerror(errno));
+BUG(""fileno failed!"");
+printf(""%s"", strerror(errno));
 exit(EXIT_FAILURE);
 }
 }
",90,17
another BUG conversion," static unsigned long fill_arg(int call, int argnum)
 high = syscalls[call].entry->hi6range;
 break;
 default:
-printf(""this should never happen. %s:%d\n"", __FILE__, __LINE__);
+BUG(""Should never happen.\n"");
 break;
 }
 
",378,126
bit being shifted needs to be long," unsigned long get_interesting_32bit_value()
 /* rare case, single bit. */
 case 0:
 bit = rand() % 63;
-return (1 << bit);
+return (1L << bit);
 
 /* common case, return small values*/
 case 1 ... 7:
",378,126
"Compat changes for 2.6.32/11.04 compile.

Found these trying to compile trinity on an old 2.6.32/11.04 box.

Signed-off-by: Brian Haley <brian.haley@hp.com>","
 
 #include ""trinity.h""
 #include ""sanitise.h""
+#include ""compat.h""
 
 #define MSG_CMSG_COMPAT 0x80000000 /* This message needs 32 bit fixups */
 
",47,2
add IA32_PAGE_OFFSET as two 32-bit interesting values," unsigned long get_interesting_32bit_value()
 
 case 8 ... 10:
 /* less common case, go crazy */
-i = rand() % 10;
+i = rand() % 12;
 
 switch (i) {
 case 0:return 0x00010000;
 unsigned long get_interesting_32bit_value()
 case 3:return 0x80000000;
 case 4:return 0x80000001;
 case 5:return 0x8fffffff;
-case 6:return 0xf0000000;
-case 7:return 0xff000000;
-case 8:return 0xffffff00 | (rand() % 256);
-case 9:return 0xffffffff;
+case 6: return 0xc0000000;
+case 7:return 0xf0000000;
+case 8:return 0xff000000;
+case 9:return 0xFFFFe000;
+case 10: return 0xffffff00 | (rand() % 256);
+case 11: return 0xffffffff;
 default:
 BUG(""unreachable!\n"");
 return 0;
",380,128
"annotate syscalls that take a second address as an input

No difference to ARG_ADDRESS yet."," static unsigned long fill_arg(int call, int argnum)
 return (unsigned long)get_len();
 
 case ARG_ADDRESS:
+case ARG_ADDRESS2:
 return (unsigned long)get_address();
 case ARG_NON_NULL_ADDRESS:
 return (unsigned long)get_non_null_address();
",381,129
"Move the syscall number & arguments into per-child structs in the shm

This is necessary for future work where one sanitise routine depends
on the result from another."," int child_process(void)
 int ret = 0;
 unsigned int syscallnr;
 unsigned int cpu;
+unsigned int childno = find_pid_slot(pid);
 
 disable_coredumps();
 
 retry:
 if (syscalls[syscallnr].entry->flags & NI_SYSCALL)
 goto retry;
 
+/* if we get here, syscallnr is finally valid */
+
+shm->syscallno[childno] = syscallnr;
 
 if (syscallcount) {
 if (shm->execcount >= syscallcount) {
 shm->exit_now = TRUE;
-printf(""[%d] Reached maximum syscall count %ld\n"", getpid(), shm->execcount);
+printf(""[%d] Reached maximum syscall count %ld\n"", pid, shm->execcount);
 }
 }
 
-ret = mkcall(syscallnr);
+ret = mkcall(childno);
 }
 
 reenable_coredumps();
",130,30
"do ARG_ADDRESS half the time for ARG_ADDRESS2

sometimes we'll want completely different addresses, not just
same/mangled versions of what the first address was."," static unsigned long fill_arg(int childno, int call, int argnum)
 return (unsigned long)get_address();
 
 case ARG_ADDRESS2:
+/* just do ARG_ADDRESS half the time. */
+if ((rand() % 2) == 0)
+return (unsigned long)get_address();
 
 if ((syscalls[call].entry->arg1type == ARG_ADDRESS) ||
  (syscalls[call].entry->arg1type == ARG_NON_NULL_ADDRESS)) {
",422,145
"Just reap a single child each pass through the watchdog.

Reaping one child might free up enough resources that other
children are blocked on, so they might continue."," static void check_children(void)
 pid, old, now, diff);
 kill(pid, SIGKILL);
 reap_child(pid);
+break;
 }
 }
 }
",102,24
"don't reap in the watchdog.

Let the child handler deal with the pidmap cleanup."," static void check_children(void)
 output(""pid %d hasn't made progress in 30 seconds! (last:%ld now:%ld diff:%d) Killing.\n"",
 pid, old, now, diff);
 kill(pid, SIGKILL);
-reap_child(pid);
 break;
 }
 }
",101,24
"Make the watchdog look for pids that have disappeared.

If the oom-killer has taken away one of our children it could get confused.
If we can't ptrace it, it's probably been oom-killed.","
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <sys/wait.h>
+#include <sys/ptrace.h>
 
 #include ""trinity.h""
 #include ""shm.h""
 static void check_children(void)
 time_t old, now;
 pid_t pid;
 unsigned int i;
+int ret;
 
 gettimeofday(&tv, NULL);
 now = tv.tv_sec;
 static void check_children(void)
 //printf(""pid slot %d [%d]: old:%ld now:%ld diff= %d\n"", i, pid, old, now, diff);
 
 if (diff > 30) {
-output(""pid %d hasn't made progress in 30 seconds! (last:%ld now:%ld diff:%d) Killing.\n"",
+
+ret = ptrace(PTRACE_ATTACH, pid, NULL, NULL);
+if (ret == -ESRCH) {
+output(""pid %d has disappeared (oom-killed maybe?). Reaping.\n"");
+reap_child(pid);
+} else {
+output(""pid %d hasn't made progress in 30 seconds! (last:%ld now:%ld diff:%d). Sending SIGKILL.\n"",
 pid, old, now, diff);
-kill(pid, SIGKILL);
+ptrace(PTRACE_CONT, pid, NULL, NULL);
+kill(pid, SIGKILL);
+}
 break;
 }
 }
",110,25
always fflush stdout before we fork.," static void fork_children()
 (void) rand();
 
 (void)alarm(0);
+fflush(stdout);
 pid = fork();
 if (pid != 0)
 shm->pids[pidslot] = pid;
 void main_loop()
 if (!shm->regenerate)
 regenerate();
 
+fflush(stdout);
 pid = fork();
 if (pid == 0)
 watchdog();// Never returns.
",188,40
handle more errors from watchdog ptracing," static void check_children(void)
 if (diff > 30) {
 
 ret = ptrace(PTRACE_ATTACH, pid, NULL, NULL);
-if (ret == -ESRCH) {
+switch (ret) {
+case -ESRCH:
 output(""pid %d has disappeared (oom-killed maybe?). Reaping.\n"");
 reap_child(pid);
-} else {
+break;
+case -EPERM:
+output(""couldn't attach to pid %d. Zombie? Removing from pid map.\n"");
+reap_child(pid);
+break;
+default:
 output(""pid %d hasn't made progress in 30 seconds! (last:%ld now:%ld diff:%d). Sending SIGKILL.\n"",
 pid, old, now, diff);
 ptrace(PTRACE_CONT, pid, NULL, NULL);
 kill(pid, SIGKILL);
+break;
 }
 break;
 }
",117,26
"reverse how the regeneration counts.

Also move it to the right place. (main loop, instead of just on init)","
 
 static void regenerate()
 {
+shm->regenerate = 0;
+
 output(""[%d] Regenerating random pages, fd's etc.\n"", getpid());
 
 regenerate_fds();
 static void regenerate()
 destroy_maps();
 setup_maps();
 
-shm->regenerate = REGENERATION_POINT - 1;
-
 regenerate_random_page();
 }
 
 void main_loop()
 {
 pid_t pid;
 
-if (!shm->regenerate)
-regenerate();
-
 fflush(stdout);
 pid = fork();
 if (pid == 0)
 void main_loop()
 while (shm->exit_now == FALSE) {
 fork_children();
 handle_children();
+
+if (shm->regenerate >= REGENERATION_POINT)
+regenerate();
+
+//output(""regenerate:%d\n"", shm->regenerate);
 }
 printf(""[%d] Bailing main loop\n"", getpid());
 }
",188,40
regeneration should reopen pipes/sockets too,"
 #include <sys/stat.h>
 
 #include ""trinity.h""
+#include ""files.h""
 #include ""shm.h""
 #include ""constants.h""
 
 void regenerate_fds(void)
 {
 close_files();
 pathname_idx = 0;
-open_files();
+setup_fds();
 }
",202,51
"disable the . .. passing for now

it's a pain in the ass for debugging when it chmod's the sourcedir to something unreadable."," openit:
 
 void open_files()
 {
-const char dir1[]=""/"";
+/*const char dir1[]=""/"";
 const char dir2[]=""."";
 const char dir3[]="".."";
 const char dir4[]="""";
-
+*/
 while (fds_left_to_create > 0) {
 
-(void)add_fd(-1, dir1, O_RDONLY, TRUE);
+/*(void)add_fd(-1, dir1, O_RDONLY, TRUE);
 (void)add_fd(-1, dir2, O_RDWR, TRUE);
 (void)add_fd(-1, dir3, O_RDWR, TRUE);
 (void)add_fd(-1, dir4, O_RDWR, TRUE);
-
+*/
 if (victim_path != NULL)
 open_fds(victim_path, TRUE);
 
",194,51
regenerate needs to close pipes/sockets too.," unsigned int fd_idx = 0;
 
 unsigned int fds_left_to_create = MAX_FDS;
 
-void open_pipes(void)
+static void open_pipes(void)
 {
 int pipes[MAX_PIPE_FDS * 2];
 unsigned int i;
 void open_pipes(void)
 }
 }
 
-void setup_fds(void)
+static void close_pipes(void)
 {
-open_pipes();
-open_sockets();
-open_files();
+unsigned int i;
+int fd;
+
+for (i = 0; i < MAX_PIPE_FDS; i+=2) {
+fd = shm->pipe_fds[i];
+shm->pipe_fds[i] = 0;
+close(fd);
+fd = shm->pipe_fds[i+1];
+shm->pipe_fds[i+1] = 0;
+close(fd);
+}
 }
 
 static int get_random_fd(void)
 regen:
 
 return shm->current_fd;
 }
+
+void setup_fds(void)
+{
+open_pipes();
+open_sockets();
+open_files();
+}
+
+void regenerate_fds(void)
+{
+close_pipes();
+close_files();
+close_sockets();
+
+setup_fds();
+}
",110,20
"don't regenerate sockets

This is a pain in the ass, because the socket state keeps the fd's open
for a while even after we close() them."," regen:
 void setup_fds(void)
 {
 open_pipes();
-open_sockets();
 open_files();
 }
 
 void regenerate_fds(void)
 {
-close_pipes();
 close_files();
-close_sockets();
+close_pipes();
 
 setup_fds();
 }
",108,20
"oops, we want to generate sockets on startup."," regen:
 void setup_fds(void)
 {
 open_pipes();
+open_sockets();
 open_files();
 }
 
 void regenerate_fds(void)
 close_files();
 close_pipes();
 
-setup_fds();
+open_pipes();
+open_files();
 }
",110,20
pause the children when regenerating fd's," int child_process(void)
 
 while (shm->exit_now == FALSE) {
 
+while (shm->regenerating == TRUE)
+sleep(1);
+
 if (biarch == TRUE) {
 
 if ((use_64bit == TRUE) && (use_32bit == TRUE)) {
",132,31
"supress unused param warnings in syscall32()

arches that do not define any code for syscall32()
are failing to compile, because gcc complains
about unused parameters. Supress these warnings.

Signed-off-by: Jan Stancek <jstancek@redhat.com>"," static long syscall32(int num_args, unsigned int call,
 return __res;
 }
 /* TODO: 6 arg 32bit x86 syscall goes here.*/
+#else
+
+// TODO: 32-bit syscall entry for non-x86 archs goes here.
+UNUSED(num_args);
+UNUSED(call);
+UNUSED(a1);
+UNUSED(a2);
+UNUSED(a3);
+UNUSED(a4);
+UNUSED(a5);
+UNUSED(a6);
 #endif
-
-// TODO: 32-bit syscall entry for non-x86 archs goes here.
 return 0;
 }
 
",171,23
backwards compat for ptrace,"
 /*
 * SYSCALL_DEFINE4(ptrace, long, request, long, pid, long, addr, long, data)
 */
+#include <stdlib.h>
+#include <linux/ptrace.h>
+
 #include ""trinity.h""
 #include ""sanitise.h""
 #include ""shm.h""
-#include <stdlib.h>
-#include <linux/ptrace.h>
+#include ""compat.h""
 
 
 static void sanitise_ptrace(int childno)
",32,1
"initialize max_nr_syscalls for powerpc

Signed-off-by: Jan Stancek <jstancek@redhat.com>"," void setup_syscall_tables(void)
 max_nr_syscalls = NR_I386_SYSCALLS;
 #elif defined(__powerpc__)
 syscalls = syscalls_ppc;
+max_nr_syscalls = NR_PPC_SYSCALLS;
 #elif defined(__ia64__)
 syscalls = syscalls_ia64;
 #elif defined(__sparc__)
",239,68
"ARM support

Signed-off-by: Philippe De Swert <philippedeswert@gmail.com>
Signed-off-by: Mikko Rapeli <mikko.rapeli@iki.fi>"," void setup_syscall_tables(void)
 syscalls = syscalls_ia64;
 #elif defined(__sparc__)
 syscalls = syscalls_sparc;
+#elif defined(__arm__)
+syscalls = syscalls_arm;
+syscalls_32bit = syscalls_arm;
+max_nr_syscalls = NR_ARM_SYSCALLS;
 #else
 syscalls = syscalls_i386;
 #endif
",242,69
make sure there's always at least one syscall enabled.," retry:
 }
 
 ret = mkcall(childno);
+
+if (validate_syscall_tables() == FALSE) {
+shm->exit_now = TRUE;
+output(""[%d] No more syscalls enabled. Exiting\n"");
+}
 }
 
 reenable_coredumps();
",136,32
microoptimisation to exit faster when -N is near regeneration point.,"
 
 static void regenerate()
 {
+if (syscallcount >= shm->regenerate)
+return;
+
 shm->regenerating = TRUE;
 
 sleep(1);/* give children time to finish with fds. */
",193,41
Abort if the watchdog segfaults.," static void handle_children()
 case SIGPIPE:
 case SIGABRT:
 debugf(""[%d] got a signal from pid %d (%s)\n"", getpid(), childpid, strsignal(WTERMSIG(childstatus)));
+if (childpid == shm->watchdog_pid) {
+output(""Bad juju from the watchdog.Exiting immediately.\n"");
+shm->exit_now = TRUE;
+}
+
 reap_child(childpid);
 break;
 default:
",197,42
log more information.," static void handle_children()
 case SIGABRT:
 debugf(""[%d] got a signal from pid %d (%s)\n"", getpid(), childpid, strsignal(WTERMSIG(childstatus)));
 if (childpid == shm->watchdog_pid) {
-output(""Bad juju from the watchdog.Exiting immediately.\n"");
+output(""Bad juju from the watchdog. Exiting immediately. %s\n"", strsignal(WTERMSIG(childstatus)));
 shm->exit_now = TRUE;
 }
 
",197,42
"Don't worry about ENOSYS on futex

This could use some improving maybe. What a pain."," args_done:
 
 /* If the syscall doesn't exist don't bother calling it next time. */
 if ((ret == -1) && (errno == ENOSYS)) {
+
+/* Futex is awesome, it ENOSYS's depending on arguments. Sigh. */
+if (call == search_syscall_table(syscalls, max_nr_syscalls, ""futex""))
+goto skip_enosys;
+
 output(""%s returned ENOSYS, marking as avoid.\n"", syscalls[call].entry->name);
 syscalls[call].entry->flags |= AVOID_SYSCALL;
 }
 
+skip_enosys:
+
 shm->execcount++;
 
 if (syscalls[call].entry->post)
",174,24
missing pid arguments," static void check_children(void)
 
 switch (ret) {
 case -ESRCH:
-output(""pid %d has disappeared (oom-killed maybe?). Reaping.\n"");
+output(""pid %d has disappeared (oom-killed maybe?). Reaping.\n"", pid);
 reap_child(pid);
 break;
 
 case -EPERM:
-output(""couldn't attach to pid %d. Zombie? Removing from pid map.\n"");
+output(""couldn't attach to pid %d. Zombie? Removing from pid map.\n"", pid);
 reap_child(pid);
 break;
 
 default:
 ptrace(PTRACE_CONT, pid, NULL, NULL);
-output(""tried to kill pid %d, but %s. Trying again.\n"", strerror(errno));
+output(""tried to kill pid %d, but %s. Trying again.\n"", pid, strerror(errno));
 kill(pid, SIGKILL);
 break;
 }
",124,28
"don't log messages about EBUSY, just send a kill"," static void check_children(void)
 break;
 
 default:
-ptrace(PTRACE_CONT, pid, NULL, NULL);
 output(""tried to kill pid %d, but %s. Trying again.\n"", pid, strerror(errno));
+// fallthrough
+;;
+
+case -EBUSY:
+ptrace(PTRACE_CONT, pid, NULL, NULL);
 kill(pid, SIGKILL);
 break;
 }
",126,29
"Introduce ARG_OP

This is like ARG_LIST, but only a single value gets set.
Used when we want to pick a 'command' argument for eg."," static unsigned long fill_arg(int childno, int call, int argnum)
 i &= high;
 }
 return i;
+
+case ARG_OP:/* Like ARG_LIST, but just a single value. */
+switch (argnum) {
+case 1:num = syscalls[call].entry->arg1list.num;
+values = syscalls[call].entry->arg1list.values;
+break;
+case 2:num = syscalls[call].entry->arg2list.num;
+values = syscalls[call].entry->arg2list.values;
+break;
+case 3:num = syscalls[call].entry->arg3list.num;
+values = syscalls[call].entry->arg3list.values;
+break;
+case 4:num = syscalls[call].entry->arg4list.num;
+values = syscalls[call].entry->arg4list.values;
+break;
+case 5:num = syscalls[call].entry->arg5list.num;
+values = syscalls[call].entry->arg5list.values;
+break;
+case 6:num = syscalls[call].entry->arg6list.num;
+values = syscalls[call].entry->arg6list.values;
+break;
+default: break;
+}
+mask |= values[rand() % num];
+return mask;
+
 case ARG_LIST:
 switch (argnum) {
 case 1:num = syscalls[call].entry->arg1list.num;
",449,155
"only log the ""reached maximum"" from the first child to hit it."," retry:
 shm->syscallno[childno] = syscallnr;
 
 if (syscallcount) {
-if (shm->execcount >= syscallcount) {
+if (shm->execcount >= syscallcount)
 shm->exit_now = TRUE;
+if (shm->execcount == syscallcount)
 printf(""[%d] Reached maximum syscall count %ld\n"", pid, shm->execcount);
-}
 }
 
 ret = mkcall(childno);
",136,33
initialise the regeneration point to the correct value," static int create_shm()
 memset(shm, 0, sizeof(struct shm_s));
 
 shm->execcount = 1;
-shm->regenerate = REGENERATION_POINT - 1;
+shm->regenerate = 0;
 
 shm->nr_childs = sysconf(_SC_NPROCESSORS_ONLN);
 if (shm->nr_childs > MAX_NR_CHILDREN) {
",237,43
"handle the case of ENOSYS and -c correctly.

When we have no more syscalls left to run, we got stuck in an infinite loop.
Refactor the validation code accordingly."," int child_process(void)
 //shm->do32bit = TRUE;
 }
 
+if (validate_syscall_table_32() == FALSE)
+use_32bit = FALSE;
+
+if (validate_syscall_table_64() == FALSE)
+use_64bit = FALSE;
 
 if (shm->do32bit == FALSE) {
 syscalls = syscalls_64bit;
 int child_process(void)
 }
 }
 
+if (count_enabled_syscalls() == 0) {
+output(""[%d] No more syscalls enabled. Exiting\n"");
+shm->exit_now = TRUE;
+}
+
 retry:
-/* We're doing something random. */
 syscallnr = rand() % max_nr_syscalls;
 
 if (syscalls[syscallnr].entry->num_args == 0)
 retry:
 }
 
 ret = mkcall(childno);
-
-if (validate_syscall_tables() == FALSE) {
-shm->exit_now = TRUE;
-output(""[%d] No more syscalls enabled. Exiting\n"");
-}
 }
 
 reenable_coredumps();
 
+output(""child %d waiting for watchdog to exit\n"", getpid());
 wait_for_watchdog_to_exit();
 
 return ret;
",141,35
remove unnecessary double return," static void fork_children()
 return;
 
 }
-debugf(""[%d] created enough children\n\n"", getpid());
+debugf(""[%d] created enough children\n"", getpid());
 }
 
 void reap_child(pid_t childpid)
",199,43
Move the total fail/success to the iterations printout rather than every syscall.," args_done:
 WHITE
 shm->successes++;
 }
-sptr += sprintf(sptr, "" [T:%ld F:%ld S:%ld]"", shm->execcount, shm->failures, shm->successes);
 sptr += sprintf(sptr, ""\n"");
 
 *sptr = '\0';
",173,24
"No need anymore for assigning syscalls_32, BIARCH flag takes care of that

Signed-off-by: Philippe De Swert <philippedeswert@gmail.com>"," void setup_syscall_tables(void)
 syscalls = syscalls_sparc;
 #elif defined(__arm__)
 syscalls = syscalls_arm;
-syscalls_32bit = syscalls_arm;
 max_nr_syscalls = NR_ARM_SYSCALLS;
 #else
 syscalls = syscalls_i386;
",274,79
"Don't reap zombies.

This is worse than leaving them running, as we end up essentially forkbombing
if something goes wrong. By leaving them, we cap the number of children
that we fork."," static void check_children(void)
 break;
 
 case -EPERM:
-output(""couldn't attach to pid %d. Zombie? Removing from pid map.\n"", pid);
-reap_child(pid);
+output(""couldn't attach to pid %d. Zombie? Sleeping another 30s\n"", pid);
+shm->tv[i].tv_sec = now;
 break;
 
 default:
",126,29
Make sure *all* children exit before the main loop terminates.," int find_pid_slot(pid_t mypid)
 return -1;
 }
 
+static unsigned char pidmap_empty()
+{
+unsigned int i;
+
+for (i = 0; i < shm->nr_childs; i++) {
+if (shm->pids[i] == -1)
+continue;
+if (shm->pids[i] != 0)
+return FALSE;
+}
+return TRUE;
+}
+
 
 #define debugf if (debug == TRUE) printf
 
 static void handle_children()
 break;
 
 case -1:
+if (shm->exit_now == TRUE)
+return;
+
 if (errno == ECHILD) {
 debugf(""[%d] All children exited!\n"", getpid());
 for (i = 0; i < shm->nr_childs; i++) {
 void main_loop()
 
 //output(""regenerate:%d\n"", shm->regenerate);
 }
+while (!(pidmap_empty()))
+handle_children();
+
 printf(""[%d] Bailing main loop\n"", getpid());
 }
",226,53
"move the final wait for watchdog exit into the main loop

This should be superfluous anyway, as the children shouldn't have exited.
It's here purely as a sanity check in case it takes a while to exit."," void main_loop()
 
 //output(""regenerate:%d\n"", shm->regenerate);
 }
+wait_for_watchdog_to_exit();
+
 while (!(pidmap_empty()))
 handle_children();
 
",227,53
"Fix infinite loop.

If child1 exits because there's no more syscalls enabled, it sets exit_now,
and the watchdog exits. After it has exited, child1 exits.
In the meantime, child2 hasn't been scheduled. It then gets stuck in
this loop with no way out."," int child_process(void)
 }
 
 retry:
+if (shm->exit_now == TRUE)
+goto out;
+
 syscallnr = rand() % max_nr_syscalls;
 
 if (syscalls[syscallnr].entry->num_args == 0)
 retry:
 ret = mkcall(childno);
 }
 
+
+out:
 reenable_coredumps();
 
 output(""child %d waiting for watchdog to exit\n"", getpid());
",144,36
log the previous syscall (for debugging purposes)," skip_enosys:
 
 if (syscalls[call].entry->post)
  syscalls[call].entry->post(ret);
+
+/* store info for debugging. */
+shm->previous_syscallno[childno] = shm->syscallno[childno];
+shm->previous_a1[childno] = shm->a1[childno];
+shm->previous_a2[childno] = shm->a2[childno];
+shm->previous_a3[childno] = shm->a3[childno];
+shm->previous_a4[childno] = shm->a4[childno];
+shm->previous_a5[childno] = shm->a5[childno];
+shm->previous_a6[childno] = shm->a6[childno];
+
 return ret;
 }
",180,24
"sanity check the tables on startup for missing members.

Fix up some missing ones.
(recvfrom was the only one that was really bad)."," long mkcall(int childno)
 WHITE\
 sptr += sprintf(sptr, ""%ld"", REG);\
 break;\
+case ARG_UNDEFINED:\
+BUG(""Undefined!\n"")\
+break;\
 case ARG_LEN:\
 case ARG_ADDRESS:\
 case ARG_ADDRESS2:\
 long mkcall(int childno)
 case ARG_LIST:\
 case ARG_RANDPAGE:\
 case ARG_CPU:\
+case ARG_RANDOM_INT:\
 default:\
 if (REG > 8 * 1024)\
 sptr += sprintf(sptr, ""0x%lx"", REG);\
",180,24
"gah, debugging left in the last commit actually broke some stuff."," long mkcall(int childno)
 sptr += sprintf(sptr, ""%ld"", REG);\
 break;\
 case ARG_UNDEFINED:\
-BUG(""Undefined!\n"")\
-break;\
 case ARG_LEN:\
 case ARG_ADDRESS:\
 case ARG_ADDRESS2:\
",180,24
move parentpid into shm," retry:
 if (pid == shm->pids[i])
 goto retry;
 }
-if (pid == parentpid)
+if (pid == shm->parentpid)
 goto retry;
 
 if (pid == shm->watchdog_pid)
",449,155
add missing cases for generic sanitise," static unsigned long fill_arg(int childno, int call, int argnum)
 }
 
 switch (argtype) {
+case ARG_UNDEFINED:
+case ARG_RANDOM_INT:
+return (unsigned long)rand();
+
 case ARG_FD:
 return get_fd();
 case ARG_LEN:
",452,157
"process signals from all children, not just the first one to wake up.

I think the problem with the zombies sticking around too long was due
to them being starved for attention in this function.

If one pidslot kept exiting/forking, all the others weren't getting
processed even though they were waiting for the parent to acknowledge
they were about to exit."," static void handle_children()
 
 default:
 debugf(""[%d] Something happened to pid %d\n"", getpid(), childpid);
-
+again:
 if (WIFEXITED(childstatus)) {
 
 slot = find_pid_slot(childpid);
 static void handle_children()
 output(""erk, wtf\n"");
 }
 }
+
+/* anything else to process ? */
+sleep(1);/* Give other children a chance to do something. */
+childpid = waitpid(-1, &childstatus, WUNTRACED | WCONTINUED | WNOHANG);
+if (childpid == 0)
+return;
+if (childpid == -1)
+return;
+
+goto again;
+
 }
 
 void main_loop()
",218,48
"handle signals when ptrace'd properly

we don't need to send a CONT if the signal was a segfault or whatever."," again:
 break;
 
 } else if (WIFSTOPPED(childstatus)) {
-debugf(""[%d] Child was stopped by %d."", getpid(), WSTOPSIG(childstatus));
-debugf(""[%d] Sending PTRACE_CONT (and then KILL)\n"", getpid());
-ptrace(PTRACE_CONT, childpid, NULL, NULL);
+debugf(""[%d] Child was stopped (%s).\n"", getpid(), strsignal(WSTOPSIG(childstatus)));
+if (WSTOPSIG(childstatus) == SIGSTOP) {
+debugf(""[%d] Sending PTRACE_CONT (and then KILL)\n"", getpid());
+ptrace(PTRACE_CONT, childpid, NULL, NULL);
+}
 kill(childpid, SIGKILL);
 reap_child(childpid);
 } else if (WIFCONTINUED(childstatus)) {
",220,49
"sleep when this ""shouldn't happen"" case happens.

A recent change seems to have started to occasionally trigger this."," void output(const char *fmt, ...)
 if (!handle) {
 printf(""## child logfile handle was null logging to main!\n"");
 handle = parentlogfile;
+sleep(5);
 return;
 }
 
",132,27
mention the pid of the child that was stopped," again:
 break;
 
 } else if (WIFSTOPPED(childstatus)) {
-debugf(""[%d] Child was stopped (%s).\n"", getpid(), strsignal(WSTOPSIG(childstatus)));
+debugf(""[%d] Child %d was stopped (%s).\n"", getpid(), childpid, strsignal(WSTOPSIG(childstatus)));
 if (WSTOPSIG(childstatus) == SIGSTOP) {
 debugf(""[%d] Sending PTRACE_CONT (and then KILL)\n"", getpid());
 ptrace(PTRACE_CONT, childpid, NULL, NULL);
",220,49
"update the parentpid after forking.

Since 01d0d494eb6777119a1a87983bf8eb580a591cd3, parentpid changes,
so we need to take that into consideration both before and after
the child handler."," void main_loop()
 pid = fork();
 if (pid != 0) {
 pid = waitpid(pid, &childstatus, WUNTRACED | WCONTINUED);
-_exit(EXIT_SUCCESS);
+shm->parentpid = getpid(); /* reset */
+return;
 }
 
+shm->parentpid = getpid();
+
 prctl(PR_SET_NAME, (unsigned long) &taskname);
 
 while (shm->watchdog_pid == 0)
",222,49
handle the case where ptrace succeeds explicitly," static void check_children(void)
 break;
 
 default:
-output(""tried to kill pid %d, but %s. Trying again.\n"", pid, strerror(errno));
+output(""(ret=%d) tried to attach to pid %d, but %s (%d). Trying again.\n"", ret, pid, strerror(errno), errno);
 // fallthrough
 ;;
 
 case -EBUSY:
+case 0:
 ptrace(PTRACE_CONT, pid, NULL, NULL);
 kill(pid, SIGKILL);
 break;
",129,31
"Try the 'jump back to the child handler when the alarm goes off' thing again.

A number of things have changed dramatically since I disabled this,
so things may be good enough to reenable this feature, which
should speed things up a little."," int child_process(void)
 {
 cpu_set_t set;
 pid_t pid = getpid();
-int ret = 0;
+int ret;
 unsigned int syscallnr;
 unsigned int cpu;
 unsigned int childno = find_pid_slot(pid);
 int child_process(void)
 if (extrafork == FALSE)
 init_child();
 
+sigsetjmp(ret_jump, 1);
+
+ret = 0;
+
 while (shm->exit_now == FALSE) {
 
 while (shm->regenerating == TRUE)
",146,36
handle (and ignore) sigalarm in child processing.," again:
 break;
 
 } else if (WIFSTOPPED(childstatus)) {
-debugf(""[%d] Child %d was stopped (%s).\n"", getpid(), childpid, strsignal(WSTOPSIG(childstatus)));
-if (WSTOPSIG(childstatus) == SIGSTOP) {
+switch (WSTOPSIG(childstatus)) {
+case SIGALRM:
+break;
+default:
+debugf(""[%d] Child %d was stopped (%s).\n"", getpid(), childpid, strsignal(WSTOPSIG(childstatus)));
+;; // fallthrough
+case SIGSTOP:
 debugf(""[%d] Sending PTRACE_CONT (and then KILL)\n"", getpid());
 ptrace(PTRACE_CONT, childpid, NULL, NULL);
+kill(childpid, SIGKILL);
+reap_child(childpid);
 }
-kill(childpid, SIGKILL);
-reap_child(childpid);
+break;
+
 } else if (WIFCONTINUED(childstatus)) {
 break;
 } else {
",228,50
"use PTRACE_DETACH, not PTRACE_CONT

Otherwise we may end up reparenting the child"," static unsigned long do_syscall(int childno)
 }
 if (WIFSTOPPED(childstatus)) {
 output(""[%d] Child process %d stopped. killing.\n"", getpid(), childpid);
-ptrace(PTRACE_CONT, childpid, NULL, NULL);
+ptrace(PTRACE_DETACH, childpid, NULL, NULL);
 kill(childpid, SIGKILL);
 break;
 }
",179,24
"avoid ptrace for now.

This is going to need some more thought.
There are a number of awkward cases where we end up with zombies.
One example:

child a ptraces child b
child a segfaults
child b waits forever for a PTRACE_DETACH/CONT

attempting a PTRACE_DETACH from the watchdog gets -ESRCH, because
it wasn't the pid that initiated the tracing."," struct syscall syscall_ptrace = {
 .arg3type = ARG_ADDRESS,
 .arg4name = ""data"",
 .sanitise = sanitise_ptrace,
+
+.flags = AVOID_SYSCALL,
 };
",33,1
"ignore ctrl-z for now.

sometimes, a tmux attach will send this for some reason, and trinity shits itself."," static void mask_signals(void)
 (void)signal(SIGCHLD, SIG_DFL);
 (void)signal(SIGFPE, SIG_IGN);
 (void)signal(SIGXCPU, SIG_IGN);
+(void)signal(SIGTSTP, SIG_IGN);
 if (debug == TRUE)
 (void)signal(SIGSEGV, SIG_DFL);
 }
",241,44
reinstate the ctrl-c handler.," void open_fds(const char *dir, unsigned char add_all)
 }
 while ((de = readdir(d))) {
 
+if (shm->exit_now == TRUE)
+return;
+
 memset(&buf, 0, sizeof(struct stat));
 snprintf(b, sizeof(b), ""%s/%s"", dir, de->d_name);
 if (ignore_files(de->d_name))
 void open_files()
 */
 while (fds_left_to_create > 0) {
 
+if (shm->exit_now == TRUE)
+return;
+
 /*(void)add_fd(-1, dir1, O_RDONLY, TRUE);
 (void)add_fd(-1, dir2, O_RDWR, TRUE);
 (void)add_fd(-1, dir3, O_RDWR, TRUE);
",193,52
introduce ARG_IOVEC/IOVECLEN," long mkcall(int childno)
 case ARG_RANDPAGE:\
 case ARG_CPU:\
 case ARG_RANDOM_INT:\
+case ARG_IOVEC:\
+case ARG_IOVECLEN:\
 default:\
 if (REG > 8 * 1024)\
 sptr += sprintf(sptr, ""0x%lx"", REG);\
",179,24
"remove the need for ARG_ADDRESS2

Now that the args are in the shm, we can just go hunting for them."," long mkcall(int childno)
 case ARG_UNDEFINED:\
 case ARG_LEN:\
 case ARG_ADDRESS:\
-case ARG_ADDRESS2:\
 case ARG_NON_NULL_ADDRESS:\
 case ARG_RANGE:\
 case ARG_OP:\
",179,24
factor out the watchdog startup and move to watchdog.c," void main_loop()
 if (shm->exit_now == TRUE)
 return;
 
-fflush(stdout);
-pid = fork();
-if (pid == 0)
-watchdog();// Never returns.
+init_watchdog();
 
 /* do an extra fork so that the watchdog and the children don't share a common parent */
 pid = fork();
",246,59
"check for exit status in loop in write sanitise.

Under memory pressure, we can spin here for a while, so explicitly check."," retry:
 newbuffer = malloc(newsize);
 if (newbuffer == NULL) {
 newsize >>= 1;
+if (shm->exit_now == TRUE)
+return;
 goto retry;
 }
 
",33,3
"rework main loop.

Split up the initialisation & the event handling.

Now we also wait for both the main process and the watchdog to exit when we ctrl-c."," int main(int argc, char* argv[])
 /* nothing right now */
 }
 
-main_loop();
+if (shm->exit_now == TRUE)
+goto cleanup_fds;
+
+init_watchdog();
+
+do_main_loop();
 
 printf(""\nRan %ld syscalls (%ld retries). Successes: %ld Failures: %ld\n"",
 shm->execcount - 1, shm->retries, shm->successes, shm->failures);
 
 ret = EXIT_SUCCESS;
 
-
-destroy_maps();
+cleanup_fds:
 
 for (i = 0; i < socks; i++)
 close(shm->socket_fds[i]);
 
+destroy_maps();
+
 if (logging == TRUE)
 close_logfiles();
 
",251,46
"add an exit check to the read sanitise too

For the same reason as sanitise_write"," retry:
 filebuffer = malloc(newsize);
 if (filebuffer == NULL) {
 newsize >>= 1;
+if (shm->exit_now == TRUE)
+return;
 goto retry;
 }
 filebuffersize = newsize;
",41,6
choose correct len for setsockopt based on the option set.,"
 
 #include <stdlib.h>
 #include <sys/socket.h>
+#include <sys/time.h>
+#include ""linux/filter.h""
 #include ""trinity.h""
 #include ""sanitise.h""
 #include ""shm.h""
 void sanitise_setsockopt(int childno)
 shm->a2[childno] = rand() % 256;
 
 shm->a4[childno] = (unsigned long) page_rand;
-shm->a5[childno] = rand() % page_size;
+
+shm->a5[childno] = sizeof(int);// at the minimum, we want an int.
+
+/* Adjust length according to operation set. */
+if (shm->a2[childno] == SOL_SOCKET) {
+switch (shm->a3[childno]) {
+case SO_LINGER:shm->a5[childno] = sizeof(struct linger);
+break;
+case SO_RCVTIMEO:
+case SO_SNDTIMEO:
+shm->a5[childno] = sizeof(struct timeval);
+break;
+case SO_ATTACH_FILTER:
+shm->a5[childno] = sizeof(struct sock_fprog);
+break;
+default:
+break;
+}
+}
 }
 
 struct syscall syscall_setsockopt = {
",59,7
"remove the extrafork code.

it was only ever meant for debugging, and has outlived its usefulness
(and is now broken with the new process model)"," int child_process(void)
 sched_setaffinity(getpid(), sizeof(set), &set);
 output(""bound child %d to cpu %d\n"", pid, cpu);
 }
-if (extrafork == FALSE)
-init_child();
+
+init_child();
 
 sigsetjmp(ret_jump, 1);
 
",145,35
"improve setsockopt sanitise

pass random args for non-SOL_SOCKET.","
 
 void sanitise_setsockopt(int childno)
 {
-if (rand() % 2)
-shm->a2[childno] = SOL_SOCKET;
-else
-shm->a2[childno] = rand() % 256;
-
 shm->a4[childno] = (unsigned long) page_rand;
+shm->a5[childno] = sizeof(int);// at the minimum, we want an int (overridden below)
 
-shm->a5[childno] = sizeof(int);// at the minimum, we want an int.
+if (rand() % 2) {
+shm->a2[childno] = SOL_SOCKET;
 
-/* Adjust length according to operation set. */
-if (shm->a2[childno] == SOL_SOCKET) {
+/* Adjust length according to operation set. */
 switch (shm->a3[childno]) {
 case SO_LINGER:shm->a5[childno] = sizeof(struct linger);
 break;
 void sanitise_setsockopt(int childno)
 default:
 break;
 }
+} else {
+//TODO: Add some specific cases here for IP etc.
+shm->a2[childno] = rand() % 256;/* random protocol. */
+shm->a3[childno] = rand() % 255;/* random operation. */
 }
 }
 
",59,6
remove unnecessary memset," void sanitise_ioctl_sg_io(int childno)
 struct sgio *sgio;
 
 sgio = (struct sgio *) page_rand;
-memset(page_rand, 0, page_size);
 
 sgio->cmd[0] = 0x12;
 sgio->cmd[3] = 0x2;
",45,8
ignore window change signals.," static void mask_signals(void)
 (void)signal(SIGFPE, SIG_IGN);
 (void)signal(SIGXCPU, SIG_IGN);
 (void)signal(SIGTSTP, SIG_IGN);
+(void)signal(SIGWINCH, SIG_IGN);
 if (debug == TRUE)
 (void)signal(SIGSEGV, SIG_DFL);
 }
",252,46
remove long-ago removed option from help text," static void usage(void)
 fprintf(stderr, "" --victims,-V: path to victim files.\n"");
 fprintf(stderr, ""\n"");
 fprintf(stderr, "" -c#: target specific syscall (takes syscall name as parameter).\n"");
-fprintf(stderr, "" -k: pass kernel addresses as arguments.\n"");
 fprintf(stderr, "" -N#: do # syscalls then exit.\n"");
 fprintf(stderr, "" -p: pause after syscall.\n"");
 fprintf(stderr, "" -s#: use # as random seed.\n"");
",149,28
fix case of monochrome short param," void parse_args(int argc, char *argv[])
 { ""help"", no_argument, NULL, 'h' },
 { ""list"", no_argument, NULL, 'L' },
 { ""logging"", required_argument, NULL, 'l' },
-{ ""monochrome"", no_argument, NULL, 'M' },
+{ ""monochrome"", no_argument, NULL, 'm' },
 { ""proto"", required_argument, NULL, 'P' },
 { ""quiet"", no_argument, NULL, 'q' },
 { ""syslog"", no_argument, NULL, 'S' },
",149,28
"2.6.32 compat changes

Another trinity compat patch.","
 #include ""linux/filter.h""
 #include ""trinity.h""
 #include ""sanitise.h""
+#include ""compat.h""
 #include ""shm.h""
 
 void sanitise_setsockopt(int childno)
",60,6
sanitise routine for splice,"
 # define SPLICE_F_MORE 4 /* Expect more data. */
 # define SPLICE_F_GIFT 8 /* Pages passed in are a gift. */
 
+#include <stdlib.h>
 #include ""trinity.h""
 #include ""sanitise.h""
+#include ""shm.h""
+
+void sanitise_splice(int childno)
+{
+if ((rand() % 10) < 3)
+return;
+
+if (rand() % 2) {
+shm->a1[childno] = shm->pipe_fds[rand() % MAX_PIPE_FDS];
+shm->a2[childno] = 0;
+}
+
+if (rand() % 2) {
+shm->a3[childno] = shm->pipe_fds[rand() % MAX_PIPE_FDS];
+shm->a4[childno] = 0;
+}
+}
 
 struct syscall syscall_splice = {
 .name = ""splice"",
 struct syscall syscall_splice = {
 .num = 4,
 .values = { SPLICE_F_MOVE, SPLICE_F_NONBLOCK, SPLICE_F_MORE, SPLICE_F_GIFT },
 },
+.sanitise = sanitise_splice,
 };
",38,4
vmsplice fd MUST be a pipe.,"
 
 static void sanitise_vmsplice(int childno)
 {
+shm->a1[childno] = shm->pipe_fds[rand() % MAX_PIPE_FDS];
 shm->a3[childno] = rand() % UIO_MAXIOV;
 }
 
",29,1
"just in case, occasionally pass a non-pipe fd.","
 
 static void sanitise_vmsplice(int childno)
 {
-shm->a1[childno] = shm->pipe_fds[rand() % MAX_PIPE_FDS];
+if ((rand() % 10) > 0)
+shm->a1[childno] = shm->pipe_fds[rand() % MAX_PIPE_FDS];
 shm->a3[childno] = rand() % UIO_MAXIOV;
 }
 
",30,2
tee only takes pipe fd's too.,"
 # define SPLICE_F_MORE 4 /* Expect more data. */
 # define SPLICE_F_GIFT 8 /* Pages passed in are a gift. */
 
+#include <stdlib.h>
 #include ""trinity.h""
 #include ""sanitise.h""
+#include ""shm.h""
+
+void sanitise_tee(int childno)
+{
+if ((rand() % 10) > 0) {
+shm->a1[childno] = shm->pipe_fds[rand() % MAX_PIPE_FDS];
+shm->a2[childno] = shm->pipe_fds[rand() % MAX_PIPE_FDS];
+}
+}
 
 struct syscall syscall_tee = {
 .name = ""tee"",
 struct syscall syscall_tee = {
 .num = 4,
 .values = { SPLICE_F_MOVE, SPLICE_F_NONBLOCK, SPLICE_F_MORE, SPLICE_F_GIFT },
 },
+.sanitise = sanitise_tee,
 };
",28,2
"improve read/write

- reduce read size to 1M
- increase write size to 1M
- don't try to allocate 0 bytes
- in write, don't free filebuffer if null","
 */
 static void sanitise_read(int childno)
 {
-unsigned long newsize = (unsigned int) shm->a3[childno] & 0xffffffff;
+unsigned long newsize = (unsigned int) shm->a3[childno] & 0xfffff;
 
 if (filebuffer != NULL) {
 if (filebuffersize < newsize) {
 retry:
 filebuffer = malloc(newsize);
 if (filebuffer == NULL) {
 newsize >>= 1;
+if (newsize == 0)// FIXME: Need a better way to indicate ""we're fucked"".
+return;
 if (shm->exit_now == TRUE)
 return;
 goto retry;
 }
 filebuffersize = newsize;
 }
+memset(filebuffer, 0, newsize);
+
 shm->a2[childno] = (unsigned long) filebuffer;
 shm->a3[childno] = newsize;
-memset(filebuffer, 0, newsize);
 }
 
 struct syscall syscall_read = {
",43,7
"pipes is only ever passed to pipe()

so it doesn't need to be so big."," unsigned int fds_left_to_create = MAX_FDS;
 
 static void open_pipes(void)
 {
-int pipes[MAX_PIPE_FDS * 2];
+int pipes[2];
 unsigned int i;
 
 for (i = 0; i < MAX_PIPE_FDS; i+=2) {
",110,20
"switch 'wait for watchdog' to poll instead of sleeping.

It seems there's a corner-case where we get children sleeping here
after the watchdog has left the building.

Until I figure out exactly what's going on, this band-aid should suffice."," void wait_for_watchdog_to_exit(void)
 
 while (shm->watchdog_pid != 0) {
 
-ret = waitpid(shm->watchdog_pid, &status, 0);
+if (shm->watchdog_pid == 0)
+return;
+
+ret = waitpid(shm->watchdog_pid, &status, WNOHANG);
 switch (ret) {
 case 0:
 break;
 case -1:
+shm->watchdog_pid = 0;
 return;
 default:
 if (WIFEXITED(status)) {
 void wait_for_watchdog_to_exit(void)
 }
 break;
 }
-sleep(1);
+sleep(0.1);
 }
 }
 
",136,33
common helper for dumping pid slots," static FILE * find_logfile_handle()
 return shm->logfiles[i];
 else {
 printf(""[%d] ## Couldn't find logfile for pid %d\n"", getpid(), pid);
-printf(""## pids: "");
-for (j = 0; j < shm->nr_childs; j++)
-printf(""%d "", shm->pids[j]);
-printf(""\n"");
+dump_pid_slots();
 printf(""## Logfiles for pids: "");
 for (j = 0; j < shm->nr_childs; j++)
 printf(""%p "", shm->logfiles[j]);
",129,26
don't call reap_child if we can't find the pid slot," static void handle_child(pid_t childpid, int childstatus)
 printf(""[%d] ## Couldn't find pid slot for %d\n"", getpid(), childpid);
 shm->exit_now = TRUE;
 dump_pid_slots();
-
-} else
+} else {
 debugf(""[%d] Child %d exited after %d syscalls.\n"", getpid(), childpid, shm->total_syscalls[slot]);
-reap_child(childpid);
+reap_child(childpid);
+}
 break;
 
 } else if (WIFSIGNALED(childstatus)) {
",248,59
"we know this is ESRCH, so don't bother printing errno in this case."," static void check_children(void)
 /* first things first, does the pid still exist ? */
 if (getpgid(pid) == -1) {
 if (errno == ESRCH) {
-output(""pid %d has disappeared (oom-killed maybe?). (ret=%d:%s) Reaping.\n"", pid, errno, strerror(errno));
+output(""pid %d has disappeared (oom-killed maybe?). Reaping.\n"", pid);
 reap_child(pid);
 } else {
 output(""problem running getpgid on pid %d (%d:%s)\n"", pid, errno, strerror(errno));
",136,33
"improve iovec code.

- always alloc a whole page.
- don't try to allocate zero iovecs"," static struct iovec * alloc_iovec(unsigned int num)
 iov = malloc(num * sizeof(struct iovec));
 if (iov != NULL) {
 for (i = 0; i < num; i++) {
-iov[i].iov_len = rand() % page_size;
-iov[i].iov_base = malloc(iov[i].iov_len);;
+iov[i].iov_base = malloc(page_size);
+iov[i].iov_len = page_size;
 }
 }
 return iov;
 static unsigned long fill_arg(int childno, int call, int argnum)
 return (unsigned long) pathnames[rand() % 50];
 
 case ARG_IOVEC:
-i = rand() % 4;
+i = (rand() % 4) + 1;
 
 switch (argnum) {
 case 1:if (syscalls[call].entry->arg2type == ARG_IOVECLEN)
",492,183
"exit the children first, then the watchdog.

This way, if any children get stuck while exiting, we can kill them."," retry:
 out:
 reenable_coredumps();
 
-output(""child %d waiting for watchdog to exit\n"", getpid());
-wait_for_watchdog_to_exit();
-
 return ret;
 }
",143,35
"if we blocked while reading an fd, don't reuse that fd.

There's lots of room for future improvement here, but this will suffice for now."," static void sighandler(__unused__ int sig)
 {
 switch(sig) {
 case SIGALRM:
+/* if we blocked in read() or similar, we want to avoid doing it again. */
+shm->fd_lifetime = 0;
+
 (void)signal(sig, sighandler);
 siglongjmp(ret_jump, 1);
 break;
",253,46
"Mix in the pidslot into the seed.

I accidentally committed a brainfart that reintroduced the ""every child is exactly the same"" bug.
Do the srand in the child, and make the seed child-unique."," static void fork_children()
 exit(EXIT_FAILURE);
 }
 
-/*
- * consume some randomness. otherwise each child starts
- * with the same random seed, and ends up doing identical syscalls.
- */
-(void) rand();
-
 (void)alarm(0);
 fflush(stdout);
 pid = fork();
 static void fork_children()
 shm->pids[pidslot] = pid;
 else {
 int ret = 0;
+
 memset(childname, 0, sizeof(childname));
 sprintf(childname, ""trinity-child%d"", pidslot);
 prctl(PR_SET_NAME, (unsigned long) &childname);
 
+set_seed(pidslot);
+
 /* Wait for parent to set our pidslot */
 while (shm->pids[pidslot] != getpid());
 
",259,62
"sanitise madvise

Limit it to a single page. Otherwise we segfault when we try to advise
past the end of page_rand or similar.","
 /*
 * SYSCALL_DEFINE3(madvise, unsigned long, start, size_t, len_in, int, behavior)
 */
+#include <stdlib.h>
+#include <sys/mman.h>
+
 #include ""trinity.h""
 #include ""sanitise.h""
 #include ""compat.h""
+#include ""shm.h""
 
-#include <sys/mman.h>
+static void sanitise_madvise(int childno)
+{
+shm->a2[childno] = rand() % page_size;
+}
 
 struct syscall syscall_madvise = {
 .name = ""madvise"",
 .num_args = 3,
 .arg1name = ""start"",
-.arg1type = ARG_ADDRESS,
+.arg1type = ARG_NON_NULL_ADDRESS,
 .arg2name = ""len_in"",
 .arg2type = ARG_LEN,
 .arg3name = ""advice"",
 struct syscall syscall_madvise = {
  MADV_MERGEABLE, MADV_UNMERGEABLE, MADV_HUGEPAGE, MADV_NOHUGEPAGE },
 },
 .group = GROUP_VM,
+.sanitise = sanitise_madvise,
 };
",28,1
"only mmap/munmap a single page.

This stops the segfaults we're seeing from happening
when we try to mmap past the end of page_rand etc.

We can improve this later to use larger sizes for /dev/zero maps etc."," void sanitise_mmap(int childno)
 
 /* page align addr & len */
 shm->a1[childno] &= PAGE_MASK;
-shm->a2[childno] &= PAGE_MASK;
+shm->a2[childno] = page_size;
 if (shm->a2[childno] == 0)
 shm->a2[childno] = page_size;
 
",54,5
return the unmunged address 95% of the time.," static void * _get_address(unsigned char null_allowed)
 break;
 }
 
-i = rand() % 5;
+i = rand() % 100;
 switch (i) {
-case 0:return addr;
-case 1:return addr + (page_size - sizeof(char));
-case 2:return addr + (page_size - sizeof(int));
-case 3:return addr + (page_size - sizeof(long));
-case 4:return addr + (page_size / 2);
+case 0:return addr + (page_size - sizeof(char));
+case 1:return addr + (page_size - sizeof(int));
+case 2:return addr + (page_size - sizeof(long));
+case 3:return addr + (page_size / 2);
+case 4 ... 99:
 default: return addr;
 }
 }
",492,183
TODO: make the kernel addresses per-arch," unsigned long get_interesting_value()
 case 8: return 0x0000800000000000;// First x86-64 non-canonical addr
 case 9: return 0x7fffffff00000000 | low;
 case 10: return 0x8000000000000000 | low;
+// FIXME: Use per-arch #defines for these
 case 11: return 0xffff800000000000 | (low << 4);// x86-64 canonical addr range 2 begin
 case 12: return 0xffff880000000000 | (low << 4);// x86-64 PAGE_OFFSET
 case 13: return 0xffffffff00000000 | low;
",492,183
return interesting numbers for unannotated arguments sometimes.," static unsigned long do_syscall(int childno)
 return ret;
 }
 
+static unsigned long get_reg()
+{
+if ((rand() % 2) == 0)
+return rand64();
+else
+return get_interesting_value();
+}
+
 long mkcall(int childno)
 {
 unsigned long olda1, olda2, olda3, olda4, olda5, olda6;
 long mkcall(int childno)
 if (shm->do32bit == TRUE)
 sptr += sprintf(sptr, ""[32BIT] "");
 
-olda1 = shm->a1[childno] = rand64();
-olda2 = shm->a2[childno] = rand64();
-olda3 = shm->a3[childno] = rand64();
-olda4 = shm->a4[childno] = rand64();
-olda5 = shm->a5[childno] = rand64();
-olda6 = shm->a6[childno] = rand64();
+olda1 = shm->a1[childno] = get_reg();
+olda2 = shm->a2[childno] = get_reg();
+olda3 = shm->a3[childno] = get_reg();
+olda4 = shm->a4[childno] = get_reg();
+olda5 = shm->a5[childno] = get_reg();
+olda6 = shm->a6[childno] = get_reg();
 
 if (call > max_nr_syscalls)
 sptr += sprintf(sptr, ""%u"", call);
",148,19
"ugly workaround for a race.

The pidmap really needs proper locking. I'll do it later."," static FILE * find_logfile_handle()
 if (i != -1)
 return shm->logfiles[i];
 else {
+/* try one more time. FIXME: This is awful. */
+printf(""[%d] ## Couldn't find logfile for pid %d. Retrying.\n"", getpid(), pid);
+sleep(1);
+i = find_pid_slot(pid);
+if (i != 1)
+return shm->logfiles[i];
+
 printf(""[%d] ## Couldn't find logfile for pid %d\n"", getpid(), pid);
 dump_pid_slots();
 printf(""## Logfiles for pids: "");
",134,27
output the reason for exiting.," int child_process(void)
 }
 
 if (count_enabled_syscalls() == 0) {
-output(""[%d] No more syscalls enabled. Exiting\n"");
+output(""[%d] No more syscalls enabled. Exiting\n"", getpid());
 shm->exit_now = TRUE;
 }
 
 retry:
 shm->syscallno[childno] = syscallnr;
 
 if (syscallcount) {
-if (shm->execcount >= syscallcount)
+if (shm->execcount >= syscallcount) {
+output(""[%d] shm->execcount (%d) >= syscallcount (%d)\n"", getpid(), shm->execcount,syscallcount);
 shm->exit_now = TRUE;
+}
+
 if (shm->execcount == syscallcount)
 printf(""[%d] Reached maximum syscall count %ld\n"", pid, shm->execcount);
 }
",145,35
"Make the mmap flag selection truly random.

Instead of just 0-N.","
 #include ""arch.h""
 #include ""compat.h""
 
+#define NUM_FLAGS 12
+
 void sanitise_mmap(int childno)
 {
 unsigned int i;
-unsigned int flagvals[12] = { MAP_FIXED, MAP_ANONYMOUS,
+unsigned int flagvals[NUM_FLAGS] = { MAP_FIXED, MAP_ANONYMOUS,
  MAP_GROWSDOWN, MAP_DENYWRITE, MAP_EXECUTABLE, MAP_LOCKED,
  MAP_NORESERVE, MAP_POPULATE, MAP_NONBLOCK, MAP_STACK,
  MAP_HUGETLB, MAP_UNINITIALIZED };
-unsigned int numflags = rand() % 12;
+unsigned int numflags = rand() % NUM_FLAGS;
 
 /* page align addr & len */
 shm->a1[childno] &= PAGE_MASK;
 void sanitise_mmap(int childno)
 
 // set additional flags
 for (i = 0; i < numflags; i++)
-shm->a4[childno] |= flagvals[i];
+shm->a4[childno] |= flagvals[rand() % NUM_FLAGS];
 
 /* no fd if anonymous mapping. */
 if (shm->a4[childno] & MAP_ANONYMOUS)
",54,5
"Don't set a mmap address.

This causes segfaults right now"," void sanitise_mmap(int childno)
  MAP_HUGETLB, MAP_UNINITIALIZED };
 unsigned int numflags = rand() % NUM_FLAGS;
 
-/* page align addr & len */
-shm->a1[childno] &= PAGE_MASK;
+/* Don't actually set a hint right now, in case we give out
+ something that we don't want changed. One day, we'll recycle
+ mappings from mmap results and the like here instead.
+ Right now, ARG_ADDRESS is a bad choice, as it causes page_rand()
+ to be remapped as unwritable/unreadable, and then we segfault */
+shm->a1[childno] = 0;
+
 shm->a2[childno] = page_size;
 if (shm->a2[childno] == 0)
 shm->a2[childno] = page_size;
",54,5
remove open coded ARG_NON_NULL_ADDRESS implementation,"
 
 void sanitise_munmap(int childno)
 {
-retry:
-if (shm->a1[childno] == 0) {
-shm->a1[childno] = (unsigned long) get_address();
-goto retry;
-}
-
 shm->a2[childno] = page_size;
 }
 
 struct syscall syscall_munmap = {
 .name = ""munmap"",
 .num_args = 2,
 .arg1name = ""addr"",
-.arg1type = ARG_ADDRESS,
+.arg1type = ARG_NON_NULL_ADDRESS,
 .arg2name = ""len"",
 .arg2type = ARG_LEN,
 .group = GROUP_VM,
",17,1
disable munmap for now," args_done:
 #endif
 ret = do_syscall(childno);
 
+
+page_rand[0] = rand();
+
+
 sptr = string;
 
 if (ret < 0) {
",150,19
remove some debug code that accidentally got committed.," args_done:
 #endif
 ret = do_syscall(childno);
 
-
-page_rand[0] = rand();
-
-
 sptr = string;
 
 if (ret < 0) {
",149,19
Remove open-coded find_pid_slot," int child_process(void)
 
 disable_coredumps();
 
-for (cpu = 0; cpu < shm->nr_childs; cpu++) {
-if (shm->pids[cpu] == pid)
-break;
-}
+cpu = find_pid_slot(pid);
 
 if (sched_getaffinity(pid, sizeof(set), &set) == 0) {
 CPU_ZERO(&set);
",142,33
"add some sanity checking to the shm.

Very rarely, there's a case where we get nonsense pids in the shm.
I've seen it happen twice now, so add some debugging to catch it
so it can be properly debugged.

If you see this happen, attach to a trinity process with gdb,
and print out the values of shm->previous_syscallno, and shm->previous_a[1-6]
Hopefully that will show the syscall that's doing the corrupting."," static void handle_children()
 }
 }
 
+static void check_shm_sanity(void)
+{
+unsigned int i;
+
+for (i = 0; i < shm->nr_childs; i++) {
+if (shm->pids[i] > 65535) {
+output(""Sanity check failed! Found pid %d!\n"", shm->pids[i]);
+shm->exit_now = TRUE;
+sleep(30);
+}
+}
+}
+
 static void main_loop()
 {
 static const char taskname[13]=""trinity-main"";
 static void main_loop()
 
 if (shm->regenerate >= REGENERATION_POINT)
 regenerate();
+
+check_shm_sanity();
+
 }
 while (!(pidmap_empty()))
 handle_children();
",271,65
"add another sanity check

Another rare bug. Hopefully with debugging info I can figure out what happened
prior to the fds disappearing."," static int get_random_fd(void)
 
 switch (i) {
 case 0:
-retry:fd = shm->fds[rand() % fd_idx];
+retry:
+if (fd_idx == 0) {
+i = find_pid_slot(getpid());
+output(""[%d] wtf, no fds! Last syscall was %d\n"",
+getpid(), shm->previous_syscallno[i]);
+shm->exit_now = TRUE;
+return -1;
+}
+
+fd = shm->fds[rand() % fd_idx];
 
 /* avoid stdin/stdout/stderr */
 if (logging == FALSE)
",118,21
change exit_now from a boolean into an enum so we can track the reason we exited.," int child_process(void)
 
 if (count_enabled_syscalls() == 0) {
 output(""[%d] No more syscalls enabled. Exiting\n"", getpid());
-shm->exit_now = TRUE;
+shm->exit_now = EXIT_NO_SYSCALLS_ENABLED;
 }
 
 retry:
-if (shm->exit_now == TRUE)
+if (shm->exit_now != EXIT_FALSE)
 goto out;
 
 syscallnr = rand() % max_nr_syscalls;
 retry:
 if (syscallcount) {
 if (shm->execcount >= syscallcount) {
 output(""[%d] shm->execcount (%d) >= syscallcount (%d)\n"", getpid(), shm->execcount,syscallcount);
-shm->exit_now = TRUE;
+shm->exit_now = EXIT_REACHED_COUNT;
 }
 
 if (shm->execcount == syscallcount)
",142,33
rename exit_now -> exit_reason," int child_process(void)
 
 ret = 0;
 
-while (shm->exit_now == FALSE) {
+while (shm->exit_reason == FALSE) {
 
 while (shm->regenerating == TRUE)
 sleep(1);
 int child_process(void)
 
 if (count_enabled_syscalls() == 0) {
 output(""[%d] No more syscalls enabled. Exiting\n"", getpid());
-shm->exit_now = EXIT_NO_SYSCALLS_ENABLED;
+shm->exit_reason = EXIT_NO_SYSCALLS_ENABLED;
 }
 
 retry:
-if (shm->exit_now != EXIT_FALSE)
+if (shm->exit_reason != EXIT_FALSE)
 goto out;
 
 syscallnr = rand() % max_nr_syscalls;
 retry:
 if (syscallcount) {
 if (shm->execcount >= syscallcount) {
 output(""[%d] shm->execcount (%d) >= syscallcount (%d)\n"", getpid(), shm->execcount,syscallcount);
-shm->exit_now = EXIT_REACHED_COUNT;
+shm->exit_reason = EXIT_REACHED_COUNT;
 }
 
 if (shm->execcount == syscallcount)
",142,33
rename EXIT_FALSE -> STILL_RUNNING," int child_process(void)
 }
 
 retry:
-if (shm->exit_reason != EXIT_FALSE)
+if (shm->exit_reason != STILL_RUNNING)
 goto out;
 
 syscallnr = rand() % max_nr_syscalls;
",142,33
"add a missing define conversion (harmless, but now wrong)"," int child_process(void)
 
 ret = 0;
 
-while (shm->exit_reason == FALSE) {
+while (shm->exit_reason == STILL_RUNNING) {
 
 while (shm->regenerating == TRUE)
 sleep(1);
",142,33
"oops, fix some compilation errors as a result of the last few changes."," retry:
 newsize >>= 1;
 if (newsize == 0)// FIXME: Need a better way to indicate ""we're fucked"".
 return;
-if (shm->exit_now == TRUE)
+if (shm->exit_reason != STILL_RUNNING)
 return;
 goto retry;
 }
",43,7
invalidate the cached fd in the shm when we regenerate fd's," void close_files()
 unsigned int i;
 int fd;
 
+shm->current_fd = 0;
+shm->fd_lifetime = 0;
+
 for (i = 0; i < fd_idx; i++) {
 fd = shm->fds[i];
 shm->fds[i] = 0;
",195,52
allocate a guard page after our zero page mappings.," static void * _get_address(unsigned char null_allowed)
 break;
 }
 
+/*
+ * Most of the time, we just return the address we got above unmunged.
+ * But sometimes, we return an address just before the end of the page.
+ * The idea here is that we might see some bugs that are caused by page boundary failures.
+ */
 i = rand() % 100;
 switch (i) {
 case 0:return addr + (page_size - sizeof(char));
",492,183
rename socks -> nr_sockets," retry:
 break;
 
 case 1:
-fd = shm->socket_fds[rand() % socks];
+fd = shm->socket_fds[rand() % nr_sockets];
 break;
 
 case 2:
",118,21
rename nr_childs -> max_children," retry:
 
 /* get highest logfile fd if logging is enabled */
 else {
-file = shm->logfiles[shm->nr_childs-1];
+file = shm->logfiles[shm->max_children - 1];
 if (file == NULL) {
 printf(""## WTF, logfile was null!\n"");
 printf(""## logfiles: "");
-for (i = 0; i < shm->nr_childs; i++)
+for (i = 0; i < shm->max_children; i++)
 printf(""%p "", shm->logfiles[i]);
 printf(""\n"");
 exit(EXIT_FAILURE);
",118,21
"Move the shm sanity check to the watchdog

It seems to make more sense to do this there instead."," static void handle_children()
 }
 }
 
-static void check_shm_sanity(void)
-{
-unsigned int i;
-
-for (i = 0; i < shm->max_children; i++) {
-if (shm->pids[i] > 65535) {
-output(""Sanity check failed! Found pid %d!\n"", shm->pids[i]);
-shm->exit_reason = EXIT_PID_OUT_OF_RANGE;
-sleep(30);
-}
-}
-}
-
 static void main_loop()
 {
 static const char taskname[13]=""trinity-main"";
 static void main_loop()
 
 if (shm->regenerate >= REGENERATION_POINT)
 regenerate();
-
-check_shm_sanity();
-
 }
 while (!(pidmap_empty()))
 handle_children();
",259,62
"move the make-it-fail flag to the shm

Saves us rechecking it every time we fork a new child"," static void reenable_coredumps()
 }
 static void set_make_it_fail()
 {
-static char failed = FALSE;
 int fd;
 const char *buf = ""1"";
 
 /* If we failed last time, don't bother trying in future. */
-if (failed == TRUE)
+if (shm->do_make_it_fail == TRUE)
 return;
 
 fd = open(""/proc/self/make-it-fail"", O_WRONLY);
 static void set_make_it_fail()
 if (errno != EPERM)
 printf(""writing to /proc/self/make-it-fail failed! (%s)\n"", strerror(errno));
 else
-failed = TRUE;
+shm->do_make_it_fail = TRUE;
 }
 close(fd);
 }
",141,33
Fix dumb bug in logfile number searching.," static FILE * find_logfile_handle()
 return shm->logfiles[i];
 else {
 /* try one more time. FIXME: This is awful. */
-printf(""[%d] ## Couldn't find logfile for pid %d. Retrying.\n"", getpid(), pid);
 sleep(1);
 i = find_pid_slot(pid);
-if (i != 1)
+if (i != -1)
 return shm->logfiles[i];
 
 printf(""[%d] ## Couldn't find logfile for pid %d\n"", getpid(), pid);
",133,27
remove unnecessary variable.," int child_process(void)
 pid_t pid = getpid();
 int ret;
 unsigned int syscallnr;
-unsigned int cpu;
 unsigned int childno = find_pid_slot(pid);
 
 disable_coredumps();
 
-cpu = find_pid_slot(pid);
-
 if (sched_getaffinity(pid, sizeof(set), &set) == 0) {
 CPU_ZERO(&set);
-CPU_SET(cpu, &set);
+CPU_SET(childno, &set);
 sched_setaffinity(getpid(), sizeof(set), &set);
-output(""bound child %d to cpu %d\n"", pid, cpu);
+output(""bound child %d to cpu %d\n"", pid, childno);
 }
 
 init_child();
",139,33
introduce a define for the 'pidslot not found' result.," static FILE * find_logfile_handle()
 return parentlogfile;
 
 i = find_pid_slot(pid);
-if (i != -1)
+if (i != NO_PIDSLOT)
 return shm->logfiles[i];
 else {
 /* try one more time. FIXME: This is awful. */
 sleep(1);
 i = find_pid_slot(pid);
-if (i != -1)
+if (i != NO_PIDSLOT)
 return shm->logfiles[i];
 
 printf(""[%d] ## Couldn't find logfile for pid %d\n"", getpid(), pid);
",133,27
introduce a bool type.," unsigned int pathname_idx = 0;
 
 #define FD_LIKELYHOOD 5000
 
-static int add_fd(unsigned int chance, const char *pathname, int flags, unsigned char is_dir)
+static int add_fd(unsigned int chance, const char *pathname, int flags, bool is_dir)
 {
 int fd = -1;
 DIR *d = NULL;
 void open_fds(const char *dir, unsigned char add_all)
 unsigned int chance = 0;
 int set_read;
 int set_write;
-unsigned char is_dir = FALSE;
+bool is_dir = FALSE;
 
 
 if (!d) {
",195,52
add argument to specify number of child processes," static int create_shm()
 shm->execcount = 1;
 shm->regenerate = 0;
 
-shm->max_children = sysconf(_SC_NPROCESSORS_ONLN);
+if (user_specified_children != 0)
+shm->max_children = user_specified_children;
+else
+shm->max_children = sysconf(_SC_NPROCESSORS_ONLN);
+
 if (shm->max_children > MAX_NR_CHILDREN) {
 printf(""Increase MAX_NR_CHILDREN!\n"");
 exit(EXIT_FAILURE);
",256,47
remove unused 'retries' from shm.," int main(int argc, char* argv[])
 
 do_main_loop();
 
-printf(""\nRan %ld syscalls (%ld retries). Successes: %ld Failures: %ld\n"",
-shm->execcount - 1, shm->retries, shm->successes, shm->failures);
+printf(""\nRan %ld syscalls. Successes: %ld Failures: %ld\n"",
+shm->execcount - 1, shm->successes, shm->failures);
 
 ret = EXIT_SUCCESS;
 
",256,47
Do possible regeneration before handling child processes.," static void main_loop()
 if (shm->running_childs < shm->max_children)
 fork_children();
 
-handle_children();
-
 if (shm->regenerate >= REGENERATION_POINT)
 regenerate();
+
+handle_children();
 }
 while (!(pidmap_empty()))
 handle_children();
",259,62
"clean up some pid handling.

'0' is no longer a valid pidslot state"," static FILE * find_logfile_handle()
 return parentlogfile;
 
 i = find_pid_slot(pid);
-if (i != NO_PIDSLOT)
+if (i != PIDSLOT_NOT_FOUND)
 return shm->logfiles[i];
 else {
 /* try one more time. FIXME: This is awful. */
 sleep(1);
 i = find_pid_slot(pid);
-if (i != NO_PIDSLOT)
+if (i != PIDSLOT_NOT_FOUND)
 return shm->logfiles[i];
 
 printf(""[%d] ## Couldn't find logfile for pid %d\n"", getpid(), pid);
",133,27
"clear any potential SO_LINGER on sockets, so we don't hang in close on exit."," int main(int argc, char* argv[])
 
 cleanup_fds:
 
-for (i = 0; i < nr_sockets; i++)
+for (i = 0; i < nr_sockets; i++) {
+struct linger ling;
+
+ling.l_onoff = FALSE;/* linger active */
+setsockopt(shm->socket_fds[i], SOL_SOCKET, SO_LINGER, &ling, sizeof(struct linger));
+shutdown(shm->socket_fds[i], SHUT_RDWR);
 close(shm->socket_fds[i]);
+}
 
 destroy_maps();
 
",261,47
"Remove another check for 0 pid.

No longer possible."," static void handle_children()
 
 pid = shm->pids[i];
 
-if (pid == 0)
-continue;
 if (pid == -1)
 continue;
 
",255,60
Use define instead of -1," static void handle_children()
 
 pid = shm->pids[i];
 
-if (pid == -1)
+if (pid == EMPTY_PIDSLOT)
 continue;
 
 pid = waitpid(pid, &childstatus, WUNTRACED | WCONTINUED | WNOHANG);
",255,60
This sleep should no longer be necessary.," static void handle_children()
 pid = waitpid(pid, &childstatus, WUNTRACED | WCONTINUED | WNOHANG);
 if (pid != 0)
 handle_child(pid, childstatus);
-
-sleep(0.1);/* Give other children a chance to do something. */
 }
 }
 
",254,60
"Factor out the pidmap sanity check

And call it when we're in handle_children as well as from the watchdog.

This should fix a rare bug where we corrupt the pidmap just after reaching
the maximum syscall count, and get stuck because pidmap_empty() never returns TRUE."," void dump_pid_slots(void)
 printf(""## slot%d: %d\n"", i, shm->pids[i]);
 }
 
+int pid_is_valid(pid_t pid)
+{
+if ((pid > 65535) || (pid < 1)) {
+output(""Sanity check failed! Found pid %d!\n"", pid);
+return FALSE;
+}
+
+return TRUE;
+}
+
 #define debugf if (debug == TRUE) printf
 
 static void fork_children()
 static void handle_children()
 if (pid == EMPTY_PIDSLOT)
 continue;
 
+if (pid_is_valid(pid) == FALSE)
+return;
+
 pid = waitpid(pid, &childstatus, WUNTRACED | WCONTINUED | WNOHANG);
 if (pid != 0)
 handle_child(pid, childstatus);
",264,64
move the pid handling code to its own file.," int check_tainted(void)
 return ret;
 }
 
-int find_pid_slot(pid_t mypid)
-{
-unsigned int i;
-
-for (i = 0; i < shm->max_children; i++) {
-if (shm->pids[i] == mypid)
-return i;
-}
-return PIDSLOT_NOT_FOUND;
-}
-
-static bool pidmap_empty(void)
-{
-unsigned int i;
-
-for (i = 0; i < shm->max_children; i++) {
-if (shm->pids[i] != EMPTY_PIDSLOT)
-return FALSE;
-}
-return TRUE;
-}
-
-void dump_pid_slots(void)
-{
-unsigned int i;
-
-printf(""## pids:\n"");
-
-for (i = 0; i < shm->max_children; i++)
-printf(""## slot%d: %d\n"", i, shm->pids[i]);
-}
-
-int pid_is_valid(pid_t pid)
-{
-if ((pid > 65535) || (pid < 1)) {
-output(""Sanity check failed! Found pid %d!\n"", pid);
-return FALSE;
-}
-
-return TRUE;
-}
-
 #define debugf if (debug == TRUE) printf
 
 static void fork_children()
",231,53
decode the exit reasons.," static void handle_children()
 }
 }
 
+static const char * decode_exit(unsigned int reason)
+{
+const char *reasons[] = {
+""Still running"",
+""No more syscalls enabled"",
+""Reached maximum syscall count"",
+""No file descriptors open"",
+""Lost track of a pid slot"",
+""shm corruption - Found a pid out of range."",
+""ctrl-c"",
+""kernel became tainted"",
+};
+
+return reasons[reason];
+}
+
 static void main_loop()
 {
 static const char taskname[13]=""trinity-main"";
 static void main_loop()
 while (pidmap_empty() == FALSE)
 handle_children();
 
-printf(""[%d] Bailing main loop. Exit reason: %d\n"", getpid(), shm->exit_reason);
+printf(""[%d] Bailing main loop. Exit reason: %s\n"", getpid(), decode_exit(shm->exit_reason));
 _exit(EXIT_SUCCESS);
 }
 
",245,54
"remove more 'pid == 0' leftovers, and replace -1 uses with PIDSLOT_EMPTY"," static void check_children(void)
 for (i = 0; i < shm->max_children; i++) {
 pid = shm->pids[i];
 
-if ((pid == 0) || (pid == -1))
+if (pid == EMPTY_PIDSLOT)
 continue;
 
 /* first things first, does the pid still exist ? */
 corrupt:
 for (i = 0; i < shm->max_children; i++) {
 pid_t pid;
 pid = shm->pids[i];
-if (pid == 0)
-continue;
-if (pid == -1)
+if (pid == EMPTY_PIDSLOT)
 continue;
 kill(pid, SIGKILL);
 }
",142,33
constify protocols list," struct protocol {
 unsigned int proto;
 };
 
-static struct protocol protocols[] = {
+static const struct protocol protocols[] = {
 { ""PF_UNSPEC"", 0 },
 { ""PF_LOCAL"", 1 },
 { ""PF_UNIX"", PF_LOCAL },
 static struct protocol protocols[] = {
 void find_specific_proto(char *protoarg)
 {
 unsigned int i;
-struct protocol *p = protocols;
+const struct protocol *p = protocols;
 
 if (specific_proto == 0) {
 /* we were passed a string */
",246,35
"kill that warning

(this is WIP anyway)","
 static void sanitise_modify_ldt(int childno)
 {
 void *ldt;
-struct user_desc *desc;
+//struct user_desc *desc;
 
 switch (shm->a1[childno]) {
 case 0:
",34,4
"make the main loop sleep when idle.

Similar to what was removed in ad27756bef82bb2cb83771697c825d3921676963,
but a level up the stack, where we have better visibility into what
we're currently doing."," static void main_loop()
 regenerate();
 
 handle_children();
+
+sleep(1);// Nothing left to do, sleep a while.
 }
 while (pidmap_empty() == FALSE)
 handle_children();
",246,54
"don't reseed children before we've waited for our pid to show up in the pidmap

This occasionally led to spew about being unable to find our logfile,
as the reseed code does an output()"," static void fork_children()
 sprintf(childname, ""trinity-child%d"", pidslot);
 prctl(PR_SET_NAME, (unsigned long) &childname);
 
-set_seed(pidslot);
-
 /* Wait for parent to set our pidslot */
 while (shm->pids[pidslot] != getpid());
 
+set_seed(pidslot);
+
 ret = child_process();
 
 output(""child %d exitting\n"", getpid());
",246,54
"remove unnecessary allocation.

This caused NR_CPUs*64 bytes to be leaked"," void open_logfiles()
 }
 
 for (i = 0; i < shm->max_children; i++) {
-logfilename = malloc(64);
 sprintf(logfilename, ""trinity-%d-child%d.log"", shm->parentpid, i);
 unlink(logfilename);
 shm->logfiles[i] = fopen(logfilename, ""a"");
",132,27
"MIPS arch support for Trinity

This is my first attempt to port Trinity System call fuzz tester to MIPS
architecture (I am using a qemu emulation of MIPS - Malta).

Compilation using Codesourcery MIPS Toolchain worked fine and I was able
to run ""Trinity"" on the emulated MIPS platform.

The ""syscalls-mips.h"" was derived from
""arch/mips/kernel/scall32-o32.S"" of 3.6.0-rc7 kernel. I have commented
out some mips specific system calls like ""cacheflush"" as support for
these system calls can be added to Trinity at a later stage.

Signed-off-by: Maxin B. John <maxin.john@gmail.com>"," void setup_syscall_tables(void)
 #elif defined(__arm__)
 syscalls = syscalls_arm;
 max_nr_syscalls = NR_ARM_SYSCALLS;
+#elif defined(__mips__)
+syscalls = syscalls_mips;
+max_nr_syscalls = NR_MIPS_SYSCALLS;
 #else
 syscalls = syscalls_i386;
 #endif
",323,90
support architectures with a non-zero syscall base in a cleaner way.," args_done:
 sleep(1);
 }
 
-/* IA64 is retarde^Wspecial. */
-#ifdef __ia64__
-call += 1024;
-#endif
+/* Some architectures (IA64/MIPS) start their Linux syscalls
+ * At non-zero, and have other ABIs below.
+ */
+call += SYSCALL_OFFSET;
+
 ret = do_syscall(childno);
 
 sptr = string;
",149,18
"modify_ldt is x86 only.

ugly fix for now, until I have a better way to deal with per-arch syscalls","
+#ifdef X86
 /*
 * asmlinkage int sys_modify_ldt(int func, void __user *ptr, unsigned long bytecount)
 */
 struct syscall syscall_modify_ldt = {
 .arg2name = ""ptr"",
 .arg3name = ""bytecount"",
 };
+#endif
",34,4
"Remove powerpc/sync_file_range2.c

1. It's not ppc specific. ARM also uses this.
2. As it's identical to sync_file_range, but with different arg order,
 it can use the same sanitise routine."," struct syscall syscall_sync_file_range = {
 },
 };
 
+/*
+ * ARM & PowerPC have different argument order.
+ * See edd5cd4a9424f22b0fa08bef5e299d41befd5622 in kernel tree.
+ */
 struct syscall syscall_sync_file_range2 = {
 .name = ""sync_file_range2"",
 .num_args = 4,
",63,4
"a basic sanitise routine for connect()

Based on Eric Dumazet's reproducer for the SO_KEEPALIVE/Raw socket bug.","
 * If the connection or binding succeeds, zero is returned.
 * On error, -1 is returned, and errno is set appropriately.
 */
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <stdlib.h>
 #include ""trinity.h""
 #include ""sanitise.h""
+#include ""shm.h""
+
+static void sanitise_connect(int childno)
+{
+struct sockaddr_in *addr;
+
+addr = malloc(sizeof(struct sockaddr_in));
+if (addr == NULL)
+return;
+
+//TODO: Support more families
+addr->sin_family = AF_INET;
+addr->sin_addr.s_addr = htonl(0x7f000001);
+addr->sin_port = rand() % 65535;
+shm->a2[childno] = (unsigned long) addr;
+shm->a3[childno] = sizeof(struct sockaddr_in);
+}
 
 struct syscall syscall_connect = {
 .name = ""connect"",
 struct syscall syscall_connect = {
 .arg3name = ""addrlen"",
 .arg3type = ARG_LEN,
 .rettype = RET_ZERO_SUCCESS,
+.sanitise = sanitise_connect,
 };
",31,2
"Add a check for potential shm corruption.

This gets triggered occasionally. Still chasing it."," static int check_shm_sanity(void)
 return SHM_CORRUPT;
 }
 }
+
+if (shm->execcount - shm->previous_count > 100000) {
+output(""Execcount increased dramatically! (old:%ld new:%ld):\n"",
+shm->previous_count, shm->execcount);
+shm->exit_reason = EXIT_SHM_CORRUPTION;
+}
+shm->previous_count = shm->execcount;
+
 return SHM_OK;
 }
 
",148,34
"Switch from SYSV shm to shared mmap.

Because Android doesn't implement SYSV SHM.

Based on a patch from Feng Zou <jef.zou@gmail.com>","
 #include <sys/wait.h>
 #include <sys/syscall.h>
 #include <sys/ipc.h>
-#include <sys/shm.h>
+#include <sys/mman.h>
 #include <sys/socket.h>
 
 #include ""arch.h""
 static void mask_signals(void)
 
 static int create_shm()
 {
-int shmid;
-key_t key;
-struct shmid_ds shmid_ds;
-
-key = IPC_PRIVATE;
-if ((shmid = shmget(key, sizeof(struct shm_s), IPC_CREAT | 0666)) < 0) {
-perror(""shmget"");
-return -1;
-}
-if ((shm = shmat(shmid, NULL, 0)) == (void *) -1) {
-perror(""shmat"");
+shm = mmap(NULL, sizeof(struct shm_s), PROT_READ | PROT_WRITE, MAP_ANON | MAP_SHARED, -1, 0);
+if (shm == MAP_FAILED) {
+perror(""mmap"");
 return -1;
 }
-shmctl(key, IPC_RMID, &shmid_ds);
 
 memset(shm, 0, sizeof(struct shm_s));
 
 cleanup_fds:
 
 cleanup_shm:
 
-shmdt(shm);
+if (shm != NULL)
+munmap(shm, sizeof(struct shm_s));
 
 exit(ret);
 }
",254,47
Add X25 support to connect sanitise,"
 #include <sys/socket.h>
 #include <sys/un.h>
 #include <netinet/in.h>
+#include <linux/x25.h>
 #include <stdlib.h>
 #include ""trinity.h""
 #include ""sanitise.h""
 static void sanitise_connect(int childno)
 struct sockaddr_in *ipv4;
 struct sockaddr_in6 *ipv6;
 struct sockaddr_un *unixsock;
+struct sockaddr_x25 *x25;
 unsigned int len;
 unsigned int pf;
 
 static void sanitise_connect(int childno)
 break;
 
 case AF_X25:
-
+x25 = malloc(sizeof(struct sockaddr_x25));
+if (x25 == NULL)
+return;
+
+x25->sx25_family = AF_X25;
+len = rand() % 15;
+memset(&page_rand[len], 0, 1);
+strncpy(x25->sx25_addr.x25_addr, page_rand, len);
 break;
+
 case AF_NETLINK:
 break;
 case AF_APPLETALK:
",84,12
netlink socket support for connect sanitise,"
 #include <sys/un.h>
 #include <netinet/in.h>
 #include <linux/x25.h>
+#include <linux/netlink.h>
 #include <stdlib.h>
 #include ""trinity.h""
 #include ""sanitise.h""
 static void sanitise_connect(int childno)
 struct sockaddr_in6 *ipv6;
 struct sockaddr_un *unixsock;
 struct sockaddr_x25 *x25;
+struct sockaddr_nl *nl;
 unsigned int len;
 unsigned int pf;
 
 static void sanitise_connect(int childno)
 break;
 
 case AF_NETLINK:
+nl = malloc(sizeof(struct sockaddr_nl));
+if (nl == NULL)
+return;
+
+nl->nl_family = AF_NETLINK;
+nl->nl_pid = rand();
+nl->nl_groups = rand();
 break;
+
 case AF_APPLETALK:
 break;
 case AF_NFC:
",92,13
initial NFC support for connect sanitise,"
 #include <netinet/in.h>
 #include <linux/x25.h>
 #include <linux/netlink.h>
+#include <linux/nfc.h>
 #include <stdlib.h>
 #include ""trinity.h""
 #include ""sanitise.h""
 static void sanitise_connect(int childno)
 struct sockaddr_un *unixsock;
 struct sockaddr_x25 *x25;
 struct sockaddr_nl *nl;
+struct sockaddr_nfc *nfc;
 unsigned int len;
 unsigned int pf;
 
 static void sanitise_connect(int childno)
 nl->nl_groups = rand();
 break;
 
-case AF_APPLETALK:
-break;
 case AF_NFC:
+// TODO: See also sockaddr_nfc_llcp
+nfc = malloc(sizeof(struct sockaddr_nfc));
+if (nfc == NULL)
+return;
+
+nfc->sa_family = AF_NFC;
+nfc->dev_idx = rand();
+nfc->target_idx = rand();
+nfc->nfc_protocol = rand() % 5;
 break;
 
 //TODO: Support more families
",99,13
add some missing register setting.," static void sanitise_connect(int childno)
 len = rand() % 15;
 memset(&page_rand[len], 0, 1);
 strncpy(x25->sx25_addr.x25_addr, page_rand, len);
+shm->a2[childno] = (unsigned long) x25;
+shm->a3[childno] = sizeof(struct sockaddr_x25);
 break;
 
-
 case PF_INET6:
 ipv6 = malloc(sizeof(struct sockaddr_in6));
 if (ipv6 == NULL)
 static void sanitise_connect(int childno)
 nl->nl_family = PF_NETLINK;
 nl->nl_pid = rand();
 nl->nl_groups = rand();
+shm->a2[childno] = (unsigned long) nl;
+shm->a3[childno] = sizeof(struct sockaddr_nl);
 break;
 
 case PF_PACKET:
 static void sanitise_connect(int childno)
 nfc->dev_idx = rand();
 nfc->target_idx = rand();
 nfc->nfc_protocol = rand() % 5;
+shm->a2[childno] = (unsigned long) nfc;
+shm->a3[childno] = sizeof(struct sockaddr_nfc);
 break;
 
 default:
",169,45
PF_AX25 support for connect sanitise,"
 #include <sys/un.h>
 #include <netinet/in.h>
 #include <linux/x25.h>
+#include <linux/ax25.h>
 #include <linux/netlink.h>
 #include <linux/nfc.h>
 #include <stdlib.h>

 
 static void sanitise_connect(int childno)
 {
-struct sockaddr_in *ipv4;
-struct sockaddr_in6 *ipv6;
 struct sockaddr_un *unixsock;
+struct sockaddr_in *ipv4;
 struct sockaddr_x25 *x25;
+struct sockaddr_in6 *ipv6;
+struct sockaddr_ax25 *ax25;
 struct sockaddr_nl *nl;
 struct sockaddr_nfc *nfc;
 unsigned int len;
 static void sanitise_connect(int childno)
 break;
 
 case PF_AX25:
-//TODO
+ax25 = malloc(sizeof(struct sockaddr_ax25));
+if (ax25 == NULL)
+return;
+
+ax25->sax25_family = PF_AX25;
+len = rand() % 7;
+memset(&page_rand[len], 0, 1);
+strncpy(ax25->sax25_call.ax25_call, page_rand, len);
+ax25->sax25_ndigis = rand();
+shm->a2[childno] = (unsigned long) ax25;
+shm->a3[childno] = sizeof(struct sockaddr_ax25);
 break;
 
 case PF_IPX:
",181,46
IPX support for connect sanitise,"
 #include <netinet/in.h>
 #include <linux/x25.h>
 #include <linux/ax25.h>
+#include <linux/ipx.h>
 #include <linux/netlink.h>
 #include <linux/nfc.h>
 #include <stdlib.h>
 static void sanitise_connect(int childno)
 struct sockaddr_x25 *x25;
 struct sockaddr_in6 *ipv6;
 struct sockaddr_ax25 *ax25;
+struct sockaddr_ipx *ipx;
 struct sockaddr_nl *nl;
 struct sockaddr_nfc *nfc;
 unsigned int len;
 unsigned int pf;
+unsigned int i;
 
 pf = rand() % PF_MAX;
 
 static void sanitise_connect(int childno)
 break;
 
 case PF_IPX:
-//TODO
+ipx = malloc(sizeof(struct sockaddr_ipx));
+if (ipx == NULL)
+return;
+
+ipx->sipx_family = PF_AX25;
+ipx->sipx_port = rand();
+ipx->sipx_network = rand();
+for (i = 0; i < 6; i++)
+ipx->sipx_node[i] = rand();
+ipx->sipx_type = rand();
+ipx->sipx_zero = rand() % 2;
+shm->a2[childno] = (unsigned long) ipx;
+shm->a3[childno] = sizeof(struct sockaddr_ipx);
 break;
 
 case PF_APPLETALK:
",196,48
PF_APPLETALK support for connect sanitise,"
 #include <linux/x25.h>
 #include <linux/ax25.h>
 #include <linux/ipx.h>
+#include <linux/atalk.h>
 #include <linux/netlink.h>
 #include <linux/nfc.h>
 #include <stdlib.h>
 static void sanitise_connect(int childno)
 struct sockaddr_in6 *ipv6;
 struct sockaddr_ax25 *ax25;
 struct sockaddr_ipx *ipx;
+struct sockaddr_at *atalk;
 struct sockaddr_nl *nl;
 struct sockaddr_nfc *nfc;
 unsigned int len;
 static void sanitise_connect(int childno)
 break;
 
 case PF_APPLETALK:
-//TODO
+atalk = malloc(sizeof(struct sockaddr_at));
+if (atalk == NULL)
+return;
+
+atalk->sat_family = PF_APPLETALK;
+atalk->sat_port = rand();
+atalk->sat_addr.s_net = rand();
+atalk->sat_addr.s_node = rand();
+shm->a2[childno] = (unsigned long) atalk;
+shm->a3[childno] = sizeof(struct sockaddr_at);
 break;
 
 case PF_NETROM:
",207,49
PF_ATMPVC support for connect sanitise,"
 #include <linux/ax25.h>
 #include <linux/ipx.h>
 #include <linux/atalk.h>
+#include <linux/atm.h>
 #include <linux/netlink.h>
 #include <linux/nfc.h>
 #include <stdlib.h>
 static void sanitise_connect(int childno)
 struct sockaddr_ax25 *ax25;
 struct sockaddr_ipx *ipx;
 struct sockaddr_at *atalk;
+struct sockaddr_atmpvc *atmpvc;
 struct sockaddr_nl *nl;
 struct sockaddr_nfc *nfc;
 unsigned int len;
 static void sanitise_connect(int childno)
 break;
 
 case PF_ATMPVC:
-//TODO
+atmpvc = malloc(sizeof(struct sockaddr_atmpvc));
+if (atmpvc == NULL)
+return;
+
+atmpvc->sap_family = PF_ATMPVC;
+atmpvc->sap_addr.itf = rand();
+atmpvc->sap_addr.vpi = rand();
+atmpvc->sap_addr.vci = rand();
+shm->a2[childno] = (unsigned long) atmpvc;
+shm->a3[childno] = sizeof(struct sockaddr_atmpvc);
 break;
 
 case PF_X25:
",218,50
This length should always be 7," static void sanitise_connect(int childno)
 return;
 
 ax25->sax25_family = PF_AX25;
-len = rand() % 7;
-memset(&page_rand[len], 0, 1);
-strncpy(ax25->sax25_call.ax25_call, page_rand, len);
+strncpy(ax25->sax25_call.ax25_call, page_rand, 7);
 ax25->sax25_ndigis = rand();
 shm->a2[childno] = (unsigned long) ax25;
 shm->a3[childno] = sizeof(struct sockaddr_ax25);
",233,51
PF_DECNET support for connect sanitise,"
 #include <linux/atalk.h>
 #include <linux/atm.h>
 #include <linux/rose.h>
+#include <linux/dn.h>
 #include <linux/netlink.h>
 #include <linux/nfc.h>
 #include <stdlib.h>
 static void sanitise_connect(int childno)
 struct sockaddr_at *atalk;
 struct sockaddr_atmpvc *atmpvc;
 struct sockaddr_rose *rose;
+struct sockaddr_dn *dn;
 struct sockaddr_nl *nl;
 struct sockaddr_nfc *nfc;
 unsigned int len;
 static void sanitise_connect(int childno)
 break;
 
 case PF_DECnet:
-//TODO
+dn = malloc(sizeof(struct sockaddr_dn));
+if (dn == NULL)
+return;
+
+dn->sdn_family = PF_DECnet;
+dn->sdn_flags = rand();
+dn->sdn_objnum = rand();
+dn->sdn_objnamel = rand() % 16;
+for (i = 0; i < dn->sdn_objnamel; i++)
+dn->sdn_objname[i] = rand();
+dn->sdn_add.a_len = rand() % 2;
+dn->sdn_add.a_addr[0] = rand();
+dn->sdn_add.a_addr[1] = rand();
+shm->a2[childno] = (unsigned long) dn;
+shm->a3[childno] = sizeof(struct sockaddr_dn);
 break;
 
+
 case PF_NETBEUI:
 //TODO
 break;
",249,53
NETBEUI support for connect sanitise,"
 #include <linux/atm.h>
 #include <linux/rose.h>
 #include <linux/dn.h>
+#include <linux/if.h>
+#include <linux/if_arp.h>
+#include <linux/llc.h>
 #include <linux/netlink.h>
 #include <linux/nfc.h>
 #include <stdlib.h>
 static void sanitise_connect(int childno)
 struct sockaddr_atmpvc *atmpvc;
 struct sockaddr_rose *rose;
 struct sockaddr_dn *dn;
+struct sockaddr_llc *llc;
 struct sockaddr_nl *nl;
 struct sockaddr_nfc *nfc;
 unsigned int len;
 static void sanitise_connect(int childno)
 shm->a3[childno] = sizeof(struct sockaddr_dn);
 break;
 
-
 case PF_NETBEUI:
-//TODO
+llc = malloc(sizeof(struct sockaddr_llc));
+if (llc == NULL)
+return;
+llc->sllc_family = AF_LLC;
+llc->sllc_arphrd = ARPHRD_ETHER;
+llc->sllc_test = rand();
+llc->sllc_xid = rand();
+llc->sllc_ua = rand();
+llc->sllc_sap = rand();
+for (i = 0; i < IFHWADDRLEN; i++)
+llc->sllc_mac[i] = rand();
 break;
 
 case PF_SECURITY:
",264,55
PF_PACKET support for connect sanitise,"
 #include <linux/if.h>
 #include <linux/if_arp.h>
 #include <linux/llc.h>
+#include <linux/if_packet.h>
 #include <linux/netlink.h>
 #include <linux/nfc.h>
 #include <stdlib.h>
 static void sanitise_connect(int childno)
 struct sockaddr_rose *rose;
 struct sockaddr_dn *dn;
 struct sockaddr_llc *llc;
+struct sockaddr_pkt *pkt;
 struct sockaddr_nl *nl;
 struct sockaddr_nfc *nfc;
 unsigned int len;
 static void sanitise_connect(int childno)
 break;
 
 case PF_PACKET:
-//TODO
+//TODO: See also sockaddr_ll
+pkt = malloc(sizeof(struct sockaddr_pkt));
+if (pkt == NULL)
+return;
+
+pkt->spkt_family = PF_PACKET;
+for (i = 0; i < 14; i++)
+pkt->spkt_device[i] = rand();
+shm->a2[childno] = (unsigned long) pkt;
+shm->a3[childno] = sizeof(struct sockaddr_pkt);
 break;
 
+
 case PF_ASH:
 //TODO
 break;
",274,57
Add missing register setting," static void sanitise_connect(int childno)
 llc->sllc_sap = rand();
 for (i = 0; i < IFHWADDRLEN; i++)
 llc->sllc_mac[i] = rand();
+shm->a2[childno] = (unsigned long) llc;
+shm->a3[childno] = sizeof(struct sockaddr_llc);
 break;
 
 case PF_SECURITY:
",276,57
ECONET support for connect sanitise,"
 #include <linux/if_arp.h>
 #include <linux/llc.h>
 #include <linux/if_packet.h>
+#include <neteconet/ec.h>
 #include <linux/netlink.h>
 #include <linux/nfc.h>
 #include <stdlib.h>
 static void sanitise_connect(int childno)
 struct sockaddr_dn *dn;
 struct sockaddr_llc *llc;
 struct sockaddr_pkt *pkt;
+struct sockaddr_ec *ec;
 struct sockaddr_nl *nl;
 struct sockaddr_nfc *nfc;
 unsigned int len;
 static void sanitise_connect(int childno)
 shm->a3[childno] = sizeof(struct sockaddr_pkt);
 break;
 
-
 case PF_ASH:
 //TODO
 break;
 
 case PF_ECONET:
-//TODO
+ec = malloc(sizeof(struct sockaddr_ec));
+if (ec == NULL)
+return;
+
+ec->sec_family = PF_ECONET;
+ec->port = rand();
+ec->cb = rand();
+ec->type = rand();
+ec->addr.station = rand();
+ec->addr.net = rand();
+ec->cookie = rand();
+shm->a2[childno] = (unsigned long) ec;
+shm->a3[childno] = sizeof(struct sockaddr_ec);
 break;
 
 case PF_ATMSVC:
",290,58
ATMSVC support for connect sanitise," static void sanitise_connect(int childno)
 struct sockaddr_ipx *ipx;
 struct sockaddr_at *atalk;
 struct sockaddr_atmpvc *atmpvc;
+struct sockaddr_atmsvc *atmsvc;
 struct sockaddr_rose *rose;
 struct sockaddr_dn *dn;
 struct sockaddr_llc *llc;
 static void sanitise_connect(int childno)
 break;
 
 case PF_ATMSVC:
-//TODO
+atmsvc = malloc(sizeof(struct sockaddr_atmsvc));
+if (atmsvc == NULL)
+return;
+
+atmsvc->sas_family = PF_ATMSVC;
+for (i = 0; i < ATM_ESA_LEN; i++)
+atmsvc->sas_addr.prv[i] = rand();
+for (i = 0; i < ATM_E164_LEN; i++)
+atmsvc->sas_addr.pub[i] = rand();
+atmsvc->sas_addr.lij_type = rand();
+atmsvc->sas_addr.lij_id = rand();
+shm->a2[childno] = (unsigned long) atmsvc;
+shm->a3[childno] = sizeof(struct sockaddr_atmsvc);
 break;
 
 case PF_RDS:
",303,61
PF_IRDA support for connect sanitise,"
 #include <linux/llc.h>
 #include <linux/if_packet.h>
 #include <neteconet/ec.h>
+#include <linux/irda.h>
 #include <linux/netlink.h>
 #include <linux/nfc.h>
 #include <stdlib.h>
 static void sanitise_connect(int childno)
 struct sockaddr_llc *llc;
 struct sockaddr_pkt *pkt;
 struct sockaddr_ec *ec;
+struct sockaddr_irda *irda;
 struct sockaddr_nl *nl;
 struct sockaddr_nfc *nfc;
 unsigned int len;
 static void sanitise_connect(int childno)
 break;
 
 case PF_IRDA:
-//TODO
+irda = malloc(sizeof(struct sockaddr_irda));
+if (irda == NULL)
+return;
+
+irda->sir_family = PF_IRDA;
+irda->sir_lsap_sel = rand();
+irda->sir_addr = rand();
+for (i = 0; i < 25; i++)
+irda->sir_name[i] = rand();
+shm->a2[childno] = (unsigned long) irda;
+shm->a3[childno] = sizeof(struct sockaddr_irda);
 break;
 
 case PF_PPPOX:
",315,63
LLC can be the same as NETBEUI for now.," static void sanitise_connect(int childno)
 break;
 
 case PF_LLC:
-//TODO
+llc = malloc(sizeof(struct sockaddr_llc));
+if (llc == NULL)
+return;
+llc->sllc_family = AF_LLC;
+llc->sllc_arphrd = ARPHRD_ETHER;
+llc->sllc_test = rand();
+llc->sllc_xid = rand();
+llc->sllc_ua = rand();
+llc->sllc_sap = rand();
+for (i = 0; i < IFHWADDRLEN; i++)
+llc->sllc_mac[i] = rand();
+shm->a2[childno] = (unsigned long) llc;
+shm->a3[childno] = sizeof(struct sockaddr_llc);
 break;
 
+
 case PF_CAN:
 //TODO
 break;
",343,68
PF_CAN support for connect sanitise,"
 #include <neteconet/ec.h>
 #include <linux/irda.h>
 #include <linux/if_pppox.h>
+#include <linux/can.h>
 #include <linux/netlink.h>
 #include <linux/nfc.h>
 #include <stdlib.h>
 static void sanitise_connect(int childno)
 struct sockaddr_ec *ec;
 struct sockaddr_irda *irda;
 struct sockaddr_pppox *pppox;
+struct sockaddr_can *can;
 struct sockaddr_nl *nl;
 struct sockaddr_nfc *nfc;
 unsigned int len;
 static void sanitise_connect(int childno)
 shm->a3[childno] = sizeof(struct sockaddr_llc);
 break;
 
-
 case PF_CAN:
-//TODO
+can = malloc(sizeof(struct sockaddr_can));
+if (can == NULL)
+return;
+can->can_family = AF_CAN;
+can->can_ifindex = rand();
+can->can_addr.tp.rx_id = rand();
+can->can_addr.tp.tx_id = rand();
+shm->a2[childno] = (unsigned long) can;
+shm->a3[childno] = sizeof(struct sockaddr_can);
 break;
 
 case PF_TIPC:
",354,69
ALG support for connect sanitise,"
 #include <linux/can.h>
 #include <linux/tipc.h>
 #include <linux/caif/caif_socket.h>
+#include <linux/if_alg.h>
 #include <linux/netlink.h>
 #include <linux/nfc.h>
 #include <stdlib.h>
 static void sanitise_connect(int childno)
 struct sockaddr_can *can;
 struct sockaddr_tipc *tipc;
 struct sockaddr_caif *caif;
+struct sockaddr_alg *alg;
 struct sockaddr_nl *nl;
 struct sockaddr_nfc *nfc;
 unsigned int len;
 static void sanitise_connect(int childno)
 break;
 
 case PF_ALG:
-//TODO
+// TODO: See also sockaddr_nfc_llcp
+alg = malloc(sizeof(struct sockaddr_alg));
+if (alg == NULL)
+return;
+
+alg->salg_family = PF_ALG;
+for (i = 0; i < 14; i++)
+alg->salg_type[i] = rand();
+alg->salg_feat = rand();
+alg->salg_mask = rand();
+for (i = 0; i < 64; i++)
+alg->salg_name[i] = rand();
+shm->a2[childno] = (unsigned long) alg;
+shm->a3[childno] = sizeof(struct sockaddr_alg);
 break;
 
 case PF_NFC:
",404,76
PHONET support for connect sanitise,"
 #include <linux/tipc.h>
 #include <linux/caif/caif_socket.h>
 #include <linux/if_alg.h>
+#include <linux/phonet.h>
 #include <linux/netlink.h>
 #include <linux/nfc.h>
 #include <stdlib.h>
 static void sanitise_connect(int childno)
 struct sockaddr_tipc *tipc;
 struct sockaddr_caif *caif;
 struct sockaddr_alg *alg;
+struct sockaddr_pn *pn;
 struct sockaddr_nl *nl;
 struct sockaddr_nfc *nfc;
 unsigned int len;
 static void sanitise_connect(int childno)
 break;
 
 case PF_PHONET:
-//TODO
+pn = malloc(sizeof(struct sockaddr_pn));
+if (pn == NULL)
+return;
+
+pn->spn_family = PF_PHONET;
+pn->spn_obj = rand();
+pn->spn_dev = rand();
+pn->spn_resource = rand();
+shm->a2[childno] = (unsigned long) pn;
+shm->a3[childno] = sizeof(struct sockaddr_pn);
 break;
 
+
 case PF_IEEE802154:
 //TODO
 break;
",415,77
"don't count number of enabled syscalls.

We only care if there are ANY still enabled.
So if we find one, we can stop counting, and just return true."," int child_process(void)
 }
 }
 
-if (count_enabled_syscalls() == 0) {
+if (no_syscalls_enabled() == TRUE) {
 output(""[%d] No more syscalls enabled. Exiting\n"", getpid());
 shm->exit_reason = EXIT_NO_SYSCALLS_ENABLED;
 }
",139,33
support all the variants of PF_PPPOX in connect sanitise," static void close_pipes(void)
 }
 }
 
-static int get_random_fd(void)
+int get_random_fd(void)
 {
 unsigned int i;
 FILE *file;
",118,21
"Add missing string, to decode shm corruption on exit"," static const char * decode_exit(unsigned int reason)
 ""shm corruption - Found a pid out of range."",
 ""ctrl-c"",
 ""kernel became tainted"",
+""SHM was corrupted!\n"",
 };
 
 return reasons[reason];
",247,54
"bump up the execcount corruption detector minimum.

On a really fast machine, it's too easy to hit.
This still might be too low for some machines, hence the FIXME."," static int check_shm_sanity(void)
 }
 }
 
-if (shm->execcount - shm->previous_count > 100000) {
+// FIXME: The '500000' is magic, and should be dynamically calculated.
+// On startup, we should figure out how many getpid()'s per second we can do,
+// and use that.
+if (shm->execcount - shm->previous_count > 500000) {
 output(""Execcount increased dramatically! (old:%ld new:%ld):\n"",
 shm->previous_count, shm->execcount);
 shm->exit_reason = EXIT_SHM_CORRUPTION;
",148,34
lower fd lifetime to number of child processes rather than always 64," int get_fd(void)
 regen:
 if (shm->fd_lifetime == 0) {
 shm->current_fd = get_random_fd();
-shm->fd_lifetime = rand() % MAX_NR_CHILDREN;
+shm->fd_lifetime = rand() % shm->running_childs;
 } else
 shm->fd_lifetime--;
 
",118,21
max children is an even better variable than current running children.," int get_fd(void)
 regen:
 if (shm->fd_lifetime == 0) {
 shm->current_fd = get_random_fd();
-shm->fd_lifetime = rand() % shm->running_childs;
+shm->fd_lifetime = rand() % shm->max_children;
 } else
 shm->fd_lifetime--;
 
",118,21
"don't search the whole pidmap when picking a pid.

Just look at the populated part."," retry:
 BUG(""unreachable!\n"");
 break;
 }
-for (i = 0; i < MAX_NR_CHILDREN; i++) {
+for (i = 0; i < shm->max_children; i++) {
 if (pid == shm->pids[i])
 goto retry;
 }
",516,196
"fix signedness warning

Also add a fixme. Need a coherent story here.

This is why we're randomly seeing tmux getting killed for eg.
Perhaps we should just always return a child pid."," void regenerate_random_page()
 
 unsigned int get_pid(void)
 {
-int i, pid = 0;
+unsigned int i;
+pid_t pid = 0;
+
 retry:
 i = rand() % 2;
 
 retry:
 BUG(""unreachable!\n"");
 break;
 }
+
+/*
+ * Exclude pids of our children, parent, and watchdog.
+ * FIXME: This is at odds with 'getpid' above.
+ */
 for (i = 0; i < shm->max_children; i++) {
 if (pid == shm->pids[i])
 goto retry;
",517,196
"change get_pid to only ever return one of our child pids

(or 0, or 1 if non-root)

sending signals to random processes is a dumb idea.
This probably explains the bug where tmux was getting killed."," unsigned int get_pid(void)
 unsigned int i;
 pid_t pid = 0;
 
-retry:
-i = rand() % 2;
+switch (rand() % 3) {
 
-switch (i) {
-case 0:pid = getpid();
+case 0:i = rand() % shm->running_childs;
+pid = shm->pids[i];
 break;
-case 1:pid = rand() & 32767;
+
+case 1:pid = 0;
 break;
-default:
-BUG(""unreachable!\n"");
+
+case 2:if (dangerous == TRUE)// We don't want root trying to kill init.
+pid = 1;
 break;
-}
 
-/*
- * Exclude pids of our children, parent, and watchdog.
- * FIXME: This is at odds with 'getpid' above.
- */
-for (i = 0; i < shm->max_children; i++) {
-if (pid == shm->pids[i])
-goto retry;
+default:
+break;
 }
-if (pid == shm->parentpid)
-goto retry;
-
-if (pid == shm->watchdog_pid)
-goto retry;
 
 return pid;
 }
",510,194
"Fix seed=0

Every child was doing the same syscall if seed was set to 0"," void set_seed(unsigned int pidslot)
  * This still isn't perfect: When we -s right now, we set all children to the same seed.
  * This sucks if the bug we're trying to reproduce was caused by interaction between threads.
  */
-srand(seed << pidslot);
+srand(seed + pidslot);
 
 if (do_syslog == FALSE)
 return;
",256,48
Handle the case where we get called from the parent while no children around.," unsigned int get_pid(void)
 unsigned int i;
 pid_t pid = 0;
 
-switch (rand() % 3) {
+/* If we get called from the parent, and there are no
+ * children around yet, we need to not look at the pidmap. */
+if (shm->running_childs == 0)
+return 0;
 
+switch (rand() % 3) {
 case 0:i = rand() % shm->running_childs;
 pid = shm->pids[i];
 break;
",512,195
"Look at the whole pidmap when searching for random pid.

Also handle empty pidslots correctly instead of returning -1"," unsigned int get_pid(void)
 return 0;
 
 switch (rand() % 3) {
-case 0:i = rand() % shm->running_childs;
+case 0:
+retry:i = rand() % shm->max_children;
 pid = shm->pids[i];
+if (pid == EMPTY_PIDSLOT)
+goto retry;
 break;
 
 case 1:pid = 0;
",515,196
move get_pid to pids.c," void regenerate_random_page()
 }
 }
 
-unsigned int get_pid(void)
-{
-unsigned int i;
-pid_t pid = 0;
-
-/* If we get called from the parent, and there are no
- * children around yet, we need to not look at the pidmap. */
-if (shm->running_childs == 0)
-return 0;
-
-switch (rand() % 3) {
-case 0:
-retry:i = rand() % shm->max_children;
-pid = shm->pids[i];
-if (pid == EMPTY_PIDSLOT)
-goto retry;
-break;
-
-case 1:pid = 0;
-break;
-
-case 2:if (dangerous == TRUE)// We don't want root trying to kill init.
-pid = 1;
-break;
-
-default:
-break;
-}
-
-return pid;
-}
-
 static unsigned int get_cpu()
 {
 int i;
",492,189
Some debugging code for the bug where the child gets reparented.," int child_process(void)
 int ret;
 unsigned int syscallnr;
 unsigned int childno = find_pid_slot(pid);
+unsigned int i;
 
 disable_coredumps();
 
 int child_process(void)
 
 while (shm->exit_reason == STILL_RUNNING) {
 
+if (getppid() != shm->parentpid) {
+i = find_pid_slot(getpid());
+output(BUGTXT ""CHILD (pid:%d) GOT REPARENTED!\n""
+""Last syscall was %d (call:%d)\n"",
+getpid(), shm->previous_syscallno[i], shm->total_syscalls[i]);
+while(1)
+sleep(5);
+}
+
 while (shm->regenerating == TRUE)
 sleep(1);
 
",148,35
reseed every 10 seconds.," static void main_loop()
 if (shm->regenerate >= REGENERATION_POINT)
 regenerate();
 
+if (shm->need_reseed == TRUE)
+reseed();
+
 handle_children();
 
 sleep(1);// Nothing left to do, sleep a while.
",262,57
Log the seed when we detect we oopsed.," void watchdog(void)
 /* Only check taint if it was zero on startup */
 if (do_check_tainted == FALSE) {
 if (check_tainted() != 0) {
-output(""kernel became tainted!\n"");
+output(""kernel became tainted! Last seed was %d:%x\n"", shm->seed, shm->seed);
 shm->exit_reason = EXIT_KERNEL_TAINTED;
 }
 }
",154,35
"propagate seed changes to child processes.

If the parent reseeds, a long running child may still be using the old seed
for some time."," int child_process(void)
 int ret;
 unsigned int syscallnr;
 unsigned int childno = find_pid_slot(pid);
-unsigned int i;
+unsigned int pidslot;
 
 disable_coredumps();
 
 int child_process(void)
 
 while (shm->exit_reason == STILL_RUNNING) {
 
+pidslot = find_pid_slot(getpid());
+
 if (getppid() != shm->parentpid) {
-i = find_pid_slot(getpid());
 output(BUGTXT ""CHILD (pid:%d) GOT REPARENTED!\n""
 ""Last syscall was %d (call:%d)\n"",
-getpid(), shm->previous_syscallno[i], shm->total_syscalls[i]);
+getpid(), shm->previous_syscallno[pidslot], shm->total_syscalls[pidslot]);
 while(1)
 sleep(5);
 }
 int child_process(void)
 while (shm->regenerating == TRUE)
 sleep(1);
 
+/* If the parent reseeded, we should reflect the latest seed too. */
+if (shm->seed != shm->seeds[pidslot])
+set_seed(pidslot);
+
 if (biarch == TRUE) {
 
 if ((use_64bit == TRUE) && (use_32bit == TRUE)) {
",150,36
"remove pids from log file names.

This just causes way too much clutter."," void open_logfiles()
 char *logfilename;
 
 logfilename = malloc(64);
-sprintf(logfilename, ""trinity-%d.log"", shm->parentpid);
+sprintf(logfilename, ""trinity.log"");
 unlink(logfilename);
 parentlogfile = fopen(logfilename, ""a"");
 if (!parentlogfile) {
 void open_logfiles()
 }
 
 for (i = 0; i < shm->max_children; i++) {
-sprintf(logfilename, ""trinity-%d-child%d.log"", shm->parentpid, i);
+sprintf(logfilename, ""trinity-child%d.log"", i);
 unlink(logfilename);
 shm->logfiles[i] = fopen(logfilename, ""a"");
 if (!shm->logfiles[i]) {
",132,27
remove noisy and pointless output.," int child_process(void)
 CPU_ZERO(&set);
 CPU_SET(childno, &set);
 sched_setaffinity(getpid(), sizeof(set), &set);
-output(""bound child %d to cpu %d\n"", pid, childno);
 }
 
 init_child();
",149,36
"Change how 'quiet' works.

This now allows multiple verbosity levels.

0 = everything, even all the registers
1 = Watchdog prints syscall count
2 = Just the reseed values"," static void open_pipes(void)
 shm->pipe_fds[i] = pipes[0];
 shm->pipe_fds[i+1] = pipes[1];
 
-output(""fd[%d] = pipe\n"", shm->pipe_fds[i]);
-output(""fd[%d] = pipe\n"", shm->pipe_fds[i+1]);
+if (quiet_level == 0) {
+output(""fd[%d] = pipe\n"", shm->pipe_fds[i]);
+output(""fd[%d] = pipe\n"", shm->pipe_fds[i+1]);
+}
 }
 }
 
",120,22
better describe the problem.," args_done:
 if (call == (unsigned int) search_syscall_table(syscalls, max_nr_syscalls, ""futex""))
 goto skip_enosys;
 
-//FIXME: This seems broken, as these syscalls keep getting called.
+// FIXME: Crap, this can't work. We're in the child at this point, and we want to change a global
+// structure in the parent. Will need big changes to how syscall_table's are stored if we have
+// to make those a shared struct.
 
-//output(""%s returned ENOSYS, marking as inactive.\n"", syscalls[call].entry->name);
+//output(""%s returned ENOSYS, marking as inactive.\n"", syscalls[call].entry->name);
 syscalls[call].entry->flags &= ~ACTIVE;
 }
 
",150,20
"move log level into a parameter for output()

The previous change broke logging for child processes.
This isn't 100% the way I want it, but it's a step in the right
direction, and at least gets things working again"," int child_process(void)
 pidslot = find_pid_slot(getpid());
 
 if (getppid() != shm->parentpid) {
-output(BUGTXT ""CHILD (pid:%d) GOT REPARENTED!\n""
+output(0, BUGTXT ""CHILD (pid:%d) GOT REPARENTED!\n""
 ""Last syscall was %d (call:%d)\n"",
 getpid(), shm->previous_syscallno[pidslot], shm->total_syscalls[pidslot]);
 while(1)
 int child_process(void)
 }
 
 if (no_syscalls_enabled() == TRUE) {
-output(""[%d] No more syscalls enabled. Exiting\n"", getpid());
+output(0, ""[%d] No more syscalls enabled. Exiting\n"", getpid());
 shm->exit_reason = EXIT_NO_SYSCALLS_ENABLED;
 }
 
 retry:
 
 if (syscallcount) {
 if (shm->execcount >= syscallcount) {
-output(""[%d] shm->execcount (%d) >= syscallcount (%d)\n"", getpid(), shm->execcount,syscallcount);
+output(0, ""[%d] shm->execcount (%d) >= syscallcount (%d)\n"", getpid(), shm->execcount,syscallcount);
 shm->exit_reason = EXIT_REACHED_COUNT;
 }
 
",149,36
"Avoid using 0 as a pidslot in the seed.

Otherwise, childs 0 & 1 end up with the same seed."," int init_seed(unsigned int seedparam)
 */
 void set_seed(unsigned int pidslot)
 {
-srand(shm->seed + pidslot);
+srand(shm->seed + (pidslot + 1));
 shm->seeds[pidslot] = shm->seed;
 }
 
",48,8
"remove rand64

just use random() in its place."," void * get_non_null_address()
 return _get_address(FALSE);
 }
 
+unsigned long get_reg(void)
+{
+if ((rand() % 2) == 0)
+return random();
 
+return get_interesting_value();
+}
 
 void regenerate_random_page()
 {
 static unsigned long fill_arg(int childno, int call, int argnum)
 if (high == 0)
 printf(""%s forgets to set hirange!\n"", syscalls[call].entry->name);
 
-i = rand64() % high;
+i = random() % high;
 if (i < low) {
 i += low;
 i &= high;
",498,191
move some vars out of trinity.c,"
 #include ""trinity.h""
 #include ""shm.h""
 
+unsigned int seed = 0;
+
 /*
 * If we passed in a seed with -s, use that. Otherwise make one up from time of day.
 */
",50,8
abstract out shared alloc function," char *page_0xff;
 char *page_rand;
 char *page_allocs;
 
+void * alloc_shared(unsigned int size)
+{
+return mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_ANON | MAP_SHARED, -1, 0); 
+}
 
 static struct map * alloc_map()
 {
",134,21
Make syscall structs shared between children," char *page_allocs;
 
 void * alloc_shared(unsigned int size)
 {
-return mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_ANON | MAP_SHARED, -1, 0); 
+void *ret;
+
+ret = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_ANON | MAP_SHARED, -1, 0);
+if (ret == MAP_FAILED)
+return NULL;
+
+return ret;
 }
 
 static struct map * alloc_map()
",138,22
get the pid into the initial seed too," int init_seed(unsigned int seedparam)
 printf(""[%d] Using user passed random seed: %u (0x%x)\n"", getpid(), seedparam, seedparam);
 else {
 gettimeofday(&t, 0);
-seedparam = t.tv_sec * t.tv_usec;
+seedparam = (t.tv_sec * getpid()) | t.tv_usec;
 
 printf(""Initial random seed from time of day: %u (0x%x)\n"", seedparam, seedparam);
 }
",50,8
SOL_IP socket options,"
 #define SOL_CAIF 278
 #define SOL_ALG 279
 
+#define NR_IP_OPTS 19
+
 void sanitise_setsockopt(int childno)
 {
 int level;
+unsigned char bit;
+
+int ip_opts[NR_IP_OPTS] = { IP_TOS, IP_TTL, IP_HDRINCL, IP_OPTIONS,
+IP_ROUTER_ALERT, IP_RECVOPTS, IP_RETOPTS, IP_PKTINFO,
+IP_PKTOPTIONS, IP_MTU_DISCOVER, IP_RECVERR, IP_RECVTTL,
+IP_RECVTOS, IP_MTU, IP_FREEBIND, IP_IPSEC_POLICY,
+IP_XFRM_POLICY, IP_PASSSEC, IP_TRANSPARENT };
+
 
 shm->a4[childno] = (unsigned long) page_rand;
 shm->a5[childno] = sizeof(int);// at the minimum, we want an int (overridden below)
 void sanitise_setsockopt(int childno)
 break;
 
 case SOL_IP:
+bit = rand() % NR_IP_OPTS;
+shm->a3[childno] = 1 << (ip_opts[bit]);
+break;
+
 case SOL_TCP:
 case SOL_UDP:
 case SOL_IPV6:
",152,71
fallback case should just use single bit," void sanitise_setsockopt(int childno)
 case SOL_ALG:
 
 default:
-shm->a3[childno] = rand() % 255;/* random operation. */
+shm->a3[childno] = 1 << (rand() % 16);/* random operation. */
 }
 }
 
",152,71
sometimes disable the option," void sanitise_setsockopt(int childno)
 default:
 shm->a3[childno] = 1 << (rand() % 16);/* random operation. */
 }
+
+/* optval should be nonzero to enable a boolean option, or zero if the option is to be disabled.
+ * Let's disable it half the time.
+ */
+if (rand() % 2)
+shm->a4[childno] = 0;
 }
 
 struct syscall syscall_setsockopt = {
",154,72
fix cut-n-paste screw up," void sanitise_setsockopt(int childno)
 break;
 
 case SOL_IPV6:
-bit = rand() % NR_SOL_IP_OPTS;
-shm->a3[childno] = 1 << (ip_opts[bit]);
+bit = rand() % NR_SOL_IPV6_OPTS;
+shm->a3[childno] = 1 << (ipv6_opts[bit]);
 break;
 
 case SOL_UDPLITE:
",201,78
icmpv6 support for setsockopt,"
 #include <netrom/netrom.h>
 #include <linux/tipc.h>
 #include <linux/filter.h>
+#include <linux/icmpv6.h>
 
 #include ""trinity.h""
 #include ""sanitise.h""
 static int ipv6_opts[NR_SOL_IPV6_OPTS] = {
 IPV6_DROP_MEMBERSHIP, IPV6_ROUTER_ALERT, IPV6_MTU_DISCOVER, IPV6_MTU,
 IPV6_RECVERR, IPV6_V6ONLY, IPV6_JOIN_ANYCAST, IPV6_LEAVE_ANYCAST };
 
+#define NR_SOL_ICMPV6_OPTS 1
+static int icmpv6_opts[NR_SOL_ICMPV6_OPTS] = { ICMPV6_FILTER };
 
 void sanitise_setsockopt(int childno)
 {
 void sanitise_setsockopt(int childno)
 shm->a3[childno] = 1 << (ipv6_opts[bit]);
 break;
 
+case SOL_ICMPV6:
+bit = rand() % NR_SOL_ICMPV6_OPTS;
+shm->a3[childno] = 1 << (icmpv6_opts[bit]);
+break;
+
 case SOL_UDPLITE:
 bit = rand() % NR_SOL_UDPLITE_OPTS;
 shm->a3[childno] = 1 << (udplite_opts[bit]);
 void sanitise_setsockopt(int childno)
 
 break;
 
-case SOL_ICMPV6:
 case SOL_SCTP:
 
 case SOL_RAW:
",206,78
RAW support for setsockopt,"
 #include <linux/tipc.h>
 #include <linux/filter.h>
 #include <linux/icmpv6.h>
+#include <linux/icmp.h>
 
 #include ""trinity.h""
 #include ""sanitise.h""
 void sanitise_setsockopt(int childno)
 break;
 
 case SOL_RAW:
+shm->a3[childno] = ICMP_FILTER;// that's all (for now?)
+break;
+
 case SOL_IPX:
 case SOL_AX25:
 case SOL_ATALK:
",223,78
AX25 support for setsockopt," static int sctp_opts[NR_SOL_SCTP_OPTS] = {
 SCTP_SOCKOPT_BINDX_ADD, SCTP_SOCKOPT_BINDX_REM, SCTP_SOCKOPT_PEELOFF, SCTP_SOCKOPT_CONNECTX_OLD,
 SCTP_GET_PEER_ADDRS, SCTP_GET_LOCAL_ADDRS, SCTP_SOCKOPT_CONNECTX, SCTP_SOCKOPT_CONNECTX3 };
 
+#define NR_SOL_AX25_OPTS 12
+static int ax25_opts[NR_SOL_AX25_OPTS] = {
+AX25_WINDOW, AX25_T1, AX25_N2, AX25_T3,
+AX25_T2, AX25_BACKOFF, AX25_EXTSEQ, AX25_PIDINCL,
+AX25_IDLE, AX25_PACLEN, AX25_IAMDIGI,
+SO_BINDTODEVICE };
+
+
 void sanitise_setsockopt(int childno)
 {
 int level;
 void sanitise_setsockopt(int childno)
 break;
 
 case SOL_AX25:
+val = rand() % NR_SOL_AX25_OPTS;
+shm->a3[childno] = ax25_opts[val];
+break;
+
 case SOL_ATALK:
 case SOL_NETROM:
 case SOL_ROSE:
",233,78
atalk doesn't setsockopt," void sanitise_setsockopt(int childno)
 shm->a3[childno] = ax25_opts[val];
 break;
 
-case SOL_ATALK:
+case SOL_ATALK:/* sock_no_setsockopt */
+break;
+
 case SOL_NETROM:
 case SOL_ROSE:
 case SOL_DECNET:
",234,78
netrom support for setsockopt," static int ax25_opts[NR_SOL_AX25_OPTS] = {
 AX25_IDLE, AX25_PACLEN, AX25_IAMDIGI,
 SO_BINDTODEVICE };
 
+#define NR_SOL_NETROM_OPTS 5
+static int netrom_opts[NR_SOL_NETROM_OPTS] = {
+NETROM_T1, NETROM_T2, NETROM_N2, NETROM_T4, NETROM_IDLE };
+
 
 void sanitise_setsockopt(int childno)
 {
 void sanitise_setsockopt(int childno)
 break;
 
 case SOL_NETROM:
+val = rand() % NR_SOL_NETROM_OPTS;
+shm->a3[childno] = netrom_opts[val];
+break;
+
 case SOL_ROSE:
 case SOL_DECNET:
 case SOL_X25:
",239,78
ROSE support for setsockopt," static int ax25_opts[NR_SOL_AX25_OPTS] = {
 static int netrom_opts[NR_SOL_NETROM_OPTS] = {
 NETROM_T1, NETROM_T2, NETROM_N2, NETROM_T4, NETROM_IDLE };
 
+#define NR_SOL_ROSE_OPTS 7
+static int rose_opts[NR_SOL_ROSE_OPTS] = {
+ROSE_DEFER, ROSE_T1, ROSE_T2, ROSE_T3,
+ROSE_IDLE, ROSE_QBITINCL, ROSE_HOLDBACK };
+
 
 void sanitise_setsockopt(int childno)
 {
 void sanitise_setsockopt(int childno)
 break;
 
 case SOL_ROSE:
+val = rand() % NR_SOL_ROSE_OPTS;
+shm->a3[childno] = rose_opts[val];
+break;
+
 case SOL_DECNET:
 case SOL_X25:
 case SOL_PACKET:
",245,78
DECNET support for setsockopt,"
 #include <netax25/ax25.h>
 #include <netrose/rose.h>
 #include <netrom/netrom.h>
+#include <linux/dn.h>
 #include <linux/tipc.h>
 #include <linux/filter.h>
 #include <linux/icmpv6.h>
 static int rose_opts[NR_SOL_ROSE_OPTS] = {
 ROSE_DEFER, ROSE_T1, ROSE_T2, ROSE_T3,
 ROSE_IDLE, ROSE_QBITINCL, ROSE_HOLDBACK };
 
+#define NR_SOL_DECNET_OPTS 18
+static int decnet_opts[NR_SOL_DECNET_OPTS] = {
+SO_CONDATA, SO_CONACCESS, SO_PROXYUSR, SO_LINKINFO,
+DSO_CONDATA, DSO_DISDATA, DSO_CONACCESS, DSO_ACCEPTMODE,
+DSO_CONACCEPT, DSO_CONREJECT, DSO_LINKINFO, DSO_STREAM,
+DSO_SEQPACKET, DSO_MAXWINDOW, DSO_NODELAY, DSO_CORK,
+DSO_SERVICES, DSO_INFO
+};
 
 void sanitise_setsockopt(int childno)
 {
 void sanitise_setsockopt(int childno)
 break;
 
 case SOL_DECNET:
+// TODO: set size correctly
+val = rand() % NR_SOL_DECNET_OPTS;
+shm->a3[childno] = decnet_opts[val];
+break;
+
 case SOL_X25:
 case SOL_PACKET:
 case SOL_ATM:
",256,78
PACKET support for setsockopt,"
 #include <linux/filter.h>
 #include <linux/icmpv6.h>
 #include <linux/icmp.h>
+#include <linux/if_packet.h>
 
 #include ""trinity.h""
 #include ""sanitise.h""
 static int decnet_opts[NR_SOL_DECNET_OPTS] = {
 DSO_SERVICES, DSO_INFO
 };
 
+#define NR_SOL_PACKET_OPTS 22
+static int packet_opts[NR_SOL_PACKET_OPTS] = {
+PACKET_ADD_MEMBERSHIP, PACKET_DROP_MEMBERSHIP, PACKET_RECV_OUTPUT, 4,/* Value 4 is still used by obsolete turbo-packet. */
+PACKET_RX_RING, PACKET_STATISTICS, PACKET_COPY_THRESH, PACKET_AUXDATA,
+PACKET_ORIGDEV, PACKET_VERSION, PACKET_HDRLEN, PACKET_RESERVE,
+PACKET_TX_RING, PACKET_LOSS, PACKET_VNET_HDR, PACKET_TX_TIMESTAMP,
+PACKET_TIMESTAMP, PACKET_FANOUT };
+
+
 void sanitise_setsockopt(int childno)
 {
 int level;
 void sanitise_setsockopt(int childno)
 break;
 
 case SOL_PACKET:
+val = rand() % NR_SOL_PACKET_OPTS;
+shm->a3[childno] = packet_opts[val];
+break;
+
 case SOL_ATM:
 case SOL_AAL:
 case SOL_IRDA:
",269,78
ATM support for setsockopt,"
 #include <linux/icmpv6.h>
 #include <linux/icmp.h>
 #include <linux/if_packet.h>
+#include <linux/atmdev.h>
+#include <linux/atm.h>
 
 #include ""trinity.h""
 #include ""sanitise.h""
 static int packet_opts[NR_SOL_PACKET_OPTS] = {
 PACKET_TX_RING, PACKET_LOSS, PACKET_VNET_HDR, PACKET_TX_TIMESTAMP,
 PACKET_TIMESTAMP, PACKET_FANOUT };
 
+#define NR_SOL_ATM_OPTS 6
+static int atm_opts[NR_SOL_ATM_OPTS] = {
+SO_SETCLP, SO_CIRANGE, SO_ATMQOS, SO_ATMSAP, SO_ATMPVC, SO_MULTIPOINT };
+
 
 void sanitise_setsockopt(int childno)
 {
 void sanitise_setsockopt(int childno)
 break;
 
 case SOL_ATM:
+val = rand() % NR_SOL_ATM_OPTS;
+shm->a3[childno] = atm_opts[val];
+break;
+
 case SOL_AAL:
 case SOL_IRDA:
 case SOL_NETBEUI:
",276,78
IRDA support for setsockopt,"
 #include <linux/if_packet.h>
 #include <linux/atmdev.h>
 #include <linux/atm.h>
+#include <linux/irda.h>
 
 #include ""trinity.h""
 #include ""sanitise.h""
 static int packet_opts[NR_SOL_PACKET_OPTS] = {
 static int atm_opts[NR_SOL_ATM_OPTS] = {
 SO_SETCLP, SO_CIRANGE, SO_ATMQOS, SO_ATMSAP, SO_ATMPVC, SO_MULTIPOINT };
 
+#define NR_SOL_IRDA_OPTS 11
+static int irda_opts[NR_SOL_IRDA_OPTS] = {
+IRLMP_ENUMDEVICES, IRLMP_IAS_SET, IRLMP_IAS_QUERY, IRLMP_HINTS_SET,
+IRLMP_QOS_SET, IRLMP_QOS_GET, IRLMP_MAX_SDU_SIZE, IRLMP_IAS_GET,
+IRLMP_IAS_DEL, IRLMP_HINT_MASK_SET, IRLMP_WAITDEVICE };
+
 
 void sanitise_setsockopt(int childno)
 {
 void sanitise_setsockopt(int childno)
 shm->a3[childno] = atm_opts[val];
 break;
 
-case SOL_AAL:
+case SOL_AAL:/* no setsockopt */
+break;
+
 case SOL_IRDA:
+val = rand() % NR_SOL_IRDA_OPTS;
+shm->a3[childno] = irda_opts[val];
+break;
+
 case SOL_NETBEUI:
 case SOL_LLC:
 case SOL_DCCP:
",285,78
SOL_LLC support for setsockopt,"
 #include <linux/atmdev.h>
 #include <linux/atm.h>
 #include <linux/irda.h>
+#include <linux/if.h>
+#include <linux/llc.h>
 
 #include ""trinity.h""
 #include ""sanitise.h""
 static int irda_opts[NR_SOL_IRDA_OPTS] = {
 IRLMP_QOS_SET, IRLMP_QOS_GET, IRLMP_MAX_SDU_SIZE, IRLMP_IAS_GET,
 IRLMP_IAS_DEL, IRLMP_HINT_MASK_SET, IRLMP_WAITDEVICE };
 
+#define NR_SOL_LLC_OPTS 9
+static int llc_opts[NR_SOL_LLC_OPTS] = {
+LLC_OPT_RETRY, LLC_OPT_SIZE, LLC_OPT_ACK_TMR_EXP, LLC_OPT_P_TMR_EXP,
+LLC_OPT_REJ_TMR_EXP, LLC_OPT_BUSY_TMR_EXP, LLC_OPT_TX_WIN, LLC_OPT_RX_WIN,
+LLC_OPT_PKTINFO };
+
 
 void sanitise_setsockopt(int childno)
 {
 void sanitise_setsockopt(int childno)
 shm->a3[childno] = irda_opts[val];
 break;
 
-case SOL_NETBEUI:
+case SOL_NETBEUI:/* no setsockopt */
+break;
+
 case SOL_LLC:
+val = rand() % NR_SOL_LLC_OPTS;
+shm->a3[childno] = llc_opts[val];
+break;
+
 case SOL_DCCP:
 case SOL_NETLINK:
 case SOL_TIPC:
",295,78
netlink support for setsockopt,"
 #include <linux/if.h>
 #include <linux/llc.h>
 #include <linux/dccp.h>
+#include <linux/netlink.h>
 
 #include ""trinity.h""
 #include ""sanitise.h""
 static int dccp_opts[NR_SOL_DCCP_OPTS] = {
 DCCP_SOCKOPT_AVAILABLE_CCIDS, DCCP_SOCKOPT_CCID, DCCP_SOCKOPT_TX_CCID, DCCP_SOCKOPT_RX_CCID,
 DCCP_SOCKOPT_QPOLICY_ID, DCCP_SOCKOPT_QPOLICY_TXQLEN, DCCP_SOCKOPT_CCID_RX_INFO, DCCP_SOCKOPT_CCID_TX_INFO };
 
+#define NR_SOL_NETLINK_OPTS 5
+static int netlink_opts[NR_SOL_NETLINK_OPTS] = {
+NETLINK_ADD_MEMBERSHIP, NETLINK_DROP_MEMBERSHIP, NETLINK_PKTINFO, NETLINK_BROADCAST_ERROR,
+NETLINK_NO_ENOBUFS };
+
+
 void sanitise_setsockopt(int childno)
 {
 int level;
 void sanitise_setsockopt(int childno)
 break;
 
 case SOL_NETLINK:
+val = rand() % NR_SOL_NETLINK_OPTS;
+shm->a3[childno] = netlink_opts[val];
+break;
+
 case SOL_TIPC:
 case SOL_RXRPC:
 case SOL_PPPOL2TP:
",311,78
TIPC support for setsockopt," static int netlink_opts[NR_SOL_NETLINK_OPTS] = {
 NETLINK_ADD_MEMBERSHIP, NETLINK_DROP_MEMBERSHIP, NETLINK_PKTINFO, NETLINK_BROADCAST_ERROR,
 NETLINK_NO_ENOBUFS };
 
+#define NR_SOL_TIPC_OPTS 6
+static int tipc_opts[NR_SOL_TIPC_OPTS] = {
+TIPC_IMPORTANCE, TIPC_SRC_DROPPABLE, TIPC_DEST_DROPPABLE, TIPC_CONN_TIMEOUT,
+TIPC_NODE_RECVQ_DEPTH, TIPC_SOCK_RECVQ_DEPTH };
+
 
 void sanitise_setsockopt(int childno)
 {
 void sanitise_setsockopt(int childno)
 break;
 
 case SOL_TIPC:
+shm->a4[childno] = sizeof(__u32);
+val = rand() % NR_SOL_TIPC_OPTS;
+shm->a3[childno] = tipc_opts[val];
+break;
+
 case SOL_RXRPC:
 case SOL_PPPOL2TP:
 case SOL_BLUETOOTH:
",318,78
rxrpc support for setsockopt," static int tipc_opts[NR_SOL_TIPC_OPTS] = {
 TIPC_IMPORTANCE, TIPC_SRC_DROPPABLE, TIPC_DEST_DROPPABLE, TIPC_CONN_TIMEOUT,
 TIPC_NODE_RECVQ_DEPTH, TIPC_SOCK_RECVQ_DEPTH };
 
+#define NR_SOL_RXRPC_OPTS 8
+static int rxrpc_opts[NR_SOL_RXRPC_OPTS] = {
+RXRPC_USER_CALL_ID, RXRPC_ABORT, RXRPC_ACK, RXRPC_NET_ERROR,
+RXRPC_BUSY, RXRPC_LOCAL_ERROR, RXRPC_NEW_CALL, RXRPC_ACCEPT };
+
 
 void sanitise_setsockopt(int childno)
 {
 void sanitise_setsockopt(int childno)
 break;
 
 case SOL_RXRPC:
+val = rand() % NR_SOL_RXRPC_OPTS;
+shm->a3[childno] = rxrpc_opts[val];
+break;
+
 case SOL_PPPOL2TP:
 case SOL_BLUETOOTH:
 case SOL_PNPIPE:
",324,78
pppo2ltp support for setsockopt,"
 #include <linux/llc.h>
 #include <linux/dccp.h>
 #include <linux/netlink.h>
+#include <linux/if_pppol2tp.h>
 
 #include ""trinity.h""
 #include ""sanitise.h""
 static int rxrpc_opts[NR_SOL_RXRPC_OPTS] = {
 RXRPC_USER_CALL_ID, RXRPC_ABORT, RXRPC_ACK, RXRPC_NET_ERROR,
 RXRPC_BUSY, RXRPC_LOCAL_ERROR, RXRPC_NEW_CALL, RXRPC_ACCEPT };
 
+#define NR_SOL_PPPOL2TP_OPTS 5
+static int pppol2tp_opts[NR_SOL_PPPOL2TP_OPTS] = {
+PPPOL2TP_SO_DEBUG, PPPOL2TP_SO_RECVSEQ, PPPOL2TP_SO_SENDSEQ, PPPOL2TP_SO_LNSMODE,
+PPPOL2TP_SO_REORDERTO };
 
 void sanitise_setsockopt(int childno)
 {
 void sanitise_setsockopt(int childno)
 break;
 
 case SOL_PPPOL2TP:
+shm->a4[childno] = sizeof(int);
+val = rand() % NR_SOL_PPPOL2TP_OPTS;
+shm->a3[childno] = pppol2tp_opts[val];
+break;
+
 case SOL_BLUETOOTH:
 case SOL_PNPIPE:
 case SOL_RDS:
",332,78
RDS support for setsockopt,"
 #include <linux/dccp.h>
 #include <linux/netlink.h>
 #include <linux/if_pppol2tp.h>
+#include <linux/rds.h>
 
 #include ""trinity.h""
 #include ""sanitise.h""
 static int bluetooth_l2cap_opts[NR_SOL_BLUETOOTH_L2CAP_OPTS] = {
 #define NR_SOL_BLUETOOTH_RFCOMM_OPTS 2
 static int bluetooth_rfcomm_opts[NR_SOL_BLUETOOTH_RFCOMM_OPTS] = { RFCOMM_LM };
 
+#define NR_SOL_RDS_OPTS 7
+static int rds_opts[NR_SOL_RDS_OPTS] = {
+RDS_CANCEL_SENT_TO, RDS_GET_MR, RDS_FREE_MR,
+4, /* deprecated RDS_BARRIER 4 */
+RDS_RECVERR, RDS_CONG_MONITOR, RDS_GET_MR_FOR_DEST };
+
 
 void sanitise_setsockopt(int childno)
 {
 void sanitise_setsockopt(int childno)
 }
 break;
 
-case SOL_PNPIPE:
+case SOL_PNPIPE/* no setsockopt */:
+break;
+
 case SOL_RDS:
+val = rand() % NR_SOL_RDS_OPTS;
+shm->a3[childno] = rds_opts[val];
+break;
+
 case SOL_IUCV:
 case SOL_CAIF:
 case SOL_ALG:
",381,88
iucv support for setsockopt," static int rds_opts[NR_SOL_RDS_OPTS] = {
 4, /* deprecated RDS_BARRIER 4 */
 RDS_RECVERR, RDS_CONG_MONITOR, RDS_GET_MR_FOR_DEST };
 
+#define NR_SOL_IUCV_OPTS 3
+static int iucv_opts[NR_SOL_IUCV_OPTS] = {
+SO_IPRMDATA_MSG, SO_MSGLIMIT, SO_MSGSIZE };
+
 
 void sanitise_setsockopt(int childno)
 {
 void sanitise_setsockopt(int childno)
 break;
 
 case SOL_IUCV:
+val = rand() % NR_SOL_IUCV_OPTS;
+shm->a3[childno] = iucv_opts[val];
+shm->a4[childno] = sizeof(int);
+break;
+
 case SOL_CAIF:
 case SOL_ALG:
 
",387,88
CAIF support for setsockopt," static int rds_opts[NR_SOL_RDS_OPTS] = {
 static int iucv_opts[NR_SOL_IUCV_OPTS] = {
 SO_IPRMDATA_MSG, SO_MSGLIMIT, SO_MSGSIZE };
 
+#define NR_SOL_CAIF_OPTS 2
+static int caif_opts[NR_SOL_CAIF_OPTS] = {
+CAIFSO_LINK_SELECT, CAIFSO_REQ_PARAM };
 
 void sanitise_setsockopt(int childno)
 {
 void sanitise_setsockopt(int childno)
 break;
 
 case SOL_CAIF:
+val = rand() % NR_SOL_CAIF_OPTS;
+shm->a3[childno] = caif_opts[val];
+break;
+
 case SOL_ALG:
 
 default:
",392,88
"finally, ALG support for setsockopt"," void sanitise_setsockopt(int childno)
 shm->a3[childno] = caif_opts[val];
 break;
 
-case SOL_ALG:
+case SOL_ALG:/* no setsockopt */
+break;
+
 
 default:
 shm->a3[childno] = (rand() % 0xff);/* random operation. */
",393,88
occasionally mangle the setsockopt option," void sanitise_setsockopt(int childno)
 
 shm->a2[childno] = level;
 
+
+/*
+ * 10% of the time, mangle the options.
+ * This should catch new options we don't know about, and also maybe some missing bounds checks.
+ */
+if ((rand() % 100) < 10)
+shm->a3[childno] |= (1 << (rand() % 32));
+
+
 /* optval should be nonzero to enable a boolean option, or zero if the option is to be disabled.
  * Let's disable it half the time.
  */
",395,89
"change arg_len to sometimes return ""number of (int/long/long long)"""," unsigned long get_len()
 
 i = get_interesting_value();
 
-switch(rand() % 5) {
+switch(rand() % 6) {
 
-case 0:return (i & 0xff);
-case 1: return (i & page_size);
-case 2:return (i & 0xffff);
-case 3:return (i & 0xffffff);
-case 4:return (i & 0xffffffff);
+case 0:i &= 0xff;
+break;
+case 1: i &= page_size;
+break;
+case 2:i &= 0xffff;
+break;
+case 3:i &= 0xffffff;
+break;
+case 4:i &= 0xffffffff;
+break;
 default:
-BUG(""unreachable!\n"");
+// Pass through
 break;
 }
 
+/* we might get lucky if something is counting ints/longs etc. */
+if (rand() % 100 < 25) {
+switch (rand() % 3) {
+case 0:i /= sizeof(int);
+break;
+case 1:i /= sizeof(long);
+break;
+case 2:i /= sizeof(long long);
+break;
+default:
+break;
+}
+}
+
 return i;
 }
 
",514,195
remove unnecessary comment," unsigned long get_interesting_value()
 i = rand() % 17;
 
 switch (i) {
-/* 64 bit */
 case 0: return 0;
 case 1: return 0x0000000100000000;
 case 2: return 0x7fffffff00000000;
",514,195
add 0xffff0000 as a 32bit 'interesting' value," unsigned long get_interesting_32bit_value()
 }
 break;
 
+/* less common case, go crazy */
 case 8 ... 10:
-/* less common case, go crazy */
-i = rand() % 12;
+i = rand() % 13;
 
 switch (i) {
 case 0:return 0x00010000;
 unsigned long get_interesting_32bit_value()
 case 6: return 0xc0000000;
 case 7:return 0xf0000000;
 case 8:return 0xff000000;
-case 9:return 0xFFFFe000;
-case 10: return 0xffffff00 | (rand() % 256);
-case 11: return 0xffffffff;
+case 9:return 0xffff0000;
+case 10: return 0xffffe000;
+case 11: return 0xffffff00 | (rand() % 256);
+case 12: return 0xffffffff;
 default:
 BUG(""unreachable!\n"");
 return 0;
",515,196
"nfc isn't in a lot of older toolchains, so add it to compat.

caif should be the opposite.","
 #include <linux/if_alg.h>
 #include <linux/phonet.h>
 #include <linux/netlink.h>
-#include <linux/nfc.h>
 #include <stdlib.h>
 #include ""trinity.h""
 #include ""sanitise.h""
+#include ""compat.h""
 
 static int random_ipv4_address(void)
 {
",636,125
reduce getuid/getgid calls," void open_fds(const char *dir, unsigned char add_all)
 int set_read;
 int set_write;
 bool is_dir = FALSE;
-
+uid_t my_id = getuid();
+gid_t my_gid = getgid();
 
 if (!d) {
 printf(""can't open %s\n"", dir);
 void open_fds(const char *dir, unsigned char add_all)
 /* probability of adding a directory to the list. */
 chance = 5;
 
-if (buf.st_uid != getuid()) {
+if (buf.st_uid != my_id) {
 /* We don't own the dir, is it group/other readable ? */
 if (buf.st_mode & (S_IRGRP|S_IROTH)) {
 open_fds(b, add_all);
 openit:
 set_write = FALSE;
 
 /* if we own the file, unlikely, since you should NOT run this thing as root */
-if (buf.st_uid == getuid()) {
+if (buf.st_uid == my_id) {
 if (buf.st_mode & S_IRUSR)
 set_read = TRUE;
 if (buf.st_mode & S_IWUSR)
 set_write = TRUE;
 
-} else if (buf.st_gid == getgid()) {
+} else if (buf.st_gid == my_gid) {
 if (buf.st_mode & S_IRGRP)
 set_read = TRUE;
 if (buf.st_mode & S_IWGRP)
",198,52
Prefer NULL over zero in sanitise_ioctl_sg_io()," void sanitise_ioctl_sg_io(int childno)
 sgio->ioh.mx_sb_len = sizeof(sgio->sense);
 sgio->ioh.sbp = sgio->sense;
 sgio->ioh.timeout = UINT_MAX;
-sgio->ioh.usr_ptr = 0;
+sgio->ioh.usr_ptr = NULL;
 sgio->ioh.flags |= SG_FLAG_DIRECT_IO;
 
 shm->a3[childno] = (unsigned long) page_rand;
",45,8
Set all empty arguments lists `void',"
 
 static struct rlimit oldrlimit;
 
-static void disable_coredumps()
+static void disable_coredumps(void)
 {
 struct rlimit limit;
 
 static void disable_coredumps()
 perror( ""setrlimit(RLIMIT_CORE)"" );
 }
 
-static void reenable_coredumps()
+static void reenable_coredumps(void)
 {
 if (debug == TRUE)
 return;
 static void reenable_coredumps()
 strerror(errno));
 }
 }
-static void set_make_it_fail()
+static void set_make_it_fail(void)
 {
 int fd;
 const char *buf = ""1"";
",149,36
"Rework the filename tree walk.

- Keep an index of every filename as we scan
- kill off MAX_FDS & fds_left_to_create for better separation
 between sockets/files.
- don't create so many fd's as before.

Startup should now be a lot faster."," static unsigned long find_previous_arg_address(unsigned int argnum, unsigned int
 return addr;
 }
 
+char * get_filename(void)
+{
+return fileindex[rand() % files_in_index];
+}
 
 static unsigned long fill_arg(int childno, int call, int argnum)
 {
 static unsigned long fill_arg(int childno, int call, int argnum)
 return (unsigned long) get_cpu();
 
 case ARG_PATHNAME:
-return (unsigned long) pathnames[rand() % 50];
+return (unsigned long) get_filename();
 
 case ARG_IOVEC:
 i = (rand() % 4) + 1;
",519,197
Don't close non-open fd's," void close_files(void)
 for (i = 0; i < nr_file_fds; i++) {
 fd = shm->file_fds[i];
 shm->file_fds[i] = 0;
-close(fd);
+if (fd != 0)
+close(fd);
 }
 }
",257,60
"timeval wrap workaround

if a thread completes a syscall after we sample 'old', we can appear
to have wrapped. Most the time, this shows up as a single second delta,
but on occasion if the system is heavily loaded it can take a few more.
This doesn't fix the problem entirely, but it should lessen it."," static void check_children(void)
 continue;
 
 /* if we wrapped, just reset it, we'll pick it up next time around. */
-if (old > now) {
+if (old > (now + 3)) {
 printf(""child %d wrapped! old=%ld now=%ld\n"", i, old, now);
 shm->tv[i].tv_sec = now;
 continue;
",159,37
rename some variables," retry:
 
 shm->syscallno[childno] = syscallnr;
 
-if (syscallcount) {
-if (shm->execcount >= syscallcount) {
-output(0, ""[%d] shm->execcount (%d) >= syscallcount (%d)\n"", getpid(), shm->execcount,syscallcount);
+if (syscalls_todo) {
+if (shm->total_syscalls_done >= syscalls_todo) {
+output(0, ""[%d] shm->total_syscalls_done (%d) >= syscalls_todo (%d)\n"", getpid(), shm->total_syscalls_done,syscalls_todo);
 shm->exit_reason = EXIT_REACHED_COUNT;
 }
 
-if (shm->execcount == syscallcount)
-printf(""[%d] Reached maximum syscall count %ld\n"", pid, shm->execcount);
+if (shm->total_syscalls_done == syscalls_todo)
+printf(""[%d] Reached maximum syscall count %ld\n"", pid, shm->total_syscalls_done);
 }
 
 ret = mkcall(childno);
",149,36
this doesn't need to be a long long," const struct syscalltable *syscalls;
 const struct syscalltable *syscalls_32bit;
 const struct syscalltable *syscalls_64bit;
 
-unsigned long long syscalls_todo = 0;
+unsigned long syscalls_todo = 0;
 
 unsigned int max_nr_syscalls;
 unsigned int max_nr_32bit_syscalls;
",330,90
"Revert ""microoptimisation to exit faster when -N is near regeneration point.""

This reverts commit b8061965480e07e7451112e655355c59ee8f46e7.

This looks suspect, and is probably unnecessary

Conflicts:
	main.c","
 
 static void regenerate(void)
 {
-if (syscalls_todo >= shm->regenerate)
-return;
-
 shm->regenerating = TRUE;
 
 sleep(1);/* give children time to finish with fds. */
",262,56
maintain better counts of the syscalls done per child.," void init_child(void)
 int i;
 
 i = find_pid_slot(getpid());
-shm->total_syscalls[i] = 0;
+shm->child_syscall_count[i] = 0;
 
 set_make_it_fail();
 if (rand() % 100 < 50)
 int child_process(void)
 if (getppid() != shm->parentpid) {
 output(0, BUGTXT ""CHILD (pid:%d) GOT REPARENTED!\n""
 ""Last syscall was %d (call:%d)\n"",
-getpid(), shm->previous_syscallno[pidslot], shm->total_syscalls[pidslot]);
+getpid(), shm->previous_syscallno[pidslot], shm->child_syscall_count[pidslot]);
 while(1)
 sleep(5);
 }
",149,36
do32bit is a per-child thing.," int child_process(void)
 /*
  * 10% possibility of a 32bit syscall
  */
-shm->do32bit = FALSE;
+shm->do32bit[childno] = FALSE;
 //if (rand() % 100 < 10)
-//shm->do32bit = TRUE;
+//shm->do32bit[childno] = TRUE;
 }
 
 if (validate_syscall_table_32() == FALSE)
 int child_process(void)
 if (validate_syscall_table_64() == FALSE)
 use_64bit = FALSE;
 
-if (shm->do32bit == FALSE) {
+if (shm->do32bit[childno] == FALSE) {
 syscalls = syscalls_64bit;
 max_nr_syscalls = max_nr_64bit_syscalls;
 } else {
",149,36
remove duplicate code," int child_process(void)
 int ret;
 unsigned int syscallnr;
 unsigned int childno = find_pid_slot(pid);
-unsigned int pidslot;
 
 disable_coredumps();
 
 int child_process(void)
 
 while (shm->exit_reason == STILL_RUNNING) {
 
-pidslot = find_pid_slot(getpid());
-
 if (getppid() != shm->parentpid) {
 output(0, BUGTXT ""CHILD (pid:%d) GOT REPARENTED!\n""
 ""Last syscall was %d (call:%d)\n"",
-getpid(), shm->previous_syscallno[pidslot], shm->child_syscall_count[pidslot]);
+getpid(), shm->previous_syscallno[childno], shm->child_syscall_count[childno]);
 while(1)
 sleep(5);
 }
 int child_process(void)
 sleep(1);
 
 /* If the parent reseeded, we should reflect the latest seed too. */
-if (shm->seed != shm->seeds[pidslot])
-set_seed(pidslot);
+if (shm->seed != shm->seeds[childno])
+set_seed(childno);
 
 if (biarch == TRUE) {
 
",147,36
"Move this out of the function, and off the stack"," static void handle_children(void)
 }
 }
 
+static const char *reasons[] = {
+""Still running"",
+""No more syscalls enabled"",
+""Reached maximum syscall count"",
+""No file descriptors open"",
+""Lost track of a pid slot"",
+""shm corruption - Found a pid out of range."",
+""ctrl-c"",
+""kernel became tainted"",
+""SHM was corrupted!\n"",
+};
+
 static const char * decode_exit(unsigned int reason)
 {
-const char *reasons[] = {
-""Still running"",
-""No more syscalls enabled"",
-""Reached maximum syscall count"",
-""No file descriptors open"",
-""Lost track of a pid slot"",
-""shm corruption - Found a pid out of range."",
-""ctrl-c"",
-""kernel became tainted"",
-""SHM was corrupted!\n"",
-};
-
 return reasons[reason];
 }
 
",262,56
remove unneeded signedness," unsigned long filebuffersize = 0;
 
 unsigned long get_interesting_32bit_value(void)
 {
-int i, bit;
+unsigned int i, bit;
 
 i = rand() % 10;
 
",519,197
"reseed when we fork a new child.

Otherwise the newly spawned child does the same syscalls the previous one did."," static void main_loop(void)
 setup_fds();
 
 while (shm->exit_reason == STILL_RUNNING) {
-if (shm->running_childs < shm->max_children)
+if (shm->running_childs < shm->max_children) {
+reseed();
 fork_children();
+}
 
 if (shm->regenerate >= REGENERATION_POINT)
 regenerate();
",264,56
"Add some missing flushes of stdout

When a syscall was hung & killed, we never printed it out."," void output(unsigned char level, const char *fmt, ...)
 exit(EXIT_FAILURE);
 }
 
-if (quiet_level > level)
+if (quiet_level > level) {
 printf(""%s"", outputbuf);
+(void)fflush(stdout);
+}
 
 if (logging == FALSE)
 return;
 void output(unsigned char level, const char *fmt, ...)
 handle = find_logfile_handle();
 if (!handle) {
 printf(""## child logfile handle was null logging to main!\n"");
+(void)fflush(stdout);
 handle = parentlogfile;
 sleep(5);
 return;
 void output(unsigned char level, const char *fmt, ...)
 
 if (monochrome == TRUE) {
 fprintf(handle, ""%s"", outputbuf);
+(void)fflush(handle);
 return;
 }
 
+/* copy buffer, sans ANSI codes */
 len = strlen(outputbuf);
 for (i = 0, j = 0; i < len; i++) {
 if (outputbuf[i] == '')
",136,27
"remove unnecessary buffer building in output()

The supression of ANSI codes happens in the macros now, so we don't
need to do this stripping at output time."," void output(unsigned char level, const char *fmt, ...)
 va_list args;
 int n;
 FILE *handle;
-unsigned int len, i, j;
 char outputbuf[1024];
-char monobuf[1024];
 
 va_start(args, fmt);
 n = vsnprintf(outputbuf, sizeof(outputbuf), fmt, args);
 void output(unsigned char level, const char *fmt, ...)
 return;
 }
 
-if (monochrome == TRUE) {
-fprintf(handle, ""%s"", outputbuf);
-(void)fflush(handle);
-return;
-}
-
-/* copy buffer, sans ANSI codes */
-len = strlen(outputbuf);
-for (i = 0, j = 0; i < len; i++) {
-if (outputbuf[i] == '')
-i += 6;
-else {
-monobuf[j] = outputbuf[i];
-j++;
-}
-}
-monobuf[j] = '\0';
-
-fprintf(handle, ""%s"", monobuf);
+fprintf(handle, ""%s"", outputbuf);
 (void)fflush(handle);
 }
",119,24
allow ctrl-c to bail out of the filename scan," static void __open_fds(const char *dir)
 }
 while ((de = readdir(d))) {
 
+if (shm->exit_reason != STILL_RUNNING)
+return;
+
 memset(&buf, 0, sizeof(struct stat));
 memset(&path, 0, 4096);
 snprintf(path, sizeof(path), ""%s/%s"", dir, de->d_name);
",259,61
log which syscall a process seems to be stuck in.," static void check_children(void)
 
 /* After 30 seconds of no progress, send a kill signal. */
 if (diff == 30) {
-output(0, ""pid %d hasn't made progress in 30 seconds! (last:%ld now:%ld diff:%d). Sending SIGKILL.\n"",
-pid, old, now, diff);
+output(0, ""pid %d hasn't made progress in 30 seconds! (last:%ld now:%ld diff:%d). ""
+""Stuck in syscall %d%s. Sending SIGKILL.\n"",
+pid, old, now, diff, shm->syscallno[i],
+shm->do32bit[i] ? "" (32bit)"" : """");
 kill(pid, SIGKILL);
 break;
 }
",161,38
"Introduce NEED_ALARM flag

This allows us to skip setting the alarm in cases where we know we won't hang.
(Right now, everything that uses fd's is deemed 'might hang')"," static unsigned long do_syscall(int childno)
 a5 = shm->a5[childno];
 a6 = shm->a6[childno];
 
-(void)alarm(3);
+if (syscalls[nr].entry->flags & NEED_ALARM)
+(void)alarm(3);
+
 if (shm->do32bit[childno] == FALSE)
 ret = syscall(nr, a1, a2, a3, a4, a5, a6);
 else
 ret = syscall32(num_args, nr, a1, a2, a3, a4, a5, a6);
-(void)alarm(0);
+
+if (syscalls[nr].entry->flags & NEED_ALARM)
+(void)alarm(0);
 
 pidslot = find_pid_slot(getpid());
 if (pidslot != PIDSLOT_NOT_FOUND) {
",146,19
"tweak the 'reuse fd' logic.

This was subtly broken, and now seems to work again."," static void open_pipes(void)
 }
 }
 
-int get_random_fd(void)
+static int get_new_random_fd(void)
 {
 unsigned int i;
 unsigned int fd_index;
 retry:
 return fd;
 }
 
-int get_fd(void)
+int get_random_fd(void)
 {
+/* 25% of the time, return something new. */
+if ((rand() % 4) == 0)
+return get_new_random_fd();
+
+/* the rest of the time, return the same fd as last time. */
+
 regen:
 if (shm->fd_lifetime == 0) {
-shm->current_fd = get_random_fd();
-shm->fd_lifetime = rand() % shm->max_children;
+shm->current_fd = get_new_random_fd();
+shm->fd_lifetime = (rand() % shm->max_children) + 5;
 } else
 shm->fd_lifetime--;
 
",101,19
"Revert ""remove unnecessary buffer building in output()""

This reverts commit 7f6f26f1f84b5c3d6eb9e8b146d2d1ce32da459c.

This *is* needed. We don't want the ANSI codes going to the logfiles."," void output(unsigned char level, const char *fmt, ...)
 va_list args;
 int n;
 FILE *handle;
+unsigned int len, i, j;
 char outputbuf[1024];
+char monobuf[1024];
 
 va_start(args, fmt);
 n = vsnprintf(outputbuf, sizeof(outputbuf), fmt, args);
 void output(unsigned char level, const char *fmt, ...)
 return;
 }
 
-fprintf(handle, ""%s"", outputbuf);
+if (monochrome == TRUE) {
+fprintf(handle, ""%s"", outputbuf);
+(void)fflush(handle);
+return;
+}
+
+/* copy buffer, sans ANSI codes */
+len = strlen(outputbuf);
+for (i = 0, j = 0; i < len; i++) {
+if (outputbuf[i] == '')
+i += 6;
+else {
+monobuf[j] = outputbuf[i];
+j++;
+}
+}
+monobuf[j] = '\0';
+
+fprintf(handle, ""%s"", monobuf);
 (void)fflush(handle);
 }
",136,27
document why that ANSI stripping is there so I don't forget again.," void output(unsigned char level, const char *fmt, ...)
 return;
 }
 
+/* If we've specified monochrome, we can just dump the buffer
+ * into the logfile as is. Otherwise, we need to strip out
+ * any ANSI codes that may be present.
+ */
 if (monochrome == TRUE) {
 fprintf(handle, ""%s"", outputbuf);
 (void)fflush(handle);
",136,27
Make sure MAP_UNINITIALIZED gets defined,"
 
 #define NUM_FLAGS 12
 
+// need this to actually get MAP_UNINITIALIZED defined
+#define CONFIG_MMAP_ALLOW_UNINITIALIZED
+
 void sanitise_mmap(int childno)
 {
 unsigned int i;
",55,5
Pass more valid values for the first argument of `getrlimit()',"
 */
 #include ""trinity.h""
 #include ""sanitise.h""
+#include ""shm.h""
+
+#include <stdlib.h>
+#include <sys/time.h>
+#include <sys/resource.h>
+
+static void sanitise_getrlimit(int childno)
+{
+if (rand() % 2 == 0)
+return;
+
+/* set ""resource"" some random value half the time. */
+shm->a1[childno] = get_interesting_32bit_value();
+}
 
 struct syscall syscall_getrlimit = {
 .name = ""getrlimit"",
 .num_args = 2,
+.sanitise = sanitise_getrlimit,
 .arg1name = ""resource"",
+.arg1type = ARG_OP,
+.arg1list = {
+.num = 16,
+.values = {
+RLIMIT_AS,
+RLIMIT_CORE,
+RLIMIT_CPU,
+RLIMIT_DATA,
+RLIMIT_FSIZE,
+RLIMIT_LOCKS,
+RLIMIT_MEMLOCK,
+RLIMIT_MSGQUEUE,
+RLIMIT_NICE,
+RLIMIT_NOFILE,
+RLIMIT_NPROC,
+RLIMIT_RSS,
+RLIMIT_RTPRIO,
+RLIMIT_RTTIME,
+RLIMIT_SIGPENDING,
+RLIMIT_STACK,
+},
+},
 .arg2name = ""rlim"",
 .arg2type = ARG_ADDRESS,
 };
",42,2
find_specific_proto() argument constness," static const struct protocol protocols[] = {
 { ""PF_NFC"", 39 },
 };
 
-void find_specific_proto(char *protoarg)
+void find_specific_proto(const char *protoarg)
 {
 unsigned int i;
 const struct protocol *p = protocols;
",244,35
"Initialize `struct flock' per field in `sockets.c'

sockets.c: In function 'generate_sockets':
sockets.c:26:9: warning: missing initializer [-Wmissing-field-initializers]
sockets.c:26:9: warning: (near initialization for 'fl.__unused') [-Wmissing-field-initializers]
sockets.c: In function 'open_sockets':
sockets.c:139:9: warning: missing initializer [-Wmissing-field-initializers]
sockets.c:139:9: warning: (near initialization for 'fl.__unused') [-Wmissing-field-initializers]"," static char sockarray[PF_MAX];
 
 void generate_sockets(void)
 {
-struct flock fl = { F_WRLCK, SEEK_SET, 0, 0, 0 };
+struct flock fl = {
+.l_type = F_WRLCK,
+.l_whence = SEEK_SET,
+};
+
 int fd, n;
 unsigned int i, tries;
 int cachefile;
 static void close_sockets(void)
 
 void open_sockets(void)
 {
-struct flock fl = { F_WRLCK, SEEK_SET, 0, 0, 0 };
+struct flock fl = {
+.l_type = F_WRLCK,
+.l_whence = SEEK_SET,
+};
+
 int cachefile;
 unsigned int domain, type, protocol;
 unsigned int buffer[3];
",250,35
"Seed the parent too.

Otherwise we end up with the same sockets/fd's every time."," int main(int argc, char* argv[])
 if (create_shm())
 exit(EXIT_FAILURE);
 
+/* Set seed in parent thread*/
+set_seed(0);
+
 if (desired_group != GROUP_NONE) {
 ret = setup_syscall_group(desired_group);
 if (ret == FALSE) {
",180,32
"socket flags cleanup

- remove duplicate definitions
- use system headers & compat.h for newer defs
- use FASTOPEN","
 #include ""compat.h""
 #include ""shm.h""
 
-#define MSG_CMSG_COMPAT 0x80000000 /* This message needs 32 bit fixups */
-
 static void sanitise_sendmsg(int childno)
 {
 struct msghdr *msg;
 struct syscall syscall_sendmsg = {
 .arg3name = ""flags"",
 .arg3type = ARG_LIST,
 .arg3list = {
-.num = 19,
+.num = 20,
 .values = { MSG_OOB, MSG_PEEK, MSG_DONTROUTE, MSG_CTRUNC,
 MSG_TRUNC, MSG_DONTWAIT, MSG_EOR,
 MSG_WAITALL, MSG_FIN, MSG_SYN, MSG_CONFIRM,
 MSG_RST, MSG_ERRQUEUE, MSG_NOSIGNAL, MSG_MORE,
-MSG_WAITFORONE, MSG_CMSG_CLOEXEC, MSG_CMSG_COMPAT },
+MSG_WAITFORONE, MSG_CMSG_CLOEXEC, MSG_FASTOPEN, MSG_CMSG_COMPAT },
 },
 .sanitise = sanitise_sendmsg,
 .flags = NEED_ALARM,
",43,2
"move init stuff out of the main_loop function

Leaving it actually be just 'main loop'"," static const char * decode_exit(unsigned int reason)
 
 static void main_loop(void)
 {
-static const char taskname[13]=""trinity-main"";
-
-shm->parentpid = getpid();
-
-output(0, ""[%d] Main thread is alive.\n"", getpid());
-
-prctl(PR_SET_NAME, (unsigned long) &taskname);
-
-setup_fds();
-
 while (shm->exit_reason == STILL_RUNNING) {
 if (shm->running_childs < shm->max_children) {
 reseed();
 static void main_loop(void)
 
 void do_main_loop(void)
 {
+const char taskname[13]=""trinity-main"";
 int childstatus;
 pid_t pid;
 
 /* do an extra fork so that the watchdog and the children don't share a common parent */
 fflush(stdout);
 pid = fork();
-if (pid == 0)
+if (pid == 0) {
+shm->parentpid = getpid();
+output(0, ""[%d] Main thread is alive.\n"", getpid());
+prctl(PR_SET_NAME, (unsigned long) &taskname);
+setup_fds();
+
 main_loop();
+}
 
 while (pid != -1)
 pid = waitpid(-1, &childstatus, 0);
",265,56
"set the seed the forked 'main loop' too.

so we get properly randomised sockets/fd's"," void do_main_loop(void)
 shm->parentpid = getpid();
 output(0, ""[%d] Main thread is alive.\n"", getpid());
 prctl(PR_SET_NAME, (unsigned long) &taskname);
+set_seed(0);
 setup_fds();
 
 main_loop();
",266,56
"mapping improvements

- sometimes do huge page mappings
- make them shared between children"," void * alloc_zero_map(struct map *map, int prot, const char *name)
 {
 struct map *tmpmap = map;
 int fd;
+unsigned long size;
 
 if (!tmpmap)
 tmpmap = alloc_map();
 void * alloc_zero_map(struct map *map, int prot, const char *name)
  * This is necessary for when we want to test page boundaries.
  * see end of _get_address() for details.
  */
-tmpmap->ptr = mmap(NULL, page_size * 2, prot, MAP_PRIVATE, fd, 0);
+
+if (rand() % 2)
+size = page_size * 2;
+else
+size = 4*1024*1024*2-1;
+
+tmpmap->ptr = mmap(NULL, size, prot, MAP_ANONYMOUS|MAP_SHARED, -1, 0);
 
 
 if (!tmpmap->ptr) {
",143,23
"more seeding improvements

- when picking a new seed, make it a bit less sequential
- return the right variable. we were returning 0 when no -s was specified.","
 #include ""trinity.h""
 #include ""shm.h""
 
+/* The actual seed lives in the shm. This variable is used
+ * to store what gets passed in from the command line -s argument */
 unsigned int seed = 0;
 
 static void syslog_seed(int seedparam)
 static void syslog_seed(int seedparam)
 static int new_seed(void)
 {
 struct timeval t;
+int r;
 
 gettimeofday(&t, 0);
-
-return (t.tv_sec * getpid()) ^ t.tv_usec;
+r = rand() ^ (t.tv_sec * getpid()) ^ t.tv_usec;
+return r;
 }
 
 /*
 int init_seed(unsigned int seedparam)
 if (do_syslog == TRUE)
 syslog_seed(seedparam);
 
-return seed;
+return seedparam;
 }
 
 
",53,10
"Check mmap() return value against MAP_FAILED, not NULL in maps.c"," void * alloc_zero_map(struct map *map, int prot, const char *name)
 
 tmpmap->ptr = mmap(NULL, size, prot, MAP_ANONYMOUS|MAP_SHARED, -1, 0);
 
-
-if (!tmpmap->ptr) {
+if (tmpmap->ptr == MAP_FAILED) {
 printf(""mmap /dev/zero failure\n"");
 exit(EXIT_FAILURE);
 }
",143,23
Check malloc() failure in alloc_zero_map()," void * alloc_zero_map(struct map *map, int prot, const char *name)
 printf(""mmap /dev/zero failure\n"");
 exit(EXIT_FAILURE);
 }
+
 tmpmap->name = malloc(80);
+if (!tmpmap->name) {
+fprintf(stderr, ""malloc() failed in %s()."", __func__);
+exit(EXIT_FAILURE);
+}
+
 sprintf(tmpmap->name, ""/dev/zero(%s)"", name);
 num_mappings++;
 
",147,24
hide alloc_zero_map() in maps.c," static void dump_maps(void)
 }
 }
 
-void * alloc_zero_map(struct map *map, int prot, const char *name)
+static void * alloc_zero_map(struct map *map, int prot, const char *name)
 {
 struct map *tmpmap = map;
 int fd;
",147,24
"unmap /dev/zero mappings in destroy_maps()

We call destroy_maps() repeatedly during fuzzing, so let's also actually
unmap the /dev/zero mappings to avoid them piling up."," static void * alloc_zero_map(struct map *map, int prot, const char *name)
 exit(EXIT_FAILURE);
 }
 
+tmpmap->size = size;
+
 tmpmap->name = malloc(80);
 if (!tmpmap->name) {
 fprintf(stderr, ""malloc() failed in %s()."", __func__);
 void destroy_maps(void)
 
 for (i = 0; i < num_mappings; i++) {
 next = thismap->next;
+munmap(thismap->ptr, thismap->size);
 free(thismap->name);
 free(thismap);
 thismap = next;
",149,24
show /dev/zero mapping size in debug message in maps.c," static void * alloc_zero_map(struct map *map, int prot, const char *name)
 sprintf(tmpmap->name, ""/dev/zero(%s)"", name);
 num_mappings++;
 
-output(2, ""mapping[%d]: (zeropage %s) %p\n"", num_mappings - 1, name, tmpmap->ptr);
+output(2, ""mapping[%d]: (zeropage %s) %p (%lu bytes)\n"",
+num_mappings - 1, name, tmpmap->ptr, size);
 
 close(fd);
 return tmpmap;
 }
 
-
 void setup_maps(void)
 {
 struct map *tmpmap;
",150,24
Avoid unneeded string formatting in output()," void output(unsigned char level, const char *fmt, ...)
 char outputbuf[1024];
 char monobuf[1024];
 
+if (logging == FALSE && level >= quiet_level)
+return;
+
 va_start(args, fmt);
 n = vsnprintf(outputbuf, sizeof(outputbuf), fmt, args);
 va_end(args);
",138,29
mbind sanitise improvements,"
 unsigned long, maxnode, unsigned, flags)
 */
 
+#include <linux/mempolicy.h>
+
 #include ""../arch.h""
 
 #define MPOL_F_STATIC_NODES (1 << 15)

 static void sanitise_mbind(int childno)
 {
 unsigned long maxnode;
+
+shm->a2[childno] &= PAGE_MASK;
+
 retry_maxnode:
 shm->a5[childno] &= ~((page_size * 8) - 1);
 
 struct syscall syscall_mbind = {
 .arg2type = ARG_LEN,
 
 .arg3name = ""mode"",
-.arg3type = ARG_RANGE,
-.low3range = 0,
-.hi3range = 5,
+.arg3type = ARG_LIST,
+.arg3list = {
+.num = 4,
+.values = { MPOL_DEFAULT, MPOL_BIND, MPOL_INTERLEAVE, MPOL_PREFERRED },
+},
 
 .arg4name = ""nmask"",
 .arg4type = ARG_ADDRESS,
",45,3
"work on the 'child gets reparented' bug some.

Still not sure why this occasionally happens."," int child_process(void)
 int ret;
 unsigned int syscallnr;
 unsigned int childno = find_pid_slot(pid);
+unsigned int i;
 
 disable_coredumps();
 
 int child_process(void)
 while (shm->exit_reason == STILL_RUNNING) {
 
 if (getppid() != shm->parentpid) {
-output(0, BUGTXT ""CHILD (pid:%d) GOT REPARENTED!\n""
-""Last syscall was %d (call:%d)\n"",
-getpid(), shm->previous_syscallno[childno], shm->child_syscall_count[childno]);
-while(1)
-sleep(5);
+//FIXME: Add locking so only one child does this output.
+output(0, BUGTXT ""CHILD (pid:%d) GOT REPARENTED! ""
+""parent pid:%d. Watchdog pid:%d\n"",
+getpid(),
+shm->parentpid, shm->watchdog_pid);
+output(0, BUGTXT ""Last syscalls:\n"");
+
+for (i = 0; i < MAX_NR_CHILDREN; i++) {
+output(0, "" pid:%d call:%d callno:%d\n"",
+shm->pids[i],
+shm->previous_syscallno[i],
+shm->child_syscall_count[i]);
+}
+shm->exit_reason = EXIT_REPARENT_PROBLEM;
+exit(EXIT_FAILURE);
+//TODO: Emergency logging.
 }
 
 while (shm->regenerating == TRUE)
",156,36
"Guard against strerror(0) in syscall.c

Printing the error string when there was no error is not very
interesting."," args_done:
 
 if (ret < 0) {
 RED
-sptr += sprintf(sptr, ""= %d (%s)"", ret, strerror(errno_saved));
+sptr += sprintf(sptr, ""= %d"", ret);
+if (errno_saved != 0)
+sptr += sprintf(sptr, "" (%s)"", strerror(errno_saved));
 WHITE
 shm->failures++;
 } else {
",150,20
"One-time protect the shm

Commit bc8bb18a (""move the zeropage mappings further away from the
shm."") added some protection to the ""shm"" object we are sharing across
the processes, by mapping /dev/zero a few times. However, we call
setup_maps() whenever regenerating, so the /dev/zero mappings will pile
up.

Provide similar protection by allocating bunch of pages around the ""shm""
object, and mprotect() them to PROT_NONE."," static void * alloc_zero_map(struct map *map, int prot, const char *name)
 void setup_maps(void)
 {
 struct map *tmpmap;
-unsigned int fd, i;
 
 tmpmap = maps_list = alloc_map();
 
-/* Make sure our zero page mappings are nowhere near the shm. */
-fd = open(""/dev/zero"", O_RDWR);
-for (i = 0; i < 50; i++)
-mmap(NULL, page_size, PROT_READ, MAP_PRIVATE, fd, 0);
-close(fd);
-
 /* Add a bunch of /dev/zero mappings */
 tmpmap->next = alloc_zero_map(tmpmap, PROT_READ | PROT_WRITE, ""PROT_READ | PROT_WRITE"");
 tmpmap = tmpmap->next;
",145,23
Apply the ARRAY_SIZE macro," void find_specific_proto(const char *protoarg)
 
 if (specific_proto == 0) {
 /* we were passed a string */
-for (i = 0; i < (sizeof(protocols) / sizeof(struct protocol)); i++) {
+for (i = 0; i < ARRAY_SIZE(protocols); i++) {
 if (strcmp(protoarg, p[i].name) == 0) {
 specific_proto = p[i].proto;
 break;
 void find_specific_proto(const char *protoarg)
 
 if (i > PF_MAX) {
 printf(""Protocol unknown. Pass a numeric value [0-%d] or one of "", PF_MAX);
-for (i = 0; i < (sizeof(protocols) / sizeof(struct protocol)); i++)
+for (i = 0; i < ARRAY_SIZE(protocols); i++)
 printf(""%s "", p[i].name);
 printf(""\n"");
 
",250,35
Remove useless return statement from end of find_specific_proto()," void find_specific_proto(const char *protoarg)
 }
 
 printf(""Using protocol %s (%u) for all sockets\n"", protocols[i].name, protocols[i].proto);
-return;
 }
",248,35
Include syscall number in inactivation message," args_done:
 if (call == (unsigned int) search_syscall_table(syscalls, max_nr_syscalls, ""ioctl""))
 goto skip_enosys;
 
-output(1, ""%s returned ENOSYS, marking as inactive.\n"", syscalls[call].entry->name);
+output(1, ""%s (%d) returned ENOSYS, marking as inactive.\n"", syscalls[call].entry->name, call);
 syscalls[call].entry->flags &= ~ACTIVE;
 }
 
",150,20
"Fix nr_file_fds getting out-of-sync after regeneration

Fix nr_file_fds getting out-of-sync after regeneration. This was causing
the main process to SIGSEGV itself when accessing the file_fds array
out-of-bounds in close_files()."," void close_files(void)
 if (fd != 0)
 close(fd);
 }
+
+nr_file_fds = 0;
 }
",260,61
Really sleep 100ms when spawning watchdog,"
+#include <time.h>
 #include <errno.h>
 #include <fcntl.h>
 #include <unistd.h>

 
 void init_watchdog(void)
 {
+static const struct timespec ts = { .tv_nsec = 100000000 }; /* 100ms */
 pid_t pid;
 
 fflush(stdout);
 void init_watchdog(void)
 watchdog(); // Never returns.
 
 while (shm->watchdog_pid == 0)
-sleep(0.1);
+nanosleep(&ts, NULL);
 
 output(0, ""[%d] Started watchdog thread %d\n"", getpid(), shm->watchdog_pid);
 }
",163,38
Hide the watchdog() function,"
 #include ""files.h""
 #include ""syscall.h""
 
+static void watchdog(void);
+
 void init_watchdog(void)
 {
 static const struct timespec ts = { .tv_nsec = 100000000 }; /* 100ms */
 static void check_children(void)
 }
 }
 
-void watchdog(void)
+static void watchdog(void)
 {
 static const char watchdogname[17]=""trinity-watchdog"";
 static unsigned long lastcount;
",164,38
"Stop calling the watchdog a thread

The watchdog is a process, not a thread."," void init_watchdog(void)
 while (shm->watchdog_pid == 0)
 nanosleep(&ts, NULL);
 
-output(0, ""[%d] Started watchdog thread %d\n"", getpid(), shm->watchdog_pid);
+output(0, ""[%d] Started watchdog process, PID is %d\n"", getpid(), shm->watchdog_pid);
 }
 
 static int check_shm_sanity(void)
 corrupt:
 }
 
 out:
-output(0, ""[%d] Watchdog thread exiting\n"", getpid());
+output(0, ""[%d] Watchdog exiting\n"", getpid());
 
 _exit(EXIT_SUCCESS);
 }
",164,38
wait for watchdog to exit before we exit main," static int create_shm(void)
 int main(int argc, char* argv[])
 {
 int ret = EXIT_SUCCESS;
+int childstatus;
 unsigned int i;
 
 printf(""Trinity v"" __stringify(VERSION) "" Dave Jones <davej@redhat.com> 2012\n"");
 int main(int argc, char* argv[])
 
 do_main_loop();
 
+waitpid(shm->watchdog_pid, &childstatus, 0);
+
 printf(""\nRan %ld syscalls. Successes: %ld Failures: %ld\n"",
 shm->total_syscalls_done - 1, shm->successes, shm->failures);
 
",187,31
move some non-loop stuff out of main_loop()," static void main_loop(void)
 
 sleep(1);// Nothing left to do, sleep a while.
 }
-while (pidmap_empty() == FALSE)
-handle_children();
-
 printf(""[%d] Bailing main loop. Exit reason: %s\n"", getpid(), decode_exit(shm->exit_reason));
-_exit(EXIT_SUCCESS);
 }
 
 
 void do_main_loop(void)
 setup_fds();
 
 main_loop();
+
+/* Wait until all children have exited. */
+while (pidmap_empty() == FALSE)
+handle_children();
+
+_exit(EXIT_SUCCESS);
 }
 
 while (pid != -1)
",267,56
explicitly wait for the main loop process to exit instead of 'any child'," void do_main_loop(void)
 _exit(EXIT_SUCCESS);
 }
 
-while (pid != -1)
-pid = waitpid(-1, &childstatus, 0);
+/* wait for main loop process to exit. */
+pid = waitpid(pid, &childstatus, 0);
 
 shm->parentpid = getpid();
 }
",266,55
output exit reason after the children have exited," static void main_loop(void)
 
 sleep(1);// Nothing left to do, sleep a while.
 }
-printf(""[%d] Bailing main loop. Exit reason: %s\n"", getpid(), decode_exit(shm->exit_reason));
 }
 
 
 void do_main_loop(void)
 while (pidmap_empty() == FALSE)
 handle_children();
 
+printf(""[%d] Bailing main loop. Exit reason: %s\n"", getpid(), decode_exit(shm->exit_reason));
 _exit(EXIT_SUCCESS);
 }
 
",266,55
add some commentary on the child handling.," static void handle_children(void)
 if (shm->running_childs == 0)
 return;
 
+/* First, we wait for *any* child to wake us up. */
 pid = waitpid(-1, &childstatus, WUNTRACED | WCONTINUED);
 
+/* We were awoken, handle it. */
 handle_child(pid, childstatus);
 
+/* While we're awake, let's see if the other children need attention.
+ * We do this instead of just waitpid(-1) again so that there's no way
+ * for any one child to starve the others of attention.
+ */
 for (i = 0; i < shm->max_children; i++) {
 
 pid = shm->pids[i];
",266,55
"remove unnecessary sleep

we go around the loop again, and will sleep when we hit the waitpid(-1,..)
in handle_children"," static void main_loop(void)
 reseed();
 
 handle_children();
-
-sleep(1);// Nothing left to do, sleep a while.
 }
 }
 
",265,55
"some work in progress stuff for the socket creation.

This will fail most of the time right now, as the PF of the sockaddr
will most likely not match what we passed to socket()

Will need a new variant of generate_sockaddr that takes a hint."," static char sockarray[PF_MAX];
 static int open_socket(unsigned int domain, unsigned int type, unsigned int protocol)
 {
 int fd;
+struct sockaddr sa;
+socklen_t salen;
 
 fd = socket(domain, type, protocol);
 if (fd == -1)
 static int open_socket(unsigned int domain, unsigned int type, unsigned int prot
 
 nr_sockets++;
 
+/* Sometimes, listen on created sockets. */
+if (rand() % 2) {
+__unused__ int ret;
+
+/* fake a sockaddr. */
+/* FIXME: This needs to match the socket packet family */
+generate_sockaddr((unsigned long *) &sa, (unsigned long *) &salen);
+
+ret = bind(fd, &sa, salen);
+//if (ret == -1)
+//printf(""bind: %s\n"", strerror(errno));
+
+ret = listen(fd, (rand() % 2) + 1);
+//if (ret == -1)
+//printf(""bind: %s\n"", strerror(errno));
+}
+
 return fd;
 }
 
",260,38
pass the domain arg down to generate_sockaddr as a hint.," static unsigned long fill_arg(int childno, int call, int argnum)
 ;; // fallthrough
 
 case ARG_SOCKADDR:
-generate_sockaddr(&sockaddr, &sockaddrlen);
+generate_sockaddr(&sockaddr, &sockaddrlen, PF_NOHINT);
 
 switch (argnum) {
 case 1:if (syscalls[call].entry->arg2type == ARG_SOCKADDRLEN)
",519,197
"Move the periodic reseed counter to the shm.

This allows us to reset it when we're doing reseeding anyway
(Like if we spawn a new child)."," void set_seed(unsigned int pidslot)
 void reseed(void)
 {
 shm->need_reseed = FALSE;
+shm->reseed_counter = 0;
 
 if (getpid() != shm->parentpid) {
 output(0, ""Reseeding should only happen from parent!\n"");
",54,10
"Prevent hang in watchdog on exit.

The children should have exited at this point, but there seems
to be a race where sometimes the pid map is still populated with
dead pids."," corrupt:
 
 for (i = 0; i < shm->max_children; i++) {
 pid_t pid;
+int ret;
+
 pid = shm->pids[i];
 if (pid == EMPTY_PIDSLOT)
 continue;
-kill(pid, SIGKILL);
+ret = kill(pid, SIGKILL);
+/* If it disappeared, reap it. */
+if (ret == ESRCH)
+reap_child(pid);
+
+if (shm->running_childs == 0)
+goto out;
 }
+
 sleep(1);
+
 if (check_shm_sanity()) {
 // FIXME: If we get here, we over-wrote the real exit_reason.
 // We should have saved that, and handled appropriately.
",169,40
"duh, missing case statement."," void sanitise_socket(int childno)
 switch (rand() % 2) {
 case 0:protocol = NFC_SOCKPROTO_LLCP;
 switch (rand() % 2) {
-type = SOCK_DGRAM;
+case 0:type = SOCK_DGRAM;
 break;
 case 1:type = SOCK_STREAM;
 break;
",128,36
"reduce the alarm timeout.

We don't need to wait a whole 3 seconds, 1 should be sufficient."," static unsigned long do_syscall(int childno, int *errno_saved)
 a6 = shm->a6[childno];
 
 if (syscalls[nr].entry->flags & NEED_ALARM)
-(void)alarm(3);
+(void)alarm(1);
 
 errno = 0;
 
",150,20
remove unnecessary cast by declaring variable as signed," static void mask_signals(void)
 {
 struct sigaction sa;
 sigset_t ss;
-unsigned int i;
+int i;
 
 for (i = 1; i < 512; i++) {
 (void)sigfillset(&ss);
 static void mask_signals(void)
 (void)signal(SIGWINCH, SIG_IGN);
 
 /* Ignore the RT signals. */
-for (i = SIGRTMIN; i <= (unsigned int) SIGRTMAX; i++)
+for (i = SIGRTMIN; i <= SIGRTMAX; i++)
 (void)signal(i, SIG_IGN);
 
 /* If we are in debug mode, we want segfaults and core dumps */
",187,31
explicitly size variable," static void mask_signals(void)
 static int create_shm(void)
 {
 void *p;
-unsigned shm_pages;
+unsigned int shm_pages;
 
 shm_pages = ((sizeof(struct shm_s) + page_size - 1) & ~(page_size - 1)) / page_size;
 
",187,31
factor out the signal masking code.," static void fork_children(void)
 if (pid != 0)
 shm->pids[pidslot] = pid;
 else {
+/* Child process. */
 int ret = 0;
 
+mask_signals_child();
+
 memset(childname, 0, sizeof(childname));
 sprintf(childname, ""trinity-child%d"", pidslot);
 prctl(PR_SET_NAME, (unsigned long) &childname);
 void do_main_loop(void)
 int childstatus;
 pid_t pid;
 
+
 /* do an extra fork so that the watchdog and the children don't share a common parent */
 fflush(stdout);
 pid = fork();
 void do_main_loop(void)
 output(0, ""[%d] Main thread is alive.\n"", getpid());
 prctl(PR_SET_NAME, (unsigned long) &taskname);
 set_seed(0);
+
 setup_fds();
 
 main_loop();
",266,55
use the domain from the sanitise_socket call instead of the loop index," void generate_sockets(void)
 
 /* Pretend we're child 0 and we've called sys_socket */
 sanitise_socket(0);
-domain = shm->a1[0];
-type = shm->a2[0];
-protocol = shm->a3[0];
+
+//FIXME: If we passed a specific domain, we want to sanitise
+// the proto/type fields. Split it out of sanitise_socket()
 
 if (do_specific_proto == TRUE)
 domain = specific_proto;
 else
-domain = i;
+domain = shm->a1[0];
+
+type = shm->a2[0];
+protocol = shm->a3[0];
 
 fd = open_socket(domain, type, protocol);
 if (fd > -1) {
",259,38
x25 sockets must have protocol==0," void sanitise_socket(int childno)
 
 case AF_X25:
 type = SOCK_SEQPACKET;
+protocol = 0;
 break;
 
 case AF_INET:
",129,36
unix sockets need protocol==PF_UNIX," void sanitise_socket(int childno)
 break;
 
 case AF_UNIX:
+protocol = PF_UNIX;
 switch (rand() % 3) {
 case 0:type = SOCK_STREAM;
 break;
",130,36
TIPC support for sanitise_socket()," void sanitise_socket(int childno)
 }
 break;
 
+case AF_TIPC:
+protocol = 0;
+switch (rand() % 3) {
+case 0:type = SOCK_STREAM;
+break;
+case 1:type = SOCK_SEQPACKET;
+break;
+case 2:type = SOCK_DGRAM;
+break;
+default: break;
+}
+break;
+
 default:
 switch (rand() % 6) {
 case 0:type = SOCK_DGRAM;break;
",142,40
RDS support for sanitise_socket()," void sanitise_socket(int childno)
 }
 break;
 
+case AF_RDS:
+protocol = 0;
+type = SOCK_SEQPACKET;
+break;
+
 case AF_TIPC:
 protocol = 0;
 switch (rand() % 3) {
",146,41
PHONET support in sanitise_socket()," void sanitise_socket(int childno)
 }
 break;
 
+case AF_PHONET:
+protocol = 0;
+switch (rand() % 2) {
+case 0:type = SOCK_DGRAM;
+break;
+case 1:type = SOCK_SEQPACKET;
+break;
+default: break;
+}
+break;
+
 case AF_RDS:
 protocol = 0;
 type = SOCK_SEQPACKET;
",156,44
PF_PACKET support for sanitise_socket()," void sanitise_socket(int childno)
 }
 break;
 
+case AF_PACKET:
+switch (rand() % 3) {
+case 0:type = SOCK_DGRAM;
+break;
+case 1:type = SOCK_RAW;
+break;
+case 2:type = SOCK_PACKET;
+break;
+default: break;
+}
+break;
+
 case AF_PHONET:
 protocol = 0;
 switch (rand() % 2) {
",167,48
fix netlink max protocol," void sanitise_socket(int childno)
 case 1:type = SOCK_DGRAM;
 default:break;
 }
-protocol = rand() % 22;
+protocol = rand() % 32;// MAX_LINKS
 break;
 
 case AF_NFC:
",167,48
AF_LLC support for sanitise_socket," void sanitise_socket(int childno)
 }
 break;
 
+case AF_LLC:
+switch (rand() % 2) {
+case 0:type = SOCK_STREAM;
+break;
+case 1:type = SOCK_DGRAM;
+default:break;
+}
+break;
+
 case AF_NETLINK:
 switch (rand() % 2) {
 case 0:type = SOCK_RAW;
",175,51
AF_IRDA support for sanitise_socket,"
 #include <sys/types.h>
 #include <sys/socket.h>
 #include <linux/in.h>
+#include <linux/irda.h>
 
 #include ""trinity.h""
 #include ""sanitise.h""
 void sanitise_socket(int childno)
 }
 break;
 
+case AF_IRDA:
+switch (rand() % 2) {
+case 0:type = SOCK_STREAM;
+break;
+case 1:type = SOCK_SEQPACKET;
+break;
+case 2:type = SOCK_DGRAM;
+switch (rand() % 2) {
+case 0: protocol = IRDAPROTO_ULTRA;
+break;
+case 1: protocol = IRDAPROTO_UNITDATA;
+break;
+default:break;
+}
+break;
+default:break;
+}
+break;
+
 case AF_LLC:
 switch (rand() % 2) {
 case 0:type = SOCK_STREAM;
",194,57
DECnet support for sanitise_socket,"
 #include <sys/socket.h>
 #include <linux/in.h>
 #include <linux/irda.h>
+#include <linux/dn.h>
 
 #include ""trinity.h""
 #include ""sanitise.h""
 void sanitise_socket(int childno)
 }
 break;
 
+case AF_DECnet:
+if (rand() % 2) {
+type = SOCK_SEQPACKET;
+protocol = DNPROTO_NSP;
+} else {
+type = SOCK_STREAM;
+}
+break;
+
 case AF_INET:
 switch (rand() % 3) {
 case 0:type = SOCK_STREAM;// TCP
",203,59
AF_CAN support for sanitise_socket," void sanitise_socket(int childno)
 }
 break;
 
+case AF_CAN:
+protocol = rand() % 7;// CAN_NPROTO
+break;
+
 case AF_DECnet:
 if (rand() % 2) {
 type = SOCK_SEQPACKET;
",206,60
AF_CAIF support for sanitise_socket,"
 #include <sys/types.h>
 #include <sys/socket.h>
 #include <linux/in.h>
+#include <linux/caif/caif_socket.h>
 #include <linux/irda.h>
 #include <linux/dn.h>
 
 void sanitise_socket(int childno)
 }
 break;
 
+case AF_CAIF:
+protocol = rand() % _CAIFPROTO_MAX;
+switch (rand() % 2) {
+case 0:type = SOCK_SEQPACKET;
+break;
+case 1:type = SOCK_STREAM;
+break;
+default:break;
+}
+break;
+
 case AF_CAN:
 protocol = rand() % 7;// CAN_NPROTO
 break;
",217,63
skip boring entries when dumping pidmap," int child_process(void)
 output(0, BUGTXT ""Last syscalls:\n"");
 
 for (i = 0; i < MAX_NR_CHILDREN; i++) {
-output(0, "" pid:%d call:%d callno:%d\n"",
-shm->pids[i],
+// Skip over 'boring' entries.
+if ((shm->pids[i] == -1) &&
+ (shm->previous_syscallno[i] == 0) &&
+ (shm->child_syscall_count[i] == 0))
+continue;
+
+output(0, ""[%d] pid:%d call:%d callno:%d\n"",
+i, shm->pids[i],
 shm->previous_syscallno[i],
 shm->child_syscall_count[i]);
 }
",160,39
ctrl-c handling improvements.," void do_main_loop(void)
 fflush(stdout);
 pid = fork();
 if (pid == 0) {
+setup_main_signals();
+
 shm->parentpid = getpid();
 output(0, ""[%d] Main thread is alive.\n"", getpid());
 prctl(PR_SET_NAME, (unsigned long) &taskname);
",267,55
Document why we copy the syscall tables," void dump_syscall_tables(void)
 }
 }
 
+/*
+ * This changes the pointers in the table 'from' to be copies in
+ * shared mmaps across all children. We do this so that a child can
+ * modify the flags field (adding AVOID for eg) and have other processes see the change.
+ */
 static struct syscalltable * copy_syscall_table(struct syscalltable *from, unsigned int nr)
 {
 unsigned int n;
",330,90
add a fixme about the shared mmaps," static struct syscalltable * copy_syscall_table(struct syscalltable *from, unsig
 unsigned int n;
 struct syscall *copy;
 
+/* FIXME: Use fewer shared maps.
+ * It's pretty sad that we use a whole page just for a copy of that struct when we
+ * could fit dozens of them in a page. This would cut down our /proc/$$/maps a *lot*
+ */
 for (n = 0; n < nr; n++) {
 copy = alloc_shared(sizeof(struct syscall));
 if (copy == NULL)
",330,90
use some different sizes on the mmaps," static void * alloc_zero_map(struct map *map, int prot, const char *name)
 {
 struct map *tmpmap = map;
 int fd;
-unsigned long size;
+unsigned long size = 0;
 
 if (!tmpmap)
 tmpmap = alloc_map();
 static void * alloc_zero_map(struct map *map, int prot, const char *name)
 exit(EXIT_FAILURE);
 }
 
+/* Pick a random sized mmap. */
+switch (rand() % 4) {
+case 0:size = page_size;
+break;
+case 1:size = 1024*1024;
+break;
+case 2:size = 2 * (1024*1024);
+break;
+case 3:size = 4 * (1024*1024);
+break;
+default:
+break;
+}
+
 /* page_size * 2, so we have a guard page afterwards.
  * This is necessary for when we want to test page boundaries.
  * see end of _get_address() for details.
  */
-
-if (rand() % 2)
-size = page_size * 2;
-else
-size = 4*1024*1024*2-1;
+size *= 2;
 
 tmpmap->ptr = mmap(NULL, size, prot, MAP_ANONYMOUS|MAP_SHARED, -1, 0);
 
",154,26
"introduce a configure script

This is just the beginning of a bunch of backwards compat changes
that allow trinity to be built on crusty old enterprise distros."," static void gen_pppox(unsigned long *addr, unsigned long *addrlen)
 proto = rand() % 3;
 
 switch (proto) {
+
+#ifdef USE_PPPOX_PPTP
 case PX_PROTO_OE:
 pppox = malloc(sizeof(struct sockaddr_pppox));
 if (pppox == NULL)
 static void gen_pppox(unsigned long *addr, unsigned long *addrlen)
 *addr = (unsigned long) pppox;
 *addrlen = sizeof(struct sockaddr_pppox);
 break;
+#endif
 
 case PX_PROTO_OL2TP:
 switch (rand() % 4) {
",638,127
add missing header for syscall(),"
 #include <unistd.h>
 #include <sys/types.h>
 #include <sys/ptrace.h>
+#include <sys/syscall.h>
 #include <sys/wait.h>
 
 #include ""arch.h""
",151,20
"move the config.h include to the file that actually needs it

instead of needlessly including it dozens of times.","
 #include ""trinity.h""
 #include ""sanitise.h""
 #include ""compat.h""
+#include ""config.h""
 
 static in_addr_t random_ipv4_address(void)
 {
",639,127
decode the syscall name when we get stuck," static void check_children(void)
 
 /* After 30 seconds of no progress, send a kill signal. */
 if (diff == 30) {
+const struct syscalltable *table;
+int callno = shm->syscallno[i];
+
+if (shm->do32bit[i] == FALSE) {
+table = syscalls_64bit;
+} else {
+table = syscalls_32bit;
+}
+
 output(0, ""[watchdog] pid %d hasn't made progress in 30 seconds! (last:%ld now:%ld diff:%d). ""
-""Stuck in syscall %d%s. Sending SIGKILL.\n"",
-pid, old, now, diff, shm->syscallno[i],
+""Stuck in syscall %d:%s%s. Sending SIGKILL.\n"",
+pid, old, now, diff,
+callno,
+table[callno].entry->name,
 shm->do32bit[i] ? "" (32bit)"" : """");
 kill(pid, SIGKILL);
 break;
",178,41
mlock with a len=0 causes us to hang a lot.,"
 */
 #include <stdlib.h>
 #include ""trinity.h""
+#include ""shm.h""
 #include ""sanitise.h""
 
+static void sanitise_mlock(int childno)
+{
+if (shm->a2[childno] == 0)
+shm->a2[childno] = 1;// must be non-null.
+}
+
 struct syscall syscall_mlock = {
 .name = ""mlock"",
 .num_args = 2,
 struct syscall syscall_mlock = {
 .arg2name = ""len"",
 .arg2type = ARG_LEN,
 .group = GROUP_VM,
+.sanitise = sanitise_mlock,
 };
",19,2
introduce for_each_pidslot helper macro," retry:
 if (file == NULL) {
 printf(""## WTF, logfile was null!\n"");
 printf(""## logfiles: "");
-for (i = 0; i < shm->max_children; i++)
+for_each_pidslot(i)
 printf(""%p "", shm->logfiles[i]);
 printf(""\n"");
 exit(EXIT_FAILURE);
",103,19
better name for variable.," static void regenerate(void)
 shm->regenerating = FALSE;
 }
 
-bool do_check_tainted;
+bool ignore_tainted;
 
 int check_tainted(void)
 {
",267,53
wait for main to be done with regeneration before exit.," static void watchdog(void)
 if (check_tainted() != 0) {
 output(0, ""[watchdog] kernel became tainted! Last seed was %u:%x\n"", shm->seed, shm->seed);
 shm->exit_reason = EXIT_KERNEL_TAINTED;
-while (shm->regenerating ==TRUE)
-sleep(1);
 }
 }
 
 static void watchdog(void)
 }
 
 corrupt:
+/* We don't want to ever exit before main is waiting for us. */
+while (shm->regenerating == TRUE)
+sleep(1);
 
 /* Wait for all the children to exit. */
 while (shm->running_childs > 0) {
",199,41
"Fix -c to only call the syscall specified.

We were picking a random syscall, and retrying until it was the right one,
which was uh, really dumb. Like really really dumb."," retry:
 if (shm->exit_reason != STILL_RUNNING)
 goto out;
 
-syscallnr = rand() % max_nr_syscalls;
+if (do_specific_syscall == FALSE) {
+syscallnr = rand() % max_nr_syscalls;
+if (!(syscalls[syscallnr].entry->flags & ACTIVE))
+goto retry;
+
+} else {
+if (shm->do32bit[childno] == FALSE)
+syscallnr = specific_syscall64;
+else
+syscallnr = specific_syscall32;
+
+if (!(syscalls[syscallnr].entry->flags & ACTIVE)) {
+output(1, ""%s is marked disabled. Can't continue.\n"",
+syscalls[syscallnr].entry->name);
+shm->exit_reason = EXIT_NO_SYSCALLS_ENABLED;
+return EXIT_FAILURE;
+}
+}
 
 if (syscalls[syscallnr].entry->num_args == 0)
 goto retry;
 
-if (!(syscalls[syscallnr].entry->flags & ACTIVE))
-goto retry;
-
 if (syscalls[syscallnr].entry->flags & AVOID_SYSCALL)
 goto retry;
 
",173,42
"Revert ""Fix -c to only call the syscall specified.""

This reverts commit 819c566ed0c277b8ce80267da12a8ced3e2b8b00.

Turns out that wasn't quite so dumb after all.
Sasha points out that I did it this way so that multiple -c parameters
can be passed. With the commit above, we could only have a single -c.

To do this properly we'd have to construct a special syscall table,
and then change the rand() to be nr_enabled_syscalls.

For now, just revert. I'll revisit this post 1.1 sometime."," retry:
 if (shm->exit_reason != STILL_RUNNING)
 goto out;
 
-if (do_specific_syscall == FALSE) {
-syscallnr = rand() % max_nr_syscalls;
-if (!(syscalls[syscallnr].entry->flags & ACTIVE))
-goto retry;
-
-} else {
-if (shm->do32bit[childno] == FALSE)
-syscallnr = specific_syscall64;
-else
-syscallnr = specific_syscall32;
-
-if (!(syscalls[syscallnr].entry->flags & ACTIVE)) {
-output(1, ""%s is marked disabled. Can't continue.\n"",
-syscalls[syscallnr].entry->name);
-shm->exit_reason = EXIT_NO_SYSCALLS_ENABLED;
-return EXIT_FAILURE;
-}
-}
+syscallnr = rand() % max_nr_syscalls;
 
 if (syscalls[syscallnr].entry->num_args == 0)
 goto retry;
 
+if (!(syscalls[syscallnr].entry->flags & ACTIVE))
+goto retry;
+
 if (syscalls[syscallnr].entry->flags & AVOID_SYSCALL)
 goto retry;
 
",160,39
Just deal with seeds in decimal everywhere.," static void watchdog(void)
 /* Only check taint if it was zero on startup */
 if (ignore_tainted == FALSE) {
 if (check_tainted() != 0) {
-output(0, ""[watchdog] kernel became tainted! Last seed was %u:%x\n"", shm->seed, shm->seed);
+output(0, ""[watchdog] kernel became tainted! Last seed was %u\n"", shm->seed);
 shm->exit_reason = EXIT_KERNEL_TAINTED;
 }
 }
",199,41
"print syscall names

- split out into separate function
- document new bug"," int child_process(void)
  (shm->child_syscall_count[i] == 0))
 continue;
 
-output(0, ""[%d] pid:%d call:%d callno:%d\n"",
+output(0, ""[%d] pid:%d call:%s callno:%d\n"",
 i, shm->pids[i],
-shm->previous_syscallno[i],
+print_syscall_name(shm->previous_syscallno[i], shm->do32bit[i]),// FIXME: need previous do32bit
 shm->child_syscall_count[i]);
 }
 shm->exit_reason = EXIT_REPARENT_PROBLEM;
",160,39
"Make victim files be exclusive.

Don't worry about gathering fd's from other places."," void generate_filelist(void)
 
 if (victim_path != NULL)
 open_fds(victim_path);
-
-open_fds(""/dev"");
-open_fds(""/proc"");
-open_fds(""/sys"");
+else {
+open_fds(""/dev"");
+open_fds(""/proc"");
+open_fds(""/sys"");
+}
 
 if (shm->exit_reason != STILL_RUNNING)
 return;
",262,61
don't use sockets when we pass victim files," void open_sockets(void)
 int bytesread=-1;
 int fd;
 
+/* If we have victim files, don't worry about sockets. */
+if (victim_path != NULL)
+return;
+
 cachefile = open(cachefilename, O_RDONLY);
 if (cachefile < 0) {
 printf(""Couldn't find socket cachefile. Regenerating.\n"");
",251,37
"If there are no pids running, checking the pidslots is a waste of time."," static int check_shm_sanity(void)
 unsigned int i;
 pid_t pid;
 
+if (shm->running_childs == 0)
+return SHM_OK;
+
 for_each_pidslot(i) {
 pid = shm->pids[i];
 if (pid == EMPTY_PIDSLOT)
",194,41
"sanity check the arguments for addresses before we do the syscall.

This will be expanded over time, but for now, I'm just concerned
about shm corruption, so check if the address we pass is that."," args_done:
 sleep(1);
 }
 
+if (((unsigned long)shm->a1 == (unsigned long) shm) ||
+ ((unsigned long)shm->a2 == (unsigned long) shm) ||
+ ((unsigned long)shm->a3 == (unsigned long) shm) ||
+ ((unsigned long)shm->a4 == (unsigned long) shm) ||
+ ((unsigned long)shm->a5 == (unsigned long) shm) ||
+ ((unsigned long)shm->a6 == (unsigned long) shm)) {
+BUG(""Address of shm ended up in a register!\n"");
+}
+
+
 /* Some architectures (IA64/MIPS) start their Linux syscalls
  * At non-zero, and have other ABIs below.
  */
",159,26
"initialise sockaddr stack vars.

Occasionally we got sockaddr init trying to happen on shm addresses.
I think this is just stale stack contents, and this seems to be
where it's coming from."," static unsigned long fill_arg(int childno, int call, int argnum)
 unsigned int num = 0;
 const unsigned int *values = NULL;
 enum argtype argtype = 0;
-unsigned long sockaddr, sockaddrlen;
+unsigned long sockaddr = 0, sockaddrlen = 0;
 
 switch (argnum) {
 case 1:argtype = syscalls[call].entry->arg1type;
",525,198
"Change from return in switch to drop through

No functional change, just debugging cleanup"," static void * _get_address(unsigned char null_allowed)
  */
 i = rand() % 100;
 switch (i) {
-case 0:return addr + (page_size - sizeof(char));
-case 1:return addr + (page_size - sizeof(int));
-case 2:return addr + (page_size - sizeof(long));
-case 3:return addr + (page_size / 2);
+case 0:addr += (page_size - sizeof(char));
+break;
+case 1:addr += (page_size - sizeof(int));
+break;
+case 2:addr += (page_size - sizeof(long));
+break;
+case 3:addr += (page_size / 2);
+break;
 case 4 ... 99:
-default: return addr;
+default: break;
 }
+
+return addr;
 }
 
 void * get_address(void)
",530,198
compat.h: add RLIMIT_RTTIME,"
 #include <sys/time.h>
 #include <sys/resource.h>
 
+#include ""compat.h""
+
 static void sanitise_getrlimit(int childno)
 {
 if (rand() % 2 == 0)
",43,2
"prevent generate_filelist() from failing if only one file was found due to the current linked-list logic

This comes from the way I use trinity currently, only opening one specific
character device. The linked-list implementation by default points ->next to
the first element so that if only one element is in the list, the loop logic
fails to add that file."," void generate_filelist(void)
 fileindex = malloc(sizeof(void *) * files_added);
 
 node = names;
-while (node->next != names) {
+do {
 fileindex[i++] = node->name;
 node = node->next;
-}
+} while (node->next != names);
 files_in_index = i;
 }
 
",262,61
ignore SIGPIPE in the child," void mask_signals_child(void)
 (void)signal(SIGTSTP, SIG_IGN);
 (void)signal(SIGWINCH, SIG_IGN);
 (void)signal(SIGIO, SIG_IGN);
+(void)signal(SIGPIPE, SIG_IGN);
 
 /* Ignore the RT signals. */
 for (i = SIGRTMIN; i <= SIGRTMAX; i++)
",51,8
"if we pass a specific net proto, make sure the sockaddrs are specific too"," static void gen_nfc(unsigned long *addr, unsigned long *addrlen)
 
 void generate_sockaddr(unsigned long *addr, unsigned long *addrlen, int pf)
 {
+/* If we want sockets of a specific type, we'll want sockaddrs that match. */
+if (do_specific_proto == TRUE)
+pf = specific_proto;
+
+/* If we got no hint passed down, pick a random proto. */
 if (pf == -1)
 pf = rand() % PF_MAX;
 
",645,129
"Move VERSION definition into config.h

Otherwise it doesn't trigger rebuilds when it changes.","
 #include ""files.h""
 #include ""shm.h""
 #include ""syscall.h""
+#include ""config.h""// for VERSION
 
 char *progname = NULL;
 
",149,24
Remove incorrect (and pointless) date from startup message.," int main(int argc, char* argv[])
 int childstatus;
 unsigned int i;
 
-printf(""Trinity v"" __stringify(VERSION) "" Dave Jones <davej@redhat.com> 2012\n"");
+printf(""Trinity v"" __stringify(VERSION) "" Dave Jones <davej@redhat.com>\n"");
 
 progname = argv[0];
 
",149,24
close stdin before calling execve,"
 #include ""trinity.h""
 #include ""sanitise.h""
 
+void sanitise_execve(__unused__ int childno)
+{
+/* we don't want to block if something tries to read from stdin */
+fclose(stdin);
+}
+
 struct syscall syscall_execve = {
 .name = ""execve"",
 .num_args = 4,
 struct syscall syscall_execve = {
 .arg3type = ARG_ADDRESS,
 .arg4name = ""regs"",
 .arg4type = ARG_ADDRESS,
+.sanitise = sanitise_execve,
 };
",19,1
Don't bother generating parameter output if we're running silent.," long mkcall(int childno)
 * I *really* loathe how this macro has grown. It should be a real function one day.
 */
 #define COLOR_ARG(ARGNUM, NAME, BIT, OLDREG, REG, TYPE)\
+if ((logging == FALSE) && (quiet_level < MAX_LOGLEVEL))\
+goto args_done;\
+\
 if (syscalls[call].entry->num_args >= ARGNUM) {\
 if (!NAME)\
 goto args_done;\
",159,26
"Always allow --list/-L as root

When running as root, we insist on passing --dangerous before proceeding.
Allow --list/-L to work as root even without --dangerous."," int main(int argc, char* argv[])
 if ((do_specific_syscall == FALSE) && (do_exclude_syscall == FALSE))
 mark_all_syscalls_active();
 
+if (desired_group != GROUP_NONE) {
+ret = setup_syscall_group(desired_group);
+if (ret == FALSE) {
+ret = EXIT_FAILURE;
+goto out;
+}
+}
+
+if (show_syscall_list == TRUE) {
+dump_syscall_tables();
+goto out;
+}
+
 if (getuid() == 0) {
 if (dangerous == TRUE) {
 printf(""DANGER: RUNNING AS ROOT.\n"");
 int main(int argc, char* argv[])
 /* Set seed in parent thread*/
 set_seed(0);
 
-if (desired_group != GROUP_NONE) {
-ret = setup_syscall_group(desired_group);
-if (ret == FALSE) {
-ret = EXIT_FAILURE;
-goto out;
-}
-}
-
-if (show_syscall_list == TRUE) {
-dump_syscall_tables();
-goto out;
-}
-
 if (validate_syscall_tables() == FALSE) {
 printf(""No syscalls were enabled!\n"");
 printf(""Use 32bit:%d 64bit:%d\n"", use_32bit, use_64bit);
",149,24
some currently unused sanity test routines for later.," unsigned long get_interesting_value(void)
 #endif
 }
 
+static bool within_page(void *addr, void *check)
+{
+if (addr == check)
+return TRUE;
+if ((addr > check) && (addr < (check + page_size)))
+return TRUE;
+return FALSE;
+}
+
+bool validate_address(void *addr)
+{
+if (within_page(addr, shm) == TRUE)
+return FALSE;
+if (within_page(addr, page_rand) == TRUE)
+return FALSE;
+if (within_page(addr, page_zeros) == TRUE)
+return FALSE;
+if (within_page(addr, page_0xff) == TRUE)
+return FALSE;
+if (within_page(addr, page_allocs) == TRUE)
+return FALSE;
+
+return TRUE;
+}
+
 static void * _get_address(unsigned char null_allowed)
 {
 int i;
",552,208
"count needs to be at least 1, to prevent malloc(0)"," static void sanitise_move_pages(int childno)
 return;
 
 count = rand() % (page_size / sizeof(void *));
+count = max(1, count);
+
 shm->a2[childno] = count;
 
 for (i = 0; i < count; i++) {
",54,6
Avoid division by zero," static unsigned long fill_arg(int childno, int call, int argnum)
 break;
 }
 
-if (high == 0)
+if (high == 0) {
 printf(""%s forgets to set hirange!\n"", syscalls[call].entry->name);
+BUG(""Fix syscall definition!\n"");
+return 0;
+}
 
 i = random() % high;
 if (i < low) {
",555,208
"Avoid potential malloc(0) when no syscalls match group.

Right now this shouldn't be possible, but this sanity check
will be useful when I start adding additional groups."," int setup_syscall_group(unsigned int group)
 count++;
 }
 
+if (count == 0) {
+printf(""No 32-bit syscalls in group\n"");
+goto try_64bit;
+}
+
 newsyscalls32 = malloc(count * sizeof(struct syscalltable));
 if (newsyscalls32 == NULL)
 return FALSE;
 int setup_syscall_group(unsigned int group)
 
 printf(""Found %d 32-bit syscalls in group\n"", max_nr_32bit_syscalls);
 
+try_64bit:
 /* now the 64 bit table*/
 count = 0, j = 0;
 
 int setup_syscall_group(unsigned int group)
 count++;
 }
 
+if (count == 0) {
+printf(""No 64-bit syscalls in group\n"");
+return FALSE;
+}
+
 newsyscalls64 = malloc(count * sizeof(struct syscalltable));
 if (newsyscalls64 == NULL)
 return FALSE;
 int setup_syscall_group(unsigned int group)
 count++;
 }
 
+if (count == 0) {
+printf(""No syscalls found in group\n"");
+return FALSE;
+}
+
 newsyscalls = malloc(count * sizeof(struct syscalltable));
 if (newsyscalls == NULL)
 exit(EXIT_FAILURE);
",352,77
"when child logging fails, set all logfiles to the main logfile."," void output(unsigned char level, const char *fmt, ...)
 if (!handle) {
 printf(""## child logfile handle was null logging to main!\n"");
 (void)fflush(stdout);
-handle = parentlogfile;
+for_each_pidslot(j)
+shm->logfiles[j] = parentlogfile;
 sleep(5);
 return;
 }
",139,25
check read() return value," int check_tainted(void)
 return -1;
 ret = read(fd, buffer, 3);
 close(fd);
-ret = atoi(buffer);
+
+if (ret > 0)
+ret = atoi(buffer);
+else {
+/* We should never fail, but if we do, assume untainted. */
+ret = 0;
+}
 
 return ret;
 }
",271,54
remove unnecessary assignment.," args_done:
 *sptr = '\0';
 
 output(2, ""%s"", string);
-sptr = string;
 
 /* If the syscall doesn't exist don't bother calling it next time. */
 if ((ret == -1) && (errno_saved == ENOSYS)) {
",158,26
unnecessary assignment," void setup_maps(void)
 tmpmap = tmpmap->next;
 
 tmpmap->next = alloc_zero_map(NULL, PROT_WRITE, ""PROT_WRITE"");
-tmpmap = tmpmap->next;
 
 output(2, ""Added /dev/zero mappings.\n"");
 dump_maps();
",153,26
"Do not disable sendfile() on ENOSYS

Noticed that sendfile() was getting inactivated due to returning ENOSYS when
passed some suitable arguments:

[pid 3615] sendfile(304<socket:[73572]>, 622</sys/kernel/slab/:t-0000096/alloc_calls>, [5], 4096) = -1 ENOSYS (Function not implemented)"," args_done:
 if (call == (unsigned int) search_syscall_table(syscalls, max_nr_syscalls, ""ioctl""))
 goto skip_enosys;
 
+/* sendfile() may ENOSYS depending on args. */
+if (call == (unsigned int) search_syscall_table(syscalls, max_nr_syscalls, ""sendfile""))
+goto skip_enosys;
+
 output(1, ""%s (%d) returned ENOSYS, marking as inactive.\n"", syscalls[call].entry->name, call);
 syscalls[call].entry->flags &= ~ACTIVE;
 }
",160,27
make 64bit -1 > -255 be potentially 'interesting' numbers.," unsigned long get_interesting_value(void)
 
 low = get_interesting_32bit_value();
 
-i = rand() % 17;
+i = rand() % 18;
 
 switch (i) {
 case 0: return 0;
 unsigned long get_interesting_value(void)
 case 14: return 0xffffffff80000000 | (low & 0xffffff);// x86-64 kernel text address
 case 15: return 0xffffffffa0000000 | (low & 0xffffff);// x86-64 module space
 case 16: return 0xffffffffff600000 | (low & 0x0fffff);// x86-64 vdso
+case 17: return 0xffffffffffffff00 | (rand() % 256);
 default:
 BUG(""unreachable!\n"");
 return 0;
",556,209
"When using -V, we can divide by zero in get_new_random_fd

Spotted by Tommi.

This whole function needs rewriting really, it's getting a bit crufty."," static int get_new_random_fd(void)
 
 switch (i) {
 case 0:
-retry:
+retry_file:
 fd_index = rand() % nr_file_fds;
 fd = shm->file_fds[fd_index];
 
 retry:
 
 
 if (fd <= ret)
-goto retry;
+goto retry_file;
 break;
 
 case 1:
+/* When using victim files, sockets can be 0. */
+//FIXME: See the previous fixme. Could we infinite loop here ?
+if (nr_sockets == 0)
+goto retry_file;
+
 fd = shm->socket_fds[rand() % nr_sockets];
 break;
 
",105,20
"beginnings of vsock fuzzing.

Just an empty template for now."," void generate_sockaddr(unsigned long *addr, unsigned long *addrlen, int pf)
 
 /* If we got no hint passed down, pick a random proto. */
 if (pf == -1)
-pf = rand() % PF_MAX;
+pf = rand() % TRINITY_PF_MAX;
 
 switch (pf) {
 
 void generate_sockaddr(unsigned long *addr, unsigned long *addrlen, int pf)
 gen_nfc(addr, addrlen);
 break;
 
+case PF_VSOCK:
+//TODO
+break;
+
 default:
 break;
 }
",647,130
Move headers to include/,"
 
 #include <linux/mempolicy.h>
 
-#include ""../arch.h""
+#include ""arch.h""
 
 #define MPOL_F_STATIC_NODES (1 << 15)
 #define MPOL_F_RELATIVE_NODES (1 << 14)
",45,3
move pid related stuff to its own header,"
 #include ""trinity.h""
 #include ""syscall.h""
 #include ""shm.h""
+#include ""pids.h""
 
 static struct rlimit oldrlimit;
 
",161,39
move logging stuff from trinity.h to its own header,"
 
 #include ""trinity.h""
 #include ""syscall.h""
+#include ""log.h""
 #include ""shm.h""
 #include ""pids.h""
 
",162,39
move mappings stuff out to its own header file,"
 #include ""sanitise.h""
 #include ""syscall.h""
 #include ""log.h""
+#include ""maps.h""
 #include ""shm.h""
 
 char * filebuffer = NULL;
",558,209
"move parameters stuff to params.h

also create types.h (so far, just bool)","
 #include ""log.h""
 #include ""shm.h""
 #include ""pids.h""
+#include ""params.h""// for 'debug'
 
 static struct rlimit oldrlimit;
 
",163,39
move networking bits out to net.h,"
 #include ""shm.h""
 #include ""files.h""
 #include ""pids.h""
+#include ""net.h""
 #include ""log.h""
 #include ""params.h""
 
",109,20
move signals related bits out to signal.h,"
 #include ""syscall.h""
 #include ""log.h""
 #include ""shm.h""
+#include ""signals.h""
 #include ""pids.h""
 #include ""params.h""// for 'debug'
 
",164,39
reduce includes in trinity.h,"
+#include <stdio.h>
 #include <string.h>
 #include <unistd.h>
 #include <stdlib.h>
",167,31
move child related bits out to child.h,"
 #include <sys/resource.h>
 #include <sys/prctl.h>
 
+#include ""child.h""
 #include ""trinity.h""
 #include ""syscall.h""
 #include ""log.h""
",165,39
move random seed stuff to random.h,"
 #include ""trinity.h""
 #include ""syscall.h""
 #include ""log.h""
+#include ""random.h""
 #include ""shm.h""
 #include ""signals.h""
 #include ""pids.h""
",166,39
move some networking bits to net.h,"
 #include ""trinity.h""
 #include ""sanitise.h""
 #include ""syscall.h""
+#include ""net.h""
 #include ""log.h""
 #include ""maps.h""
 #include ""shm.h""
",559,209
remove unnecessary includes of trinity.h,"
 #include <sys/prctl.h>
 
 #include ""child.h""
-#include ""trinity.h""
 #include ""syscall.h""
 #include ""log.h""
 #include ""random.h""
",165,39
move child init code into init_child," static void fork_children(void)
 }
 }
 
-set_seed(pidslot);
+init_child(pidslot);
 
-ret = child_process();
+ret = child_process(pidslot);
 
 output(0, ""child %d exitting\n"", getpid());
 
",277,54
Fix another potential divide by zero.," retry_file:
 break;
 
 case 1:
-/* When using victim files, sockets can be 0. */
-//FIXME: See the previous fixme. Could we infinite loop here ?
-if (nr_sockets == 0)
-goto retry_file;
-
+/* When using victim files, sockets can be 0.
+ * Use files as a fallback, or pipes if no files are open.
+ */
+if (nr_sockets == 0) {
+if (nr_file_fds > 0)
+goto retry_file;
+else
+goto do_pipe;
+}
 fd = shm->socket_fds[rand() % nr_sockets];
 break;
 
 case 2:
+do_pipe:
 fd = shm->pipe_fds[rand() % MAX_PIPE_FDS];
 break;
 default:
",113,21
another potential div 0," unsigned long get_len(void)
 
 i = get_interesting_value();
 
+if (i == 0)
+return 0;
+
 switch(rand() % 6) {
 
 case 0:i &= 0xff;
",560,210
remove old commented out code," static void check_children(void)
 shm->tv[i].tv_sec = now;
 continue;
 }
-//if (diff > 3)
-//printf(""[watchdog] pid slot %d [%d]: old:%ld now:%ld diff= %d\n"", i, pid, old, now, diff);
 
 /* After 30 seconds of no progress, send a kill signal. */
 if (diff == 30) {
",197,41
fix caif compile problems on older kernels,"
 #include ""compat.h""
 #include ""maps.h""
 #include ""shm.h""
+#include ""config.h""
 #include ""syscalls/setsockopt.h""
 
 void sanitise_setsockopt(int childno)
 void sanitise_setsockopt(int childno)
 shm->a4[childno] = sizeof(int);
 break;
 
+#ifdef USE_CAIF
 case SOL_CAIF:
 val = rand() % NR_SOL_CAIF_OPTS;
 shm->a3[childno] = caif_opts[val];
 break;
+#endif
 
 case SOL_ALG:/* no setsockopt */
 break;
",264,90
fix if_alg compile problems on older kernels,"
 #include <linux/if_pppox.h>
 #include <linux/can.h>
 #include <linux/tipc.h>
-#include <linux/if_alg.h>
 #include <linux/phonet.h>
 #include <linux/netlink.h>
 #include <stdlib.h>

 #include <linux/caif/caif_socket.h>
 #endif
 
+#ifdef USE_IF_ALG
+#include <linux/if_alg.h>
+#endif
+
 static in_addr_t random_ipv4_address(void)
 {
 int addr = 0;
 static void gen_caif(unsigned long *addr, unsigned long *addrlen)
 }
 #endif
 
+#ifdef USE_IF_ALG
 static void gen_alg(unsigned long *addr, unsigned long *addrlen)
 {
 struct sockaddr_alg *alg;
 static void gen_alg(unsigned long *addr, unsigned long *addrlen)
 *addr = (unsigned long) alg;
 *addrlen = sizeof(struct sockaddr_alg);
 }
+#endif
 
 static void gen_nfc(unsigned long *addr, unsigned long *addrlen)
 {
 void generate_sockaddr(unsigned long *addr, unsigned long *addrlen, int pf)
 break;
 #endif
 
+#ifdef USE_IF_ALG
 case PF_ALG:
 gen_alg(addr, addrlen);
 break;
+#endif
 
 case PF_NFC:
 gen_nfc(addr, addrlen);
",651,135
fix rds compile problems on older kernels," void sanitise_setsockopt(int childno)
 case SOL_PNPIPE/* no setsockopt */:
 break;
 
+#ifdef USE_RDS
 case SOL_RDS:
 val = rand() % NR_SOL_RDS_OPTS;
 shm->a3[childno] = rds_opts[val];
 break;
+#endif
 
 case SOL_IUCV:
 val = rand() % NR_SOL_IUCV_OPTS;
",264,91
"add s390 backend

Add s390 31 and 64 bit system call lists and defines.
Since s390 doesn't support all ptrace requests that other
architectures support, define those request to zero, so we
don't get a compile error.
All those test calls will then be mapped to a ""zero"" ptrace
request, but that doesn't hurt.

Signed-off-by: Heiko Carstens <heiko.carstens@de.ibm.com>","
 #include ""sanitise.h""
 #include ""shm.h""
 #include ""compat.h""
+#include ""arch.h""
 
 
 static void sanitise_ptrace(int childno)
",33,1
"Allow -V to take a single file as an argument

Suggested by Tommi."," void setup_fds(void)
 open_sockets();
 
 generate_filelist();
+if (files_in_index == 0)
+return;
 
 open_files();
 }
",115,22
"Reorder syscall tests in child loop

This way, we retry faster on disabled syscalls."," retry:
 
 syscallnr = rand() % max_nr_syscalls;
 
-if (syscalls[syscallnr].entry->num_args == 0)
-goto retry;
-
 if (!(syscalls[syscallnr].entry->flags & ACTIVE))
 goto retry;
 
 if (syscalls[syscallnr].entry->flags & AVOID_SYSCALL)
 goto retry;
 
+if (syscalls[syscallnr].entry->num_args == 0)
+goto retry;
+
 if (syscalls[syscallnr].entry->flags & NI_SYSCALL)
 goto retry;
 
",164,39
"Fix handling of forced 32bit syscalls.

if we ran trinity -c lstat on a 64bit machine, we would never
do any syscalls, because lstat only exists on 32bit."," int child_process(int childno)
 
 if (biarch == TRUE) {
 
+/* First, check that we have syscalls enabled in either table. */
+if (validate_syscall_table_64() == FALSE) {
+use_64bit = FALSE;
+/* If no 64bit syscalls enabled, force 32bit. */
+shm->do32bit[childno] = TRUE;
+}
+
+if (validate_syscall_table_32() == FALSE)
+use_32bit = FALSE;
+
+/* If both tables enabled, pick randomly. */
 if ((use_64bit == TRUE) && (use_32bit == TRUE)) {
 /*
  * 10% possibility of a 32bit syscall
  */
 shm->do32bit[childno] = FALSE;
+
+// FIXME: I forgot why this got disabled. Revisit.
+
 //if (rand() % 100 < 10)
 //shm->do32bit[childno] = TRUE;
 }
 
-if (validate_syscall_table_32() == FALSE)
-use_32bit = FALSE;
-
-if (validate_syscall_table_64() == FALSE)
-use_64bit = FALSE;
 
 if (shm->do32bit[childno] == FALSE) {
 syscalls = syscalls_64bit;
",166,39
clean up the page_rand randomizer some," void fabricate_onepage_struct(char *page)
 void regenerate_random_page(void)
 {
 unsigned int i;
-unsigned int type = rand() % 3;
-
-/* sometimes return a page that looks kinda like a struct */
-if ((rand() % 100) < 50) {
-fabricate_onepage_struct(page_rand);
-return;
-}
+unsigned int type = rand() % 4;
 
 /* The rest of the time, return a page of complete trash */
 switch (type) {
 void regenerate_random_page(void)
 page_rand[i++] = (unsigned char)rand();
 }
 return;
+
+case 3:/* sometimes return a page that looks kinda like a struct */
+fabricate_onepage_struct(page_rand);
+return;
+
 default:
 BUG(""unreachable!\n"");
 return;
",574,213
terminate the unicode page somewhere randomly," static void gen_unicode_page(char *page)
 break;
 }
 }
+
+page[rand() % page_size] = 0;
 }
 
 void regenerate_random_page(void)
",635,227
"change the filename suffix generation to use more varied data

including unicode. Bring the noise."," static void regenerate(void)
 destroy_maps();
 setup_maps();
 
-regenerate_random_page();
+generate_random_page(page_rand);
 
 shm->regenerating = FALSE;
 }
",282,55
"Parse /proc/devices and /proc/misc for new ioctl support

Parse /proc/devices and /proc/misc. These will be used in the new ioctl()
fuzzing code to match a file descriptor to a device name."," int main(int argc, char* argv[])
 
 init_buffers();
 
+parse_devices();
+
 setup_main_signals();
 
 if (check_tainted() != 0) {
",157,24
"new ioctl() sanitise

This changes the ioctl() sanitise to prefer valid ioctl operations given
the file descriptor. The old version would simply pick an ioctl
operation at random, but this is not very interesting in most cases,
since unrecognized ioctl() operations do not tend to have any effect."," void parse_devices(void)
 output(2, ""Parsed %zu char devices, %zu block devices, %zu misc devices.\n"",
 chrdevs, bldevs, miscdevs);
 }
+
+const char *map_dev(dev_t st_rdev, mode_t st_mode)
+{
+int major, minor;
+size_t i, j;
+
+major = MAJOR(st_rdev);
+minor = MINOR(st_rdev);
+
+if (S_ISCHR(st_mode))
+for (i=0; i < chrdevs; ++i)
+if (char_devs[i].major == major) {
+if (strcmp(char_devs[i].name, ""misc"") == 0) {
+for (j=0; j < miscdevs; ++j)
+if (misc_devs[j].minor == minor)
+return misc_devs[j].name;
+} else
+return char_devs[i].name;
+}
+else if (S_ISBLK(st_mode))
+for (i=0; i < bldevs; ++i)
+if (block_devs[i].major == major)
+return block_devs[i].name;
+
+return NULL;
+}
",331,74
Add --ioctls/-I for dumping known ioctl operations," void pick_random_ioctl(const struct ioctl_group *grp, int childno)
 
 shm->a2[childno] = grp->ioctls[ioctlnr].request;
 }
+
+void dump_ioctls(void)
+{
+int i;
+size_t j;
+
+for (i=0; i < grps_cnt; ++i) {
+if (grps[i]->name)
+printf(""- %s:\n"", grps[i]->name);
+else if (grps[i]->devtype) {
+if (grps[i]->devtype == DEV_MISC)
+printf(""- misc devices"");
+else if (grps[i]->devtype == DEV_CHAR)
+printf(""- char devices"");
+else if (grps[i]->devtype == DEV_BLOCK)
+printf(""- block devices"");
+for (j=0; j < grps[i]->devs_cnt; ++j)
+printf(""%s '%s'"",
+j == 0 ? """" : "","",
+grps[i]->devs[j]);
+printf("":\n"");
+} else
+printf(""- <unknown>:\n"");
+
+for (j=0; j < grps[i]->ioctls_cnt; ++j) {
+printf("" - 0x%08x : %s\n"",
+grps[i]->ioctls[j].request,
+grps[i]->ioctls[j].name ? : """");
+}
+}
+}
",94,30
shm.h cleanup. Split exit stuff from trinity.h out to separate file,"
 #include <sys/mman.h>
 #include <sys/types.h>
 #include <sys/stat.h>
+#include ""trinity.h""// page_size
 #include ""arch.h""
 #include ""maps.h""
 #include ""log.h""
",155,26
"syscall.h only needs types.h, not the whole trinity.h

Fix up fallout from places which were missing explicit trinity.h includes.","
 #include <sys/resource.h>
 #include <sys/prctl.h>
 
+#include ""trinity.h""// biarch
 #include ""child.h""
 #include ""syscall.h""
 #include ""log.h""
",167,39
remove unnecessary trinity.h includes from syscall table definitions.,"
 #include <unistd.h>
 #include <stdlib.h>
 
+#include ""trinity.h""// ARRAY_SIZE, alloc_shared
 #include ""arch.h""
 #include ""arch-syscalls.h""
 #include ""syscall.h""
",356,79
move get_filename to files.c," void close_files(void)
 nr_file_fds = 0;
 }
 
+char * get_filename(void)
+{
+return fileindex[rand() % files_in_index];
+}
+
+
 static struct {
 int major;
 int minor;
",336,75
"kill off global 'filebuffer'

re-use page_rand instead.
It's properly shared between threads.

The only downside is that we're only going to do at most 1 page of I/O,
but we can revisit this one day maybe.","
 #include ""maps.h""
 #include ""shm.h""
 
-char * filebuffer = NULL;
-unsigned long filebuffersize = 0;
-
 /*
 * This function gets called before we call ->sanitise routines.
 */
",311,106
move ARG_LEN stuff out to own file," static unsigned int get_cpu(void)
 return 0;
 }
 
-unsigned long get_len(void)
-{
-int i = 0;
-
-i = get_interesting_value();
-
-if (i == 0)
-return 0;
-
-switch(rand() % 6) {
-
-case 0:i &= 0xff;
-break;
-case 1: i &= page_size;
-break;
-case 2:i &= 0xffff;
-break;
-case 3:i &= 0xffffff;
-break;
-case 4:i &= 0xffffffff;
-break;
-default:
-// Pass through
-break;
-}
-
-/* we might get lucky if something is counting ints/longs etc. */
-if (rand() % 100 < 25) {
-switch (rand() % 3) {
-case 0:i /= sizeof(int);
-break;
-case 1:i /= sizeof(long);
-break;
-case 2:i /= sizeof(long long);
-break;
-default:
-break;
-}
-}
-
-return i;
-}
-
 
 static unsigned long fill_arg(int childno, int call, int argnum)
 {
",277,95
move the ARG_PATHNAME logic out into files.c,"
 
 #include ""trinity.h""// __unused__
 #include ""files.h""
-#include ""shm.h""
 #include ""log.h""
+#include ""maps.h""
+#include ""shm.h""
 #include ""sanitise.h""
 #include ""constants.h""
 
 char * get_filename(void)
 return fileindex[rand() % files_in_index];
 }
 
+char * generate_pathname(void)
+{
+char *pathname = get_filename();
+char *suffix;
+int len = strlen(pathname);
+
+/* 90% of the time, we just return an unmangled filename */
+if ((rand() % 100) > 10)
+return get_filename();
+
+/* Create a bogus filename with junk at the end of an existing one. */
+suffix = malloc(page_size);
+if (suffix == NULL)
+return get_filename();// give up.
+
+generate_random_page(suffix);
+
+//FIXME: We're scribbling past the length of pathname here.
+(void) strcat(pathname, suffix);
+
+/* 50% of the time, make it look like a dir */
+if ((rand() % 2) == 0)
+pathname[len] = '/';
+
+return pathname;
+}
+
 
 static struct {
 int major;
",353,79
fix path mangling to not scribble over memory," char * get_filename(void)
 char * generate_pathname(void)
 {
 char *pathname = get_filename();
-char *suffix;
+char *newpath;
 int len = strlen(pathname);
 
 /* 90% of the time, we just return an unmangled filename */
 char * generate_pathname(void)
 return get_filename();
 
 /* Create a bogus filename with junk at the end of an existing one. */
-suffix = malloc(page_size);
-if (suffix == NULL)
+newpath = malloc(page_size);// FIXME: We leak this.
+if (newpath == NULL)
 return get_filename();// give up.
 
-generate_random_page(suffix);
+generate_random_page(newpath);
 
-//FIXME: We're scribbling past the length of pathname here.
-(void) strcat(pathname, suffix);
+(void) strncpy(newpath, pathname, len);
 
 /* 50% of the time, make it look like a dir */
 if ((rand() % 2) == 0)
-pathname[len] = '/';
+newpath[len] = '/';
 
-return pathname;
+return newpath;
 }
 
 
",353,79
"bump IOCTL_GROUPS_MAX

We hit the limit, so allocate some more.","
 #include ""shm.h""
 #include ""ioctls.h""
 
-#define IOCTL_GROUPS_MAX 32
+#define IOCTL_GROUPS_MAX 48
 
 static const struct ioctl_group *grps[IOCTL_GROUPS_MAX];
 static int grps_cnt;
",95,30
"socket: close all the sockets

As in close_files(), close all the sockets, not half.

Signed-off-by: Kees Cook <keescook@chromium.org>
Reported-by: Brad Spengler <spender@grsecurity.net>"," static void close_sockets(void)
 for (i = 0; i < nr_sockets; i++) {
 fd = shm->socket_fds[i];
 shm->socket_fds[i] = 0;
-if (close(fd) == 0) {
-nr_sockets--;
-} else {
+if (close(fd) != 0) {
 printf(""failed to close socket.(%s)\n"", strerror(errno));
 }
 }
+
+nr_sockets = 0;
 }
 
 void open_sockets(void)
",265,44
"guard against empty ioctl groups

We assume elsewhere that all groups contain at least one ioctl operation, so
filter out any empty group at registration time to avoid crashing."," static int grps_cnt;
 
 void register_ioctl_group(const struct ioctl_group *grp)
 {
+/* group could be empty e.g. if everything is ifdeffed out */
+if (grp->ioctls_cnt == 0)
+return;
+
 if (grps_cnt == ARRAY_SIZE(grps)) {
 fprintf(stderr, ""WARNING: please grow IOCTL_GROUPS_MAX.\n"");
 return;
",97,31
use more random page contents for ioctls," static void ioctl_mangle_arg(int childno)
 break;
 
 case 1:shm->a3[childno] = (unsigned long) page_rand;
-fabricate_onepage_struct(page_rand);
+generate_random_page(page_rand);
 break;
 default: break;
 }
",58,12
make execve generate pages of junk instead of structs as args,"
 #include ""trinity.h""// page_size
 #include ""sanitise.h""
 #include ""shm.h""
+#include ""maps.h""// generate_random_page
 
 static unsigned long ** gen_ptrs_to_crap(void)
 {
 static unsigned long ** gen_ptrs_to_crap(void)
 for (i = 0; i < count; i++) {
 ptr[i] = malloc(page_size);// FIXME: LEAK
 if (ptr[i] != NULL)
-fabricate_onepage_struct((char *) ptr[i]);
+generate_random_page((char *) ptr[i]);
 }
 
 return ptr;
",38,5
make fabricate_onepage_struct an internal implementation detail of generate_random_page,"
 #include ""sanitise.h""// interesting_*
 #include ""log.h""// For BUG
 
-void fabricate_onepage_struct(char *page)
+static void fabricate_onepage_struct(char *page)
 {
 void *addr;
 unsigned int i, j;
",63,15
only decode errno for negative errno's," args_done:
 if (ret < 0) {
 RED
 sptr += sprintf(sptr, ""= %d"", ret);
-if (errno_saved != 0)
+if (errno_saved < 0)
 sptr += sprintf(sptr, "" (%s)"", strerror(errno_saved));
 WHITE
 shm->failures++;
",164,27
"for whatever reason, nodes is signed.","
 
 static void sanitise_move_pages(int childno)
 {
-unsigned int *nodes;
+int *nodes;
 unsigned long *page_alloc;
 unsigned int i;
 unsigned int count;
",54,6
blacklist some dangerous files in /proc," static int ignore_files(const char *path)
 const char *ignored_paths[] = {
 ""."", "".."",
 
+/* dangerous/noisy/annoying stuff in /proc */
+""/proc/sysrq-trigger"", ""/proc/kmem"", ""/proc/kcore"",
+
 /* dangerous/noisy/annoying stuff in /dev */
 ""/dev/log"", ""/dev/mem"", ""/dev/kmsg"",
 NULL
",267,62
"prefer to OOM kill the children

Tell the kernel to prefer to kill the children first when running out of
memory. We do not currently handle the watchdog or the main process death very
well."," int check_tainted(void)
 return ret;
 }
 
+static void oom_score_adj(int adj)
+{
+FILE *fp;
+
+fp = fopen(""/proc/self/oom_score_adj"", ""w"");
+if (!fp)
+return;
+
+fprintf(fp, ""%d"", adj);
+fclose(fp);
+}
+
 #define debugf if (debug == TRUE) printf
 
 static void fork_children(void)
 static void fork_children(void)
 sprintf(childname, ""trinity-child%d"", pidslot);
 prctl(PR_SET_NAME, (unsigned long) &childname);
 
+oom_score_adj(500);
+
 /* Wait for parent to set our pidslot */
 while (shm->pids[pidslot] != getpid()) {
 /* Make sure parent is actually alive to wait for us. */
",293,57
"add missing biarch check

watchdog was segfaulting on i386"," const char * print_syscall_name(unsigned int callno, bool bitsize)
 {
 const struct syscalltable *table;
 
+if (biarch == FALSE)
+return syscalls[callno].entry->name;
+
 if (bitsize == FALSE)
 table = syscalls_64bit;
 else
",358,80
hush nftw walk error if we ctrl-c'd," static void open_fds(const char *dirpath)
 
 ret = nftw(dirpath, file_tree_callback, 32, flags);
 if (ret != 0) {
-output(0, ""Something went wrong during nftw(). Returned %d\n"", ret);
+if (shm->exit_reason != EXIT_SIGINT)
+output(0, ""Something went wrong during nftw(). Returned %d\n"", ret);
 return;
 }
 
",268,63
"overwritten assignment in sanitise_setsockopt

I noticed an assignment that gets immediately overwritten, contradicting
a nearby comment.
According to the comment, 'optval' should get disabled half of the time.

As at the time of the conditional assignment optval was already set to
different nonzero values, it looks to me like the trailing assignment,
which was introduced in commit 737e1a71, may be unintended.

Signed-off-by: Nicolas Kaiser <nikai@nikai.net>"," void sanitise_setsockopt(int childno)
  */
 if (rand() % 2)
 shm->a4[childno] = 0;
-
-shm->a4[childno] = sizeof(int);
 }
 
 struct syscall syscall_setsockopt = {
",263,91
"child process factoring

child_process will eventually pick a random 'thing' to do,
and random syscalls will be just one possibility."," static void check_parent_pid(void)
 //TODO: Emergency logging.
 }
 
-int child_process(int childno)
+static int do_random_syscalls(int childno)
 {
 pid_t pid = getpid();
 int ret;
 retry:
 
 ret = mkcall(childno);
 }
+out:
+return ret;
+}
 
+int child_process(int childno)
+{
+int ret;
+
+ret = do_random_syscalls(childno);
 
-out:
 reenable_coredumps();
 
 return ret;
",179,41
"ugly hack to support 32bit pids.

clean up later."," void dump_pid_slots(void)
 
 int pid_is_valid(pid_t pid)
 {
-if ((pid > 65535) || (pid < 1)) {
+pid_t pidmax;
+
+// FIXME: Read this from /proc/sys/kernel/pid_max on startup
+#ifdef __x86_64__
+pidmax = 4194304;
+#else
+pidmax = 32768;
+#endif
+
+if ((pid > pidmax) || (pid < 1)) {
 output(0, ""Sanity check failed! Found pid %d!\n"", pid);
 return FALSE;
 }
",64,16
"simplify seed generation.

this seems good enough"," static unsigned int new_seed(void)
 unsigned int r;
 
 gettimeofday(&t, 0);
-r = rand() ^ (t.tv_sec * getpid()) ^ t.tv_usec;
+
+r = t.tv_usec * rand();
 return r;
 }
 
",55,10
occasionally don't add in the usecs," static unsigned int new_seed(void)
 struct timeval t;
 unsigned int r;
 
-gettimeofday(&t, 0);
-
-r = t.tv_usec * rand();
+r = rand();
+if (!(rand() % 1)) {
+gettimeofday(&t, 0);
+r |= t.tv_usec;
+}
 return r;
 }
 
",58,11
"decode errno when a syscall fails.

Not sure where this negative check idea came from, but it was misguided."," args_done:
 
 if (ret < 0) {
 RED
-sptr += sprintf(sptr, ""= %d"", ret);
-if (errno_saved < 0)
-sptr += sprintf(sptr, "" (%s)"", strerror(errno_saved));
+sptr += sprintf(sptr, ""= %d (%s)"", ret, strerror(errno_saved));
 CRESET
 shm->failures++;
 } else {
",162,26
decode protocol number correctly.," static const struct protocol protocols[] = {
 { ""PF_VSOCK"", 40 },
 };
 
-static const char * get_proto_name(int proto)
+static const char * get_proto_name(unsigned int proto)
 {
-return protocols[proto].name;
+unsigned int i;
+
+for (i = 0; i < TRINITY_PF_MAX; i++)
+if (protocols[i].proto == proto)
+return protocols[i].name;
+return NULL;
 }
 
 void find_specific_proto(const char *protoarg)
",269,46
add a mode to only use network sockets," static int get_new_random_fd(void)
 int fd = 0;
 int ret;
 
+i = rand() % 3;
+
 if (do_specific_proto == TRUE)
 i = 1;
-else
-i = rand() % 3;
+
+if (no_files == TRUE)
+i = 1;
 
 /* Ugly special case.
  * Sometimes, we can get here without any fd's setup.
 regen:
 
 void setup_fds(void)
 {
-open_pipes();
-
 open_sockets();
+if (no_files == TRUE)
+return;
+
+open_pipes();
 
 generate_filelist();
 if (files_in_index == 0)
 void setup_fds(void)
 
 void regenerate_fds(void)
 {
+if (no_files == TRUE)
+return;
+
 close_files();
 open_files();
 }
",120,25
add 'random 10 syscalls' mode.," static int setup_tables(void)
 {
 unsigned int ret;
 
-/* If we didn't pass -c, or -x, mark all syscalls active. */
-if ((do_specific_syscall == FALSE) && (do_exclude_syscall == FALSE))
+/* If we didn't pass -c, -x or -r, mark all syscalls active. */
+if ((do_specific_syscall == FALSE) && (do_exclude_syscall == FALSE) && (random_selection == FALSE))
 mark_all_syscalls_active();
 
 if (desired_group != GROUP_NONE) {
 static int setup_tables(void)
 return FALSE;
 }
 
+if (random_selection == TRUE)
+enable_random_syscalls();
+
 if (validate_syscall_tables() == FALSE) {
 printf(""No syscalls were enabled!\n"");
 printf(""Use 32bit:%d 64bit:%d\n"", use_32bit, use_64bit);
",171,29
avoid potential div by 0 when running with -n," void close_files(void)
 
 char * get_filename(void)
 {
+if (files_in_index == 0)/* This can happen if we run with -n. Should we do something else ? */
+return NULL;
+
 return fileindex[rand() % files_in_index];
 }
 
",270,64
only output progress every 10k," static void check_children(void)
 static void watchdog(void)
 {
 static const char watchdogname[17]=""trinity-watchdog"";
-static unsigned long lastcount;
+static unsigned long lastcount = 0;
 
 shm->watchdog_pid = getpid();
 printf(""[%d] Watchdog is alive\n"", shm->watchdog_pid);
 static void watchdog(void)
 synclogs();
 
 if ((quiet_level > 1) && (shm->total_syscalls_done > 1)) {
-if (shm->total_syscalls_done != lastcount)
+if (shm->total_syscalls_done - lastcount > 10000) {
 printf(""[watchdog] %ld iterations. [F:%ld S:%ld]\n"",
 shm->total_syscalls_done, shm->failures, shm->successes);
-lastcount = shm->total_syscalls_done;
+lastcount = shm->total_syscalls_done;
+}
 }
 }
 
",199,41
"evaluate -r earlier

this way we can use -r and -x together"," void parse_args(int argc, char *argv[])
 
 case 'r':
 random_selection = 1;
+enable_random_syscalls();
 break;
 
 /* Set seed */
",168,30
"remove duplicate test

already done (better) in the validate routine"," retry:
 else
 num = rand() % max_nr_syscalls;
 
-syscallname = lookup_name(num);
-if (!strcmp(syscallname, ""ni_syscall (generic)""))
-goto retry;
-
 if (biarch == TRUE) {
 if (validate_specific_syscall_silent(syscalls_64bit, num) == FALSE)
 goto retry;
 retry:
 
 }
 
+syscallname = lookup_name(num);
 toggle_syscall(syscallname, TRUE);
 }
 }
",386,91
remove hand-rolled validate function," retry:
 if (!(syscalls[syscallnr].entry->flags & ACTIVE))
 goto retry;
 
-if (syscalls[syscallnr].entry->flags & AVOID_SYSCALL)
-goto retry;
-
-if (syscalls[syscallnr].entry->num_args == 0)
-goto retry;
-
-if (syscalls[syscallnr].entry->flags & NI_SYSCALL)
+if (validate_specific_syscall_silent(syscalls, syscallnr) == FALSE)
 goto retry;
 
 /* if we get here, syscallnr is finally valid */
",73,18
make sure -x doesn't enable all syscalls if we've already done -r," void parse_args(int argc, char *argv[])
 break;
 
 case 'x':
-/* First time we see a '-x', set all syscalls to enabled, then selectively disable. */
-if (do_exclude_syscall == FALSE)
-mark_all_syscalls_active();
-
+/* First time we see a '-x', set all syscalls to enabled, then selectively disable.
+ * Unless we've started enabling them already (with -r)
+ */
+if (random_selection == FALSE) {
+if (do_exclude_syscall == FALSE)
+mark_all_syscalls_active();
+}
 do_exclude_syscall = TRUE;
 toggle_syscall(optarg, FALSE);
 break;
",170,31
"remove duplicate message

toggle_* prints this already"," void parse_args(int argc, char *argv[])
 /* syscalls are all disabled at this point. enable the syscall we care about. */
 do_specific_syscall = TRUE;
 toggle_syscall(optarg, TRUE);
-printf(""Enabling syscall %s\n"", optarg);
 break;
 
 case 'C':
",169,31
"split up shm init

we need randomness in parse_args if we pass -r
but we also need to handle -s, so post-setup the shm too if necessary"," static void syslog_seed(int seedparam)
 closelog();
 }
 
-static unsigned int new_seed(void)
+unsigned int new_seed(void)
 {
 struct timeval t;
 unsigned int r;
",58,11
don't enable already enabled syscalls," retry:
 num = rand() % max_nr_syscalls;
 
 if (biarch == TRUE) {
+
+if (syscalls_64bit[num].entry->flags & ACTIVE)
+goto retry;
+
 if (validate_specific_syscall_silent(syscalls_64bit, num) == FALSE)
 goto retry;
 
+if (syscalls_64bit[num].entry->flags & ACTIVE)
+goto retry;
+
 if (validate_specific_syscall_silent(syscalls_32bit, num) == FALSE)
 goto retry;
 
 } else {
 if (validate_specific_syscall_silent(syscalls, num) == FALSE)
 goto retry;
+if (syscalls[num].entry->flags & ACTIVE)
+goto retry;
 
 }
 
",402,101
-x options need to be after -r," void parse_args(int argc, char *argv[])
 break;
 
 case 'r':
+if (do_exclude_syscall == TRUE) {
+printf(""-r needs to be before any -x options.\n"");
+return;
+}
 random_selection = 1;
 enable_random_syscalls();
 break;
",173,32
"if we pass -r and -n, might as well skip the VM syscalls."," void parse_args(int argc, char *argv[])
 exit(EXIT_FAILURE);
 }
 random_selection = 1;
-enable_random_syscalls();
 break;
 
 /* Set seed */
",172,32
move unix sockets out to seperate file,"
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+#include <netinet/in.h>
+#include <linux/dn.h>
+#include <stdlib.h>
+#include ""maps.h""
+
+void gen_unixsock(unsigned long *addr, unsigned long *addrlen)
+{
+struct sockaddr_un *unixsock;
+unsigned int len;
+
+unixsock = malloc(sizeof(struct sockaddr_un));
+if (unixsock == NULL)
+return;
+
+unixsock->sun_family = PF_UNIX;
+len = rand() % 20;
+memset(&page_rand[len], 0, 1);
+strncpy(unixsock->sun_path, page_rand, len);
+*addr = (unsigned long) unixsock;
+*addrlen = sizeof(struct sockaddr_un);
+}
",21,2
"move the -x processing out until after we're done processing args.

we need to collect things and process them afterwards rather trying
to process as we go. This should make a few things work better, such
as having '-x foo -r' and then having -r re-enabling the x'd option."," void parse_args(int argc, char *argv[])
 break;
 
 case 'x':
-/* First time we see a '-x', set all syscalls to enabled, then selectively disable.
- * Unless we've started enabling them already (with -r)
- */
-if (random_selection == FALSE) {
-if (do_exclude_syscall == FALSE)
-mark_all_syscalls_active();
-}
 do_exclude_syscall = TRUE;
 toggle_syscall(optarg, FALSE);
 break;
",170,31
make -r take the number of syscalls to choose from," void enable_random_syscalls(void)
 unsigned int num;
 const char *syscallname;
 
-printf(""Enabling 10 random syscalls\n"");
+if (random_selection_num == 0) {
+printf(""-r 0 syscalls ? what?\n"");
+exit(EXIT_FAILURE);
+}
+
+if (biarch == TRUE) {
+if (random_selection_num > max_nr_64bit_syscalls) {
+printf(""-r val %d out of range (1-%d)\n"", random_selection_num, max_nr_64bit_syscalls);
+exit(EXIT_FAILURE);
+}
+} else {
+if (random_selection_num > max_nr_syscalls) {
+printf(""-r val %d out of range (1-%d)\n"", random_selection_num, max_nr_syscalls);
+exit(EXIT_FAILURE);
+}
+}
+
+printf(""Enabling %d random syscalls\n"", random_selection_num);
 
-for (i = 0; i < 10; i++) {
+for (i = 0; i < random_selection_num; i++) {
 
 retry:
 if (biarch == TRUE)
",471,121
move caif out to separate file,"
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+#include <netinet/in.h>
+#include <stdlib.h>
+#include ""config.h""
+
+#ifdef USE_CAIF
+#include <linux/caif/caif_socket.h>
+
+void gen_caif(unsigned long *addr, unsigned long *addrlen)
+{
+struct sockaddr_caif *caif;
+unsigned int i;
+
+caif = malloc(sizeof(struct sockaddr_caif));
+if (caif == NULL)
+return;
+
+caif->family = PF_CAIF;
+caif->u.at.type = rand();
+for (i = 0; i < 16; i++)
+caif->u.util.service[i] = rand();
+caif->u.dgm.connection_id = rand();
+caif->u.dgm.nsapi = rand();
+caif->u.rfm.connection_id = rand();
+for (i = 0; i < 16; i++)
+caif->u.rfm.volume[i] = rand();
+caif->u.dbg.type = rand();
+caif->u.dbg.service = rand();
+*addr = (unsigned long) caif;
+*addrlen = sizeof(struct sockaddr_caif);
+}
+
+#endif
",28,4
move alg out to separate file,"
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+#include <netinet/in.h>
+#include <stdlib.h>
+#include ""config.h""
+
+#ifdef USE_IF_ALG
+#include <linux/if_alg.h>
+
+void gen_alg(unsigned long *addr, unsigned long *addrlen)
+{
+struct sockaddr_alg *alg;
+unsigned int i;
+
+alg = malloc(sizeof(struct sockaddr_alg));
+if (alg == NULL)
+return;
+
+alg->salg_family = PF_ALG;
+for (i = 0; i < 14; i++)
+alg->salg_type[i] = rand();
+alg->salg_feat = rand();
+alg->salg_mask = rand();
+for (i = 0; i < 64; i++)
+alg->salg_name[i] = rand();
+*addr = (unsigned long) alg;
+*addrlen = sizeof(struct sockaddr_alg);
+}
+
+#endif
",24,4
fix -x behaviour when no -r," static int munge_tables(void)
 return FALSE;
 }
 
-if (random_selection == TRUE) {
+if (random_selection == TRUE)
 enable_random_syscalls();
-} else {
 
-/* If we saw a '-x', set all syscalls to enabled, then selectively disable.
- * Unless we've started enabling them already (with -r)
- */
 
-if (do_exclude_syscall == FALSE)
+/* If we saw a '-x', set all syscalls to enabled, then selectively disable.
+ * Unless we've started enabling them already (with -r)
+ */
+if (do_exclude_syscall == TRUE) {
+if (random_selection == FALSE)
 mark_all_syscalls_active();
-}
 
-if (do_exclude_syscall == TRUE)
 deactivate_disabled_syscalls();
+}
 
 sanity_check_tables();
 
",185,33
display count of dis/enabled syscalls.," int validate_specific_syscall_silent(const struct syscalltable *table, int call)
 return TRUE;
 }
 
+void count_syscalls_enabled(void)
+{
+unsigned int i;
+unsigned int ecount_32 = 0, ecount_64 = 0;
+unsigned int dcount_32 = 0, dcount_64 = 0;
+
+if (biarch == TRUE) {
+for_each_64bit_syscall(i) {
+if (syscalls_64bit[i].entry->flags & ACTIVE)
+ecount_64++;
+else
+dcount_64++;
+}
+
+for_each_32bit_syscall(i) {
+if (syscalls_32bit[i].entry->flags & ACTIVE)
+ecount_32++;
+else
+dcount_32++;
+}
+printf(""[%d] 32-bit syscalls: %d enabled, %d disabled. ""
+""64-bit syscalls: %d enabled, %d disabled.\n"",
+getpid(), ecount_32, dcount_32, ecount_64, dcount_64);
+
+} else {
+
+/* non-biarch */
+for_each_syscall(i) {
+if (syscalls[i].entry->flags & ACTIVE)
+ecount_32++;
+else
+dcount_32++;
+}
+printf(""[%d] Enabled %d syscalls. Disabled %d syscalls.\n"", getpid(), ecount_32, dcount_32);
+}
+}
+
 bool no_syscalls_enabled(void)
 {
 unsigned int i;
",502,126
don't ignore enabled syscalls," retry:
 
 if (biarch == TRUE) {
 
-if (syscalls_64bit[num].entry->flags & ACTIVE)
-goto retry;
-
 if (validate_specific_syscall_silent(syscalls_64bit, num) == FALSE)
 goto retry;
-
-if (syscalls_32bit[num].entry->flags & ACTIVE)
-goto retry;
-
 if (validate_specific_syscall_silent(syscalls_32bit, num) == FALSE)
 goto retry;
 
 retry:
 } else {
 if (validate_specific_syscall_silent(syscalls, num) == FALSE)
 goto retry;
-if (syscalls[num].entry->flags & ACTIVE)
-goto retry;
 
 /* If we want just network sockets, don't bother with VM syscalls */
 if (no_files == TRUE) {
",496,123
Remove duplicate information.," int main(int argc, char* argv[])
 }
 }
 
-if (do_specific_syscall == FALSE) {
-if (biarch == TRUE)
-output(0, ""Fuzzing %d 32-bit syscalls & %d 64-bit syscalls.\n"",
-max_nr_32bit_syscalls, max_nr_64bit_syscalls);
-else
-output(0, ""Fuzzing %d syscalls.\n"", max_nr_syscalls);
-}
-
 if (do_specific_proto == TRUE)
 find_specific_proto(specific_proto_optarg);
 
",179,31
"when verbose, display all enabled syscalls."," static const char * lookup_name(unsigned int num)
 return syscalls[num].entry->name;
 }
 
+void display_enabled_syscalls(void)
+{
+unsigned int i;
+
+if (biarch == TRUE) {
+for_each_64bit_syscall(i) {
+if (syscalls_64bit[i].entry->flags & ACTIVE)
+printf(""[%d] 64-bit syscall %s enabled.\n"", getpid(), syscalls_64bit[i].entry->name);
+}
+
+for_each_32bit_syscall(i) {
+if (syscalls_32bit[i].entry->flags & ACTIVE)
+printf(""[%d] 32-bit syscall %s enabled.\n"", getpid(), syscalls_32bit[i].entry->name);
+}
+
+} else {
+/* non-biarch */
+for_each_syscall(i) {
+if (syscalls[i].entry->flags & ACTIVE)
+printf(""[%d] syscall %s enabled.\n"", getpid(), syscalls[i].entry->name);
+}
+}
+}
+
+
 void enable_random_syscalls(void)
 {
 unsigned int i;
",515,128
revert debug code accidentally committed.," void sanitise_socket(int childno)
 
 
 case AF_INET6:
-//DEBUG CODE
-type = SOCK_DGRAM;// UDP
-protocol = IPPROTO_UDP;
-break;
-
 switch (rand() % 3) {
 case 0:type = SOCK_STREAM;// TCP
 protocol = 0;
",250,69
"do validation at the end, after we've done with -r etc"," static int munge_tables(void)
 return FALSE;
 }
 
-if (validate_syscall_tables() == FALSE) {
-printf(""No syscalls were enabled!\n"");
-printf(""Use 32bit:%d 64bit:%d\n"", use_32bit, use_64bit);
-return FALSE;
-}
-
 if (random_selection == TRUE)
 enable_random_syscalls();
 
-
 /* If we saw a '-x', set all syscalls to enabled, then selectively disable.
  * Unless we've started enabling them already (with -r)
  */
 static int munge_tables(void)
 if (verbose == TRUE)
 display_enabled_syscalls();
 
+if (validate_syscall_tables() == FALSE) {
+printf(""No syscalls were enabled!\n"");
+printf(""Use 32bit:%d 64bit:%d\n"", use_32bit, use_64bit);
+return FALSE;
+}
+
 return TRUE;
 }
 
",181,32
disable VM/VFS syscalls if we -n," static int munge_tables(void)
 deactivate_disabled_syscalls();
 }
 
+/* if we passed -n, make sure there's no VM/VFS syscalls enabled. */
+if (no_files == TRUE)
+disable_non_net_syscalls();
+
 sanity_check_tables();
 
 count_syscalls_enabled();
",183,33
print out syscall number for non-biarch -L," void dump_syscall_tables(void)
 } else {
 printf(""syscalls: %d\n"", max_nr_syscalls);
 for_each_syscall(i) {
-printf(""%s : "", syscalls[i].entry->name);
+printf(""%d %s : "", syscalls[i].entry->number, syscalls[i].entry->name);
 show_state(syscalls[i].entry->flags & ACTIVE);
 if (syscalls[i].entry->flags & AVOID_SYSCALL)
 printf("" AVOID"");
",558,139
lower priority of debug message," static void fork_children(void)
 
 ret = child_process(pidslot);
 
-output(0, ""child %d exiting\n"", getpid());
+output(1, ""child %d exiting\n"", getpid());
 
 _exit(ret);
 }
",297,59
use correct type for mode," static unsigned long fill_arg(int childno, int call, int argnum)
 const unsigned int *values = NULL;
 enum argtype argtype = 0;
 unsigned long sockaddr = 0, sockaddrlen = 0;
-unsigned int bit, mode = 0, j, count;
+unsigned int bit, j, count;
+mode_t mode = 0;
 
 switch (argnum) {
 case 1:argtype = syscalls[call].entry->arg1type;
",287,106
skeleton for SOL_NFC setsockopt support later," void sanitise_setsockopt(int childno)
 
 /* First we pick a level */
 
-switch (rand() % 33) {
+switch (rand() % 34) {
 case 0:level = SOL_IP;break;
 case 1:level = SOL_SOCKET; break;
 case 2:level = SOL_TCP; break;
 void sanitise_setsockopt(int childno)
 case 30: level = SOL_IUCV; break;
 case 31: level = SOL_CAIF; break;
 case 32: level = SOL_ALG; break;
+case 33: level = SOL_NFC; break;
 default:
 level = rand();
 break;
 void sanitise_setsockopt(int childno)
 case SOL_ALG:/* no setsockopt */
 break;
 
+case SOL_NFC:
+//TODO.
+break;
 
 default:
 shm->a3[childno] = (rand() % 0xff);/* random operation. */
",280,97
new rand-page mode: page of 0's and 1's," static void fabricate_onepage_struct(char *page)
 void generate_random_page(char *page)
 {
 unsigned int i;
-unsigned int type = rand() % 5;
+unsigned int type = rand() % 6;
 
 switch (type) {
 /* return a page of complete trash */
 void generate_random_page(char *page)
 case 4:gen_unicode_page(page);
 return;
 
+/* page of 0's and 1's. */
+case 5:
+for (i = 0; i < page_size; i++)
+page[i++] = (unsigned char)rand() % 1;
+return;
+
 default:
 BUG(""unreachable!\n"");
 return;
",67,17
move NFC support out of sockaddr.c into its own file,"
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+#include <netinet/in.h>
+#include <stdlib.h>
+#include ""config.h""
+#include ""compat.h""
+
+void gen_nfc(unsigned long *addr, unsigned long *addrlen)
+{
+struct sockaddr_nfc *nfc;
+
+// TODO: See also sockaddr_nfc_llcp
+nfc = malloc(sizeof(struct sockaddr_nfc));
+if (nfc == NULL)
+return;
+
+nfc->sa_family = PF_NFC;
+nfc->dev_idx = rand();
+nfc->target_idx = rand();
+nfc->nfc_protocol = rand() % 5;
+*addr = (unsigned long) nfc;
+*addrlen = sizeof(struct sockaddr_nfc);
+}
",20,2
move ax25 sockaddr code out to its own file,"
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+#include <netinet/in.h>
+#include <linux/ax25.h>
+#include <stdlib.h>
+#include ""maps.h""// page_rand
+
+void gen_ax25(unsigned long *addr, unsigned long *addrlen)
+{
+struct sockaddr_ax25 *ax25;
+
+ax25 = malloc(sizeof(struct sockaddr_ax25));
+if (ax25 == NULL)
+return;
+
+ax25->sax25_family = PF_AX25;
+strncpy(ax25->sax25_call.ax25_call, page_rand, 7);
+ax25->sax25_ndigis = rand();
+*addr = (unsigned long) ax25;
+*addrlen = sizeof(struct sockaddr_ax25);
+}
",19,2
move ipx sockaddr code out to own file,"
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+#include <netinet/in.h>
+#include <linux/ipx.h>
+#include <stdlib.h>
+
+void gen_ipx(unsigned long *addr, unsigned long *addrlen)
+{
+struct sockaddr_ipx *ipx;
+unsigned int i;
+
+ipx = malloc(sizeof(struct sockaddr_ipx));
+if (ipx == NULL)
+return;
+
+ipx->sipx_family = PF_IPX;
+ipx->sipx_port = rand();
+ipx->sipx_network = rand();
+for (i = 0; i < 6; i++)
+ipx->sipx_node[i] = rand();
+ipx->sipx_type = rand();
+ipx->sipx_zero = rand() % 2;
+*addr = (unsigned long) ipx;
+*addrlen = sizeof(struct sockaddr_ipx);
+}
",23,3
move appletalk sockaddr code out to own file,"
+#include <stdlib.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+#include <netinet/in.h>
+#include <linux/atalk.h>
+
+void gen_appletalk(unsigned long *addr, unsigned long *addrlen)
+{
+struct sockaddr_at *atalk;
+
+atalk = malloc(sizeof(struct sockaddr_at));
+if (atalk == NULL)
+return;
+
+atalk->sat_family = PF_APPLETALK;
+atalk->sat_port = rand();
+atalk->sat_addr.s_net = rand();
+atalk->sat_addr.s_node = rand();
+*addr = (unsigned long) atalk;
+*addrlen = sizeof(struct sockaddr_at);
+}
",19,2
move atmpvc sockaddr code out to separate file,"
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+#include <netinet/in.h>
+#include <linux/atm.h>
+#include <stdlib.h>
+
+void gen_atmpvc(unsigned long *addr, unsigned long *addrlen)
+{
+struct sockaddr_atmpvc *atmpvc;
+
+atmpvc = malloc(sizeof(struct sockaddr_atmpvc));
+if (atmpvc == NULL)
+return;
+
+atmpvc->sap_family = PF_ATMPVC;
+atmpvc->sap_addr.itf = rand();
+atmpvc->sap_addr.vpi = rand();
+atmpvc->sap_addr.vci = rand();
+*addr = (unsigned long) atmpvc;
+*addrlen = sizeof(struct sockaddr_atmpvc);
+}
",19,2
move x25 sockaddr code out to own file,"
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+#include <netinet/in.h>
+#include <linux/x25.h>
+#include <stdlib.h>
+#include ""maps.h""// page_rand
+
+void gen_x25(unsigned long *addr, unsigned long *addrlen)
+{
+struct sockaddr_x25 *x25;
+unsigned int len;
+
+x25 = malloc(sizeof(struct sockaddr_x25));
+if (x25 == NULL)
+return;
+
+x25->sx25_family = PF_X25;
+len = rand() % 15;
+memset(&page_rand[len], 0, 1);
+strncpy(x25->sx25_addr.x25_addr, page_rand, len);
+*addr = (unsigned long) x25;
+*addrlen = sizeof(struct sockaddr_x25);
+}
",21,2
move rose sockaddr code out to own file,"
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+#include <netinet/in.h>
+#include <linux/rose.h>
+#include <stdlib.h>
+#include ""maps.h""// page_rand
+
+void gen_rose(unsigned long *addr, unsigned long *addrlen)
+{
+struct sockaddr_rose *rose;
+
+rose = malloc(sizeof(struct sockaddr_rose));
+if (rose == NULL)
+return;
+
+rose->srose_family = PF_ROSE;
+rose->srose_addr.rose_addr[0] = rand();
+rose->srose_addr.rose_addr[1] = rand();
+rose->srose_addr.rose_addr[2] = rand();
+rose->srose_addr.rose_addr[3] = rand();
+rose->srose_addr.rose_addr[4] = rand();
+
+strncpy(rose->srose_call.ax25_call, page_rand, 7);
+
+rose->srose_ndigis = rand();
+strncpy(rose->srose_digi.ax25_call, page_rand+7, 7);
+
+*addr = (unsigned long) rose;
+*addrlen = sizeof(struct sockaddr_rose);
+}
",25,2
move decnet sockaddr code out to own file,"
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+#include <netinet/in.h>
+#include <linux/dn.h>
+#include <stdlib.h>
+
+void gen_decnet(unsigned long *addr, unsigned long *addrlen)
+{
+struct sockaddr_dn *dn;
+unsigned int i;
+
+dn = malloc(sizeof(struct sockaddr_dn));
+if (dn == NULL)
+return;
+
+dn->sdn_family = PF_DECnet;
+dn->sdn_flags = rand();
+dn->sdn_objnum = rand();
+dn->sdn_objnamel = rand() % 16;
+for (i = 0; i < dn->sdn_objnamel; i++)
+dn->sdn_objname[i] = rand();
+dn->sdn_add.a_len = rand() % 2;
+dn->sdn_add.a_addr[0] = rand();
+dn->sdn_add.a_addr[1] = rand();
+*addr = (unsigned long) dn;
+*addrlen = sizeof(struct sockaddr_dn);
+}
",25,3
move llc sockaddr code out to own file,"
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+#include <netinet/in.h>
+#include <linux/if.h>
+#include <linux/if_arp.h>
+#include <linux/llc.h>
+#include <stdlib.h>
+
+void gen_llc(unsigned long *addr, unsigned long *addrlen)
+{
+struct sockaddr_llc *llc;
+unsigned int i;
+
+llc = malloc(sizeof(struct sockaddr_llc));
+if (llc == NULL)
+return;
+llc->sllc_family = AF_LLC;
+llc->sllc_arphrd = ARPHRD_ETHER;
+llc->sllc_test = rand();
+llc->sllc_xid = rand();
+llc->sllc_ua = rand();
+llc->sllc_sap = rand();
+for (i = 0; i < IFHWADDRLEN; i++)
+llc->sllc_mac[i] = rand();
+*addr = (unsigned long) llc;
+*addrlen = sizeof(struct sockaddr_llc);
+}
",26,3
move netlink sockaddr code out to own file,"
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+#include <netinet/in.h>
+#include <linux/netlink.h>
+#include <stdlib.h>
+
+void gen_netlink(unsigned long *addr, unsigned long *addrlen)
+{
+struct sockaddr_nl *nl;
+
+nl = malloc(sizeof(struct sockaddr_nl));
+if (nl == NULL)
+return;
+
+nl->nl_family = PF_NETLINK;
+nl->nl_pid = rand();
+nl->nl_groups = rand();
+*addr = (unsigned long) nl;
+*addrlen = sizeof(struct sockaddr_nl);
+}
",18,2
move packet sockaddr code out to own file,"
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+#include <netinet/in.h>
+#include <linux/if_packet.h>
+#include <stdlib.h>
+
+void gen_packet(unsigned long *addr, unsigned long *addrlen)
+{
+struct sockaddr_pkt *pkt;
+unsigned int i;
+
+//TODO: See also sockaddr_ll
+pkt = malloc(sizeof(struct sockaddr_pkt));
+if (pkt == NULL)
+return;
+
+pkt->spkt_family = PF_PACKET;
+for (i = 0; i < 14; i++)
+pkt->spkt_device[i] = rand();
+*addr = (unsigned long) pkt;
+*addrlen = sizeof(struct sockaddr_pkt);
+}
",19,3
move econet sockaddr code out to own file,"
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+#include <netinet/in.h>
+#include <neteconet/ec.h>
+#include <stdlib.h>
+
+void gen_econet(unsigned long *addr, unsigned long *addrlen)
+{
+struct sockaddr_ec *ec;
+
+ec = malloc(sizeof(struct sockaddr_ec));
+if (ec == NULL)
+return;
+
+ec->sec_family = PF_ECONET;
+ec->port = rand();
+ec->cb = rand();
+ec->type = rand();
+ec->addr.station = rand();
+ec->addr.net = rand();
+ec->cookie = rand();
+*addr = (unsigned long) ec;
+*addrlen = sizeof(struct sockaddr_ec);
+}
",22,2
"move atmsvc sockaddr code into own file too, along with the other atm code.

(and rename)","
 #include <sys/socket.h>
 #include <sys/un.h>
 #include <netinet/in.h>
-#include <linux/atm.h>
 #include <linux/if.h>
 #include <linux/if_arp.h>
 #include <linux/irda.h>

 #include ""config.h""
 #include ""params.h""// do_specific_proto
 
-static void gen_atmsvc(unsigned long *addr, unsigned long *addrlen)
-{
-struct sockaddr_atmsvc *atmsvc;
-unsigned int i;
-
-atmsvc = malloc(sizeof(struct sockaddr_atmsvc));
-if (atmsvc == NULL)
-return;
-
-atmsvc->sas_family = PF_ATMSVC;
-for (i = 0; i < ATM_ESA_LEN; i++)
-atmsvc->sas_addr.prv[i] = rand();
-for (i = 0; i < ATM_E164_LEN; i++)
-atmsvc->sas_addr.pub[i] = rand();
-atmsvc->sas_addr.lij_type = rand();
-atmsvc->sas_addr.lij_id = rand();
-*addr = (unsigned long) atmsvc;
-*addrlen = sizeof(struct sockaddr_atmsvc);
-}
-
 static void gen_irda(unsigned long *addr, unsigned long *addrlen)
 {
 struct sockaddr_irda *irda;
",191,53
move irda sockaddr code out to own file,"
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+#include <netinet/in.h>
+#include <linux/irda.h>
+#include <stdlib.h>
+
+void gen_irda(unsigned long *addr, unsigned long *addrlen)
+{
+struct sockaddr_irda *irda;
+unsigned int i;
+
+irda = malloc(sizeof(struct sockaddr_irda));
+if (irda == NULL)
+return;
+
+irda->sir_family = PF_IRDA;
+irda->sir_lsap_sel = rand();
+irda->sir_addr = rand();
+for (i = 0; i < 25; i++)
+irda->sir_name[i] = rand();
+*addr = (unsigned long) irda;
+*addrlen = sizeof(struct sockaddr_irda);
+}
",21,3
move CAN sockaddr code out to own file,"
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+#include <netinet/in.h>
+#include <linux/can.h>
+#include <stdlib.h>
+
+void gen_can(unsigned long *addr, unsigned long *addrlen)
+{
+struct sockaddr_can *can;
+
+can = malloc(sizeof(struct sockaddr_can));
+if (can == NULL)
+return;
+can->can_family = AF_CAN;
+can->can_ifindex = rand();
+can->can_addr.tp.rx_id = rand();
+can->can_addr.tp.tx_id = rand();
+*addr = (unsigned long) can;
+*addrlen = sizeof(struct sockaddr_can);
+}
",19,2
move tipc sockaddr code out to own file,"
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+#include <netinet/in.h>
+#include <linux/tipc.h>
+#include <stdlib.h>
+
+void gen_tipc(unsigned long *addr, unsigned long *addrlen)
+{
+struct sockaddr_tipc *tipc;
+
+tipc = malloc(sizeof(struct sockaddr_tipc));
+if (tipc == NULL)
+return;
+tipc->family = AF_TIPC;
+tipc->addrtype = rand();
+tipc->scope = rand();
+tipc->addr.id.ref = rand();
+tipc->addr.id.node = rand();
+tipc->addr.nameseq.type = rand();
+tipc->addr.nameseq.lower = rand();
+tipc->addr.nameseq.upper = rand();
+tipc->addr.name.name.type = rand();
+tipc->addr.name.name.instance = rand();
+tipc->addr.name.domain = rand();
+*addr = (unsigned long) tipc;
+*addrlen = sizeof(struct sockaddr_tipc);
+}
",26,2
move phonet sockaddr code out to own file,"
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+#include <netinet/in.h>
+#include <linux/phonet.h>
+#include <stdlib.h>
+
+void gen_phonet(unsigned long *addr, unsigned long *addrlen)
+{
+struct sockaddr_pn *pn;
+
+pn = malloc(sizeof(struct sockaddr_pn));
+if (pn == NULL)
+return;
+
+pn->spn_family = PF_PHONET;
+pn->spn_obj = rand();
+pn->spn_dev = rand();
+pn->spn_resource = rand();
+*addr = (unsigned long) pn;
+*addrlen = sizeof(struct sockaddr_pn);
+}
",19,2
"50% of the time, write a single byte","
 static void sanitise_write(int childno)
 {
 shm->a2[childno] = (unsigned long) page_rand;
-shm->a3[childno] = rand() % page_size;
+if ((rand() % 100) > 50)
+shm->a3[childno] = 1;
+else
+shm->a3[childno] = rand() % page_size;
 }
 
 struct syscall syscall_write = {
",25,2
"perf_event_open updates

- add missing PERF_COUNT_HW_REF_CPU_CYCLES
- use get_len for more interesting lengths than rand()"," static void sanitise_perf_event_open(int childno)
 
 switch(rand() % 6) {
 case 0:hw->type = PERF_TYPE_HARDWARE;
-switch(rand() % 9) {
+switch(rand() % 10) {
 case 0: hw->config=PERF_COUNT_HW_CPU_CYCLES;
 break;
 case 1: hw->config=PERF_COUNT_HW_INSTRUCTIONS;
 static void sanitise_perf_event_open(int childno)
 break;
 case 7: hw->config=PERF_COUNT_HW_STALLED_CYCLES_BACKEND;
 break;
-case 8: hw->config = rand();
+case 8: hw->config=PERF_COUNT_HW_REF_CPU_CYCLES;
+break;
+case 9: hw->config = rand();
 break;
 default: break;
 }
 static void sanitise_perf_event_open(int childno)
 switch(rand() % 2) {
 case 0: hw->size = sizeof(struct perf_event_attr);
 break;
-case 1: hw->size = rand();
+case 1: hw->size = get_len();
 default: break;
 }
 }
",99,29
make sure we clear reserved bits in perf struct,"
 */
 
 #include <stdlib.h>
+#include <string.h>
 #include <linux/perf_event.h>
 #include ""sanitise.h""
 #include ""compat.h""
 static void sanitise_perf_event_open(int childno)
 shm->a1[childno] = (unsigned long) page_rand;
 hw = (struct perf_event_attr *) shm->a1[childno];
 
+/* this makes sure we clear out the reserved fields. */
+memset(page_rand, 0, sizeof(struct perf_event_attr));
+
 switch(rand() % 6) {
 case 0:hw->type = PERF_TYPE_HARDWARE;
 switch(rand() % 10) {
",101,29
fill out some more fields," static void sanitise_perf_event_open(int childno)
 case 1: attr->size = get_len();
 default: break;
 }
+
+attr->sample_type = rand() % PERF_SAMPLE_MAX;
+attr->read_format = rand() % PERF_FORMAT_MAX;
+attr->exclude_kernel = TRUE;// FIXME: root-mode
 }
 
 struct syscall syscall_perf_event_open = {
",104,29
"net: add generation of semi-random BPF filters

BPF filters are used in networking and in application sand-boxing
and even have a arch-dependant JIT compiler in the kernel, so add
a more detailed semi-random BPF generator.

Signed-off-by: Daniel Borkmann <dborkman@redhat.com>","
 #include ""compat.h""
 #include ""maps.h""
 #include ""shm.h""
+#include ""net.h""
 #include ""config.h""
 #include ""syscalls/setsockopt.h""
 
 void sanitise_setsockopt(int childno)
 shm->a5[childno] = sizeof(struct timeval);
 break;
 case SO_ATTACH_FILTER:
+gen_bpf((unsigned long *) page_rand, NULL);
 shm->a5[childno] = sizeof(struct sock_fprog);
 break;
 default:
",282,97
"net: bpf: increase the chance that the semi-random bpf is run

The kernel filter code expects us to have a return instruction and
that won't be changed in the kernel code. So increase the chance that
we can also get past the filter precheck and run this fuzzed filter
code.

Signed-off-by: Daniel Borkmann <dborkman@redhat.com>"," static const uint16_t bpf_misc_vars[] = {
 #define bpf_rand(type) \
 (bpf_##type##_vars[rand() % ARRAY_SIZE(bpf_##type##_vars)])
 
-static uint16_t gen_bpf_code(void)
+static uint16_t gen_bpf_code(bool last_instr)
 {
 uint16_t ret = bpf_rand(class);
 
+if (last_instr) {
+/* The kernel filter precheck code already tests if
+ * there's a return instruction as the last one, so
+ * increase the chance to be accepted and that we
+ * actually run the generated fuzz filter code.
+ */
+if (rand() % 2 == 0)
+ret = BPF_RET;
+}
+
 switch (ret) {
 case BPF_LD:
 case BPF_LDX:
 void gen_bpf(unsigned long *addr, unsigned long *addrlen)
 for (i = 0; i < bpf->len; i++) {
 memset(&bpf->filter[i], 0, sizeof(bpf->filter[i]));
 
-bpf->filter[i].code = gen_bpf_code();
+bpf->filter[i].code = gen_bpf_code(i == bpf->len - 1);
 
 /* Fill out jump offsets if jmp instruction */
 if (BPF_CLASS(bpf->filter[i].code) == BPF_JMP) {
",108,28
fix off by 1 rand usage," unsigned int new_seed(void)
 unsigned int r;
 
 r = rand();
-if (!(rand() % 1)) {
+if (!(rand() % 2)) {
 gettimeofday(&t, 0);
 r |= t.tv_usec;
 }
",58,11
"fix random switches and page construction

Fix truncated page construction, as well as several unreachable switch
statements. Make interesting 32bit number actually 32 bits. Add additional
64 bit construction with high 32bits from interesting-32.

Signed-off-by: Kees Cook <keescook@chromium.org>"," char * generate_pathname(void)
 if ((rand() % 100) > 10)
 return get_filename();
 
-case 91 ... 100:
+case 91 ... 99:
 /* Create a bogus filename. */
 newpath = malloc(page_size);// FIXME: We leak this.
 if (newpath == NULL)
",297,72
"fix tpacket3_hdr build failure

It is declared iff TPACKET3_HDRLEN is..."," void sanitise_setsockopt(int childno)
 break;
 case PACKET_TX_RING:
 case PACKET_RX_RING:
+#ifdef TPACKET3_HDRLEN
 if (rand() % 3 == 0)
 shm->a5[childno] = sizeof(struct tpacket_req3);
 else
+#endif
 shm->a5[childno] = sizeof(struct tpacket_req);
 break;
 default:
",282,98
Make ARG_RANDOM_INT a bit more interesting than rand()," static unsigned long fill_arg(int childno, int call, int argnum)
 switch (argtype) {
 case ARG_UNDEFINED:
 case ARG_RANDOM_INT:
-return (unsigned long) rand();
+return (unsigned long) rand64();
 
 case ARG_FD:
 return get_random_fd();
",280,103
move rand64 to random.h,"
 #include ""trinity.h""// page_size
 #include ""files.h""
 #include ""arch.h""
+#include ""random.h""
 #include ""sanitise.h""
 #include ""syscall.h""
 #include ""net.h""
",281,103
add a random bool helper," unsigned long rand64(void)
 }
 return r;
 }
+
+unsigned int rand_bool(void)
+{
+return rand() % 2;
+}
",89,21
introduce some routines to return single bits.,"
 #include <stdlib.h>
 #include ""arch.h""
 #include ""log.h""// for BUG
+#include ""random.h""
 
 unsigned int get_interesting_32bit_value(void)
 {
-unsigned int bit;
-
 switch (rand() % 11) {
 
 /* rare case, single bit. */
-case 0:
-bit = rand() % 32;
-return (1L << bit);
+case 0:return rand_single_32bit();
 
 /* common case, return small values*/
 case 1 ... 7:
 unsigned long get_interesting_value(void)
 
 low = get_interesting_32bit_value();
 
-switch (rand() % 16) {
+switch (rand() % 17) {
 case 0: return 0;
 case 1: return low;
 case 2: return 0x0000000100000000;
 unsigned long get_interesting_value(void)
 case 13: return MODULE_ADDR | (low & 0xffffff);
 case 14: return per_arch_interesting_addr(low);
 case 15: return (low << 32);
+case 16: return rand_single_64bit();
 default: break;
 }
 BUG(""unreachable!\n"");
",94,50
add an extra short circuit if 0," unsigned long get_len(void)
 
 i = get_interesting_value();
 
+/* short circuit if 0 */
 if (i == 0)
 return 0;
 
 unsigned long get_len(void)
 break;
 }
 
+/* again, short circuit if 0 */
+if (i == 0)
+return 0;
+
 /* we might get lucky if something is counting ints/longs etc. */
 if (rand() % 100 < 25) {
 switch (rand() % 3) {
",39,12
"introduce rand32

to be used in places instead of rand(), to stress the single-bit cases some.
(later, I'll bias it so that rand() is what gets called most the time)"," unsigned long rand_single_64bit(void)
 return (1L << (rand() % 64));
 }
 
+unsigned int rand32(void)
+{
+unsigned long r = 0;
+
+switch (rand() % 3) {
+
+/* Just set one bit */
+case 0:return rand_single_32bit();
+
+/* 0 .. RAND_MAX */
+case 1:r = rand();
+if (rand_bool())
+r |= (1<<31);
+break;
+
+case 2:return get_interesting_32bit_value();
+
+default:
+break;
+}
+return r;
+}
+
 unsigned long rand64(void)
 {
 unsigned long r = 0;
",114,30
flip high bit randomly.," unsigned int rand32(void)
 /* 0 .. RAND_MAX */
 case 1:r = rand();
 if (rand_bool())
-r |= (1<<31);
+r |= (1L << 31);
 break;
 
 case 2:return get_interesting_32bit_value();
 unsigned long rand64(void)
 default:
 break;
 }
+
+if (rand_bool())
+r |= (1L << 63);
+
 return r;
 }
",116,31
"Some older distros don't have hw_breakpoint.h

Just dupe it in compat.h, seeing as it's so small.","
 #include <stdlib.h>
 #include <string.h>
 #include <linux/perf_event.h>
-#include <linux/hw_breakpoint.h>
 #include ""random.h""
 #include ""sanitise.h""
 #include ""compat.h""
",342,106
"socket: packet: mostly use ETH_P_ALL protocol, but also randomize it

Probably that's jut minor, but mostly use ETH_P_ALL as a protocol
and in some minor cases allow to randomize it.

Signed-off-by: Daniel Borkmann <dborkman@redhat.com>","
 #include <netinet/in.h>
 #include <linux/irda.h>
 #include <linux/dn.h>
+#include <linux/if_ether.h>
 #include ""compat.h""
 #include ""log.h""
 #include ""net.h""
 void sanitise_socket(int childno)
 break;
 
 case AF_PACKET:
+protocol = htons(ETH_P_ALL);
+if (rand() % 8 == 0) {
+protocol = rand();
+if (rand() % 2 == 0)
+protocol = (uint16_t) rand();
+}
 switch (rand() % 3) {
 case 0:type = SOCK_DGRAM;
 break;
",257,71
"random: use /dev/urandom for reseeding if available

Use a real source of randomness for reseeding, if available. Otherwise,
reseeding is only permuted by time.

Signed-off-by: Kees Cook <keescook@chromium.org>","
 #include <syslog.h>
 #include <unistd.h>
 #include <stdlib.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
 #include ""shm.h""
 #include ""params.h""// 'user_set_seed'
 #include ""log.h""
 static void syslog_seed(int seedparam)
 
 unsigned int new_seed(void)
 {
+int fd;
 struct timeval t;
 unsigned int r;
 
-r = rand();
-if (!(rand() % 2)) {
-gettimeofday(&t, 0);
-r |= t.tv_usec;
+if ((fd = open(""/dev/urandom"", O_RDONLY)) < 0 ||
+ read(fd, &r, sizeof(r)) != sizeof(r)) {
+r = rand();
+if (!(rand() % 2)) {
+gettimeofday(&t, 0);
+r |= t.tv_usec;
+}
 }
+if (fd >= 0)
+close(fd);
 return r;
 }
 
 unsigned int init_seed(unsigned int seedparam)
 else {
 seedparam = new_seed();
 
-printf(""Initial random seed from time of day: %u\n"", seedparam);
+printf(""Initial random seed: %u\n"", seedparam);
 }
 
 if (do_syslog == TRUE)
",125,34
don't ignore no-input syscalls.," static void validate_specific_syscall(const struct syscalltable *table, int call
 
 if (table[call].entry->flags & NI_SYSCALL)
 printf(""%s is NI_SYSCALL. Skipping\n"", table[call].entry->name);
-
-if (table[call].entry->num_args == 0)
-printf(""%s has no arguments. Skipping\n"", table[call].entry->name);
 }
 
 int validate_specific_syscall_silent(const struct syscalltable *table, int call)
 int validate_specific_syscall_silent(const struct syscalltable *table, int call)
 if (table[call].entry->flags & NI_SYSCALL)
 return FALSE;
 
-if (table[call].entry->num_args == 0)
-return FALSE;
-
 return TRUE;
 }
 
",580,150
"when disabling a syscall for ENOSYS, handle biarch too

This isn't strictly the right thing to do here, but it works around
an ugly infinite loop bug that I don't have a good fix for yet."," long mkcall(int childno)
 {
 unsigned long olda1, olda2, olda3, olda4, olda5, olda6;
 unsigned int call = shm->syscallno[childno];
-
+unsigned int call32, call64;
 int ret = 0, errno_saved;
 char string[512], *sptr;
 
 args_done:
 goto skip_enosys;
 
 output(1, ""%s (%d) returned ENOSYS, marking as inactive.\n"", syscalls[call].entry->name, call);
-syscalls[call].entry->flags &= ~ACTIVE;
+
+if (biarch == FALSE) {
+syscalls[call].entry->flags &= ~ACTIVE;
+} else {
+call32 = search_syscall_table(syscalls_32bit, max_nr_32bit_syscalls, syscalls[call].entry->name);
+syscalls_32bit[call32].entry->flags &= ~ACTIVE;
+call64 = search_syscall_table(syscalls_64bit, max_nr_64bit_syscalls, syscalls[call].entry->name);
+syscalls_64bit[call64].entry->flags &= ~ACTIVE;
+output(1, ""Disabled syscalls 32bit:%d 64bit:%d\n"", call32, call64);
+}
 }
 
 skip_enosys:
",172,27
check for syscalls still enabled in loop," int do_random_syscalls(int childno)
 // a better way would be to do something in tables.c where we construct
 // our own syscall table just containing enabled syscalls.
 retry:
+if (no_syscalls_enabled() == TRUE) {
+shm->exit_reason = EXIT_NO_SYSCALLS_ENABLED;
+goto out;
+}
+
 if (shm->exit_reason != STILL_RUNNING)
 goto out;
 
",77,19
fix highest netlink socket proto,"
 #include <linux/irda.h>
 #include <linux/dn.h>
 #include <linux/if_ether.h>
+#include <linux/netlink.h>
 #include ""compat.h""
 #include ""log.h""
 #include ""net.h""
 void sanitise_socket(int childno)
 case 1:type = SOCK_DGRAM;
 default:break;
 }
-protocol = rand() % 32;// MAX_LINKS
+protocol = rand() % (NETLINK_CRYPTO + 1);// Current highest netlink socket.
 break;
 
 case AF_NFC:
",258,71
"net: bpf: let clang shut up

Let clang warning shut up and initialize the allocated area
with zeroes.

 CC	net/bpf.o
net/bpf.c:297:16: warning: The left expression of the compound assignment
 is an uninitialized value. The computed value will also be garbage
 curr[1].code |= (uint16_t) rand();
 ~~~~~~~~~~~~ ^
net/bpf.c:299:16: warning: The left expression of the compound assignment
 is an uninitialized value. The computed value will also be garbage
 curr[2].code |= (uint16_t) rand();
 ~~~~~~~~~~~~ ^

Reported-by: Dave Jones <davej@redhat.com>
Signed-off-by: Daniel Borkmann <dborkman@redhat.com>"," void gen_seccomp_bpf(unsigned long *addr, unsigned long *addrlen)
 return;
 }
 
+memset(bpf->filter, 0, bpf->len * sizeof(struct sock_filter));
+
 seccomp_state = seccomp_choose(seccomp_markov_init);
+
 for (curr = bpf->filter; avail > 3; ) {
 used = gen_seccomp_bpf_code(curr);
 curr += used;
 avail -= used;
+
 seccomp_state = seccomp_choose(seccomp_markov[seccomp_state]);
 }
 
",256,49
"minor: move offsetof into trinity.h

Move it there since it's of generic use somewhere in future
else as well.

Signed-off-by: Daniel Borkmann <dborkman@redhat.com>","
 # define SKF_AD_MAX56
 #endif
 
-#ifndef offsetof
-# define offsetof(type, member)((size_t) &((type *) 0)->member)
-#endif
-
 #define syscall_nr(offsetof(struct seccomp_data, nr))
 #define arch_nr(offsetof(struct seccomp_data, arch))
 
",256,49
"Read pid_max from /proc

I was hitting this on my system, where it's 65536. So fix the todo and
read it from /proc.

I left a fallback to the hardcoded values in case /proc is not mounted
or something else goes wrong."," void dump_pid_slots(void)
 printf(""## slot%d: %d\n"", i, shm->pids[i]);
 }
 
-int pid_is_valid(pid_t pid)
+static pid_t pidmax;
+
+int read_pid_max(void)
 {
-pid_t pidmax;
+unsigned long result;
+char *end, buf[32];
+FILE *fp;
+int rc;
+
+fp = fopen(""/proc/sys/kernel/pid_max"", ""r"");
+if (!fp) {
+perror(""fopen"");
+return -1;
+}
+
+rc = -1;
+if (!fgets(buf, sizeof(buf), fp))
+goto out;
+
+result = strtoul(buf, &end, 10);
+if (end == buf)
+goto out;
+
+pidmax = result;
+rc = 0;
+out:
+fclose(fp);
+return rc;
+}
 
-// FIXME: Read this from /proc/sys/kernel/pid_max on startup
+void pids_init(void)
+{
+if (read_pid_max()) {
 #ifdef __x86_64__
-pidmax = 4194304;
+pidmax = 4194304;
 #else
-pidmax = 32768;
+pidmax = 32768;
 #endif
+printf(""Couldn't read pid_max from proc\n"");
+}
+
+printf(""Using pid_max = %d\n"", pidmax);
+}
 
+int pid_is_valid(pid_t pid)
+{
 if ((pid > pidmax) || (pid < 1)) {
 output(0, ""Sanity check failed! Found pid %d!\n"", pid);
 return FALSE;
",94,22
"use config.h in USE_* users

Sometimes we use USE_* macros but do not include config.h. Fix that.","
 #include <linux/if_ether.h> /* for ETH_ALEN in if_pppox.h */
 #include <linux/if_pppox.h>
 #include <stdlib.h>
+#include ""config.h""
 #include ""net.h""
 #include ""sanitise.h""
 
",133,20
"detect seccomp

It is not defined on some older systems:
syscalls/prctl.c:7:27: error: linux/seccomp.h: No such file or directory
syscalls/prctl.c:37: error: 'SECCOMP_MODE_FILTER' undeclared (first use in this function)","
 * SYSCALL_DEFINE5(prctl, int, option, unsigned long, arg2, unsigned long, arg3,
  unsigned long, arg4, unsigned long, arg5)
 */
+#include ""config.h""
+
 #include <stdlib.h>
 #include <linux/prctl.h>
+#ifdef USE_SECCOMP
 #include <linux/seccomp.h>
+#endif
 #include <sys/prctl.h>
 
 #include ""sanitise.h""
 void sanitise_prctl(int childno)
 
 switch (option) {
 case PR_SET_SECCOMP:
+#ifdef USE_SECCOMP
 if (rand() % 3 == SECCOMP_MODE_FILTER) {
 gen_seccomp_bpf((unsigned long *) page_rand, NULL);
 
 shm->a2[childno] = SECCOMP_MODE_FILTER;
 shm->a3[childno] = (unsigned long) page_rand;
 }
+#endif
 break;
 default:
 break;
",46,5
"compat: define some more

syscalls/prctl.c:27: error: 'PR_MCE_KILL_GET' undeclared here (not in a function)
syscalls/socket.c:178: error: 'NETLINK_CRYPTO' undeclared (first use in this function)

[v2]
 - include compat.h at the end, otherwise we fail to build on some
 configs","
 #include ""net.h""
 #include ""maps.h""
 #include ""shm.h""
+#include ""compat.h""
 
 #define NR_PRCTL_OPTS 28
 static int prctl_opts[NR_PRCTL_OPTS] = {
",47,5
skip ANSI_RESET correctly in log files.," void output(unsigned char level, const char *fmt, ...)
 len = strlen(outputbuf);
 for (i = 0, j = 0; i < len; i++) {
 if (outputbuf[i] == '')
-i += 6;
+if (outputbuf[i + 2] == '1')
+i += 6;// ANSI_COLOUR
+else
+i += 3;// ANSI_RESET
 else {
 monobuf[j] = outputbuf[i];
 j++;
",143,26
simplify output string in syscall," args_done:
 CRESET
 shm->successes++;
 }
-sptr += sprintf(sptr, ""\n"");
 
 *sptr = '\0';
 
-output(2, ""%s"", string);
+output(2, ""%s\n"", string);
 
 /* If the syscall doesn't exist don't bother calling it next time. */
 if ((ret == -1) && (errno_saved == ENOSYS)) {
",171,27
"Handle error return from syscalls correctly.

Successful returns from mmap were being flagged as errors for eg.

Also if successful return > 10000, print it in hex"," extern unsigned int user_specified_children;
 # define offsetof(type, member)((size_t) &((type *) 0)->member)
 #endif
 
+#define MAX_ERRNO 4095
+#define IS_ERR_VALUE(x) ((x) >= (unsigned long)-MAX_ERRNO)
+static inline long IS_ERR(unsigned long x)
+{
+return IS_ERR_VALUE(x);
+}
+
+
 #endif/* _TRINITY_H */
",14,1
"Fix compile error in net/bpf.c for non x86

In bpf.c there is an architecture check with cases for i386, x86-64 and
""other"". But the other case typos TRUE_ARCH, leading to a build error."," static const uint32_t bpf_seccomp_jmp_arch_vars[] = {
 # define TRUE_ARCHAUDIT_ARCH_X86_64
 #else
 # define TRUE_REG_SYSCALL((uint32_t) rand()) /* TODO later */
-# define TRUE_ARCH_NR((uint32_t) rand()) /* TODO later */
+# define TRUE_ARCH((uint32_t) rand()) /* TODO later */
 #endif
 
 struct seccomp_data {
",256,49
"Sanity check the syscall number in print_syscall_name()

In case it's out of bounds, causing us to segfault."," try_64bit:
 const char * print_syscall_name(unsigned int callno, bool is32bit)
 {
 const struct syscalltable *table;
+unsigned int max;
 
-if (biarch == FALSE)
-return syscalls[callno].entry->name;
+if (biarch == FALSE) {
+max = max_nr_syscalls;
+table = syscalls;
+} else {
+if (is32bit == FALSE) {
+max = max_nr_64bit_syscalls;
+table = syscalls_64bit;
+} else {
+max = max_nr_32bit_syscalls;
+table = syscalls_32bit;
+}
+}
 
-if (is32bit == FALSE)
-table = syscalls_64bit;
-else
-table = syscalls_32bit;
+if (callno >= max) {
+printf(""Bogus syscall number in %s (%u)\n"", __func__, callno);
+return ""invalid-syscall"";
+}
 
 return table[callno].entry->name;
 }
",591,151
"make the watchdog keep check on the parent too, in case it crashes.

having the children be reparented makes things go crazy otherwise."," static void handle_children(void)
 }
 
 static const char *reasons[] = {
-""Still running"",
-""No more syscalls enabled"",
-""Reached maximum syscall count"",
-""No file descriptors open"",
-""Lost track of a pid slot"",
+""Still running."",
+""No more syscalls enabled."",
+""Reached maximum syscall count."",
+""No file descriptors open."",
+""Lost track of a pid slot."",
 ""shm corruption - Found a pid out of range."",
 ""ctrl-c"",
-""kernel became tainted"",
+""kernel became tainted."",
 ""SHM was corrupted!"",
 ""Child reparenting problem"",
-""No files in file list"",
+""No files in file list."",
+""Main process disappeared."",
 };
 
 static const char * decode_exit(unsigned int reason)
",298,59
"Specify domain in sanitise_socket

We should specify the domain in sanitise_socket().
If we pass a specific domain, we may otherwise get unrelated type and protocol.

Signed-off-by: Hangbin Liu <liuhangbin@gmail.com>"," void generate_sockets(void)
 /* Pretend we're child 0 and we've called sys_socket */
 sanitise_socket(0);
 
-//FIXME: If we passed a specific domain, we want to sanitise
-// the proto/type fields. Split it out of sanitise_socket()
-
-if (do_specific_proto == TRUE)
-domain = specific_proto;
-else
-domain = shm->a1[0];
-
+domain = shm->a1[0];
 type = shm->a2[0];
 protocol = shm->a3[0];
 
",184,34
be explicit with braces.," const char *map_dev(dev_t st_rdev, mode_t st_mode)
 major = MAJOR(st_rdev);
 minor = MINOR(st_rdev);
 
-if (S_ISCHR(st_mode))
-for (i=0; i < chrdevs; ++i)
+if (S_ISCHR(st_mode)) {
+for (i = 0; i < chrdevs; ++i) {
 if (char_devs[i].major == major) {
 if (strcmp(char_devs[i].name, ""misc"") == 0) {
 for (j=0; j < miscdevs; ++j)
 const char *map_dev(dev_t st_rdev, mode_t st_mode)
 } else
 return char_devs[i].name;
 }
-else if (S_ISBLK(st_mode))
-for (i=0; i < bldevs; ++i)
+}
+} else if (S_ISBLK(st_mode)) {
+for (i = 0; i < bldevs; ++i) {
 if (block_devs[i].major == major)
 return block_devs[i].name;
+}
+}
 
 return NULL;
 }
",111,23
"don't check ppid every syscall.

this dominates profiles, and isn't really necessary in the common case."," void check_parent_pid(void)
 {
 pid_t pid;
 unsigned int i;
+static unsigned int parent_check_time = 10;
+
+parent_check_time--;
+if (parent_check_time != 0)
+return;
+
+parent_check_time = 10;
 
 if (getppid() == shm->parentpid)
 return;
",120,23
"don't quit the watchdog process while there are still children running.

If we have a child stuck in a sleep, we need the watchdog around to kill it."," static void watchdog(void)
 {
 static const char watchdogname[17]=""trinity-watchdog"";
 static unsigned long lastcount = 0;
+bool watchdog_exit = FALSE;
 
 shm->watchdog_pid = getpid();
 printf(""[%d] Watchdog is alive\n"", shm->watchdog_pid);
 static void watchdog(void)
 prctl(PR_SET_NAME, (unsigned long) &watchdogname);
 (void)signal(SIGSEGV, SIG_DFL);
 
-while (shm->exit_reason == STILL_RUNNING) {
+while (watchdog_exit == FALSE) {
 
 if (shm->regenerating == FALSE) {
 
 static void watchdog(void)
 }
 }
 
+/* Are we done ? */
+if (shm->exit_reason != STILL_RUNNING) {
+/* Give children a chance to exit. */
+sleep(1);
+
+/* Are there still children running ? */
+if (pidmap_empty() == TRUE)
+watchdog_exit = TRUE;
+else
+output(0, ""[watchdog] exit_reason=%d, but %d children still running.\n"",
+shm->running_childs);
+}
+
 sleep(1);
 }
 
",223,46
"Fix divide by zero in random_sysfs_config

> [221186.493638] traps: trinity-child30[375] trap divide error
> ip:40dbae sp:7fff3c1d7ae0 error:0 in trinity[400000+28000]

Signed-off-by: Vince Weaver <vincent.weaver@maine.edu>"," static long long random_sysfs_config(__u32 *type, __u64 *config1) {
 int i,j;
 long long c=0,c1=0;
 
+if (num_pmus==0) {
+/* For some reason we didn't get initialized */
+/* Fake it so we don't divide by zero */
+*type=rand32();
+*config1=rand64();
+return rand64();
+}
+
 i=rand()%num_pmus;
 
 *type=pmus[i].type;
",866,207
fix up s390 compile problem.,"
 #include ""shm.h""
 #include ""compat.h""
 
+#if F_GETLK64 != F_GETLK
+#define HAVE_LK64
+#endif
+
 void sanitise_fcntl(int childno)
 {
 switch (shm->a2[childno]) {
 void sanitise_fcntl(int childno)
 case F_SETLK:
 case F_SETLKW:
 break;
-#ifndef __x86_64__
+#ifdef HAVE_LK64
 case F_GETLK64:
 break;
 case F_SETLK64:
 struct syscall syscall_fcntl = {
 .arg2name = ""cmd"",
 .arg2type = ARG_OP,
 .arg2list = {
-#ifdef __x86_64__
+#ifndef HAVE_LK64
 .num = 20,
 #else
 .num = 23,
 struct syscall syscall_fcntl = {
 .values = { F_DUPFD, F_DUPFD_CLOEXEC, F_GETFD, F_SETFD, F_GETFL, F_SETFL, F_GETLK, F_SETLK,
  F_SETLKW, F_GETOWN, F_SETOWN, F_GETOWN_EX, F_SETOWN_EX, F_GETSIG, F_SETSIG, F_GETLEASE,
  F_SETLEASE, F_NOTIFY, F_SETPIPE_SZ, F_GETPIPE_SZ,
-#ifndef __x86_64__
+#ifdef HAVE_LK64
  F_GETLK64, F_SETLK64, F_SETLKW64,
 #endif
 },
",100,36
print the taint reason in the watchdog.," static void watchdog(void)
 static const char watchdogname[17]=""trinity-watchdog"";
 static unsigned long lastcount = 0;
 bool watchdog_exit = FALSE;
+int ret = 0;
 
 shm->watchdog_pid = getpid();
 printf(""[%d] Watchdog is alive\n"", shm->watchdog_pid);
 static void watchdog(void)
 
 /* Only check taint if it was zero on startup */
 if (ignore_tainted == FALSE) {
-if (check_tainted() != 0) {
-output(0, ""[watchdog] kernel became tainted! Last seed was %u\n"", shm->seed);
+ret = check_tainted();
+if (ret != 0) {
+output(0, ""[watchdog] kernel became tainted! (%d) Last seed was %u\n"", ret, shm->seed);
 shm->exit_reason = EXIT_KERNEL_TAINTED;
 }
 }
",230,47
"Sanitise F_SETSIG argument to avoid SIGINT

It's possible to send ourselves a SIGINT using F_SETSIG. This is then
interpreted as a Ctrl-c from the user and trinity quits.

Avoid SIGINT, instead use 0, which switches back to the default
behaviour of sending SIGIO.","
 */
 
 #include <fcntl.h>
+#include <signal.h>
 #include ""random.h""
 #include ""sanitise.h""
 #include ""shm.h""
 void sanitise_fcntl(int childno)
 
 case F_SETSIG:
 shm->a3[childno] = (unsigned long) rand32();
+if (shm->a3[childno] == SIGINT)
+shm->a3[childno] = 0; /* restore default (SIGIO) */
 break;
 
 case F_NOTIFY:
",103,37
"add init() function to struct syscall

While working on the perf_event_open() sysfs init problem, I was wondering
if it might be easier if we added the possibility of an init() routine
to each syscall structure. That way trinity can support doing setup
before fuzzing begins.

Below is a quick patch implementing this, it seems to work but I still
don't have the best grasp of trinity internals.

Signed-off-by: Vince Weaver <vincent.weaver@maine.edu>"," void count_syscalls_enabled(void)
 }
 }
 
+void init_syscalls(void)
+{
+unsigned int i;
+
+if (biarch == TRUE) {
+for_each_64bit_syscall(i) {
+if (syscalls_64bit[i].entry->flags & ACTIVE)
+if (syscalls_64bit[i].entry->init)
+syscalls_64bit[i].entry->init();
+}
+
+for_each_32bit_syscall(i) {
+if (syscalls_32bit[i].entry->flags & ACTIVE)
+if (syscalls_32bit[i].entry->init)
+syscalls_32bit[i].entry->init();
+}
+
+} else {
+
+/* non-biarch */
+for_each_syscall(i) {
+if (syscalls[i].entry->flags & ACTIVE)
+if (syscalls[i].entry->init)
+syscalls[i].entry->init();
+}
+}
+}
+
+
 bool no_syscalls_enabled(void)
 {
 unsigned int i;
",613,159
"make perf_event_open() use init routine

This makes the perf_event_open() syscall use the new init functionality.

Signed-off-by: Vince Weaver <vincent.weaver@maine.edu>"," static long long random_event_config(__u32 *event_type, __u64 *config1)
 break;
 
 case PERF_TYPE_READ_FROM_SYSFS:
-if (pmus==NULL) init_pmus();
 config = random_sysfs_config(event_type,config1);
 break;
 
 struct syscall syscall_perf_event_open = {
 },
 },
 .sanitise = sanitise_perf_event_open,
+.init = init_pmus,
 .flags = NEED_ALARM,
 };
",866,206
fdstr needs to be bigger to handle larger pids," static void check_children(void)
 /* After 30 seconds of no progress, send a kill signal. */
 if (diff == 30) {
 unsigned int callno = shm->syscallno[i];
-char fdstr[12];
+char fdstr[20];
 
-memset(fdstr, 0, 12);
+memset(fdstr, 0, sizeof(fdstr));
 
 /* if the first arg was an fd, find out which one it was. */
 if (biarch == FALSE) {
",245,52
extra debug when nftw fails," static void open_fds(const char *dirpath)
 ret = nftw(dirpath, file_tree_callback, 32, flags);
 if (ret != 0) {
 if (shm->exit_reason != EXIT_SIGINT)
-output(0, ""Something went wrong during nftw(). Returned %d\n"", ret);
+output(0, ""Something went wrong during nftw(%s). Returned %d\n"", dirpath, ret);
 return;
 }
 
",297,72
introduce some more randomness to lengths.,"
 
 #include ""trinity.h""// page_size
 #include ""sanitise.h""
+#include ""random.h""
 
 unsigned long get_len(void)
 {
 int i = 0;
 
-i = get_interesting_value();
+if (rand_bool())
+i = get_interesting_value();
+else
+i = rand32();
 
 /* short circuit if 0 */
 if (i == 0)
",43,13
move page_size to arch.h,"
 #include <sys/stat.h>
 
 #include ""trinity.h""// __unused__
+#include ""arch.h""// page_size
 #include ""files.h""
 #include ""log.h""
 #include ""maps.h""
",298,72
sometimes don't mangle," unsigned int rand32(void)
 /* now mangle it. */
 for (i = 0; i < rounds; i++) {
 
-switch (rand() % 4) {
+switch (rand() % 5) {
 
 case 0: r &= rand();
 break;
",166,47
fix race at shutdown where we could spawn a new child as the watchdog exited.," static void check_children(void)
 
 static void kill_all_kids(void)
 {
+shm->spawn_no_more = TRUE;
+
 /* Wait for all the children to exit. */
 while (shm->running_childs > 0) {
 unsigned int i;
",246,52
collapse single bit setting functions into one," unsigned int get_interesting_32bit_value(void)
 switch (rand() % 11) {
 
 /* rare case, single bit. */
-case 0:return rand_single_32bit();
+case 0:return rand_single_bit(32);
 
 /* common case, return small values*/
 case 1 ... 7:
 unsigned long get_interesting_value(void)
 case 14: return MODULE_ADDR | (low & 0xffffff);
 case 15: return per_arch_interesting_addr(low);
 case 16: return (low << 32);
-case 17: return rand_single_64bit();
+case 17: return rand_single_bit(64);
 default: break;
 }
 BUG(""unreachable!\n"");
",97,52
give rand64() a 50/50 chance of returning a 32bit number.," unsigned long rand64(void)
 {
 unsigned long r = 0;
 
-switch (rand() % 7) {
-
-/* Just set one bit */
-case 0:return rand_single_bit(32);
-case 1:return rand_single_bit(64);
-case 2:return randbits(32);
-case 3:return randbits(64);
-
-/* Sometimes pick a not-so-random number. */
-case 4:return get_interesting_value();
-
-/* limit to RAND_MAX (31 bits) */
-case 5:r = rand();
-break;
+if (rand_bool()) {
+/* 32-bit ranges. */
+switch (rand() % 3) {
+case 0:r = rand_single_bit(32);
+break;
+case 1:r = randbits(32);
+break;
+case 2:r = rand32();
+break;
+case 3:r = rand();
+break;
+default:
+break;
+}
 
-case 6:r = taviso();
-break;
-default:
-break;
+} else {
+/* 33:64-bit ranges. */
+switch (rand() % 4) {
+case 0:r = rand_single_bit(64);
+break;
+case 1:r = randbits(64);
+break;
+case 2:r = taviso();
+break;
+/* Sometimes pick a not-so-random number. */
+case 3:return get_interesting_value();
+default:
+break;
+}
 }
 
 if (rand_bool())
",185,51
Move randbits out of the way of forthcoming work.," unsigned int rand_single_bit(unsigned char size)
 return (1L << (rand() % size));
 }
 
+static unsigned long randbits(int limit)
+{
+unsigned int num = rand() % limit / 2;
+unsigned int i;
+unsigned long r = 0;
+
+for (i = 0; i < num; i++)
+r |= (1 << (rand() % (limit - 1)));
+
+return r;
+}
+
 /*
 * Based on very similar routine stolen from iknowthis. Thanks Tavis.
 */
 unsigned int rand32(void)
 return r;
 }
 
-static unsigned long randbits(int limit)
-{
-unsigned int num = rand() % limit / 2;
-unsigned int i;
-unsigned long r = 0;
-
-for (i = 0; i < num; i++)
-r |= (1 << (rand() % (limit - 1)));
-
-return r;
-}
-
 unsigned long rand64(void)
 {
 unsigned long r = 0;
",185,51
use randbits() in rand32," unsigned int rand32(void)
 unsigned int rounds = rand() % 3;
 
 switch (rand() % 4) {
-/* Just set one bit */
 case 0: r = rand_single_bit(32);
 break;
-
-/* 0 .. RAND_MAX */
-case 1: r = rand();
+case 1:r = randbits(32);
+break;
+case 2: r = rand();
 break;
-
-case 2:return get_interesting_32bit_value();
-
 case 3:r = taviso();
 break;
-
+case 4:return get_interesting_32bit_value();
 default:
 break;
 }
",187,52
split up rand32 into generation/mangling," static unsigned long rept8(unsigned int num)
 return r;
 }
 
-unsigned int rand32(void)
+static unsigned int __rand32(void)
 {
 unsigned long r = 0;
-unsigned int i;
-unsigned int rounds = rand() % 3;
 
 switch (rand() % 7) {
 case 0: r = rand_single_bit(32);
 unsigned int rand32(void)
 break;
 }
 
+return r;
+}
+
+unsigned int rand32(void)
+{
+unsigned long r = 0;
+unsigned int i;
+unsigned int rounds = rand() % 3;
+
+r = __rand32();
+
 /* now mangle it. */
 for (i = 0; i < rounds; i++) {
 
",219,61
don't take bits away in rand32 mangler," unsigned int rand32(void)
 
 r = __rand32();
 
-/* now mangle it. */
+/* mangle it. */
 for (i = 0; i < rounds; i++) {
-
-switch (rand() % 5) {
-
-case 0: r &= rand();
-break;
-
-case 1: r |= rand();
+switch (rand() % 2) {
+case 0: r |= rand();
 break;
-
-case 2: r >>= (rand() % 31);
-break;
-
-case 3: r ^= rand();
+case 1: r ^= rand();
 break;
-
 default:
 break;
 }
",215,59
"don't always mangle, sometimes let rand32 just pass through"," static unsigned int __rand32(void)
 unsigned int rand32(void)
 {
 unsigned long r = 0;
-unsigned int i;
-unsigned int rounds = rand() % 3;
 
 r = __rand32();
 
-/* mangle it. */
-for (i = 0; i < rounds; i++) {
-switch (rand() % 2) {
-case 0: r |= rand();
-break;
-case 1: r ^= rand();
-break;
-default:
-break;
+if (rand_bool()) {
+unsigned int i;
+unsigned int rounds;
+
+/* mangle it. */
+rounds = rand() % 3;
+for (i = 0; i < rounds; i++) {
+switch (rand() % 2) {
+case 0: r |= rand();
+break;
+case 1: r ^= rand();
+break;
+default:
+break;
+}
 }
 }
 
",218,60
"re-use __rand32 in the mangler

This was the reasoning behind splitting it out."," unsigned int rand32(void)
 rounds = rand() % 3;
 for (i = 0; i < rounds; i++) {
 switch (rand() % 2) {
-case 0: r |= rand();
+case 0: r |= __rand32();
 break;
-case 1: r ^= rand();
+case 1: r ^= __rand32();
 break;
 default:
 break;
",218,60
"remove duplication in rand64.

Just call rand32 instead of reimplementing it."," unsigned long rand64(void)
 
 if (rand_bool()) {
 /* 32-bit ranges. */
-switch (rand() % 3) {
-case 0:r = rand_single_bit(32);
-break;
-case 1:r = randbits(32);
-break;
-case 2:r = rand32();
-break;
-case 3:r = rand();
-break;
-default:
-break;
-}
+r = rand32();
 
 } else {
 /* 33:64-bit ranges. */
",207,56
add a crappy rand|rand<<32 64bit case," unsigned long rand64(void)
 
 } else {
 /* 33:64-bit ranges. */
-switch (rand() % 6) {
+switch (rand() % 7) {
 case 0:r = rand_single_bit(64);
 break;
 case 1:r = randbits(64);
 break;
-case 2:r = taviso();
+case 2:r = rand32() | rand32() << 31;
 break;
-case 3:r = rand8x8();
+case 3:r = taviso();
 break;
-case 4:r = rept8(8);
+case 4:r = rand8x8();
+break;
+case 5:r = rept8(8);
 break;
 /* Sometimes pick a not-so-random number. */
-case 5:return get_interesting_value();
+case 6:return get_interesting_value();
 default:
 break;
 }
",209,57
add some 64-bit truncation," unsigned long rand64(void)
 default:
 break;
 }
+
+/* limit the size */
+switch (rand() % 4) {
+case 0: r &= 0x000000ffffffffff;
+break;
+case 1: r &= 0x0000ffffffffffff;
+break;
+case 2: r &= 0x00ffffffffffffff;
+break;
+default:
+break;
+}
+
 }
 
 if (rand_bool())
",219,60
Occasionally invert rand64," unsigned long rand64(void)
 
 }
 
+if (rand_bool())
+r ^= r;
+
 if (rand_bool())
 r |= (1L << (__WORDSIZE - 1));
 
",221,61
Increase random distribution in MSB of rand64," unsigned long rand64(void)
 if (rand_bool())
 r ^= r;
 
+/* increase distribution in MSB */
+if ((rand() % 10)) {
+unsigned int i;
+unsigned int rounds;
+
+rounds = rand() % 4;
+for (i = 0; i < rounds; i++)
+r |= (1L << (__WORDSIZE - (rand() % 256)));
+}
+
+/* randomly flip sign bit. */
 if (rand_bool())
 r |= (1L << (__WORDSIZE - 1));
 
",228,63
"devices.c: dont use %as scanf format string, but instead allocate and parse the device name manually for compatibility with non-glibc libcs"," static size_t bldevs, chrdevs, miscdevs;
 static void parse_proc_devices(void)
 {
 FILE *fp;
-char *name, *line = NULL;
+char *p, *name, *line = NULL;
 size_t n = 0;
 int block, major;
 void *new;
 static void parse_proc_devices(void)
 while (getline(&line, &n, fp) >= 0) {
 if (strcmp(""Block devices:\n"", line) == 0)
 block = 1;
-else if (sscanf(line, ""%d %as"", &major, &name) == 2) {
+else if (strcmp(""Character devices:\n"", line) == 0)
+block = 0;
+else if (sscanf(line, ""%d %*s"", &major) == 1) {
+if ((p = strrchr(line, ' ')) == NULL)
+continue;
+p++;
+name = strdup(p);
+
 if (block) {
 new = realloc(block_devs, (bldevs+1)*sizeof(*block_devs));
 if (!new) {
",117,25
"Remove noisy 'Unable to opendir /sys/bus/event_source/devices' messages

It's not fatal if the directory doesn't exist.

A patch that removes the message is included below."," static int init_pmus(void) {
 
 dir=opendir(""/sys/bus/event_source/devices"");
 if (dir==NULL) {
-fprintf(stderr,""Unable to opendir ""
-""/sys/bus/event_source/devices : %s\n"",
-strerror(errno));
 return -1;
 }
 
",863,206
Use TRINITY_PF_MAX instead of PF_MAX in syscalls/socket.c," void sanitise_socket(int childno)
 if (do_specific_proto == TRUE)
 family = specific_proto;
 else
-family = rand() % PF_MAX;
+family = rand() % TRINITY_PF_MAX;
 
 type = rand() % TYPE_MAX;
 protocol = rand() % PROTO_MAX;
",264,72
Fix open() result check in check_tainted()," int check_tainted(void)
 char buffer[4];
 
 fd = open(""/proc/sys/kernel/tainted"", O_RDONLY);
-if (!fd)
+if (fd < 0)
 return -1;
 ret = read(fd, buffer, 3);
 close(fd);
",303,62
Avoid needless get_filename() calls in generate_pathname()," char * generate_pathname(void)
 case 0 ... 90:
 /* 90% chance of returning an unmangled filename */
 if ((rand() % 100) > 10)
-return get_filename();
+return pathname;
 
 case 91 ... 99:
 /* Create a bogus filename. */
 newpath = malloc(page_size);// FIXME: We leak this.
 if (newpath == NULL)
-return get_filename();// give up.
+return pathname;// give up.
 
 generate_random_page(newpath);
 
",298,72
"Fix double rand() in generate_pathname()

We take 90% chance two times in the ""unmangled"" path in
generate_pathname(); looks accidental to me."," char * generate_pathname(void)
 
 case 0 ... 90:
 /* 90% chance of returning an unmangled filename */
-if ((rand() % 100) > 10)
-return pathname;
+return pathname;
 
 case 91 ... 99:
 /* Create a bogus filename. */
",297,71
factor out the routine to calculate the fileno of the last logfile," static FILE * find_logfile_handle(void)
 return NULL;
 }
 
+unsigned int highest_logfile(void)
+{
+FILE *file;
+int ret;
+
+if (logging == FALSE)
+return 0;
+
+file = shm->logfiles[shm->max_children - 1];
+ret = fileno(file);
+
+return ret;
+}
+
 void synclogs(void)
 {
 unsigned int i;
",153,28
watchdog should be avoiding anything that looks like a logfile fd too," static unsigned int check_if_fd(unsigned int callno, unsigned int child)
 /* shortcut, if it's out of range, it's not going to be valid. */
 if ((unsigned long) shm->a1 > 1024)
 return FALSE;
-if ((unsigned long) shm->a1 < 3)
+if ((unsigned long) shm->a1 < highest_logfile())
 return FALSE;
 
 if (biarch == FALSE) {
",256,56
"remove the fd 'retry' loop

This is all crap. We're dealing with array indexes here, not absolute fd numbers."," static int get_new_random_fd(void)
 unsigned int i;
 unsigned int fd_index;
 int fd = 0;
-int ret;
 
 i = rand() % 3;
 
 static int get_new_random_fd(void)
 switch (i) {
 case 0:
 retry_file:
-// FIXME: This whole 'retry' logic is pretty ugly.
-// We should just figure out the range of randomness we care about.
 fd_index = rand() % nr_file_fds;
 fd = shm->file_fds[fd_index];
-
-if (logging == FALSE)
-/* avoid stdin/stdout/stderr */
-ret = fileno(stderr);
-else {
-/* if logging is enabled, we want to make sure we skip
- * over the logfiles, so get highest logfile fd. */
-ret = highest_logfile();
-}
-
-if (fd <= ret)
-goto retry_file;
 break;
 
 case 1:
",97,21
"more get_new_random_fd cleanup

Remove the goto targets, and split out the code that gets used in
multiple places."," static void open_pipes(void)
 }
 }
 
+static int rand_file_fd(void)
+{
+unsigned int fd_index;
+
+fd_index = rand() % nr_file_fds;
+return shm->file_fds[fd_index];
+}
+
+static int rand_pipe_fd(void)
+{
+return shm->pipe_fds[rand() % MAX_PIPE_FDS];
+}
+
 static int get_new_random_fd(void)
 {
 unsigned int i;
-unsigned int fd_index;
 int fd = 0;
 
 i = rand() % 3;
 static int get_new_random_fd(void)
 if (nr_file_fds == 0)
 i = 1;
 
-
 switch (i) {
 case 0:
-retry_file:
-fd_index = rand() % nr_file_fds;
-fd = shm->file_fds[fd_index];
+fd = rand_file_fd();
 break;
 
 case 1:
 retry_file:
  */
 if (nr_sockets == 0) {
 if (nr_file_fds > 0)
-goto retry_file;
+fd = rand_file_fd();
 else
-goto do_pipe;
+fd = rand_pipe_fd();
+return fd;
 }
 fd = shm->socket_fds[rand() % nr_sockets];
 break;
 
 case 2:
-do_pipe:
-fd = shm->pipe_fds[rand() % MAX_PIPE_FDS];
+fd = rand_pipe_fd();
 break;
 default:
 break;
",104,23
add the MROUTE setsockopt optlens,"
 #include <stdlib.h>
 #include <sys/types.h>
 #include <sys/socket.h>
+#include <linux/types.h>
 #include ""sanitise.h""
 #include ""compat.h""
 #include ""maps.h""
 void sanitise_setsockopt(int childno)
 else
 shm->a5[childno] = sizeof(struct ip_mreqn);
 break;
+
+case MRT_ADD_VIF:
+case MRT_DEL_VIF:
+shm->a5[childno] = sizeof(struct vifctl);
+break;
+case MRT_ADD_MFC:
+case MRT_ADD_MFC_PROXY:
+case MRT_DEL_MFC:
+case MRT_DEL_MFC_PROXY:
+shm->a5[childno] = sizeof(struct mfcctl);
+break;
+case MRT_TABLE:
+shm->a5[childno] = sizeof(__u32);
+break;
+
 case IP_MSFILTER:
 //FIXME: Read size from sysctl /proc/sys/net/core/optmem_max
 shm->a5[childno] = rand() % sizeof(unsigned long)*(2*UIO_MAXIOV+512);
",344,134
try some more random optlens for some of the as-yet unannotated protocols," void sanitise_setsockopt(int childno)
 unsigned char val;
 
 shm->a4[childno] = (unsigned long) page_rand;
-shm->a5[childno] = sizeof(int);// at the minimum, we want an int (overridden below)
+// pick a size for optlen. At the minimum, we want an int (overridden below)
+if (rand_bool())
+shm->a5[childno] = sizeof(int);
+else
+shm->a5[childno] = rand() % 256;
 
 /* First we pick a level */
 
",347,135
"That's pretty much it for ip_setsockopt

All other options will do fine with just the default sizeof(int)"," void ip_setsockopt(int childno)
 shm->a5[childno] = rand() % sizeof(unsigned long)*(2*UIO_MAXIOV+512);
 shm->a5[childno] |= IP_MSFILTER_SIZE(0);
 break;
+
+case IP_BLOCK_SOURCE:
+case IP_UNBLOCK_SOURCE:
+case IP_ADD_SOURCE_MEMBERSHIP:
+case IP_DROP_SOURCE_MEMBERSHIP:
+shm->a5[childno] = sizeof(struct ip_mreq_source);
+break;
+
+case MCAST_JOIN_GROUP:
+case MCAST_LEAVE_GROUP:
+shm->a5[childno] = sizeof(struct group_req);
+break;
+
+case MCAST_JOIN_SOURCE_GROUP:
+case MCAST_LEAVE_SOURCE_GROUP:
+case MCAST_BLOCK_SOURCE:
+case MCAST_UNBLOCK_SOURCE:
+shm->a5[childno] = sizeof(struct group_source_req);
+break;
+
+case MCAST_MSFILTER:
+//FIXME: Read size from sysctl /proc/sys/net/core/optmem_max
+shm->a5[childno] = rand() % sizeof(unsigned long)*(2*UIO_MAXIOV+512);
+shm->a5[childno] |= GROUP_FILTER_SIZE(0);
+break;
+
 default:
 break;
 }
",117,48
remove unnecessary assignment," static void open_fds(const char *dirpath)
 void generate_filelist(void)
 {
 unsigned int i = 0;
-struct list_head *node = &names->list;
+struct list_head *node;
 struct namelist *nl;
 
 my_uid = getuid();
",288,68
"check for ctrl-c before we check for 0 files in filelist.

Saves printing out an unsurprising message."," void generate_filelist(void)
 open_fds(""/sys"");
 }
 
+if (shm->exit_reason != STILL_RUNNING)
+return;
+
 if (files_added == 0) {
 output(1, ""Didn't add any files!!\n"");
 return;
 }
 
-if (shm->exit_reason != STILL_RUNNING)
-return;
+/* Generate an index of pointers to the filenames */
 
-/*
- * Generate an index of pointers to the filenames
- */
 fileindex = malloc(sizeof(char *) * files_added);
 
 list_for_each(node, &names->list) {
",288,68
"remove a clang warning, and clarify indentation"," static void sanitise_perf_event_open(int childno)
 /* requires ROOT to select pid that doesn't belong to us */
 /* pid of 0 means current process */
 /* pid of -1 means all processes */
-pid = 0;
+
 if (flags & PERF_FLAG_PID_CGROUP) {
 /* In theory in this case we should pass in */
 /* a file descriptor from /dev/cgroup */
 pid = get_random_fd();
-} else if (rand() % 2) {
-pid = 0;
 } else {
-pid = get_pid();
+if (rand_bool()) {
+pid = 0;
+} else {
+pid = get_pid();
+}
 }
 shm->a2[childno] = pid;
 
",864,206
"Fix up clang warnings in perf_event_open.c

I was slightly off, the problem turned out to be if we fail at fopen()
we never got to the fscanf(), but we'd then still call parse_format()
with an uninitialized format_value. So good catch by llvm.

The following should fix things.

Signed-off-by: Vince Weaver <vincent.weaver@maine.edu>"," static int init_pmus(void) {
 pmus[pmu_num].formats[format_num].value=
 strdup(format_value);
 fclose(fff);
-}
-parse_format(format_value,
+
+parse_format(format_value,
 &pmus[pmu_num].formats[format_num].field,
 &pmus[pmu_num].formats[format_num].shift,
 &pmus[pmu_num].formats[format_num].bits);
-if (pmus[pmu_num].formats[format_num].bits==64) {
-pmus[pmu_num].formats[format_num].mask=0xffffffffffffffffULL;
-} else {
-pmus[pmu_num].formats[format_num].mask=
-(1ULL<<pmus[pmu_num].formats[format_num].bits)-1;
+if (pmus[pmu_num].formats[format_num].bits==64) {
+pmus[pmu_num].formats[format_num].mask=0xffffffffffffffffULL;
+} else {
+pmus[pmu_num].formats[format_num].mask=
+(1ULL<<pmus[pmu_num].formats[format_num].bits)-1;
+}
+format_num++;
 }
-format_num++;
 }
 closedir(format_dir);
 }
",869,206
"perf_event_open: initialize chars

Just in case if they get used like in Coverity CID 1042349 and 1042348.

Signed-off-by: Mikko Rapeli <mikko.rapeli@iki.fi>"," static int init_pmus(void) {
 
 DIR *dir,*event_dir,*format_dir;
 struct dirent *entry,*event_entry,*format_entry;
-char dir_name[BUFSIZ],event_name[BUFSIZ],event_value[BUFSIZ],
-temp_name[BUFSIZ],format_name[BUFSIZ],format_value[BUFSIZ];
+char dir_name[BUFSIZ] = """";
+char event_name[BUFSIZ] = """";
+char event_value[BUFSIZ] = """";
+char temp_name[BUFSIZ] = """";
+char format_name[BUFSIZ] = """";
+char format_value[BUFSIZ] = """";
 int type,pmu_num=0,format_num=0,generic_num=0;
 FILE *fff;
 int result;
",873,206
"perf_event_open.c: close dir's on exit paths

Don't leaky fd's so much. Fixes Coverity CID's 1042345, 1042346 and 1042347.

Signed-off-by: Mikko Rapeli <mikko.rapeli@iki.fi>"," static int init_pmus(void) {
 sizeof(struct format_type));
 if (pmus[pmu_num].formats==NULL) {
 pmus[pmu_num].num_formats=0;
+closedir(dir);
+closedir(format_dir);
 return -1;
 }
 
 static int init_pmus(void) {
 sizeof(struct generic_event_type));
 if (pmus[pmu_num].generic_events==NULL) {
 pmus[pmu_num].num_generic_events=0;
+closedir(dir);
+closedir(event_dir);
 return -1;
 }
 
",877,206
"sockets.c: don't leak cachefile on return paths

Fixes Coverity CID's 1042341 and 1042342.

Signed-off-by: Mikko Rapeli <mikko.rapeli@iki.fi>"," void generate_sockets(void)
 
 while (nr_to_create > 0) {
 
-if (shm->exit_reason != STILL_RUNNING)
+if (shm->exit_reason != STILL_RUNNING) {
+close(cachefile);
 return;
+}
 
 /* Pretend we're child 0 and we've called sys_socket */
 sanitise_socket(0);
 void open_sockets(void)
 if (domain != specific_proto) {
 printf(""ignoring socket cachefile due to specific protocol request, and stale data in cachefile.\n"");
 generate_sockets();
+close(cachefile);
 return;
 }
 }
 regenerate:
 }
 
 /* check for ctrl-c */
-if (shm->exit_reason != STILL_RUNNING)
+if (shm->exit_reason != STILL_RUNNING) {
+close(cachefile);
 return;
-
+}
 }
 
 if (nr_sockets < NR_SOCKET_FDS) {
",189,34
"maps.c: only close() if fd is valid

Fixes Coverity CID 1042340.

Signed-off-by: Mikko Rapeli <mikko.rapeli@iki.fi>"," static void * alloc_zero_map(struct map *map, int prot, const char *name)
 output(2, ""mapping[%d]: (zeropage %s) %p (%lu bytes)\n"",
 num_mappings - 1, name, tmpmap->ptr, size);
 
-close(fd);
+if (fd >= 0)
+close(fd);
 return tmpmap;
 }
 
",156,27
fix error checking for open,"
+#include <errno.h>
 #include <fcntl.h>
 #include <malloc.h>
 #include <stdio.h>
 static void * alloc_zero_map(struct map *map, int prot, const char *name)
 tmpmap = alloc_map();
 
 fd = open(""/dev/zero"", O_RDWR);
-if (!fd) {
-printf(""open /dev/zero failure\n"");
+if (fd < 0) {
+printf(""open /dev/zero failure. %s\n"", strerror(errno));
 exit(EXIT_FAILURE);
 }
 
",157,27
actually use the zero page in the mmap," static void * alloc_zero_map(struct map *map, int prot, const char *name)
  */
 size *= 2;
 
-tmpmap->ptr = mmap(NULL, size, prot, MAP_ANONYMOUS|MAP_SHARED, -1, 0);
+tmpmap->ptr = mmap(NULL, size, prot, MAP_ANONYMOUS|MAP_SHARED, fd, 0);
 
 if (tmpmap->ptr == MAP_FAILED) {
 printf(""mmap /dev/zero failure\n"");
",157,27
"pick the right sync_file_range syscall table entry.

Because we copy all these structs, the comparison is never going to
compare to the correct version. Check the name instead.","
 */
 #include <linux/fs.h>
 #include <fcntl.h>
+#include <string.h>
 #include <stdlib.h>
 #include ""arch.h""
 #include ""sanitise.h""
 retry:
 if (off >= (0x100000000LL << PAGE_SHIFT))
 goto retry;
 
-if (syscall_entry == &syscall_sync_file_range) {
+if (strcmp(""sync_file_range2"", syscall_entry->name) == 0) {
 shm->a2[childno] = off;
 shm->a3[childno] = nbytes;
 } else {
",67,4
use 64bit rand for sync_file_range,"
 #include <string.h>
 #include <stdlib.h>
 #include ""arch.h""
+#include ""random.h""
 #include ""sanitise.h""
 #include ""shm.h""
 
 static void sanitise_sync_file_range(int childno)
 loff_t off;
 
 retry:
-off = rand() & 0xfffffff;
-nbytes = rand() & 0xfffffff;
+off = rand64() & 0x0fffffffffffffff;
+nbytes = rand64() & 0x0fffffffffffffff;
 endbyte = off + nbytes;
 if (endbyte < off)
 goto retry;
",68,4
"use memcpy instead of strcpy, as this is not a string

(side effect of silencing coverity)"," void gen_rose(unsigned long *addr, unsigned long *addrlen)
 strncpy(rose->srose_call.ax25_call, page_rand, 7);
 
 rose->srose_ndigis = rand();
+
 strncpy(rose->srose_digi.ax25_call, page_rand+7, 7);
 
 *addr = (unsigned long) rose;
",26,2
use memcpy instead of strncpy on non-string data," void gen_ax25(unsigned long *addr, unsigned long *addrlen)
 return;
 
 ax25->sax25_family = PF_AX25;
-strncpy(ax25->sax25_call.ax25_call, page_rand, 7);
+memcpy(ax25->sax25_call.ax25_call, page_rand, 7);
 ax25->sax25_ndigis = rand();
 *addr = (unsigned long) ax25;
 *addrlen = sizeof(struct sockaddr_ax25);
",19,2
"trinity.c: fix uninitialized variable

Coverity says:

CID 1042350 (#1 of 1): Uninitialized scalar variable (UNINIT)
23. uninit_use_in_call: Using uninitialized value ""ling"": field ""ling"".""l_linger"" is uninitialized when calling ""setsockopt(int, int, int, void const *, socklen_t)"".

Signed-off-by: Mikko Rapeli <mikko.rapeli@iki.fi>"," int main(int argc, char* argv[])
 cleanup_fds:
 
 for (i = 0; i < nr_sockets; i++) {
-struct linger ling;
+struct linger ling = { .l_onoff = FALSE, };
 
 ling.l_onoff = FALSE;/* linger active */
 setsockopt(shm->socket_fds[i], SOL_SOCKET, SO_LINGER, &ling, sizeof(struct linger));
",185,33
"trinity.c: log errors if socket calls fail

Maybe that's all that needs to be done at this point.

Coverity CID 1042335 (#1 of 1): Unchecked return value from library
(CHECKED_RETURN)

Signed-off-by: Mikko Rapeli <mikko.rapeli@iki.fi>"," int main(int argc, char* argv[])
 cleanup_fds:
 
 for (i = 0; i < nr_sockets; i++) {
+int r = 0;
 struct linger ling = { .l_onoff = FALSE, };
 
 ling.l_onoff = FALSE;/* linger active */
-setsockopt(shm->socket_fds[i], SOL_SOCKET, SO_LINGER, &ling, sizeof(struct linger));
-shutdown(shm->socket_fds[i], SHUT_RDWR);
+r = setsockopt(shm->socket_fds[i], SOL_SOCKET, SO_LINGER, &ling, sizeof(struct linger));
+if (r)
+perror(""setsockopt"");
+r = shutdown(shm->socket_fds[i], SHUT_RDWR);
+if (r)
+perror(""shutdown"");
 close(shm->socket_fds[i]);
 }
 
",190,35
stagger the output of the pidmap," bool pidmap_empty(void)
 
 void dump_pid_slots(void)
 {
-unsigned int i;
+unsigned int i, j = 0;
 
-printf(""## pids:\n"");
+printf(""## pids: (%d active)\n"", shm->running_childs);
 
-for_each_pidslot(i)
-printf(""## slot%d: %d\n"", i, shm->pids[i]);
+for (i = 0; i < shm->max_children; i+=8) {
+printf(""%d-%d: "", j, j+7);
+for (j = 0; j < 8; j++)
+printf(""%d "", shm->pids[i]);
+printf(""\n"");
+}
 }
 
 static pid_t pidmax;
",98,24
colorize pids in the pidmap that are dead,"
 #include <stdlib.h>
+#include <stdio.h>
+#include <sys/types.h>
+#include <signal.h>
 #include ""shm.h""
 #include ""params.h""// for 'dangerous'
 #include ""pids.h""
 bool pidmap_empty(void)
 void dump_pid_slots(void)
 {
 unsigned int i, j = 0;
+char string[512], *sptr = string;
 
-printf(""## pids: (%d active)\n"", shm->running_childs);
+sptr += sprintf(sptr, ""## pids: (%d active)\n"", shm->running_childs);
 
 for (i = 0; i < shm->max_children; i+=8) {
-printf(""%d-%d: "", j, j+7);
+sptr += sprintf(sptr, ""%d-%d: "", j, j+7);
 for (j = 0; j < 8; j++)
-printf(""%d "", shm->pids[i]);
-printf(""\n"");
+if (pid_alive(shm->pids[i] == -1)) {
+RED
+printf(""%d "", shm->pids[i]);
+CRESET
+}
+sptr += sprintf(sptr, ""\n"");
+*sptr = '\0';
 }
+output(2, ""%s"", string);
 }
 
 static pid_t pidmax;
",108,25
"null terminate at end of string, not eol"," void dump_pid_slots(void)
 CRESET
 }
 sptr += sprintf(sptr, ""\n"");
-*sptr = '\0';
 }
+*sptr = '\0';
 output(2, ""%s"", string);
 }
 
",108,25
use correct iterator.," void dump_pid_slots(void)
 sptr += sprintf(sptr, ""## pids: (%d active)\n"", shm->running_childs);
 
 for (i = 0; i < shm->max_children; i+=8) {
-sptr += sprintf(sptr, ""%d-%d: "", j, j+7);
+sptr += sprintf(sptr, ""%d-%d: "", i, i+7);
 for (j = 0; j < 8; j++)
 if (pid_alive(shm->pids[i] == -1)) {
 RED
 void dump_pid_slots(void)
 sptr += sprintf(sptr, ""\n"");
 }
 *sptr = '\0';
-output(2, ""%s"", string);
+printf(""%s"", string);
 }
 
 static pid_t pidmax;
",108,25
"print out the pid in both cases, duh."," void dump_pid_slots(void)
 for (i = 0; i < shm->max_children; i+=8) {
 sptr += sprintf(sptr, ""%d-%d: "", i, i+7);
 for (j = 0; j < 8; j++)
-if (pid_alive(shm->pids[i] == -1)) {
+if (pid_alive(shm->pids[i] == -1))
 RED
-printf(""%d "", shm->pids[i]);
-CRESET
-}
+
+printf(""%d "", shm->pids[i]);
+CRESET
 sptr += sprintf(sptr, ""\n"");
 }
 *sptr = '\0';
",107,25
don't mix up printf/sprintf," void dump_pid_slots(void)
 if (pid_alive(shm->pids[i] == -1))
 RED
 
-printf(""%d "", shm->pids[i]);
+sptr += sprintf(sptr, ""%d "", shm->pids[i]);
 CRESET
 sptr += sprintf(sptr, ""\n"");
 }
 *sptr = '\0';
-printf(""%s"", string);
+output(2, ""%s"", string);
 }
 
 static pid_t pidmax;
",107,25
"Fix looping in pid dump.

I'm not sure how many more ways I can get this wrong."," void dump_pid_slots(void)
 
 for (i = 0; i < shm->max_children; i+=8) {
 sptr += sprintf(sptr, ""%d-%d: "", i, i+7);
-for (j = 0; j < 8; j++)
+for (j = 0; j < 8; j++) {
 if (pid_alive(shm->pids[i] == -1))
 RED
 
 sptr += sprintf(sptr, ""%d "", shm->pids[i]);
 CRESET
+}
 sptr += sprintf(sptr, ""\n"");
 }
 *sptr = '\0';
-output(2, ""%s"", string);
+printf(""%s"", string);
 }
 
 static pid_t pidmax;
",108,25
"get pidslot offset correct

also don't colorize the empty pidslots"," void dump_pid_slots(void)
 for (i = 0; i < shm->max_children; i+=8) {
 sptr += sprintf(sptr, ""%d-%d: "", i, i+7);
 for (j = 0; j < 8; j++) {
-if (pid_alive(shm->pids[i] == -1))
-RED
+if (shm->pids[i+j] != EMPTY_PIDSLOT) {
+if (pid_alive(shm->pids[i+j] == -1))
+RED
+}
 
-sptr += sprintf(sptr, ""%d "", shm->pids[i]);
+sptr += sprintf(sptr, ""%d "", shm->pids[i+j]);
 CRESET
 }
 sptr += sprintf(sptr, ""\n"");
",110,26
bail watchdog pid walking immediately if something weird has happened.," static unsigned int reap_dead_kids(void)
 pid_t pid;
 int ret;
 
+/* If something weird has happened, bail immediately. */
+if (shm->exit_reason != STILL_RUNNING)
+return shm->running_childs;
+
 pid = shm->pids[i];
 if (pid == EMPTY_PIDSLOT)
 continue;
",258,57
output pid in error message when failing to restore limit," static void reenable_coredumps(void)
 prctl(PR_SET_DUMPABLE, TRUE);
 
 if (setrlimit(RLIMIT_CORE, &oldrlimit) != 0) {
-printf(""Error restoring rlimits to cur:%d max:%d (%s)\n"",
+printf(""[%d] Error restoring rlimits to cur:%d max:%d (%s)\n"",
+getpid(),
 (unsigned int) oldrlimit.rlim_cur,
 (unsigned int) oldrlimit.rlim_max,
 strerror(errno));
",121,23
"Revert ""bail watchdog pid walking immediately if something weird has happened.""

This reverts commit e2eda88807c9ad98b4d8f9a050bef674eebfa9ba.

We can't do this because we call the reap_dead_kids function on exit
when things go bad, and this change would leave the watchdog
thinking there are still child processes around."," static unsigned int reap_dead_kids(void)
 pid_t pid;
 int ret;
 
-/* If something weird has happened, bail immediately. */
-if (shm->exit_reason != STILL_RUNNING)
-return shm->running_childs;
-
 pid = shm->pids[i];
 if (pid == EMPTY_PIDSLOT)
 continue;
",256,56
"convert strncpy->memcpy.

this time for real. Not sure what happened in the earlier commit."," void gen_rose(unsigned long *addr, unsigned long *addrlen)
 rose->srose_addr.rose_addr[3] = rand();
 rose->srose_addr.rose_addr[4] = rand();
 
-strncpy(rose->srose_call.ax25_call, page_rand, 7);
+memcpy(rose->srose_call.ax25_call, page_rand, 7);
 
 rose->srose_ndigis = rand();
 
-strncpy(rose->srose_digi.ax25_call, page_rand+7, 7);
+memcpy(rose->srose_digi.ax25_call, page_rand + 7, 7);
 
 *addr = (unsigned long) rose;
 *addrlen = sizeof(struct sockaddr_rose);
",26,2
"fix up 'dir' leak

caught by coverity."," static int init_pmus(void) {
 char format_value[BUFSIZ] = """";
 int type,pmu_num=0,format_num=0,generic_num=0;
 FILE *fff;
-int result;
+int result = -1;
 
 
 /* Count number of PMUs */
 static int init_pmus(void) {
 num_pmus++;
 }
 
-if (num_pmus<1) return -1;
+if (num_pmus<1)
+goto out;
 
 pmus=calloc(num_pmus,sizeof(struct pmu_type));
-if (pmus==NULL) {
-return -1;
-}
+if (pmus==NULL)
+goto out;
 
 /****************/
 /* Add each PMU */
 static int init_pmus(void) {
 pmu_num++;
 }
 
-closedir(dir);
-
-(void)result;
+result = 0;
 
-return 0;
+out:
+closedir(dir);
 
+return result;
 }
 
 
",878,206
"wait until all children have started.

Prevents the reseed storm on startup."," static void fork_children(void)
 return;
 
 /* a new child means a new seed, or the new child
- * will do the same syscalls as the one in the pidslot it's replacing. */
-reseed();
+ * will do the same syscalls as the one in the pidslot it's replacing.
+ * (special case startup, or we reseed unnecessarily)
+ */
+if (shm->ready == TRUE)
+reseed();
 
 /* Find a space for it in the pid map */
 pidslot = find_pid_slot(EMPTY_PIDSLOT);
 static void fork_children(void)
 }
 }
 
+/* Wait for all the children to start up. */
+while (shm->ready == FALSE);
+
 init_child(pidslot);
 
 ret = child_process(pidslot);
 static void fork_children(void)
 return;
 
 }
+shm->ready = TRUE;
+
 debugf(""[%d] created enough children\n"", getpid());
 }
 
",306,64
"parse_proc_devices: cut off device string on newline

I didn't see that the device name includes the newline so that map_dev() will fail.
This was kind of hard to see unless you have a driver and you know how the
command ids should look like."," static void parse_proc_devices(void)
 else if (strcmp(""Character devices:\n"", line) == 0)
 block = 0;
 else if (sscanf(line, ""%d %*s"", &major) == 1) {
+if ((p = strchr(line, '\n')) != NULL)
+*p = 0;
 if ((p = strrchr(line, ' ')) == NULL)
 continue;
 p++;
",119,26
"do the pause from -p /after/ the syscall.

Keep the pre-syscall sync where it is though."," args_done:
 
 output(2, ""%s"", string);
 
-if (dopause == TRUE) {
+/* If we're going to pause, might as well sync pre-syscall */
+if (dopause == TRUE)
 synclogs();
-sleep(1);
-}
 
 if (((unsigned long)shm->a1 == (unsigned long) shm) ||
  ((unsigned long)shm->a2 == (unsigned long) shm) ||
 args_done:
 
 output(2, ""%s\n"", string);
 
+if (dopause == TRUE)
+sleep(1);
+
 /* If the syscall doesn't exist don't bother calling it next time. */
 if ((ret == -1UL) && (errno_saved == ENOSYS)) {
 
",175,29
"be a bit more anal about missing prototypes.

This highlighted a bunch of functions that could be made static,
as well as some missing includes.","
 #include <sys/stat.h>
 #include <sys/types.h>
 #include <linux/kdev_t.h>
+#include ""files.h""
 
 #include ""log.h""
 
",120,26
"limit rand64 to 32bits when building on 32bit.

I might later change this to make this function return u64 if necessary,
but for now, the rand64() consumers on 32bit don't care because
they work on ulongs."," unsigned long rand64(void)
 {
 unsigned long r = 0;
 
+#if __WORDSIZE == 32
+return rand32();
+#endif
+
 if (rand_bool()) {
 /* 32-bit ranges. */
 r = rand32();
",230,64
"Make rand64 return a u64 always, even on 32-bit."," static unsigned long fill_arg(int childno, int call, int argnum)
 return 0;
 }
 
-i = rand64() % high;
+i = (unsigned long) rand64() % high;
 if (i < low) {
 i += low;
 i &= high;
",281,103
This probably works better if it works on the right register.," retry_size:
 }
 
 retry_pgoff:
-if (shm->a5[childno] + (shm->a2[childno] >> PAGE_SHIFT) < shm->a5[childno]) {
-shm->a5[childno] = get_interesting_value();
+if (shm->a4[childno] + (shm->a2[childno] >> PAGE_SHIFT) < shm->a4[childno]) {
+shm->a4[childno] = get_interesting_value();
 goto retry_pgoff;
 }
 
 retry_pgoff_bits:
-if (shm->a5[childno] + (shm->a2[childno] >> PAGE_SHIFT) >= (1UL << PTE_FILE_MAX_BITS)) {
-shm->a5[childno] = (shm->a5[childno] >> 1);
+if (shm->a4[childno] + (shm->a2[childno] >> PAGE_SHIFT) >= (1UL << PTE_FILE_MAX_BITS)) {
+shm->a4[childno] = (shm->a4[childno] >> 1);
 goto retry_pgoff_bits;
 }
 }
",43,4
"Don't directly call the 'interesting number' functions.

rand32/rand64 will sometimes call these, so just use those.
That way, we'll also get some randomness used.","
 #include ""maps.h""
 #include ""trinity.h""// ARRAY_SIZE
 #include ""arch.h""// page_size
+#include ""random.h""
 #include ""sanitise.h""
 #include ""ioctls.h""
 
 static void scsi_sg_io_sanitise(int childno)
 
 switch (rand() % 3) {
 case 0: sgio->ioh.dxfer_len = rand() % page_size;break;
-case 1: sgio->ioh.dxfer_len = get_interesting_value();break;
+case 1: sgio->ioh.dxfer_len = (unsigned int) rand32();break;
 case 2: sgio->ioh.dxfer_len = rand() % 512;break;
 default: break;
 }
",114,10
The rand() functions do the single bit case.," unsigned int get_interesting_32bit_value(void)
 {
 switch (rand() % 11) {
 
-/* rare case, single bit. */
-case 0:return rand_single_bit(32);
-
 /* common case, return small values*/
-case 1 ... 7:
+case 0 ... 7:
 switch (rand() % 8) {
 case 0:return 0x00000000;
 case 1:return 0x00000001;
 unsigned long get_interesting_value(void)
 
 low = get_interesting_32bit_value();
 
-switch (rand() % 18) {
+switch (rand() % 17) {
 case 0: return 0;
 case 1: return low;
 case 2: return 0x0000000100000000UL;
 unsigned long get_interesting_value(void)
 case 14: return MODULE_ADDR | (low & 0xffffff);
 case 15: return per_arch_interesting_addr(low);
 case 16: return (low << 32);
-case 17: return rand_single_bit(64);
 default: break;
 }
 BUG(""unreachable!\n"");
",96,50
don't panic about lost pid slots if we reaped a pid.," static void handle_child(pid_t childpid, int childstatus)
 
 slot = find_pid_slot(childpid);
 if (slot == PIDSLOT_NOT_FOUND) {
-printf(""[%d] ## Couldn't find pid slot for %d\n"", getpid(), childpid);
-shm->exit_reason = EXIT_LOST_PID_SLOT;
-dump_pid_slots();
+/* If we reaped it, it wouldn't show up, so check that. */
+if (shm->last_reaped != childpid) {
+printf(""[%d] ## Couldn't find pid slot for %d\n"", getpid(), childpid);
+shm->exit_reason = EXIT_LOST_PID_SLOT;
+dump_pid_slots();
+}
 } else {
 debugf(""[%d] Child %d exited after %ld syscalls.\n"", getpid(), childpid, shm->child_syscall_count[slot]);
 reap_child(childpid);
",308,65
Use child offset into array.," static unsigned int reap_dead_kids(void)
 static unsigned int check_if_fd(unsigned int callno, unsigned int child)
 {
 /* shortcut, if it's out of range, it's not going to be valid. */
-if ((unsigned long) shm->a1 > 1024)
+if ((unsigned long) shm->a1[child] > 1024)
 return FALSE;
-if ((unsigned long) shm->a1 < highest_logfile())
+if ((unsigned long) shm->a1[child] < highest_logfile())
 return FALSE;
 
 if (biarch == FALSE) {
",256,56
Add AF_IB address family," void sanitise_socket(int childno)
 }
 break;
 
+//TODO;
+/*case AF_IB:
+break;
+*/
 case AF_NETLINK:
 switch (rand_bool()) {
 case 0:type = SOCK_RAW;
",264,72
appletalk: move random socket generation into per protocol files.,"
 #include <sys/un.h>
 #include <netinet/in.h>
 #include <linux/atalk.h>
+#include ""random.h""
 #include ""net.h""
 
 void gen_appletalk(unsigned long *addr, unsigned long *addrlen)
 void gen_appletalk(unsigned long *addr, unsigned long *addrlen)
 *addr = (unsigned long) atalk;
 *addrlen = sizeof(struct sockaddr_at);
 }
+
+void appletalk_rand_socket(struct proto_type *pt)
+{
+if (rand_bool()) {
+pt->type = SOCK_DGRAM;
+ pt->protocol = 0;
+ return;
+}
+
+pt->protocol = rand() % PROTO_MAX;
+pt->type = SOCK_RAW;
+}
",31,4
caif: move random socket generation into per protocol files.,"
 #include <stdlib.h>
 #include ""config.h""
 #include ""net.h""
+#include ""random.h""
 
 #ifdef USE_CAIF
 #include <linux/caif/caif_socket.h>
 void gen_caif(unsigned long *addr, unsigned long *addrlen)
 *addrlen = sizeof(struct sockaddr_caif);
 }
 
+void caif_rand_socket(struct proto_type *pt)
+{
+pt->protocol = rand() % _CAIFPROTO_MAX;
+if (rand_bool())
+pt->type = SOCK_SEQPACKET;
+else
+pt->type = SOCK_STREAM;
+}
+
 #endif
",38,6
can: move random socket generation into per protocol files.,"
 #include <linux/can.h>
 #include <stdlib.h>
 #include ""net.h""
+#include ""random.h""
 
 void gen_can(unsigned long *addr, unsigned long *addrlen)
 {
 void gen_can(unsigned long *addr, unsigned long *addrlen)
 *addr = (unsigned long) can;
 *addrlen = sizeof(struct sockaddr_can);
 }
+
+void can_rand_socket(struct proto_type *pt)
+{
+pt->protocol = rand() % 7; // CAN_NPROTO
+pt->type = rand() % TYPE_MAX;
+}
",26,3
decnet: move random socket generation into per protocol files.,"
 #include <linux/dn.h>
 #include <stdlib.h>
 #include ""net.h""
+#include ""random.h""
 
 void gen_decnet(unsigned long *addr, unsigned long *addrlen)
 {
 void gen_decnet(unsigned long *addr, unsigned long *addrlen)
 *addr = (unsigned long) dn;
 *addrlen = sizeof(struct sockaddr_dn);
 }
+
+void decnet_rand_socket(struct proto_type *pt)
+{
+if (rand_bool()) {
+pt->type = SOCK_SEQPACKET;
+pt->protocol = DNPROTO_NSP;
+} else {
+pt->type = SOCK_STREAM;
+pt->protocol = rand() % PROTO_MAX;
+}
+}
",37,5
inet: move random socket generation into per protocol files.,"
 #include <netinet/in.h>
 #include <stdlib.h>
 #include ""net.h""
+#include ""random.h""
 
 in_addr_t random_ipv4_address(void)
 {
 void gen_ipv4(unsigned long *addr, unsigned long *addrlen)
 *addr = (unsigned long) ipv4;
 *addrlen = sizeof(struct sockaddr_in);
 }
+
+void inet_rand_socket(struct proto_type *pt)
+{
+switch (rand() % 3) {
+case 0: pt->type = SOCK_STREAM; // TCP
+if (rand_bool())
+pt->protocol = 0;
+else
+pt->protocol = IPPROTO_TCP;
+break;
+
+case 1: pt->type = SOCK_DGRAM; // UDP
+if (rand_bool())
+pt->protocol = 0;
+else
+pt->protocol = IPPROTO_UDP;
+break;
+
+case 2: pt->type = SOCK_RAW;
+pt->protocol = rand() % PROTO_MAX;
+break;
+
+default:break;
+}
+}
",90,24
inet6: move random socket generation into per protocol files.,"
 #include <linux/if_packet.h>
 #include <stdlib.h>
 #include ""net.h""
+#include ""random.h""
 
 void gen_ipv6(unsigned long *addr, unsigned long *addrlen)
 {
 void gen_ipv6(unsigned long *addr, unsigned long *addrlen)
 *addr = (unsigned long) ipv6;
 *addrlen = sizeof(struct sockaddr_in6);
 }
+
+void inet6_rand_socket(struct proto_type *pt)
+{
+switch (rand() % 3) {
+case 0: pt->type = SOCK_STREAM; // TCP
+pt->protocol = 0;
+break;
+
+case 1: pt->type = SOCK_DGRAM; // UDP
+if (rand_bool())
+pt->protocol = 0;
+else
+pt->protocol = IPPROTO_UDP;
+break;
+
+case 2: pt->type = SOCK_RAW;
+pt->protocol = rand() % PROTO_MAX;
+break;
+
+default:break;
+}
+}
",43,7
ipx: move random socket generation into per protocol files.," void gen_ipx(unsigned long *addr, unsigned long *addrlen)
 *addr = (unsigned long) ipx;
 *addrlen = sizeof(struct sockaddr_ipx);
 }
+
+void ipx_rand_socket(struct proto_type *pt)
+{
+pt->protocol = rand() % PROTO_MAX;
+pt->type = SOCK_DGRAM;
+}
",29,4
irda: move random socket generation into per protocol files.,"
 #include <linux/irda.h>
 #include <stdlib.h>
 #include ""net.h""
+#include ""random.h""
 
 void gen_irda(unsigned long *addr, unsigned long *addrlen)
 {
 void gen_irda(unsigned long *addr, unsigned long *addrlen)
 *addr = (unsigned long) irda;
 *addrlen = sizeof(struct sockaddr_irda);
 }
+
+void irda_rand_socket(struct proto_type *pt)
+{
+switch (rand() % 3) {
+
+case 0: pt->type = SOCK_STREAM;
+pt->protocol = rand() % PROTO_MAX;
+break;
+
+case 1: pt->type = SOCK_SEQPACKET;
+pt->protocol = rand() % PROTO_MAX;
+break;
+
+case 2: pt->type = SOCK_DGRAM;
+if (rand_bool())
+pt->protocol = IRDAPROTO_ULTRA;
+else
+pt->protocol = IRDAPROTO_UNITDATA;
+break;
+
+default:break;
+}
+}
",41,8
llc: move random socket generation into per protocol files.,"
 #include <linux/llc.h>
 #include <stdlib.h>
 #include ""net.h""
+#include ""random.h""
 
 void gen_llc(unsigned long *addr, unsigned long *addrlen)
 {
 void gen_llc(unsigned long *addr, unsigned long *addrlen)
 *addr = (unsigned long) llc;
 *addrlen = sizeof(struct sockaddr_llc);
 }
+
+void llc_rand_socket(struct proto_type *pt)
+{
+pt->protocol = rand() % PROTO_MAX;
+if (rand_bool())
+pt->type = SOCK_STREAM;
+else
+pt->type = SOCK_DGRAM;
+}
",36,5
netlink: move random socket generation into per protocol files.,"
 #include <linux/netlink.h>
 #include <stdlib.h>
 #include ""net.h""
+#include ""random.h""
 
 void gen_netlink(unsigned long *addr, unsigned long *addrlen)
 {
 void gen_netlink(unsigned long *addr, unsigned long *addrlen)
 *addr = (unsigned long) nl;
 *addrlen = sizeof(struct sockaddr_nl);
 }
+
+void netlink_rand_socket(struct proto_type *pt)
+{
+if (rand_bool())
+pt->type = SOCK_RAW;
+else
+pt->type = SOCK_DGRAM;
+
+pt->protocol = rand() % (NETLINK_CRYPTO + 1); // Current highest netlink socket.
+}
",28,4
nfc: move random socket generation into per protocol files.,"
 #include ""config.h""
 #include ""compat.h""
 #include ""net.h""
+#include ""random.h""
 
 void gen_nfc(unsigned long *addr, unsigned long *addrlen)
 {
 void gen_nfc(unsigned long *addr, unsigned long *addrlen)
 *addr = (unsigned long) nfc;
 *addrlen = sizeof(struct sockaddr_nfc);
 }
+
+void nfc_rand_socket(struct proto_type *pt)
+{
+if (rand_bool()) {
+pt->protocol = NFC_SOCKPROTO_LLCP;
+if (rand_bool())
+pt->type = SOCK_DGRAM;
+else
+pt->type = SOCK_STREAM;
+return;
+}
+
+pt->protocol = NFC_SOCKPROTO_RAW;
+pt->type = SOCK_SEQPACKET;
+}
",35,5
packet: move random socket generation into per protocol files.,"
 #include <sys/un.h>
 #include <netinet/in.h>
 #include <linux/if_packet.h>
+#include <linux/if_ether.h>
 #include <stdlib.h>
 #include ""net.h""
+#include ""random.h""
 
 void gen_packet(unsigned long *addr, unsigned long *addrlen)
 {
 void gen_packet(unsigned long *addr, unsigned long *addrlen)
 *addr = (unsigned long) pkt;
 *addrlen = sizeof(struct sockaddr_pkt);
 }
+
+void packet_rand_socket(struct proto_type *pt)
+{
+pt->protocol = htons(ETH_P_ALL);
+
+if (rand() % 8 == 0) {
+pt->protocol = rand();
+if (rand_bool())
+pt->protocol = (uint16_t) rand();
+}
+
+switch (rand() % 3) {
+case 0: pt->type = SOCK_DGRAM;
+break;
+case 1: pt->type = SOCK_RAW;
+break;
+case 2: pt->type = SOCK_PACKET;
+break;
+default: break;
+}
+}
",40,9
phonet: move random socket generation into per protocol files.,"
 #include <linux/phonet.h>
 #include <stdlib.h>
 #include ""net.h""
+#include ""random.h""
 
 void gen_phonet(unsigned long *addr, unsigned long *addrlen)
 {
 void gen_phonet(unsigned long *addr, unsigned long *addrlen)
 *addr = (unsigned long) pn;
 *addrlen = sizeof(struct sockaddr_pn);
 }
+
+void phonet_rand_socket(struct proto_type *pt)
+{
+pt->protocol = 0;
+if (rand_bool())
+pt->type = SOCK_DGRAM;
+else
+pt->type = SOCK_SEQPACKET;
+}
",29,4
rds: move random socket generation into per protocol files.,"
+#include ""net.h""
+
+void rds_rand_socket(struct proto_type *pt)
+{
+pt->protocol = 0;
+pt->type = SOCK_SEQPACKET;
+}
",6,1
tipc: move random socket generation into per protocol files.,"
 #include <linux/tipc.h>
 #include <stdlib.h>
 #include ""net.h""
+#include ""random.h""
 
 void gen_tipc(unsigned long *addr, unsigned long *addrlen)
 {
 void gen_tipc(unsigned long *addr, unsigned long *addrlen)
 *addr = (unsigned long) tipc;
 *addrlen = sizeof(struct sockaddr_tipc);
 }
+
+void tipc_rand_socket(struct proto_type *pt)
+{
+pt->protocol = 0;
+
+switch (rand() % 3) {
+case 0: pt->type = SOCK_STREAM;
+break;
+case 1: pt->type = SOCK_SEQPACKET;
+break;
+case 2: pt->type = SOCK_DGRAM;
+break;
+default: break;
+}
+}
",41,6
unix: move random socket generation into per protocol files.," void gen_unixsock(unsigned long *addr, unsigned long *addrlen)
 *addr = (unsigned long) unixsock;
 *addrlen = sizeof(struct sockaddr_un);
 }
+
+void unix_rand_socket(struct proto_type *pt)
+{
+pt->protocol = PF_UNIX;
+
+switch (rand() % 3) {
+case 0: pt->type = SOCK_STREAM;
+break;
+case 1: pt->type = SOCK_DGRAM;
+break;
+case 2: pt->type = SOCK_SEQPACKET;
+break;
+default:break;
+}
+}
",35,6
x25: move random socket generation into per protocol files.," void gen_x25(unsigned long *addr, unsigned long *addrlen)
 *addr = (unsigned long) x25;
 *addrlen = sizeof(struct sockaddr_x25);
 }
+
+void x25_rand_socket(struct proto_type *pt)
+{
+pt->type = SOCK_SEQPACKET;
+pt->protocol = 0;
+}
",27,3
in the default case (unknown family) we still need to set the prototype," void sanitise_socket(int childno)
 
 
 default:
+pt.protocol = rand() % PROTO_MAX;
+
 switch (rand() % 6) {
 case 0:pt.type = SOCK_DGRAM;break;
 case 1:pt.type = SOCK_STREAM;break;
",107,29
remove unnecessary includes,"
 #include <stdlib.h>
 #include <sys/types.h>
 #include <sys/socket.h>
-#include <netinet/in.h>
-#include <linux/irda.h>
-#include <linux/dn.h>
-#include <linux/netlink.h>
 #include ""compat.h""
 #include ""log.h""
 #include ""net.h""
",103,29
move socket setsockopt stuff out to own file," static void sanitise_setsockopt(int childno)
 shm->a5[childno] = so.optlen;
 break;
 
-case 1:level = SOL_SOCKET;
-shm->a2[childno] = level;
-val = rand() % NR_SOL_SOCKET_OPTS;
-shm->a3[childno] = socket_opts[val];
-
-/* Adjust length according to operation set. */
-switch (shm->a3[childno]) {
-case SO_LINGER:shm->a5[childno] = sizeof(struct linger);
-break;
-case SO_RCVTIMEO:
-case SO_SNDTIMEO:
-shm->a5[childno] = sizeof(struct timeval);
-break;
-case SO_ATTACH_FILTER:
-gen_bpf((unsigned long *) page_rand, NULL);
-shm->a5[childno] = sizeof(struct sock_fprog);
-break;
-default:
-break;
-}
+case 1:
+socket_setsockopt(&so);
+shm->a2[childno] = so.level;
+shm->a3[childno] = so.optname;
+shm->a4[childno] = so.optval;
+shm->a5[childno] = so.optlen;
 break;
 
 case 2:level = SOL_TCP;
",272,61
move tcp setsockopt out to own file.,"
+#include <stdlib.h>
+#include <linux/tcp.h>
+#include ""net.h""
+#include ""maps.h""// page_rand
+#include ""compat.h""
+#include ""trinity.h""// ARRAY_SIZE
+
+#define SOL_TCP 6
+
+#define NR_SOL_TCP_OPTS ARRAY_SIZE(tcp_opts)
+static int tcp_opts[] = { TCP_NODELAY, TCP_MAXSEG, TCP_CORK, TCP_KEEPIDLE,
+TCP_KEEPINTVL, TCP_KEEPCNT, TCP_SYNCNT, TCP_LINGER2,
+TCP_DEFER_ACCEPT, TCP_WINDOW_CLAMP, TCP_INFO, TCP_QUICKACK,
+TCP_CONGESTION, TCP_MD5SIG, TCP_COOKIE_TRANSACTIONS, TCP_THIN_LINEAR_TIMEOUTS,
+TCP_THIN_DUPACK, TCP_USER_TIMEOUT, TCP_REPAIR, TCP_REPAIR_QUEUE,
+TCP_QUEUE_SEQ, TCP_REPAIR_OPTIONS, TCP_FASTOPEN};
+
+void tcp_setsockopt(struct sockopt *so)
+{
+unsigned char val;
+
+so->level = SOL_TCP;
+
+val = rand() % NR_SOL_TCP_OPTS;
+so->optname = tcp_opts[val];
+}
",19,1
move UDP setsockopt out to own file,"
+#include <stdlib.h>
+#include <netinet/udp.h>
+#include ""net.h""
+#include ""maps.h""// page_rand
+#include ""compat.h""
+#include ""trinity.h""// ARRAY_SIZE
+
+#define NR_SOL_UDP_OPTS ARRAY_SIZE(udp_opts)
+static int udp_opts[] = { UDP_CORK, UDP_ENCAP };
+
+void udp_setsockopt(struct sockopt *so)
+{
+unsigned char val;
+
+so->level = SOL_UDP;
+
+val = rand() % NR_SOL_UDP_OPTS;
+so->optname = udp_opts[val];
+
+switch (so->optname) {
+case UDP_CORK:
+break;
+case UDP_ENCAP:
+page_rand[0] = (rand() % 3) + 1; // Encapsulation types.
+break;
+default:
+break;
+}
+}
",23,3
move ipv6 setsockopt out to own file,"
+#include <stdlib.h>
+#include ""net.h""
+#include ""maps.h""// page_rand
+#include ""compat.h""
+#include ""trinity.h""// ARRAY_SIZE
+
+#define NR_SOL_INET6_OPTS ARRAY_SIZE(inet6_opts)
+static int inet6_opts[] = {
+IPV6_ADDRFORM, IPV6_2292PKTINFO, IPV6_2292HOPOPTS, IPV6_2292DSTOPTS,
+IPV6_2292RTHDR, IPV6_2292PKTOPTIONS, IPV6_CHECKSUM, IPV6_2292HOPLIMIT,
+IPV6_NEXTHOP, IPV6_AUTHHDR, IPV6_FLOWINFO, IPV6_UNICAST_HOPS,
+IPV6_MULTICAST_IF, IPV6_MULTICAST_HOPS, IPV6_MULTICAST_LOOP, IPV6_ADD_MEMBERSHIP,
+IPV6_DROP_MEMBERSHIP, IPV6_ROUTER_ALERT, IPV6_MTU_DISCOVER, IPV6_MTU,
+IPV6_RECVERR, IPV6_V6ONLY, IPV6_JOIN_ANYCAST, IPV6_LEAVE_ANYCAST };
+
+void inet6_setsockopt(struct sockopt *so)
+{
+unsigned char val;
+
+so->level = SOL_IPV6;
+
+val = rand() % NR_SOL_INET6_OPTS;
+so->optname = inet6_opts[val];
+}
",19,1
move icmpv6 setsockopt out to own file,"
+#include <stdlib.h>
+#include <linux/icmpv6.h>
+#include ""net.h""
+#include ""maps.h""// page_rand
+#include ""compat.h""
+#include ""trinity.h""// ARRAY_SIZE
+
+#define NR_SOL_ICMPV6_OPTS ARRAY_SIZE(icmpv6_opts)
+static int icmpv6_opts[] = { ICMPV6_FILTER };
+
+void icmpv6_setsockopt(struct sockopt *so)
+{
+unsigned char val;
+
+so->level = SOL_IPV6;
+
+val = rand() % NR_SOL_ICMPV6_OPTS;
+so->optname = icmpv6_opts[val];
+}
",14,1
move sctp setsockopt out to own file," static void sanitise_setsockopt(int childno)
 shm->a5[childno] = so.optlen;
 break;
 
-case 6:level = SOL_SCTP;
-shm->a2[childno] = level;
-val = rand() % NR_SOL_SCTP_OPTS;
-shm->a3[childno] = sctp_opts[val];
+case 6:sctp_setsockopt(&so);
+shm->a2[childno] = so.level;
+shm->a3[childno] = so.optname;
+shm->a4[childno] = so.optval;
+shm->a5[childno] = so.optlen;
 break;
 
 case 7:level = SOL_UDPLITE;
",267,59
move udplite setsockopt out to own file,"
+#include <stdlib.h>
+#include <linux/udp.h>
+#include ""net.h""
+#include ""maps.h""// page_rand
+#include ""compat.h""
+#include ""trinity.h""// ARRAY_SIZE
+
+#define SOL_UDPLITE 136
+
+#define NR_SOL_UDPLITE_OPTS ARRAY_SIZE(udplite_opts)
+static int udplite_opts[] = { UDP_CORK, UDP_ENCAP, UDPLITE_SEND_CSCOV, UDPLITE_RECV_CSCOV };
+
+void udplite_setsockopt(struct sockopt *so)
+{
+unsigned char val;
+
+so->level = SOL_UDPLITE;
+
+val = rand() % NR_SOL_UDPLITE_OPTS;
+so->optname = udplite_opts[val];
+
+switch (so->optname) {
+case UDP_CORK:
+break;
+case UDP_ENCAP:
+page_rand[0] = (rand() % 3) + 1; // Encapsulation types.
+break;
+case UDPLITE_SEND_CSCOV:
+break;
+case UDPLITE_RECV_CSCOV:
+break;
+default:
+break;
+}
+}
",27,5
move raw setsockopt out to own file,"
+#include <linux/icmp.h>
+#include ""net.h""
+
+void raw_setsockopt(struct sockopt *so)
+{
+so->level = SOL_RAW;
+so->optname = ICMP_FILTER; // that's all (for now?)
+}
",7,1
move ipx setsockopt out to own file,"
+#include <netipx/ipx.h>
+#include ""net.h""
+
+void ipx_setsockopt(struct sockopt *so)
+{
+so->level = SOL_IPX;
+so->optname = IPX_TYPE;
+}
",7,1
move ax25 setsockopt out to own file,"
+#include <stdlib.h>
+#include <netax25/ax25.h>
+#include ""net.h""
+#include ""maps.h""// page_rand
+#include ""compat.h""
+#include ""trinity.h""// ARRAY_SIZE
+
+#define NR_SOL_AX25_OPTS ARRAY_SIZE(ax25_opts)
+static int ax25_opts[] = {
+AX25_WINDOW, AX25_T1, AX25_N2, AX25_T3,
+AX25_T2, AX25_BACKOFF, AX25_EXTSEQ, AX25_PIDINCL,
+AX25_IDLE, AX25_PACLEN, AX25_IAMDIGI,
+SO_BINDTODEVICE };
+
+void ax25_setsockopt(struct sockopt *so)
+{
+unsigned char val;
+
+so->level = SOL_AX25;
+
+val = rand() % NR_SOL_AX25_OPTS;
+so->optname = ax25_opts[val];
+}
",18,1
move appletalk setsockopt out to own file,"
+#include <netatalk/at.h>
+#include ""net.h""
+
+void atalk_setsockopt(struct sockopt *so)
+{
+so->level = SOL_ATALK;
+}
",6,1
move netrom setsockopt out to own file,"
+#include <stdlib.h>
+#include <netrom/netrom.h>
+#include ""net.h""
+#include ""maps.h""// page_rand
+#include ""compat.h""
+#include ""trinity.h""// ARRAY_SIZE
+
+#define NR_SOL_NETROM_OPTS ARRAY_SIZE(netrom_opts)
+static int netrom_opts[] = {
+NETROM_T1, NETROM_T2, NETROM_N2, NETROM_T4, NETROM_IDLE };
+
+void netrom_setsockopt(struct sockopt *so)
+{
+unsigned char val;
+
+so->level = SOL_NETROM;
+
+val = rand() % NR_SOL_NETROM_OPTS;
+so->optname = netrom_opts[val];
+}
",15,1
move ROSE setsockopt out to own file,"
+#include <stdlib.h>
+#include <bits/sockaddr.h>
+#include <linux/ax25.h>
+#include <netrose/rose.h>
+#include ""net.h""
+#include ""maps.h""// page_rand
+#include ""compat.h""
+#include ""trinity.h""// ARRAY_SIZE
+
+#define NR_SOL_ROSE_OPTS ARRAY_SIZE(rose_opts)
+static int rose_opts[] = {
+ROSE_DEFER, ROSE_T1, ROSE_T2, ROSE_T3,
+ROSE_IDLE, ROSE_QBITINCL, ROSE_HOLDBACK };
+
+void rose_setsockopt(struct sockopt *so)
+{
+unsigned char val;
+
+so->level = SOL_ROSE;
+
+val = rand() % NR_SOL_ROSE_OPTS;
+so->optname = rose_opts[val];
+}
",18,1
move decnet setsockopt out to own file,"
+#include <stdlib.h>
+#include <linux/dn.h>
+#include ""net.h""
+#include ""maps.h""// page_rand
+#include ""compat.h""
+#include ""trinity.h""// ARRAY_SIZE
+
+#define NR_SOL_DECNET_OPTS ARRAY_SIZE(decnet_opts)
+static int decnet_opts[] = {
+SO_CONDATA, SO_CONACCESS, SO_PROXYUSR, SO_LINKINFO,
+DSO_CONDATA, DSO_DISDATA, DSO_CONACCESS, DSO_ACCEPTMODE,
+DSO_CONACCEPT, DSO_CONREJECT, DSO_LINKINFO, DSO_STREAM,
+DSO_SEQPACKET, DSO_MAXWINDOW, DSO_NODELAY, DSO_CORK,
+DSO_SERVICES, DSO_INFO
+};
+
+void decnet_setsockopt(struct sockopt *so)
+{
+unsigned char val;
+
+so->level = SOL_DECNET;
+
+val = rand() % NR_SOL_DECNET_OPTS;
+so->optname = decnet_opts[val];
+
+// TODO: set optlen correctly
+
+}
",20,1
move x25 setsockopt out to own file,"
+#include <stdlib.h>
+#include ""net.h""
+#include ""maps.h""// page_rand
+#include ""random.h""
+
+void x25_setsockopt(struct sockopt *so)
+{
+so->level = SOL_X25;
+
+page_rand[0] = rand_bool();
+so->optval = sizeof(int);
+}
",10,1
move packet setsockopt out to own file," static void sanitise_setsockopt(int childno)
 shm->a5[childno] = so.optlen;
 break;
 
-case 16: level = SOL_PACKET;
-shm->a2[childno] = level;
-val = rand() % NR_SOL_PACKET_OPTS;
-shm->a3[childno] = packet_opts[val];
-
-/* Adjust length according to operation set. */
-switch (shm->a3[childno]) {
-case PACKET_VERSION:
-page_rand[0] = rand() % 3; /* tpacket versions 1/2/3 */
-break;
-case PACKET_TX_RING:
-case PACKET_RX_RING:
-#ifdef TPACKET3_HDRLEN
-if (rand() % 3 == 0)
-shm->a5[childno] = sizeof(struct tpacket_req3);
-else
-#endif
-shm->a5[childno] = sizeof(struct tpacket_req);
-break;
-default:
-break;
-}
+case 16:
+packet_setsockopt(&so);
+shm->a2[childno] = so.level;
+shm->a3[childno] = so.optname;
+shm->a4[childno] = so.optval;
+shm->a5[childno] = so.optlen;
 break;
 
 case 17: level = SOL_ATM;
",259,50
move atm setsockopt out to own file,"
+#include <stdlib.h>
+#include <linux/atmdev.h>
+#include <linux/atm.h>
+#include ""net.h""
+#include ""maps.h""// page_rand
+#include ""compat.h""
+#include ""trinity.h""// ARRAY_SIZE
+
+#define NR_SOL_ATM_OPTS ARRAY_SIZE(atm_opts)
+static int atm_opts[] = {
+SO_SETCLP, SO_CIRANGE, SO_ATMQOS, SO_ATMSAP, SO_ATMPVC, SO_MULTIPOINT };
+
+void atm_setsockopt(struct sockopt *so)
+{
+unsigned char val;
+
+so->level = SOL_ATM;
+
+val = rand() % NR_SOL_ATM_OPTS;
+so->optname = atm_opts[val];
+}
",16,1
move aal setsockopt out to own file,"
+#include ""net.h""
+
+void aal_setsockopt(struct sockopt *so)
+{
+so->level = SOL_AAL;
+}
",5,1
move irda setsockopt out to own file,"
+#include <stdlib.h>
+#include <linux/irda.h>
+#include ""net.h""
+#include ""maps.h""// page_rand
+#include ""compat.h""
+#include ""trinity.h""// ARRAY_SIZE
+
+#define NR_SOL_IRDA_OPTS ARRAY_SIZE(irda_opts)
+static int irda_opts[] = {
+IRLMP_ENUMDEVICES, IRLMP_IAS_SET, IRLMP_IAS_QUERY, IRLMP_HINTS_SET,
+IRLMP_QOS_SET, IRLMP_QOS_GET, IRLMP_MAX_SDU_SIZE, IRLMP_IAS_GET,
+IRLMP_IAS_DEL, IRLMP_HINT_MASK_SET, IRLMP_WAITDEVICE };
+
+void irda_setsockopt(struct sockopt *so)
+{
+unsigned char val;
+
+so->level = SOL_IRDA;
+
+val = rand() % NR_SOL_IRDA_OPTS;
+so->optname = irda_opts[val];
+}
",17,1
move netbeui setsockopt out to own file,"
+#include ""net.h""
+
+#define SOL_NETBEUI 267
+
+void netbeui_setsockopt(struct sockopt *so)
+{
+so->level = SOL_NETBEUI;
+}
",5,1
move llc setsockopt out to own file,"
+#include <stdlib.h>
+#include <net/if.h>
+#include <linux/llc.h>
+#include ""net.h""
+#include ""maps.h""// page_rand
+#include ""compat.h""
+#include ""config.h""
+#include ""trinity.h""// ARRAY_SIZE
+
+#define SOL_LLC 268
+
+#ifndef USE_LLC_OPT_PKTINFO
+#define LLC_OPT_PKTINFO LLC_OPT_UNKNOWN
+#endif
+
+#define NR_SOL_LLC_OPTS ARRAY_SIZE(llc_opts)
+static int llc_opts[] = {
+LLC_OPT_RETRY, LLC_OPT_SIZE, LLC_OPT_ACK_TMR_EXP, LLC_OPT_P_TMR_EXP,
+LLC_OPT_REJ_TMR_EXP, LLC_OPT_BUSY_TMR_EXP, LLC_OPT_TX_WIN, LLC_OPT_RX_WIN,
+LLC_OPT_PKTINFO };
+
+
+void llc_setsockopt(struct sockopt *so)
+{
+unsigned char val;
+
+so->level = SOL_LLC;
+
+val = rand() % NR_SOL_LLC_OPTS;
+so->optname = llc_opts[val];
+}
",19,1
move dccp setsockopt out to own file,"
+#include <stdlib.h>
+#include <linux/dccp.h>
+#include ""net.h""
+#include ""maps.h""// page_rand
+#include ""compat.h""
+#include ""config.h""
+#include ""trinity.h""// ARRAY_SIZE
+
+#define SOL_DCCP 269
+
+#define NR_SOL_DCCP_OPTS ARRAY_SIZE(dccp_opts)
+static int dccp_opts[] = {
+DCCP_SOCKOPT_PACKET_SIZE, DCCP_SOCKOPT_SERVICE, DCCP_SOCKOPT_CHANGE_L, DCCP_SOCKOPT_CHANGE_R,
+DCCP_SOCKOPT_GET_CUR_MPS, DCCP_SOCKOPT_SERVER_TIMEWAIT, DCCP_SOCKOPT_SEND_CSCOV, DCCP_SOCKOPT_RECV_CSCOV,
+DCCP_SOCKOPT_AVAILABLE_CCIDS, DCCP_SOCKOPT_CCID, DCCP_SOCKOPT_TX_CCID, DCCP_SOCKOPT_RX_CCID,
+DCCP_SOCKOPT_QPOLICY_ID, DCCP_SOCKOPT_QPOLICY_TXQLEN, DCCP_SOCKOPT_CCID_RX_INFO, DCCP_SOCKOPT_CCID_TX_INFO };
+
+void dccp_setsockopt(struct sockopt *so)
+{
+unsigned char val;
+
+so->level = SOL_DCCP;
+
+val = rand() % NR_SOL_DCCP_OPTS;
+so->optname = dccp_opts[val];
+}
",19,1
move netlink setsockopt out to own file,"
+#include <stdlib.h>
+#include <linux/netlink.h>
+#include ""net.h""
+#include ""maps.h""// page_rand
+#include ""compat.h""
+#include ""trinity.h""// ARRAY_SIZE
+
+#define SOL_NETLINK 270
+
+#define NR_SOL_NETLINK_OPTS ARRAY_SIZE(netlink_opts)
+static int netlink_opts[] = {
+NETLINK_ADD_MEMBERSHIP, NETLINK_DROP_MEMBERSHIP, NETLINK_PKTINFO, NETLINK_BROADCAST_ERROR,
+NETLINK_NO_ENOBUFS };
+
+void netlink_setsockopt(struct sockopt *so)
+{
+unsigned char val;
+
+so->level = SOL_NETLINK;
+
+val = rand() % NR_SOL_NETLINK_OPTS;
+so->optname = netlink_opts[val];
+}
",16,1
move tipc setsockopt out to own file,"
+#include <stdlib.h>
+#include <linux/tipc.h>
+#include ""net.h""
+#include ""compat.h""
+#include ""trinity.h""// ARRAY_SIZE
+
+#define NR_SOL_TIPC_OPTS ARRAY_SIZE(tipc_opts)
+static int tipc_opts[] = {
+TIPC_IMPORTANCE, TIPC_SRC_DROPPABLE, TIPC_DEST_DROPPABLE, TIPC_CONN_TIMEOUT,
+TIPC_NODE_RECVQ_DEPTH, TIPC_SOCK_RECVQ_DEPTH };
+
+void tipc_setsockopt(struct sockopt *so)
+{
+unsigned char val;
+
+so->level = SOL_TIPC;
+
+val = rand() % NR_SOL_TIPC_OPTS;
+so->optname = tipc_opts[val];
+
+so->optval = sizeof(__u32);
+}
",16,1
move rxrpc setsockopt out to own file,"
+#include <stdlib.h>
+#include ""net.h""
+#include ""compat.h""
+#include ""trinity.h""// ARRAY_SIZE
+
+#define SOL_RXRPC 272
+
+#define NR_SOL_RXRPC_OPTS ARRAY_SIZE(rxrpc_opts)
+static int rxrpc_opts[] = {
+RXRPC_USER_CALL_ID, RXRPC_ABORT, RXRPC_ACK, RXRPC_NET_ERROR,
+RXRPC_BUSY, RXRPC_LOCAL_ERROR, RXRPC_NEW_CALL, RXRPC_ACCEPT };
+
+void rxrpc_setsockopt(struct sockopt *so)
+{
+unsigned char val;
+
+so->level = SOL_RXRPC;
+
+val = rand() % NR_SOL_RXRPC_OPTS;
+so->optname = rxrpc_opts[val];
+}
",14,1
move pppol2tp out to own file,"
+#include <stdlib.h>
+#include <netinet/in.h>
+#include <linux/if_pppol2tp.h>
+#include ""net.h""
+#include ""compat.h""
+#include ""trinity.h""// ARRAY_SIZE
+
+#define SOL_PPPOL2TP 273
+
+#define NR_SOL_PPPOL2TP_OPTS ARRAY_SIZE(pppol2tp_opts)
+static int pppol2tp_opts[] = {
+PPPOL2TP_SO_DEBUG, PPPOL2TP_SO_RECVSEQ, PPPOL2TP_SO_SENDSEQ, PPPOL2TP_SO_LNSMODE,
+PPPOL2TP_SO_REORDERTO };
+
+void pppol2tp_setsockopt(struct sockopt *so)
+{
+unsigned char val;
+
+so->level = SOL_PPPOL2TP;
+
+val = rand() % NR_SOL_PPPOL2TP_OPTS;
+so->optname = pppol2tp_opts[val];
+
+so->optval = sizeof(int);
+}
",17,1
move pnpipe setsockopt out to own file,"
+#include <stdlib.h>
+#include ""net.h""
+
+#define SOL_PNPIPE 275
+
+void pnpipe_setsockopt(struct sockopt *so)
+{
+so->level = SOL_PNPIPE;
+}
",6,1
move rds setsockopt out to own file,"
+#include <stdlib.h>
+#include ""net.h""
+#include ""config.h""
+#ifdef USE_RDS
+#include <linux/rds.h>
+#endif
+
+#include ""compat.h""
+#include ""trinity.h""// ARRAY_SIZE
+
+#define SOL_RDS 276
+
+#ifdef USE_RDS
+#define NR_SOL_RDS_OPTS ARRAY_SIZE(rds_opts)
+static int rds_opts[] = {
+RDS_CANCEL_SENT_TO, RDS_GET_MR, RDS_FREE_MR,
+4, /* deprecated RDS_BARRIER 4 */
+RDS_RECVERR, RDS_CONG_MONITOR, RDS_GET_MR_FOR_DEST };
+#endif
+
+void rds_setsockopt(struct sockopt *so)
+{
+unsigned char val;
+
+so->level = SOL_RDS;
+#ifdef USE_RDS
+val = rand() % NR_SOL_RDS_OPTS;
+so->optname = rds_opts[val];
+#endif
+}
",17,2
move iucv setsockopt out to own file,"
+#include <stdlib.h>
+#include ""net.h""
+#include ""compat.h""
+#include ""trinity.h""// ARRAY_SIZE
+
+#define SOL_IUCV 277
+
+#define NR_SOL_IUCV_OPTS ARRAY_SIZE(iucv_opts)
+static int iucv_opts[] = {
+SO_IPRMDATA_MSG, SO_MSGLIMIT, SO_MSGSIZE };
+
+void iucv_setsockopt(struct sockopt *so)
+{
+unsigned char val;
+
+so->level = SOL_IUCV;
+
+val = rand() % NR_SOL_IUCV_OPTS;
+so->optname = iucv_opts[val];
+
+so->optval = sizeof(int);
+}
",14,1
move caif setsockopt out to own file,"
+#include <stdlib.h>
+#include ""net.h""
+#include ""config.h""
+#include ""compat.h""
+#include ""trinity.h""// ARRAY_SIZE
+
+#ifdef USE_CAIF
+#include <linux/caif/caif_socket.h>
+#endif
+
+#define SOL_CAIF 278
+
+#ifdef USE_CAIF
+#define NR_SOL_CAIF_OPTS ARRAY_SIZE(caif_opts)
+static int caif_opts[] = { CAIFSO_LINK_SELECT, CAIFSO_REQ_PARAM };
+#endif
+
+void caif_setsockopt(struct sockopt *so)
+{
+unsigned char val;
+
+so->level = SOL_CAIF;
+
+#ifdef USE_CAIF
+val = rand() % NR_SOL_CAIF_OPTS;
+so->optname = caif_opts[val];
+#endif
+}
",14,2
move alg setsockopt out to own file,"
+#include ""net.h""
+
+#define SOL_ALG 279
+
+void alg_setsockopt(struct sockopt *so)
+{
+so->level = SOL_ALG;
+}
",5,1
move nfc setsockopt out to own file,"
+#include ""net.h""
+
+#define SOL_NFC 280
+
+void nfc_setsockopt(struct sockopt *so)
+{
+so->level = SOL_NFC;
+}
",5,1
silence some llvm warnings,"
 void sanitise_socket(int childno)
 {
 unsigned long family;
-struct proto_type pt;
+struct proto_type pt = { .protocol = 0, .type = 0 };
 
 if (do_specific_proto == TRUE)
 family = specific_proto;
",103,29
rename sockaddr generation functions,"
 #ifdef USE_IF_ALG
 #include <linux/if_alg.h>
 
-void gen_alg(unsigned long *addr, unsigned long *addrlen)
+void alg_gen_sockaddr(unsigned long *addr, unsigned long *addrlen)
 {
 struct sockaddr_alg *alg;
 unsigned int i;
",25,4
rename function to match others from same proto," void atalk_gen_sockaddr(unsigned long *addr, unsigned long *addrlen)
 *addrlen = sizeof(struct sockaddr_at);
 }
 
-void appletalk_rand_socket(struct proto_type *pt)
+void atalk_rand_socket(struct proto_type *pt)
 {
 if (rand_bool()) {
 pt->type = SOCK_DGRAM;
",31,4
constify socket options,"
 #include ""trinity.h""// ARRAY_SIZE
 
 #define NR_SOL_ATM_OPTS ARRAY_SIZE(atm_opts)
-static int atm_opts[] = {
+static const int atm_opts[] = {
 SO_SETCLP, SO_CIRANGE, SO_ATMQOS, SO_ATMSAP, SO_ATMPVC, SO_MULTIPOINT };
 
 void atm_setsockopt(struct sockopt *so)
",16,1
socket options are unsigned,"
 #include ""trinity.h""// ARRAY_SIZE
 
 #define NR_SOL_ATM_OPTS ARRAY_SIZE(atm_opts)
-static const int atm_opts[] = {
+static const unsigned int atm_opts[] = {
 SO_SETCLP, SO_CIRANGE, SO_ATMQOS, SO_ATMSAP, SO_ATMPVC, SO_MULTIPOINT };
 
 void atm_setsockopt(struct sockopt *so)
",16,1
The remainder is more interesting here.," static unsigned int get_cpu(void)
 
 switch (i) {
 case 0: return -1;
-case 1: return rand() & 4095;
-case 2: return rand() & 15;
+case 1: return rand() % 4095;
+case 2: return rand() % 15;
 default:
 BUG(""unreachable!\n"");
 break;
",281,103
make get_cpus return something in the range of num online cpus most the time.,"
 static unsigned int get_cpu(void)
 {
 int i;
-i = rand() % 3;
+i = rand() % 100;
 
 switch (i) {
 case 0: return -1;
 case 1: return rand() % 4095;
 case 2: return rand() % 15;
+
+case 3 ... 99:
+return rand() % num_online_cpus;
+
 default:
 BUG(""unreachable!\n"");
 break;
",283,104
constify file/path names,"
 #include ""list.h""
 
 static int files_added = 0;
-char **fileindex;
+const char **fileindex;
 unsigned int files_in_index = 0;
 
 struct namelist {
 struct list_head list;
-char *name;
+const char *name;
 };
 
 static struct namelist *names = NULL;
 static int open_file(void)
 {
 int fd;
 int ret;
-char *filename;
+const char *filename;
 int flags;
 const char *modestr;
 struct stat sb;
 void close_files(void)
 nr_file_fds = 0;
 }
 
-char * get_filename(void)
+const char * get_filename(void)
 {
 if (files_in_index == 0)/* This can happen if we run with -n. Should we do something else ? */
 return NULL;
 char * get_filename(void)
 return fileindex[rand() % files_in_index];
 }
 
-char * generate_pathname(void)
+const char * generate_pathname(void)
 {
-char *pathname = get_filename();
+const char *pathname = get_filename();
 char *newpath;
 unsigned int len;
 unsigned int i, chance;
",288,68
add an extra case to the taviso rand function," static unsigned long taviso(void)
 {
 unsigned long r = 0;
 
-switch (rand() % 3) {
+switch (rand() % 4) {
 case 0:r = rand() & rand();
 #if __WORDSIZE == 64
 r <<= 32;
 static unsigned long taviso(void)
 #endif
 break;
 
-case 1:r = rand() | rand();
+case 1:r = rand() % rand();
+#if __WORDSIZE == 64
+r <<= 32;
+r |= rand() % rand();
+#endif
+break;
+
+case 2:r = rand() | rand();
 #if __WORDSIZE == 64
 r <<= 32;
 r |= rand() | rand();
 #endif
 break;
 
-case 2:r = rand();
+case 3:r = rand();
 #if __WORDSIZE == 64
 r <<= 32;
 r |= rand();
",172,51
use rand_bool everywhere instead of rand() % 2,"
 #include ""sanitise.h""
 #include ""constants.h""
 #include ""list.h""
+#include ""random.h""
 
 static int files_added = 0;
 const char **fileindex;
 const char * generate_pathname(void)
 generate_random_page(newpath);
 
 /* sometimes, just complete junk. */
-if (rand() % 2)
+if (rand_bool())
 goto out;
 
 /* Sometimes, pathname + junk */
-if (rand() % 2)
+if (rand_bool())
 (void) strncpy(newpath, pathname, len);
 else {
 /* make it look relative to cwd */
 const char * generate_pathname(void)
 }
 
 /* Sometimes, remove all /'s */
-if ((rand() % 2) == 0) {
+if (rand_bool()) {
 for (i = 0; i < len; i++) {
 if (newpath[i] == '/')
 newpath[i] = rand();
 const char * generate_pathname(void)
 }
 out:
 /* 50/50 chance of making it look like a dir */
-if ((rand() % 2) == 0) {
+if (rand_bool()) {
 newpath[len] = '/';
 newpath[len + 1] = 0;
 }
",289,68
device names can be const.,"
 static struct {
 int major;
 int minor;
-char *name;
+const char *name;
 } *block_devs, *char_devs, *misc_devs;
 
 static size_t bldevs, chrdevs, miscdevs;
",120,26
move ARG_RANDOM_PAGE out to own function," static unsigned long handle_arg_list(unsigned long call, unsigned long argnum)
 return mask;
 }
 
+static unsigned long handle_arg_randpage(void)
+{
+if (rand_bool())
+return (unsigned long) page_allocs;
+else
+return (unsigned long) page_rand;
+}
+
 static unsigned long fill_arg(int childno, int call, int argnum)
 {
 unsigned long i;
 static unsigned long fill_arg(int childno, int call, int argnum)
 return handle_arg_list(call, argnum);
 
 case ARG_RANDPAGE:
-if (rand_bool())
-return (unsigned long) page_allocs;
-else
-return (unsigned long) page_rand;
+return handle_arg_randpage();
 
 case ARG_CPU:
 return (unsigned long) get_cpu();
",308,109
"rename ARG_RANDOM_INT to ARG_RANDOM_LONG

This has been bugging me for a while."," static unsigned long fill_arg(int childno, int call, int argnum)
 
 switch (argtype) {
 case ARG_UNDEFINED:
-case ARG_RANDOM_INT:
+case ARG_RANDOM_LONG:
 return (unsigned long) rand64();
 
 case ARG_FD:
",325,113
"Rewrite the tree-walk permissions checking

It looks like there were some cases where we'd miss a file we could read/write."," static int check_stat_file(const struct stat *sb)
 set_read = TRUE;
 if (sb->st_mode & S_IWUSR)
 set_write = TRUE;
+}
 
-} else if (sb->st_gid == my_gid) {
+if (sb->st_gid == my_gid) {
 if (sb->st_mode & S_IRGRP)
 set_read = TRUE;
 if (sb->st_mode & S_IWGRP)
 set_write = TRUE;
-
-} else {
-if ((sb->st_mode & S_IROTH))
-set_read = TRUE;
-if (sb->st_mode & S_IWOTH)
-set_write = TRUE;
 }
 
+if (sb->st_mode & S_IROTH)
+set_read = TRUE;
+if (sb->st_mode & S_IWOTH)
+set_write = TRUE;
+
+
 if ((set_read | set_write) == 0)
 return -1;
 
",289,68
"Split shm->parentpid into two.

In some cases this was 'initial process', and the rest of the time 'forking thread'.
Split into two so watchdog monitors only the forking process.

This way, if for whatever reason the forking thread dies (usually a segv)
then we don't hang, because the watchdog will see it's no longer around
instead of it checking on the init process.

Additionally, these pids don't need to be in the shm."," void check_parent_pid(void)
 
 parent_check_time = 10;
 
-if (getppid() == shm->parentpid)
+if (getppid() == mainpid)
 return;
 
 pid = getpid();
 void check_parent_pid(void)
 //FIXME: Add locking so only one child does this output.
 output(0, BUGTXT ""CHILD (pid:%d) GOT REPARENTED! ""
 ""parent pid:%d. Watchdog pid:%d\n"",
-pid, shm->parentpid, shm->watchdog_pid);
+pid, mainpid, shm->watchdog_pid);
 output(0, BUGTXT ""Last syscalls:\n"");
 
 for (i = 0; i < MAX_NR_CHILDREN; i++) {
",121,23
Move the watchdog pid out of the shm too.," void check_parent_pid(void)
 //FIXME: Add locking so only one child does this output.
 output(0, BUGTXT ""CHILD (pid:%d) GOT REPARENTED! ""
 ""parent pid:%d. Watchdog pid:%d\n"",
-pid, mainpid, shm->watchdog_pid);
+pid, mainpid, watchdog_pid);
 output(0, BUGTXT ""Last syscalls:\n"");
 
 for (i = 0; i < MAX_NR_CHILDREN; i++) {
",121,23
watchdog should check shm snity & main alive even if we're regenerating.," static void watchdog(void)
 
 while (watchdog_exit == FALSE) {
 
-if (shm->regenerating == FALSE) {
+if (check_shm_sanity() == SHM_CORRUPT)
+goto corrupt;
 
-if (check_shm_sanity() == SHM_CORRUPT)
-goto corrupt;
+check_main();
 
-reap_dead_kids();
+if (shm->regenerating == FALSE) {
 
-check_main();
+reap_dead_kids();
 
 check_children();
 
",256,56
"Revert ""Move the watchdog pid out of the shm too.""

This reverts commit b1a2fa9391cd2e8bf40601ee2df3b374ab846d2a.

This is nonsense, of course it needs to be in the shm."," void check_parent_pid(void)
 //FIXME: Add locking so only one child does this output.
 output(0, BUGTXT ""CHILD (pid:%d) GOT REPARENTED! ""
 ""parent pid:%d. Watchdog pid:%d\n"",
-pid, mainpid, watchdog_pid);
+pid, mainpid, shm->watchdog_pid);
 output(0, BUGTXT ""Last syscalls:\n"");
 
 for (i = 0; i < MAX_NR_CHILDREN; i++) {
",121,23
"move watchdog_pid out of shm, take 2.

This way should work better."," void check_parent_pid(void)
 //FIXME: Add locking so only one child does this output.
 output(0, BUGTXT ""CHILD (pid:%d) GOT REPARENTED! ""
 ""parent pid:%d. Watchdog pid:%d\n"",
-pid, mainpid, shm->watchdog_pid);
+pid, mainpid, watchdog_pid);
 output(0, BUGTXT ""Last syscalls:\n"");
 
 for (i = 0; i < MAX_NR_CHILDREN; i++) {
",121,23
move function to avoid need for prototype,"
 
 pid_t watchdog_pid;
 
-static void watchdog(void);
-
-void init_watchdog(void)
-{
-pid_t pid;
-
-fflush(stdout);
-pid = fork();
-
-if (pid == 0) {
-watchdog_pid = getpid();
-watchdog(); // Never returns.
-} else {
-watchdog_pid = pid;
-output(0, ""[%d] Started watchdog process, PID is %d\n"", getpid(), watchdog_pid);
-}
-}
-
 static int check_shm_sanity(void)
 {
 unsigned int i;
 corrupt:
 
 _exit(EXIT_SUCCESS);
 }
+
+void init_watchdog(void)
+{
+pid_t pid;
+
+fflush(stdout);
+pid = fork();
+
+if (pid == 0) {
+watchdog_pid = getpid();
+watchdog(); // Never returns.
+} else {
+watchdog_pid = pid;
+output(0, ""[%d] Started watchdog process, PID is %d\n"", getpid(), watchdog_pid);
+}
+}
",255,55
move exit related stuff out of the watchdog function.," corrupt:
 sleep(1);
 
 kill_all_kids();
-
-output(0, ""[%d] Watchdog exiting\n"", getpid());
-
-_exit(EXIT_SUCCESS);
 }
 
 void init_watchdog(void)
 void init_watchdog(void)
 
 if (pid == 0) {
 watchdog_pid = getpid();
-watchdog(); // Never returns.
+watchdog();
+output(0, ""[%d] Watchdog exiting\n"", watchdog_pid);
+_exit(EXIT_SUCCESS);
+
 } else {
 watchdog_pid = pid;
 output(0, ""[%d] Started watchdog process, PID is %d\n"", getpid(), watchdog_pid);
",255,55
"If the 'main' process crashes during regeneration, avoid hanging the watchdog"," static void check_main(void)
 if (errno == ESRCH) {
 output(0, ""[watchdog] main pid %d has disappeared.\n"", mainpid);
 shm->exit_reason = EXIT_MAIN_DISAPPEARED;
+
+/* if main crashed while regenerating, we'll hang the watchdog,
+ * because nothing will ever set it back to FALSE. So we do it ourselves.
+ */
+shm->regenerating = FALSE;
 } else {
 output(0, ""[watchdog] problem checking on pid %d (%d:%s)\n"", mainpid, errno, strerror(errno));
 }
",256,55
add special case for 'main dead' to bail the watchdog loop.," static int check_shm_sanity(void)
 return SHM_OK;
 }
 
-static void check_main(void)
+static int check_main_alive(void)
 {
 int ret;
 
 static void check_main(void)
 } else {
 output(0, ""[watchdog] problem checking on pid %d (%d:%s)\n"", mainpid, errno, strerror(errno));
 }
+return FALSE;
 }
+return TRUE;
 }
 
 static unsigned int reap_dead_kids(void)
 static void watchdog(void)
 if (check_shm_sanity() == SHM_CORRUPT)
 goto corrupt;
 
-check_main();
+if (check_main_alive() == FALSE)
+goto main_dead;
 
 if (shm->regenerating == FALSE) {
 
 static void watchdog(void)
 }
 }
 
+main_dead:
 /* Are we done ? */
 if (shm->exit_reason != STILL_RUNNING) {
 /* Give children a chance to exit. */
",260,56
Sanity check to catch a rare segv," static void check_children(void)
 
 memset(fdstr, 0, sizeof(fdstr));
 
-if (check_if_fd(callno, i) == TRUE)
-sprintf(fdstr, ""(fd = %ld)"", shm->a1[i]);
+if ((int) callno == -1) {
+output(0, ""[watchdog] callno was -1. WTF!\n"");
+shm->exit_reason = EXIT_REACHED_COUNT;
+} else {
+if (check_if_fd(callno, i) == TRUE)
+sprintf(fdstr, ""(fd = %ld)"", shm->a1[i]);
+}
 
 output(0, ""[watchdog] pid %d hasn't made progress in 30 seconds! (last:%ld now:%ld diff:%d). ""
 ""Stuck in syscall %d:%s%s%s. Sending SIGKILL.\n"",
",265,57
"Fix up i386 socketcall segfault.

This was an ugly bug.
Occasionally the watchdog would segv after trying to print info
about syscall number -1. It happened because socketcall was trying
to lookup ""socket"", which doesn't exist on i386.

Instead, we repurpose the sanitise function from socket into a
function that generates family/type/protocol triplets.","
 */
 #include <stdlib.h>
 #include <linux/net.h>
+#include <sys/types.h> /* See NOTES */
+#include <sys/socket.h>
 #include ""compat.h""
+#include ""net.h""
 #include ""sanitise.h""
 #include ""shm.h""
 
+//FIXME: Change to table driven, instead of switch.
+
 static void sanitise_socketcall(int childno)
 {
+struct socket_triplet st;
 unsigned long *args;
 
 args = malloc(6 * sizeof(unsigned long));
 static void sanitise_socketcall(int childno)
 shm->a1[childno] = rand() % 20;
 
 switch (shm->a1[childno]) {
+
 case SYS_SOCKET:
-sanitise_socket(childno);
-shm->syscallno[childno] = search_syscall_table(syscalls, max_nr_syscalls, ""socket"");
+gen_socket_args(&st);
+args[0] = st.family;
+args[1] = st.type;
+args[2] = st.protocol;
 break;
+
 case SYS_BIND:
 break;
 case SYS_CONNECT:
",72,21
"kill off struct proto_type

Seems pointless given we have the triplet"," void atalk_gen_sockaddr(unsigned long *addr, unsigned long *addrlen)
 *addrlen = sizeof(struct sockaddr_at);
 }
 
-void atalk_rand_socket(struct proto_type *pt)
+void atalk_rand_socket(struct socket_triplet *st)
 {
 if (rand_bool()) {
-pt->type = SOCK_DGRAM;
- pt->protocol = 0;
+st->type = SOCK_DGRAM;
+ st->protocol = 0;
  return;
 }
 
-pt->protocol = rand() % PROTO_MAX;
-pt->type = SOCK_RAW;
+st->protocol = rand() % PROTO_MAX;
+st->type = SOCK_RAW;
 }
",31,4
"Add PTRACE_GETSIGMASK and PTRACE_SETSIGMASK

ptrace still disabled, but adding for completeness."," struct syscall syscall_ptrace = {
 .arg1name = ""request"",
 .arg1type = ARG_OP,
 .arg1list = {
-.num = 23,
+.num = 25,
 .values = { PTRACE_TRACEME, PTRACE_PEEKTEXT, PTRACE_PEEKDATA, PTRACE_PEEKUSR,
 PTRACE_POKETEXT, PTRACE_POKEDATA, PTRACE_POKEUSR, PTRACE_GETREGS,
 PTRACE_GETFPREGS, PTRACE_GETSIGINFO, PTRACE_SETREGS, PTRACE_SETFPREGS,
 PTRACE_SETSIGINFO, PTRACE_SETOPTIONS, PTRACE_GETEVENTMSG, PTRACE_CONT,
 PTRACE_SYSCALL, PTRACE_SINGLESTEP, PTRACE_SYSEMU, PTRACE_SYSEMU_SINGLESTEP,
-PTRACE_KILL, PTRACE_ATTACH, PTRACE_DETACH },
+PTRACE_KILL, PTRACE_ATTACH, PTRACE_DETACH, PTRACE_GETSIGMASK,
+PTRACE_SETSIGMASK },
 },
 .arg2name = ""pid"",
 .arg3name = ""addr"",
",34,1
"Fix potential div0 in ARG_LIST handling.

appease coverity.

In theory there's a divide by zero here if we ever had syscall arg
annotated as ARG_LIST, with 0 elements. Hopefully I'm not dumb enough
to create such an entry, but just in case.."," static unsigned long handle_arg_list(unsigned long call, unsigned long argnum)
 break;
 default: break;
 }
+
+if (num == 0)
+BUG(""ARG_LIST with 0 args. What?\n"");
+
 bits = rand() % num;/* num of bits to OR */
 for (i = 0; i < bits; i++)
 mask |= values[rand() % num];
",327,114
ARG_OP has the same issue.," static unsigned long handle_arg_op(unsigned long call, unsigned long argnum)
 break;
 default: break;
 }
+
+if (num == 0)
+BUG(""ARG_OP with 0 args. What?\n"");
+
 mask |= values[rand() % num];
 return mask;
 }
",329,115
more 'should never happen' bulletproofing.," static unsigned long handle_arg_op(unsigned long call, unsigned long argnum)
 if (num == 0)
 BUG(""ARG_OP with 0 args. What?\n"");
 
+if (values == NULL)
+BUG(""ARG_OP with no values.\n"");
+
 mask |= values[rand() % num];
 return mask;
 }
 static unsigned long handle_arg_list(unsigned long call, unsigned long argnum)
 if (num == 0)
 BUG(""ARG_LIST with 0 args. What?\n"");
 
+if (values == NULL)
+BUG(""ARG_LIST with no values.\n"");
+
 bits = rand() % num;/* num of bits to OR */
 for (i = 0; i < bits; i++)
 mask |= values[rand() % num];
",333,117
"improve randomness in rand64()

Commit 6112813df53ce6762f5c8de1d4382d67f9f2f769 introduced
code to occasionally invert the valuerand64(). However the code
mistakenly zeroed the value instead by xoring it with itself.

Signed-off-by: Andy Honig <ahonig@google.com>"," u64 rand64(void)
 }
 
 if (rand_bool())
-r ^= r;
+r = ~r;
 
 /* increase distribution in MSB */
 if ((rand() % 10)) {
",173,51
"fix potential use after free if memory alloc fails.

Coverity #1042351"," static void parse_proc_devices(void)
 
 if (block) {
 new = realloc(block_devs, (bldevs+1)*sizeof(*block_devs));
-if (!new) {
+if (!new) {// FIXME: We should propagate failure up here.
 free(name);
-continue;
+break;
 }
 block_devs = new;
 block_devs[bldevs].major = major;
 static void parse_proc_devices(void)
 new = realloc(char_devs, (chrdevs+1)*sizeof(*char_devs));
 if (!new) {
 free(name);
-continue;
+break;
 }
 char_devs = new;
 char_devs[chrdevs].major = major;
",120,26
"move the 'change to tmp/' code out to its own function.

Coverity #1042334"," static int munge_tables(void)
 return TRUE;
 }
 
+/*
+ * just in case we're not using the test.sh harness, we
+ * change to the tmp dir if it exists.
+ */
+static void change_tmp_dir(void)
+{
+struct stat sb;
+const char tmpdir[]=""tmp/"";
+int ret;
+
+/* Check if it exists, bail early if it doesn't */
+ret = (lstat(tmpdir, &sb));
+if (ret == -1)
+return;
+
+/* Just in case a previous run screwed the perms. */
+ret = chmod(tmpdir, 0755);
+if (ret == -1)
+output(0, ""Couldn't chmod %s to 0755.\n"", tmpdir);
+
+ret = chdir(tmpdir);
+if (ret == -1)
+output(0, ""Couldn't change to %s\n"", tmpdir);
+}
+
+
 int main(int argc, char* argv[])
 {
 int ret = EXIT_SUCCESS;
 int main(int argc, char* argv[])
 ignore_tainted = TRUE;
 }
 
-/* just in case we're not using the test.sh harness. */
-chmod(""tmp/"", 0755);
-ret = chdir(""tmp/"");
-if (!ret) {
-/* nothing right now */
-}
+change_tmp_dir();
 
 /* check if we ctrl'c or something went wrong during init. */
 if (shm->exit_reason != STILL_RUNNING)
",204,38
remove unnecessary allocation,"
 
 static void post_shmget(int syscallret)
 {
-struct shmid_ds *shmid_ds;
-
 if (syscallret == -1)
 return;
 
-shmid_ds = malloc(sizeof(struct shmid_ds));
-
-shmctl(syscallret, IPC_RMID, shmid_ds);
-
-free(shmid_ds);
+shmctl(syscallret, IPC_RMID, 0);
 }
 
 struct syscall syscall_shmget = {
",19,2
"fix another use-after-free in devices.c

I missed one variant in 0d6921aa64dafa990cdc6fcbdf1589a8ace82a69"," static void parse_proc_misc(void)
 new = realloc(misc_devs, (miscdevs+1)*sizeof(*misc_devs));
 if (!new) {
 free(name);
-continue;
+break;
 }
 misc_devs = new;
 misc_devs[miscdevs].major = 0;
",120,26
fix off by one in ARG_LIST number of bits.," static unsigned long handle_arg_list(unsigned long call, unsigned long argnum)
 if (values == NULL)
 BUG(""ARG_LIST with no values.\n"");
 
-bits = rand() % num;/* num of bits to OR */
+bits = rand() % (num + 1);/* num of bits to OR */
 for (i = 0; i < bits; i++)
 mask |= values[rand() % num];
 return mask;
",333,117
"Fix child crash when disabling some syscalls on biarch

Check if search_syscall_table() fails and returns -1. This avoids
crashing the child processes, that I was seeing on x86-64 with the
msgrcv() syscall."," long mkcall(int childno)
 {
 unsigned long olda1, olda2, olda3, olda4, olda5, olda6;
 unsigned int call = shm->syscallno[childno];
-unsigned int call32, call64;
 unsigned long ret = 0;
+int call32, call64;
 int errno_saved;
 char string[512], *sptr;
 
 args_done:
 syscalls[call].entry->flags &= ~ACTIVE;
 } else {
 call32 = search_syscall_table(syscalls_32bit, max_nr_32bit_syscalls, syscalls[call].entry->name);
-syscalls_32bit[call32].entry->flags &= ~ACTIVE;
+if (call32 != -1)
+syscalls_32bit[call32].entry->flags &= ~ACTIVE;
+
 call64 = search_syscall_table(syscalls_64bit, max_nr_64bit_syscalls, syscalls[call].entry->name);
-syscalls_64bit[call64].entry->flags &= ~ACTIVE;
-output(1, ""Disabled syscalls 32bit:%d 64bit:%d\n"", call32, call64);
+if (call64 != -1)
+syscalls_64bit[call64].entry->flags &= ~ACTIVE;
 }
 }
 
",177,31
"Do not busy loop child processes on startup

Stop busy looping the child processes on trinity startup, so that they
do not compete with the main process for CPU time."," static void fork_children(void)
 }
 
 /* Wait for all the children to start up. */
-while (shm->ready == FALSE);
+while (shm->ready == FALSE)
+sleep(1);
 
 init_child(pidslot);
 
",309,65
"Introduce child process types.

'do random syscalls' is just one type. (And right now, the only one).

More to follow.","
 #include ""signals.h""
 #include ""pids.h""
 #include ""params.h""// for 'debug'
+#include ""trinity.h""// ARRAY_SIZE
 
 static struct rlimit oldrlimit;
 
 void check_parent_pid(void)
 //TODO: Emergency logging.
 }
 
+struct child_funcs {
+int type;
+const char *name;
+int (*func)(int childno);
+};
+
+static const struct child_funcs child_functions[] = {
+{ .type = CHILD_RANDOM_SYSCALLS, .name = ""rand_syscalls"", .func = do_random_syscalls },
+};
+
 int child_process(int childno)
 {
 int ret;
+unsigned int i;
+
+i = rand() % ARRAY_SIZE(child_functions);
+
+output(0, ""rand:%d\n"", i);
+
+output(0, ""Chose %s for process %d\n"", child_functions[i].name, getpid());
 
-ret = do_random_syscalls(childno);
+shm->child_type[childno] = child_functions[i].type;
+ret = child_functions[i].func(childno);
 
 reenable_coredumps();
 
",135,23
"add a second child type. (read all files)

This is disabled for now, because it's pretty dull, and there is
some more groundwork to do before we can have multiple child types running."," struct child_funcs {
 };
 
 static const struct child_funcs child_functions[] = {
-{ .type = CHILD_RANDOM_SYSCALLS, .name = ""rand_syscalls"", .func = do_random_syscalls },
+{ .type = CHILD_RANDOM_SYSCALLS, .name = ""rand_syscalls"", .func = child_random_syscalls },
+//{ .type = CHILD_OPEN_ALL_FILES, .name = ""read_all_files"", .func = child_read_all_files },
 };
 
 int child_process(int childno)
 int child_process(int childno)
 
 i = rand() % ARRAY_SIZE(child_functions);
 
-output(0, ""rand:%d\n"", i);
-
 output(0, ""Chose %s for process %d\n"", child_functions[i].name, getpid());
 
 shm->child_type[childno] = child_functions[i].type;
",134,23
"net/alg.c: Include compat.h.

This patch fixes this build error with glibc before 2.13.

 CC	net/alg.o
net/alg.c: In function alg_gen_sockaddr:
net/alg.c:21: error: PF_ALG undeclared (first use in this function)
net/alg.c:21: error: (Each undeclared identifier is reported only once
net/alg.c:21: error: for each function it appears in.)

Signed-off-by: Vinson Lee <vlee@twitter.com>","
 #include <stdlib.h>
 #include ""config.h""
 #include ""net.h""
+#include ""compat.h""
 
 #ifdef USE_IF_ALG
 #include <linux/if_alg.h>
",26,4
"net/caif.c: Include compat.h.

This patch fixes this build error with glibc before 2.13.

 CC net/caif.o
net/caif.c: In function caif_gen_sockaddr:
net/caif.c:22: error: PF_CAIF undeclared (first use in this function)
net/caif.c:22: error: (Each undeclared identifier is reported only once
net/caif.c:22: error: for each function it appears in.)
make: *** [net/caif.o] Error 1

Signed-off-by: Vinson Lee <vlee@twitter.com>","
 #include ""config.h""
 #include ""net.h""
 #include ""random.h""
+#include ""compat.h""
 
 #ifdef USE_CAIF
 #include <linux/caif/caif_socket.h>
",39,6
add AT_FDCWD special case to linkat,"
  int, newdfd, const char __user *, newname, int, flags)
 */
 #include <fcntl.h>
-#include ""sanitise.h""
+#include <stdlib.h>
 #include ""compat.h""
+#include ""shm.h""
+#include ""sanitise.h""
+
+static void sanitise_linkat(int childno)
+{
+/* .. If oldpath is relative and olddirfd is the special value AT_FDCWD, then oldpath is
+ * interpreted relative to the current working directory of the calling process */
+if ((rand() % 100) == 0)
+shm->a1[childno] = AT_FDCWD;
+}
 
 struct syscall syscall_linkat = {
 .name = ""linkat"",
 struct syscall syscall_linkat = {
 },
 .flags = NEED_ALARM,
 .group = GROUP_VFS,
+.sanitise = sanitise_linkat,
 };
",31,2
"add a case where random pathname can be """"

brought on because of this kernel commit:
""fs: Allow unprivileged linkat(..., AT_EMPTY_PATH) aka flink"""," const char * generate_pathname(void)
 if (newpath == NULL)
 return pathname;// give up.
 
+/* empty string. */
+if ((rand() % 100) == 0) {
+memset(newpath, 0, page_size);
+goto out;
+}
+
 generate_random_page(newpath);
 
 /* sometimes, just complete junk. */
",54,12
minor fixes to random pathname code.," const char * generate_pathname(void)
 const char *pathname = get_filename();
 char *newpath;
 unsigned int len;
-unsigned int i, chance;
+unsigned int i;
 
 if (pathname == NULL)/* As above, handle -n correctly. */
 return NULL;
 
-len = strlen(pathname);
+switch (rand() % 100) {
 
-chance = rand() % 100;
-switch (chance) {
-
-case 0 ... 90:
+case 0 ... 89:
 /* 90% chance of returning an unmangled filename */
 return pathname;
 
-case 91 ... 99:
+case 90 ... 99:
 /* Create a bogus filename. */
 newpath = malloc(page_size);// FIXME: We leak this.
 if (newpath == NULL)
 return pathname;// give up.
 
+len = strlen(pathname);
+
 /* empty string. */
 if ((rand() % 100) == 0) {
 memset(newpath, 0, page_size);
 const char * generate_pathname(void)
 else {
 /* make it look relative to cwd */
 newpath[0] = '.';
-(void) strncpy(newpath + 1, pathname, len);
+newpath[1] = '/';
+(void) strncpy(newpath + 2, pathname, len);
 }
 
 /* Sometimes, remove all /'s */
",54,12
"Fix -P usage, broken by recent reworking of socket generation."," static void generate_sockets(void)
 
 for (st.family = 0; st.family < TRINITY_PF_MAX; st.family++) {
 
+if (do_specific_proto == TRUE)
+st.family = specific_proto;
+
 if (get_proto_name(st.family) == NULL)
 goto skip;
 
",189,35
disable that 'Chose' output by default until we have more children types," struct child_funcs {
 
 static const struct child_funcs child_functions[] = {
 { .type = CHILD_RANDOM_SYSCALLS, .name = ""rand_syscalls"", .func = child_random_syscalls },
-//{ .type = CHILD_OPEN_ALL_FILES, .name = ""read_all_files"", .func = child_read_all_files },
+#ifdef DEBUG_MULTI
+{ .type = CHILD_OPEN_ALL_FILES, .name = ""read_all_files"", .func = child_read_all_files },
+#endif
 };
 
 int child_process(int childno)
 int child_process(int childno)
 
 i = rand() % ARRAY_SIZE(child_functions);
 
+#ifdef DEBUG_MULTI
 output(0, ""Chose %s for process %d\n"", child_functions[i].name, getpid());
+#endif
 
 shm->child_type[childno] = child_functions[i].type;
 ret = child_functions[i].func(childno);
",135,24
reduce the amount of casting in check_if_fd," static unsigned int reap_dead_kids(void)
 /* if the first arg was an fd, find out which one it was. */
 static unsigned int check_if_fd(unsigned int callno, unsigned int child)
 {
+unsigned int fd;
+
 /* shortcut, if it's out of range, it's not going to be valid. */
-if ((unsigned long) shm->a1[child] > 1024)
+fd = shm->a1[child];
+if (fd > 1024)
 return FALSE;
-if ((unsigned long) shm->a1[child] < highest_logfile())
+if (fd < highest_logfile())
 return FALSE;
 
 if (biarch == FALSE) {
",267,57
generate some perf fds in the parent for sharing.,"
 #include <string.h>
 #include <unistd.h>
 
+#include ""perf.h""
 #include ""shm.h""
 #include ""files.h""
 #include ""pids.h""
 regen:
 void setup_fds(void)
 {
 open_sockets();
-if (no_files == TRUE)
-return;
 
 open_pipes();
 
-generate_filelist();
-if (files_in_index == 0)
-return;
+open_perf_fds();
 
-open_files();
+if (no_files == FALSE) {
+generate_filelist();
+if (files_in_index == 0)/* Something bad happened. Crappy -V maybe? */
+return;// FIXME: We should log something here probably.
+
+open_files();
+}
 }
 
 void regenerate_fds(void)
",107,23
"can.c: Include compat.h.

This patch fixes these build errors with glibc before 2.10.

net/can.c: In function can_gen_sockaddr:
net/can.c:17: error: AF_CAN undeclared (first use in this function)
net/can.c:17: error: (Each undeclared identifier is reported only once
net/can.c:17: error: for each function it appears in.)

Signed-off-by: Vinson Lee <vlee@twitter.com>","
 #include <stdlib.h>
 #include ""net.h""
 #include ""random.h""
+#include ""compat.h""
 
 void can_gen_sockaddr(unsigned long *addr, unsigned long *addrlen)
 {
",27,3
"crazy idea: actually use those shared perf fds.

derp."," static int rand_pipe_fd(void)
 return shm->pipe_fds[rand() % MAX_PIPE_FDS];
 }
 
+static int rand_perf_fd(void)
+{
+return shm->perf_fds[rand() % MAX_PERF_FDS];
+}
+
 static int get_new_random_fd(void)
 {
 unsigned int i;
 int fd = 0;
 
-i = rand() % 3;
+i = rand() % 4;
 
 if (do_specific_proto == TRUE)
 i = 1;
 static int get_new_random_fd(void)
 case 2:
 fd = rand_pipe_fd();
 break;
+
+case 3:
+fd = rand_perf_fd();
+break;
+
 default:
 break;
 }
",114,25
"perf may not be available

We had an infinite loop here if we got an ENOSYS back. oops."," static int get_new_random_fd(void)
 unsigned int i;
 int fd = 0;
 
+retry:
 i = rand() % 6;
 
 if (do_specific_proto == TRUE)
 static int get_new_random_fd(void)
 break;
 
 case 3:
+if (shm->perf_fds[0] == 0)/* perf unavailable/disabled. */
+goto retry;
+
 fd = rand_perf_fd();
 break;
 
",170,37
"update perf_event_open() for Linux 3.11 release

Update the perf_event_open syscall support for new ABIs added
in the 3.11 release.

Thankfully this is pretty minor. Lots of big changes to the ABI
seem to be afoot for 3.12 though.

Signed-off-by: Vince Weaver <vincent.weaver@maine.edu>"," static long long random_branch_sample_type(void)
 if (rand_bool())
 branch_sample |= PERF_SAMPLE_BRANCH_IND_CALL;
 
+/* Transactional Memory Types */
+if (rand_bool())
+branch_sample |= PERF_SAMPLE_BRANCH_ABORT_TX;
+if (rand_bool())
+branch_sample |= PERF_SAMPLE_BRANCH_IN_TX;
+if (rand_bool())
+branch_sample |= PERF_SAMPLE_BRANCH_NO_TX;
+
 return branch_sample;
 }
 
",971,238
Add MAP_32BIT for x86-64 to mmap flags,"
 #include ""arch.h""
 #include ""compat.h""
 
+#ifdef __x86_64__
+#define NUM_FLAGS 13
+#else
 #define NUM_FLAGS 12
+#endif
 
 // need this to actually get MAP_UNINITIALIZED defined
 #define CONFIG_MMAP_ALLOW_UNINITIALIZED
 void sanitise_mmap(int childno)
 {
 unsigned int i;
 unsigned int flagvals[NUM_FLAGS] = { MAP_FIXED, MAP_ANONYMOUS,
- MAP_GROWSDOWN, MAP_DENYWRITE, MAP_EXECUTABLE, MAP_LOCKED,
- MAP_NORESERVE, MAP_POPULATE, MAP_NONBLOCK, MAP_STACK,
- MAP_HUGETLB, MAP_UNINITIALIZED };
+MAP_GROWSDOWN, MAP_DENYWRITE, MAP_EXECUTABLE, MAP_LOCKED,
+MAP_NORESERVE, MAP_POPULATE, MAP_NONBLOCK, MAP_STACK,
+MAP_HUGETLB, MAP_UNINITIALIZED,
+#ifdef __x86_64__
+MAP_32BIT,
+#endif
+};
 unsigned int numflags = rand() % NUM_FLAGS;
 
 /* Don't actually set a hint right now, in case we give out
",57,6
"rand64: we want a bit number here, not a value."," u64 rand64(void)
 
 rounds = rand() % 4;
 for (i = 0; i < rounds; i++)
-r |= (1L << (__WORDSIZE - (rand() % 256)));
+r |= (1L << (__WORDSIZE - (rand() % 8)));
 }
 
 /* randomly flip sign bit. */
",173,51
"rand64: bits are numbered 0-63, so we need to subtract one."," u64 rand64(void)
 
 rounds = rand() % 4;
 for (i = 0; i < rounds; i++)
-r |= (1L << (__WORDSIZE - (rand() % 8)));
+r |= (1L << ((__WORDSIZE - 1) - (rand() % 8)));
 }
 
 /* randomly flip sign bit. */
",173,51
"add support for the AArch64 architecture

This patch wires up support for the AArch64 architecture, which has been
supported in the mainline kernel (as arm64) since 3.7.

Signed-off-by: Will Deacon <will.deacon@arm.com>"," void select_syscall_tables(void)
 #elif defined(__sh__)
 syscalls = copy_syscall_table(syscalls_sh, ARRAY_SIZE(syscalls_sh));
 max_nr_syscalls = ARRAY_SIZE(syscalls_sh);
+#elif defined(__aarch64__)
+syscalls = copy_syscall_table(syscalls_aarch64, ARRAY_SIZE(syscalls_aarch64));
+max_nr_syscalls = ARRAY_SIZE(syscalls_aarch64);
 #else
 #error Unknown architecture.
 #endif
",615,160
"update perf_event support for 3.12-rc1

This patch wires up PERF_COUNT_SW_DUMMY and PERF_SAMPLE_IDENTIFIER
which appear in 3.12-rc1

Signed-off-by: Vince Weaver <vincent.weaver@maine.edu>"," static long long random_event_config(__u32 *event_type,
 }
 break;
 case PERF_TYPE_SOFTWARE:
-switch (rand() % 10) {
+switch (rand() % 11) {
 case 0:
 config = PERF_COUNT_SW_CPU_CLOCK;
 break;
 static long long random_event_config(__u32 *event_type,
 config = PERF_COUNT_SW_EMULATION_FAULTS;
 break;
 case 9:
+config = PERF_COUNT_SW_DUMMY;
+break;
+case 10:
 config = rand64();
 break;
 default:
 static long long random_sample_type(void)
 sample_type |= PERF_SAMPLE_WEIGHT;
 if (rand_bool())
 sample_type |= PERF_SAMPLE_DATA_SRC;
+if (rand_bool())
+sample_type |= PERF_SAMPLE_IDENTIFIER;
 
 return sample_type;
 }
",976,240
"make handle_arg_randpage copy the page_allocs page instead of passing it.

also fix broken indentation."," static unsigned long handle_arg_list(unsigned long call, unsigned long argnum)
 
 static unsigned long handle_arg_randpage(void)
 {
-if (rand_bool())
-return (unsigned long) page_allocs;
-else
-return (unsigned long) page_rand;
+/* Because we pass this to something that might overwrite it,
+ * and we want page_allocs to remain unmodified, we copy it to page rand instead.
+ */
+if (rand_bool())
+memcpy(page_rand, page_allocs, page_size);
+
+return (unsigned long) page_rand;
 }
 
 static unsigned long handle_arg_iovec(int childno, unsigned long call, unsigned long argnum)
",332,117
"Reduce the number of pages allocated in copy_syscall_table function.

This patch reduces the number of pages allocated in the copy_syscall_table
function.

Signed-off-by: Ildar Muslukhov <ildarm@google.com>"," static struct syscalltable * copy_syscall_table(struct syscalltable *from, unsig
 unsigned int n;
 struct syscall *copy;
 
-/* FIXME: Use fewer shared maps.
- * It's pretty sad that we use a whole page just for a copy of that struct when we
- * could fit dozens of them in a page. This would cut down our /proc/$$/maps a *lot*
- */
+copy = alloc_shared(nr * sizeof(struct syscall));
+if (copy == NULL)
+exit(EXIT_FAILURE);
+
 for (n = 0; n < nr; n++) {
-copy = alloc_shared(sizeof(struct syscall));
-if (copy == NULL)
-exit(EXIT_FAILURE);
-memcpy(copy, from[n].entry, sizeof(struct syscall));
-copy->number = n;
-from[n].entry = copy;
+memcpy(copy + n , from[n].entry, sizeof(struct syscall));
+copy[n].number = n;
+from[n].entry = &copy[n];
 }
 return from;
 }
",661,175
"Added parameter that controls which taint flag causes trinity to stop.

This is reworked patch for the parameter that allows to control which
kernel taint flags causes trinity to stop. In particular, now the short
parameter is -T (instead of -t) and flags has to be specified as literals
(e.g., DIE, WARN, USER, etc.). All 13 supported flags are specified in
README.

Signed-off-by: Ildar Muslukhov <ildarm@google.com>"," void do_main_loop(void);
 
 extern bool biarch;
 
-extern bool ignore_tainted;
 int check_tainted(void);
 
 void init_watchdog(void);
",13,1
We should be safe to do 32-bit syscalls from 64bit again.," static void choose_syscall_table(int childno)
  */
 shm->do32bit[childno] = FALSE;
 
-// FIXME: I forgot why this got disabled. Revisit.
-//if (rand() % 100 < 10)
-//shm->do32bit[childno] = TRUE;
+if (rand() % 100 < 10)
+shm->do32bit[childno] = TRUE;
 }
 
 
",79,20
remove callno param from check_if_fd," static unsigned int reap_dead_kids(void)
 }
 
 /* if the first arg was an fd, find out which one it was. */
-static unsigned int check_if_fd(unsigned int callno, unsigned int child)
+static unsigned int check_if_fd(unsigned int child)
 {
 unsigned int fd;
+unsigned callno = shm->syscallno[child];
 
 /* shortcut, if it's out of range, it's not going to be valid. */
 fd = shm->a1[child];
 static void check_children(void)
 output(0, ""[watchdog] callno was -1. WTF!\n"");
 shm->exit_reason = EXIT_REACHED_COUNT;
 } else {
-if (check_if_fd(callno, i) == TRUE)
+if (check_if_fd(i) == TRUE)
 sprintf(fdstr, ""(fd = %ld)"", shm->a1[i]);
 }
 
",268,57
remove pointless local var," static unsigned int reap_dead_kids(void)
 /* if the first arg was an fd, find out which one it was. */
 static unsigned int check_if_fd(unsigned int child)
 {
-unsigned int fd;
+unsigned int highest;
 unsigned callno = shm->syscallno[child];
 
 /* shortcut, if it's out of range, it's not going to be valid. */
-fd = shm->a1[child];
-if (fd > 1024)
+if (shm->a1[child] > 1024)
 return FALSE;
-if (fd < highest_logfile())
+
+highest = highest_logfile();
+if (shm->a1[child] < highest)
 return FALSE;
 
 if (biarch == FALSE) {
",268,57
print out the fd as an int.," static void check_children(void)
 shm->exit_reason = EXIT_REACHED_COUNT;
 } else {
 if (check_if_fd(i) == TRUE)
-sprintf(fdstr, ""(fd = %ld)"", shm->a1[i]);
+sprintf(fdstr, ""(fd = %d)"", (unsigned int) shm->a1[i]);
 }
 
 output(0, ""[watchdog] pid %d hasn't made progress in 30 seconds! (last:%ld now:%ld diff:%d). ""
",268,57
"check return from kill, just in case"," static void check_children(void)
 
 /* After 30 seconds of no progress, send a kill signal. */
 if (diff == 30) {
+int ret;
+
 stuck_syscall_info(i);
 output(0, ""[watchdog] pid %d hasn't made progress in 30 seconds! (last:%ld now:%ld diff:%d). Sending SIGKILL.\n"",
 pid, old, now, diff);
 
-kill(pid, SIGKILL);
+ret = kill(pid, SIGKILL);
+if (ret != 0) {
+output(0, ""[watchdog] couldn't kill pid %d [%s]\n"", pid, strerror(errno));
+}
 break;
 }
 
",273,58
"signal handler improvements.

When the alarm goes off, check if we're stuck in an fd."," extern bool biarch;
 int check_tainted(void);
 
 void init_watchdog(void);
+unsigned int check_if_fd(unsigned int child);
 
 extern unsigned int user_specified_children;
 
",14,1
print out pid in ENOSYS output," args_done:
 if (call == (unsigned int) search_syscall_table(syscalls, max_nr_syscalls, ""sendfile""))
 goto skip_enosys;
 
-output(1, ""%s (%d) returned ENOSYS, marking as inactive.\n"", syscalls[call].entry->name, call);
+output(1, ""[%d] %s (%d) returned ENOSYS, marking as inactive.\n"",
+getpid(), syscalls[call].entry->name, call);
 
 if (biarch == FALSE) {
 syscalls[call].entry->flags &= ~ACTIVE;
",199,33
"when we get back from the signal handler, print what happened in the child.

Ignore SIGALRM, it'll happen too often.","
 * Call random syscalls with random args.
 */
 
+#include <signal.h>
 #include <stdlib.h>
 #include <unistd.h>
 

 #include ""random.h""
 #include ""shm.h""
 #include ""signals.h""
+#include <string.h>
 #include ""pids.h""
 
 /*
 static void choose_syscall_table(int childno)
 }
 }
 
+extern int sigwas;
+
 int child_random_syscalls(int childno)
 {
 pid_t pid = getpid();
 int ret;
 unsigned int syscallnr;
 
-sigsetjmp(ret_jump, 1);
+ret = sigsetjmp(ret_jump, 1);
+if (ret != 0) {
+if (sigwas != SIGALRM)
+output(1, ""[%d] Back from signal handler! (sig was %s)\n"", getpid(), strsignal(sigwas));
+}
 
 ret = 0;
 
",86,22
add missing brackets to disambiguate," void output(unsigned char level, const char *fmt, ...)
 /* copy buffer, sans ANSI codes */
 len = strlen(outputbuf);
 for (i = 0, j = 0; i < len; i++) {
-if (outputbuf[i] == '')
+if (outputbuf[i] == '') {
 if (outputbuf[i + 2] == '1')
 i += 6;// ANSI_COLOUR
 else
 i += 3;// ANSI_RESET
-else {
+} else {
 monobuf[j] = outputbuf[i];
 j++;
 }
",156,29
"change the watchdog sigkill usage.

kill off the 60s counter, and instead use a 'kill count'.
After 30s, we send 1 kill per second, which seems more succesful.

(With -C64, we still see high kill counts before success, but we do
 eventually seem to make forward progress.)"," void init_child(int childno)
 
 set_seed(childno);
 
+shm->kill_count[childno] = 0;
+
 disable_coredumps();
 
 if (sched_getaffinity(pid, sizeof(set), &set) == 0) {
",136,24
reword parameter text for specifying whether to do 32/64 bit syscalls," static void usage(void)
 fprintf(stderr, "" --victims,-V: path to victim files.\n"");
 fprintf(stderr, "" --arch, -a: selects syscalls for the specified architecture (32 or 64). Both by default."");
 fprintf(stderr, ""\n"");
-fprintf(stderr, "" -c#,@: target specific syscall (takes syscall name as parameter and @ as architecture. No @ defaults to both archs.).\n"");
+fprintf(stderr, "" -c#,@: target specific syscall (takes syscall name as parameter and optionally 32 or 64 as bit-width. Default:both).\n"");
 fprintf(stderr, "" -N#: do # syscalls then exit.\n"");
 fprintf(stderr, "" -p: pause after syscall.\n"");
 fprintf(stderr, "" -s#: use # as random seed.\n"");
",258,55
"move the prefix printing into output itself.

small bug right now: Split calls to output() without a newline get
two prefixes logged. Will fix later."," int child_process(int childno)
 i = rand() % ARRAY_SIZE(child_functions);
 
 #ifdef DEBUG_MULTI
-output(0, ""Chose %s for process %d\n"", child_functions[i].name, getpid());
+output(0, ""Chose %s.\n"", child_functions[i].name);
 #endif
 
 shm->child_type[childno] = child_functions[i].type;
",136,24
rand_page: return page of format strings.," void generate_random_page(char *page)
 {
 unsigned int i;
 
-switch (rand() % 6) {
+switch (rand() % 7) {
 /* return a page of complete trash */
 case 0:/* bytes */
 for (i = 0; i < page_size; )
 void generate_random_page(char *page)
 page[i++] = (unsigned char)rand_bool();
 return;
 
+/* page full of format strings. */
+case 6:
+for (i = 0; i < page_size; ) {
+page[i++] = '%';
+switch (rand_bool()) {
+case 0:page[i++] = 'd';
+break;
+case 1:page[i++] = 's';
+break;
+default: break;
+}
+}
+return;
+
 default:
 BUG(""unreachable!\n"");
 return;
",91,25
limit setuid params to sizeof(uid_t),"
 /*
 * SYSCALL_DEFINE1(setuid, uid_t, uid)
 */
+#include ""random.h""
+#include ""shm.h""
 #include ""sanitise.h""
 
+static void sanitise_setuid(int childno)
+{
+shm->a1[childno] = rand32();
+}
+
 struct syscall syscall_setuid = {
 .name = ""setuid"",
 .num_args = 1,
 .arg1name = ""uid"",
+.sanitise = sanitise_setuid,
 };
",13,1
"fix incorrect syscall table usage on non-biarch

Spotted by Josh Scheid <jscheid@velocetechnologies.com>"," try32bit:
 &activate_syscall32, 32, syscalls_32bit[call32].entry->name);
 }
 
-
-
-
 } else {
+/* non-biarch case */
+
 call = rand() % max_nr_syscalls;
 
 if (validate_specific_syscall_silent(syscalls, call) == FALSE)
 goto retry;
 
 if (no_files == TRUE)
-if (is_syscall_net_related(syscalls_32bit, call) == FALSE)
+if (is_syscall_net_related(syscalls, call) == FALSE)
 goto retry;
 
 /* if we've set this to be disabled, don't enable it! */
",691,186
"Re-add checks for AVOID and correct syscall activation.

This patch fixes commit 6e296f3a7cab6d946479e76398535f107e80ac4d, that is
it adds back checks for AVOID types of syscalls and corrects syscalls
deactivation.

Signed-off-by: Ildar Muslukhov <ildarm@google.com>"," int child_random_syscalls(int childno)
 choose_syscall_table(childno);
 
 if (nr_active_syscalls == 0) {
-printf(""OOPS: no syscalls enabled\n"");
 shm->exit_reason = EXIT_NO_SYSCALLS_ENABLED;
 goto out;
 }
 int child_random_syscalls(int childno)
 }
 
 syscallnr = rand() % nr_active_syscalls;
+/* If we got a syscallnr which is not actvie repeat the attempt, since another child has switched that syscall off already.*/
+if (active_syscalls[syscallnr] == 0)
+continue;
+
 syscallnr = active_syscalls[syscallnr] - 1;
 
+if (validate_specific_syscall_silent(syscalls, syscallnr) == FALSE) {
+if (biarch == FALSE) {
+deactivate_syscall(syscallnr);
+} else {
+if (shm->do32bit[childno] == TRUE)
+deactivate_syscall32(syscallnr);
+else
+deactivate_syscall64(syscallnr);
+}
+continue;
+}
+
 shm->syscallno[childno] = syscallnr;
 
 if (syscalls_todo) {
",110,26
"fix arch selection parameter

This patch fixes arch (-a) selection parameter when applied to all
syscall.

Signed-off-by: Ildar Muslukhov <ildarm@google.com>"," void mark_all_syscalls_active(void)
 
 printf(""Marking all syscalls as enabled.\n"");
 if (biarch == TRUE) {
-for_each_32bit_syscall(i) {
-syscalls_32bit[i].entry->flags |= ACTIVE;
-activate_syscall32(i);
-}
-for_each_64bit_syscall(i) {
-syscalls_64bit[i].entry->flags |= ACTIVE;
-activate_syscall64(i);
-}
+if (do_32_arch)
+for_each_32bit_syscall(i) {
+syscalls_32bit[i].entry->flags |= ACTIVE;
+activate_syscall32(i);
+}
+if (do_64_arch)
+for_each_64bit_syscall(i) {
+syscalls_64bit[i].entry->flags |= ACTIVE;
+activate_syscall64(i);
+}
 } else {
 for_each_syscall(i) {
 syscalls[i].entry->flags |= ACTIVE;
",693,189
check if uid changes across syscalls.," long syscall32(int num_args, unsigned int call,
 return 0;
 }
 
+static void check_uid(uid_t olduid)
+{
+uid_t myuid;
+
+myuid = getuid();
+if (myuid != olduid) {
+
+/* unshare() can change us to /proc/sys/kernel/overflowuid */
+if (myuid == 65534)
+return;
+
+output(0, ""uid changed! Was: %d, now %d\n"", olduid, myuid);
+
+shm->exit_reason = EXIT_UID_CHANGED;
+_exit(EXIT_FAILURE);
+}
+}
 
 static unsigned long do_syscall(int childno, int *errno_saved)
 {
 long mkcall(int childno)
 unsigned long ret = 0;
 int errno_saved;
 char string[512], *sptr;
+uid_t olduid = getuid();
 
 shm->regenerate++;
 
 skip_enosys:
 shm->previous_a5[childno] = shm->a5[childno];
 shm->previous_a6[childno] = shm->a6[childno];
 
+check_uid(olduid);
+
 return ret;
 }
",278,66
"on nftw failure, print the errno string, instead of just '-1'"," static void open_fds(const char *dirpath)
 ret = nftw(dirpath, file_tree_callback, 32, flags);
 if (ret != 0) {
 if (shm->exit_reason != EXIT_SIGINT)
-output(0, ""Something went wrong during nftw(%s). Returned %d\n"", dirpath, ret);
+output(0, ""Something went wrong during nftw(%s). (%s)\n"",
+dirpath, ret, strerror(errno));
 return;
 }
 
",247,57
"remove unnecessary assignment

This actually prevents the watchdog exiting in some cases."," void do_main_loop(void)
 
 /* wait for main loop process to exit. */
 pid = waitpid(pid, &childstatus, 0);
-
-mainpid = 0;
 }
",308,65
"net/netlink: add missing compat.h include

On 3.0, we get:
net/netlink.c:32: error: 'NETLINK_CRYPTO' undeclared (first use in this function)","
 #include <netinet/in.h>
 #include <linux/netlink.h>
 #include <stdlib.h>
+#include ""compat.h""
 #include ""net.h""
 #include ""random.h""
 
",29,4
"fix broken includes

In 3.0, we get errors like:
/usr/include/linux/netlink.h:34: error: expected specifier-qualifier-list before 'sa_family_t'","
 #include <stdlib.h>
+#include <sys/socket.h> /* old irda.h is broken */
 #include <linux/irda.h>
 #include ""net.h""
 #include ""maps.h""// page_rand
",18,1
add missing reason string.," static const char *reasons[] = {
 ""Child reparenting problem"",
 ""No files in file list."",
 ""Main process disappeared."",
+""UID changed."",
 };
 
 static const char * decode_exit(unsigned int reason)
",309,65
"added outputerr/outputstd log functions

This patch adds two function that is going to be used for output to stdout and stderr. This is done in order to have printf called from one file.

Signed-off-by: Ildar Muslukhov <ildarm@google.com>"," void output(unsigned char level, const char *fmt, ...)
 fprintf(handle, ""%s %s"", prefix, monobuf);
 (void)fflush(handle);
 }
+
+/*
+* Used as a way to consolidated all printf calls if someones one to redirect it to somewhere else.
+* note: this function ignores quiet_level since it main purpose is error output.
+*/
+void outputerr(const char *fmt, ...)
+{
+va_list args;
+
+va_start(args, fmt);
+vfprintf(stderr, fmt, args);
+va_end(args);
+}
+
+void outputstd(const char *fmt, ...)
+{
+va_list args;
+
+va_start(args, fmt);
+vfprintf(stdout, fmt, args);
+va_end(args);
+}
",189,35
"wired outputstd/err functions

This patch replaces printf call with outputstd or outputerr functions where appropriate.

Signed-off-by: Ildar Muslukhov <ildarm@google.com>"," static void reenable_coredumps(void)
 prctl(PR_SET_DUMPABLE, TRUE);
 
 if (setrlimit(RLIMIT_CORE, &oldrlimit) != 0) {
-printf(""[%d] Error restoring rlimits to cur:%d max:%d (%s)\n"",
+outputerr(""[%d] Error restoring rlimits to cur:%d max:%d (%s)\n"",
 getpid(),
 (unsigned int) oldrlimit.rlim_cur,
 (unsigned int) oldrlimit.rlim_max,
 static void set_make_it_fail(void)
 
 if (write(fd, buf, 1) == -1) {
 if (errno != EPERM)
-printf(""writing to /proc/self/make-it-fail failed! (%s)\n"", strerror(errno));
+outputerr(""writing to /proc/self/make-it-fail failed! (%s)\n"", strerror(errno));
 else
 shm->do_make_it_fail = TRUE;
 }
",136,24
"wired in output function instead of printf (and some missing outputstd)

This patch replaces the remaining printf with output function call. Some of the printf are replaced with outputstd.

Signed-off-by: Ildar Muslukhov <ildarm@google.com>"," extern int sigwas;
 
 int child_random_syscalls(int childno)
 {
-pid_t pid = getpid();
 int ret;
 unsigned int syscallnr;
 
 int child_random_syscalls(int childno)
 
 if (syscalls_todo) {
 if (shm->total_syscalls_done >= syscalls_todo) {
-output(0, ""[%d] shm->total_syscalls_done (%d) >= syscalls_todo (%d)\n"",
-pid, shm->total_syscalls_done,syscalls_todo);
+output(0, ""Reached maximum syscall count (todo = %d, done = %d), exiting...\n"",
+syscalls_todo, shm->total_syscalls_done);
 shm->exit_reason = EXIT_REACHED_COUNT;
 }
-
-if (shm->total_syscalls_done == syscalls_todo)
-printf(""[%d] Reached maximum syscall count %ld\n"",
-pid, shm->total_syscalls_done);
 }
 
 ret = mkcall(childno);
",106,25
remove redundant check.," static void choose_syscall_table(int childno)
 if (biarch == FALSE) {
 active_syscalls = shm->active_syscalls;
 nr_active_syscalls = shm->nr_active_syscalls;
-} else if (biarch == TRUE) {
+} else {
 
 /* First, check that we have syscalls enabled in either table. */
 if (validate_syscall_table_64() == FALSE) {
",106,24
"converted debugf from macro to a function

This patch replaces debugf macro with a function.

Signed-off-by: Ildar Muslukhov <ildarm@google.com>"," static int ignore_files(const char *path)
 }
 
 if (!strcmp(path, ignored_paths[i])) {
-//printf(""Skipping %s\n"", path);
+debugf(""Skipping %s\n"", path);
 return 1;
 }
 }
 static int ignore_files(const char *path)
 
 for (i = 0; ignored_patterns[i]; i++) {
 if (!strcmp(path + offset, ignored_patterns[i])) {
-//printf(""Skipping pattern %s\n"", path);
+debugf(""Skipping pattern %s\n"", path);
 return 1;
 }
 }
 
 /* special case to match tty* until I do globbing */
 if (!strncmp(path + offset, ""tty"", 3)) {
-//printf(""Skipping %s\n"", path);
+debugf(""Skipping %s\n"", path);
 return 1;
 }
 return 0;
",250,57
split disable_non_net_syscalls into uni/biarch variants," try32bit:
 &activate_syscall32, 32, syscalls_32bit[call32].entry->name);
 }
 }
+
+void disable_non_net_syscalls_biarch(void)
+{
+unsigned int i;
+
+for_each_64bit_syscall(i) {
+if (validate_specific_syscall_silent(syscalls_64bit, i) == FALSE)
+continue;
+
+if (syscalls_64bit[i].entry->flags & ACTIVE) {
+if (is_syscall_net_related(syscalls_64bit, i) == FALSE) {
+toggle_syscall_biarch_n(i, syscalls_64bit, FALSE, do_64_arch, FALSE,
+&activate_syscall64, 64, syscalls_64bit[i].entry->name);
+}
+}
+}
+
+for_each_32bit_syscall(i) {
+if (validate_specific_syscall_silent(syscalls_32bit, i) == FALSE)
+continue;
+
+if (syscalls_32bit[i].entry->flags & ACTIVE) {
+if (is_syscall_net_related(syscalls_32bit, i) == FALSE) {
+toggle_syscall_biarch_n(i, syscalls_32bit, FALSE, do_32_arch, FALSE,
+&activate_syscall32, 32, syscalls_32bit[i].entry->name);
+}
+}
+}
+}
",181,53
split setup_syscall_group into uniarch/biarch," void disable_non_net_syscalls_biarch(void)
 }
 }
 }
+
+int setup_syscall_group_biarch(unsigned int group)
+{
+unsigned int i;
+
+for_each_32bit_syscall(i) {
+if (syscalls_32bit[i].entry->group == group)
+activate_syscall32(i);
+}
+
+if (shm->nr_active_32bit_syscalls == 0)
+outputstd(""No 32-bit syscalls in group\n"");
+else
+outputstd(""Found %d 32-bit syscalls in group\n"", shm->nr_active_32bit_syscalls);
+
+/* now the 64 bit table*/
+for_each_64bit_syscall(i) {
+if (syscalls_64bit[i].entry->group == group)
+activate_syscall64(i);
+}
+
+if (shm->nr_active_64bit_syscalls == 0) {
+outputstd(""No 64-bit syscalls in group\n"");
+return FALSE;
+} else {
+outputstd(""Found %d 64-bit syscalls in group\n"", shm->nr_active_64bit_syscalls);
+}
+
+return TRUE;
+}
",204,58
split mark_all_syscalls_active into uniarch/biarch," int setup_syscall_group_biarch(unsigned int group)
 
 return TRUE;
 }
+
+void mark_all_syscalls_active_biarch(void)
+{
+unsigned int i;
+
+if (do_32_arch) {
+for_each_32bit_syscall(i) {
+syscalls_32bit[i].entry->flags |= ACTIVE;
+activate_syscall32(i);
+}
+}
+
+if (do_64_arch) {
+for_each_64bit_syscall(i) {
+syscalls_64bit[i].entry->flags |= ACTIVE;
+activate_syscall64(i);
+}
+}
+}
",220,61
split init_syscalls into uni/biarch," void mark_all_syscalls_active_biarch(void)
 }
 }
 }
+
+void init_syscalls_biarch(void)
+{
+unsigned int i;
+
+for_each_64bit_syscall(i) {
+if (syscalls_64bit[i].entry->flags & ACTIVE)
+if (syscalls_64bit[i].entry->init)
+syscalls_64bit[i].entry->init();
+}
+
+for_each_32bit_syscall(i) {
+if (syscalls_32bit[i].entry->flags & ACTIVE)
+if (syscalls_32bit[i].entry->init)
+syscalls_32bit[i].entry->init();
+}
+}
",234,66
split deactivate_disabled_syscalls into uni/biarch," void init_syscalls_biarch(void)
 syscalls_32bit[i].entry->init();
 }
 }
+
+void deactivate_disabled_syscalls_biarch(void)
+{
+unsigned int i;
+
+for_each_64bit_syscall(i) {
+if (syscalls_64bit[i].entry->flags & TO_BE_DEACTIVATED) {
+syscalls_64bit[i].entry->flags &= ~(ACTIVE|TO_BE_DEACTIVATED);
+deactivate_syscall64(i);
+output(0, ""Marked 64-bit syscall %s (%d) as deactivated.\n"",
+syscalls_64bit[i].entry->name, syscalls_64bit[i].entry->number);
+}
+}
+
+for_each_32bit_syscall(i) {
+if (syscalls_32bit[i].entry->flags & TO_BE_DEACTIVATED) {
+syscalls_32bit[i].entry->flags &= ~(ACTIVE|TO_BE_DEACTIVATED);
+deactivate_syscall32(i);
+output(0, ""Marked 32-bit syscall %s (%d) as deactivated.\n"",
+syscalls_32bit[i].entry->name, syscalls_32bit[i].entry->number);
+}
+}
+}
",254,69
add back a missing space that got inadvertantly dropped.," void dump_syscall_tables(void)
 outputstd(""syscalls: %d [64-bit]\n"", max_nr_64bit_syscalls);
 
 for_each_32bit_syscall(i) {
-outputstd(""entrypoint %d %s : [32-bit]"",
+outputstd(""entrypoint %d %s : [32-bit] "",
 syscalls_32bit[i].entry->number,
 syscalls_32bit[i].entry->name);
 show_state(syscalls_32bit[i].entry->flags & ACTIVE);
 void dump_syscall_tables(void)
 outputstd(""\n"");
 }
 for_each_64bit_syscall(i) {
-outputstd(""entrypoint %d %s : [64-bit]"",
+outputstd(""entrypoint %d %s : [64-bit] "",
 syscalls_64bit[i].entry->number,
 syscalls_64bit[i].entry->name);
 show_state(syscalls_64bit[i].entry->flags & ACTIVE);
",410,110
split dump_syscall_tables into uni/biarch," void deactivate_disabled_syscalls_biarch(void)
 }
 }
 }
+
+void dump_syscall_tables_biarch(void)
+{
+unsigned int i;
+
+outputstd(""syscalls: %d [32-bit]\n"", max_nr_32bit_syscalls);
+outputstd(""syscalls: %d [64-bit]\n"", max_nr_64bit_syscalls);
+
+for_each_32bit_syscall(i) {
+outputstd(""entrypoint %d %s : [32-bit] "",
+syscalls_32bit[i].entry->number,
+syscalls_32bit[i].entry->name);
+show_state(syscalls_32bit[i].entry->flags & ACTIVE);
+
+if (syscalls_32bit[i].entry->flags & AVOID_SYSCALL)
+outputstd("" AVOID"");
+outputstd(""\n"");
+}
+
+for_each_64bit_syscall(i) {
+outputstd(""entrypoint %d %s : [64-bit] "",
+syscalls_64bit[i].entry->number,
+syscalls_64bit[i].entry->name);
+show_state(syscalls_64bit[i].entry->flags & ACTIVE);
+if (syscalls_64bit[i].entry->flags & AVOID_SYSCALL)
+outputstd("" AVOID"");
+
+outputstd(""\n"");
+}
+}
",278,72
remove unnecessary variable," void select_syscall_tables(void)
 
 int setup_syscall_group(unsigned int group)
 {
-unsigned int ret;
-
 if (biarch == TRUE)
-ret = setup_syscall_group_biarch(group);
+return setup_syscall_group_biarch(group);
 else
-ret = setup_syscall_group_uniarch(group);
-
-return ret;
+return setup_syscall_group_uniarch(group);
 }
 
 const char * print_syscall_name(unsigned int callno, bool is32bit)
",378,107
split display_enabled_syscalls into uni/biarch," void dump_syscall_tables_biarch(void)
 outputstd(""\n"");
 }
 }
+
+void display_enabled_syscalls_biarch(void)
+{
+unsigned int i;
+
+for_each_64bit_syscall(i) {
+if (syscalls_64bit[i].entry->flags & ACTIVE)
+output(0, ""64-bit syscall %d:%s enabled.\n"", i, syscalls_64bit[i].entry->name);
+}
+
+for_each_32bit_syscall(i) {
+if (syscalls_32bit[i].entry->flags & ACTIVE)
+output(0, ""32-bit syscall %d:%s enabled.\n"", i, syscalls_32bit[i].entry->name);
+}
+}
",290,75
"split the table related stuff out of syscall.h

this means we can change tables headers without rebuilding every single syscall.","
 #include ""signals.h""
 #include ""pids.h""
 #include ""params.h""// for 'debug'
+#include ""tables.h""
 #include ""trinity.h""// ARRAY_SIZE
 
 static struct rlimit oldrlimit;
",137,24
remove excess whitespace," void check_user_specified_arch(const char *arg, char **arg_name, bool *only_64bi
 } else {
 *arg_name = (char*)arg;//castaway const.
 }
-
-
 }
 
 void clear_check_user_specified_arch(const char *arg, char **arg_name)
",367,104
terminate the page of rand format strings at a random part of the page.," void generate_random_page(char *page)
 default: break;
 }
 }
+page[rand() % page_size] = 0;
 return;
 
 default:
",92,25
Add missing format string," static void open_fds(const char *dirpath)
 ret = nftw(dirpath, file_tree_callback, 32, flags);
 if (ret != 0) {
 if (shm->exit_reason != EXIT_SIGINT)
-output(0, ""Something went wrong during nftw(%s). (%s)\n"",
+output(0, ""Something went wrong during nftw(%s). (%d:%s)\n"",
 dirpath, ret, strerror(errno));
 return;
 }
",250,57
Wait until children have been started before starting watchdog checking.," static void watchdog(void)
 bool watchdog_exit = FALSE;
 int ret = 0;
 
+while (shm->ready == FALSE) {
+sleep(1);
+if (shm->exit_reason != STILL_RUNNING)
+return;
+}
+
 output(0, ""Watchdog is alive. (pid:%d)\n"", watchdog_pid);
 
 prctl(PR_SET_NAME, (unsigned long) &watchdogname);
",284,60
"move mainpid into the shm

Watchdog needs to read it, and we forked off the watchdog before we
set mainpid. This meant we were doing kill(0, 0) in check_main_alive()"," void check_parent_pid(void)
 
 parent_check_time = 10;
 
-if (getppid() == mainpid)
+if (getppid() == shm->mainpid)
 return;
 
 pid = getpid();
 void check_parent_pid(void)
 //FIXME: Add locking so only one child does this output.
 output(0, BUGTXT ""CHILD (pid:%d) GOT REPARENTED! ""
 ""parent pid:%d. Watchdog pid:%d\n"",
-pid, mainpid, watchdog_pid);
+pid, shm->mainpid, watchdog_pid);
 output(0, BUGTXT ""Last syscalls:\n"");
 
 for (i = 0; i < MAX_NR_CHILDREN; i++) {
",137,24
"maintain a 'hiscore' of nr of syscalls a child did.

Not especially useful, but I was curious","
 
 pid_t watchdog_pid;
 
+static unsigned long hiscore = 0;
+
 static int check_shm_sanity(void)
 {
 unsigned int i;
 static void watchdog(void)
 goto main_dead;
 
 if (shm->regenerating == FALSE) {
+unsigned int i;
 
 reap_dead_kids();
 
 static void watchdog(void)
 if (shm->total_syscalls_done % 1000 == 0)
 synclogs();
 
+for_each_pidslot(i) {
+if (shm->child_syscall_count[i] > hiscore)
+hiscore = shm->child_syscall_count[i];
+}
+
 if (shm->total_syscalls_done > 1) {
 if (shm->total_syscalls_done - lastcount > 10000) {
-output(0, ""%ld iterations. [F:%ld S:%ld]\n"",
-shm->total_syscalls_done, shm->failures, shm->successes);
+output(0, ""%ld iterations. [F:%ld S:%ld HI:%ld]\n"",
+shm->total_syscalls_done,
+shm->failures, shm->successes,
+hiscore);
 lastcount = shm->total_syscalls_done;
 }
 }
+
 }
 
 /* Only check taint if it mask allows it */
",297,62
do perioidic setsockopt on opened sockets.,"
 #include ""log.h""
 #include ""params.h""
 #include ""maps.h""
+#include ""net.h""
+
+static void do_sso_sockets(void)
+{
+struct sockopt so = { 0, 0, 0, 0 };
+unsigned int i;
+int fd, ret;
+
+for (i = 0; i < nr_sockets; i++) {
+fd = shm->socket_fds[i];
+do_setsockopt(&so);
+ret = setsockopt(fd, so.level, so.optname, (void *)so.optval, so.optlen);
+if (ret == 0)
+output(1, ""Setsockopt(%lx %lx %lx %lx) on fd %d\n"",
+so.level, so.optname, so.optval, so.optlen, fd);
+//else
+//output(1, ""sso failed %s\n"", strerror(errno));
+}
+}
 
 static void regenerate(void)
 {
 static void regenerate(void)
 
 regenerate_fds();
 
+/* Do random setsockopts on all network sockets. */
+do_sso_sockets();
+
 destroy_maps();
 setup_maps();
 
",325,68
remove unneeded include,"
 #include ""pids.h""
 #include ""log.h""
 #include ""params.h""
-#include ""maps.h""
 
 int check_tainted(void)
 {
",292,62
do setsockopt on sockets at creation time.," static const char *cachefilename=""trinity.socketcache"";
 
 static int open_socket(unsigned int domain, unsigned int type, unsigned int protocol)
 {
-int fd;
+int fd, ret;
 struct sockaddr sa;
 socklen_t salen;
+struct sockopt so = { 0, 0, 0, 0 };
 
 fd = socket(domain, type, protocol);
 if (fd == -1)
 static int open_socket(unsigned int domain, unsigned int type, unsigned int prot
 
 nr_sockets++;
 
+/* Set some random socket options. */
+retry_sso:
+do_setsockopt(&so);
+ret = setsockopt(fd, so.level, so.optname, (void *)so.optval, so.optlen);
+if (ret == 0)
+output(1, ""Setsockopt(%lx %lx %lx %lx) on fd %d\n"",
+so.level, so.optname, so.optval, so.optlen, fd);
+else
+goto retry_sso;
+
 /* Sometimes, listen on created sockets. */
 if (rand_bool()) {
-__unused__ int ret;
-
 /* fake a sockaddr. */
 generate_sockaddr((unsigned long *) &sa, (unsigned long *) &salen, domain);
 
",197,36
truncate log files to 0 when starting a new child.," static void fork_children(void)
 
 while (shm->running_childs < shm->max_children) {
 int pid = 0;
+int fd;
 
 if (shm->spawn_no_more == TRUE)
 return;
 static void fork_children(void)
 exit(EXIT_FAILURE);
 }
 
+fd = fileno(shm->logfiles[pidslot]);
+if (ftruncate(fd, 0) == 0)
+lseek(fd, 0, SEEK_SET);
+
 (void)alarm(0);
 fflush(stdout);
 pid = fork();
",296,63
don't try truncating logfiles if logging is turned off.," static void fork_children(void)
 exit(EXIT_FAILURE);
 }
 
-fd = fileno(shm->logfiles[pidslot]);
-if (ftruncate(fd, 0) == 0)
-lseek(fd, 0, SEEK_SET);
+if (logging == TRUE) {
+fd = fileno(shm->logfiles[pidslot]);
+if (ftruncate(fd, 0) == 0)
+lseek(fd, 0, SEEK_SET);
+}
 
 (void)alarm(0);
 fflush(stdout);
",298,64
shorten the length dividing code.," unsigned long get_len(void)
 
 /* we might get lucky if something is counting ints/longs etc. */
 if (rand() % 100 < 25) {
-switch (rand() % 3) {
-case 0:i /= sizeof(int);
-break;
-case 1:i /= sizeof(long);
-break;
-case 2:i /= sizeof(long long);
-break;
-default:
-break;
-}
+int div = 1 << ((rand() % 4) + 1); /* 2,4,8 or 16 */
+i /= div;
 }
 
 return i;
",32,9
"make rand32 do the length dividing thing too

on the off-chance we're using it to unannotated length args"," unsigned int rand32(void)
 if (rand_bool())
 r |= (1L << 31);
 
+/* we might get lucky if something is counting ints/longs etc. */
+if (rand() % 100 < 25) {
+int div = 1 << ((rand() % 4) + 1);/* 2,4,8 or 16 */
+r /= div;
+}
+
 /* limit the size */
 switch (rand() % 4) {
 case 0: r &= 0xff;
",177,52
"multicast address block is a /24, not a /4"," in_addr_t random_ipv4_address(void)
 case 6:addr = 0xc0a80000;/* 192.168.0.0/16 */
 class = 16;
 break;
-case 7:addr = 0xe0000000;/* 224.0.0.0/4 (multicast)*/
-class = 4;
+case 7:addr = 0xe0000000;/* 224.0.0.0/24 (multicast)*/
+class = 24;
 break;
 case 8:addr = 0xffffffff;/* 255.255.255.255 */
 break;
",90,24
"add a hack to shut up clang.

It thinks page_size can be zero here, which is crap."," void generate_random_page(char *page)
 default: break;
 }
 }
+page_size = getpagesize();// Hack for clang 3.3 false positive.
 page[rand() % page_size] = 0;
 return;
 
",93,25
Generate random ethernet types for packet sockets.," void packet_rand_socket(struct socket_triplet *st)
 {
 st->protocol = htons(ETH_P_ALL);
 
-if (rand() % 8 == 0) {
-st->protocol = rand();
-if (rand_bool())
-st->protocol = (uint16_t) rand();
-}
+if (rand() % 8 == 0)// FIXME: 8 ? Why?
+st->protocol = get_random_ether_type();
 
 switch (rand() % 3) {
 case 0: st->type = SOCK_DGRAM;
",37,8
"net: bpf: fix off by one in seccomp_choose

We were off by one when iterating through states, so simply fix
that by choosing the correct max limit.

Signed-off-by: Daniel Borkmann <dborkman@redhat.com>"," static int seccomp_choose(const float probs[__STATE_GEN_MAX])
 float sum = .0f;
 float thr = (float) rand() / (float) RAND_MAX;
 
-for (i = 0; i < STATE_GEN_MAX; ++i) {
+for (i = 0; i < __STATE_GEN_MAX; ++i) {
 sum += probs[i];
 if (sum > thr)
 return i;
",259,49
ETH_P_802_3_MIN back compat.,"
 #include <linux/if_ether.h>
 #include ""net.h""
 #include ""trinity.h""
+#include ""compat.h""
 
 static const int ether_types[] = {
 
",31,1
"Define IP_MULTICAST_ALL if header files don't have it

Older systems have it defined in <linux/in.h> which conflicts with
<netinet/in.h>.

Signed-off-by: Mikko Rapeli <mikko.rapeli@iki.fi>","
 #include ""random.h""
 #include ""trinity.h""// ARRAY_SIZE
 
+/* workaround for <linux/in.h> vs. <netinet/in.h> */
+#ifndef IP_MULTICAST_ALL
+#define IP_MULTICAST_ALL 49
+#endif
+
 #define NR_SOL_IP_OPTS ARRAY_SIZE(ip_opts)
 static const unsigned int ip_opts[] = { IP_TOS, IP_TTL, IP_HDRINCL, IP_OPTIONS,
 IP_ROUTER_ALERT, IP_RECVOPTS, IP_RETOPTS, IP_PKTINFO,
",135,48
"net/irda_setsockopt.c: workaround for old irda headers

Signed-off-by: Mikko Rapeli <mikko.rapeli@iki.fi>","
 #include <stdlib.h>
 #include <sys/socket.h> /* old irda.h is broken */
+
+/* old irda.h does not include something which defines sa_family_t */
+#include <netinet/in.h>
+
 #include <linux/irda.h>
 #include ""net.h""
 #include ""maps.h""// page_rand
",19,1
"net/netlink.c: support older kernels and headers

Signed-off-by: Mikko Rapeli <mikko.rapeli@iki.fi>","
 #include ""net.h""
 #include ""random.h""
 
+/* Current highest netlink socket. Supports some older kernels. */
+#ifdef NETLINK_CRYPTO
+#define _NETLINK_MAX NETLINK_CRYPTO
+#else
+#ifdef NETLINK_RDMA
+#define _NETLINK_MAX NETLINK_RDMA
+#else
+#define _NETLINK_MAX NETLINK_ECRYPTFS
+#endif /* NETLINK_RDMA */
+#endif /* NETLINK_CRYPTO */
+
 void netlink_gen_sockaddr(unsigned long *addr, unsigned long *addrlen)
 {
 struct sockaddr_nl *nl;
 void netlink_rand_socket(struct socket_triplet *st)
 else
 st->type = SOCK_DGRAM;
 
-st->protocol = rand() % (NETLINK_CRYPTO + 1); // Current highest netlink socket.
+st->protocol = rand() % (_NETLINK_MAX + 1);
 }
",29,4
"net/netlink_setsockopt.c: workaround for old headers

Signed-off-by: Mikko Rapeli <mikko.rapeli@iki.fi>","
 #include <stdlib.h>
 #include <sys/socket.h> /* old netlink.h is broken */
+
+/* For sa_family_t needed by <linux/netlink.h> */
+#include <netinet/in.h>
+
 #include <linux/netlink.h>
 #include ""net.h""
 #include ""maps.h""// page_rand
",18,1
"Add missing NETLINK_RX_RING, NETLINK_TX_RING definitions.","
 #define NR_SOL_NETLINK_OPTS ARRAY_SIZE(netlink_opts)
 static const unsigned int netlink_opts[] = {
 NETLINK_ADD_MEMBERSHIP, NETLINK_DROP_MEMBERSHIP, NETLINK_PKTINFO, NETLINK_BROADCAST_ERROR,
-NETLINK_NO_ENOBUFS };
+NETLINK_NO_ENOBUFS, NETLINK_RX_RING, NETLINK_TX_RING };
 
 void netlink_setsockopt(struct sockopt *so)
 {
",18,1
use a trinity child pid for the netlink pid,"
 #include ""compat.h""
 #include ""net.h""
 #include ""random.h""
+#include ""sanitise.h""
 
 /* Current highest netlink socket. Supports some older kernels. */
 #ifdef NETLINK_CRYPTO
 void netlink_gen_sockaddr(unsigned long *addr, unsigned long *addrlen)
 return;
 
 nl->nl_family = PF_NETLINK;
-nl->nl_pid = rand();
+nl->nl_pid = get_pid();
 nl->nl_groups = rand();
 *addr = (unsigned long) nl;
 *addrlen = sizeof(struct sockaddr_nl);
",30,4
use rand32 for netlink groups.," void netlink_gen_sockaddr(unsigned long *addr, unsigned long *addrlen)
 
 nl->nl_family = PF_NETLINK;
 nl->nl_pid = get_pid();
-nl->nl_groups = rand();
+nl->nl_groups = rand32();
 *addr = (unsigned long) nl;
 *addrlen = sizeof(struct sockaddr_nl);
 }
",30,4
"jump back to child after getting SIGALRM

This should work better now, so we should be able to jump directly back into
the same child and just do a different syscall."," static void sighandler(int sig)
 shm->fd_lifetime = 0;
 
 /* TODO: Somehow mark the fd in the parent not to be used again too. */
-
-/* Nothing we can do, just bail. */
-_exit(EXIT_SUCCESS);
 }
 
 /* Re-arm the alarm. */
",65,10
flush previous syscall output when we get SIGALRM," int child_random_syscalls(int childno)
 
 ret = sigsetjmp(ret_jump, 1);
 if (ret != 0) {
+output(0, ""<timed out>\n"");/* Flush out the previous syscall output. */
 if (sigwas != SIGALRM)
 output(1, ""[%d] Back from signal handler! (sig was %s)\n"", getpid(), strsignal(sigwas));
 
",108,24
"fix accounting so it counts syscalls before we do the syscall.

Otherwise when we jump back after sigalrm, we don't increment the counters."," static unsigned long do_syscall(int childno, int *errno_saved)
 a5 = shm->a5[childno];
 a6 = shm->a6[childno];
 
+pidslot = find_pid_slot(getpid());
+if (pidslot != PIDSLOT_NOT_FOUND) {
+shm->total_syscalls_done++;
+shm->child_syscall_count[pidslot]++;
+(void)gettimeofday(&shm->tv[pidslot], NULL);
+}
+
 if (syscalls[nr].entry->flags & NEED_ALARM)
 (void)alarm(1);
 
 static unsigned long do_syscall(int childno, int *errno_saved)
 if (syscalls[nr].entry->flags & NEED_ALARM)
 (void)alarm(0);
 
-pidslot = find_pid_slot(getpid());
-if (pidslot != PIDSLOT_NOT_FOUND) {
-shm->total_syscalls_done++;
-shm->child_syscall_count[pidslot]++;
-(void)gettimeofday(&shm->tv[pidslot], NULL);
-}
-
 return ret;
 }
 
",176,32
hush some noise if we're running with -q," int child_random_syscalls(int childno)
 
 ret = sigsetjmp(ret_jump, 1);
 if (ret != 0) {
-output(0, ""<timed out>\n"");/* Flush out the previous syscall output. */
+output(1, ""<timed out>\n"");/* Flush out the previous syscall output. */
 if (sigwas != SIGALRM)
 output(1, ""[%d] Back from signal handler! (sig was %s)\n"", getpid(), strsignal(sigwas));
 
",108,24
"set syscalls_todo to N, not N+1

I really do not see any use case to increment users choice.

Signed-off-by: Toralf Frster <toralf.foerster@gmx.de>"," void parse_args(int argc, char *argv[])
 
 /* Set number of syscalls to do */
 case 'N':
-syscalls_todo = strtoll(optarg, NULL, 10) + 1;
+syscalls_todo = strtoll(optarg, NULL, 10);
 break;
 
 /* Pause after each syscall */
",259,55
"params: Add missing \n into usage output

Signed-off-by: Cyrill Gorcunov <gorcunov@gmail.com>"," bool kernel_taint_param_occured = FALSE;
 static void usage(void)
 {
 outputerr(""%s\n"", progname);
-outputerr("" --arch, -a: selects syscalls for the specified architecture (32 or 64). Both by default."");
+outputerr("" --arch, -a: selects syscalls for the specified architecture (32 or 64). Both by default.\n"");
 outputerr("" --children,-C: specify number of child processes\n"");
 outputerr("" --exclude,-x: don't call a specific syscall\n"");
 outputerr("" --group,-g: only run syscalls from a certain group (So far just 'vm').\n"");
",259,55
"net: protocols -- Use ARRAY_SIZE helper

We're looking up over @protocols array so use appropriate
helper here instead of TRINITY_PF_MAX constant.

Signed-off-by: Cyrill Gorcunov <gorcunov@openvz.org>"," const char * get_proto_name(unsigned int proto)
 {
 unsigned int i;
 
-for (i = 0; i < TRINITY_PF_MAX; i++)
+for (i = 0; i < ARRAY_SIZE(protocols); i++)
 if (protocols[i].proto == proto)
 return protocols[i].name;
 return NULL;
 void find_specific_proto(const char *protoarg)
 }
 } else {
 /* we were passed a numeric arg. */
-for (i = 0; i < TRINITY_PF_MAX; i++) {
+for (i = 0; i < ARRAY_SIZE(protocols); i++) {
 if (specific_proto == protocols[i].proto)
 break;
 }
 }
 
-if (i > TRINITY_PF_MAX) {
+if (i > ARRAY_SIZE(protocols)) {
 outputerr(""Protocol unknown. Pass a numeric value [0-%d] or one of "", TRINITY_PF_MAX);
 for (i = 0; i < ARRAY_SIZE(protocols); i++)
 outputerr(""%s "", protocols[i].name);
",90,11
"net: protocols -- Move protocol function declarations to protocols.h

This allows to isolate functions and include the header only where needed.

Signed-off-by: Cyrill Gorcunov <gorcunov@openvz.org>","
 
 #include ""trinity.h""
 #include ""constants.h""
+#include ""protocols.h""
 #include ""net.h""
 #include ""log.h""
 
",91,13
"params: Add --no_proto|-E option

This option will track the socket families which user
prefer to exclude from testing, for example PF_PACKET
sockets and such.

Note I've had to include net.h in two files only because
TRINITY_PF_MAX is declared there. Maybe it worth to move
this constant to constants.h.

Signed-off-by: Cyrill Gorcunov <gorcunov@openvz.org>","
 #include ""trinity.h""
 #include ""constants.h""
 #include ""protocols.h""
+#include ""params.h""
 #include ""net.h""
 #include ""log.h""
 
 void find_specific_proto(const char *protoarg)
 
 exit(EXIT_FAILURE);
 }
+
+void parse_exclude_protos(const char *arg)
+{
+char *_arg = strdup(arg);
+const struct protocol *p;
+char *tok;
+
+if (!_arg) {
+outputerr(""No free memory\n"");
+exit(EXIT_FAILURE);
+}
+
+for (tok = strtok(_arg, "",""); tok; tok = strtok(NULL, "","")) {
+p = lookup_proto(tok, (unsigned int)atoi(tok));
+if (p) {
+BUG_ON(p->proto >= ARRAY_SIZE(no_protos));
+no_protos[p->proto] = TRUE;
+} else
+goto err;
+}
+
+free(_arg);
+return;
+
+err:
+free(_arg);
+outputerr(""Protocol unknown in argument %s\n"", arg);
+exit(EXIT_FAILURE);
+}
",116,17
"net: sockets -- Don't generate sockets with disabled protocol families

Signed-off-by: Cyrill Gorcunov <gorcunov@openvz.org>"," void find_specific_proto(const char *protoarg)
 exit(EXIT_FAILURE);
 }
 
+unsigned int find_next_enabled_proto(unsigned int from)
+{
+unsigned int i;
+
+from %= ARRAY_SIZE(no_protos);
+
+for (i = from; i < ARRAY_SIZE(no_protos); i++) {
+if (no_protos[i] == FALSE)
+return no_protos[i];
+}
+
+for (i = 0; i < from; i++) {
+if (no_protos[i] == FALSE)
+return no_protos[i];
+}
+
+return -1u;
+}
+
 void parse_exclude_protos(const char *arg)
 {
 char *_arg = strdup(arg);
",130,22
restore the unconditional <timed out> message.," static unsigned int handle_sigreturn(int childno)
 static unsigned int count = 0;
 static unsigned int last = -1;
 
-if (count > 0)
-output(1, ""<timed out>\n"");/* Flush out the previous syscall output. */
+output(1, ""<timed out>\n"");/* Flush out the previous syscall output. */
 
 /* Check if we're making any progress at all. */
 if (shm->child_syscall_count[childno] == last) {
",126,28
"save/restore r10 around 32bit x86-64 syscalls.

This fixes the problem where we segfault as soon as we hit __syscall_return(res)
res was being held in r10, and went out of scope once we hit the syscall,
so we were scribbling through random ptrs ->segv.

We should probably be saving more registers here to be completely safe,
but for now this seems to do the trick."," long syscall32(int num_args, unsigned int call,
 #elif defined(__x86_64__)
 __asm__ volatile (
 ""pushq %%rbp\n\t""
+""pushq %%r10\n\t""
 ""movq %7, %%rbp\n\t""
 ""int $0x80\n\t""
+""popq %%r10\n\t""
 ""popq %%rbp\n\t""
 : ""=a"" (__res)
 : ""0"" (call),""b"" ((long)(a1)),""c"" ((long)(a2)),""d"" ((long)(a3)), ""S"" ((long)(a4)),""D"" ((long)(a5)), ""g"" ((long)(a6))
",178,32
"remove i386 int80 code.

This is unnecessary. x86-32 uses syscall(), not syscall32()."," long syscall32(unsigned int call,
 
 //FIXME: Move the implementations out to arch header files.
 
-#if defined( __i386__)
-__asm__ volatile (
-""pushl %%ebp\n\t""
-""movl %7, %%ebp\n\t""
-""int $0x80\n\t""
-""popl %%ebp\n\t""
-: ""=a"" (__res)
-: ""0"" (call),""b"" ((long)(a1)),""c"" ((long)(a2)),""d"" ((long)(a3)), ""S"" ((long)(a4)),""D"" ((long)(a5)), ""g"" ((long)(a6))
-: ""%ebp"" /* mark EBP reg as dirty */
-);
-__syscall_return(long, __res);
-
-#elif defined(__x86_64__)
+#if defined(__x86_64__)
 __asm__ volatile (
 ""pushq %%rbp\n\t""
 ""pushq %%r10\n\t""
",149,30
"reenable prctl, but just for seccomp for now."," void sanitise_prctl(int childno)
 {
 int option = prctl_opts[rand() % NR_PRCTL_OPTS];
 
+// For now, just do SECCOMP, the other options need some attention.
+option = PR_SET_SECCOMP;
+
 /* Also allow crap by small chance */
 if (rand() % 100 != 0)
 shm->a1[childno] = option;
 void sanitise_prctl(int childno)
 switch (option) {
 case PR_SET_SECCOMP:
 #ifdef USE_SECCOMP
-if (rand() % 3 == SECCOMP_MODE_FILTER) {
+//if (rand() % 3 == SECCOMP_MODE_FILTER) {
 gen_seccomp_bpf((unsigned long *) page_rand, NULL);
 
 shm->a2[childno] = SECCOMP_MODE_FILTER;
 shm->a3[childno] = (unsigned long) page_rand;
-}
+//}
 #endif
 break;
 default:
 void sanitise_prctl(int childno)
 
 struct syscall syscall_prctl = {
 .name = ""prctl"",
-.flags = AVOID_SYSCALL,
 .num_args = 5,
 .arg1name = ""option"",
 .arg2name = ""arg2"",
",45,4
"sockets code shouldn't really know about things like victim path

Move that to the caller."," regen:
 
 void setup_fds(void)
 {
-open_sockets();
+/* If we have victim files, don't worry about sockets. */
+if (victim_path == NULL)
+open_sockets();
 
 open_pipes();
 
",171,38
replace shm->socket_fds with a struct to map back to family/proto/type," retry:
 fd = rand_pipe_fd();
 return fd;
 }
-fd = shm->socket_fds[rand() % nr_sockets];
+fd = shm->sockets[rand() % nr_sockets].fd;
 break;
 
 case 2:
",171,38
store the family/type/proto on socket creation.," static int open_socket(unsigned int domain, unsigned int type, unsigned int prot
 return fd;
 
 shm->sockets[nr_sockets].fd = fd;
+shm->sockets[nr_sockets].triplet.family = domain;
+shm->sockets[nr_sockets].triplet.type = type;
+shm->sockets[nr_sockets].triplet.protocol = protocol;
 
 output(2, ""fd[%i] = domain:%i (%s) type:0x%x protocol:%i\n"",
 fd, domain, get_proto_name(domain), type, protocol);
",211,42
"make socket shutdown at exit use the code in sockets.c

Also improve the sockets.c variant to do the SO_LINGER tweaking."," done:
 }
 
 
-static void close_sockets(void)
+void close_sockets(void)
 {
 unsigned int i;
 int fd;
+int r = 0;
+struct linger ling = { .l_onoff = FALSE, };
 
 for (i = 0; i < nr_sockets; i++) {
+/* Grab an fd, and nuke it before someone else uses it. */
 fd = shm->sockets[i].fd;
 shm->sockets[i].fd = 0;
-if (close(fd) != 0) {
+
+/* disable linger */
+ling.l_onoff = FALSE;/* linger active */
+r = setsockopt(fd, SOL_SOCKET, SO_LINGER, &ling, sizeof(struct linger));
+if (r)
+perror(""setsockopt"");
+
+r = shutdown(fd, SHUT_RDWR);
+if (r)
+perror(""shutdown"");
+
+if (close(fd) != 0)
 output(1, ""failed to close socket.(%s)\n"", strerror(errno));
-}
 }
 
 nr_sockets = 0;
 regenerate:
 unlock_cachefile(cachefile);
 close(cachefile);
 }
+
",219,44
informational use of socket triplet on closure failure," void close_sockets(void)
 perror(""shutdown"");
 
 if (close(fd) != 0)
-output(1, ""failed to close socket.(%s)\n"", strerror(errno));
+output(1, ""failed to close socket [%d:%d:%d].(%s)\n"",
+shm->sockets[i].triplet.family,
+shm->sockets[i].triplet.type,
+shm->sockets[i].triplet.protocol,
+strerror(errno));
 }
 
 nr_sockets = 0;
",223,44
silence -Wshadow warning," unsigned long get_len(void)
 
 /* we might get lucky if something is counting ints/longs etc. */
 if (rand() % 100 < 25) {
-int div = 1 << ((rand() % 4) + 1); /* 2,4,8 or 16 */
-i /= div;
+int _div = 1 << ((rand() % 4) + 1); /* 2,4,8 or 16 */
+i /= _div;
 }
 
 return i;
",32,9
Add SO_MAX_PACING_RATE to setsockopt options," static const unsigned int socket_opts[] = { SO_DEBUG, SO_REUSEADDR, SO_TYPE, SO_
 SO_PASSSEC, SO_TIMESTAMPNS, SO_MARK, SO_TIMESTAMPING,
 SO_PROTOCOL, SO_DOMAIN, SO_RXQ_OVFL, SO_WIFI_STATUS,
 SO_PEEK_OFF, SO_NOFCS, SO_LOCK_FILTER, SO_SELECT_ERR_QUEUE,
-SO_BUSY_POLL };
+SO_BUSY_POLL, SO_MAX_PACING_RATE };
 
 void socket_setsockopt(struct sockopt *so)
 {
",40,5
"Fix unused variable build errors.

This patch fixes these build errors on CentOS 6.

 CC	net/caif_setsockopt.o
cc1: warnings being treated as errors
net/caif_setsockopt.c: In function caif_setsockopt:
net/caif_setsockopt.c:20: error: unused variable val

 CC	net/rds_setsockopt.o
cc1: warnings being treated as errors
net/rds_setsockopt.c: In function rds_setsockopt:
net/rds_setsockopt.c:23: error: unused variable val

Signed-off-by: Vinson Lee <vlee@twitter.com>"," static const unsigned int caif_opts[] = { CAIFSO_LINK_SELECT, CAIFSO_REQ_PARAM }
 
 void caif_setsockopt(struct sockopt *so)
 {
+#ifdef USE_CAIF
 unsigned char val;
+#endif
 
 so->level = SOL_CAIF;
 
",14,3
add ETH_P_PRP to ether types," static const int ether_types[] = {
 ETH_P_ATMMPOA, ETH_P_LINK_CTL, ETH_P_ATMFATE,
 
 ETH_P_PAE, ETH_P_AOE, ETH_P_8021AD, ETH_P_802_EX1,
-ETH_P_TIPC, ETH_P_8021AH, ETH_P_MVRP, ETH_P_1588,
+ETH_P_TIPC, ETH_P_8021AH, ETH_P_MVRP, ETH_P_1588, ETH_P_PRP,
 ETH_P_FCOE, ETH_P_TDLS, ETH_P_FIP, ETH_P_QINQ1,
 ETH_P_QINQ2, ETH_P_QINQ3, ETH_P_EDSA, ETH_P_AF_IUCV,
 
",31,1
Add missing command line option to help.," static void usage(void)
 outputerr(""%s\n"", progname);
 outputerr("" --arch, -a: selects syscalls for the specified architecture (32 or 64). Both by default.\n"");
 outputerr("" --children,-C: specify number of child processes\n"");
+outputerr("" --debug,-D: enable debug\n"");
 outputerr("" --exclude,-x: don't call a specific syscall\n"");
 outputerr("" --group,-g: only run syscalls from a certain group (So far just 'vm').\n"");
 outputerr("" --ioctls,-I: list all ioctls.\n"");
",268,56
"perf_event_open more likely tracepoint values

Tracepoint ids tend to be relatively small (less than 1024 or so).
This change makes it more likely to hit valid ones.

Once the fix to avoid the troublesome 0x18 (irq_work_exit)
tracepoint gets into the kernel maybe we can start stressing
things with trinity again.

Signed-off-by: Vince Weaver <vincent.weaver@maine.edu>"," static long long random_event_config(__u32 *event_type,
 break;
 case PERF_TYPE_TRACEPOINT:
 /* Actual values to use can be found under */
-/* debugfs tracing/events// *//*/id */
-/* usually a small < 1024 number */
-config = rand64();
+/* debugfs tracing/events/?*?/?*?/id */
+/* usually a small < 4096 number */
+switch(rand()%2) {
+case 0:
+/* Try a value < 4096 */
+config = rand()&0xfff;
+break;
+case 1:
+config = rand64();
+break;
+default:
+config = rand64();
+break;
+}
 break;
 case PERF_TYPE_HW_CACHE:
 config = random_cache_config();
",1008,247
"ugly hack for 32bit warnings.

This needs to just go away entirely on 32bit builds. Will do later.","
 * It does 32 bit syscalls on 64 bit kernel.
 * 32-on-32 will just use syscall() directly from do_syscall() because shm->do32bit is biarch only.
 */
-long syscall32(unsigned int call,
-unsigned long a1, unsigned long a2, unsigned long a3,
-unsigned long a4, unsigned long a5, unsigned long a6)
+long syscall32(__unused__ unsigned int call,
+__unused__ unsigned long a1, __unused__ unsigned long a2, __unused__ unsigned long a3,
+__unused__ unsigned long a4, __unused__ unsigned long a5, __unused__ unsigned long a6)
 {
 long __res = 0;
 
",149,30
workaround a lockup with bluetooth sockets," void close_sockets(void)
 struct linger ling = { .l_onoff = FALSE, };
 
 for (i = 0; i < nr_sockets; i++) {
+
+//FIXME: This is a workaround for a weird bug where we hang forevre
+// waiting for bluetooth sockets when we setsockopt.
+// Hopefully at some point we can remove this when someone figures out what's going on.
+if (shm->sockets[i].triplet.family == PF_BLUETOOTH)
+continue;
+
 /* Grab an fd, and nuke it before someone else uses it. */
 fd = shm->sockets[i].fd;
 shm->sockets[i].fd = 0;
",225,45
remove double assign of variable.," void close_sockets(void)
 shm->sockets[i].fd = 0;
 
 /* disable linger */
-ling.l_onoff = FALSE;/* linger active */
 r = setsockopt(fd, SOL_SOCKET, SO_LINGER, &ling, sizeof(struct linger));
 if (r)
 perror(""setsockopt"");
",224,45
"don't fill out args that don't exist.

Not sure how I never noticed this before."," static unsigned long handle_arg_mode_t(void)
 }
 
 
-static unsigned long fill_arg(int childno, int call, int argnum)
+static unsigned long fill_arg(int childno, int call, unsigned int argnum)
 {
 enum argtype argtype = 0;
 
+if (argnum > syscalls[call].entry->num_args)
+return 0;
+
 switch (argnum) {
 case 1:argtype = syscalls[call].entry->arg1type;
 break;
",335,118
reduce ifdeffery in rds,"
 #include <stdlib.h>
 #include ""net.h""
 #include ""config.h""
+
 #ifdef USE_RDS
 #include <linux/rds.h>
-#endif
 
 #include ""compat.h""
 #include ""trinity.h""// ARRAY_SIZE
 
 #define SOL_RDS 276
 
-#ifdef USE_RDS
 #define NR_SOL_RDS_OPTS ARRAY_SIZE(rds_opts)
 static const unsigned int rds_opts[] = {
 RDS_CANCEL_SENT_TO, RDS_GET_MR, RDS_FREE_MR,
 4, /* deprecated RDS_BARRIER 4 */
 RDS_RECVERR, RDS_CONG_MONITOR, RDS_GET_MR_FOR_DEST };
-#endif
 
 void rds_setsockopt(struct sockopt *so)
 {
-#ifdef USE_RDS
 unsigned char val;
-#endif
 
 so->level = SOL_RDS;
-#ifdef USE_RDS
+
 val = rand() % NR_SOL_RDS_OPTS;
 so->optname = rds_opts[val];
-#endif
 }
+
+#else
+/* stub if we are built on something without RDS headers */
+void rds_setsockopt(struct sockopt *so)
+{
+so->level = SOL_RDS;
+}
+#endif/* USE_RDS */
",21,2
reduce ifdeffery in caif,"
 #include ""compat.h""
 #include ""trinity.h""// ARRAY_SIZE
 
-#ifdef USE_CAIF
-#include <linux/caif/caif_socket.h>
-#endif
-
 #define SOL_CAIF 278
 
 #ifdef USE_CAIF
+#include <linux/caif/caif_socket.h>
+
 #define NR_SOL_CAIF_OPTS ARRAY_SIZE(caif_opts)
 static const unsigned int caif_opts[] = { CAIFSO_LINK_SELECT, CAIFSO_REQ_PARAM };
-#endif
 
 void caif_setsockopt(struct sockopt *so)
 {
-#ifdef USE_CAIF
 unsigned char val;
-#endif
 
 so->level = SOL_CAIF;
 
-#ifdef USE_CAIF
 val = rand() % NR_SOL_CAIF_OPTS;
 so->optname = caif_opts[val];
-#endif
 }
+#else
+/* stub if we are built on something without RDS headers */
+void caif_setsockopt(struct sockopt *so)
+{
+so->level = SOL_CAIF;
+}
+#endif
",18,2
clear out pidslots after we kill all children," static void check_children(void)
 
 static void kill_all_kids(void)
 {
+unsigned int i;
+
 shm->spawn_no_more = TRUE;
 
 /* Wait for all the children to exit. */
 while (shm->running_childs > 0) {
-unsigned int i;
 unsigned int alive;
 
 /* Make sure there's no dead kids lying around.
 static void kill_all_kids(void)
 return;
 }
 }
+
+/* Just to be sure, clear out the pid slots. */
+for_each_pidslot(i) {
+shm->pids[i] = EMPTY_PIDSLOT;
+}
 }
 
 static void watchdog(void)
",300,62
"net/rds_setsockopt.c: Always define SOL_RDS.

This patch fixes this build error on CentOS 6.

 CC	net/rds_setsockopt.o
net/rds_setsockopt.c: In function rds_setsockopt:
net/rds_setsockopt.c:33: error: SOL_RDS undeclared (first use in this function)
net/rds_setsockopt.c:33: error: (Each undeclared identifier is reported only once
net/rds_setsockopt.c:33: error: for each function it appears in.)

Signed-off-by: Vinson Lee <vlee@twitter.com>","
 #include ""net.h""
 #include ""config.h""
 
+#define SOL_RDS 276
+
 #ifdef USE_RDS
 #include <linux/rds.h>
 
 #include ""compat.h""
 #include ""trinity.h""// ARRAY_SIZE
 
-#define SOL_RDS 276
-
 #define NR_SOL_RDS_OPTS ARRAY_SIZE(rds_opts)
 static const unsigned int rds_opts[] = {
 RDS_CANCEL_SENT_TO, RDS_GET_MR, RDS_FREE_MR,
",21,2
save/restore r11 in 32bit syscalls.," long syscall32(unsigned int call,
 __asm__ volatile (
 ""pushq %%rbp\n\t""
 ""pushq %%r10\n\t""
+""pushq %%r11\n\t""
 ""movq %7, %%rbp\n\t""
 ""int $0x80\n\t""
+""popq %%r11\n\t""
 ""popq %%r10\n\t""
 ""popq %%rbp\n\t""
 : ""=a"" (__res)
",151,29
work around bluetooth linger bug," static void do_sso_sockets(void)
 int fd, ret;
 
 for (i = 0; i < nr_sockets; i++) {
+/* skip over bluetooth due to weird linger bug */
+if (shm->sockets[i].triplet.family == PF_BLUETOOTH)
+continue;
+
 fd = shm->sockets[i].fd;
 do_setsockopt(&so);
 ret = setsockopt(fd, so.level, so.optname, (void *)so.optval, so.optlen);
 if (ret == 0)
-output(1, ""Setsockopt(%lx %lx %lx %lx) on fd %d\n"",
-so.level, so.optname, so.optval, so.optlen, fd);
+output(1, ""Setsockopt(%lx %lx %lx %lx) on fd %d [%d:%d:%d]\n"",
+so.level, so.optname, so.optval, so.optlen, fd,
+shm->sockets[i].triplet.family,
+shm->sockets[i].triplet.type,
+shm->sockets[i].triplet.protocol);
 //else
 //output(1, ""sso failed %s\n"", strerror(errno));
 }
",45,7
fix bad cut-n-paste causing inverted state when using -r on uniarch," retry:
 if (syscalls[call].entry->flags & TO_BE_DEACTIVATED)
 goto retry;
 
-toggle_syscall_n(call, FALSE, syscalls[call].entry->name, syscalls[call].entry->name);
+toggle_syscall_n(call, TRUE, syscalls[call].entry->name, syscalls[call].entry->name);
 }
 
 void disable_non_net_syscalls_uniarch(void)
",131,28
centralise the setsockopt code in one place instead of duplicating workarounds.," static void do_sso_sockets(void)
 {
 struct sockopt so = { 0, 0, 0, 0 };
 unsigned int i;
-int fd, ret;
+int fd;
 
 for (i = 0; i < nr_sockets; i++) {
-/* skip over bluetooth due to weird linger bug */
-if (shm->sockets[i].triplet.family == PF_BLUETOOTH)
-continue;
-
 fd = shm->sockets[i].fd;
-do_setsockopt(&so);
-ret = setsockopt(fd, so.level, so.optname, (void *)so.optval, so.optlen);
-if (ret == 0)
-output(1, ""Setsockopt(%lx %lx %lx %lx) on fd %d [%d:%d:%d]\n"",
-so.level, so.optname, so.optval, so.optlen, fd,
-shm->sockets[i].triplet.family,
-shm->sockets[i].triplet.type,
-shm->sockets[i].triplet.protocol);
-//else
-//output(1, ""sso failed %s\n"", strerror(errno));
+sso_socket(&shm->sockets[i].triplet, &so, fd);
 }
 }
 
",36,5
fix build error on 32bit," void * zmalloc(size_t size)
 
 p = malloc(size);
 if (p == NULL) {
-printf(""malloc(%ld) failure.\n"", size);
+printf(""malloc(%zu) failure.\n"", size);
 exit(EXIT_FAILURE);
 }
 
",15,2
"Fixes bug with incorrect casting of on stackvariable to a pointer.

This patch fixes a bug in open_socket function with sa variable of type
struct sockaddr. In particular, this variable is alloctaed on stack, and
then address to it is passed to specific functions that allocate memory
and overwrite the content of sa with the address of the newly allocated
object, but not with the values that were assigned to the object. Thus, 4
or 8 first bytes of the sa struct are always initialized with an
address of newly allocated object.

Signed-off-by: Ildar Muslukhov <ildarm@google.com>"," static unsigned long handle_arg_sockaddr(int childno, unsigned long call, unsign
 {
 unsigned long sockaddr = 0, sockaddrlen = 0;
 
-generate_sockaddr(&sockaddr, &sockaddrlen, PF_NOHINT);
+generate_sockaddr((unsigned long **)&sockaddr, &sockaddrlen, PF_NOHINT);
 
 switch (argnum) {
 case 1:if (syscalls[call].entry->arg2type == ARG_SOCKADDRLEN)
",335,118
fix up a missed pointer conversion after Ildar's last change.," void pppox_gen_sockaddr(unsigned long **addr, unsigned long *addrlen)
 pppol2tpv3in6->pppol2tp.addr.sin6_addr.s6_addr32[2] = 0;
 pppol2tpv3in6->pppol2tp.addr.sin6_addr.s6_addr32[3] = random_ipv4_address();
 pppol2tpv3in6->pppol2tp.addr.sin6_scope_id = rand();
-*addr = (unsigned long) pppol2tpv3in6;
+*addr = (unsigned long *) pppol2tpv3in6;
 *addrlen = sizeof(struct sockaddr_pppol2tpv3in6);
 }
 #endif
",133,20
missing address-of op.," option = PR_SET_SECCOMP;
 //if (rand() % 3 == SECCOMP_MODE_FILTER) {
 // FIXME: This leaks memory, but needs to be cleared
 // after the syscall is done.
-gen_seccomp_bpf((unsigned long **) saddr, NULL);
+gen_seccomp_bpf((unsigned long **) &saddr, NULL);
 shm->a2[childno] = SECCOMP_MODE_FILTER;
 shm->a3[childno] = (unsigned long) saddr;
 //}
",47,4
"change ->post to have the childno as the parameter, instead of the retval.

Stick the retval in the shm.

This will allow ->post ops to figure out what our params were."," long mkcall(int childno)
 call += SYSCALL_OFFSET;
 
 ret = do_syscall(childno, &errno_saved);
+shm->retval[childno] = ret;
 
 if (IS_ERR(ret))
 shm->failures++;
 long mkcall(int childno)
 skip_enosys:
 
 if (syscalls[call].entry->post)
- syscalls[call].entry->post(ret);
+ syscalls[call].entry->post(childno);
 
 /* store info for debugging. */
 shm->previous_syscallno[childno] = shm->syscallno[childno];
",152,29
"[watchdog] if we're exiting don't bother checking main.

Fairly big messy diff, but it cleans up some occasional spew at process exit time."," void do_main_loop(void)
 
 /* wait for main loop process to exit. */
 pid = waitpid(pid, &childstatus, 0);
+shm->mainpid = 0;
 }
",299,64
move the anon mmap code out to its own subroutine.,"
 // need this to actually get MAP_UNINITIALIZED defined
 #define CONFIG_MMAP_ALLOW_UNINITIALIZED
 
+static void do_anon(int childno)
+{
+/* no fd if anonymous mapping. */
+shm->a5[childno] = -1;
+shm->a6[childno] = 0;
+}
+
 void sanitise_mmap(int childno)
 {
 unsigned int i;
 void sanitise_mmap(int childno)
 for (i = 0; i < numflags; i++)
 shm->a4[childno] |= flagvals[rand() % NUM_FLAGS];
 
-/* no fd if anonymous mapping. */
-if (shm->a4[childno] & MAP_ANONYMOUS)
-shm->a5[childno] = -1;
-
-/* page align non-anonymous mappings. */
-if (shm->a4[childno] & MAP_ANONYMOUS)
+if (shm->a4[childno] & MAP_ANONYMOUS) {
+do_anon(childno);
+} else {
+/* page align non-anonymous mappings. */
 shm->a6[childno] &= PAGE_MASK;
-else
-shm->a6[childno] = 0;
-
+}
 }
 
 struct syscall syscall_mmap = {
",61,6
add a ->post for mmap,"
 #include ""shm.h""
 #include ""arch.h""
 #include ""compat.h""
+#include ""random.h""
 
 #ifdef __x86_64__
 #define NUM_FLAGS 13
 void sanitise_mmap(int childno)
 }
 }
 
+static void post_mmap(int childno)
+{
+char *p;
+
+p = (void *) shm->retval[childno];
+if (p == NULL)
+return;
+
+/* Sometimes dirty the mapping. */
+if (rand_bool())
+p[rand() % page_size] = 1;
+
+//TODO: Add this to a list for use by subsequent syscalls.
+}
+
 struct syscall syscall_mmap = {
 .name = ""mmap"",
 .num_args = 6,
 struct syscall syscall_mmap = {
 .arg6type = ARG_LEN,
 .group = GROUP_VM,
 .flags = NEED_ALARM,
+.post = post_mmap,
 };
",72,9
add F_GETOWNER_UIDS fcntl flag," static void sanitise_fcntl(int childno)
 case F_GETSIG:
 case F_GETLEASE:
 case F_GETPIPE_SZ:
+case F_GETOWNER_UIDS:
 break;
 
 case F_SETFD:/* arg = flags */
 struct syscall syscall_fcntl = {
 .arg2type = ARG_OP,
 .arg2list = {
 #ifndef HAVE_LK64
-.num = 20,
+.num = 21,
 #else
-.num = 23,
+.num = 24,
 #endif
 .values = { F_DUPFD, F_DUPFD_CLOEXEC, F_GETFD, F_SETFD, F_GETFL, F_SETFL, F_GETLK, F_SETLK,
  F_SETLKW, F_GETOWN, F_SETOWN, F_GETOWN_EX, F_SETOWN_EX, F_GETSIG, F_SETSIG, F_GETLEASE,
- F_SETLEASE, F_NOTIFY, F_SETPIPE_SZ, F_GETPIPE_SZ,
+ F_SETLEASE, F_NOTIFY, F_SETPIPE_SZ, F_GETPIPE_SZ, F_GETOWNER_UIDS,
 #ifdef HAVE_LK64
  F_GETLK64, F_SETLK64, F_SETLKW64,
 #endif
",104,38
Convert maps.c over to use list.h,"
 #ifndef __LIST_H__
 #define __LIST_H__
 
+#include <stdio.h>
+
 /*
 * Simple linked-list routines, based on functions of the same name from the Linux kernel.
 */
",40,7
"change get_map to return the map struct, not the ptr"," void setup_maps(void)
 }
 
 /* Walk the list, get the j'th element */
-void * get_map(void)
+struct map * get_map(void)
 {
 struct map *m;
 struct list_head *node;
 void * get_map(void)
 m = (struct map *) node;
 
 if (i == j)
-return m->ptr;
+return m;
 j++;
 }
 return 0;
",144,21
add a TODO for tomorrow.," static void sanitise_mremap(int childno)
 p[i] = 1;
 }
 
+static void post_mremap(__unused__ int childno)
+{
+//FIXME: Need to stash a ptr to the map struct, and update it on success.
+}
+
 struct syscall syscall_mremap = {
 .name = ""mremap"",
 .num_args = 5,
 struct syscall syscall_mremap = {
 .arg5name = ""new_addr"",
 .arg5type = ARG_ADDRESS,
 .group = GROUP_VM,
+.post = post_mremap,
 };
",55,6
"don't do 3GB worth of mmaps on startup, it ooms way too quick."," static void alloc_zero_map(unsigned long size, int prot, const char *name)
 void setup_maps(void)
 {
 unsigned int i;
-const unsigned long sizes[] = { 1 * MB, 2 * MB, 4 * MB, 10 * MB, 1 * GB };
+const unsigned long sizes[] = {
+1 * MB, 2 * MB, 4 * MB, 10 * MB,
+//1 * GB,// disabled for now, due to OOM.
+};
 
 maps = zmalloc(sizeof(struct map));
 INIT_LIST_HEAD(&maps->list);
",142,18
update the mapping pointers on successful mremaps,"
 */
 #include <linux/mman.h>
 #include <stdlib.h>
+#include <sys/mman.h>
 #include ""trinity.h""// page_size
 #include ""arch.h""
 #include ""maps.h""
 static void sanitise_mremap(int childno)
 shm->a1[childno] &= PAGE_MASK;
 
 map = get_map();
+shm->scratch[childno] = (unsigned long) map;/* Save this for ->post */
 
 shm->a1[childno] = (unsigned long) map->ptr;
 shm->a2[childno] = map->size;
 static void sanitise_mremap(int childno)
 p[i] = 1;
 }
 
-static void post_mremap(__unused__ int childno)
+
+/*
+ * If we successfully remapped a range, we need to update our record of it
+ * so we don't re-use the old address.
+ */
+static void post_mremap(int childno)
 {
-//FIXME: Need to stash a ptr to the map struct, and update it on success.
+struct map *map = (struct map *) shm->scratch[childno];
+void *ptr = (void *) shm->retval[childno];
+
+if (ptr != MAP_FAILED)
+map->ptr = ptr;
 }
 
 struct syscall syscall_mremap = {
",61,7
don't write to read-only mappings.," static void alloc_zero_map(unsigned long size, int prot, const char *name)
 newnode = zmalloc(sizeof(struct map));
 newnode->name = strdup(name);
 newnode->size = size;
+newnode->prot = prot;
 newnode->ptr = mmap(NULL, size, prot, MAP_ANONYMOUS | MAP_SHARED, fd, 0);
 if (newnode->ptr == MAP_FAILED) {
 outputerr(""mmap failure\n"");
",143,18
add ARG_MMAP for routines that operate on mappings we're going to track.," static unsigned long fill_arg(int childno, int call, unsigned int argnum)
 case ARG_NON_NULL_ADDRESS:
 return (unsigned long) get_non_null_address();
 
+case ARG_MMAP:
+return (unsigned long) get_map();
+
 case ARG_PID:
 return (unsigned long) get_pid();
 
",337,119
make mremap use ARG_MMAP properly," static void sanitise_mremap(int childno)
 char *p;
 unsigned int i;
 
-shm->a1[childno] &= PAGE_MASK;
-
-map = get_map();
+map = (struct map *) shm->a1[childno];
 shm->scratch[childno] = (unsigned long) map;/* Save this for ->post */
 
 shm->a1[childno] = (unsigned long) map->ptr;
",63,8
use correct error check in mmap->post,"
 unsigned long, fd, unsigned long, off)
 */
 #include <stdlib.h>
-#include <asm/mman.h>
+#include <sys/mman.h>
 #include ""trinity.h""// page_size
 #include ""sanitise.h""
 #include ""shm.h""
 static void post_mmap(int childno)
 char *p;
 
 p = (void *) shm->retval[childno];
-if (p == NULL)
+if (p == MAP_FAILED)
 return;
 
 /* Sometimes dirty the mapping. */
",72,9
add a fixme for later," static void post_mmap(int childno)
 if (p == MAP_FAILED)
 return;
 
+//FIXME: Need to check here for PROT_WRITE when we add per-child mapping list.
+
 /* Sometimes dirty the mapping. */
 if (rand_bool())
 p[rand() % page_size] = 1;
",72,9
rename maps variables," void regenerate(void)
 /* Do random setsockopts on all network sockets. */
 do_sso_sockets();
 
-destroy_maps();
-setup_maps();
+destroy_global_mappings();
+setup_global_mappings();
 
 generate_random_page(page_rand);
 
",36,5
move some non mmap stuff out of maps.c,"
 #include ""arch.h""// page_size
 #include ""sanitise.h""
 #include ""shm.h""
-#include ""maps.h""// generate_random_page
+#include ""random.h""// generate_random_page
 
 static unsigned long ** gen_ptrs_to_crap(void)
 {
",40,5
move shm code out of trinity.c into own file," extern unsigned int num_online_cpus;
 
 extern char *progname;
 
-void * alloc_shared(unsigned int size);
-
 void do_main_loop(void);
 
 extern bool biarch;
 int check_tainted(void);
 void init_watchdog(void);
 unsigned int check_if_fd(unsigned int child);
 
-extern unsigned int user_specified_children;
-
 void regenerate(void);
 
 #define UNUSED(x) (void)(x)
",13,1
use common definition for MB/GB," static void alloc_zero_map(unsigned long size, int prot, const char *name)
 close(fd);
 }
 
-#define MB (1024 * 1024UL)
-#define GB (1024 * MB)
-
 void setup_global_mappings(void)
 {
 unsigned int i;
",102,10
add per-child mmap list.,"
 #include <sys/prctl.h>
 
 #include ""child.h""
-#include ""syscall.h""
+#include ""list.h""
 #include ""log.h""
+#include ""maps.h""
+#include ""params.h""// for 'debug'
+#include ""pids.h""
 #include ""random.h""
 #include ""shm.h""
 #include ""signals.h""
-#include ""pids.h""
-#include ""params.h""// for 'debug'
+#include ""syscall.h""
 #include ""tables.h""
 #include ""trinity.h""// ARRAY_SIZE
+#include ""utils.h""// zmalloc
 
 static struct rlimit oldrlimit;
 
 void init_child(int childno)
 
 if (rand() % 100 < 50)
 use_fpu();
+
+shm->mappings[childno] = zmalloc(sizeof(struct map));
+INIT_LIST_HEAD(&shm->mappings[childno]->list);
 }
 
 void check_parent_pid(void)
",142,24
add results from mmap to child-local list.," void init_child(int childno)
 if (rand() % 100 < 50)
 use_fpu();
 
+shm->num_mappings[childno] = 0;
 shm->mappings[childno] = zmalloc(sizeof(struct map));
 INIT_LIST_HEAD(&shm->mappings[childno]->list);
 }
",143,24
make get_map choose from both local and global mapping lists.," static void use_fpu(void)
 asm volatile("""":""+m"" (x));
 }
 
+int this_child = 0;
+
 void init_child(int childno)
 {
 cpu_set_t set;
 pid_t pid = getpid();
 
+this_child = childno;
+
 set_seed(childno);
 
 shm->kill_count[childno] = 0;
",145,24
set mmap sizes to something more interesting,"
 #include ""arch.h""
 #include ""compat.h""
 #include ""random.h""
+#include ""trinity.h""//ARRAY_SIZE
 #include ""utils.h""
 
 #ifdef __x86_64__
 void sanitise_mmap(int childno)
 #endif
 };
 unsigned int numflags = rand() % NUM_FLAGS;
+unsigned long sizes[] = {
+-1,/* over-written with page_size below */
+1 * MB, 2 * MB, 4 * MB, 10 * MB,
+1 * GB, // disabled for now, due to OOM.
+};
+
+sizes[0] = page_size;
 
 /* Don't actually set a hint right now. */
 shm->a1[childno] = 0;
 
-shm->a2[childno] = page_size;
-if (shm->a2[childno] == 0)
-shm->a2[childno] = page_size;
-
+shm->a2[childno] = sizes[rand() % ARRAY_SIZE(sizes)];
 
 // set additional flags
 for (i = 0; i < numflags; i++)
",91,9
move some macros out of trinity.h into utils.h,"
 #include <stdlib.h>
 #include <unistd.h>
 
-#include ""trinity.h""// biarch
+#include ""arch.h""// biarch
 #include ""child.h""
 #include ""syscall.h""
 #include ""log.h""
",126,28
"add a routine to delete local mappings

(so I don't forget to decrement the mapping count)"," void destroy_global_mappings(void)
 
 num_global_mappings = 0;
 }
+
+void delete_local_mapping(int childno, struct map *map)
+{
+list_del(&map->list);
+shm->num_mappings[childno]--;
+}
",123,15
make madvise map-list aware,"
 */
 #include <stdlib.h>
 #include <sys/mman.h>
-#include ""arch.h""// page_size
+#include ""maps.h""
 #include ""sanitise.h""
 #include ""shm.h""
 #include ""compat.h""
 
 static void sanitise_madvise(int childno)
 {
-shm->a2[childno] = rand() % page_size;
+struct map *map;
+
+map = (struct map *) shm->a1[childno];
+shm->scratch[childno] = (unsigned long) map; /* Save this for ->post */
+
+shm->a1[childno] = (unsigned long) map->ptr;
+shm->a2[childno] = map->size; //TODO: Munge this.
 }
 
 struct syscall syscall_madvise = {
 .name = ""madvise"",
 .num_args = 3,
 .arg1name = ""start"",
-.arg1type = ARG_NON_NULL_ADDRESS,
+.arg1type = ARG_MMAP,
 .arg2name = ""len_in"",
-.arg2type = ARG_LEN,
 .arg3name = ""advice"",
 .arg3type = ARG_OP,
 .arg3list = {
",31,1
add common routine for setting a1/a2 for start/len of mmap.," void delete_local_mapping(int childno, struct map *map)
 list_del(&map->list);
 shm->num_mappings[childno]--;
 }
+
+struct map * common_set_mmap_ptr_len(int childno)
+{
+struct map *map;
+
+map = (struct map *) shm->a1[childno];
+shm->scratch[childno] = (unsigned long) map; /* Save this for ->post */
+
+shm->a1[childno] = (unsigned long) map->ptr;
+shm->a2[childno] = map->size; //TODO: Munge this.
+
+return map;
+}
",132,16
make mlock aware of maps list,"
 * SYSCALL_DEFINE2(mlock, unsigned long, start, size_t, len)
 */
 #include <stdlib.h>
+#include ""maps.h""
 #include ""shm.h""
 #include ""sanitise.h""
 
 static void sanitise_mlock(int childno)
 {
-if (shm->a2[childno] == 0)
-shm->a2[childno] = 1;// must be non-null.
+(void) common_set_mmap_ptr_len(childno);
 }
 
 struct syscall syscall_mlock = {
 .name = ""mlock"",
 .num_args = 2,
 .arg1name = ""addr"",
-.arg1type = ARG_ADDRESS,
+.arg1type = ARG_MMAP,
 .arg2name = ""len"",
-.arg2type = ARG_LEN,
 .group = GROUP_VM,
 .sanitise = sanitise_mlock,
 };
",17,1
make munlock aware of maps list,"
 /*
 * SYSCALL_DEFINE2(munlock, unsigned long, start, size_t, len)
 */
+#include ""maps.h""
 #include ""sanitise.h""
 
+static void sanitise_munlock(int childno)
+{
+(void) common_set_mmap_ptr_len(childno);
+}
+
 struct syscall syscall_munlock = {
 .name = ""munlock"",
 .num_args = 2,
 .arg1name = ""addr"",
-.arg1type = ARG_ADDRESS,
+.arg1type = ARG_MMAP,
 .arg2name = ""len"",
-.arg2type = ARG_LEN,
 .group = GROUP_VM,
+.sanitise = sanitise_munlock,
 };
",15,1
make msync aware of maps list,"
 /*
 * SYSCALL_DEFINE3(msync, unsigned long, start, size_t, len, int, flags)
 */
+#include ""maps.h""
 #include ""sanitise.h""
 
 #define MS_ASYNC 1 /* Sync memory asynchronously. */
 #define MS_SYNC 4 /* Synchronous memory sync. */
 #define MS_INVALIDATE 2 /* Invalidate the caches. */
 
+static void sanitise_msync(int childno)
+{
+ (void) common_set_mmap_ptr_len(childno);
+}
+
 struct syscall syscall_msync = {
 .name = ""msync"",
 .num_args = 3,
 .arg1name = ""start"",
-.arg1type = ARG_ADDRESS,
+.arg1type = ARG_MMAP,
 .arg2name = ""len"",
-.arg2type = ARG_LEN,
 .arg3name = ""flags"",
 .arg3type = ARG_LIST,
 .arg3list = {
 struct syscall syscall_msync = {
 .values = { MS_ASYNC, MS_INVALIDATE, MS_SYNC },
 },
 .group = GROUP_VM,
+.sanitise = sanitise_msync,
 };
",21,1
"syscalls/prctl.c: Fix build with USE_SECCOMP disabled.

This patch fixes this build error on CentOS 6.

 CC	syscalls/prctl.o
syscalls/prctl.c:48: error: expected ) before int
cc1: warnings being treated as errors
syscalls/prctl.c: In function sanitise_prctl:
syscalls/prctl.c:63: error: implicit declaration of function do_set_seccomp
syscalls/prctl.c:63: error: nested extern declaration of do_set_seccomp

Signed-off-by: Vinson Lee <vlee@twitter.com>","
 #include ""shm.h""
 #include ""compat.h""
 #include ""utils.h""
+#include ""trinity.h""
 
 #define NR_PRCTL_OPTS 28
 static int prctl_opts[NR_PRCTL_OPTS] = {
",53,4
explicitly list l_linger as 0," void close_sockets(void)
 unsigned int i;
 int fd;
 int r = 0;
-struct linger ling = { .l_onoff = FALSE, };
+struct linger ling = { .l_onoff = FALSE, .l_linger = 0 };
 
 for (i = 0; i < nr_sockets; i++) {
 
",221,45
increment nr_sockets after we've done using it.," static int open_socket(unsigned int domain, unsigned int type, unsigned int prot
 output(2, ""fd[%i] = domain:%i (%s) type:0x%x protocol:%i\n"",
 fd, domain, get_proto_name(domain), type, protocol);
 
-nr_sockets++;
-
 /* Set some random socket options. */
 sso_socket(&shm->sockets[nr_sockets].triplet, &so, fd);
 
+nr_sockets++;
+
 /* Sometimes, listen on created sockets. */
 if (rand_bool()) {
 /* fake a sockaddr. */
",221,45
flush partial out to stdout.," static void output_syscall_prefix_to_fd(const unsigned int childno, const pid_t
 syscalls[syscallno].entry->arg6type, fd, mono);
 CRESETFD
 fprintf(fd, "") "");
+if (fd == stdout)
+fflush(stdout);
 }
 
 /* This function is always called from a fuzzing child. */
",345,94
avoid dereferencing null maps after we munmap everything," struct map * common_set_mmap_ptr_len(int childno)
 
 map = (struct map *) shm->a1[childno];
 shm->scratch[childno] = (unsigned long) map; /* Save this for ->post */
+if (map == NULL) {
+shm->a1[childno] = 0;
+shm->a2[childno] = 0;
+return NULL;
+}
 
 shm->a1[childno] = (unsigned long) map->ptr;
 shm->a2[childno] = map->size; //TODO: Munge this.
",137,17
output message when parsing failure for -a," void parse_args(int argc, char *argv[])
 do_64_arch = TRUE;
 else if (strcmp(optarg, ""32"") == 0)
 do_32_arch = TRUE;
-else
+else {
+outputstd(""can't parse %s\n"", optarg);
 exit(EXIT_FAILURE);
-
+}
 break;
 
 case 'C':
",270,56
add more missing flushes," static void output_syscall_prefix_to_fd(const unsigned int childno, const pid_t
 syscalls[syscallno].entry->arg6type, fd, mono);
 CRESETFD
 fprintf(fd, "") "");
-if (fd == stdout)
-fflush(stdout);
+fflush(fd);
 }
 
 /* This function is always called from a fuzzing child. */
 static void output_syscall_postfix_err(unsigned long ret, int errno_saved, FILE
 fprintf(fd, ""= %ld (%s)"", ret, strerror(errno_saved));
 CRESETFD
 fprintf(fd, ""\n"");
+fflush(fd);
 }
 
 static void output_syscall_postfix_success(unsigned long ret, FILE *fd, bool mono)
 static void output_syscall_postfix_success(unsigned long ret, FILE *fd, bool mon
 fprintf(fd, ""= %ld"", ret);
 CRESETFD
 fprintf(fd, ""\n"");
+fflush(fd);
 }
 
 void output_syscall_postfix(unsigned long ret, int errno_saved, bool err)
",346,93
explicitly clear the other arch if not specified in -a," void parse_args(int argc, char *argv[])
 /* One of the architectures selected*/
 do_32_arch = FALSE;
 do_64_arch = FALSE;
-if (strcmp(optarg, ""64"") == 0)
+if (strcmp(optarg, ""64"") == 0) {
+do_32_arch = FALSE;
 do_64_arch = TRUE;
-else if (strcmp(optarg, ""32"") == 0)
+} else if (strcmp(optarg, ""32"") == 0) {
 do_32_arch = TRUE;
-else {
+do_64_arch = FALSE;
+} else {
 outputstd(""can't parse %s\n"", optarg);
 exit(EXIT_FAILURE);
 }
",272,56
remove outdated comment," void sanitise_mmap(int childno)
 unsigned long sizes[] = {
 -1,/* over-written with page_size below */
 1 * MB, 2 * MB, 4 * MB, 10 * MB,
-1 * GB, // disabled for now, due to OOM.
+1 * GB,
 };
 
 sizes[0] = page_size;
",91,9
centralise the 'dirty a mapping' code.,"
 #include <sys/mman.h>
 #include <sys/types.h>
 #include <sys/stat.h>
-#include ""trinity.h""// page_size
 #include ""arch.h""
 #include ""child.h""
-#include ""maps.h""
 #include ""list.h""
 #include ""log.h""
+#include ""maps.h""
 #include ""random.h""
 #include ""shm.h""
+#include ""trinity.h""// page_size
 #include ""utils.h""
 
 static unsigned int num_global_mappings = 0;
 struct map * common_set_mmap_ptr_len(int childno)
 
 return map;
 }
+
+void dirty_mapping(struct map *map)
+{
+char *p = map->ptr;
+unsigned int i;
+
+/* Check mapping is writable. */
+if (!(map->prot & PROT_WRITE))
+return;
+
+if (rand_bool()) {
+/* Just fault in one page. */
+p[rand() % page_size] = 1;
+} else {
+/* fault in the whole mapping */
+for (i = 0; i < map->size; i += page_size)
+p[i] = 1;
+}
+//TODO: More access patterns.
+}
",150,21
msync can't be ASYNC and SYNC,"
 * SYSCALL_DEFINE3(msync, unsigned long, start, size_t, len, int, flags)
 */
 #include ""maps.h""
+#include ""random.h""
 #include ""sanitise.h""
+#include ""shm.h""
 
 #define MS_ASYNC 1 /* Sync memory asynchronously. */
 #define MS_SYNC 4 /* Synchronous memory sync. */

 static void sanitise_msync(int childno)
 {
 (void) common_set_mmap_ptr_len(childno);
+
+if (rand_bool())
+shm->a3[childno] |= MS_INVALIDATE;
 }
 
 struct syscall syscall_msync = {
 struct syscall syscall_msync = {
 .arg1type = ARG_MMAP,
 .arg2name = ""len"",
 .arg3name = ""flags"",
-.arg3type = ARG_LIST,
+.arg3type = ARG_OP,
 .arg3list = {
-.num = 3,
-.values = { MS_ASYNC, MS_INVALIDATE, MS_SYNC },
+.num = 2,
+.values = { MS_ASYNC, MS_SYNC },
 },
 .group = GROUP_VM,
 .sanitise = sanitise_msync,
",25,2
clean up the remap_file_pages sanitize routine,"
 
 static void sanitise_remap_file_pages(int childno)
 {
-(void) common_set_mmap_ptr_len(childno);
+struct map *map;
+size_t size;
 
-shm->a3[childno] = 0;
+map = common_set_mmap_ptr_len(childno);
+
+/* We just want to remap a part of the mapping. */
+size = rand() % map->size;
+shm->a2[childno] = size;
 
-retry_pgoff:
-if (shm->a4[childno] + (shm->a2[childno] >> PAGE_SHIFT) < shm->a4[childno]) {
-shm->a4[childno] = rand() & (shm->a2[childno] / page_size);
-goto retry_pgoff;
-}
+/* ""The prot argument must be specified as 0"" */
+shm->a3[childno] = 0;
 
-retry_pgoff_bits:
-if (shm->a4[childno] + (shm->a2[childno] >> PAGE_SHIFT) >= (1UL << PTE_FILE_MAX_BITS)) {
-shm->a4[childno] = (shm->a4[childno] >> 1);
-goto retry_pgoff_bits;
-}
+/* Pick a random pgoff. */
+shm->a4[childno] = rand() & (size / page_size);
 }
 
 struct syscall syscall_remap_file_pages = {
",34,1
make -g followed by a -x work.," static int munge_tables(void)
 enable_random_syscalls();
 
 /* If we saw a '-x', set all syscalls to enabled, then selectively disable.
- * Unless we've started enabling them already (with -r)
+ * Unless we've started enabling them already (with -r) (or if we specified a group -g)
  */
 if (do_exclude_syscall == TRUE) {
-if (random_selection == FALSE)
+if ((random_selection == FALSE) && (desired_group == GROUP_NONE))
 mark_all_syscalls_active();
 deactivate_disabled_syscalls();
 }
",177,38
add a show_backtrace function for debugging.,"
 #define MB (1024 * 1024UL)
 #define GB (1024 * MB)
 
+void show_backtrace(void);
+
 void * zmalloc(size_t size);
 
 #define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))
",7,1
"actually, forget that idea.","
 #define MB (1024 * 1024UL)
 #define GB (1024 * MB)
 
-void show_backtrace(void);
-
 void * zmalloc(size_t size);
 
 #define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))
",6,1
"if this fails we're SOL anyway.

But it shuts coverity up"," static void alloc_zero_map(unsigned long size, int prot, const char *name)
 int fd;
 
 fd = open(""/dev/zero"", O_RDWR);
+if (fd == -1) {
+outputerr(""couldn't open /dev/zero\n"");
+exit(EXIT_FAILURE);
+}
 
 newnode = zmalloc(sizeof(struct map));
 newnode->name = strdup(name);
",154,22
"perf_event_open update to 3.13-rc3

Update perf_event_open support to Linux 3.13-rc3

This mostly just enables Haswell PERF_SAMPLE_TRANSACTION
support.

Signed-off-by: Vince Weaver <vincent.weaver@maine.edu>"," static long long random_sample_type(void)
 sample_type |= PERF_SAMPLE_DATA_SRC;
 if (rand_bool())
 sample_type |= PERF_SAMPLE_IDENTIFIER;
+if (rand_bool())
+sample_type |= PERF_SAMPLE_TRANSACTION;
 
 return sample_type;
 }
",1010,248
remove pointless duplicate break," static void sanitise_fcntl(int childno)
 case F_SETLEASE:
 shm->a3[childno] = (unsigned long) get_random_fd();
 break;
-break;
 
 /* no arg */
 case F_GETFD:
",103,38
remove unnecessary init," struct map * get_map(void)
 
 void destroy_global_mappings(void)
 {
-struct map *m = global_mappings;
+struct map *m;
 
 while (!list_empty(&global_mappings->list)) {
 m = global_mappings;
",154,22
"throw away result, we don't care."," void do_main_loop(void)
 }
 
 /* wait for main loop process to exit. */
-pid = waitpid(pid, &childstatus, 0);
+(void)waitpid(pid, &childstatus, 0);
 shm->mainpid = 0;
 }
",299,64
"remove duplicate varaible.

pidslot == childno"," static unsigned long do_syscall(int childno, int *errno_saved)
 int nr = shm->syscallno[childno];
 unsigned long a1, a2, a3, a4, a5, a6;
 unsigned long ret = 0;
-int pidslot;
 
 a1 = shm->a1[childno];
 a2 = shm->a2[childno];
 static unsigned long do_syscall(int childno, int *errno_saved)
 a5 = shm->a5[childno];
 a6 = shm->a6[childno];
 
-pidslot = find_pid_slot(getpid());
-if (pidslot != PIDSLOT_NOT_FOUND) {
-shm->total_syscalls_done++;
-shm->child_syscall_count[pidslot]++;
-(void)gettimeofday(&shm->tv[pidslot], NULL);
-}
+shm->total_syscalls_done++;
+shm->child_syscall_count[childno]++;
+(void)gettimeofday(&shm->tv[childno], NULL);
 
 if (syscalls[nr].entry->flags & NEED_ALARM)
 (void)alarm(1);
",148,28
update 'now' every pidslot walk instead of once per loop.," static void check_children(void)
 pid_t pid;
 unsigned int i;
 
-gettimeofday(&tv, NULL);
-now = tv.tv_sec;
-
 for_each_pidslot(i) {
 pid = shm->pids[i];
 
 static void check_children(void)
 if (old == 0)
 continue;
 
+gettimeofday(&tv, NULL);
+now = tv.tv_sec;
+
 /* if we wrapped, just reset it, we'll pick it up next time around. */
 if (old > (now + 3)) {
 output(1, ""child %d wrapped! old=%ld now=%ld\n"", i, old, now);
",308,64
remove misleading message.," int child_random_syscalls(int childno)
 goto out;
 }
 
-if (shm->exit_reason != STILL_RUNNING) {
-outputerr(""Main is not running, exiting"");
+if (shm->exit_reason != STILL_RUNNING)
 goto out;
-}
 
 syscallnr = rand() % nr_active_syscalls;
 /* If we got a syscallnr which is not actvie repeat the attempt, since another child has switched that syscall off already.*/
",124,28
bump up maximum children to 256.," static void fork_children(void)
 mask_signals_child();
 
 memset(childname, 0, sizeof(childname));
-sprintf(childname, ""trinity-child%d"", pidslot);
+sprintf(childname, ""trinity-c%d"", pidslot);
 prctl(PR_SET_NAME, (unsigned long) &childname);
 
 oom_score_adj(500);
",299,64
"store mapping type in the struct.

right now we could figure this out by looking what list it's on, but
actually storing it is simpler."," static void alloc_zero_map(unsigned long size, int prot, const char *name)
 newnode->name = strdup(name);
 newnode->size = size;
 newnode->prot = prot;
+newnode->type = MAP_GLOBAL;
 newnode->ptr = mmap(NULL, size, prot, MAP_ANONYMOUS | MAP_SHARED, fd, 0);
 if (newnode->ptr == MAP_FAILED) {
 outputerr(""mmap failure\n"");
 void destroy_global_mappings(void)
 num_global_mappings = 0;
 }
 
-void delete_local_mapping(int childno, struct map *map)
+static void delete_local_mapping(int childno, struct map *map)
 {
 list_del(&map->list);
 shm->num_mappings[childno]--;
 }
 
+void delete_mapping(int childno, struct map *map)
+{
+if (map->type == MAP_LOCAL)
+delete_local_mapping(childno, map);
+
+/* Right now, we don't want to delete MAP_GLOBAL mappings */
+}
+
 struct map * common_set_mmap_ptr_len(int childno)
 {
 struct map *map;
",160,24
generate random sockaddr contents if we don't know the protocol yet.,"
 #include ""net.h""
 #include ""maps.h""
 #include ""config.h""
+#include ""random.h""
 #include ""params.h""// do_specific_proto
 #include ""utils.h""// ARRAY_SIZE
 
 void generate_sockaddr(unsigned long **addr, unsigned long *addrlen, int pf)
 pf = rand() % TRINITY_PF_MAX;
 
 for (i = 0; i < ARRAY_SIZE(sa_funcs); i++) {
-if (sa_funcs[i].pf == (unsigned int) pf)
+if (sa_funcs[i].pf == (unsigned int) pf) {
 sa_funcs[i].func(addr, addrlen);
+return;
+}
 }
+
+/* Make something up for unknown protocols. */
+*addr = (unsigned long *) page_rand;
+*addrlen = rand() % 100;
 }
",59,5
beginnings of rds sockaddr gen,"
 #include ""compat.h""
 #include ""utils.h""// ARRAY_SIZE
 
-#define NR_SOL_RDS_OPTS ARRAY_SIZE(rds_opts)
+void rds_gen_sockaddr(unsigned long **addr, unsigned long *addrlen)
+{
+struct sockaddr_in *rds;
+
+rds = malloc(sizeof(struct sockaddr_in));
+if (rds == NULL)
+return;
+rds->sin_family = AF_INET;
+rds->sin_addr.s_addr = random_ipv4_address();
+rds->sin_port = rand() % 65535;
+
+*addr = (unsigned long *) rds;
+*addrlen = sizeof(struct sockaddr_in);
+}
+
 static const unsigned int rds_opts[] = {
 RDS_CANCEL_SENT_TO, RDS_GET_MR, RDS_FREE_MR,
 4, /* deprecated RDS_BARRIER 4 */
 RDS_RECVERR, RDS_CONG_MONITOR, RDS_GET_MR_FOR_DEST };
+#define NR_SOL_RDS_OPTS ARRAY_SIZE(rds_opts)
 
 void rds_setsockopt(struct sockopt *so)
 {
",33,4
"collapse the various sockaddr/setsockopt files into per-proto files.

I got tired of bouncing between the two sets.","
 #ifdef USE_IF_ALG
 #include <linux/if_alg.h>
 
+#define SOL_ALG 279
+
 void alg_gen_sockaddr(unsigned long **addr, unsigned long *addrlen)
 {
 struct sockaddr_alg *alg;
 void alg_gen_sockaddr(unsigned long **addr, unsigned long *addrlen)
 *addrlen = sizeof(struct sockaddr_alg);
 }
 
+void alg_setsockopt(struct sockopt *so)
+{
+so->level = SOL_ALG;
+}
 #endif
",30,5
"fix centos6 build failures

reported & tested by Vinson Lee.","
 #include ""net.h""
 #include ""compat.h""
 
+#define SOL_ALG 279
+
 #ifdef USE_IF_ALG
 #include <linux/if_alg.h>
 
-#define SOL_ALG 279
-
 void alg_gen_sockaddr(unsigned long **addr, unsigned long *addrlen)
 {
 struct sockaddr_alg *alg;
 void alg_gen_sockaddr(unsigned long **addr, unsigned long *addrlen)
 *addr = (unsigned long *) alg;
 *addrlen = sizeof(struct sockaddr_alg);
 }
+#endif
 
 void alg_setsockopt(struct sockopt *so)
 {
 so->level = SOL_ALG;
 }
-#endif
",30,5
"change sockaddr generation to pass around correct types.

These are pointers to sockaddr structs, not unsigned longs."," static unsigned long handle_arg_len_already_set(int childno, unsigned long argnu
 static unsigned long handle_arg_sockaddr(int childno, unsigned long call, unsigned long argnum)
 {
 struct sockaddr *sockaddr = NULL;
-unsigned long sockaddrlen = 0;
+socklen_t sockaddrlen = 0;
 
-generate_sockaddr((unsigned long **)&sockaddr, &sockaddrlen, PF_NOHINT);
+generate_sockaddr((struct sockaddr **)&sockaddr, &sockaddrlen, PF_NOHINT);
 
 switch (argnum) {
 case 1:if (syscalls[call].entry->arg2type == ARG_SOCKADDRLEN)
",338,119
don't free(page_rand) when we don't have a sockaddr generator.,"
 #include ""constants.h""
 #include ""log.h""
 #include ""net.h""
+#include ""maps.h""
 #include ""params.h""// verbose, do_specific_proto
 #include ""protocols.h""
 #include ""random.h""
 static int open_socket(unsigned int domain, unsigned int type, unsigned int prot
 debugf(""listen: success!\n"");
 */
 }
+
+/* If we didn't have a function for this sockaddr type, we would
+ * have returned page_rand, so don't free() it or we segv. */
+if (sa == (struct sockaddr *) page_rand)
+return fd;
+
 if (sa != NULL)
- free(sa);
+free(sa);
 
 return fd;
 }
",224,46
"use pragma once instead of ifndef guards.

also adds some missing guards to some files.","
-#ifndef __LIST_H__
-#define __LIST_H__
+#pragma once
 
 #include <stdio.h>
 
 static inline void list_del(struct list_head *entry)
 #define list_for_each(pos, head) \
 for (pos = (head)->next; pos != (head); pos = pos->next)
 
-#endif
",40,7
max_nr_children doesn't need to be in the shm,"
 #include <sys/epoll.h>
 #include <sys/eventfd.h>
 
-#include ""perf.h""
-#include ""random.h""
-#include ""shm.h""
 #include ""files.h""
-#include ""pids.h""
-#include ""net.h""
 #include ""log.h""
-#include ""sanitise.h""
+#include ""net.h""
 #include ""params.h""
+#include ""perf.h""
+#include ""pids.h""
+#include ""random.h""
+#include ""sanitise.h""
+#include ""shm.h""
+#include ""trinity.h""
 
 /* Pipe FD related functions. */
 static void open_pipes(void)
 int get_random_fd(void)
 regen:
 if (shm->fd_lifetime == 0) {
 shm->current_fd = get_new_random_fd();
-shm->fd_lifetime = (rand() % shm->max_children) + 5;
+shm->fd_lifetime = (rand() % max_children) + 5;
 } else
 shm->fd_lifetime--;
 
",172,38
pass around a page of ptrs to the shared mmaps,"
 #include <sys/resource.h>
 #include <sys/prctl.h>
 
+#include ""arch.h""
 #include ""child.h""
 #include ""list.h""
 #include ""log.h""
 static void use_fpu(void)
 
 int this_child = 0;
 
+static void setup_page_maps(void)
+{
+struct map *map;
+unsigned long *page;
+unsigned int i;
+
+page = (void *) page_maps;
+
+for (i = 0; i < page_size / sizeof(unsigned long); i++) {
+map = get_map();
+page[i] = (unsigned long) map->ptr;
+}
+}
+
 void init_child(int childno)
 {
 cpu_set_t set;
 void init_child(int childno)
 
 disable_coredumps();
 
+setup_page_maps();
+
 if (sched_getaffinity(pid, sizeof(set), &set) == 0) {
 CPU_ZERO(&set);
 CPU_SET(childno, &set);
",158,26
fault in every other page of a mapping," void dirty_mapping(struct map *map)
 if (!(map->prot & PROT_WRITE))
 return;
 
-if (rand_bool()) {
+switch (rand() % 3) {
+case 0:
 /* Just fault in one page. */
-p[rand() % page_size] = 1;
-} else {
-/* fault in the whole mapping */
+p[rand() % page_size] = rand();
+break;
+case 1:
+/* fault in the whole mapping. */
 for (i = 0; i < map->size; i += page_size)
-p[i] = 1;
+p[i] = rand();
+break;
+case 2:
+/* every other page. */
+for (i = 0; i < map->size; i += (page_size * 2))
+p[i] = rand();
+break;
+default:
+break;
 }
-//TODO: More access patterns.
 }
",198,31
fault in mapping in reverse order," void dirty_mapping(struct map *map)
 if (!(map->prot & PROT_WRITE))
 return;
 
-switch (rand() % 3) {
+switch (rand() % 4) {
 case 0:
 /* Just fault in one page. */
 p[rand() % page_size] = rand();
 void dirty_mapping(struct map *map)
 for (i = 0; i < map->size; i += (page_size * 2))
 p[i] = rand();
 break;
+
+case 3:
+/* whole mapping in reverse */
+for (i = map->size; i > 0; i -= page_size)
+p[i] = rand();
+break;
+
 default:
 break;
 }
",202,33
fault in pages in random order.," void dirty_mapping(struct map *map)
 {
 char *p = map->ptr;
 unsigned int i;
+unsigned int num_pages = map->size / page_size;
 
 /* Check mapping is writable. */
 if (!(map->prot & PROT_WRITE))
 return;
 
-switch (rand() % 4) {
+switch (rand() % 5) {
 case 0:
 /* Just fault in one page. */
 p[rand() % page_size] = rand();
 break;
+
 case 1:
 /* fault in the whole mapping. */
 for (i = 0; i < map->size; i += page_size)
 p[i] = rand();
 break;
+
 case 2:
 /* every other page. */
 for (i = 0; i < map->size; i += (page_size * 2))
 void dirty_mapping(struct map *map)
 p[i] = rand();
 break;
 
+case 4:
+/* fault in map->size pages. (some may be faulted >once) */
+for (i = 0; i < num_pages; i++);
+p[rand() % num_pages] = rand();
+break;
+
 default:
 break;
 }
",207,35
only allocate page_types array once," static void sanitise_move_pages(int childno)
 unsigned long *page_alloc;
 unsigned int i, j;
 
-pagetypes = zmalloc(page_size);
+if (pagetypes == NULL)
+pagetypes = malloc(page_size);
+memset(pagetypes, 0, page_size);
 
 /* number of pages to move */
 count = rand() % (page_size / sizeof(void *));
",90,14
"be more quiet in [main] Setsockopt(...

Signed-off-by: Toralf Frster <toralf.foerster@gmx.de>"," retry:
 
 ret = setsockopt(fd, so->level, so->optname, (void *)so->optval, so->optlen);
 if (ret == 0) {
-output(1, ""Setsockopt(%lx %lx %lx %lx) on fd %d [%d:%d:%d]\n"",
+output(2, ""Setsockopt(%lx %lx %lx %lx) on fd %d [%d:%d:%d]\n"",
 so->level, so->optname, so->optval, so->optlen, fd,
 triplet->family, triplet->type, triplet->protocol);
 } else {
",115,10
use network order for port number," void ipv4_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 
 ipv4->sin_family = PF_INET;
 ipv4->sin_addr.s_addr = random_ipv4_address();
-ipv4->sin_port = rand() % 65535;
+ipv4->sin_port = htons(rand() % 65535);
 *addr = (struct sockaddr *) ipv4;
 *addrlen = sizeof(struct sockaddr_in);
 }
",218,71
use network order for port number in ipv6 too," void ipv6_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 ipv6->sin6_addr.s6_addr32[1] = 0;
 ipv6->sin6_addr.s6_addr32[2] = 0;
 ipv6->sin6_addr.s6_addr32[3] = htonl(1);
-ipv6->sin6_port = rand() % 65535;
+ipv6->sin6_port = htons(rand() % 65535);
 *addr = (struct sockaddr *) ipv6;
 *addrlen = sizeof(struct sockaddr_in6);
 }
",60,8
do address munging all the time.," in_addr_t random_ipv4_address(void)
 break;
 }
 
-if (rand() % 100 < 50) {
-switch (class) {
-case 8:addr |= rand() % 0xffffff;
-break;
-case 12: addr |= rand() % 0xfffff;
-break;
-case 16: addr |= rand() % 0xffff;
-break;
-case 24: addr |= rand() % 0xff;
-break;
-default: break;
-}
+switch (class) {
+case 8:addr |= rand() % 0xffffff;
+break;
+case 12: addr |= rand() % 0xfffff;
+break;
+case 16: addr |= rand() % 0xffff;
+break;
+case 24: addr |= rand() % 0xff;
+break;
+default: break;
 }
 return htonl(addr);
 }
",216,70
reuse the same IP five times.,"
 #define IP_MULTICAST_ALL 49
 #endif
 
+int previous_ip;
+static unsigned int ip_lifetime = 0;
+
 in_addr_t random_ipv4_address(void)
 {
 int addr = 0;
 int class = 0;
 
+if (ip_lifetime != 0) {
+ip_lifetime--;
+return previous_ip;
+}
+
 switch (rand() % 9) {
 case 0:addr = 0;/* 0.0.0.0 */
 class = 8;
 in_addr_t random_ipv4_address(void)
 break;
 default: break;
 }
+
+previous_ip = addr;
+ip_lifetime = 5;
+
 return htonl(addr);
 }
 
",224,71
save a getuid() call each loop,"
 
 char *progname = NULL;
 
+uid_t origuid;
+
 unsigned int page_size;
 unsigned int num_online_cpus;
 unsigned int max_children;
 int main(int argc, char* argv[])
 
 initpid = getpid();
 
+origuid = getuid();
+
 page_size = getpagesize();
 num_online_cpus = sysconf(_SC_NPROCESSORS_ONLN);
 
",124,20
hand out page_maps as an address," static void * _get_address(unsigned char null_allowed)
 void *addr = NULL;
 
 if (null_allowed == TRUE)
-i = rand() % 9;
+i = rand() % 10;
 else
-i = (rand() % 8) + 1;
+i = (rand() % 9) + 1;
 
 
 switch (i) {
 static void * _get_address(unsigned char null_allowed)
 // tricky. We want to hand the munged version out too, so we might end up
 // having to split this into alloc_address / get_address.
 break;
+case 9:addr = page_maps;
+break;
 default:
 BUG(""unreachable!\n"");
 break;
",109,38
fix off-by-one that could lead to div by 0," void dirty_mapping(struct map *map)
 case 4:
 /* fault in map->size pages. (some may be faulted >once) */
 for (i = 0; i < num_pages; i++);
-p[rand() % num_pages] = rand();
+p[rand() % (num_pages + 1)] = rand();
 break;
 
 default:
",207,35
"validate protocol when passing -P and handle accordingly.

graceful exit means we have to pass failure upwards."," regen:
 return shm->current_fd;
 }
 
-void setup_fds(void)
+unsigned int setup_fds(void)
 {
+int ret;
+
 /* If we have victim files, don't worry about sockets. */
-if (victim_path == NULL)
-open_sockets();
+if (victim_path == NULL) {
+ret = open_sockets();
+if (ret == FALSE)
+return FALSE;
+}
 
 open_pipes();
 
 void setup_fds(void)
 if (no_files == FALSE) {
 generate_filelist();
 if (files_in_index == 0)/* Something bad happened. Crappy -V maybe? */
-return;// FIXME: We should log something here probably.
+return FALSE;// FIXME: We should log something here probably.
 
 open_files();
 }
+
+return TRUE;
 }
 
 void regenerate_fds(void)
",177,39
remove some other getuid calls.," struct namelist {
 
 static struct namelist *names = NULL;
 
-static uid_t my_uid;
 static gid_t my_gid;
 
 static int ignore_files(const char *path)
 static int check_stat_file(const struct stat *sb)
 if (S_ISLNK(sb->st_mode))
 return -1;
 
-if (sb->st_uid == my_uid) {
+if (sb->st_uid == origuid) {
 if (sb->st_mode & S_IRUSR)
 set_read = TRUE;
 if (sb->st_mode & S_IWUSR)
 void generate_filelist(void)
 struct list_head *node;
 struct namelist *nl;
 
-my_uid = getuid();
 my_gid = getgid();
 
 names = zmalloc(sizeof(struct namelist));
",240,55
move printing shm ptr to shm.c,"
 #include ""log.h""
 #include ""maps.h""
 #include ""random.h""
-#include ""shm.h""
 #include ""trinity.h""// page_size
 #include ""utils.h""
 
 void init_shared_pages(void)
 {
 unsigned int i;
 
-output(2, ""shm is at %p\n"", shm);
-
 // a page of zeros
 page_zeros = __allocbuf(""page_zeros"");
 
",37,4
rename global -> shared," void init_shared_pages(void)
 page_maps = __allocbuf(""page_maps"");
 
 // mmaps that get shared across children.
-setup_global_mappings();
+setup_shared_mappings();
 
-// generate_random_page may end up using global_mappings, so has to be last.
+// generate_random_page may end up using shared_mappings, so has to be last.
 generate_random_page(page_rand);
 }
",37,4
remove unneeded includes,"
 #include ""list.h""
 #include ""log.h""
 #include ""maps.h""
-#include ""trinity.h""// page_size
 #include ""utils.h""
 
 unsigned int num_shared_mappings = 0;
",87,9
cppcheck variable scoping reductions.," int this_child = 0;
 
 static void setup_page_maps(void)
 {
-struct map *map;
 unsigned long *page;
 unsigned int i;
 
 page = (void *) page_maps;
 
 for (i = 0; i < page_size / sizeof(unsigned long); i++) {
+struct map *map;
+
 map = get_map();
 page[i] = (unsigned long) map->ptr;
 }
",158,26
cppcheck format string corrections.," void dump_pid_slots(void)
 unsigned int i, j = 0;
 char string[512], *sptr = string;
 
-sptr += sprintf(sptr, ""## pids: (%d active)\n"", shm->running_childs);
+sptr += sprintf(sptr, ""## pids: (%u active)\n"", shm->running_childs);
 
 for (i = 0; i < max_children; i += 8) {
-sptr += sprintf(sptr, ""%d-%d: "", i, i+7);
+sptr += sprintf(sptr, ""%u-%u: "", i, i+7);
 for (j = 0; j < 8; j++) {
 if (shm->pids[i+j] != EMPTY_PIDSLOT) {
 if (pid_alive(shm->pids[i+j] == -1))
",113,26
"ugly workaround for bug introduced by the format string cleanups

Better would be for ret to be passed down as a signed long, but
this at least fixes things for now."," void output_syscall_prefix(const unsigned int childno, const unsigned int syscal
 static void output_syscall_postfix_err(unsigned long ret, int errno_saved, FILE *fd, bool mono)
 {
 REDFD
-fprintf(fd, ""= %lu (%s)"", ret, strerror(errno_saved));
+fprintf(fd, ""= %ld (%s)"", (long) ret, strerror(errno_saved));
 CRESETFD
 fprintf(fd, ""\n"");
 fflush(fd);
 static void output_syscall_postfix_success(unsigned long ret, FILE *fd, bool mon
 if ((unsigned long)ret > 10000)
 fprintf(fd, ""= 0x%lx"", ret);
 else
-fprintf(fd, ""= %lu"", ret);
+fprintf(fd, ""= %ld"", (long) ret);
 CRESETFD
 fprintf(fd, ""\n"");
 fflush(fd);
",348,93
"introduce a ->decode function for syscalls to output decoded parameters.

decode mmap PROT args as an example, but it's going to be more useful
for decoding structs."," static void post_mmap(int childno)
 dirty_mapping(new);
 }
 
+static char * decode_mmap(int argnum, int childno)
+{
+char *buf;
+
+if (argnum == 3) {
+int flags = shm->a3[childno];
+char *p;
+
+p = buf = zmalloc(80);
+p += sprintf(buf, ""["");
+
+if (flags == 0) {
+p += sprintf(p, ""PROT_NONE]"");
+return buf;
+}
+if (flags & PROT_READ)
+p += sprintf(p, ""PROT_READ|"");
+if (flags & PROT_WRITE)
+p += sprintf(p, ""PROT_WRITE|"");
+if (flags & PROT_EXEC)
+p += sprintf(p, ""PROT_EXEC|"");
+if (flags & PROT_SEM)
+p += sprintf(p, ""PROT_SEM "");
+p--;
+sprintf(p, ""]"");
+
+return buf;
+}
+return NULL;
+}
+
 struct syscall syscall_mmap = {
 .name = ""mmap"",
 .num_args = 6,
+
 .sanitise = sanitise_mmap,
+.post = post_mmap,
+.decode = decode_mmap,
+
 .arg1name = ""addr"",
 .arg1type = ARG_MMAP,
 .arg2name = ""len"",
 struct syscall syscall_mmap = {
 .arg5type = ARG_FD,
 .arg6name = ""off"",
 .arg6type = ARG_LEN,
+
 .group = GROUP_VM,
 .flags = NEED_ALARM,
-.post = post_mmap,
 };
",117,15
"when faulting in a page, don't just do the first page in the mapping."," void dirty_mapping(struct map *map)
 switch (rand() % 5) {
 case 0:
 /* Just fault in one page. */
-p[rand() % page_size] = rand();
+p[rand() % map->size] = rand();
 break;
 
 case 1:
",94,22
"shut up llvm false positive.

The default case won't ever be hit, but we might as well just set it to NULL."," void synclogs(void)
 static void output_arg(unsigned int argnum, struct syscall *syscall, FILE *fd, bool mono, int childno)
 {
 int type = 0;
-const char *name;
+const char *name = NULL;
 unsigned long reg;
 
 switch (argnum) {
",380,101
don't check for uid changes when we run as root," static void check_uid(void)
 {
 uid_t myuid;
 
+/* If we were root, then obviously setuid() will change us, so don't even check. */
+if (orig_uid == 0)
+return;
+
 myuid = getuid();
 if (myuid != orig_uid) {
 
",152,29
"rename the syscall struct to syscallentry

and rename all instances of variables using it.

(all because an older ver of gcc doesn't like shadowing syscall()
 with a struct of the same name. Garg.)"," static void sanitise_execve(__unused__ int childno)
 shm->a3[childno] = (unsigned long) gen_ptrs_to_crap();
 }
 
-struct syscall syscall_execve = {
+struct syscallentry syscall_execve = {
 .name = ""execve"",
 .num_args = 3,
 .arg1name = ""name"",
",40,5
only process the number of args a syscall entry has.," void outputstd(const char *fmt, ...)
 static void output_syscall_prefix_to_fd(const unsigned int childno, const pid_t pid, const unsigned int syscallno, FILE *fd, bool mono)
 {
 struct syscallentry *entry;
+unsigned int i;
 
 entry = syscalls[syscallno].entry;
 
 static void output_syscall_prefix_to_fd(const unsigned int childno, const pid_t
 CRESETFD
 fprintf(fd, ""("");
 
-output_arg(1, entry, fd, mono, childno);
-output_arg(2, entry, fd, mono, childno);
-output_arg(3, entry, fd, mono, childno);
-output_arg(4, entry, fd, mono, childno);
-output_arg(5, entry, fd, mono, childno);
-output_arg(6, entry, fd, mono, childno);
+for (i = 1; i < entry->num_args + 1; i++)
+output_arg(i, entry, fd, mono, childno);
 
 CRESETFD
 fprintf(fd, "") "");
",379,102
we always have name set.," static void output_arg(unsigned int argnum, struct syscallentry *entry, FILE *fd
 }
 
 if (entry->num_args >= argnum) {
-if (!name)
-return;
 
 if (argnum != 1) {
 CRESETFD
 fprintf(fd, "", "");
 }
-if (name)
-fprintf(fd, ""%s="", name);
+
+fprintf(fd, ""%s="", name);
 
 switch (type) {
 case ARG_PATHNAME:
",376,100
guarantee page alignment for page allocs.,"
 #define MPOL_MF_MOVE (1<<1) /* Move pages owned by this process to conform to mapping */
 #define MPOL_MF_MOVE_ALL (1<<2) /* Move every page to conform to mapping */
 
+#include <malloc.h>
 #include <string.h>
 #include <stdlib.h>
 #include <unistd.h>
 static void sanitise_move_pages(int childno)
 for (i = 0; i < count; i++) {
 if (rand_bool()) {
 /* malloc */
-page_alloc[i] = (unsigned long) malloc(page_size);
+page_alloc[i] = (unsigned long) memalign(page_size, page_size);
 if (!page_alloc[i]) {
 free_all_pageallocs(page_alloc);
 return;
 }
-page_alloc[i] &= PAGE_MASK;
 pagetypes[i] = WAS_MALLOC;
 } else {
 /* mapping. */
",89,13
"put the masking on the variable that changes, not the original alloc."," static void output_arg(unsigned int argnum, struct syscallentry *entry, FILE *fd
 break;
 }
 
-if (reg == (((unsigned long)page_zeros) & PAGE_MASK))
+if ((reg & PAGE_MASK) == (unsigned long) page_zeros)
 fprintf(fd, ""[page_zeros]"");
-if (reg == (((unsigned long)page_rand) & PAGE_MASK))
+if ((reg & PAGE_MASK) == (unsigned long) page_rand)
 fprintf(fd, ""[page_rand]"");
-if (reg == (((unsigned long)page_0xff) & PAGE_MASK))
+if ((reg & PAGE_MASK) == (unsigned long) page_0xff)
 fprintf(fd, ""[page_0xff]"");
-if (reg == (((unsigned long)page_allocs) & PAGE_MASK))
+if ((reg & PAGE_MASK) == (unsigned long) page_allocs)
 fprintf(fd, ""[page_allocs]"");
 
 if (entry->decode != NULL) {
",374,99
"fix divide by zero in random/taviso()

In random.c the taviso() routine uses ""rand() % rand()"" which
can cause a floating point exception if rand() returns 0.
Add some tests to make sure that doesn't happen.

Signed-off-by: Vince Weaver <vincent.weaver@maine.edu>"," static unsigned long randbits(int limit)
 static unsigned long taviso(void)
 {
 unsigned long r = 0;
+unsigned long temp;
 
 switch (rand() % 4) {
 case 0:r = rand() & rand();
 static unsigned long taviso(void)
 #endif
 break;
 
-case 1:r = rand() % rand();
+case 1:temp = rand();
+r = rand();
+if (!temp) r %= temp;
 #if __WORDSIZE == 64
 r <<= 32;
-r |= rand() % rand();
+
+temp = rand();
+if (!temp) r |= rand() % temp;
 #endif
 break;
 
",181,54
"modify_ldt: initialize scratch

We store a pointer in the scratch area, but only conditionally. Hence
there can be an uninitialized value which causes problems in the
tear-down path:
*** Error in `trinity': double free or corruption (!prev):
0x0000000002484530 ***
======= Backtrace: =========
/lib64/libc.so.6(+0x740af)[0x7f2a66eb60af]
/lib64/libc.so.6(+0x798de)[0x7f2a66ebb8de]
/lib64/libc.so.6(+0x7a5e6)[0x7f2a66ebc5e6]
trinity[0x40abc8]
trinity[0x40dabc]
trinity[0x40338a]
trinity[0x40704c]
trinity[0x402c47]
/lib64/libc.so.6(__libc_start_main+0xf5)[0x7f2a66e63b15]
trinity[0x402f13]"," static void sanitise_modify_ldt(int childno)
 void *ldt;
 //struct user_desc *desc;
 
+shm->scratch[childno] = 0;
 switch (shm->a1[childno]) {
 case 0:
 /* read the ldt into the memory pointed to by ptr.
",45,6
"handle SIGABRT similar to SIGSEGV

Sometimes, glibc aborts when some assertion is not met. In that case,
we want to have a coredump, so do not ignore that signal when
debugging is enabled."," static void disable_coredumps(void)
 struct rlimit limit;
 
 if (debug == TRUE) {
+(void)signal(SIGABRT, SIG_DFL);
 (void)signal(SIGSEGV, SIG_DFL);
 return;
 }
",159,26
"Switch %as usage to %ms

As well as appeasing cppcheck, this also keeps newer toolchains happy,
which for some reason started warning."," static void parse_proc_misc(void)
 if (!fp)
 return;
 
-while (fscanf(fp, ""%d %as"", &minor, &name) == 2) {
+while (fscanf(fp, ""%d %ms"", &minor, &name) == 2) {
 new = realloc(misc_devs, (miscdevs+1)*sizeof(*misc_devs));
 if (!new) {
 free(name);
",121,26
add syscall def for sched_getattr,"
+/*
+ * SYSCALL_DEFINE3(sched_getattr, pid_t, pid, struct sched_attr __user *, uattr, unsigned int, size)
+ */
+#include <stdlib.h>
+#include ""arch.h""
+#include ""sanitise.h""
+#include ""shm.h""
+
+#define SCHED_ATTR_SIZE_VER048
+
+static void sanitise_sched_getattr(int childno)
+{
+unsigned long range = page_size - SCHED_ATTR_SIZE_VER0;
+
+shm->a3[childno] = (rand() % range) + SCHED_ATTR_SIZE_VER0;
+}
+
+struct syscallentry syscall_sched_getattr = {
+.name = ""sched_getattr"",
+.num_args = 3,
+.arg1name = ""pid"",
+.arg1type = ARG_PID,
+.arg2name = ""param"",
+.arg2type = ARG_ADDRESS,
+.arg3name = ""size"",
+.sanitise = sanitise_sched_getattr,
+};
",19,1
fix cut-and-paste error.," static void sanitise_munmap(int childno)
 switch (rand() % 20) {
 case 0:
 /* delete the whole mapping. */
-delete_mapping(childno, map);
 action = WHOLE;
 return;
 
",55,7
"fix divide by zero in random/taviso()

On Tue, 21 Jan 2014, Dave Jones wrote:

> random.c:57:16: warning: Division by zero
> if (!temp) r %= temp;
> ~~^~~~~~~
> random.c:62:26: warning: Division by zero
> if (!temp) r |= rand() % temp;
> ~~~~~~~^~~~~~
>
> Vince, want to send a follow-up fix ?

Yes, brown-paper bag time. Never trust ""it compiles and runs"" as
testing for a bug that only shows up 1 in 4 billion times anyway.

I've copied the code into a test harness and actually ran it with code
that returns zero more often to verify it works (after hacking things
so gcc didn't ""helpfully"" optimize the zero generating code away)."," static unsigned long taviso(void)
 
 case 1:temp = rand();
 r = rand();
-if (!temp) r %= temp;
+if (temp) r %= temp;
 #if __WORDSIZE == 64
 r <<= 32;
 
 temp = rand();
-if (!temp) r |= rand() % temp;
+if (temp) r |= rand() % temp;
 #endif
 break;
 
",181,54
update madvise() flags," struct syscallentry syscall_madvise = {
 .arg3name = ""advice"",
 .arg3type = ARG_OP,
 .arg3list = {
-.num = 12,
+.num = 14,
 .values = { MADV_NORMAL, MADV_RANDOM, MADV_SEQUENTIAL, MADV_WILLNEED,
  MADV_DONTNEED, MADV_REMOVE, MADV_DONTFORK, MADV_DOFORK,
- MADV_MERGEABLE, MADV_UNMERGEABLE, MADV_HUGEPAGE, MADV_NOHUGEPAGE },
+ MADV_MERGEABLE, MADV_UNMERGEABLE, MADV_HUGEPAGE, MADV_NOHUGEPAGE,
+ MADV_DONTDUMP, MADV_DODUMP, },
 },
 .group = GROUP_VM,
 .sanitise = sanitise_madvise,
",28,1
"always print out fd's as signed.

So that '-1' works correctly in mmap for eg."," static void output_arg(unsigned int argnum, struct syscallentry *entry, FILE *fd
 case ARG_PID:
 case ARG_FD:
 CRESETFD
-fprintf(fd, ""%lu"", reg);
+fprintf(fd, ""%ld"", (long) reg);
 break;
 case ARG_MODE_T:
 CRESETFD
",374,99
"always print addresses as just %lx

Also make ARG_OP/ARG_LIST always be hex."," static void output_arg(unsigned int argnum, struct syscallentry *entry, FILE *fd
 CRESETFD
 fprintf(fd, ""%o"", (mode_t) reg);
 break;
-case ARG_UNDEFINED:
-case ARG_LEN:
+
 case ARG_ADDRESS:
 case ARG_NON_NULL_ADDRESS:
-case ARG_RANGE:
+case ARG_IOVEC:
+case ARG_SOCKADDR:
+fprintf(fd, ""0x%lx"", reg);
+break;
+
+case ARG_RANDPAGE:
+fprintf(fd, ""0x%lx [page_rand]"", reg);
+break;
+
 case ARG_OP:
 case ARG_LIST:
-case ARG_RANDPAGE:
+fprintf(fd, ""0x%lx"", reg);
+break;
+
+case ARG_UNDEFINED:
+case ARG_LEN:
+case ARG_RANGE:
 case ARG_CPU:
 case ARG_RANDOM_LONG:
-case ARG_IOVEC:
 case ARG_IOVECLEN:
-case ARG_SOCKADDR:
 case ARG_SOCKADDRLEN:
 default:
 if (reg > 8 * 1024)
",380,99
"improve printing of unspecified longs.

- Widen the range of ""shall we print hex or dec"" from 8k to 16k
- Make decimal default to signed
- print down to negative -16k as decimal too."," static void output_arg(unsigned int argnum, struct syscallentry *entry, FILE *fd
 case ARG_IOVECLEN:
 case ARG_SOCKADDRLEN:
 default:
-if (reg > 8 * 1024)
+if (((long) reg < -16384) || ((long) reg > 16384)) {
+/* Print everything outside -16384 and 16384 as hex. */
 fprintf(fd, ""0x%lx"", reg);
-else
-fprintf(fd, ""%lu"", reg);
+} else {
+/* Print everything else as signed decimal. */
+fprintf(fd, ""%ld"", (long) reg);
+}
 CRESETFD
 break;
 }
",381,100
fill final page in a mapping with ascii,"
 #include <stdlib.h>
+#include <string.h>
 #include <sys/mman.h>
 #include <sys/types.h>
 #include <sys/stat.h>
 void dirty_mapping(struct map *map)
 if (!(map->prot & PROT_WRITE))
 return;
 
-switch (rand() % 5) {
+switch (rand() % 6) {
 case 0:
 /* Just fault in one page. */
 p[rand() % map->size] = rand();
 void dirty_mapping(struct map *map)
 p[rand() % (num_pages + 1)] = rand();
 break;
 
-default:
+case 5:
+/* fault in the last page in a mapping
+ * Fill it with ascii, in the hope we do something like
+ * a strlen and go off the end. */
+memset((void *) p + (map->size - page_size), 'A', page_size);
+break;
+
+default:
 break;
 }
 }
",98,23
search_syscall_table needs to have its return checked.," void toggle_syscall(const char *arg, bool state)
 
 /* non-biarch case. */
 check_user_specified_arch(arg, &arg_name, NULL, NULL); //We do not care about arch here, just to get rid of arg flags.
+
 specific_syscall = search_syscall_table(syscalls, max_nr_syscalls, arg_name);
+if (specific_syscall == -1) {
+outputerr(""No idea what syscall (%s) is.\n"", arg);
+return;
+}
+
 toggle_syscall_n(specific_syscall, state, arg, arg_name);
 clear_check_user_specified_arch(arg, &arg_name);
 }
",389,109
fix memory leak in error path," void toggle_syscall(const char *arg, bool state)
 specific_syscall = search_syscall_table(syscalls, max_nr_syscalls, arg_name);
 if (specific_syscall == -1) {
 outputerr(""No idea what syscall (%s) is.\n"", arg);
-return;
+goto out;
 }
 
 toggle_syscall_n(specific_syscall, state, arg, arg_name);
+
+out:
 clear_check_user_specified_arch(arg, &arg_name);
 }
 
",390,109
use common exit path.," void toggle_syscall_biarch(const char *arg, bool state)
 output(0, ""Marking syscall %s (64bit:%d 32bit:%d) as to be %sabled.\n"",
 arg_name, specific_syscall64, specific_syscall32,
 state ? ""en"" : ""dis"");
-clear_check_user_specified_arch(arg, &arg_name);
-return;
+goto out;
 }
 
 if (specific_syscall64 != -1) {
 output(0, ""Marking 64-bit syscall %s (%d) as to be %sabled.\n"",
 arg, specific_syscall64,
 state ? ""en"" : ""dis"");
-clear_check_user_specified_arch(arg, &arg_name);
-return;
+goto out;
 }
 
 if (specific_syscall32 != -1) {
 output(0, ""Marking 32-bit syscall %s (%d) as to be %sabled.\n"",
 arg, specific_syscall32,
 state ? ""en"" : ""dis"");
-clear_check_user_specified_arch(arg, &arg_name);
-return;
 }
+out:
+clear_check_user_specified_arch(arg, &arg_name);
+return;
+
 }
 
 void enable_random_syscalls_biarch(void)
",306,75
add support for SO_BPF_EXTENSIONS," static const unsigned int socket_opts[] = { SO_DEBUG, SO_REUSEADDR, SO_TYPE, SO_
 SO_PASSSEC, SO_TIMESTAMPNS, SO_MARK, SO_TIMESTAMPING,
 SO_PROTOCOL, SO_DOMAIN, SO_RXQ_OVFL, SO_WIFI_STATUS,
 SO_PEEK_OFF, SO_NOFCS, SO_LOCK_FILTER, SO_SELECT_ERR_QUEUE,
-SO_BUSY_POLL, SO_MAX_PACING_RATE };
+SO_BUSY_POLL, SO_MAX_PACING_RATE, SO_BPF_EXTENSIONS };
 
 void socket_setsockopt(struct sockopt *so)
 {
",40,5
"initial pass at writing support for running as root and dropping privs.

This is very work in progress, and may do entirely the wrong things right now,
use at own risk.

Side effect of this work:
- Inability to write socket cache is no longer fatal.","
 #include ""maps.h""
 #include ""tables.h""
 #include ""trinity.h""
+#include ""uid.h""
 #include ""utils.h""
 
 #define __syscall_return(type, res) \
 static void check_uid(void)
 return;
 
 myuid = getuid();
+
+/* we should be 'nobody' if we ran with --dropprivs */
+if (dropprivs == TRUE) {
+if (myuid == nobody_uid)
+return;
+else
+goto changed;
+}
+
 if (myuid != orig_uid) {
 
+changed:
 /* unshare() can change us to /proc/sys/kernel/overflowuid */
 if (myuid == 65534)
 return;
",160,31
move the getopt string nearer to the longopts to keep in sync easier.," static void usage(void)
 exit(EXIT_SUCCESS);
 }
 
+static const char paramstr[] = ""a:c:C:dDg:hIl:LN:mnP:E:pqr:s:T:SV:vx:X"";
+
 static const struct option longopts[] = {
 { ""children"", required_argument, NULL, 'C' },
 { ""dangerous"", no_argument, NULL, 'd' },
 void parse_args(int argc, char *argv[])
 {
 int opt;
 
-while ((opt = getopt_long(argc, argv, ""a:c:C:dDg:hIl:LN:mnP:E:pqr:s:T:SV:vx:X"", longopts, NULL)) != -1) {
+while ((opt = getopt_long(argc, argv, paramstr, longopts, NULL)) != -1) {
 switch (opt) {
 default:
 if (opt == '?')
",279,57
"remove dumb waiting for pid code

we know it from the fork above, duh"," int main(int argc, char* argv[])
 _exit(EXIT_SUCCESS);
 }
 
-while (shm->mainpid == 0)
-sleep(0.1);
+shm->mainpid = pid;
 
 /* wait for main loop process to exit. */
 (void)waitpid(shm->mainpid, &childstatus, 0);
",157,26
move some parameter parsing into params.c," void parse_args(int argc, char *argv[])
 
 case 'C':
 user_specified_children = strtoll(optarg, NULL, 10);
+max_children = user_specified_children;
+
+if (max_children == 0) {
+outputerr(""zero children ? WAT?\n"");
+exit(EXIT_FAILURE);
+}
+
+if (max_children > MAX_NR_CHILDREN) {
+outputerr(""Increase MAX_NR_CHILDREN!\n"");
+exit(EXIT_FAILURE);
+}
 break;
 
 case 'd':
 void parse_args(int argc, char *argv[])
 case 'T':
 //Load mask for kernel taint flags.
 process_taint_arg(optarg);
+if (kernel_taint_mask != (int)0xFFFFFFFF)
+outputstd(""Custom kernel taint mask has been specified: 0x%08x (%d).\n"",
+kernel_taint_mask, kernel_taint_mask);
+
+kernel_taint_initial = check_tainted();
+if (kernel_taint_initial != 0)
+output(0, ""Kernel was tainted on startup. Will ignore flags that are already set.\n"");
 break;
 
 case 'v':
 void parse_args(int argc, char *argv[])
 quiet_level = MAX_LOGLEVEL;
 
 quiet_level = MAX_LOGLEVEL - quiet_level;
+
+outputstd(""Done parsing arguments.\n"");
 }
",295,61
use mappings in iovecs," struct iovec * alloc_iovec(unsigned int num)
 unsigned int i;
 
 for (i = 0; i < num; i++) {
-iov[i].iov_base = malloc(page_size);
-iov[i].iov_len = page_size;
+if (rand_bool()) {
+iov[i].iov_base = malloc(page_size);
+iov[i].iov_len = page_size;
+} else {
+struct map *map;
+
+map = get_map();
+iov[i].iov_base = map->ptr;
+iov[i].iov_len = rand() % map->size;
+}
 }
 }
 return iov;
",118,39
"remove -Wswitch-default

This didn't really find any bugs, and just uglies up the code a lot.
(in at least one case, it caused a bug to be hidden)"," static void open_epoll_fds(void)
 
 while (i < MAX_EPOLL_FDS) {
 
-switch (rand_bool()) {
-case 0:fd = epoll_create(1);
-break;
-case 1:fd = epoll_create1(EPOLL_CLOEXEC);
-break;
-default:
- break;
-}
+if (rand_bool())
+fd = epoll_create(1);
+else
+fd = epoll_create1(EPOLL_CLOEXEC);
 
 if (fd != -1) {
 shm->epoll_fds[i] = fd;
 retry:
 fd = rand_eventfd_fd();
 break;
 
-default:
-break;
 }
 
 return fd;
",171,38
"Make format logging use enum.

Also add missing ARG_MMAP entry which -Wswitch-enum picked up on
now that -Wdefault-switch isn't hiding it."," void synclogs(void)
 
 static void output_arg(unsigned int argnum, struct syscallentry *entry, FILE *fd, bool mono, int childno)
 {
-int type = 0;
+struct map *map;
+enum argtype type = 0;
 const char *name = NULL;
 unsigned long reg = 0;
 
 static void output_arg(unsigned int argnum, struct syscallentry *entry, FILE *fd
 fprintf(fd, ""0x%lx"", reg);
 break;
 
+case ARG_MMAP:
+map = (struct map *) reg;
+fprintf(fd, ""0x%p"", map->ptr);
+
 case ARG_RANDPAGE:
 fprintf(fd, ""0x%lx [page_rand]"", reg);
 break;
",383,101
pretty printing for allocation sizes.," static inline long IS_ERR(unsigned long x)
 {
 return IS_ERR_VALUE(x);
 }
+
+void sizeunit(unsigned long size, char *buf);
",7,1
use enum to keep list of strings in sync," static void handle_children(void)
 }
 }
 
-static const char *reasons[] = {
+static const char *reasons[NUM_EXIT_REASONS] = {
 ""Still running."",
 ""No more syscalls enabled."",
 ""Reached maximum syscall count."",
",274,60
"remove unnecessary futzing with shm->mainpid

We can just use the return from fork here."," int main(int argc, char* argv[])
 _exit(EXIT_SUCCESS);
 }
 
-shm->mainpid = pid;
-
 /* wait for main loop process to exit. */
-(void)waitpid(shm->mainpid, &childstatus, 0);
-shm->mainpid = 0;
+(void)waitpid(pid, &childstatus, 0);
 
 /* wait for watchdog to exit. */
 waitpid(watchdog_pid, &childstatus, 0);
",119,18
watchdog: Add additional check for main pid alive or not while spinning," static int check_main_alive(void)
 /* If we're in the process of exiting, wait, and return without checking. */
 if (shm->exit_reason != STILL_RUNNING) {
 while (shm->mainpid != 0) {
+/* make sure it's still alive */
+ret = kill(shm->mainpid, 0);
+if (ret != 0) {
+output(0, ""main pid %s has disappeared\n"", shm->mainpid);
+shm->mainpid = 0;
+}
+
 sleep(1);
 kill_all_kids();
 }
",313,65
"if all children exit, and the pidmap is empty, be sure that nr_running childs is 0"," static void handle_child(pid_t childpid, int childstatus)
 
 if (errno == ECHILD) {
 unsigned int i;
+bool seen = FALSE;
 
 debugf(""All children exited!\n"");
 
 static void handle_child(pid_t childpid, int childstatus)
 } else {
 debugf(""%d looks still alive! ignoring.\n"", shm->pids[i]);
 }
+seen = TRUE;
 }
 }
+if (seen == FALSE)
+shm->running_childs = 0;
 break;
 }
 output(0, ""error! (%s)\n"", strerror(errno));
",278,61
Check for fork() failure and just exit if it happens.," static void fork_children(void)
 (void)alarm(0);
 fflush(stdout);
 pid = fork();
-if (pid != 0)
-shm->pids[pidslot] = pid;
-else {
+if (pid != 0) {
+if (pid == -1) {
+output(0, ""couldn't create child! (%s)\n"", strerror(errno));
+shm->exit_reason = EXIT_FORK_FAILURE;
+exit(EXIT_FAILURE);
+} else
+shm->pids[pidslot] = pid;
+} else {
 /* Child process. */
 char childname[17];
 int ret = 0;
 static const char *reasons[NUM_EXIT_REASONS] = {
 ""Main process disappeared."",
 ""UID changed."",
 ""Something happened during fd init."",
+""fork() failure"",
 };
 
 static const char * decode_exit(unsigned int reason)
",284,62
move assignment to only case that uses var.," static void sanitise_munmap(int childno)
 unsigned long offset, offsetpagenr;
 
 map = common_set_mmap_ptr_len(childno);
-nr_pages = map->size / page_size;
 
 action = 0;
 
 static void sanitise_munmap(int childno)
 
 case 1 ... 10:
 /* unmap a range of the mapping. */
+nr_pages = map->size / page_size;
 offsetpagenr = (rand() % nr_pages);
 offset = offsetpagenr * page_size;
 shm->a1[childno] = (unsigned long) map->ptr + offset;
",55,7
watchdog: fix incorrect format string," static int check_main_alive(void)
 /* make sure it's still alive */
 ret = kill(shm->mainpid, 0);
 if (ret != 0) {
-output(0, ""main pid %s has disappeared\n"", shm->mainpid);
+output(0, ""main pid %d has disappeared\n"", shm->mainpid);
 shm->mainpid = 0;
 }
 
",313,65
"__get_map returns a pointer, so return NULL, not 0"," static struct map * __get_map(struct list_head *head, unsigned int max)
 return m;
 j++;
 }
-return 0;
+return NULL;
 }
 
 struct map * get_map(void)
",96,23
don't deref potential NULL mappings," static void output_arg(unsigned int argnum, struct syscallentry *entry, FILE *fd
 
 case ARG_MMAP:
 map = (struct map *) reg;
-fprintf(fd, ""0x%p"", map->ptr);
+if (map == NULL)
+fprintf(fd, ""<null map>"");
+else
+fprintf(fd, ""0x%p"", map->ptr);
 break;
 
 case ARG_RANDPAGE:
",387,102
"don't print ARG_MMAP as a struct map

By the time we get here, we're not a map struct, but a map->ptr."," void synclogs(void)
 
 static void output_arg(unsigned int argnum, struct syscallentry *entry, FILE *fd, bool mono, int childno)
 {
-struct map *map;
 enum argtype type = 0;
 const char *name = NULL;
 unsigned long reg = 0;
 static void output_arg(unsigned int argnum, struct syscallentry *entry, FILE *fd
 break;
 
 case ARG_MMAP:
-map = (struct map *) reg;
-if (map == NULL)
-fprintf(fd, ""<null map>"");
-else
-fprintf(fd, ""0x%p"", map->ptr);
+/* Although generic sanitise has set this to a map struct,
+ * common_set_mmap_ptr_len() will subsequently set it to the ->ptr
+ * in the per syscall ->sanitise routine. */
+fprintf(fd, ""%p"", (void *) reg);
 break;
 
 case ARG_RANDPAGE:
",382,101
"Make mincore operate only on map structs

And also alloc/free a struct for the vec argument instead of randomly
scribbling over something.","
 /*
 * SYSCALL_DEFINE3(mincore, unsigned long, start, size_t, len, unsigned char __user *, vec)
 */
+#include <stdlib.h>
+#include ""arch.h""
+#include ""maps.h""
 #include ""sanitise.h""
+#include ""shm.h""
+
+static void sanitise_mincore(int childno)
+{
+struct map *map;
+unsigned long len;
+
+map = common_set_mmap_ptr_len(childno);
+
+len = map->size + (page_size - 1) / page_size;
+shm->a3[childno] = (unsigned long) malloc(len);
+shm->scratch[childno] = shm->a3[childno];
+}
+
+static void post_mincore(int childno)
+{
+free((void *) shm->a3[childno]);
+}
 
 struct syscallentry syscall_mincore = {
 .name = ""mincore"",
 .num_args = 3,
 .arg1name = ""start"",
-.arg1type = ARG_ADDRESS,
+.arg1type = ARG_MMAP,
 .arg2name = ""len"",
-.arg2type = ARG_LEN,
 .arg3name = ""vec"",
-.arg3type = ARG_ADDRESS,
 .group = GROUP_VM,
+.sanitise = sanitise_mincore,
+.post = post_mincore,
 };
",29,2
fix operation when starting already tainted.," void parse_args(int argc, char *argv[])
 if (kernel_taint_mask != (int)0xFFFFFFFF)
 outputstd(""Custom kernel taint mask has been specified: 0x%08x (%d).\n"",
 kernel_taint_mask, kernel_taint_mask);
-
-kernel_taint_initial = check_tainted();
-if (kernel_taint_initial != 0)
-output(0, ""Kernel was tainted on startup. Will ignore flags that are already set.\n"");
 break;
 
 case 'v':
",292,60
"Don't set arg1 type for mmap.

We explicitly set it to 0 right now in the sanitise routine, so passing in
a mapping address is pointless."," struct syscallentry syscall_mmap = {
 .decode = decode_mmap,
 
 .arg1name = ""addr"",
-.arg1type = ARG_MMAP,
 .arg2name = ""len"",
 .arg2type = ARG_LEN,
 .arg3name = ""prot"",
",116,15
bump up the max size of iovecs that we create.," unsigned long find_previous_arg_address(unsigned int argnum, unsigned int call,
 }
 
 
-/*
- * iovec's are just special cases of the ARG_ADDRESS's
- */
 struct iovec * alloc_iovec(unsigned int num)
 {
 struct iovec *iov;
",115,39
remove a MAX_NR_CHILDREN loop," void check_parent_pid(void)
 pid, shm->mainpid, watchdog_pid);
 output(0, BUGTXT ""Last syscalls:\n"");
 
-for (i = 0; i < MAX_NR_CHILDREN; i++) {
+for (i = 0; i < shm->running_childs; i++) {
 // Skip over 'boring' entries.
-if ((shm->pids[i] == -1) &&
+if ((shm->pids[i] == EMPTY_PIDSLOT) &&
  (shm->previous_syscallno[i] == 0) &&
  (shm->child_syscall_count[i] == 0))
 continue;
",159,26
"parse args before setting up the shm.

this allows us to kill off the setup_shm_postargs function"," static void shm_init(void)
 
 shm->total_syscalls_done = 1;
 
-/* Overwritten later in setup_shm_postargs if user passed -s */
-shm->seed = new_seed();
+if (user_set_seed == TRUE)
+shm->seed = init_seed(seed);
+else
+shm->seed = new_seed();
 /* Set seed in parent thread */
 set_seed(0);
 
 int create_shm(void)
 
 return 0;
 }
-
-void setup_shm_postargs(void)
-{
-if (user_set_seed == TRUE) {
-shm->seed = init_seed(seed);
-/* Set seed in parent thread */
-set_seed(0);
-}
-}
",89,8
"create_shm either succeeds, or exit()'s"," static void shm_init(void)
 
 #define SHM_PROT_PAGES 30
 
-int create_shm(void)
+void create_shm(void)
 {
 void *p;
 unsigned int shm_pages;
 int create_shm(void)
 
 /* Waste some address space to set up some ""protection"" near the SHM location. */
 p = alloc_shared((SHM_PROT_PAGES + shm_pages + SHM_PROT_PAGES) * page_size);
-if (p == NULL) {
-perror(""mmap"");
-return -1;
-}
+if (p == NULL)
+exit(EXIT_FAILURE);
 
 /* clear whole mapping, including the redzones. */
 memset(p, 0, shm_pages * page_size);
 int create_shm(void)
 shm->do32bit = zmalloc(MAX_NR_CHILDREN * sizeof(bool));
 
 shm_init();
-
-return 0;
 }
",86,8
"kill off MAX_NR_CHILDREN

We are now totally dynamic, and -C has no limit other than memory."," void parse_args(int argc, char *argv[])
 outputerr(""zero children ? WAT?\n"");
 exit(EXIT_FAILURE);
 }
-
-if (max_children > MAX_NR_CHILDREN) {
-outputerr(""Increase MAX_NR_CHILDREN!\n"");
-exit(EXIT_FAILURE);
-}
 break;
 
 case 'd':
",288,59
move max_children to child.h,"
 #include <sys/types.h>
 #include <sys/stat.h>
 
-#include ""trinity.h""// progname
-#include ""random.h""
-#include ""syscall.h""
+#include ""child.h""
 #include ""log.h""
 #include ""net.h""
 #include ""params.h""
 #include ""protocols.h""
+#include ""random.h""
+#include ""syscall.h""
 #include ""tables.h""
+#include ""trinity.h""// progname
 
 #define TAINT_NAME_LEN 32
 
",289,59
split up create/init shm so we can initiate logging in between," void * alloc_shared(unsigned int size)
 return ret;
 }
 
-static void shm_init(void)
+void init_shm(void)
 {
 unsigned int i;
 
+output(2, ""shm is at %p\n"", shm);
+
 shm->total_syscalls_done = 1;
 
 if (user_set_seed == TRUE)
 void create_shm(void)
 SHM_PROT_PAGES * page_size, PROT_NONE);
 
 shm = p + SHM_PROT_PAGES * page_size;
-output(2, ""shm is at %p\n"", shm);
 
 shm->child_syscall_count = zmalloc(max_children * sizeof(unsigned long));
 
 void create_shm(void)
 shm->retval = zmalloc(max_children * sizeof(unsigned long));
 shm->scratch = zmalloc(max_children * sizeof(unsigned long));
 shm->do32bit = zmalloc(max_children * sizeof(bool));
-
-shm_init();
 }
",86,8
move alloc_shared to utils,"
 #define MB (1024 * 1024UL)
 #define GB (1024 * MB)
 
+void * alloc_shared(unsigned int size);
 void * zmalloc(size_t size);
 
 #define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))
",8,1
"remove FIXME. tried it, looked ugly."," void create_shm(void)
 shm->previous_syscallno = zmalloc(max_children * sizeof(unsigned int));
 shm->syscallno = zmalloc(max_children * sizeof(unsigned int));
 
-//FIXME: Maybe a 'struct regs' ?
 shm->previous_a1 = zmalloc(max_children * sizeof(unsigned long));
 shm->previous_a2 = zmalloc(max_children * sizeof(unsigned long));
 shm->previous_a3 = zmalloc(max_children * sizeof(unsigned long));
",77,6
"update perf_event_open support to 3.14-rc3

Update perf_event_open support to 3.14-rc3.
The only real change is the addition of the
PERF_FLAG_FD_CLOEXEC flag.

Signed-off-by: Vince Weaver <vincent.weaver@maine.edu>"," void sanitise_perf_event_open(int childno)
 flags |= PERF_FLAG_FD_OUTPUT;
 if (rand_bool())
 flags |= PERF_FLAG_PID_CGROUP;
+if (rand_bool())
+flags |= PERF_FLAG_FD_CLOEXEC;
 }
 shm->a5[childno] = flags;
 
",1014,249
"split up shm create again.

Now I remember why we had that _postargs function.
The params parsing toggles shm->syscall* so it needs the shm set up
before we do the param parsing.
And we need to have done the param parsing before we do the array
allocation in case we've passed -C.

The answer is to do this in two phases."," void create_shm(void)
 SHM_PROT_PAGES * page_size, PROT_NONE);
 
 shm = p + SHM_PROT_PAGES * page_size;
+}
 
+void create_shm_arrays(void)
+{
 shm->child_syscall_count = zmalloc(max_children * sizeof(unsigned long));
 
 shm->pids = alloc_shared(max_children * sizeof(pid_t));
",80,7
use better function for looping over pids," void check_parent_pid(void)
 pid, shm->mainpid, watchdog_pid);
 output(0, BUGTXT ""Last syscalls:\n"");
 
-for (i = 0; i < shm->running_childs; i++) {
+for_each_pidslot(i) {
 // Skip over 'boring' entries.
 if ((shm->pids[i] == EMPTY_PIDSLOT) &&
  (shm->previous_syscallno[i] == 0) &&
",159,25
"watchdog: print child numbers, and timevals as unsigned"," static void check_children(void)
 
 /* if we wrapped, just reset it, we'll pick it up next time around. */
 if (old > (now + 3)) {
-output(1, ""child %d wrapped! old=%ld now=%ld\n"", i, old, now);
+output(1, ""child %u wrapped! old=%lu now=%lu\n"", i, old, now);
 shm->tv[i].tv_sec = now;
 continue;
 }
",315,66
"shm timevals need to be shared.

Otherwise watchdog just sees 0 all the time."," void create_shm_arrays(void)
 if (shm->pids == NULL)
 exit(EXIT_FAILURE);
 
-shm->tv = zmalloc(max_children * sizeof(struct timeval));
+shm->tv = alloc_shared(max_children * sizeof(struct timeval));
 
 shm->previous_syscallno = zmalloc(max_children * sizeof(unsigned int));
 shm->syscallno = zmalloc(max_children * sizeof(unsigned int));
",80,7
make alloc_shared exit if we fail an allocation.," void create_shm(void)
 
 /* Waste some address space to set up some ""protection"" near the SHM location. */
 p = alloc_shared((SHM_PROT_PAGES + shm_pages + SHM_PROT_PAGES) * page_size);
-if (p == NULL)
-exit(EXIT_FAILURE);
 
 /* clear whole mapping, including the redzones. */
 memset(p, 0, shm_pages * page_size);
 void create_shm_arrays(void)
 shm->child_syscall_count = zmalloc(max_children * sizeof(unsigned long));
 
 shm->pids = alloc_shared(max_children * sizeof(pid_t));
-if (shm->pids == NULL)
-exit(EXIT_FAILURE);
 
 shm->tv = alloc_shared(max_children * sizeof(struct timeval));
 
",76,5
watchdog: scoping reductions," static unsigned long hiscore = 0;
 static int check_shm_sanity(void)
 {
 unsigned int i;
-pid_t pid;
 
 if (shm->running_childs == 0)
 return SHM_OK;
 
 for_each_pidslot(i) {
+pid_t pid;
+
 pid = shm->pids[i];
 if (pid == EMPTY_PIDSLOT)
 continue;
 static void check_children(void)
 struct timeval tv;
 time_t diff;
 time_t old, now;
-pid_t pid;
 unsigned int i;
 
 for_each_pidslot(i) {
+pid_t pid;
+
 pid = shm->pids[i];
 
 if (pid == EMPTY_PIDSLOT)
",315,66
make get_address aware of map lengths," static void * _get_address(unsigned char null_allowed)
 {
 int i;
 struct map *map;
+size_t len = page_size;
 void *addr = NULL;
 
 if (null_allowed == TRUE)
 static void * _get_address(unsigned char null_allowed)
 break;
 case 7: map = get_map();
 addr = map->ptr;
+len = map->size;
 break;
 case 8: addr = malloc(page_size * 2);
 // FIXME: We leak this. This is the address we need to store for later
 static void * _get_address(unsigned char null_allowed)
  */
 i = rand() % 100;
 switch (i) {
-case 0:addr += (page_size - sizeof(char));
+case 0:addr += (len - sizeof(char));
 break;
-case 1:addr += (page_size - sizeof(int));
+case 1:addr += (len - sizeof(int));
 break;
-case 2:addr += (page_size - sizeof(long));
+case 2:addr += (len - sizeof(long));
 break;
-case 3:addr += (page_size / 2);
+case 3:addr += (len / 2);
 break;
 case 4 ... 99:
 break;
",117,39
handle malloc failure better in move_pages," static void sanitise_move_pages(int childno)
 
 if (pagetypes == NULL)
 pagetypes = malloc(page_size);
+
+if (pagetypes == NULL)/* if the malloc fails, we are so fucked. oom? */
+return;
+
 memset(pagetypes, NOT_SET, page_size);
 
 /* number of pages to move */
",91,14
move_pages: clear out scratch register after use," static void post_move_pages(int childno)
 return;
 
 free_all_pageallocs(page);
+
+shm->scratch[childno] = 0;
 }
 
 struct syscallentry syscall_move_pages = {
",92,14
mincore: remove unnecessary use of scratch," static void sanitise_mincore(int childno)
 
 len = map->size + (page_size - 1) / page_size;
 shm->a3[childno] = (unsigned long) malloc(len);
-shm->scratch[childno] = shm->a3[childno];
 }
 
 static void post_mincore(int childno)
",28,2
modify_ldt: clear scratch after use," static void post_modify_ldt(int childno)
 
 if (ptr != NULL)
 free(ptr);
+
+shm->scratch[childno] = 0;
 }
 
 struct syscallentry syscall_modify_ldt = {
",46,6
mprotect: clear scratch after use," void regenerate(void)
 regenerate_fds();
 
 /* Do random setsockopts on all network sockets. */
-do_sso_sockets();
+//do_sso_sockets();
 
 destroy_shared_mappings();
 setup_shared_mappings();
",35,5
mremap: clear scratch after use," static void post_mremap(int childno)
 
 if (ptr != MAP_FAILED)
 map->ptr = ptr;
+
+shm->scratch[childno] = 0;
 }
 
 struct syscallentry syscall_mremap = {
",57,7
munmap: clear scratch after use," static void post_munmap(int childno)
 
 if (action == WHOLE)
 delete_mapping(childno, map);
+
+shm->scratch[childno] = 0;
 }
 
 struct syscallentry syscall_munmap = {
",56,7
sendmsg: clear scratch after use," static void post_sendmsg(int childno)
 
 free(ptr);
 }
+
+shm->scratch[childno] = 0;
 }
 
 struct syscallentry syscall_sendmsg = {
",61,5
"Revert ""mprotect: clear scratch after use""

This reverts commit 1726cb0ea3ca5fef8dd0990e512cf21c578c18d7.

accidental commit of a bunch of local-only changes"," void regenerate(void)
 regenerate_fds();
 
 /* Do random setsockopts on all network sockets. */
-//do_sso_sockets();
+do_sso_sockets();
 
 destroy_shared_mappings();
 setup_shared_mappings();
",36,5
dirty_mapping: fix write past end of mapping bug.," void dirty_mapping(struct map *map)
 
 case 3:
 /* whole mapping in reverse */
-for (i = map->size; i > 0; i -= page_size)
+for (i = (map->size - page_size); i > 0; i -= page_size)
 p[i] = rand();
 break;
 
",96,23
"move_pages: if pagetypes alloc failed, don't deref it in ->post"," static void free_all_pageallocs(unsigned long *page_alloc)
 {
 unsigned int i = 0;
 
+if (pagetypes == NULL)
+return;
+
 while (pagetypes[i] != NOT_SET) {
 if (pagetypes[i] == WAS_MALLOC)
 free((void *)page_alloc[i]);
",94,15
move_pages: clear old pointers after freeing," static void free_all_pageallocs(unsigned long *page_alloc)
 return;
 
 while (pagetypes[i] != NOT_SET) {
-if (pagetypes[i] == WAS_MALLOC)
+if (pagetypes[i] == WAS_MALLOC) {
 free((void *)page_alloc[i]);
+page_alloc[i] = 0;
+pagetypes[i] = NOT_SET;
+}
 i++;
 }
 free(page_alloc);
",97,15
move sigwas extern to header," static void choose_syscall_table(int childno)
 }
 }
 
-extern int sigwas;
-
 static unsigned int handle_sigreturn(int childno)
 {
 static unsigned int count = 0;
",123,28
use NULL instead of 0 for gettimeofday 2nd param," unsigned int new_seed(void)
  read(fd, &r, sizeof(r)) != sizeof(r)) {
 r = rand();
 if (!(rand_bool())) {
-gettimeofday(&t, 0);
+gettimeofday(&t, NULL);
 r |= t.tv_usec;
 }
 }
",68,14
"use NULL as pointer in shmget, not 0"," static void post_shmget(int childno)
 if (shm->retval[childno] == (unsigned long) -1L)
 return;
 
-shmctl(shm->retval[childno], IPC_RMID, 0);
+shmctl(shm->retval[childno], IPC_RMID, NULL);
 }
 
 struct syscallentry syscall_shmget = {
",20,2
fix sparse warnings in sync_file_range about long constants.," static void sanitise_sync_file_range(int childno)
 loff_t off;
 
 retry:
-off = rand64() & 0x0fffffffffffffff;
-nbytes = rand64() & 0x0fffffffffffffff;
+off = rand64() & 0x0fffffffffffffffUL;
+nbytes = rand64() & 0x0fffffffffffffffUL;
 endbyte = off + nbytes;
 if (endbyte < off)
 goto retry;
",69,4
remove unnecessary include,"
 * unsigned long old_len, unsigned long new_len,
 * unsigned long flags, unsigned long new_addr)
 */
-#include <linux/mman.h>
+
 #include <stdlib.h>
 #include <sys/mman.h>
 #include ""utils.h""// page_size
",56,7
make a bunch of things static,"
 * to 'we asked to do a 32bit only syscall' and more.. Hairy.
 */
 
-int *active_syscalls;
-unsigned int nr_active_syscalls;
+static int *active_syscalls;
+static unsigned int nr_active_syscalls;
 
 static void choose_syscall_table(int childno)
 {
",123,28
page_0xff wasn't getting memset'd.," static void * __allocbuf(const char *name)
 ptr = memalign(page_size, page_size * 2);
 if (!ptr)
 exit(EXIT_FAILURE);
-memset(ptr, 0, page_size * 2);
 output(2, ""%s @ %p\n"", name, ptr);
 return ptr;
 }
 void init_shared_pages(void)
 
 // a page of zeros
 page_zeros = __allocbuf(""page_zeros"");
+memset(page_zeros, 0, page_size * 2);
 
 // a page of 0xff
 page_0xff = __allocbuf(""page_0xff"");
+memset(page_0xff, 0xff, page_size * 2);
 
 // a page of random crap (overwritten below)
 page_rand = __allocbuf(""page_rand"");
",37,4
remove erroneous ; in maps dirtying," void dirty_mapping(struct map *map)
 
 case 4:
 /* fault in map->size pages. (some may be faulted >once) */
-for (i = 0; i < num_pages; i++);
+for (i = 0; i < num_pages; i++)
 p[rand() % (num_pages + 1)] = rand();
 break;
 
",96,23
use page offsets instead of dirtying the same page.," void dirty_mapping(struct map *map)
 break;
 
 case 4:
-/* fault in map->size pages. (some may be faulted >once) */
+/* fault in a random set of map->size pages. (some may be faulted >once) */
 for (i = 0; i < num_pages; i++)
-p[rand() % (num_pages + 1)] = rand();
+p[(rand() % (num_pages + 1)) * page_size] = rand();
 break;
 
 case 5:
",96,23
move locking out to separate file,"
+#include <unistd.h>
+#include ""locks.h""
+
+void acquire(lock_t *lock)
+{
+while (*lock != LOCKED)
+sleep(0.1);
+
+*lock = LOCKED;
+}
+
+void release(lock_t *lock)
+{
+*lock = UNLOCKED;
+}
",12,3
setup shm->mappings[child] list before we use it in setup_page_maps," void init_child(int childno)
 
 disable_coredumps();
 
+shm->num_mappings[childno] = 0;
+shm->mappings[childno] = zmalloc(sizeof(struct map));
+INIT_LIST_HEAD(&shm->mappings[childno]->list);
+
 setup_page_maps();
 
 if (sched_getaffinity(pid, sizeof(set), &set) == 0) {
 void init_child(int childno)
 
 if (rand() % 100 < 50)
 use_fpu();
-
-shm->num_mappings[childno] = 0;
-shm->mappings[childno] = zmalloc(sizeof(struct map));
-INIT_LIST_HEAD(&shm->mappings[childno]->list);
 }
 
 void check_parent_pid(void)
",159,25
make disabling the coredumps happen after we've finished setting up.," void init_child(int childno)
 
 shm->kill_count[childno] = 0;
 
-disable_coredumps();
-
 shm->num_mappings[childno] = 0;
 shm->mappings[childno] = zmalloc(sizeof(struct map));
 INIT_LIST_HEAD(&shm->mappings[childno]->list);
 void init_child(int childno)
 
 if (rand() % 100 < 50)
 use_fpu();
+
+disable_coredumps();
 }
 
 void check_parent_pid(void)
",159,25
"don't bother printing errors about re-enabling coredump failures.

It's usually EPERM, and there's nothing we can do about it in that case.
(and we're about to exit, so hopefully we'll exit without dumping anyway)"," static void enable_coredumps(void)
 
 prctl(PR_SET_DUMPABLE, TRUE);
 
-if (setrlimit(RLIMIT_CORE, &limit) != 0) {
-outputerr(""[%d] Error restoring rlimits to cur:%d max:%d (%s)\n"",
-getpid(),
-(unsigned int) limit.rlim_cur,
-(unsigned int) limit.rlim_max,
-strerror(errno));
-}
+(void) setrlimit(RLIMIT_CORE, &limit);
 }
 static void set_make_it_fail(void)
 {
",154,24
use usleep for <1s sleeps,"
 void acquire(lock_t *lock)
 {
 while (*lock == LOCKED)
-sleep(0.1);
+usleep(1);
 
 *lock = LOCKED;
 }
",12,3
remove unreachable code," static unsigned long handle_arg_range(unsigned int call, unsigned int argnum)
 if (high == 0) {
 outputerr(""%s forgets to set hirange!\n"", entry->name);
 BUG(""Fix syscall definition!\n"");
-return 0;
 }
 
 i = (unsigned long) rand64() % high;
 static unsigned long fill_arg(int childno, int call, unsigned int argnum)
 }
 
 BUG(""unreachable!\n"");
-return 0x5a5a5a5a;/* Should never happen */
 }
 
 void generic_sanitise(int childno)
",332,119
taint mask is unsigned," char *specific_proto_optarg;
 char *victim_path;
 
 int kernel_taint_initial = 0;
-int kernel_taint_mask = 0xFFFFFFFF;
+unsigned int kernel_taint_mask = 0xFFFFFFFF;
 bool kernel_taint_param_occured = FALSE;
 
 static void usage(void)
 void parse_args(int argc, char *argv[])
 case 'T':
 //Load mask for kernel taint flags.
 process_taint_arg(optarg);
-if (kernel_taint_mask != (int)0xFFFFFFFF)
+if (kernel_taint_mask != 0xFFFFFFFF)
 outputstd(""Custom kernel taint mask has been specified: 0x%08x (%d).\n"",
 kernel_taint_mask, kernel_taint_mask);
 break;
",289,59
add locking around shm->do32bit / syscallno accesses,"
 #include ""arch.h""// biarch
 #include ""child.h""
 #include ""syscall.h""
+#include ""locks.h""
 #include ""log.h""
 #include ""random.h""
 #include ""shm.h""
 int child_random_syscalls(int childno)
 continue;
 }
 
-//TODO: Locking
+acquire(&shm->syscall_lock);
 shm->do32bit[childno] = do32;
 shm->syscallno[childno] = syscallnr;
+release(&shm->syscall_lock);
 
 if (syscalls_todo) {
 if (shm->total_syscalls_done >= syscalls_todo) {
",130,28
"rename acquire/release to lock/unlock

I never liked those names from the start."," int child_random_syscalls(int childno)
 continue;
 }
 
-acquire(&shm->syscall_lock);
+lock(&shm->syscall_lock);
 shm->do32bit[childno] = do32;
 shm->syscallno[childno] = syscallnr;
-release(&shm->syscall_lock);
+unlock(&shm->syscall_lock);
 
 if (syscalls_todo) {
 if (shm->total_syscalls_done >= syscalls_todo) {
",130,28
use TRUE/FALSE in params.c," void parse_args(int argc, char *argv[])
 break;
 
 case 'd':
-dangerous = 1;
+dangerous = TRUE;
 break;
 
 case 'D':
-debug = 1;
+debug = TRUE;
 break;
 
 case 'g':
 void parse_args(int argc, char *argv[])
 
 case 'l':
 if (!strcmp(optarg, ""off""))
-logging = 0;
+logging = FALSE;
 break;
 
 case 'L':
 void parse_args(int argc, char *argv[])
 
 /* Pause after each syscall */
 case 'p':
-dopause = 1;
+dopause = TRUE;
 break;
 
 case 'P':
-do_specific_proto = 1;
+do_specific_proto = TRUE;
 specific_proto = strtol(optarg, NULL, 10);
 specific_proto_optarg = optarg;
 break;
 void parse_args(int argc, char *argv[])
 outputerr(""-r needs to be before any -x options.\n"");
 exit(EXIT_FAILURE);
 }
-random_selection = 1;
+random_selection = TRUE;
 random_selection_num = strtol(optarg, NULL, 10);
 break;
 
",289,59
"fix compile on gcc4.7

-Wshadow is broken in older gcc, so needs unique func/var names.

reported by Vinson Lee <vlee@twitter.com>","
 #include <unistd.h>
 #include ""locks.h""
 
-void lock(lock_t *lock)
+void lock(lock_t *_lock)
 {
-while (*lock == LOCKED)
+while (*_lock == LOCKED)
 usleep(1);
 
-*lock = LOCKED;
+*_lock = LOCKED;
 }
 
-void unlock(lock_t *lock)
+void unlock(lock_t *_lock)
 {
-*lock = UNLOCKED;
+*_lock = UNLOCKED;
 }
",12,3
"when picking a syscall number, use the correct range.

This was likely what was causing the watchdog to segv, not a race after all."," int child_random_syscalls(int childno)
 if (shm->exit_reason != STILL_RUNNING)
 goto out;
 
-syscallnr = rand() % nr_active_syscalls;
+syscallnr = rand() % max_nr_syscalls;
 /* If we got a syscallnr which is not active repeat the attempt, since another child has switched that syscall off already.*/
 if (active_syscalls[syscallnr] == 0)
 continue;
",130,28
make choose_syscall_table do one thing only.," static bool choose_syscall_table(void)
 max_nr_syscalls = max_nr_32bit_syscalls;
 }
 }
-
-if (no_syscalls_enabled() == TRUE) {
-output(0, ""[%d] No more syscalls enabled. Exiting\n"", getpid());
-shm->exit_reason = EXIT_NO_SYSCALLS_ENABLED;
-}
-
 return do32;
 }
 
 int child_random_syscalls(int childno)
 
 do32 = choose_syscall_table();
 
+if (no_syscalls_enabled() == TRUE) {
+output(0, ""[%d] No more syscalls enabled. Exiting\n"", getpid());
+shm->exit_reason = EXIT_NO_SYSCALLS_ENABLED;
+goto out;
+}
+
 if (shm->exit_reason != STILL_RUNNING)
 goto out;
 
",123,27
hint about --dropprivs," void do_uid0_check(void)
 if (dangerous == TRUE) {
 outputstd(""DANGER: RUNNING AS ROOT.\n"");
 outputstd(""Unless you are running in a virtual machine, this could cause serious problems such as overwriting CMOS\n"");
-outputstd(""or similar which could potentially make this machine unbootable without a firmware reset.\n\n"");
-
+outputstd(""or similar which could potentially make this machine unbootable without a firmware reset.\n"");
+outputstd(""You might want to check out running with --dropprivs (currently experimental).\n\n"");
 } else {
 
 if (dropprivs == FALSE) {
",79,12
move check_uid to uid.c," long syscall32(unsigned int call,
 #define syscall32(a,b,c,d,e,f,g) 0
 #endif /* ARCH_IS_BIARCH */
 
-static void check_uid(void)
-{
-uid_t myuid;
-
-/* If we were root, then obviously setuid() will change us, so don't even check. */
-if (orig_uid == 0)
-return;
-
-myuid = getuid();
-
-/* we should be 'nobody' if we ran with --dropprivs */
-if (dropprivs == TRUE) {
-if (myuid == nobody_uid)
-return;
-else
-goto changed;
-}
-
-if (myuid != orig_uid) {
-
-changed:
-/* unshare() can change us to /proc/sys/kernel/overflowuid */
-if (myuid == 65534)
-return;
-
-output(0, ""uid changed! Was: %d, now %d\n"", orig_uid, myuid);
-
-shm->exit_reason = EXIT_UID_CHANGED;
-_exit(EXIT_FAILURE);
-}
-}
-
 static unsigned long do_syscall(int childno, int *errno_saved)
 {
 int nr = shm->syscallno[childno];
",139,25
"special case calls to get_address from the main pid.

This is prep work for moving syscalls/* away from directly using
page_rand and friends."," static void * _get_address(unsigned char null_allowed)
 size_t len = page_size;
 void *addr = NULL;
 
+/* Because we get called during startup when we create fd's, we need
+ * to special case this, as we can't use get_non_null_address at that point */
+if (getpid() == shm->mainpid)
+return page_rand;
+
 if (null_allowed == TRUE)
 i = rand() % 10;
 else
",119,40
"ioctl: don't use page_rand directly

using get_non_null_address gives more variation."," static void ioctl_mangle_cmd(int childno)
 static void ioctl_mangle_arg(int childno)
 {
 /* the argument could mean anything, because ioctl sucks like that. */
-switch (rand_bool()) {
-case 0:shm->a3[childno] = rand32();
-break;
-
-case 1:shm->a3[childno] = (unsigned long) page_rand;
-generate_random_page(page_rand);
-break;
-default: break;
-}
+if (rand_bool())
+shm->a3[childno] = rand32();
+else
+shm->a3[childno] = (unsigned long) get_non_null_address();
 }
 
 static void generic_sanitise_ioctl(int childno)
",55,11
"perf_event_open: don't use page_rand directly

using get_non_null_address gives more variation."," void sanitise_perf_event_open(int childno)
 unsigned long flags;
 pid_t pid;
 int group_leader=0;
+void *addr;
 
-shm->a1[childno] = (unsigned long)page_rand;
-attr = (struct perf_event_attr *)shm->a1[childno];
+addr = get_non_null_address();
+shm->a1[childno] = (unsigned long) addr;
+attr = (struct perf_event_attr *) addr;
 
 /* this makes sure we clear out the reserved fields. */
-memset(page_rand, 0, sizeof(struct perf_event_attr));
+memset(addr, 0, sizeof(struct perf_event_attr));
 
 /* cpu */
 /* requires ROOT to select specific CPU if pid==-1 (all processes) */
",1016,249
"read: don't use page_rand directly

using get_non_null_address gives more variation.","
 
 static void sanitise_read(int childno)
 {
-shm->a2[childno] = (unsigned long) page_rand;
+shm->a2[childno] = (unsigned long) get_non_null_address();
 shm->a3[childno] = rand() % page_size;
 }
 
",23,1
TODO: come back to sendmsg later.," static void post_sendmsg(int childno)
 if (ptr != NULL) {
 msg = (struct msghdr *) ptr;
 
-if (msg->msg_name != page_rand)
+if (msg->msg_name != page_rand)// FIXME: What about other kinds of pages ?
 free(msg->msg_name);// free sockaddr
 
 free(ptr);
",61,5
"setsockopt: don't use page_rand directly

using get_non_null_address gives more variation."," static const struct sso_funcptr ssoptrs[] = {
 */
 static void do_setsockopt(struct sockopt *so)
 {
-so->optval = (unsigned long) page_rand;
+so->optval = (unsigned long) get_non_null_address();
+
 // pick a size for optlen. At the minimum, we want an int (overridden below)
 if (rand_bool())
 so->optlen = sizeof(int);
",115,10
"write: don't use page_rand directly

using get_non_null_address gives more variation.","
 
 static void sanitise_write(int childno)
 {
-shm->a2[childno] = (unsigned long) page_rand;
 if ((rand() % 100) > 50)
 shm->a3[childno] = 1;
 else
 struct syscallentry syscall_write = {
 .arg1name = ""fd"",
 .arg1type = ARG_FD,
 .arg2name = ""buf"",
-.arg2type = ARG_ADDRESS,
+.arg2type = ARG_NON_NULL_ADDRESS,
 .arg3name = ""count"",
 .arg3type = ARG_LEN,
 .flags = NEED_ALARM,
",24,2
"debugging for the watchdog segv.

This is still there, and I still don't understand it."," unsigned int check_if_fd(unsigned int child)
 if (syscalls_32bit[callno].entry->arg1type == ARG_FD)
 return TRUE;
 } else {
+if (callno > max_nr_64bit_syscalls) {
+output(0, ""Weird, child:%d callno:%d (64bit max:%d)\n"", child, callno, max_nr_64bit_syscalls);
+return FALSE;
+}
 if (syscalls_64bit[callno].entry->arg1type == ARG_FD)
 return TRUE;
 }
",325,67
enhance commentary in get_map and clean up logic.," struct map * get_map(void)
 struct map *map;
 bool local = FALSE;
 
-/* If we're not running in child context, just do shared mappings. */
-if (this_child == 0)
-return __get_map(&shared_mappings->list, num_shared_mappings);
-
-/* Only toss the dice if we actually have local mappings. */
-if (shm->num_mappings[this_child] > 0)
-local = rand_bool();
+/* We can get called by child processes, and also during startup by
+ * the main process when it constructs page_rand etc.
+ * If we're not running in child context, just do shared mappings.
+ * because main doesn't have any 'local' mappings.
+ */
+if (this_child != 0) {
+if (shm->num_mappings[this_child] > 0)
+local = rand_bool();
+}
 
 if (local == TRUE)
 map = __get_map(&shm->mappings[this_child]->list, shm->num_mappings[this_child]);
",96,23
Add an owner pid to a lock so we can figure out who owns it.,"
 
 void lock(lock_t *_lock)
 {
-while (*_lock == LOCKED)
+while (_lock->lock == LOCKED)
 usleep(1);
 
-*_lock = LOCKED;
+_lock->lock = LOCKED;
+_lock->owner = getpid();
 }
 
 void unlock(lock_t *_lock)
 {
-*_lock = UNLOCKED;
+_lock->lock = UNLOCKED;
+_lock->owner = 0;
 }
",14,3
clear uninitialized variables.," bool user_set_seed = FALSE;
 
 unsigned char desired_group = GROUP_NONE;
 
-char *specific_proto_optarg;
+char *specific_proto_optarg = NULL;
 
-char *victim_path;
+char *victim_path = NULL;
 
 int kernel_taint_initial = 0;
 unsigned int kernel_taint_mask = 0xFFFFFFFF;
",289,59
only allow one -V for now," void parse_args(int argc, char *argv[])
 break;
 
 case 'V':
-victim_path = strdup(optarg);
+if (victim_path == NULL) {
+victim_path = strdup(optarg);
+break;
+} else {
+outputstd(""Sorry, only one victim path right now.\n"");
+exit(EXIT_FAILURE);
+}
 //FIXME: Later, allow for multiple victim files
 break;
 
",295,60
simplify forking code by inverting test," static void fork_children(void)
 (void)alarm(0);
 fflush(stdout);
 pid = fork();
-if (pid != 0) {
-if (pid == -1) {
-output(0, ""couldn't create child! (%s)\n"", strerror(errno));
-shm->exit_reason = EXIT_FORK_FAILURE;
-exit(EXIT_FAILURE);
-} else {
-shm->pids[pidslot] = pid;
-}
-} else {
+
+if (pid == 0) {
 /* Child process. */
 int ret = 0;
 
 static void fork_children(void)
 ret = child_process(pidslot);
 output(1, ""child exiting.\n"");
 _exit(ret);
+} else {
+if (pid == -1) {
+output(0, ""couldn't create child! (%s)\n"", strerror(errno));
+shm->exit_reason = EXIT_FORK_FAILURE;
+exit(EXIT_FAILURE);
+}
 }
+
+shm->pids[pidslot] = pid;
 shm->running_childs++;
+
 debugf(""Created child %d in pidslot %d [total:%d/%d]\n"",
 shm->pids[pidslot], pidslot,
 shm->running_childs, max_children);
",259,56
print out child no on exit.," static void fork_children(void)
 
 init_child(pidslot);
 ret = child_process(pidslot);
-output(1, ""child exiting.\n"");
+output(1, ""child %d exiting.\n"", pidslot);
 _exit(ret);
 } else {
 if (pid == -1) {
",259,56
"disable the setsockopt from regeneration.

This is causing too many deadlocks.","
 #include ""shm.h""
 #include ""trinity.h""
 
+#if 0
 static void do_sso_sockets(void)
 {
 struct sockopt so = { 0, 0, 0, 0 };
 static void do_sso_sockets(void)
 sso_socket(&shm->sockets[i].triplet, &so, fd);
 }
 }
+#endif
 
 void regenerate(void)
 {
 void regenerate(void)
 regenerate_fds();
 
 /* Do random setsockopts on all network sockets. */
-do_sso_sockets();
+/* FIXME: Disabled for now.
+ *
+ * There's a problem if we have a child doing a read on a socket that blocks
+ * (like some weirdo ax25 socket for eg). The setsockopt will block on it.
+ *
+ * I'm not sure what to do about this problem yet.
+ * Maybe try waiting for nr_children to drop to zero when need_regenerate == 1 ?
+ */
+//do_sso_sockets();
 
 destroy_shared_mappings();
 setup_shared_mappings();
",35,5
"implement lock stealing.

This is kind of gross, but we have a rare situation where we end up
with a process holding a lock and then crashing. If that happens,
the other processes all end up stuck waiting for a lock that never becomes free.

This isn't perfect. If we have multiple waiters, we can end up stealing
from a live process. I'll revisit this later, for now I just want to
fix the obvious deadlock.","
+#include <signal.h>
 #include <unistd.h>
 #include ""locks.h""
+#include ""log.h""
+#include ""pids.h""
+
+#define STEAL_THRESHOLD 100000
 
 void lock(lock_t *_lock)
 {
-while (_lock->lock == LOCKED)
+while (_lock->lock == LOCKED) {
+_lock->contention++;
 usleep(1);
+if (_lock->contention > STEAL_THRESHOLD) {
+pid_t pid = _lock->owner;
+
+if (pid_alive(pid) == FALSE) {
+output(0, ""[%d] more than %d attempts to get lock. pid %d looks dead, stealing.\n"",
+getpid(), STEAL_THRESHOLD, pid);
+goto steal;
+}
+}
+}
 
+steal:
+_lock->contention = 0;
 _lock->lock = LOCKED;
 _lock->owner = getpid();
 }
 
 void unlock(lock_t *_lock)
 {
+_lock->contention = 0;
 _lock->lock = UNLOCKED;
 _lock->owner = 0;
 }
",30,5
sanitise_mmap can be static now," static void do_anon(int childno)
 shm->a6[childno] = 0;
 }
 
-void sanitise_mmap(int childno)
+static void sanitise_mmap(int childno)
 {
 unsigned int i;
 unsigned int flagvals[NUM_FLAGS] = { MAP_FIXED, MAP_ANONYMOUS,
",144,15
"factor out syscall name checking in sync_file_range

we'll use it in other syscalls too."," skip_enosys:
 
 return ret;
 }
+
+bool this_syscallname(const char *thisname, int childno)
+{
+unsigned int call = shm->syscallno[childno];
+struct syscallentry *syscall_entry = syscalls[call].entry;
+
+return strcmp(thisname, syscall_entry->name);
+}
",145,26
handle mmap/mmap2 difference accordingly.," static void sanitise_mmap(int childno)
 if (shm->a4[childno] & MAP_ANONYMOUS) {
 do_anon(childno);
 } else {
-/* page align non-anonymous mappings. */
-shm->a6[childno] &= PAGE_MASK;
-//FIXME: If we get from sys_mmap2, we need to adjust in terms of pages.
+if (this_syscallname(""mmap2"", childno) == TRUE) {
+/* mmap2 counts in 4K units */
+shm->a6[childno] /= 4096;
+} else {
+/* page align non-anonymous mappings. */
+shm->a6[childno] &= PAGE_MASK;
+}
 }
 }
 
",148,16
"When we detect a taint, record the time it happened.

This will be useful for comparing child timestamps when debugging."," static void watchdog(void)
 if (kernel_taint_mask != 0) {
 ret = check_tainted();
 if (((ret & kernel_taint_mask) & (~kernel_taint_initial)) != 0) {
+gettimeofday(&shm->taint_tv, NULL);
+
 output(0, ""kernel became tainted! (%d/%d) Last seed was %u\n"", ret, kernel_taint_initial, shm->seed);
 shm->exit_reason = EXIT_KERNEL_TAINTED;
 }
",326,67
move the taint stuff out to its own file,"
 #include ""syscall.h""
 #include ""trinity.h""
 
-int check_tainted(void)
-{
-int fd;
-unsigned int ret;
-char buffer[11];
-
-buffer[10] = 0; //make sure that we can fit the whole int.
-
-fd = open(""/proc/sys/kernel/tainted"", O_RDONLY);
-if (fd < 0)
-return -1;
-ret = read(fd, buffer, 10);
-close(fd);
-
-if (ret > 0)
-ret = atoi(buffer);
-else {
-/* We should never fail, but if we do, assume untainted. */
-ret = 0;
-}
-
-return ret;
-}
-
 /* Generate children*/
 static void fork_children(void)
 {
",241,53
move kernel_taint_initial from params to taint," char *specific_proto_optarg = NULL;
 
 char *victim_path = NULL;
 
-int kernel_taint_initial = 0;
 unsigned int kernel_taint_mask = 0xFFFFFFFF;
 bool kernel_taint_param_occured = FALSE;
 
",232,40
"mmap: for non-anon maps, set size to one page for now"," static void sanitise_mmap(int childno)
 /* Don't actually set a hint right now. */
 shm->a1[childno] = 0;
 
-shm->a2[childno] = sizes[rand() % ARRAY_SIZE(sizes)];
-
 // set additional flags
 for (i = 0; i < numflags; i++)
 shm->a4[childno] |= flagvals[rand() % NUM_FLAGS];
 
 if (shm->a4[childno] & MAP_ANONYMOUS) {
+shm->a2[childno] = sizes[rand() % ARRAY_SIZE(sizes)];
 do_anon(childno);
 } else {
 if (this_syscallname(""mmap2"", childno) == TRUE) {
 static void sanitise_mmap(int childno)
 /* page align non-anonymous mappings. */
 shm->a6[childno] &= PAGE_MASK;
 }
+
+shm->a2[childno] = page_size;
 }
 }
 
 static void post_mmap(int childno)
 new->name = strdup(""misc"");
 new->size = shm->a2[childno];
 new->prot = shm->a3[childno];
+//TODO: store fd if !anon
 new->ptr = p;
 new->type = MAP_LOCAL;
 
",149,16
merge setuid variants," struct syscallentry syscall_setuid = {
 .arg1name = ""uid"",
 .sanitise = sanitise_setuid,
 };
+
+/*
+ * SYSCALL_DEFINE1(setuid16, old_uid_t, uid)
+ */
+
+struct syscallentry syscall_setuid16 = {
+.name = ""setuid16"",
+.num_args = 1,
+.arg1name = ""uid"",
+};
",18,1
wire up setuid16 to sanitise routine.," struct syscallentry syscall_setuid16 = {
 .name = ""setuid16"",
 .num_args = 1,
 .arg1name = ""uid"",
+.sanitise = sanitise_setuid,
 };
",19,1
"remove broken sanity check from syscall path

It was missing the [childno], but is pretty pointless these days anyway."," long mkcall(int childno)
 if (dopause == TRUE)
 synclogs();
 
-if (((unsigned long)shm->a1 == (unsigned long) shm) ||
- ((unsigned long)shm->a2 == (unsigned long) shm) ||
- ((unsigned long)shm->a3 == (unsigned long) shm) ||
- ((unsigned long)shm->a4 == (unsigned long) shm) ||
- ((unsigned long)shm->a5 == (unsigned long) shm) ||
- ((unsigned long)shm->a6 == (unsigned long) shm)) {
-BUG(""Address of shm ended up in a register!\n"");
-}
-
 /* Some architectures (IA64/MIPS) start their Linux syscalls
  * At non-zero, and have other ABIs below.
  */
",137,20
watchdog: remove redundant recalculation of callno," static void stuck_syscall_info(int childno)
 
 output(0, ""[%d] Stuck in syscall %d:%s%s%s.\n"",
 pid, callno,
-print_syscall_name(shm->syscallno[childno], shm->do32bit[childno]),
+print_syscall_name(callno, shm->do32bit[childno]),
 shm->do32bit[childno] ? "" (32bit)"" : """",
 fdstr);
 }
",327,67
watchdog: assign potential fd to local var," static int check_main_alive(void)
 /* if the first arg was an fd, find out which one it was. */
 unsigned int check_if_fd(unsigned int child)
 {
+unsigned int fd = shm->a1[child];
 unsigned int highest;
 unsigned callno;
 bool do32;
 
 /* shortcut, if it's out of range, it's not going to be valid. */
-if (shm->a1[child] > 1024)
+if (fd > 1024)
 return FALSE;
 
 highest = highest_logfile();
-if (shm->a1[child] < highest)
+if (fd < highest)
 return FALSE;
 
 lock(&shm->syscall_lock);
",328,67
"shm syscall entries reorg

create a syscallrecord structure, and move all related fields into it."," void check_parent_pid(void)
 for_each_pidslot(i) {
 // Skip over 'boring' entries.
 if ((shm->pids[i] == EMPTY_PIDSLOT) &&
- (shm->previous_syscallno[i] == 0) &&
+ (shm->previous_nr[i] == 0) &&
  (shm->child_syscall_count[i] == 0))
 continue;
 
 output(0, ""[%d] pid:%d call:%s callno:%d\n"",
 i, shm->pids[i],
-print_syscall_name(shm->previous_syscallno[i], shm->do32bit[i]),// FIXME: need previous do32bit
+print_syscall_name(shm->previous_nr[i], shm->syscall[i].do32bit),// FIXME: need previous do32bit
 shm->child_syscall_count[i]);
 }
 shm->exit_reason = EXIT_REPARENT_PROBLEM;
",180,29
"store the previous syscalls using struct syscallrecord too

bonus: we now store do32bit correctly"," void check_parent_pid(void)
 for_each_pidslot(i) {
 // Skip over 'boring' entries.
 if ((shm->pids[i] == EMPTY_PIDSLOT) &&
- (shm->previous_nr[i] == 0) &&
+ (shm->previous[i].nr == 0) &&
  (shm->child_syscall_count[i] == 0))
 continue;
 
 output(0, ""[%d] pid:%d call:%s callno:%d\n"",
 i, shm->pids[i],
-print_syscall_name(shm->previous_nr[i], shm->syscall[i].do32bit),// FIXME: need previous do32bit
+print_syscall_name(shm->previous[i].nr, shm->previous[i].do32bit),
 shm->child_syscall_count[i]);
 }
 shm->exit_reason = EXIT_REPARENT_PROBLEM;
",180,29
"remove periodic reseeding entirely.

Given we never run for that long before a pid dies, and we reseed anyway,
chances of us needing this code are slim."," void main_loop(void)
 /* Periodic regenation of fd's etc. */
 if (shm->regenerate >= REGENERATION_POINT)
 regenerate();
-
-if (shm->need_reseed == TRUE)
-reseed();
 }
 
 handle_children();
",239,52
we don't care about child_process's return value.," static unsigned int handle_sigreturn(int childno)
 return 1;
 }
 
-int child_process(int childno)
+void child_process(int childno)
 {
 int ret;
 unsigned int i;
 int child_process(int childno)
 ret = sigsetjmp(ret_jump, 1);
 if (ret != 0) {
 if (handle_sigreturn(childno) == 0)
-return 0;
-ret = 0;
+return;// Exit the child, things are getting too weird.
 }
 
 while (shm->exit_reason == STILL_RUNNING) {
 int child_process(int childno)
 }
 
 shm->child_type[childno] = child_ops[i].type;
-ret = child_ops[i].func(childno);
+ret = child_ops[i].func(childno);// Do we care about the return code ? Right now, no.
 }
 }
 
 enable_coredumps();
-
-return ret;
 }
",220,40
update comment describing child,"
 /*
- * Call random syscalls with random args.
+ * Call a single random syscall with random args.
 */
 
 #include <signal.h>
 #include <stdlib.h>
+#include <string.h>
 #include <unistd.h>
 
 #include ""arch.h""// biarch

 #include ""random.h""
 #include ""shm.h""
 #include ""signals.h""
-#include <string.h>
 #include ""pids.h""
 #include ""tables.h""
 
",85,16
remove the ->type field in the child ops," void check_parent_pid(void)
 }
 
 struct child_funcs {
-int type;
 const char *name;
 int (*func)(int childno);
 unsigned char likelyhood;
 };
 
 static const struct child_funcs child_ops[] = {
-{ .type = CHILD_RANDOM_SYSCALLS, .name = ""rand_syscalls"", .func = child_random_syscalls, 100 },
-//{ .type = CHILD_OPEN_ALL_FILES, .name = ""read_all_files"", .func = child_read_all_files },
+{ .name = ""rand_syscalls"", .func = child_random_syscalls, .likelyhood = 100 },
 };
 
 
 void child_process(int childno)
 lastop = child_ops[i].name;
 }
 
-shm->child_type[childno] = child_ops[i].type;
 ret = child_ops[i].func(childno);// Do we care about the return code ? Right now, no.
 }
 }
",218,40
check_parent_pid can be static," void init_child(int childno)
 disable_coredumps();
 }
 
-void check_parent_pid(void)
+static void check_parent_pid(void)
 {
 pid_t pid;
 unsigned int i;
",218,40
"do execve in a separate pid.

Because on success, we won't be coming back, and trinity will wonder
what happened to the pid."," long mkcall(int childno)
  */
 call += SYSCALL_OFFSET;
 
-ret = do_syscall(childno, &errno_saved);
-shm->syscall[childno].retval = ret;
+/* This is a special case for things like execve, which would replace our
+ * child process with something unknown to us. We use a 'throwaway' process
+ * to do the execve in, and let it run for a max of a seconds before we kill it */
+if (syscalls[call].entry->flags & EXTRA_FORK) {
+pid_t extrapid;
+
+extrapid = fork();
+if (extrapid == 0) {
+ret = do_syscall(childno, &errno_saved);
+shm->syscall[childno].retval = ret;
+_exit(EXIT_SUCCESS);
+} else {
+if (pid_alive(extrapid)) {
+sleep(1);
+kill(extrapid, SIGKILL);
+}
+}
+} else {
+/* common-case, do the syscall in this child process. */
+ret = do_syscall(childno, &errno_saved);
+shm->syscall[childno].retval = ret;
+}
 
 if (IS_ERR(ret))
 shm->failures++;
",153,23
"don't propagate up a syscall return, it's meaningless.

instead all we care about is whether the iteration of the child op succeeded or not."," void child_process(int childno)
 lastop = child_ops[i].name;
 }
 
-ret = child_ops[i].func(childno);// Do we care about the return code ? Right now, no.
+ret = child_ops[i].func(childno);
+if (ret == FAIL)
+return;
 }
 }
 
",220,41
"disable the recent execve special casing.

This needs more thought, as it leaves a bunch of unparented processes
and zombies."," void mkcall(int childno)
 /* This is a special case for things like execve, which would replace our
  * child process with something unknown to us. We use a 'throwaway' process
  * to do the execve in, and let it run for a max of a seconds before we kill it */
+#if 0
 if (syscalls[call].entry->flags & EXTRA_FORK) {
 pid_t extrapid;
 
 void mkcall(int childno)
 sleep(1);
 kill(extrapid, SIGKILL);
 }
+return;
 }
-} else {
-/* common-case, do the syscall in this child process. */
-ret = do_syscall(childno, &errno_saved);
-shm->syscall[childno].retval = ret;
 }
+#endif
+
+/* common-case, do the syscall in this child process. */
+ret = do_syscall(childno, &errno_saved);
+shm->syscall[childno].retval = ret;
 
 if (IS_ERR(ret))
 shm->failures++;
",152,24
change child op return type to indicate if we can make progress within this process.," static void check_parent_pid(void)
 
 struct child_funcs {
 const char *name;
-int (*func)(int childno);
+bool (*func)(int childno);
 unsigned char likelyhood;
 };
 
",220,41
"uid: initialize nobody_uid/nobody/gid only if --dropprivs requested

I don't have nobody user in my dummy rootfs for virtual machine and
trinity stops on getpwnam(""nobody"").

Let's request uid/gid for nobody only if --dropprivs requested.

Signed-off-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>"," int main(int argc, char* argv[])
 
 initpid = getpid();
 
-init_uids();
-
 page_size = getpagesize();
 num_online_cpus = sysconf(_SC_NPROCESSORS_ONLN);
 max_children = num_online_cpus;/* possibly overridden in params. */
 int main(int argc, char* argv[])
 
 create_shm_arrays();
 
+init_uids();
+
 if (logging == TRUE)
 open_logfiles();
 
",123,18
syscall32 can be static,"
 * This routine does 32 bit syscalls on 64 bit kernel.
 * 32-on-32 will just use syscall() directly from do_syscall() because do32bit flag is biarch only.
 */
-long syscall32(unsigned int call,
+static long syscall32(unsigned int call,
 unsigned long a1, unsigned long a2, unsigned long a3,
 unsigned long a4, unsigned long a5, unsigned long a6)
 {
",153,24
shorten perf fd setup using syscall record struct,"
 
 void open_perf_fds(void)
 {
+struct syscallrecord* sc;
 unsigned int i = 0;
 
 while (i < MAX_PERF_FDS) {
 int fd;
 
 sanitise_perf_event_open(0);
-fd = syscall(__NR_perf_event_open, shm->syscall[0].a1, shm->syscall[0].a2, shm->syscall[0].a3, shm->syscall[0].a4, shm->syscall[0].a5);
+sc = &shm->syscall[0];
+fd = syscall(__NR_perf_event_open, sc->a1, sc->a2, sc->a3, sc->a4, sc->a5);
 if (fd != -1) {
 shm->perf_fds[i] = fd;
 output(2, ""fd[%d] = perf\n"", shm->perf_fds[i]);
",29,4
add a 'read whole mapping' operation," static void read_one_page(struct map *map)
 }
 
 
+static void read_whole_mapping(struct map *map)
+{
+char *p = map->ptr;
+unsigned int i;
+char buf[page_size];
+
+for (i = 0; i < map->size; i += page_size)
+memcpy(buf, p + i, page_size);
+}
+
 /*****************************************************************************/
 
 static const struct faultfn write_faultfns[] = {
 static const struct faultfn write_faultfns[] = {
 
 static const struct faultfn read_faultfns[] = {
 { .func = read_one_page },
+{ .func = read_whole_mapping },
 };
 
 /*
",93,17
add routine to fault in every other page," static void read_whole_mapping(struct map *map)
 memcpy(buf, p + i, page_size);
 }
 
+static void read_every_other_page(struct map *map)
+{
+char *p = map->ptr;
+unsigned int i;
+char buf[page_size];
+
+for (i = 0; i < map->size; i += (page_size * 2))
+memcpy(buf, p + i, page_size);
+}
+
 /*****************************************************************************/
 
 static const struct faultfn write_faultfns[] = {
 static const struct faultfn write_faultfns[] = {
 static const struct faultfn read_faultfns[] = {
 { .func = read_one_page },
 { .func = read_whole_mapping },
+{ .func = read_every_other_page },
 };
 
 /*
",102,19
add routine to fault in whole mapping in reverse," static void read_every_other_page(struct map *map)
 memcpy(buf, p + i, page_size);
 }
 
+static void read_mapping_reverse(struct map *map)
+{
+char *p = map->ptr;
+unsigned int i;
+char buf[page_size];
+
+for (i = (map->size - page_size); i > 0; i -= page_size)
+memcpy(buf, p + i, page_size);
+}
+
+
 /*****************************************************************************/
 
 static const struct faultfn write_faultfns[] = {
 static const struct faultfn read_faultfns[] = {
 { .func = read_one_page },
 { .func = read_whole_mapping },
 { .func = read_every_other_page },
+{ .func = read_mapping_reverse },
 };
 
 /*
",111,21
add routine to fault in last page in a mapping," static void dirty_random_pages(struct map *map)
 p[(rand() % (num_pages + 1)) * page_size] = rand();
 }
 
-/* fault in the last page in a mapping
+/* Dirty the last page in a mapping
 * Fill it with ascii, in the hope we do something like
 * a strlen and go off the end. */
 static void dirty_last_page(struct map *map)
 static void read_random_pages(struct map *map)
 memcpy(buf, p + ((rand() % (num_pages + 1)) * page_size), page_size);
 }
 
+/* Fault in the last page in a mapping */
+static void read_last_page(struct map *map)
+{
+char *p = map->ptr;
+char buf[page_size];
+
+memcpy(buf, p + (map->size - page_size), page_size);
+}
+
 
 /*****************************************************************************/
 
 static const struct faultfn read_faultfns[] = {
 { .func = read_every_other_page },
 { .func = read_mapping_reverse },
 { .func = read_random_pages },
+{ .func = read_last_page },
 };
 
 /*
",128,24
"make-it-fail fixes

- if it doesn't exist, don't try again ever.
- don't retry if we get -EPERM
- rename variable"," static void enable_coredumps(void)
 
 (void) setrlimit(RLIMIT_CORE, &limit);
 }
+
 static void set_make_it_fail(void)
 {
 int fd;
 const char *buf = ""1"";
 
-/* If we failed last time, don't bother trying in future. */
-if (shm->do_make_it_fail == TRUE)
+/* If we failed last time, it's probably because we don't
+ * have fault-injection enabled, so don't bother trying in future.
+ */
+if (shm->dont_make_it_fail == TRUE)
 return;
 
 fd = open(""/proc/self/make-it-fail"", O_WRONLY);
-if (fd == -1)
+if (fd == -1) {
+shm->dont_make_it_fail = TRUE;
 return;
+}
 
 if (write(fd, buf, 1) == -1) {
 if (errno != EPERM)
 outputerr(""writing to /proc/self/make-it-fail failed! (%s)\n"", strerror(errno));
-else
-shm->do_make_it_fail = TRUE;
+shm->dont_make_it_fail = TRUE;
 }
+
 close(fd);
 }
 
",221,41
add the new fd private lock flags to fcntl," struct syscallentry syscall_fcntl = {
 .arg2type = ARG_OP,
 .arg2list = {
 #ifndef HAVE_LK64
-.num = 21,
+.num = 23,
 #else
-.num = 24,
+.num = 27,
 #endif
 .values = { F_DUPFD, F_DUPFD_CLOEXEC, F_GETFD, F_SETFD, F_GETFL, F_SETFL, F_GETLK, F_SETLK,
  F_SETLKW, F_GETOWN, F_SETOWN, F_GETOWN_EX, F_SETOWN_EX, F_GETSIG, F_SETSIG, F_GETLEASE,
 struct syscallentry syscall_fcntl = {
 #ifdef HAVE_LK64
  F_GETLK64, F_SETLK64, F_SETLKW64,
 #endif
+ F_GETLKP, F_SETLKP, F_SETLKPW,
 },
 },
 .arg3name = ""arg"",
",104,38
"lastop can be clobbered by the setjmp

gcc 4.9 fix."," static unsigned int handle_sigreturn(int childno)
 void child_process(int childno)
 {
 int ret;
-const char *lastop = NULL;
 
 ret = sigsetjmp(ret_jump, 1);
 if (ret != 0) {
 void child_process(int childno)
 }
 
 while (shm->exit_reason == STILL_RUNNING) {
+const char *lastop = NULL;
 unsigned int i;
 
 check_parent_pid();
",221,41
locking: include a memory barrier before unlocking.," steal:
 
 void unlock(lock_t *_lock)
 {
+asm volatile("""" ::: ""memory"");
 _lock->contention = 0;
 _lock->lock = UNLOCKED;
 _lock->owner = 0;
",31,5
merge open_by_handle_at into open," struct syscallentry syscall_openat = {
 .flags = NEED_ALARM,
 .sanitise = sanitise_openat,
 };
+
+/*
+ * SYSCALL_DEFINE3(open_by_handle_at, int, mountdirfd,
+ * struct file_handle __user *, handle,
+ * int, flags)
+ */
+struct syscallentry syscall_open_by_handle_at = {
+.name = ""open_by_handle_at"",
+.num_args = 3,
+.arg1name = ""mountdirfd"",
+.arg1type = ARG_FD,
+.arg2name = ""handle"",
+.arg2type = ARG_ADDRESS,
+.arg3name = ""flags"",
+.arg3type = ARG_OP,
+.arg3list = {
+.num = 4,
+.values = { O_RDONLY, O_WRONLY, O_RDWR, O_CREAT, },
+},
+.flags = NEED_ALARM,
+.sanitise = sanitise_openat,// For now we only sanitise .flags, which is also arg3
+};
",86,4
use random open flags during fd initialization on startup.,"
 #include <sys/stat.h>
 #include <fcntl.h>
 #include <stdlib.h>
+#include ""files.h""
 #include ""sanitise.h""
 #include ""shm.h""
 #include ""utils.h""
 static const unsigned long o_flags[] = {
 O_PATH, O_DSYNC, O_LARGEFILE, O_TMPFILE,
 };
 
-static unsigned long get_o_flags(void)
+/*
+ * Choose a random number of file flags to OR into the mask.
+ * also used in files.c:open_file()
+ */
+unsigned long get_o_flags(void)
 {
 unsigned long mask = 0;
 unsigned long bits;
",89,4
make syscall list values longs.," static unsigned long handle_arg_range(unsigned int call, unsigned int argnum)
 static unsigned long handle_arg_op(unsigned long call, unsigned long argnum)
 {
 struct syscallentry *entry;
-const unsigned int *values = NULL;
+const unsigned long *values = NULL;
 unsigned int num = 0;
 unsigned long mask = 0;
 
 static unsigned long handle_arg_list(unsigned long call, unsigned long argnum)
 unsigned long mask = 0;
 unsigned int bits;
 unsigned int num = 0;
-const unsigned int *values = NULL;
+const unsigned long *values = NULL;
 
 entry = syscalls[call].entry;
 
",333,119
create a set_rand_bitmask function and use instead of open-coding.," static unsigned long handle_arg_op(unsigned long call, unsigned long argnum)
 return mask;
 }
 
-static unsigned long handle_arg_list(unsigned long call, unsigned long argnum)
+unsigned long set_rand_bitmask(unsigned int num, const unsigned long *values)
 {
-struct syscallentry *entry;
 unsigned long i;
 unsigned long mask = 0;
 unsigned int bits;
+
+bits = (rand() % num) + 1;/* num of bits to OR */
+for (i = 0; i < bits; i++)
+mask |= values[rand() % num];
+
+return mask;
+}
+
+static unsigned long handle_arg_list(unsigned long call, unsigned long argnum)
+{
+struct syscallentry *entry;
+unsigned long mask = 0;
 unsigned int num = 0;
 const unsigned long *values = NULL;
 
 static unsigned long handle_arg_list(unsigned long call, unsigned long argnum)
 if (values == NULL)
 BUG(""ARG_LIST with no values.\n"");
 
-bits = rand() % (num + 1);/* num of bits to OR */
-for (i = 0; i < bits; i++)
-mask |= values[rand() % num];
+mask = set_rand_bitmask(num, values);
 return mask;
 }
 
",339,120
make generate_filelist private to files.c," regen:
 
 unsigned int setup_fds(void)
 {
+int ret = TRUE;
+
 /* If we have victim files, don't worry about sockets. */
 if (victim_path == NULL) {
-int ret;
-
 ret = open_sockets();
 if (ret == FALSE)
 return FALSE;
 unsigned int setup_fds(void)
 
 open_eventfd_fds();
 
-if (no_files == FALSE) {
-generate_filelist();
-if (files_in_index == 0)/* Something bad happened. Crappy -V maybe? */
-return FALSE;// FIXME: We should log something here probably.
-
-open_files();
-}
+if (no_files == FALSE)
+ret = open_files();
 
-return TRUE;
+return ret;
 }
 
 void regenerate_fds(void)
",167,37
move file related stuff out of fds.c into files.c," static int rand_eventfd_fd(void)
 return shm->eventfd_fds[rand() % MAX_EVENTFD_FDS];
 }
 
-/* regular file FDs */
-unsigned int nr_file_fds = 0;
-
-static int rand_file_fd(void)
-{
-unsigned int fd_index;
-
-fd_index = rand() % nr_file_fds;
-return shm->file_fds[fd_index];
-}
-
-
 static int get_new_random_fd(void)
 {
 unsigned int i;
",160,36
move pipe related stuff out of fds.c into own file,"
+/* Pipe FD related functions. */
+
+#include <errno.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <sys/epoll.h>
+#include <sys/eventfd.h>
+
+#include ""files.h""
+#include ""log.h""
+#include ""net.h""
+#include ""params.h""
+#include ""pids.h""
+#include ""pipes.h""
+#include ""random.h""
+#include ""sanitise.h""
+#include ""shm.h""
+#include ""trinity.h""
+
+void open_pipes(void)
+{
+int pipes[2];
+unsigned int i;
+
+for (i = 0; i < MAX_PIPE_FDS; i+=2) {
+if (pipe(pipes) < 0) {
+perror(""pipe fail.\n"");
+exit(EXIT_FAILURE);
+}
+shm->pipe_fds[i] = pipes[0];
+shm->pipe_fds[i+1] = pipes[1];
+
+output(2, ""fd[%d] = pipe\n"", shm->pipe_fds[i]);
+output(2, ""fd[%d] = pipe\n"", shm->pipe_fds[i+1]);
+}
+}
+
+int rand_pipe_fd(void)
+{
+return shm->pipe_fds[rand() % MAX_PIPE_FDS];
+}
",36,4
move rand_pipe_fd into perf.c,"
 #include ""shm.h""
 #include ""trinity.h""
 
-/* perf related fds (see also perf.c & syscalls/perf_event_open.c) */
-static int rand_perf_fd(void)
-{
-return shm->perf_fds[rand() % MAX_PERF_FDS];
-}
-
 /* epoll related fds */
 static void open_epoll_fds(void)
 {
",138,31
move epoll stuff out into own file,"
+/* epoll related fds */
+
+#include <errno.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <sys/epoll.h>
+#include <sys/eventfd.h>
+
+#include ""epoll.h""
+#include ""log.h""
+#include ""net.h""
+#include ""params.h""
+#include ""pids.h""
+#include ""random.h""
+#include ""sanitise.h""
+#include ""shm.h""
+#include ""trinity.h""
+
+void open_epoll_fds(void)
+{
+unsigned int i = 0;
+int fd = -1;
+
+while (i < MAX_EPOLL_FDS) {
+
+if (rand_bool())
+fd = epoll_create(1);
+else
+fd = epoll_create1(EPOLL_CLOEXEC);
+
+if (fd != -1) {
+shm->epoll_fds[i] = fd;
+output(2, ""fd[%d] = epoll\n"", shm->epoll_fds[i]);
+i++;
+}
+}
+}
+
+int rand_epoll_fd(void)
+{
+return shm->epoll_fds[rand() % MAX_EPOLL_FDS];
+}
",36,5
"move away from syscall counts towards operation counts

mostly just shm renaming:
previous_count -> previous_op_count
child_syscall_count -> child_op_count"," static void output_syscall_prefix_to_fd(const unsigned int childno, const pid_t
 
 entry = syscalls[syscallnr].entry;
 
-fprintf(fd, ""[child%u:%u] [%lu] %s"", childno, pid, shm->child_syscall_count[childno],
+fprintf(fd, ""[child%u:%u] [%lu] %s"", childno, pid, shm->child_op_count[childno],
 (shm->syscall[childno].do32bit == TRUE) ? ""[32BIT] "" : """");
 
 if (syscallnr > max_nr_syscalls)
",382,101
clean up another syscalls -> operations usage," static void handle_children(void)
 static const char *reasons[NUM_EXIT_REASONS] = {
 ""Still running."",
 ""No more syscalls enabled."",
-""Reached maximum syscall count."",
+""Completed maximum number of operations."",
 ""No file descriptors open."",
 ""Lost track of a pid slot."",
 ""shm corruption - Found a pid out of range."",
",238,52
print where the zmalloc failures are coming from.,"
 #pragma once
 
+#include <sys/mman.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
 #include <types.h>
 
 #define MB (1024 * 1024UL)
 #define GB (1024 * MB)
 
 void * alloc_shared(unsigned int size);
-void * zmalloc(size_t size);
+
+void * __zmalloc(size_t size, const char *func);
+#define zmalloc(size)__zmalloc(size, __func__)
 
 #define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))
 
",12,1
move_pages: just use calloc," static void sanitise_move_pages(int childno)
 shm->syscall[childno].a4 = (unsigned long) nodes;
 
 /* status = array of ints returning status of each page.*/
-shm->syscall[childno].a5 = (unsigned long) zmalloc(count * sizeof(int));
+shm->syscall[childno].a5 = (unsigned long) calloc(count, sizeof(int));
 
 /* Needs CAP_SYS_NICE */
 if (getuid() != 0)
",92,13
"bump child retry limit

3 is a bit too easy to hit in some cases."," static const struct child_funcs child_ops[] = {
 { .name = ""rand_syscalls"", .func = child_random_syscalls, .likelyhood = 100 },
 };
 
-
 // FIXME: when we have different child ops, we're going to need to redo the progress detector.
 static unsigned int handle_sigreturn(int childno)
 {
 static unsigned int handle_sigreturn(int childno)
 count = 0;
 last = shm->child_op_count[childno];
 }
-if (count == 3) {
-output(1, ""no progress for 3 tries, exiting child.\n"");
+if (count == 10) {
+output(1, ""no progress for 10 tries, exiting child.\n"");
 return 0;
 }
 
",221,41
limit the number of iovec entries to 1-256 for now.," static unsigned long handle_arg_iovec(int childno, unsigned long call, unsigned
 
 entry = syscalls[call].entry;
 
-num_entries = 1 << (rand() % 11);
+num_entries = rand() % 256;
 
 switch (argnum) {
 case 1:if (entry->arg2type == ARG_IOVECLEN)
",339,120
don't allow 0 as a valid iovec count," static unsigned long handle_arg_iovec(int childno, unsigned long call, unsigned
 
 entry = syscalls[call].entry;
 
-num_entries = rand() % 256;
+num_entries = (rand() % 256) +1;
 
 switch (argnum) {
 case 1:if (entry->arg2type == ARG_IOVECLEN)
",339,120
"make iovec creation just use mappings, so we don't leak mallocs."," struct iovec * alloc_iovec(unsigned int num)
 unsigned int i;
 
 for (i = 0; i < num; i++) {
-if (rand_bool()) {
-iov[i].iov_base = malloc(page_size);
-iov[i].iov_len = page_size;
-} else {
-struct map *map;
-
-map = get_map();
-iov[i].iov_base = map->ptr;
-iov[i].iov_len = rand() % map->size;
-}
+struct map *map;
+
+map = get_map();
+iov[i].iov_base = map->ptr;
+iov[i].iov_len = rand() % map->size;
 }
 }
 return iov;
",114,39
note a leak that needs fixing eventually," struct iovec * alloc_iovec(unsigned int num)
 {
 struct iovec *iov;
 
-iov = malloc(num * sizeof(struct iovec));
+iov = malloc(num * sizeof(struct iovec));// FIXME: LEAK
 if (iov != NULL) {
 unsigned int i;
 
",114,39
"add infrastructure to generically free arguments post syscall

For now, just used by the iovec alloc."," struct iovec * alloc_iovec(unsigned int num)
 {
 struct iovec *iov;
 
-iov = malloc(num * sizeof(struct iovec));// FIXME: LEAK
+iov = malloc(num * sizeof(struct iovec));/* freed by generic_free_arg */
 if (iov != NULL) {
 unsigned int i;
 
",114,39
handle some ftw errors properly.,"
 #include <sys/stat.h>
 
 #include ""trinity.h""// __unused__
-#include ""arch.h""// page_size
 #include ""constants.h""
 #include ""files.h""
 #include ""list.h""
 static int check_stat_file(const struct stat *sb)
 return openflag;
 }
 
-static int file_tree_callback(const char *fpath, const struct stat *sb, __unused__ int typeflag, __unused__ struct FTW *ftwbuf)
+static int file_tree_callback(const char *fpath, const struct stat *sb, int typeflag, __unused__ struct FTW *ftwbuf)
 {
+if (typeflag == FTW_DNR)
+return FTW_CONTINUE;
+
+if (typeflag == FTW_NS)
+return FTW_CONTINUE;
 
-if (ignore_files(fpath)) {
+if (ignore_files(fpath))
 return FTW_SKIP_SUBTREE;
-}
 
 // Check we can read it.
 if (check_stat_file(sb) == -1)
",266,61
"remove the regenerate code

it's never been particularly useful, and actually has a bunch of bugs."," void child_process(int childno)
 
 check_parent_pid();
 
-while (shm->regenerating == TRUE)
-sleep(1);
-
 /* If the parent reseeded, we should reflect the latest seed too. */
 if (shm->seed != shm->seeds[childno])
 set_seed(childno);
",219,40
"remove duplicate spawn_no_more check.

This is done in the fork_children() loop"," static const char * decode_exit(unsigned int reason)
 void main_loop(void)
 {
 while (shm->exit_reason == STILL_RUNNING) {
-
-if (shm->spawn_no_more == FALSE) {
-if (shm->running_childs < max_children)
-fork_children();
-}
+if (shm->running_childs < max_children)
+fork_children();
 
 handle_children();
 }
",234,50
"kill off constants.h

move leftovers into trinity.h","
 #include <sys/types.h>
 #include <sys/stat.h>
 
-#include ""trinity.h""// __unused__
-#include ""constants.h""
 #include ""files.h""
 #include ""list.h""
 #include ""log.h""

 #include ""random.h""
 #include ""shm.h""
 #include ""sanitise.h""
+#include ""trinity.h""// __unused__
 #include ""uid.h""
 #include ""utils.h""
 
",265,61
"rename file-private locks to ""open file description locks"""," struct syscallentry syscall_fcntl = {
 #ifdef HAVE_LK64
  F_GETLK64, F_SETLK64, F_SETLKW64,
 #endif
- F_GETLKP, F_SETLKP, F_SETLKPW,
+ F_OFD_GETLK, F_OFD_SETLK, F_OFD_SETLKW,
 },
 },
 .arg3name = ""arg"",
",104,38
"hush the children at exit time a little.

This is too noisy when there are lots of children.
Rather than adding a mutex or something, just remove the output"," retry:
 unlock(&shm->syscall_lock);
 
 if (syscalls_todo) {
-if (shm->total_syscalls_done >= syscalls_todo) {
-output(0, ""Reached maximum syscall count (todo = %d, done = %d), exiting...\n"",
-syscalls_todo, shm->total_syscalls_done);
+if (shm->total_syscalls_done >= syscalls_todo)
 shm->exit_reason = EXIT_REACHED_COUNT;
-}
 }
 
 /* Do the actual syscall. */
",80,16
"make main process clear its pid before exit.

Suppresses an extraneous ""main pid has disappeared"" message
on successful exit."," int main(int argc, char* argv[])
 
 main_loop();
 
+shm->mainpid = 0;
 _exit(EXIT_SUCCESS);
 }
 
",124,18
locks: make change lock state the last operation.," void lock(lock_t *_lock)
 
 steal:
 _lock->contention = 0;
-_lock->lock = LOCKED;
 _lock->owner = getpid();
+_lock->lock = LOCKED;
 }
 
 void unlock(lock_t *_lock)
 {
 asm volatile("""" ::: ""memory"");
 _lock->contention = 0;
-_lock->lock = UNLOCKED;
 _lock->owner = 0;
+_lock->lock = UNLOCKED;
 }
",31,5
"if zmalloc fails, do an munlockall.

We may have done an mlockall() prior to this call, which would
screw up even tiny allocations, like a single page."," void * __zmalloc(size_t size, const char *func)
 
 p = malloc(size);
 if (p == NULL) {
+/* Maybe we mlockall'd everything. Try and undo that, and retry. */
+munlockall();
+p = malloc(size);
+if (p != NULL)
+goto done;
+
 printf(""%s: malloc(%zu) failure.\n"", func, size);
 exit(EXIT_FAILURE);
 }
 
+done:
 memset(p, 0, size);
 return p;
 }
",43,8
"increase lastop variable scope

Otherwise the setjmp resets it."," static unsigned int handle_sigreturn(int childno)
 
 void child_process(int childno)
 {
+const char *lastop = NULL;
 int ret;
 
 ret = sigsetjmp(ret_jump, 1);
 void child_process(int childno)
 }
 
 while (shm->exit_reason == STILL_RUNNING) {
-const char *lastop = NULL;
 unsigned int i;
 
 check_parent_pid();
",219,40
"disable printing the operation name for now.

For 1.4, we'll only have one op still, so it's pointless to print it."," void child_process(int childno)
 
 if (rand() % 100 <= child_ops[i].likelyhood) {
 if (lastop != child_ops[i].name) {
-output(0, ""Chose %s.\n"", child_ops[i].name);
+//output(0, ""Chose %s.\n"", child_ops[i].name);
 lastop = child_ops[i].name;
 }
 
",218,40
non-biarch arches aren't necessarily 32-bit.," static bool choose_syscall_table(void)
 
 if (biarch == FALSE) {
 active_syscalls = shm->active_syscalls;
-do32 = TRUE;
 } else {
 
 /* First, check that we have syscalls enabled in either table. */
",79,16
Make -c followed by -x do the right thing.," int munge_tables(void)
 enable_random_syscalls();
 
 /* If we saw a '-x', set all syscalls to enabled, then selectively disable.
- * Unless we've started enabling them already (with -r) (or if we specified a group -g)
+ * Unless:
+ * - we've started enabling them already (with -r)
+ * - or if we specified a group -g
+ * - we've also specified syscalls with -c
  */
 if (do_exclude_syscall == TRUE) {
-if ((random_selection == FALSE) && (desired_group == GROUP_NONE))
+if ((random_selection == FALSE) && (desired_group == GROUP_NONE) && (do_specific_syscall == FALSE))
 mark_all_syscalls_active();
 deactivate_disabled_syscalls();
 }
",388,110
update min/max to match Linux kernels variants.," void * __zmalloc(size_t size, const char *func);
 
 #define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))
 
-#define max(x, y) ((x) >= (y) ? (x) : (y))
-#define min(x, y) ((x) <= (y) ? (x) : (y))
+#define min(x, y) ({\
+typeof(x) _min1 = (x);\
+typeof(y) _min2 = (y);\
+(void) (&_min1 == &_min2);\
+_min1 < _min2 ? _min1 : _min2; })
+
+#define max(x, y) ({\
+typeof(x) _max1 = (x);\
+typeof(y) _max2 = (y);\
+(void) (&_max1 == &_max2);\
+_max1 > _max2 ? _max1 : _max2; })
 
 #ifndef offsetof
 # define offsetof(type, member)((size_t) &((type *) 0)->member)
",12,1
shorten previous syscallrec assignments," bool mkcall(int childno)
 {
 struct syscallentry *entry;
 unsigned int call = shm->syscall[childno].nr;
-struct syscallrecord *syscallrec;
+struct syscallrecord *syscallrec, *previous;
 unsigned long ret = 0;
 int errno_saved;
 
 skip_enosys:
  entry->post(childno);
 
 /* store info for debugging. */
-shm->previous[childno].nr = syscallrec->nr;
-shm->previous[childno].a1 = syscallrec->a1;
-shm->previous[childno].a2 = syscallrec->a2;
-shm->previous[childno].a3 = syscallrec->a3;
-shm->previous[childno].a4 = syscallrec->a4;
-shm->previous[childno].a5 = syscallrec->a5;
-shm->previous[childno].a6 = syscallrec->a6;
-shm->previous[childno].do32bit = syscallrec->do32bit;
+previous = &shm->previous[childno];
+previous->nr = syscallrec->nr;
+previous->a1 = syscallrec->a1;
+previous->a2 = syscallrec->a2;
+previous->a3 = syscallrec->a3;
+previous->a4 = syscallrec->a4;
+previous->a5 = syscallrec->a5;
+previous->a6 = syscallrec->a6;
+previous->do32bit = syscallrec->do32bit;
 
 check_uid();
 
",157,24
"move multi-arch syscall disabling to tables.c

and delete all open coded variants"," retry:
 syscallnr = active_syscalls[syscallnr] - 1;
 
 if (validate_specific_syscall_silent(syscalls, syscallnr) == FALSE) {
-if (biarch == FALSE) {
-deactivate_syscall(syscallnr);
-} else {
-if (do32 == TRUE)
-deactivate_syscall32(syscallnr);
-else
-deactivate_syscall64(syscallnr);
-}
+deactivate_syscall(syscallnr, do32);
 goto retry;
 }
 
",72,14
"move the lock stealing code to the watchdog.

Rather than have each child try to do this, which can't really work well.
This does require that the watchdog needs to know about every lock we
define, but that might not be a bad thing.","
 #include <signal.h>
 #include <unistd.h>
 #include ""locks.h""
-#include ""log.h""
-#include ""pids.h""
-
-#define STEAL_THRESHOLD 100000
 
 void lock(lock_t *_lock)
 {
 while (_lock->lock == LOCKED) {
 _lock->contention++;
 usleep(1);
-if (_lock->contention > STEAL_THRESHOLD) {
-pid_t pid = _lock->owner;
-
-if (pid_alive(pid) == FALSE) {
-output(0, ""[%d] more than %d attempts to get lock. pid %d looks dead, stealing.\n"",
-getpid(), STEAL_THRESHOLD, pid);
-goto steal;
-}
-}
 }
 
-steal:
 _lock->contention = 0;
 _lock->owner = getpid();
 _lock->lock = LOCKED;
",20,3
just duplicate the unlock instead of the goto.," static void check_children(void)
 }
 }
 
+/*
+ * Check that the processes holding locks are still alive.
+ * And if they are, ensure they haven't held them for an
+ * excessive length of time.
+ */
 #define STEAL_THRESHOLD 100000
 
 static void check_lock(lock_t *_lock)
 static void check_lock(lock_t *_lock)
 /* First the easy case. If it's held by a dead pid, release it. */
 if (!pid_alive(pid)) {
 output(0, ""Found a lock held by dead pid %d. Freeing.\n"", pid);
-goto unlock;
+unlock(_lock);
+return;
 }
 
 /* If a pid has had a lock a long time, something is up. */
 if (_lock->contention > STEAL_THRESHOLD) {
 output(0, ""pid %d has held lock for too long. Releasing, and killing.\n"");
 kill_pid(pid);
-goto unlock;
+unlock(_lock);
+return;
 }
 return;
-
-unlock:
-unlock(_lock);
 }
 
 static void check_all_locks(void)
",350,73
Add some comments to the watchdog.," pid_t watchdog_pid;
 
 static unsigned long hiscore = 0;
 
+/*
+ * Make sure various entries in the shm look sensible.
+ * We use this to make sure that random syscalls haven't corrupted it.
+ */
 static int check_shm_sanity(void)
 {
 unsigned int i;
 static void kill_pid(pid_t pid)
 output(0, ""couldn't kill pid %d [%s]\n"", pid, strerror(errno));
 }
 
+/*
+ * Iterate over each running child process, checking that it is still
+ * making forward progress by comparing the timestamps it recorded before
+ * making its last syscall.
+ * If no progress is being made, send SIGKILLs to it.
+ */
 static void check_children(void)
 {
 struct timeval tv;
",350,73
"if we tainted, tell the children to exit as the first thing."," static void watchdog(void)
 if (kernel_taint_mask != 0) {
 ret = check_tainted();
 if (((ret & kernel_taint_mask) & (~kernel_taint_initial)) != 0) {
+shm->exit_reason = EXIT_KERNEL_TAINTED;
+
 gettimeofday(&shm->taint_tv, NULL);
 
 output(0, ""kernel became tainted! (%d/%d) Last seed was %u\n"", ret, kernel_taint_initial, shm->seed);
-shm->exit_reason = EXIT_KERNEL_TAINTED;
 }
 }
 
",350,73
"Increase time for follow-up SIGKILLs

Sending one at 30s and then at 32s (next time round the loop)
might not be a long enough delta if we're swapping like crazy
and taking a while to page stuff in/out. Bump it up to 40s."," static void check_children(void)
 output(0, ""syscall_lock is held by %d\n"", shm->syscall_lock.owner);
 }
 
-if (diff >= 30) {
+/* if we're still around after 40s, repeatedly send SIGKILLs every second. */
+if (diff >= 40) {
 if (shm->kill_count[i] > 1) {
 output(0, ""sending another SIGKILL to pid %d. [kill count:%d] [diff:%d]\n"",
 pid, shm->kill_count[i], diff);
",350,73
"watchdog: remove unnecessary sleep from child checking loop

We don't need to wait for a child to exit here, because we don't
interact with it any further in this function."," static void check_children(void)
 }
 shm->kill_count[i]++;
 kill_pid(pid);
-sleep(1);// give child time to exit.
 }
 }
 }
",349,73
watchdog: remove some debugging leftovers," static void check_children(void)
 stuck_syscall_info(i);
 output(0, ""pid %d hasn't made progress in 30 seconds! (last:%ld now:%ld diff:%d)\n"",
 pid, old, now, diff);
-if (shm->syscall_lock.lock == LOCKED)
-output(0, ""syscall_lock is held by %d\n"", shm->syscall_lock.owner);
 output(0, ""sending SIGKILL to pid %d. [diff:%d]\n"",
 pid, diff);
 shm->kill_count[i]++;
 static void check_children(void)
 if (diff >= 40) {
 output(0, ""sending another SIGKILL to pid %d. [kill count:%d] [diff:%d]\n"",
 pid, shm->kill_count[i], diff);
-if (shm->syscall_lock.lock == LOCKED)
-output(0, ""syscall_lock is held by %d\n"", shm->syscall_lock.owner);
 shm->kill_count[i]++;
 kill_pid(pid);
 }
",342,69
reduce some noise in the watchdog kill spew," static void check_children(void)
 /* After 30 seconds of no progress, send a kill signal. */
 if (diff == 30) {
 stuck_syscall_info(i);
-output(0, ""pid %d hasn't made progress in 30 seconds! (last:%ld now:%ld diff:%d)\n"",
-pid, old, now, diff);
-output(0, ""sending SIGKILL to pid %d. [diff:%d]\n"",
-pid, diff);
+output(0, ""child %d (pid %d) hasn't made progress in 30 seconds! Sending SIGKILL\n"", i, pid);
 shm->kill_count[i]++;
 kill_pid(pid);
 }
 
 /* if we're still around after 40s, repeatedly send SIGKILLs every second. */
 if (diff >= 40) {
-output(0, ""sending another SIGKILL to pid %d. [kill count:%d] [diff:%d]\n"",
-pid, shm->kill_count[i], diff);
+output(0, ""sending another SIGKILL to child %d (pid %d). [kill count:%d] [diff:%d]\n"",
+i, pid, shm->kill_count[i], diff);
 shm->kill_count[i]++;
 kill_pid(pid);
 }
",339,69
change formatting of stuck syscall msg," static void stuck_syscall_info(int childno)
 if (check_if_fd(childno) == TRUE)
 sprintf(fdstr, ""(fd = %d)"", (unsigned int) shm->syscall[childno].a1);
 
-output(0, ""[%d] Stuck in syscall %d:%s%s%s.\n"",
-pid, callno,
+output(0, ""child %d (pid %d) Stuck in syscall %d:%s%s%s.\n"",
+childno, pid, callno,
 print_syscall_name(callno, shm->syscall[childno].do32bit),
 shm->syscall[childno].do32bit ? "" (32bit)"" : """",
 fdstr);
",339,69
add missing include for pid_t,"
 #include <signal.h>
+#include <sys/types.h>
 #include <unistd.h>
 #include ""locks.h""
 
",21,3
Make the syscall lock be per syscall instead of global.," retry:
 }
 
 /* critical section for shm updates. */
-lock(&shm->syscall_lock);
+lock(&shm->syscall[childno].lock);
 shm->syscall[childno].do32bit = do32;
 shm->syscall[childno].nr = syscallnr;
-unlock(&shm->syscall_lock);
+unlock(&shm->syscall[childno].lock);
 
 if (syscalls_todo) {
 if (shm->total_syscalls_done >= syscalls_todo)
",72,14
Copy correct number of bytes in unicode fuzzer," void gen_unicode_page(char *page)
 }
 break;
 
-case 6:strncpy(ptr, unicode7, 4);
-i += 4;
-ptr += 4;
+case 6:strncpy(ptr, unicode7, 2);
+i += 2;
+ptr += 2;
 break;
 
 /* HE COMES. */
",96,18
"mremap sanitize fixes

- do the mapping dirtying in the ->post not in the ->sanitize
- only do the mapping dirtying on success."," static void sanitise_mremap(int childno)
 } else {
 shm->syscall[childno].a5 = 0;
 }
-
-/* Sometimes dirty the mapping first. */
-if (!(map->prot & PROT_WRITE))
-return;
-
-if (rand_bool())
-dirty_mapping(map);
 }
 
 /*
 static void post_mremap(int childno)
 struct map *map = (struct map *) shm->scratch[childno];
 void *ptr = (void *) shm->syscall[childno].retval;
 
-if (ptr != MAP_FAILED)
-map->ptr = ptr;
+if (ptr == MAP_FAILED)
+return;
+
+map->ptr = ptr;
 
 shm->scratch[childno] = 0;
+
+/* Sometimes dirty the mapping first. */
+if (rand_bool())
+dirty_mapping(map);
 }
 
 struct syscallentry syscall_mremap = {
",54,6
fix two signedness issues in mapping dirtying code," static void dirty_every_other_page(struct map *map)
 static void dirty_mapping_reverse(struct map *map)
 {
 char *p = map->ptr;
-unsigned int i;
+int i;
 
 for (i = ((map->size - 1) - page_size); i > 0; i -= page_size)
 p[i] = rand();
 static void read_every_other_page(struct map *map)
 static void read_mapping_reverse(struct map *map)
 {
 char *p = map->ptr;
-unsigned int i;
+int i;
 char buf[page_size];
 
 for (i = ((map->size - 1) - page_size); i > 0; i -= page_size)
",128,24
remove mystery +1's from page counts in page dirtying code," static void dirty_random_pages(struct map *map)
 unsigned int num_pages = map->size / page_size;
 
 for (i = 0; i < num_pages; i++)
-p[(rand() % (num_pages + 1)) * page_size] = rand();
+p[(rand() % num_pages) * page_size] = rand();
 }
 
 /* Dirty the last page in a mapping
 static void read_random_pages(struct map *map)
 char buf[page_size];
 
 for (i = 0; i < num_pages; i++)
-memcpy(buf, p + ((rand() % (num_pages + 1)) * page_size), page_size);
+memcpy(buf, p + ((rand() % num_pages) * page_size), page_size);
 }
 
 /* Fault in the last page in a mapping */
",128,24
"mremap 5th arg is an address, not a length.

Make something up for now. Later we'll do something smarter.","
 #include ""shm.h""
 #include ""utils.h""
 
-static unsigned long rand_size(void)
-{
-const unsigned long sizes[] = { 1 * MB, 2 * MB, 4 * MB, 10 * MB, 1 * GB, 2 * GB };
-
-return sizes[rand() % ARRAY_SIZE(sizes)];
-}
-
 static void sanitise_mremap(int childno)
 {
 struct map *map;
 static void sanitise_mremap(int childno)
 shm->syscall[childno].a3 = map->size;//TODO: Munge this.
 
 if (shm->syscall[childno].a4 & MREMAP_FIXED) {
-shm->syscall[childno].a5 = rand_size();
+shm->syscall[childno].a5 = ((rand() % 256) << (rand() % __WORDSIZE));
+shm->syscall[childno].a5 += page_size;
+shm->syscall[childno].a5 &= PAGE_MASK;
 } else {
 shm->syscall[childno].a5 = 0;
 }
 struct syscallentry syscall_mremap = {
 .values = { MREMAP_MAYMOVE, MREMAP_FIXED },
 },
 .arg5name = ""new_addr"",
-.arg5type = ARG_ADDRESS,
 .group = GROUP_VM,
 .post = post_mremap,
 };
",50,5
"bring back the previous table in mremap, but use them as alignments instead.

This seems to be a lot more useful than randomly corrupting glibc.","
 #include ""shm.h""
 #include ""utils.h""
 
+static const unsigned long alignments[] = {
+1 * MB, 2 * MB, 4 * MB, 8 * MB,
+10 * MB, 100 * MB,
+1 * GB, 2 * GB, 4 * GB,
+};
+
 static void sanitise_mremap(int childno)
 {
 struct map *map;
+unsigned long newaddr = 0;
+unsigned long align = alignments[rand() % ARRAY_SIZE(alignments)];
 
 map = common_set_mmap_ptr_len(childno);
 
 shm->syscall[childno].a3 = map->size;//TODO: Munge this.
 
 if (shm->syscall[childno].a4 & MREMAP_FIXED) {
-shm->syscall[childno].a5 = ((rand() % 256) << (rand() % __WORDSIZE));
-shm->syscall[childno].a5 += page_size;
-shm->syscall[childno].a5 &= PAGE_MASK;
-} else {
-shm->syscall[childno].a5 = 0;
+newaddr = ((rand() % 256) << (rand() % __WORDSIZE));
+newaddr |= align;
+newaddr &= ~(align - 1);
 }
+
+shm->syscall[childno].a5 = newaddr;
 }
 
 /*
",56,5
limit the shifting in mremap a little.," static void sanitise_mremap(int childno)
 shm->syscall[childno].a3 = map->size;//TODO: Munge this.
 
 if (shm->syscall[childno].a4 & MREMAP_FIXED) {
-newaddr = ((rand() % 256) << (rand() % __WORDSIZE));
+newaddr = ((rand() % 256) << (rand() % (__WORDSIZE - 8)));
 newaddr |= align;
 newaddr &= ~(align - 1);
 }
",56,5
"fix up dead lock detection.

pid_alive return value needs to be checked."," static void check_children(void)
 
 static void check_lock(lock_t *_lock)
 {
-pid_t pid = _lock->owner;
+pid_t pid;
 
 if (_lock->lock != LOCKED)
 return;
 
 /* First the easy case. If it's held by a dead pid, release it. */
-if (!pid_alive(pid)) {
+pid = _lock->owner;
+if (pid_alive(pid) == -1) {
+if (errno != ESRCH)
+return;
+
 output(0, ""Found a lock held by dead pid %d. Freeing.\n"", pid);
 unlock(_lock);
 return;
",344,70
introduce get_writable_address," void sanitise_perf_event_open(int childno)
 int group_leader=0;
 void *addr;
 
-addr = get_non_null_address();
+addr = get_writable_address(sizeof(struct perf_event_attr));
 shm->syscall[childno].a1 = (unsigned long) addr;
 attr = (struct perf_event_attr *) addr;
 
",1016,249
remove unused within_page function,"
 #include ""utils.h""
 
 /*
-static bool within_page(void *addr, void *check)
-{
-if (addr == check)
-return TRUE;
-if ((addr > check) && (addr < (check + page_size)))
-return TRUE;
-return FALSE;
-}
-
 bool validate_address(void *addr)
 {
 if (within_page(addr, shm) == TRUE)
",117,38
remove unused validate_address function,"
 #include ""tables.h""
 #include ""utils.h""
 
-/*
-bool validate_address(void *addr)
-{
-if (within_page(addr, shm) == TRUE)
-return FALSE;
-if (within_page(addr, page_rand) == TRUE)
-return FALSE;
-if (within_page(addr, page_zeros) == TRUE)
-return FALSE;
-if (within_page(addr, page_0xff) == TRUE)
-return FALSE;
-if (within_page(addr, page_allocs) == TRUE)
-return FALSE;
-
-return TRUE;
-}
-*/
-
 void * get_writable_address(unsigned long size)
 {
 struct map *map;
",117,38
"invert test in debugf to reduce indentation.

add commentary"," void output_syscall_postfix(unsigned long ret, int errno_saved, bool err)
 }
 }
 
+/*
+ * debugging output.
+ * This is just a convenience helper to avoid littering the code
+ * with dozens of 'if debug == TRUE' comparisons causing unnecessary nesting.
+ */
 void debugf(const char *fmt, ...)
 {
 va_list args;
 
-if (debug == TRUE) {
-va_start(args, fmt);
-vprintf(fmt, args);
-va_end(args);
-}
+if (debug == FALSE)
+return;
+
+va_start(args, fmt);
+output(0, fmt, args);
+va_end(args);
 }
",382,101
take syscall lock when writing new registers.," bool mkcall(int childno)
 
 syscallrec = &shm->syscall[childno];
 
+lock(&shm->syscall[childno].lock);
 syscallrec->a1 = (unsigned long) rand64();
 syscallrec->a2 = (unsigned long) rand64();
 syscallrec->a3 = (unsigned long) rand64();
 bool mkcall(int childno)
 if (entry->sanitise)
 entry->sanitise(childno);
 
+unlock(&shm->syscall[childno].lock);
+
 output_syscall_prefix(childno, call);
 
 /* If we're going to pause, might as well sync pre-syscall */
",152,22
use zmalloc on log startup in lieu of error checking,"
 #include <string.h>
 #include <unistd.h>
 #include <fcntl.h>
-#include ""params.h""// logging, monochrome, quiet_level
-#include ""shm.h""
-#include ""pids.h""
-#include ""log.h""
 #include ""arch.h"" //PAGE_MASK
+#include ""log.h""
 #include ""maps.h"" //pages
+#include ""params.h""// logging, monochrome, quiet_level
+#include ""pids.h""
+#include ""shm.h""
 #include ""syscall.h"" //syscalls
 #include ""tables.h""
 #include ""trinity.h""
+#include ""utils.h""
 
 #define BUFSIZE 1024
 
 void open_logfiles(void)
 unsigned int i;
 char *logfilename;
 
-logfilename = malloc(64);
+logfilename = zmalloc(64);
 sprintf(logfilename, ""trinity.log"");
 unlink(logfilename);
 mainlogfile = fopen(logfilename, ""a"");
",383,101
"Move eventfd2 defines to compat.h

Reported by Dave Miller on Sparc.","
 #include ""sanitise.h""
 #include ""shm.h""
 #include ""trinity.h""
+#include ""compat.h""
 
 void open_eventfd_fds(void)
 {
",36,3
"use a temporary buffer for debug output

Passing va_list's doesn't work, duh."," void output_syscall_postfix(unsigned long ret, int errno_saved, bool err)
 */
 void debugf(const char *fmt, ...)
 {
+char debugbuf[256];
 va_list args;
 
 if (debug == FALSE)
 return;
 
 va_start(args, fmt);
-output(0, fmt, args);
+vsprintf(debugbuf, fmt, args);
 va_end(args);
+output(0, debugbuf);
 }
",385,101
"destroy the linked-list of filenames when we build the index.

We don't free the ->name entry of each node, because it will
now be pointed at by the index instead."," static void open_fds(const char *dirpath)
 static void generate_filelist(void)
 {
 unsigned int i = 0;
-struct list_head *node;
+struct list_head *node, *tmp;
 struct namelist *nl;
 
 names = zmalloc(sizeof(struct namelist));
 static void generate_filelist(void)
 
 /* Generate an index of pointers to the filenames */
 
-fileindex = malloc(sizeof(char *) * files_added);
+fileindex = zmalloc(sizeof(char *) * files_added);
 
-list_for_each(node, &names->list) {
+list_for_each_safe(node, tmp, &names->list) {
 nl = (struct namelist *) node;
 fileindex[i++] = nl->name;
+
+/* Destroy the list head, but keep the ->name alloc because
+ * now the fileindex points to it.
+ */
+list_del(&nl->list);
+free(nl);
 }
 files_in_index = i;
+
+names = NULL;
 }
 
 static int open_file(void)
",268,61
"cpu numbers start at zero.

Also, don't bother with two separate ""out of range"" cases."," static unsigned int get_cpu(void)
 
 switch (i) {
 case 0: return -1;
-case 1: return rand() % 4095;
-case 2: return rand() % 15;
-
-case 3 ... 99:
+case 1: return rand() % 4096;
+case 2 ... 99:
 return rand() % num_online_cpus;
 }
 return 0;
",363,123
add a rand_range function," void * __zmalloc(size_t size, const char *func);
 # define offsetof(type, member)((size_t) &((type *) 0)->member)
 #endif
 
+/*
+ * swap - swap value of @a and @b
+ */
+#define swap(a, b) \
+do { typeof(a) __tmp = (a); (a) = (b); (b) = __tmp; } while (0)
+
 #define MAX_ERRNO 4095
 #define IS_ERR_VALUE(x) ((x) >= (unsigned long)-MAX_ERRNO)
 static inline long IS_ERR(unsigned long x)
",12,1
"use rand_range for listen backlog parameter.

Also bump up upper bound to 128."," static int open_socket(unsigned int domain, unsigned int type, unsigned int prot
 else
 debugf(""bind: success!\n"");
 */
-ret = listen(fd, (rand() % 2) + 1);
+ret = listen(fd, rand_range(1, 128));
 /*if (ret == -1)
 debugf(""listen: %s\n"", strerror(errno));
 else
",265,62
use rand_range in fds.c," int get_random_fd(void)
 regen:
 if (shm->fd_lifetime == 0) {
 shm->current_fd = get_new_random_fd();
-shm->fd_lifetime = (rand() % max_children) + 5;
+shm->fd_lifetime = rand_range(5, max_children);
 } else
 shm->fd_lifetime--;
 
",102,23
use rand_range in generic sanitize routines," unsigned long set_rand_bitmask(unsigned int num, const unsigned long *values)
 unsigned long mask = 0;
 unsigned int bits;
 
-bits = (rand() % num) + 1;/* num of bits to OR */
+bits = rand_range(1, num);/* num of bits to OR */
 for (i = 0; i < bits; i++)
 mask |= values[rand() % num];
 
 static unsigned long handle_arg_iovec(int childno, unsigned long call, unsigned
 
 entry = syscalls[call].entry;
 
-num_entries = (rand() % 256) +1;
+num_entries = rand_range(1, 256);
 
 switch (argnum) {
 case 1:if (entry->arg2type == ARG_IOVECLEN)
",363,123
use rand_range in random-address routines," void * get_writable_address(unsigned long size)
 i = rand() % 7;
 
 if (size > page_size)
-i = (rand() % 2) + 5;
+i = rand_range(5, 6);
 
 switch (i) {
 case 0:addr = page_zeros;
 static void * _get_address(unsigned char null_allowed)
 if (null_allowed == TRUE)
 i = rand() % 4;
 else
-i = (rand() % 3) + 1;
+i = rand_range(1, 3);
 
 switch (i) {
 case 0: addr = NULL;
",117,38
use rand_range in rand8x8,"
 #include ""types.h""
 #include ""utils.h""
 
+int rand_range(int min, int max)
+{
+if (min > max)
+swap(min, max);
+
+return min + rand() / (RAND_MAX / (max - min + 1) + 1);
+}
+
 unsigned int rand_bool(void)
 {
 return rand() % 2;
 static unsigned long rand8x8(void)
 unsigned long r = 0UL;
 unsigned int i;
 
-for (i = (rand() % 7) + 1; i > 0; --i)
+for (i = rand_range(1, 7); i > 0; --i)
 r = (r << 8) | rand() % 256;
 
 return r;
 u64 rand64(void)
 
 return r;
 }
-
-int rand_range(int min, int max)
-{
-if (min > max)
-swap(min, max);
-
-return min + rand() / (RAND_MAX / (max - min + 1) + 1);
-}
",174,55
use rand_range in get_len," unsigned long get_len(void)
 
 /* we might get lucky if something is counting ints/longs etc. */
 if (rand() % 100 < 25) {
-int _div = 1 << ((rand() % 4) + 1); /* 2,4,8 or 16 */
+int _div = 1 << rand_range(1, 4);/* 2,4,8 or 16 */
 i /= _div;
 }
 
",32,10
add a missed rand_range conversion in rand32()," unsigned int rand32(void)
 
 /* we might get lucky if something is counting ints/longs etc. */
 if (rand() % 100 < 25) {
-int _div = 1 << ((rand() % 4) + 1);/* 2,4,8 or 16 */
+int _div = 1 << rand_range(1, 4);/* 2,4,8 or 16 */
 r /= _div;
 }
 
",174,55
fix leak of namelist ptr," static void generate_filelist(void)
 }
 files_in_index = i;
 
+free(names);
 names = NULL;
 }
 
",269,61
"This isn't an error, so should use output()"," void main_loop(void)
 while (pidmap_empty() == FALSE)
 handle_children();
 
-outputerr(""Bailing main loop. Exit reason: %s\n"", decode_exit(shm->exit_reason));
+output(0, ""Bailing main loop. Exit reason: %s\n"", decode_exit(shm->exit_reason));
 }
",234,50
"we don't care about return codes of socket shutdown

it's not like we can do anything about them if something
goes wrong, and it just causes spew."," void close_sockets(void)
 {
 unsigned int i;
 int fd;
-int r = 0;
 struct linger ling = { .l_onoff = FALSE, .l_linger = 0 };
 
 for (i = 0; i < nr_sockets; i++) {
 void close_sockets(void)
 shm->sockets[i].fd = 0;
 
 /* disable linger */
-r = setsockopt(fd, SOL_SOCKET, SO_LINGER, &ling, sizeof(struct linger));
-if (r)
-perror(""setsockopt"");
+(void) setsockopt(fd, SOL_SOCKET, SO_LINGER, &ling, sizeof(struct linger));
 
-r = shutdown(fd, SHUT_RDWR);
-if (r)
-perror(""shutdown"");
+(void) shutdown(fd, SHUT_RDWR);
 
 if (close(fd) != 0)
 output(1, ""failed to close socket [%d:%d:%d].(%s)\n"",
",260,60
"always close sockets opened so far before regenerating.

Otherwise we overflow the fd struct."," regenerate:
 unlock_cachefile(cachefile);/* drop the reader lock. */
 close(cachefile);
 unlink(cachefilename);
+
+close_sockets();
 ret = generate_sockets();
 return ret;
 }
 regenerate:
 fd = open_socket(domain, type, protocol);
 if (fd < 0) {
 output(1, ""Cachefile is stale. Need to regenerate.\n"");
-close_sockets();
 goto regenerate;
 }
 
",260,60
fix shifting error in mremap," static void sanitise_mremap(int childno)
 {
 struct map *map;
 unsigned long newaddr = 0;
-unsigned long align = alignments[rand() % ARRAY_SIZE(alignments)];
 
 map = common_set_mmap_ptr_len(childno);
 
 shm->syscall[childno].a3 = map->size;//TODO: Munge this.
 
 if (shm->syscall[childno].a4 & MREMAP_FIXED) {
-newaddr = ((rand() % 256) << (rand() % (__WORDSIZE - 8)));
+unsigned long align = alignments[rand() % ARRAY_SIZE(alignments)];
+int shift = (__WORDSIZE / 2) - 1;
+
+newaddr = rand() % 256 << rand() % shift;
 newaddr |= align;
 newaddr &= ~(align - 1);
 }
",57,5
"Clear main pid before we exit.

Reported and diagnosed by Michael Ellerman.

If we don't do this, the watchdog will spin forever."," static void fork_children(void)
 if (pid == -1) {
 output(0, ""couldn't create child! (%s)\n"", strerror(errno));
 shm->exit_reason = EXIT_FORK_FAILURE;
+shm->mainpid = 0;
 exit(EXIT_FAILURE);
 }
 }
",235,50
"add an exit_main_fail() function and use it.

This should clear shm->mainpid in all the places that matter before the
main process exits."," void open_pipes(void)
 for (i = 0; i < MAX_PIPE_FDS; i+=2) {
 if (pipe(pipes) < 0) {
 perror(""pipe fail.\n"");
-exit(EXIT_FAILURE);
+exit_main_fail();
 }
 shm->pipe_fds[i] = pipes[0];
 shm->pipe_fds[i+1] = pipes[1];
",36,4
fix off by one in page size masking.," unsigned long get_len(void)
 
 case 0:i &= 0xff;
 break;
-case 1: i &= page_size;
+case 1: i &= page_size - 1;
 break;
 case 2:i &= 0xffff;
 break;
",32,10
"export pmu data from perf_event_open.c

export the perf_event_open() pmus structure, that way perf_fuzzer can
pretty-print the pmu names. It saves a lot of code duplication.

I could always just make this change in my local tree, but it's nice
having perf_event_open.c the same in both projects.

Signed-off-by: Vince Weaver <vincent.weaver@maine.edu>"," struct pmu_type {
 struct generic_event_type *generic_events;
 };
 
-static int num_pmus=0;
-
-static struct pmu_type *pmus=NULL;
+/* Not static so other tools can access the PMU data */
+int num_pmus=0;
+struct pmu_type *pmus=NULL;
 
 
 #define FIELD_UNKNOWN0
",1034,252
"Make fork failure only fatal if we have no running children.

This is an experiment, and one I tried before, but let's see if
we can at least do better than just exiting the first time fork() fails.

Last time I tried this, I ended up with a ton of fork failures,
so we might still need to do something else but that was before
I did a lot of the VM work, so things may be better now anyway."," static void fork_children(void)
 _exit(EXIT_SUCCESS);
 } else {
 if (pid == -1) {
+/* We failed, wait for a child to exit before retrying. */
+if (shm->running_childs > 0)
+return;
+
 output(0, ""couldn't create child! (%s)\n"", strerror(errno));
 shm->exit_reason = EXIT_FORK_FAILURE;
 exit_main_fail();
",245,53
move child log truncation out of main loop into child init," static void oom_score_adj(int adj)
 fclose(fp);
 }
 
+static void truncate_log(int childno)
+{
+int fd;
+
+if (logging == FALSE)
+return;
+
+fd = fileno(shm->logfiles[childno]);
+if (ftruncate(fd, 0) == 0)
+lseek(fd, 0, SEEK_SET);
+}
+
 void init_child(int childno)
 {
 cpu_set_t set;
 void init_child(int childno)
 
 this_child = childno;
 
+truncate_log(childno);
+
 set_seed(childno);
 
 shm->kill_count[childno] = 0;
",228,43
"remove pointless alarm call.

The main pid doesn't use alarms, so this is redundant."," static void fork_children(void)
 exit_main_fail();
 }
 
-(void)alarm(0);
 fflush(stdout);
 pid = fork();
 
",238,51
"syscall: Take SYSCALL_OFFSET into account

MIPS and IA64 have their syscall tables starting at non-zero
offsets so take that into account when executing a sycall
otherwise trinity just fails with ENOSYS error messages.

Tested on MIPS 32/LE system.

Signed-off-by: Markos Chandras <markos.chandras@imgtec.com>"," static long syscall32(unsigned int call,
 static unsigned long do_syscall(int childno, int *errno_saved)
 {
 int nr = shm->syscall[childno].nr;
+int call = nr + SYSCALL_OFFSET;
 unsigned long a1, a2, a3, a4, a5, a6;
 unsigned long ret = 0;
 
 static unsigned long do_syscall(int childno, int *errno_saved)
 errno = 0;
 
 if (shm->syscall[childno].do32bit == FALSE)
-ret = syscall(nr, a1, a2, a3, a4, a5, a6);
+ret = syscall(call, a1, a2, a3, a4, a5, a6);
 else
-ret = syscall32(nr, a1, a2, a3, a4, a5, a6);
+ret = syscall32(call, a1, a2, a3, a4, a5, a6);
 
 *errno_saved = errno;
 
",153,22
only do_syscall needs to care about SYSCALL_OFFSET," static long syscall32(unsigned int call,
 static unsigned long do_syscall(int childno, int *errno_saved)
 {
 int nr = shm->syscall[childno].nr;
-int call = nr + SYSCALL_OFFSET;
+int call = nr;
 unsigned long a1, a2, a3, a4, a5, a6;
 unsigned long ret = 0;
 
+/* Some architectures (IA64/MIPS) start their Linux syscalls
+ * At non-zero, and have other ABIs below.
+ */
+call += SYSCALL_OFFSET;
+
 a1 = shm->syscall[childno].a1;
 a2 = shm->syscall[childno].a2;
 a3 = shm->syscall[childno].a3;
 bool mkcall(int childno)
 if (dopause == TRUE)
 synclogs();
 
-/* Some architectures (IA64/MIPS) start their Linux syscalls
- * At non-zero, and have other ABIs below.
- */
-call += SYSCALL_OFFSET;
-
 /* This is a special case for things like execve, which would replace our
  * child process with something unknown to us. We use a 'throwaway' process
  * to do the execve in, and let it run for a max of a seconds before we kill it */
",153,22
trinity.h inclusion cleanup,"
 #include ""signals.h""
 #include ""pids.h""
 #include ""tables.h""
+#include ""trinity.h""
 
 /*
 * This function decides if we're going to be doing a 32bit or 64bit syscall.
",73,14
"missed one place where we need SYSCALL_OFFSET

Pointed out by Markos Chandras <Markos.Chandras@imgtec.com>"," bool mkcall(int childno)
 goto skip_enosys;
 
 output(1, ""%s (%d) returned ENOSYS, marking as inactive.\n"",
-entry->name, call);
+entry->name, call + SYSCALL_OFFSET);
 
 deactivate_syscall(call, syscallrec->do32bit);
 }
",152,22
use a larger buffer for debugf," void output_syscall_postfix(unsigned long ret, int errno_saved, bool err)
 */
 void debugf(const char *fmt, ...)
 {
-char debugbuf[256];
+char debugbuf[BUFSIZE];
 va_list args;
 
 if (debug == FALSE)
",388,102
"move ""we're tainted"" code out into own post-mortem function"," static void check_all_locks(void)
 check_lock(&shm->syscall[i].lock);
 }
 
+static void tainted_postmortem(int taint)
+{
+shm->exit_reason = EXIT_KERNEL_TAINTED;
+
+gettimeofday(&shm->taint_tv, NULL);
+
+output(0, ""kernel became tainted! (%d/%d) Last seed was %u\n"",
+taint, kernel_taint_initial, shm->seed);
+}
+
 static void watchdog(void)
 {
 static const char watchdogname[17]=""trinity-watchdog"";
 static void watchdog(void)
 }
 }
 
-/* Only check taint if it mask allows it */
+/* Only check taint if the mask allows it */
 if (kernel_taint_mask != 0) {
 ret = check_tainted();
-if (((ret & kernel_taint_mask) & (~kernel_taint_initial)) != 0) {
-shm->exit_reason = EXIT_KERNEL_TAINTED;
-
-gettimeofday(&shm->taint_tv, NULL);
-
-output(0, ""kernel became tainted! (%d/%d) Last seed was %u\n"", ret, kernel_taint_initial, shm->seed);
-}
+if (((ret & kernel_taint_mask) & (~kernel_taint_initial)) != 0)
+tainted_postmortem(ret);
 }
 
 main_dead:
",352,72
"When we're tainted, syslog the last seed.","
 #include <string.h>
 #include <stdlib.h>
 #include <signal.h>
+#include <syslog.h>
 #include <sys/prctl.h>
 #include <sys/types.h>
 #include <sys/stat.h>
 static void tainted_postmortem(int taint)
 
 output(0, ""kernel became tainted! (%d/%d) Last seed was %u\n"",
 taint, kernel_taint_initial, shm->seed);
+
+openlog(""trinity"", LOG_CONS|LOG_PERROR, LOG_USER);
+syslog(LOG_CRIT, ""Detected kernel tainting. Last seed was %u\n"", shm->seed);
+closelog();
 }
 
 static void watchdog(void)
",356,72
"remove the outputting of the reseeding.

This causes a *lot* of the spew from trinity, and will only get worse
as child processes start segv'ing more often.

now that the watchdog dumps the last known seed when it detects taint,
that is hopefully good enough.

The one corner case is where we crash so badly that the watchdog
doesn't get time to write the last seed to syslog. In that
circumstance, we used to be able to look back at the last known
good seed.

A better solution might be to dump some state periodically over
the network to another system. I'll experiment with this at some point.","
 * to store what gets passed in from the command line -s argument */
 unsigned int seed = 0;
 
-static void syslog_seed(int seedparam)
-{
-outputerr(""Randomness reseeded to %u\n"", seedparam);
-openlog(""trinity"", LOG_CONS|LOG_PERROR, LOG_USER);
-syslog(LOG_CRIT, ""Randomness reseeded to %u\n"", seedparam);
-closelog();
-}
-
 unsigned int new_seed(void)
 {
 int fd;
 unsigned int init_seed(unsigned int seedparam)
 output(0, ""Initial random seed: %u\n"", seedparam);
 }
 
-if (do_syslog == TRUE)
-syslog_seed(seedparam);
+if (do_syslog == TRUE) {
+openlog(""trinity"", LOG_CONS|LOG_PERROR, LOG_USER);
+syslog(LOG_CRIT, ""Initial random seed: %u\n"", seedparam);
+closelog();
+}
 
 return seedparam;
 }
 void reseed(void)
 
 /* We are reseeding. */
 shm->seed = new_seed();
-
-output(0, ""Random reseed: %u\n"", shm->seed);
-
-if (do_syslog == TRUE)
-syslog_seed(shm->seed);
 }
",59,12
"move ""do 32 bit syscall from 64 bit code"" implentation to arch header"," static long syscall32(unsigned int call,
 {
 long __res = 0;
 
-//FIXME: Move the implementations out to arch header files.
-
 #if defined(__x86_64__)
-__asm__ volatile (
-""pushq %%rbp\n\t""
-""pushq %%r10\n\t""
-""pushq %%r11\n\t""
-""movq %7, %%rbp\n\t""
-""int $0x80\n\t""
-""popq %%r11\n\t""
-""popq %%r10\n\t""
-""popq %%rbp\n\t""
-: ""=a"" (__res)
-: ""0"" (call),""b"" ((long)(a1)),""c"" ((long)(a2)),""d"" ((long)(a3)), ""S"" ((long)(a4)),""D"" ((long)(a5)), ""g"" ((long)(a6))
-: ""%rbp"" /* mark EBP reg as dirty */
-);
+DO_32_SYSCALL
 __syscall_return(long, __res);
-
 #else
 /* non-x86 implementations go here. */
 #error Implement 32-on-64 syscall in syscall.c:syscall32() for this architecture.
",140,22
remove x86-64 specific commentary," static long syscall32(unsigned int call,
 {
 long __res = 0;
 
-#if defined(__x86_64__)
+#if defined(DO_32_SYSCALL)
 DO_32_SYSCALL
 __syscall_return(long, __res);
 #else
-/* non-x86 implementations go here. */
-#error Implement 32-on-64 syscall in syscall.c:syscall32() for this architecture.
-
+#error Implement 32-on-64 syscall macro for this architecture.
 #endif
 return __res;
 }
",140,22
"add missing include dependancy in log.h

remove unneeded include in pids.c","
 #include <sys/types.h>
 #include <signal.h>
 #include ""shm.h""
-#include ""params.h""// for 'dangerous'
 #include ""pids.h""
 #include ""log.h""
 #include ""sanitise.h""
",109,26
"partial revert of previous commit

While log.h was missing the params include, we shouldn't make .c
files start depending on implicit inclusion.","
 #include <sys/types.h>
 #include <signal.h>
 #include ""shm.h""
+#include ""params.h""// dangerous
 #include ""pids.h""
 #include ""log.h""
 #include ""sanitise.h""
",110,26
"remove call param from handle_arg_iovec

we can get it from the syscallrec"," static unsigned long handle_arg_randpage(void)
 return (unsigned long) page_rand;
 }
 
-//FIXME: Do we need to pass in call ? Just get it from syscallrec
-static unsigned long handle_arg_iovec(int childno, unsigned long call, unsigned long argnum)
+static unsigned long handle_arg_iovec(int childno, unsigned long argnum)
 {
 struct syscallrecord *syscallrec;
 struct syscallentry *entry;
 unsigned long num_entries;
+unsigned long call;
 
 syscallrec = &shm->syscall[childno];
+call = syscallrec->nr;
 entry = syscalls[call].entry;
 
 num_entries = rand_range(1, 256);
 static unsigned long fill_arg(int childno, int call, unsigned int argnum)
 return (unsigned long) generate_pathname();
 
 case ARG_IOVEC:
-return handle_arg_iovec(childno, call, argnum);
+return handle_arg_iovec(childno, argnum);
 
 case ARG_IOVECLEN:
 case ARG_SOCKADDRLEN:
",374,123
"remove passing call number around to handle_arg_address & find_previous_arg_address

just read it from the syscallrec"," static unsigned int get_cpu(void)
 return 0;
 }
 
-static unsigned long handle_arg_address(int childno, int call, int argnum)
+static unsigned long handle_arg_address(int childno, int argnum)
 {
 unsigned long addr = 0;
 
 static unsigned long handle_arg_address(int childno, int call, int argnum)
 /* Half the time, we look to see if earlier args were also ARG_ADDRESS,
  * and munge that instead of returning a new one from get_address() */
 
-addr = find_previous_arg_address(argnum, call, childno);
+addr = find_previous_arg_address(argnum, childno);
 
 switch (rand() % 4) {
 case 0:break;/* return unmodified */
 static unsigned long fill_arg(int childno, int call, unsigned int argnum)
 return (unsigned long) get_len();
 
 case ARG_ADDRESS:
-return handle_arg_address(childno, call, argnum);
+return handle_arg_address(childno, argnum);
 
 case ARG_NON_NULL_ADDRESS:
 return (unsigned long) get_non_null_address();
",374,123
"handle_arg_sockaddr doesn't need the call arg

get it from the syscallrec instead"," static unsigned long get_argval(int childno, unsigned int argnum)
 }
 
 
-static unsigned long handle_arg_sockaddr(int childno, unsigned int call, unsigned long argnum)
+static unsigned long handle_arg_sockaddr(int childno, unsigned long argnum)
 {
 struct syscallrecord *syscallrec;
 struct syscallentry *entry;
 struct sockaddr *sockaddr = NULL;
 socklen_t sockaddrlen = 0;
+unsigned int call;
 
 syscallrec = &shm->syscall[childno];
+call = syscallrec->nr;
 entry = syscalls[call].entry;
 
 generate_sockaddr((struct sockaddr **)&sockaddr, &sockaddrlen, PF_NOHINT);
 static unsigned long fill_arg(int childno, int call, unsigned int argnum)
 return get_argval(childno, argnum);
 
 case ARG_SOCKADDR:
-return handle_arg_sockaddr(childno, call, argnum);
+return handle_arg_sockaddr(childno, argnum);
 
 case ARG_MODE_T:
 return handle_arg_mode_t();
",376,123
"handle_arg_range really wants the syscall entry, so just pass it"," static unsigned long handle_arg_address(int childno, int argnum)
 return addr;
 }
 
-static unsigned long handle_arg_range(unsigned int call, unsigned int argnum)
+static unsigned long handle_arg_range(struct syscallentry *entry, unsigned int argnum)
 {
-struct syscallentry *entry;
 unsigned long i;
 unsigned long low = 0, high = 0;
 
-entry = syscalls[call].entry;
-
 switch (argnum) {
 case 1:low = entry->low1range;
 high = entry->hi1range;
 static unsigned long fill_arg(int childno, unsigned int argnum)
 return (unsigned long) get_pid();
 
 case ARG_RANGE:
-return handle_arg_range(call, argnum);
+return handle_arg_range(entry, argnum);
 
 case ARG_OP:/* Like ARG_LIST, but just a single value. */
 return handle_arg_op(call, argnum);
",378,123
"handle_arg_op really wants the syscall entry, so pass that instead of call"," static unsigned long handle_arg_range(struct syscallentry *entry, unsigned int a
 return i;
 }
 
-static unsigned long handle_arg_op(unsigned int call, unsigned long argnum)
+static unsigned long handle_arg_op(struct syscallentry *entry, unsigned long argnum)
 {
-struct syscallentry *entry;
 const unsigned long *values = NULL;
 unsigned int num = 0;
 unsigned long mask = 0;
 
-entry = syscalls[call].entry;
-
 switch (argnum) {
 case 1:num = entry->arg1list.num;
 values = entry->arg1list.values;
 static unsigned long fill_arg(int childno, unsigned int argnum)
 return handle_arg_range(entry, argnum);
 
 case ARG_OP:/* Like ARG_LIST, but just a single value. */
-return handle_arg_op(call, argnum);
+return handle_arg_op(entry, argnum);
 
 case ARG_LIST:
 return handle_arg_list(call, argnum);
",376,123
handle_arg_list really wants the syscallentry so pass it instead of call," unsigned long set_rand_bitmask(unsigned int num, const unsigned long *values)
 return mask;
 }
 
-static unsigned long handle_arg_list(unsigned int call, unsigned long argnum)
+static unsigned long handle_arg_list(struct syscallentry *entry, unsigned long argnum)
 {
-struct syscallentry *entry;
 unsigned long mask = 0;
 unsigned int num = 0;
 const unsigned long *values = NULL;
 
-entry = syscalls[call].entry;
-
 switch (argnum) {
 case 1:num = entry->arg1list.num;
 values = entry->arg1list.values;
 static unsigned long fill_arg(int childno, unsigned int argnum)
 return handle_arg_op(entry, argnum);
 
 case ARG_LIST:
-return handle_arg_list(call, argnum);
+return handle_arg_list(entry, argnum);
 
 case ARG_RANDPAGE:
 return handle_arg_randpage();
",374,123
rearrange find_previous_arg_address args to match handle_arg_address," static unsigned long handle_arg_address(int childno, int argnum)
 /* Half the time, we look to see if earlier args were also ARG_ADDRESS,
  * and munge that instead of returning a new one from get_address() */
 
-addr = find_previous_arg_address(argnum, childno);
+addr = find_previous_arg_address(childno, argnum);
 
 switch (rand() % 4) {
 case 0:break;/* return unmodified */
",374,123
don't bother calling find_previous_address if argnum == 1," static unsigned long handle_arg_address(int childno, int argnum)
 {
 unsigned long addr = 0;
 
+if (argnum == 1)
+return (unsigned long) get_address();
+
 if (rand_bool())
 return (unsigned long) get_address();
 
",376,124
just pass handle_arg_iovec the args it needs," static unsigned long handle_arg_randpage(void)
 return (unsigned long) page_rand;
 }
 
-static unsigned long handle_arg_iovec(int childno, unsigned long argnum)
+static unsigned long handle_arg_iovec(struct syscallentry *entry, struct syscallrecord *syscallrec, unsigned int argnum)
 {
-struct syscallrecord *syscallrec;
-struct syscallentry *entry;
 unsigned long num_entries;
-unsigned int call;
-
-syscallrec = &shm->syscall[childno];
-call = syscallrec->nr;
-entry = syscalls[call].entry;
 
 num_entries = rand_range(1, 256);
 
 static unsigned long fill_arg(int childno, unsigned int argnum)
 return (unsigned long) generate_pathname();
 
 case ARG_IOVEC:
-return handle_arg_iovec(childno, argnum);
+return handle_arg_iovec(entry, syscallrec, argnum);
 
 case ARG_IOVECLEN:
 case ARG_SOCKADDRLEN:
",370,124
just pass handle_arg_sockaddr what it needs," static unsigned long get_argval(int childno, unsigned int argnum)
 }
 
 
-static unsigned long handle_arg_sockaddr(int childno, unsigned long argnum)
+static unsigned long handle_arg_sockaddr(struct syscallentry *entry, struct syscallrecord *syscallrec, unsigned long argnum)
 {
-struct syscallrecord *syscallrec;
-struct syscallentry *entry;
 struct sockaddr *sockaddr = NULL;
 socklen_t sockaddrlen = 0;
-unsigned int call;
-
-syscallrec = &shm->syscall[childno];
-call = syscallrec->nr;
-entry = syscalls[call].entry;
 
 generate_sockaddr((struct sockaddr **)&sockaddr, &sockaddrlen, PF_NOHINT);
 
 static unsigned long fill_arg(int childno, unsigned int argnum)
 return get_argval(childno, argnum);
 
 case ARG_SOCKADDR:
-return handle_arg_sockaddr(childno, argnum);
+return handle_arg_sockaddr(entry, syscallrec, argnum);
 
 case ARG_MODE_T:
 return handle_arg_mode_t();
",364,124
use syscallrecord struct in child_random_syscalls," static bool choose_syscall_table(void)
 
 bool child_random_syscalls(int childno)
 {
+struct syscallrecord *rec;
 unsigned int syscallnr;
 bool do32;
 
 retry:
 goto retry;
 }
 
+rec = &shm->syscall[childno];
 /* critical section for shm updates. */
-lock(&shm->syscall[childno].lock);
-shm->syscall[childno].do32bit = do32;
-shm->syscall[childno].nr = syscallnr;
-unlock(&shm->syscall[childno].lock);
+lock(&rec->lock);
+rec->do32bit = do32;
+rec->nr = syscallnr;
+unlock(&rec->lock);
 
 if (syscalls_todo) {
 if (shm->total_syscalls_done >= syscalls_todo)
",75,14
use syscallrecord struct in common_set_mmap_ptr_len," void delete_mapping(int childno, struct map *map)
 /* used in several sanitise_* functions. */
 struct map * common_set_mmap_ptr_len(int childno)
 {
+struct syscallrecord *rec;
 struct map *map;
 
-map = (struct map *) shm->syscall[childno].a1;
+rec = &shm->syscall[childno];
+map = (struct map *) rec->a1;
 shm->scratch[childno] = (unsigned long) map; /* Save this for ->post */
 if (map == NULL) {
-shm->syscall[childno].a1 = 0;
-shm->syscall[childno].a2 = 0;
+rec->a1 = 0;
+rec->a2 = 0;
 return NULL;
 }
 
-shm->syscall[childno].a1 = (unsigned long) map->ptr;
-shm->syscall[childno].a2 = map->size; //TODO: Munge this.
+rec->a1 = (unsigned long) map->ptr;
+rec->a2 = map->size; //TODO: Munge this.
 
 return map;
 }
",65,11
use syscallrecord struct in mremap sanitize,"
 #include ""random.h""
 #include ""sanitise.h""
 #include ""shm.h""
+#include ""syscall.h""
 #include ""utils.h""
 
 static const unsigned long alignments[] = {
 static const unsigned long alignments[] = {
 
 static void sanitise_mremap(int childno)
 {
+struct syscallrecord *rec;
 struct map *map;
 unsigned long newaddr = 0;
 
 map = common_set_mmap_ptr_len(childno);
 
-shm->syscall[childno].a3 = map->size;//TODO: Munge this.
+rec = &shm->syscall[childno];
 
-if (shm->syscall[childno].a4 & MREMAP_FIXED) {
+rec->a3 = map->size;//TODO: Munge this.
+
+if (rec->a4 & MREMAP_FIXED) {
 unsigned long align = alignments[rand() % ARRAY_SIZE(alignments)];
 int shift = (__WORDSIZE / 2) - 1;
 
 static void sanitise_mremap(int childno)
 newaddr &= ~(align - 1);
 }
 
-shm->syscall[childno].a5 = newaddr;
+rec->a5 = newaddr;
 }
 
 /*
",60,5
use syscallrecord struct in sync_file_range sanitize,"
 #include ""random.h""
 #include ""sanitise.h""
 #include ""shm.h""
+#include ""syscall.h""
 #include ""tables.h""
 
 static void sanitise_sync_file_range(int childno)
 {
+struct syscallrecord *rec;
 long endbyte;
 loff_t nbytes;
 loff_t off;
 
+rec = &shm->syscall[childno];
+
 retry:
 off = rand64() & 0x0fffffffffffffffUL;
 nbytes = rand64() & 0x0fffffffffffffffUL;
 retry:
 goto retry;
 
 if (this_syscallname(""sync_file_range2"", childno) == FALSE) {
-shm->syscall[childno].a2 = off;
-shm->syscall[childno].a3 = nbytes;
+rec->a2 = off;
+rec->a3 = nbytes;
 } else {
-shm->syscall[childno].a3 = off;
-shm->syscall[childno].a4 = nbytes;
+rec->a3 = off;
+rec->a4 = nbytes;
 }
 }
 
",69,4
use syscallrecord struct in setsockopt sanitize,"
 #include <sys/types.h>
 #include <sys/socket.h>
 #include <linux/types.h>
-#include ""sanitise.h""
-#include ""compat.h""
-#include ""maps.h""
+#include ""config.h""
 #include ""log.h""
-#include ""shm.h""
+#include ""maps.h""
 #include ""net.h""
-#include ""config.h""
 #include ""random.h""
+#include ""sanitise.h""
+#include ""shm.h""
+#include ""syscall.h""
 #include ""utils.h""
+#include ""compat.h""
 
 struct sso_funcptr {
 void (*func)(struct sockopt *so);
 retry:
 
 static void sanitise_setsockopt(int childno)
 {
+struct syscallrecord *rec;
 struct sockopt so = { 0, 0, 0, 0 };
 
+rec = &shm->syscall[childno];
+
 do_setsockopt(&so);
 
 /* copy the generated values to the shm. */
-shm->syscall[childno].a2 = so.level;
-shm->syscall[childno].a3 = so.optname;
-shm->syscall[childno].a4 = so.optval;
-shm->syscall[childno].a5 = so.optlen;
+rec->a2 = so.level;
+rec->a3 = so.optname;
+rec->a4 = so.optval;
+rec->a5 = so.optlen;
 }
 
 struct syscallentry syscall_setsockopt = {
",118,10
use syscallrecord struct in splice sanitize,"
 size_t, len, unsigned int, flags)
 */
 #include <stdlib.h>
-#include ""sanitise.h""
 #include ""random.h""
+#include ""sanitise.h""
 #include ""shm.h""
+#include ""syscall.h""
 
 # define SPLICE_F_MOVE 1 /* Move pages instead of copying. */
 # define SPLICE_F_NONBLOCK 2 /* Don't block on the pipe splicing

 
 static void sanitise_splice(int childno)
 {
+struct syscallrecord *rec;
+
+rec = &shm->syscall[childno];
+
 if ((rand() % 10) < 3)
 return;
 
 if (rand_bool()) {
-shm->syscall[childno].a1 = shm->pipe_fds[rand() % MAX_PIPE_FDS];
-shm->syscall[childno].a2 = 0;
+rec->a1 = shm->pipe_fds[rand() % MAX_PIPE_FDS];
+rec->a2 = 0;
 }
 
 if (rand_bool()) {
-shm->syscall[childno].a3 = shm->pipe_fds[rand() % MAX_PIPE_FDS];
-shm->syscall[childno].a4 = 0;
+rec->a3 = shm->pipe_fds[rand() % MAX_PIPE_FDS];
+rec->a4 = 0;
 }
 }
 
",42,4
use syscallrecord struct in socket sanitize,"
 #include <stdlib.h>
 #include <sys/types.h>
 #include <sys/socket.h>
-#include ""compat.h""
+#include ""config.h""
 #include ""log.h""
 #include ""net.h""
+#include ""params.h""
+#include ""protocols.h""
 #include ""random.h""
 #include ""sanitise.h""
 #include ""shm.h""
-#include ""config.h""
-#include ""params.h""
-#include ""protocols.h""
+#include ""syscall.h""
 #include ""utils.h""
+#include ""compat.h""
 
 struct socket_ptr {
 unsigned int family;
 done:
 
 static void sanitise_socket(int childno)
 {
+struct syscallrecord *rec;
 struct socket_triplet st = { .family = 0, .type = 0, .protocol = 0 };
 
+rec = &shm->syscall[childno];
+
 gen_socket_args(&st);
 
-shm->syscall[childno].a1 = st.family;
-shm->syscall[childno].a2 = st.type;
-shm->syscall[childno].a3 = st.protocol;
+rec->a1 = st.family;
+rec->a2 = st.type;
+rec->a3 = st.protocol;
 }
 
 struct syscallentry syscall_socket = {
",112,21
use syscallrecord struct in rt_sigaction sanitize,"
 */
 #include <signal.h>
 #include <stdlib.h>
-#include ""sanitise.h""
 #include ""random.h""
+#include ""sanitise.h""
 #include ""shm.h""
+#include ""syscall.h""
 
 void sanitise_rt_sigaction(int childno)
 {
+struct syscallrecord *rec;
+
+rec = &shm->syscall[childno];
+
 if (rand_bool())
-shm->syscall[childno].a2 = 0;
+rec->a2 = 0;
 
 if (rand_bool())
-shm->syscall[childno].a3 = 0;
+rec->a3 = 0;
 
-shm->syscall[childno].a4 = sizeof(sigset_t);
+rec->a4 = sizeof(sigset_t);
 }
 
 struct syscallentry syscall_rt_sigaction = {
",30,3
use syscallrecord struct in remap_file_pages sanitize,"
 #include ""random.h""
 #include ""sanitise.h""
 #include ""shm.h""
+#include ""syscall.h""
 
 static void sanitise_remap_file_pages(int childno)
 {
+struct syscallrecord *rec;
 struct map *map;
 size_t size;
 
+rec = &shm->syscall[childno];
+
 map = common_set_mmap_ptr_len(childno);
 
 /* We just want to remap a part of the mapping. */
 size = rand() % map->size;
-shm->syscall[childno].a2 = size;
+rec->a2 = size;
 
 /* ""The prot argument must be specified as 0"" */
-shm->syscall[childno].a3 = 0;
+rec->a3 = 0;
 
 /* Pick a random pgoff. */
-shm->syscall[childno].a4 = rand() & (size / page_size);
+rec->a4 = rand() & (size / page_size);
 }
 
 struct syscallentry syscall_remap_file_pages = {
",37,1
use syscallrecord struct in mlockall sanitize,"
 * SYSCALL_DEFINE1(mlockall, int, flags)
 */
 #include <stdlib.h>
-#include ""sanitise.h""
 #include ""random.h""
+#include ""sanitise.h""
 #include ""shm.h""
+#include ""syscall.h""
 
 #define MCL_CURRENT 1
 #define MCL_FUTURE 2
 
 static void sanitise_mlockall(int childno)
 {
-if (shm->syscall[childno].a1 != 0)
+struct syscallrecord *rec;
+
+rec = &shm->syscall[childno];
+
+if (rec->a1 != 0)
 return;
 
 if (rand_bool())
-shm->syscall[childno].a1 = MCL_CURRENT;
+rec->a1 = MCL_CURRENT;
 else
-shm->syscall[childno].a1 = MCL_FUTURE;
+rec->a1 = MCL_FUTURE;
 }
 
 
",28,3
use syscallrecord struct in mbind sanitize,"
 #include ""random.h""
 #include ""sanitise.h""
 #include ""shm.h""
+#include ""syscall.h""
 
 #define MPOL_F_STATIC_NODES (1 << 15)
 #define MPOL_F_RELATIVE_NODES (1 << 14)
 
 static void sanitise_mbind(int childno)
 {
+struct syscallrecord *rec;
 unsigned long maxnode;
 
+rec = &shm->syscall[childno];
+
 (void) common_set_mmap_ptr_len(childno);
 
 retry_maxnode:
-shm->syscall[childno].a5 &= ~((page_size * 8) - 1);
+rec->a5 &= ~((page_size * 8) - 1);
 
-maxnode = shm->syscall[childno].a5;
+maxnode = rec->a5;
 
 if (maxnode < 2 || maxnode > (page_size * 8)) {
-shm->syscall[childno].a5 = rand32();
+rec->a5 = rand32();
 goto retry_maxnode;
 }
 }
",48,3
use syscallrecord in autofs ioctl sanitize," static const char *const autofs_devs[] = {
 
 static void autofs_sanitise(const struct ioctl_group *grp, int childno)
 {
+struct syscallrecord *rec;
 struct autofs_dev_ioctl *arg;
 
+rec = &shm->syscall[childno];
+
 pick_random_ioctl(grp, childno);
 
-shm->syscall[childno].a3 = (unsigned long) page_rand;
+rec->a3 = (unsigned long) page_rand;
 
-switch (shm->syscall[childno].a2) {
+switch (rec->a2) {
 case AUTOFS_DEV_IOCTL_VERSION:
 case AUTOFS_DEV_IOCTL_PROTOVER:
 case AUTOFS_DEV_IOCTL_PROTOSUBVER:
 static void autofs_sanitise(const struct ioctl_group *grp, int childno)
 case AUTOFS_DEV_IOCTL_EXPIRE:
 case AUTOFS_DEV_IOCTL_ASKUMOUNT:
 case AUTOFS_DEV_IOCTL_ISMOUNTPOINT:
-arg = (struct autofs_dev_ioctl *)shm->syscall[childno].a3;
+arg = (struct autofs_dev_ioctl *) rec->a3;
 init_autofs_dev_ioctl(arg);
 arg->ioctlfd = get_random_fd();
 arg->fail.token = rand();
",181,18
"make ->post take a ptr to the syscallrecord

most of them will need to reference either the args, or the retval."," bool mkcall(int childno)
 skip_enosys:
 
 if (entry->post)
- entry->post(childno);
+ entry->post(childno, syscallrec);
 
 /* store info for debugging. */
 previous = &shm->previous[childno];
",143,22
"make ->sanitise take a ptr to the syscallrecord

most of them will need to reference either the args, or the retval."," void open_perf_fds(void)
 while (i < MAX_PERF_FDS) {
 int fd;
 
-sanitise_perf_event_open(0);
 sc = &shm->syscall[0];
+sanitise_perf_event_open(0, sc);
+
 fd = syscall(__NR_perf_event_open, sc->a1, sc->a2, sc->a3, sc->a4, sc->a5);
 if (fd != -1) {
 shm->perf_fds[i] = fd;
",33,5
move splice definitions to compat.h,"
 int, fd_out, loff_t __user *, off_out,
 size_t, len, unsigned int, flags)
 */
+#include <fcntl.h>
 #include <stdlib.h>
 #include ""random.h""
 #include ""sanitise.h""
 #include ""shm.h""
 #include ""syscall.h""
 #include ""trinity.h""
-
-//FIXME: Move to compat.h
-# define SPLICE_F_MOVE 1 /* Move pages instead of copying. */
-# define SPLICE_F_NONBLOCK 2 /* Don't block on the pipe splicing
- (but we may still block on the fd
- we splice from/to). */
-# define SPLICE_F_MORE 4 /* Expect more data. */
-# define SPLICE_F_GIFT 8 /* Pages passed in are a gift. */
+#include ""compat.h""
 
 static void sanitise_splice(__unused__ int childno, struct syscallrecord *rec)
 {
",43,4
move perf specific prototype out of sanitise.h into perf.h,"
 #include <errno.h>
 #include ""log.h""
 #include ""maps.h""
+#include ""perf.h""
 #include ""perf_event.h""
 #include ""random.h""
 #include ""sanitise.h""
",1037,252
"create an fd provider struct and iterate over it

baby steps towards dynamically creating fd tables.
Eventually this static struct will be allocated, and the various
fd generators will register their open/get operations.","
 #include ""random.h""
 #include ""sanitise.h""
 #include ""shm.h""
+#include ""utils.h""
 
 static int get_new_random_fd(void)
 {
 regen:
 return shm->current_fd;
 }
 
+struct fd_provider {
+void (*open)(void);
+};
+
+static struct fd_provider fd_providers[] = {
+{ .open = &open_pipes },
+{ .open = &open_perf_fds },
+{ .open = &open_epoll_fds },
+{ .open = &open_eventfd_fds },
+};
+
 unsigned int setup_fds(void)
 {
 int ret = TRUE;
+unsigned int i;
 
 /* If we have victim files, don't worry about sockets. */
 if (victim_path == NULL) {
 unsigned int setup_fds(void)
 return FALSE;
 }
 
-open_pipes();
-
-open_perf_fds();
-
-open_epoll_fds();
-
-open_eventfd_fds();
+for (i = 0; i < ARRAY_SIZE(fd_providers); i++)
+fd_providers[i].open();
 
 if (no_files == FALSE)
 ret = open_files();
",103,22
"make fd generator ->open's return whether they succeeded

and propagate that failure upwards","
 #include ""sanitise.h""
 #include ""shm.h""
 
-void open_epoll_fds(void)
+int open_epoll_fds(void)
 {
 unsigned int i = 0;
 int fd = -1;
 void open_epoll_fds(void)
 shm->epoll_fds[i] = fd;
 output(2, ""fd[%d] = epoll\n"", shm->epoll_fds[i]);
 i++;
+} else {
+/* not sure what happened. */
+output(0, ""epoll_create fail: %s\n"", strerror(errno));
+return FALSE;
 }
 }
+return TRUE;
 }
 
 int rand_epoll_fd(void)
",39,5
convert open_files invocation to use fd_provider struct," int open_files(void)
 {
 unsigned int i, nr_to_open;
 
+if (no_files == TRUE)
+return TRUE;
+
 generate_filelist();
 
 if (files_in_index == 0)/* Something bad happened. Crappy -V maybe? */
",271,62
convert open_sockets to use fd_provider struct," void close_sockets(void)
 nr_sockets = 0;
 }
 
-unsigned int open_sockets(void)
+int open_sockets(void)
 {
 int cachefile;
 unsigned int domain, type, protocol;
 unsigned int buffer[3];
-int bytesread=-1;
+int bytesread = -1;
 int fd;
 int ret;
 
+/* If we're doing victim files we probably don't care about sockets. */
+//FIXME: Is this really true ? We might want to sendfile for eg
+if (victim_path == NULL)
+return TRUE;
+
 cachefile = open(cachefilename, O_RDONLY);
 if (cachefile < 0) {
 output(1, ""Couldn't find socket cachefile. Regenerating.\n"");
",262,61
"initial pass at fd_provider->get

add a provider for sockets.

We won't be able to really clean out get_new_random_fd until the
dynamic conversion is complete. Until then it might have to grow
a few more special cases."," regenerate:
 
 return TRUE;
 }
+
+int get_socket_fd(void)
+{
+int fd;
+
+if (nr_sockets == 0)
+return -1;
+
+fd = shm->sockets[rand() % nr_sockets].fd;
+
+return fd;
+}
",270,63
convert pipe fd to use ->get," int open_pipes(void)
 return TRUE;
 }
 
-int rand_pipe_fd(void)
+int get_rand_pipe_fd(void)
 {
 return shm->pipe_fds[rand() % MAX_PIPE_FDS];
 }
",37,4
rename get_socket_fd to follow naming scheme," regenerate:
 return TRUE;
 }
 
-int get_socket_fd(void)
+int get_rand_socket_fd(void)
 {
 int fd;
 
",270,63
convert perf fd to use ->get," int open_perf_fds(void)
 return TRUE;
 }
 
-int rand_perf_fd(void)
+int get_rand_perf_fd(void)
 {
 return shm->perf_fds[rand() % MAX_PERF_FDS];
 }
",34,5
convert epoll fd to use ->get," int open_epoll_fds(void)
 return TRUE;
 }
 
-int rand_epoll_fd(void)
+int get_rand_epoll_fd(void)
 {
 return shm->epoll_fds[rand() % MAX_EPOLL_FDS];
 }
",39,5
convert eventfd fd to use ->get," int open_eventfd_fds(void)
 return TRUE;
 }
 
-int rand_eventfd_fd(void)
+int get_rand_eventfd_fd(void)
 {
 return shm->eventfd_fds[rand() % MAX_EVENTFD_FDS];
 }
",36,3
convert files fd to use ->get," const char * get_filename(void)
 return fileindex[rand() % files_in_index];
 }
 
-int rand_file_fd(void)
+int get_rand_file_fd(void)
 {
 unsigned int fd_index;
 
",271,62
move perf fd->get failure checking into the ->get function," int open_perf_fds(void)
 
 int get_rand_perf_fd(void)
 {
+if (shm->perf_fds[0] == 0)/* perf unavailable/disabled. */
+return -1;
+
 return shm->perf_fds[rand() % MAX_PERF_FDS];
 }
",36,6
move socket->get failure checking into the ->get function," int get_rand_socket_fd(void)
 {
 int fd;
 
+/* When using victim files, sockets can be 0. */
 if (nr_sockets == 0)
 return -1;
 
",270,63
move the files fd failure checking into the ->get function," int get_rand_file_fd(void)
 {
 unsigned int fd_index;
 
+if (no_files == TRUE)// FIXME: This should go away when we have dynamic fd reg
+return -1;
+
+if (nr_file_fds == 0)
+return -1;
+
 fd_index = rand() % nr_file_fds;
 return shm->file_fds[fd_index];
 }
",275,64
remove the specific_proto == always use socket fds assumption," static int get_new_random_fd(void)
 retry:
 i = rand() % 6;
 
-if (do_specific_proto == TRUE)
-i = 1;
-
 switch (i) {
 case 0:
 fd = get_rand_file_fd();
",91,15
convert get_new_random_fd to use the ->get operations," static struct fd_provider fd_providers[] = {
 
 static int get_new_random_fd(void)
 {
-unsigned int i;
-int fd = 0;
-
-retry:
-i = rand() % 6;
-
-switch (i) {
-case 0:
-fd = get_rand_file_fd();
-break;
-
-case 1:
-fd = get_rand_socket_fd();
-break;
+int fd = -1;
 
-case 2:
-fd = get_rand_pipe_fd();
-break;
-
-case 3:
-fd = get_rand_perf_fd();
-break;
-
-case 4:
-fd = get_rand_epoll_fd();
-break;
-
-case 5:
-fd = get_rand_eventfd_fd();
-break;
+while (fd < 0) {
+unsigned int i;
+i = rand() % ARRAY_SIZE(fd_providers);
+fd = fd_providers[i].get();
 }
 
-/* If one of the providers failed, retry with a different one */
-if (fd < 0)
-goto retry;
-
 return fd;
 }
 
",71,9
"dynamically register the fd providers

Split the structures out to their associated files.","
 #include <sys/eventfd.h>
 
 #include ""epoll.h""
+#include ""fd.h""
 #include ""log.h""
 #include ""net.h""
 #include ""params.h""

 #include ""sanitise.h""
 #include ""shm.h""
 
-int open_epoll_fds(void)
+static int open_epoll_fds(void)
 {
 unsigned int i = 0;
 int fd = -1;
 int open_epoll_fds(void)
 return TRUE;
 }
 
-int get_rand_epoll_fd(void)
+static int get_rand_epoll_fd(void)
 {
 return shm->epoll_fds[rand() % MAX_EPOLL_FDS];
 }
+
+struct fd_provider epoll_fd_provider = {
+.open = &open_epoll_fds,
+.get = &get_rand_epoll_fd,
+};
",44,5
special case adding the first node to shared_mappings list," static void alloc_zero_map(unsigned long size, int prot, const char *name)
 
 num_shared_mappings++;
 
-list = &shared_mappings->list;
-list_add_tail(&newnode->list, list);
+if (shared_mappings == NULL) {
+shared_mappings = newnode;
+INIT_LIST_HEAD(&shared_mappings->list);
+} else {
+list = &shared_mappings->list;
+list_add_tail(&newnode->list, list);
+}
 
 sizeunit(size, buf);
 output(2, ""mapping[%d]: (zeropage %s) %p (%s)\n"",
 void setup_shared_mappings(void)
 //1 * GB,// disabled for now, due to OOM.
 };
 
-shared_mappings = zmalloc(sizeof(struct map));
-INIT_LIST_HEAD(&shared_mappings->list);
-
 /* page_size * 2, so we have a guard page afterwards.
  * This is necessary for when we want to test page boundaries.
  * see end of _get_address() for details.
",92,10
"Revert ""special case adding the first node to shared_mappings list""

This reverts commit 4401f6d0f0bfdeb92595520dc3be23dee32efc77.

We need the list head to be untouched."," static void alloc_zero_map(unsigned long size, int prot, const char *name)
 
 num_shared_mappings++;
 
-if (shared_mappings == NULL) {
-shared_mappings = newnode;
-INIT_LIST_HEAD(&shared_mappings->list);
-} else {
-list = &shared_mappings->list;
-list_add_tail(&newnode->list, list);
-}
+list = &shared_mappings->list;
+list_add_tail(&newnode->list, list);
 
 sizeunit(size, buf);
 output(2, ""mapping[%d]: (zeropage %s) %p (%s)\n"",
 void setup_shared_mappings(void)
 //1 * GB,// disabled for now, due to OOM.
 };
 
+shared_mappings = zmalloc(sizeof(struct map));
+INIT_LIST_HEAD(&shared_mappings->list);
+
 /* page_size * 2, so we have a guard page afterwards.
  * This is necessary for when we want to test page boundaries.
  * see end of _get_address() for details.
",89,9
fix inverted test which meant we never init'd the socket fd's," static int open_sockets(void)
 
 /* If we're doing victim files we probably don't care about sockets. */
 //FIXME: Is this really true ? We might want to sendfile for eg
-if (victim_path == NULL)
+if (victim_path != NULL)
 return TRUE;
 
 cachefile = open(cachefilename, O_RDONLY);
",274,63
"separate fd provider list create/add.

We need the head node to be empty"," static void add_to_prov_list(struct fd_provider *prov)
 newnode->get = prov->get;
 num_fd_providers++;
 
-if (fd_providers == NULL) {
-fd_providers = newnode;
-INIT_LIST_HEAD(&fd_providers->list);
-} else {
-list_add_tail(&newnode->list, &fd_providers->list);
-}
+list_add_tail(&newnode->list, &fd_providers->list);
 }
 
 static void setup_fd_providers(void)
 {
+fd_providers = zmalloc(sizeof(struct fd_provider));
+INIT_LIST_HEAD(&fd_providers->list);
+
 add_to_prov_list(&socket_fd_provider);
 add_to_prov_list(&pipes_fd_provider);
 add_to_prov_list(&perf_fd_provider);
",94,11
remove unnecessary local var," static int ignore_files(const char *path)
 static void add_to_namelist(const char *name)
 {
 struct namelist *newnode;
-struct list_head *list = (struct list_head *) names;
 
 newnode = zmalloc(sizeof(struct namelist));
 newnode->name = strdup(name);
-list_add_tail(&newnode->list, list);
+list_add_tail(&newnode->list, &names->list);
 }
 
 static int check_stat_file(const struct stat *sb)
",279,64
remove another unneeded local var," static void dump_shared_mappings(void)
 static void alloc_zero_map(unsigned long size, int prot, const char *name)
 {
 struct map *newnode;
-struct list_head *list;
 int fd;
 char buf[10];
 
 static void alloc_zero_map(unsigned long size, int prot, const char *name)
 
 num_shared_mappings++;
 
-list = &shared_mappings->list;
-list_add_tail(&newnode->list, list);
+list_add_tail(&newnode->list, &shared_mappings->list);
 
 sizeunit(size, buf);
 output(2, ""mapping[%d]: (zeropage %s) %p (%s)\n"",
",87,9
dump the O_RD|O_WR flags too," retry_flags:
 case O_RDWR: modestr = ""read-write""; break;
 default: modestr = ""unknown""; break;
 }
-output(2, ""fd[%i] = %s (%s) flags:%x\n"", fd, filename, modestr, randflags);
+output(2, ""fd[%i] = %s (%s) flags:%x\n"", fd, filename, modestr, flags | randflags);
 return fd;
 }
 
",283,65
returning from this impossible situation is probably a bad idea.,"
 */
 void exit_main_fail(void)
 {
-if (getpid() != shm->mainpid) {
-printf(""wtf, exit_main_fail called from non main pid!\n"");
-return;
-}
+if (getpid() != shm->mainpid)
+BUG(""wtf, exit_main_fail called from non main pid!\n"");
+
 shm->mainpid = 0;
 exit(EXIT_FAILURE);
 }
",232,51
replace open-coded min with min invocation.," static int open_files(void)
 if (files_in_index == 0)/* Something bad happened. Crappy -V maybe? */
 return FALSE;// FIXME: We should log something here probably.
 
-if (files_in_index < NR_FILE_FDS)
-nr_to_open = files_in_index;
-else
-nr_to_open = NR_FILE_FDS;
+nr_to_open = min(files_in_index, NR_FILE_FDS);
 
 if (fileindex == NULL)/* this can happen if we ctrl-c'd */
 return FALSE;
",280,64
fix sign bit errors picked up by sanitize=undefined," unsigned int rand_bool(void)
 
 static unsigned int rand_single_bit(unsigned char size)
 {
-return (1L << (rand() % size));
+return (1UL << (rand() % size));
 }
 
 /*
 static unsigned int rand_single_bit(unsigned char size)
 */
 static unsigned long randbits(int limit)
 {
-unsigned int num = rand() % limit / 2;
+unsigned int num = rand() % (limit / 2);
 unsigned int i;
 unsigned long r = 0;
 
 for (i = 0; i < num; i++)
-r |= (1 << (rand() % (limit - 1)));
+r |= (1UL << (rand() % (limit - 1)));
 
 return r;
 }
 u64 rand64(void)
 
 rounds = rand() % 4;
 for (i = 0; i < rounds; i++)
-r |= (1L << ((__WORDSIZE - 1) - (rand() % 8)));
+r |= (1UL << ((__WORDSIZE - 1) - (rand() % 8)));
 }
 
 /* randomly flip sign bit. */
 if (rand_bool())
-r |= (1L << (__WORDSIZE - 1));
+r |= (1UL << (__WORDSIZE - 1));
 
 return r;
 }
",174,55
fix another sanitize=undefined error," unsigned int get_interesting_32bit_value(void)
 break;
 case 1:num = rand() % 256;// 00-0xff
 break;
-case 2:num = 1 << (rand() % 32);// set a single bit.
+case 2:num = 1UL << (rand() % 32);// set a single bit.
 break;
 case 3:num = 0x8fffffff;
 break;
",85,39
fix yet another sign bit error," static void do_setsockopt(struct sockopt *so)
  * This should catch new options we don't know about, and also maybe some missing bounds checks.
  */
 if ((rand() % 100) < 10)
-so->optname |= (1 << (rand() % 32));
+so->optname |= (1UL << (rand() % 32));
 
 /* optval should be nonzero to enable a boolean option, or zero if the option is to be disabled.
  * Let's disable it half the time.
",117,10
make rand_range operate on unsigned ints.,"
 #include ""types.h""
 #include ""utils.h""
 
-int rand_range(int min, int max)
+unsigned int rand_range(unsigned int min, unsigned int max)
 {
 if (min > max)
 swap(min, max);
",174,55
fix some shifting errors in mremap fixed addr calculation," static void sanitise_mremap(int childno, struct syscallrecord *rec)
 
 if (rec->a4 & MREMAP_FIXED) {
 unsigned long align = alignments[rand() % ARRAY_SIZE(alignments)];
-int shift = (__WORDSIZE / 2) - 1;
+unsigned int shift = (__WORDSIZE / 2) - 1;
 
-newaddr = rand() % 256 << rand() % shift;
+newaddr = rand() % 256;
+newaddr <<= rand() % shift;
 newaddr |= align;
 newaddr &= ~(align - 1);
 }
",59,5
make random page generation care about alignment.," static void fabricate_onepage_struct(char *page)
 void **ptr;
 
 ptr = (void*)&page[i];
-switch (rand() % 4) {
-case 0:
-i += sizeof(unsigned int);
-if (i > page_size)
-return;
-*(unsigned int *)ptr = rand32();
-break;
-case 1:
+
+/* 4 byte (32bit) 8 byte (64bit) alignment */
+if (i & ~((__WORDSIZE / 8) - 1)) {
+unsigned long val;
+
 i += sizeof(unsigned long);
 if (i > page_size)
 return;
-*(unsigned long *)ptr = rand64();
-break;
-case 2:
-i += sizeof(void *);
-if (i > page_size)
-return;
-*ptr = get_address();
-break;
-case 3:
+
+if (rand_bool())
+val = rand64();
+else
+val = (unsigned long) get_address();
+
+*(unsigned long *)ptr = val;
+
+} else {
+/* int alignment */
+unsigned int val;
+
 i += sizeof(unsigned int);
 if (i > page_size)
 return;
-*(unsigned int *)ptr = rand() % page_size;
-break;
+
+if (rand_bool())
+val = rand32();
+else
+val = rand() % page_size;
+
+*(unsigned int *)ptr = val;
 }
 }
 }
",117,35
add masking of PAGE_MASK in rand32,"
 #include <stdlib.h>
 #include <sys/types.h>
 #include <limits.h>
+#include ""arch.h""
 #include ""pids.h""
 #include ""random.h""
 #include ""sanitise.h""// interesting_numbers
 unsigned int rand32(void)
 }
 
 /* limit the size */
-switch (rand() % 4) {
+switch (rand() % 5) {
 case 0: r &= 0xff;
 break;
 case 1: r &= 0xffff;
 break;
-case 2: r &= 0xffffff;
+case 2: r &= PAGE_MASK;
+break;
+case 3: r &= 0xffffff;
+break;
+case 4:// do nothing
 break;
 }
 
",179,57
replace open-coded PAGE_MASK with use of define," void create_shm(void)
 unsigned int shm_pages;
 
 /* round up shm to nearest page size */
-shm_pages = ((sizeof(struct shm_s) + page_size - 1) & ~(page_size - 1)) / page_size;
+shm_pages = ((sizeof(struct shm_s) + page_size - 1) & PAGE_MASK) / page_size;
 
 /* Waste some address space to set up some ""protection"" near the SHM location. */
 p = alloc_shared((SHM_PROT_PAGES + shm_pages + SHM_PROT_PAGES) * page_size);
",60,5
fabricate_onepage_struct can now just use rand32," static void fabricate_onepage_struct(char *page)
 
 } else {
 /* int alignment */
-unsigned int val;
 
 i += sizeof(unsigned int);
 if (i > page_size)
 return;
 
-if (rand_bool())
-val = rand32();
-else
-val = rand() % page_size;
-
-*(unsigned int *)ptr = val;
+*(unsigned int *)ptr = rand32();
 }
 }
 }
",112,34
"Fix buffer overflow in output() when pid slot is not found

In output() we sprintf() the result of find_pid_slot(). We print the pid
slot to the buffer with %u and have space for two digits of pid slot.
find_pid_slot() potentially returns PIDSLOT_NOT_FOUND (-1), which when
printed with %u is 4294967295 - ten digits.

Fix it two ways, use snprintf() - truncated output is better than a
buffer overflow. And allocate more space in the buffer, 32 bytes is a
nice round size, and gives us space for everything."," void output(unsigned char level, const char *fmt, ...)
 char watchdog_prefix[]=""[watchdog]"";
 char init_prefix[]=""[init]"";
 char main_prefix[]=""[main]"";
-char child_prefix[]=""[childNN:1234567890]"";
+char child_prefix[32];
 
 if (logging == FALSE && level >= quiet_level)
 return;
 void output(unsigned char level, const char *fmt, ...)
 unsigned int slot;
 
 slot = find_pid_slot(pid);
-sprintf(child_prefix, ""[child%u:%u]"", slot, pid);
+snprintf(child_prefix, sizeof(child_prefix), ""[child%u:%u]"", slot, pid);
 prefix = child_prefix;
 }
 
",388,102
"Add an IGNORE_ENOSYS flag and use it

Some syscalls return ENOSYS depending on their arguments. We don't want
to stop calling them just because we hit one of those cases. Add a flag
to specify this behaviour so we don't have to keep special-casing those
calls in mkcall()."," struct syscallentry syscall_ioctl = {
 .arg3name = ""arg"",
 .arg3type = ARG_RANDPAGE,
 .sanitise = sanitise_ioctl,
-.flags = NEED_ALARM,
+.flags = NEED_ALARM | IGNORE_ENOSYS,
 };
",56,11
"Mark perf_event_open() with IGNORE_ENOSYS

At the very least specifying PERF_SAMPLE_STACK_USER will return ENOSYS
on arches that don't implement it."," struct syscallentry syscall_perf_event_open = {
 },
 .sanitise = sanitise_perf_event_open,
 .init = init_pmus,
-.flags = NEED_ALARM,
+.flags = NEED_ALARM | IGNORE_ENOSYS,
 };
",1037,252
"fix another buffer overflow

now that we handle >64 pids, we can overflow the 512 byte array here
quite easily. print out everything one line at a time instead."," void dump_pid_slots(void)
 sptr += sprintf(sptr, ""## pids: (%u active)\n"", shm->running_childs);
 
 for (i = 0; i < max_children; i += 8) {
-sptr += sprintf(sptr, ""%u-%u: "", i, i+7);
+sptr += sprintf(sptr, ""%u-%u: "", i, i + 7);
 for (j = 0; j < 8; j++) {
-if (shm->pids[i+j] != EMPTY_PIDSLOT) {
-if (pid_alive(shm->pids[i+j] == -1))
+if (shm->pids[i + j] != EMPTY_PIDSLOT) {
+if (pid_alive(shm->pids[i + j] == -1))
 RED
 }
 
-sptr += sprintf(sptr, ""%d "", shm->pids[i+j]);
+sptr += sprintf(sptr, ""%d "", shm->pids[i + j]);
 CRESET
 }
 sptr += sprintf(sptr, ""\n"");
+*sptr = '\0';
+outputerr(""%s"", string);
+sptr = string;
 }
-*sptr = '\0';
-outputerr(""%s"", string);
 }
 
 static pid_t pidmax;
",111,26
commentary around the execve special casing," bool mkcall(int childno)
 extrapid = fork();
 if (extrapid == 0) {
 ret = do_syscall(childno, &errno_saved);
+/* We should never get here. */
 syscallrec->retval = ret;
 _exit(EXIT_SUCCESS);
 } else {
 bool mkcall(int childno)
 sleep(1);
 kill(extrapid, SIGKILL);
 }
+//FIXME: Why would we only do this once ?
 generic_free_arg(childno);
 return FALSE;
 }
",136,20
remove syscallnr param from output_syscall_prefix," static void output_syscall_prefix_to_fd(const unsigned int childno, const unsign
 }
 
 /* This function is always called from a fuzzing child. */
-void output_syscall_prefix(const unsigned int childno, const unsigned int syscallnr)
+void output_syscall_prefix(const unsigned int childno)
 {
 FILE *log_handle;
+unsigned int syscallnr = shm->syscall[childno].nr;
 
 /* Exit if should not continue at all. */
 if (logging == FALSE && quiet_level < MAX_LOGLEVEL)
",389,102
remove err param from output_syscall_postfix," static void output_syscall_postfix_success(unsigned long ret, FILE *fd, bool mon
 fflush(fd);
 }
 
-void output_syscall_postfix(unsigned long ret, int errno_saved, bool err)
+void output_syscall_postfix(unsigned long ret, int errno_saved)
 {
 FILE *log_handle;
+bool err = IS_ERR(ret);
 
 /* Exit if should not continue at all. */
 if (logging == FALSE && quiet_level < MAX_LOGLEVEL)
",390,102
store the result of errno post syscall in the syscall record," static void output_syscall_postfix_success(unsigned long ret, FILE *fd, bool mon
 fflush(fd);
 }
 
-void output_syscall_postfix(unsigned long ret, int errno_saved)
+void output_syscall_postfix(int childno, unsigned long ret)
 {
+struct syscallrecord *rec;
 FILE *log_handle;
 bool err = IS_ERR(ret);
 
+rec = &shm->syscall[childno];
+
 /* Exit if should not continue at all. */
 if (logging == FALSE && quiet_level < MAX_LOGLEVEL)
 return;
 void output_syscall_postfix(unsigned long ret, int errno_saved)
 
 if (err) {
 if ((logging == TRUE) && (log_handle != NULL))
-output_syscall_postfix_err(ret, errno_saved, log_handle, TRUE);
+output_syscall_postfix_err(ret, rec->errno_post, log_handle, TRUE);
 if (quiet_level == MAX_LOGLEVEL)
-output_syscall_postfix_err(ret, errno_saved, stdout, monochrome);
+output_syscall_postfix_err(ret, rec->errno_post, stdout, monochrome);
 } else {
 if ((logging == TRUE) && (log_handle != NULL))
 output_syscall_postfix_success(ret, log_handle, TRUE);
",392,102
remove ret param from output_syscall_postfix," bool mkcall(int childno)
 else
 shm->successes++;
 
-output_syscall_postfix(childno, ret);
+output_syscall_postfix(childno);
 if (dopause == TRUE)
 sleep(1);
 
",135,20
"introduce a state field to track syscall records

This will be useful later when dumping them in post-mortem situations"," void init_child(int childno)
 
 setup_page_maps();
 
+shm->syscall[childno].state = UNKNOWN;
+
 if (sched_getaffinity(pid, sizeof(set), &set) == 0) {
 CPU_ZERO(&set);
 CPU_SET(childno, &set);
",229,43
childno can be signed.," void outputstd(const char *fmt, ...)
 va_end(args);
 }
 
-static void output_syscall_prefix_to_fd(const unsigned int childno, FILE *fd, bool mono)
+static void output_syscall_prefix_to_fd(int childno, FILE *fd, bool mono)
 {
 struct syscallentry *entry;
 struct syscallrecord *rec;
 static void output_syscall_prefix_to_fd(const unsigned int childno, FILE *fd, bo
 }
 
 /* This function is always called from a fuzzing child. */
-void output_syscall_prefix(const unsigned int childno)
+void output_syscall_prefix(int childno)
 {
 FILE *log_handle;
 
",397,102
"move the post mortem code out to its own file

it will grow some later when the syscallrecord dumping is added,
and watchdog.c is getting a little cluttered","
+#include <syslog.h>
+#include <sys/time.h>
+#include ""log.h""
+#include ""shm.h""
+#include ""taint.h""
+#include ""post-mortem.h""
+
+void tainted_postmortem(int taint)
+{
+shm->exit_reason = EXIT_KERNEL_TAINTED;
+
+gettimeofday(&shm->taint_tv, NULL);
+
+output(0, ""kernel became tainted! (%d/%d) Last seed was %u\n"",
+taint, kernel_taint_initial, shm->seed);
+
+openlog(""trinity"", LOG_CONS|LOG_PERROR, LOG_USER);
+syslog(LOG_CRIT, ""Detected kernel tainting. Last seed was %u\n"", shm->seed);
+closelog();
+}
",16,1
close small race between reading fd and other related args," unsigned int check_if_fd(unsigned int child)
 
 syscallrec = &shm->syscall[child];
 
-/* shortcut, if it's out of range, it's not going to be valid. */
+lock(&syscallrec->lock);
 fd = syscallrec->a1;
+callno = syscallrec->nr;
+do32 = syscallrec->do32bit;
+unlock(&syscallrec->lock);
+
+/* shortcut, if it's out of range, it's not going to be valid. */
 if (fd > 1024)
 return FALSE;
 
 unsigned int check_if_fd(unsigned int child)
 if (fd < highest)
 return FALSE;
 
-lock(&syscallrec->lock);
-callno = syscallrec->nr;
-do32 = syscallrec->do32bit;
-unlock(&syscallrec->lock);
-
 if (biarch == FALSE) {
 if (syscalls[callno].entry->arg1type == ARG_FD)
 return TRUE;
",352,71
"remove old debug code

this issue got fixed when locking was added to the syscallrecord"," unsigned int check_if_fd(unsigned int child)
 if (syscalls_32bit[callno].entry->arg1type == ARG_FD)
 return TRUE;
 } else {
-if (callno > max_nr_64bit_syscalls) {
-output(0, ""Weird, child:%d callno:%d (64bit max:%d)\n"", child, callno, max_nr_64bit_syscalls);
-return FALSE;
-}
 if (syscalls_64bit[callno].entry->arg1type == ARG_FD)
 return TRUE;
 }
",348,70
only fsync log files that have been dirtied," static void truncate_log(int childno)
 {
 int fd;
 
+shm->logdirty[childno] = FALSE;
+
 if (logging == FALSE)
 return;
 
",230,43
"make toggle_syscall_biarch_n static

(also, holy shit that prototype is awful, could it take any more args?
 Something to revisit one day)"," int validate_syscall_table_32(void)
 return use_32bit;
 }
 
-void toggle_syscall_biarch_n(int calln, const struct syscalltable *table, bool onlyflag, bool doflag, bool state, void (*activate)(unsigned int), int arch_bits, const char *arg_name)
+static void toggle_syscall_biarch_n(int calln, const struct syscalltable *table,
+ bool onlyflag, bool doflag, bool state,
+ void (*activate)(unsigned int),
+ int arch_bits, const char *arg_name)
 {
 if (calln != -1) {
 struct syscallentry *entry = table[calln].entry;
",307,73
syscallrec -> rec as elsewhere," static int open_perf_fds(void)
 unsigned int i = 0;
 
 while (i < MAX_PERF_FDS) {
-struct syscallrecord* sc;
+struct syscallrecord *rec;
 int fd;
 
-sc = &shm->syscall[0];
-sanitise_perf_event_open(0, sc);
+rec = &shm->syscall[0];
+sanitise_perf_event_open(0, rec);
 
-fd = syscall(__NR_perf_event_open, sc->a1, sc->a2, sc->a3, sc->a4, sc->a5);
+fd = syscall(__NR_perf_event_open, rec->a1, rec->a2, rec->a3, rec->a4, rec->a5);
 if (fd != -1) {
 shm->perf_fds[i] = fd;
 output(2, ""fd[%d] = perf\n"", shm->perf_fds[i]);
",41,6
remove potential usage of -1 as an index," void deactivate_syscall_uniarch(unsigned int calln)
 
 void toggle_syscall_n(int calln, bool state, const char *arg, const char *arg_name)
 {
-struct syscallentry *entry = syscalls[calln].entry;
+struct syscallentry *entry;
 
 if (calln == -1) {
 outputerr(""No idea what syscall (%s) is.\n"", arg);
 void toggle_syscall_n(int calln, bool state, const char *arg, const char *arg_na
 
 validate_specific_syscall(syscalls, calln);
 
+entry = syscalls[calln].entry;
+
 if (state == TRUE) {
 entry->flags |= ACTIVE;
 activate_syscall(calln);
",141,28
"remove knowledge of biarch/syscall tables from watchdog.

move into get_syscall_entry function"," int munge_tables(void)
 
 return TRUE;
 }
+
+/*
+ * return a ptr to a syscall table entry, allowing calling code to be
+ * ignorant about things like biarch.
+ */
+struct syscallentry * get_syscall_entry(unsigned int callno, bool do32)
+{
+if (biarch == FALSE)
+return syscalls[callno].entry;
+
+/* biarch case */
+if (do32 == TRUE)
+return syscalls_32bit[callno].entry;
+else
+return syscalls_64bit[callno].entry;
+}
",408,116
"skeleton of the dumping pidslot work

ifdef'd out for now until I figure out how I'm going to make
output_syscall_* output just to the post mortem file.","
 #include <syslog.h>
 #include <sys/time.h>
 #include ""log.h""
+#include ""pids.h""
 #include ""shm.h""
 #include ""taint.h""
 #include ""post-mortem.h""
 
+#if 0
+static void dump_syscall_rec(int childno)
+{
+struct syscallrecord *rec;
+
+rec = &shm->syscall[childno];
+
+switch (rec->state) {
+case UNKNOWN:
+/* new child, so nothing to dump. */
+break;
+case PREP:
+/* haven't finished setting up, so don't dump. */
+break;
+case BEFORE:
+output_syscall_prefix(childno);
+break;
+case AFTER:
+output_syscall_prefix(childno);
+output_syscall_postfix(childno);
+break;
+case GOING_AWAY:
+output_syscall_prefix(childno);
+break;
+}
+}
+
+static void dump_syscall_records(void)
+{
+unsigned int i;
+
+for_each_pidslot(i) {
+dump_syscall_rec(i);
+}
+}
+#endif
+
 void tainted_postmortem(int taint)
 {
 shm->exit_reason = EXIT_KERNEL_TAINTED;
",45,8
rename for_each_pidslot to for_each_child," static void check_parent_pid(void)
 pid, shm->mainpid, watchdog_pid);
 output(0, BUGTXT ""Last syscalls:\n"");
 
-for_each_pidslot(i) {
+for_each_child(i) {
 // Skip over 'boring' entries.
 if ((shm->pids[i] == EMPTY_PIDSLOT) &&
  (shm->previous[i].nr == 0) &&
",230,43
rename pidslot vars to childno," void init_child(int childno)
 
 oom_score_adj(500);
 
-/* Wait for parent to set our pidslot */
+/* Wait for parent to set our childno */
 while (shm->pids[childno] != getpid()) {
 int ret = 0;
 
",230,43
"more pidslot -> childno conversions

find_pid_slot -> find_childno
dump_pid_slots -> dump_childnos"," static FILE * find_logfile_handle(void)
 if (pid == watchdog_pid)
 return mainlogfile;
 
-i = find_pid_slot(pid);
+i = find_childno(pid);
 if (i != PIDSLOT_NOT_FOUND)
 return shm->logfiles[i];
 else {
 static FILE * find_logfile_handle(void)
 unsigned int j;
 
 sleep(1);
-i = find_pid_slot(pid);
+i = find_childno(pid);
 if (i != PIDSLOT_NOT_FOUND)
 return shm->logfiles[i];
 
 outputerr(""## Couldn't find logfile for pid %d\n"", pid);
-dump_pid_slots();
+dump_childnos();
 outputerr(""## Logfiles for pids: "");
 for_each_child(j)
 outputerr(""%p "", shm->logfiles[j]);
 void output(unsigned char level, const char *fmt, ...)
 if (prefix == NULL) {
 unsigned int slot;
 
-slot = find_pid_slot(pid);
+slot = find_childno(pid);
 snprintf(child_prefix, sizeof(child_prefix), ""[child%u:%u]"", slot, pid);
 prefix = child_prefix;
 shm->logdirty[slot] = TRUE;
",401,103
PIDSLOT_NOT_FOUND -> CHILD_NOT_FOUND," static FILE * find_logfile_handle(void)
 return mainlogfile;
 
 i = find_childno(pid);
-if (i != PIDSLOT_NOT_FOUND)
+if (i != CHILD_NOT_FOUND)
 return shm->logfiles[i];
 else {
 /* try one more time. FIXME: This is awful. */
 static FILE * find_logfile_handle(void)
 
 sleep(1);
 i = find_childno(pid);
-if (i != PIDSLOT_NOT_FOUND)
+if (i != CHILD_NOT_FOUND)
 return shm->logfiles[i];
 
 outputerr(""## Couldn't find logfile for pid %d\n"", pid);
",401,103
EXIT_LOST_PIDSLOT -> EXIT_LOST_CHILD," static void handle_child(pid_t childpid, int childstatus)
 if (slot == CHILD_NOT_FOUND) {
 /* If we reaped it, it wouldn't show up, so check that. */
 if (shm->last_reaped != childpid) {
-outputerr(""## Couldn't find pid slot for %d\n"", childpid);
-shm->exit_reason = EXIT_LOST_PID_SLOT;
+outputerr(""## Couldn't find %d in list of pids.\n"", childpid);
+shm->exit_reason = EXIT_LOST_CHILD;
 dump_childnos();
 }
 } else {
",232,51
slot -> childno variable replacements," void output(unsigned char level, const char *fmt, ...)
 prefix = main_prefix;
 
 if (prefix == NULL) {
-unsigned int slot;
+unsigned int childno;
 
-slot = find_childno(pid);
-snprintf(child_prefix, sizeof(child_prefix), ""[child%u:%u]"", slot, pid);
+childno = find_childno(pid);
+snprintf(child_prefix, sizeof(child_prefix), ""[child%u:%u]"", childno, pid);
 prefix = child_prefix;
-shm->logdirty[slot] = TRUE;
+shm->logdirty[childno] = TRUE;
 }
 
 /* formatting output */
",401,103
pass an fd to the syscall record dumper.,"
-#include <syslog.h>
 #include <sys/time.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <string.h>
+#include <syslog.h>
 #include ""log.h""
 #include ""pids.h""
 #include ""shm.h""

 #include ""post-mortem.h""
 
 #if 0
-static void dump_syscall_rec(int childno)
+static void dump_syscall_rec(int childno, int fd)
 {
 struct syscallrecord *rec;
 
 static void dump_syscall_rec(int childno)
 
 static void dump_syscall_records(void)
 {
+int fd;
 unsigned int i;
 
+fd = open(""trinity-post-mortem.log"", O_WRONLY);
+if (fd < 0) {
+outputerr(""Failed to write post mortem log (%s)\n"", strerrror(errno));
+return;
+}
+
 for_each_child(i) {
-dump_syscall_rec(i);
+dump_syscall_rec(i, fd);
 }
+
+close(fd);
 }
 #endif
 
",56,9
export output_syscall_prefix_to_fd for use in the syscall record dumper," void outputstd(const char *fmt, ...)
 va_end(args);
 }
 
-static void output_syscall_prefix_to_fd(int childno, FILE *fd, bool mono)
+/*
+ * Used from output_syscall_prefix, and also from postmortem dumper
+ */
+void output_syscall_prefix_to_fd(int childno, FILE *fd, bool mono)
 {
 struct syscallentry *entry;
 struct syscallrecord *rec;
",401,103
"export output_syscall_postfix_err and output_syscall_postfix_success

for use in the syscall record dumper"," void output_syscall_prefix(int childno)
 output_syscall_prefix_to_fd(childno, stdout, monochrome);
 }
 
-static void output_syscall_postfix_err(unsigned long ret, int errno_saved, FILE *fd, bool mono)
+void output_syscall_postfix_err(unsigned long ret, int errno_saved, FILE *fd, bool mono)
 {
 REDFD
 fprintf(fd, ""= %ld (%s)"", (long) ret, strerror(errno_saved));
 static void output_syscall_postfix_err(unsigned long ret, int errno_saved, FILE
 fflush(fd);
 }
 
-static void output_syscall_postfix_success(unsigned long ret, FILE *fd, bool mono)
+void output_syscall_postfix_success(unsigned long ret, FILE *fd, bool mono)
 {
 GREENFD
 if ((unsigned long)ret > 10000)
",401,103
don't allow multiple children to update syscall entries at once.," bool mkcall(int childno)
  * those as IGNORE_ENOSYS and keep calling them.
  */
 if ((ret == -1UL) && (rec->errno_post == ENOSYS) && !(entry->flags & IGNORE_ENOSYS)) {
+lock(&shm->syscalltable_lock);
+
+/* check another thread didn't already do this. */
+if (!(entry->flags & ACTIVE))
+goto already_done;
+
 output(1, ""%s (%d) returned ENOSYS, marking as inactive.\n"",
 entry->name, call + SYSCALL_OFFSET);
 
 deactivate_syscall(call, rec->do32bit);
+already_done:
+unlock(&shm->syscalltable_lock);
 }
 
 if (entry->post)
",146,21
"make dump_syscall_rec take a record arg

now we can pass both the previous, as well as the current record.","
 #include ""post-mortem.h""
 
 #if 0
-static void dump_syscall_rec(int childno, int fd)
+static void dump_syscall_rec(int childno, int fd, struct syscallrecord *rec)
 {
-struct syscallrecord *rec;
-
-rec = &shm->syscall[childno];
-
 switch (rec->state) {
 case UNKNOWN:
 /* new child, so nothing to dump. */
 static void dump_syscall_records(void)
 }
 
 for_each_child(i) {
-dump_syscall_rec(i, fd);
+dump_syscall_rec(i, fd, &shm->previous[childno]);
+dump_syscall_rec(i, fd, &shm->syscall[childno]);
 }
 
 close(fd);
",59,10
introduce a DONE state for use in the previous syscall record.," static void dump_syscall_rec(int childno, int fd, struct syscallrecord *rec)
 output_syscall_prefix_to_fd(childno, fd, TRUE);
 break;
 case AFTER:
+case DONE:
 output_syscall_prefix_to_fd(childno, fd, TRUE);
 err = IS_ERR(rec->retval);
 if (err)
",60,11
"make output_syscall_prefix_to_fd use the child pid in the shm

getpid() will give the wrong answer when we call it from the
postmortem routine."," void output_syscall_prefix_to_fd(int childno, FILE *fd, bool mono)
 {
 struct syscallentry *entry;
 struct syscallrecord *rec;
-pid_t pid;
 unsigned int i;
 unsigned int syscallnr;
 
 void output_syscall_prefix_to_fd(int childno, FILE *fd, bool mono)
 syscallnr = rec->nr;
 entry = syscalls[syscallnr].entry;
 
-pid = getpid();
-
-fprintf(fd, ""[child%u:%u] [%lu] %s"", childno, pid,
+fprintf(fd, ""[child%u:%u] [%lu] %s"", childno, shm->pids[childno],
 shm->child_op_count[childno],
 (rec->do32bit == TRUE) ? ""[32BIT] "" : """");
 
",399,103
"reorder decode args so childno comes first

like all the other syscall entry functions."," static void output_arg(unsigned int argnum, struct syscallentry *entry, FILE *fd
 if (entry->decode != NULL) {
 char *str;
 
-str = entry->decode(argnum, childno);
+str = entry->decode(childno, argnum);
 if (str != NULL) {
 fprintf(fd, ""%s"", str);
 free(str);
",399,103
replace open-coded for_each_child loop," void init_shm(void)
 /* Set seed in parent thread */
 set_seed(0);
 
-for (i = 0; i < max_children; i++) {
-
+for_each_child(i) {
 shm->pids[i] = EMPTY_PIDSLOT;
 
 shm->previous[i].nr = shm->syscall[i].nr = -1;
",61,4
move locking related stuff out of watchdog.c to locks.c," static inline long IS_ERR(unsigned long x)
 }
 
 void sizeunit(unsigned long size, char *buf);
+
+void kill_pid(pid_t pid);
",13,1
"remove text about oom killer.

why they disappear is a mystery, but it isn't (usually) the oom killer"," static unsigned int reap_dead_kids(void)
 /* If it disappeared, reap it. */
 if (ret == -1) {
 if (errno == ESRCH) {
-output(0, ""pid %d has disappeared (oom-killed maybe?). Reaping.\n"", pid);
+output(0, ""pid %d has disappeared. Reaping.\n"", pid);
 reap_child(pid);
 reaped++;
 } else {
",305,58
"kill off page_zeros/page_0xff

just use page_rand to generate them randomly."," static void use_fpu(void)
 
 int this_child = 0;
 
-static void setup_page_maps(void)
-{
-unsigned long *page;
-unsigned int i;
-
-page = (void *) page_maps;
-
-for (i = 0; i < page_size / sizeof(unsigned long); i++) {
-struct map *map;
-
-map = get_map();
-page[i] = (unsigned long) map->ptr;
-}
-}
-
 static void oom_score_adj(int adj)
 {
 FILE *fp;
 void init_child(int childno)
 shm->mappings[childno] = zmalloc(sizeof(struct map));
 INIT_LIST_HEAD(&shm->mappings[childno]->list);
 
-setup_page_maps();
+generate_random_page(page_rand);
 
 shm->syscall[childno].state = UNKNOWN;
 
",219,41
fold the page_rand code from maps-static.c into random-page.c,"
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
+#include <malloc.h>
 
 #include ""arch.h""// page_size
 #include ""random.h""

 #include ""maps.h""
 #include ""log.h""// For BUG
 
+char *page_rand;
+
 static void fabricate_onepage_struct(char *page)
 {
 unsigned int i;
 void generate_random_page(char *page)
 break;
 }
 }
+
+void init_page_rand(void)
+{
+page_rand = (char *) memalign(page_size, page_size * 2);
+if (!page_rand)
+exit(EXIT_FAILURE);
+
+output(2, ""page_rand @ %p\n"", page_rand);
+
+generate_random_page(page_rand);
+}
",132,39
remove untrue comment,"
 #include ""random.h""
 #include ""sanitise.h""// get_address
 #include ""maps.h""
-#include ""log.h""// For BUG
+#include ""log.h""
 
 char *page_rand;
 
",132,39
"remove duplicate memset 0 case

Make it pick a random byte to fill a page with instead."," void generate_random_page(char *page)
 return;
 
 case 2:
-memset(page, 0, page_size);
+memset(page, rand() % 0xff, page_size);
 return;
 
 /* return a page of complete trash */
",132,39
transform check_parent_pid into a generic function to delay work.," static void check_parent_pid(void)
 {
 pid_t pid;
 unsigned int i;
-static unsigned int parent_check_time = 10;
-
-parent_check_time--;
-if (parent_check_time != 0)
-return;
-
-parent_check_time = 10;
 
 if (getppid() == shm->mainpid)
 return;
 static void check_parent_pid(void)
 //TODO: Emergency logging.
 }
 
+/*
+ * Here we call various functions that perform checks/changes that
+ * we don't want to happen on every iteration of the child loop.
+ */
+static void periodic_work(void)
+{
+static unsigned int periodic_counter = 0;
+
+periodic_counter++;
+if (periodic_counter < 10)
+return;
+
+check_parent_pid();
+
+periodic_counter = 0;
+}
+
 struct child_funcs {
 const char *name;
 bool (*func)(int childno);
 void child_process(int childno)
 while (shm->exit_reason == STILL_RUNNING) {
 unsigned int i;
 
-check_parent_pid();
+periodic_work();
 
 /* If the parent reseeded, we should reflect the latest seed too. */
 if (shm->seed != shm->seeds[childno])
",223,42
regenerate random page every 100 iterations of the child loop," static void periodic_work(void)
 if (periodic_counter < 10)
 return;
 
-check_parent_pid();
+/* Every ten iterations. */
+if (!(periodic_counter % 10))
+check_parent_pid();
 
-periodic_counter = 0;
+/* Every hundred iterations. */
+if (!(periodic_counter % 100))
+generate_random_page(page_rand);
+
+if (periodic_counter == 100)
+periodic_counter = 0;
 }
 
 struct child_funcs {
",227,45
"fix the ""is syscall active"" check"," bool mkcall(int childno)
 lock(&shm->syscalltable_lock);
 
 /* check another thread didn't already do this. */
-if (!(entry->flags & ACTIVE))
+if (entry->active_number == 0)
 goto already_done;
 
 output(1, ""%s (%d) returned ENOSYS, marking as inactive.\n"",
",147,21
output whether the syscall being disabled is 32-bit or not.," bool mkcall(int childno)
 if (entry->active_number == 0)
 goto already_done;
 
-output(1, ""%s (%d) returned ENOSYS, marking as inactive.\n"",
-entry->name, call + SYSCALL_OFFSET);
+output(1, ""%s (%d%s) returned ENOSYS, marking as inactive.\n"",
+entry->name,
+call + SYSCALL_OFFSET,
+rec->do32bit == TRUE ? "":[32BIT]"" : """");
 
 deactivate_syscall(call, rec->do32bit);
 already_done:
",149,22
cache the needalarm state," static unsigned long do_syscall(int childno)
 int nr, call;
 unsigned long a1, a2, a3, a4, a5, a6;
 unsigned long ret = 0;
+bool needalarm;
 
 rec = &shm->syscall[childno];
 nr = rec->nr;
 static unsigned long do_syscall(int childno)
 shm->child_op_count[childno]++;
 (void)gettimeofday(&shm->tv[childno], NULL);
 
-if (syscalls[nr].entry->flags & NEED_ALARM)
+needalarm = syscalls[nr].entry->flags & NEED_ALARM;
+if (needalarm)
 (void)alarm(1);
 
 errno = 0;
 static unsigned long do_syscall(int childno)
 
 rec->errno_post = errno;
 
-if (syscalls[nr].entry->flags & NEED_ALARM)
+if (needalarm)
 (void)alarm(0);
 
 return ret;
",151,22
move the timestamps from the shm into the syscall records," void reap_child(pid_t childpid)
 debugf(""Removing pid %d from pidmap.\n"", childpid);
 shm->pids[i] = EMPTY_PIDSLOT;
 shm->running_childs--;
-shm->tv[i].tv_sec = 0;
+shm->syscall[i].tv.tv_sec = 0;
 shm->last_reaped = childpid;
 
 out:
",233,51
remove unnecessary local vars," static unsigned long do_syscall(int childno)
 {
 struct syscallrecord *rec;
 int nr, call;
-unsigned long a1, a2, a3, a4, a5, a6;
 unsigned long ret = 0;
 bool needalarm;
 
 static unsigned long do_syscall(int childno)
  */
 call = nr + SYSCALL_OFFSET;
 
-a1 = rec->a1;
-a2 = rec->a2;
-a3 = rec->a3;
-a4 = rec->a4;
-a5 = rec->a5;
-a6 = rec->a6;
-
 shm->total_syscalls_done++;
 shm->child_op_count[childno]++;
 (void)gettimeofday(&rec->tv, NULL);
 static unsigned long do_syscall(int childno)
 errno = 0;
 
 if (rec->do32bit == FALSE)
-ret = syscall(call, a1, a2, a3, a4, a5, a6);
+ret = syscall(call, rec->a1, rec->a2, rec->a3, rec->a4, rec->a5, rec->a6);
 else
-ret = syscall32(call, a1, a2, a3, a4, a5, a6);
+ret = syscall32(call, rec->a1, rec->a2, rec->a3, rec->a4, rec->a5, rec->a6);
 
 rec->errno_post = errno;
 
",144,22
move post-syscall record updating into do_syscall," static unsigned long do_syscall(int childno)
 else
 ret = syscall32(call, rec->a1, rec->a2, rec->a3, rec->a4, rec->a5, rec->a6);
 
+/* We returned! */
+lock(&rec->lock);
 rec->errno_post = errno;
+rec->retval = ret;
+rec->state = AFTER;
+unlock(&rec->lock);
 
 if (needalarm)
 (void)alarm(0);
 bool mkcall(int childno)
 rec->state = BEFORE;
 ret = do_syscall(childno);
 
-/* We returned! */
-lock(&rec->lock);
-rec->state = AFTER;
-rec->retval = ret;
-unlock(&rec->lock);
-
 if (IS_ERR(ret))
 shm->failures++;
 else
",144,22
add locking so only one child does the reparenting spew," static void check_parent_pid(void)
 
 pid = getpid();
 
-//FIXME: Add locking so only one child does this output.
+lock(&shm->buglock);
+
+if (shm->exit_reason == EXIT_REPARENT_PROBLEM)
+goto out;
+
 output(0, BUGTXT ""CHILD (pid:%d) GOT REPARENTED! ""
 ""parent pid:%d. Watchdog pid:%d\n"",
 pid, shm->mainpid, watchdog_pid);
 output(0, BUGTXT ""Last syscalls:\n"");
 
+//TODO: replace all this with calls to postmortem()
 for_each_child(i) {
 // Skip over 'boring' entries.
 if ((shm->pids[i] == EMPTY_PIDSLOT) &&
 static void check_parent_pid(void)
 shm->child_op_count[i]);
 }
 shm->exit_reason = EXIT_REPARENT_PROBLEM;
+
+out:
+unlock(&shm->buglock);
 exit(EXIT_FAILURE);
-//TODO: Emergency logging.
 }
 
 /*
",232,46
remove unused leftovers from when we used to regenerate fd's.," static int open_files(void)
 return TRUE;
 }
 
-void close_files(void)
-{
-unsigned int i;
-
-shm->current_fd = 0;
-shm->fd_lifetime = 0;
-
-// FIXME: Does this need locking? At the least, check for NULL fd's
-for (i = 0; i < nr_file_fds; i++) {
-int fd;
-
-fd = shm->file_fds[i];
-shm->file_fds[i] = 0;
-if (fd != 0)
-close(fd);
-}
-
-nr_file_fds = 0;
-}
-
 const char * get_filename(void)
 {
 if (files_in_index == 0)/* This can happen if we run with -n. Should we do something else ? */
",266,61
push the EXIT_NO_FILES exit reason down into fd-files.c," static int open_files(void)
 
 generate_filelist();
 
-if (files_in_index == 0)/* Something bad happened. Crappy -V maybe? */
-return FALSE;// FIXME: We should log something here probably.
+if (files_in_index == 0) {
+/* Something bad happened. Crappy -V maybe? */
+shm->exit_reason = EXIT_NO_FILES;
+return FALSE;
+}
 
 nr_to_open = min(files_in_index, NR_FILE_FDS);
 
",268,61
only set EXIT_PID_OUT_OF_RANGE if we haven't got a pre-existing exit reason," static int check_shm_sanity(void)
 continue;
 
 if (pid_is_valid(pid) == FALSE) {
-shm->exit_reason = EXIT_PID_OUT_OF_RANGE;
+if (shm->exit_reason == STILL_RUNNING)
+shm->exit_reason = EXIT_PID_OUT_OF_RANGE;
+
 return SHM_CORRUPT;
 }
 }
 static void kill_all_kids(void)
 /* wait a second to give kids a chance to exit. */
 sleep(1);
 
-if (check_shm_sanity()) {
-// FIXME: If we get here, we over-wrote the real exit_reason.
-// We should have saved that, and handled appropriately.
+if (check_shm_sanity())
 return;
-}
 }
 
 /* Just to be sure, clear out the pid slots. */
",307,59
make handle_sigreturn use a bool.," static void sighandler(int sig)
 /* Re-arm the alarm. */
 alarm(1);
 
-/* TODO: If we get back here after the 10s alarm, we should exit instead of longjmp */
-
 /* Jump back, maybe we'll make progress. */
 (void)signal(sig, sighandler);
 siglongjmp(ret_jump, 1);
",67,10
"make output_syscall_prefix_to_fd use get_syscall_entry

This way we work out the correct table to read from.
In doing this conversion I realised that the syscall rec only has the
actual syscall number in it, and we need the offset here.

One way to do this might be to make get_syscall_entry not care,
by having it have knowledge of SYSCALL_OFFSET. needs more thinking."," void output_syscall_prefix_to_fd(int childno, FILE *fd, bool mono)
 
 rec = &shm->syscall[childno];
 syscallnr = rec->nr;
-entry = syscalls[syscallnr].entry;
+entry = get_syscall_entry(syscallnr, rec->do32bit);//FIXME: Only works for 1:1 callnr:offsets
 
 fprintf(fd, ""[child%u:%u] [%lu] %s"", childno, shm->pids[childno],
 shm->child_op_count[childno],
 (rec->do32bit == TRUE) ? ""[32BIT] "" : """");
 
+//FIXME: Max = 0 outside child
 if (syscallnr > max_nr_syscalls)
 fprintf(fd, ""%u"", syscallnr);
 else
",393,100
make get_syscall_entry take SYSCALL_OFFSET into account.," void output_syscall_prefix_to_fd(int childno, FILE *fd, bool mono)
 
 rec = &shm->syscall[childno];
 syscallnr = rec->nr;
-entry = get_syscall_entry(syscallnr, rec->do32bit);//FIXME: Only works for 1:1 callnr:offsets
+entry = get_syscall_entry(syscallnr, rec->do32bit);
 
 fprintf(fd, ""[child%u:%u] [%lu] %s"", childno, shm->pids[childno],
 shm->child_op_count[childno],
",393,100
"just remove the 'syscall out of range' check.

We shouldn't be passing down numbers larger than those defined in
the syscall tables."," void output_syscall_prefix_to_fd(int childno, FILE *fd, bool mono)
 shm->child_op_count[childno],
 (rec->do32bit == TRUE) ? ""[32BIT] "" : """");
 
-//FIXME: Max = 0 outside child
-if (syscallnr > max_nr_syscalls)
-fprintf(fd, ""%u"", syscallnr);
-else
-fprintf(fd, ""%s"", entry->name);
+fprintf(fd, ""%s"", entry->name);
 
 CRESETFD
 fprintf(fd, ""("");
",390,99
move the op count into the syscall record," void output_syscall_prefix_to_fd(int childno, FILE *fd, bool mono)
 entry = get_syscall_entry(syscallnr, rec->do32bit);
 
 fprintf(fd, ""[child%u:%u] [%lu] %s"", childno, shm->pids[childno],
-shm->child_op_count[childno],
+rec->opcount,
 (rec->do32bit == TRUE) ? ""[32BIT] "" : """");
 
 fprintf(fd, ""%s"", entry->name);
",390,99
rename opcount to op_nr," void output_syscall_prefix_to_fd(int childno, FILE *fd, bool mono)
 entry = get_syscall_entry(syscallnr, rec->do32bit);
 
 fprintf(fd, ""[child%u:%u] [%lu] %s"", childno, shm->pids[childno],
-rec->opcount,
+rec->op_nr,
 (rec->do32bit == TRUE) ? ""[32BIT] "" : """");
 
 fprintf(fd, ""%s"", entry->name);
",390,99
"comment out the post mortem code again.

This is going to need a total reworking, as this way of doing things
isn't going to work. If a child does something like allocating
a page to mangle a pathname, we can't output that pathname from
the watchdog context because the allocation is child local.
So right now, we pass invalid ptrs to print as %s, and things segv.

Not sure what the solution looks like, but this isn't it.","
 #include ""post-mortem.h""
 #include ""utils.h""
 
+#if 0
 static void dump_syscall_rec(int childno, FILE *fd, struct syscallrecord *rec)
 {
 int err;
 static void dump_syscall_records(void)
 
 fclose(fd);
 }
+#endif
 
 void tainted_postmortem(int taint)
 {
 void tainted_postmortem(int taint)
 syslog(LOG_CRIT, ""Detected kernel tainting. Last seed was %u\n"", shm->seed);
 closelog();
 
-dump_syscall_records();
+//dump_syscall_records();
 }
",63,11
"remove accidentally committed test code.

sigh, I'm having a bad day.","
 #include ""trinity.h""
 #include ""uid.h""
 
-#include ""post-mortem.h""
-
 char *progname = NULL;
 
 unsigned int page_size;
 cleanup_fds:
 
 out:
 
-tainted_postmortem(0);
-
 exit(ret);
 }
",121,17
runtime disable ANSI codes if monochrome is passed.,"
 
 #define BUFSIZE 1024
 
+char ANSI_RED[] = ""[1;31m"";
+char ANSI_GREEN[] = ""[1;32m"";
+char ANSI_YELLOW[] = ""[1;33m"";
+char ANSI_BLUE[] = ""[1;34m"";
+char ANSI_MAGENTA[] = ""[1;35m"";
+char ANSI_CYAN[] = ""[1;36m"";
+char ANSI_WHITE[] = ""[1;37m"";
+char ANSI_RESET[] = ""[0m"";
+
 static FILE *mainlogfile;
 static bool logfiles_opened = FALSE;
 
",230,45
replace the various colour macros with inline sprintfs," void dump_childnos(void)
 for (j = 0; j < 8; j++) {
 if (shm->pids[i + j] != EMPTY_PIDSLOT) {
 if (pid_alive(shm->pids[i + j] == -1))
-RED
+sptr += sprintf(sptr, ""%s"", ANSI_RED);
 }
 
-sptr += sprintf(sptr, ""%d "", shm->pids[i + j]);
-CRESET
+sptr += sprintf(sptr, ""%d %s"", shm->pids[i + j], ANSI_RESET);
 }
 sptr += sprintf(sptr, ""\n"");
 *sptr = '\0';
",110,26
remove unnecessary brackets," static void render_syscall_prefix(int childno, char *buffer)
 
 sptr += sprintf(sptr, ""[child%u:%u] [%lu] %s"", childno, shm->pids[childno],
 rec->op_nr,
-(rec->do32bit == TRUE) ? ""[32BIT] "" : """");
+rec->do32bit == TRUE ? ""[32BIT] "" : """");
 
 sptr += sprintf(sptr, ""%s%s("", entry->name, ANSI_RESET);
 
",176,49
remove obvious comments," void output_syscall_prefix(int childno)
 
 /* Exit if should not continue at all. */
 if (logging == TRUE) {
-/* Find the log file handle */
 log_handle = robust_find_logfile_handle();
 
 /* TODO: strip out ascii control symbols in buffer for files
 void output_syscall_postfix(int childno)
 render_syscall_postfix(rec, buffer);
 
 if (logging == TRUE) {
-/* Find the log file handle */
 log_handle = robust_find_logfile_handle();
 if (log_handle != NULL)
 flushbuffer(buffer, log_handle);
",168,47
make strip_ansi aware of the length of the buffer it works on," void output_syscall_prefix(int childno)
 if (logging == TRUE) {
 log_handle = robust_find_logfile_handle();
 if (log_handle != NULL) {
-strip_ansi(buffer);
+strip_ansi(buffer, PREBUFFER_LEN);
 flushbuffer(buffer, log_handle);
 }
 }
 void output_syscall_postfix(int childno)
 if (logging == TRUE) {
 log_handle = robust_find_logfile_handle();
 if (log_handle != NULL) {
-strip_ansi(buffer);
+strip_ansi(buffer, POSTBUFFER_LEN);
 flushbuffer(buffer, log_handle);
 }
 }
",172,47
"make rand_pathname only generate a max of 4k

Otherwise, on systems where page size > 4k, we'd still have the buffer
overflows when trying to print these buffers in output()","
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
-#include ""arch.h""
 #include ""log.h""
 #include ""maps.h""
 #include ""random.h""
 #include ""sanitise.h""
 
+#define MAX_PATH_LEN 4096
+
 const char * generate_pathname(void)
 {
 const char *pathname = get_filename();
 const char * generate_pathname(void)
 return pathname;
 
 /* Create a bogus filename. */
-newpath = malloc(page_size);// FIXME: We leak this.
+newpath = malloc(MAX_PATH_LEN);// FIXME: We leak this.
 if (newpath == NULL)
 return pathname;// give up.
 
 const char * generate_pathname(void)
 
 /* empty string. */
 if ((rand() % 100) == 0) {
-memset(newpath, 0, page_size);
+memset(newpath, 0, MAX_PATH_LEN);
 goto out;
 }
 
-generate_random_page(newpath);// FIXME: we only want a subset (ascii basically)
+generate_random_page(page_rand);
+memcpy(newpath, page_rand, MAX_PATH_LEN);// FIXME: we only want a subset (ascii basically)
 
 /* sometimes, just complete junk. */
 if (rand_bool())
",49,11
"switch destroy_shared_mappings to use list_for_each_safe

instead of mucking about with ->next by hand"," void setup_shared_mappings(void)
 
 void destroy_shared_mappings(void)
 {
+struct list_head *node, *tmp;
 struct map *m;
 
-while (!list_empty(&shared_mappings->list)) {
-m = shared_mappings;
+list_for_each_safe(node, tmp, &shared_mappings->list) {
+m = (struct map *) node;
 
 munmap(m->ptr, m->size);
 free(m->name);
 
-shared_mappings = (struct map *) m->list.next;
-
 list_del(&m->list);
 free(m);
 }
",87,8
"put all the per-child data together in a single struct.

This simplifies the allocation, and makes things more obvious what
is global vs local to a child.

Accesses look a bit uglier right now, but will get easier to read with
creation of some local struct ptrs which can be added incrementally."," retry:
 goto retry;
 }
 
-rec = &shm->syscall[childno];
+rec = &shm->children[childno].syscall;
 /* critical section for shm updates. */
 lock(&rec->lock);
 rec->do32bit = do32;
",75,14
use a childdata ptr in render_syscall_prefix," static char * render_arg(char *buffer, unsigned int argnum, struct syscallentry
 */
 static void render_syscall_prefix(int childno, char *buffer)
 {
+struct childdata *child = &shm->children[childno];
 struct syscallentry *entry;
 struct syscallrecord *rec;
 char *sptr = buffer;
 unsigned int i;
 unsigned int syscallnr;
 
-rec = &shm->children[childno].syscall;
+rec = &child->syscall;
 syscallnr = rec->nr;
 entry = get_syscall_entry(syscallnr, rec->do32bit);
 
-sptr += sprintf(sptr, ""[child%u:%u] [%lu] %s"", childno, shm->children[childno].pid,
+sptr += sprintf(sptr, ""[child%u:%u] [%lu] %s"", childno, child->pid,
 rec->op_nr,
 rec->do32bit == TRUE ? ""[32BIT] "" : """");
 
",166,45
fix incorrect index conversion.," static FILE * find_logfile_handle(void)
 dump_childnos();
 outputerr(""## Logfiles for pids: "");
 for_each_child(j)
-outputerr(""%p "", shm->children[i].logfile);
+outputerr(""%p "", shm->children[j].logfile);
 outputerr(""\n"");
 }
 return NULL;
",236,45
"use local var for pid, seeing as we only just stored it in the shm"," static void fork_children(void)
 shm->running_childs++;
 
 debugf(""Created child %d in childno %d [total:%d/%d]\n"",
-shm->children[childno].pid, childno,
-shm->running_childs, max_children);
+pid, childno, shm->running_childs, max_children);
 
 if (shm->exit_reason != STILL_RUNNING)
 return;
",232,51
"dump_childnos: cache the index calculation instead of repeating it.

gcc is probably smart enough to figure this out, but it also makes
the code read easier"," void dump_childnos(void)
 for (i = 0; i < max_children; i += 8) {
 sptr += sprintf(sptr, ""%u-%u: "", i, i + 7);
 for (j = 0; j < 8; j++) {
-if (shm->children[i + j].pid != EMPTY_PIDSLOT) {
-if (pid_alive(shm->children[i + j].pid == -1))
+unsigned int index = i + j;
+
+if (shm->children[index].pid != EMPTY_PIDSLOT) {
+if (pid_alive(shm->children[index].pid == -1))
 sptr += sprintf(sptr, ""%s"", ANSI_RED);
 }
 
-sptr += sprintf(sptr, ""%d %s"", shm->children[i + j].pid, ANSI_RESET);
+sptr += sprintf(sptr, ""%d %s"", shm->children[index].pid, ANSI_RESET);
 }
 sptr += sprintf(sptr, ""\n"");
 *sptr = '\0';
",111,26
"dump_childnos: convert to use childdata ptr

This removes the repeated index calc in a better way."," void dump_childnos(void)
 for (i = 0; i < max_children; i += 8) {
 sptr += sprintf(sptr, ""%u-%u: "", i, i + 7);
 for (j = 0; j < 8; j++) {
-unsigned int index = i + j;
+struct childdata *child;
 
-if (shm->children[index].pid != EMPTY_PIDSLOT) {
-if (pid_alive(shm->children[index].pid == -1))
+child = &shm->children[i + j];
+
+if (child->pid != EMPTY_PIDSLOT) {
+if (pid_alive(child->pid == -1))
 sptr += sprintf(sptr, ""%s"", ANSI_RED);
 }
 
-sptr += sprintf(sptr, ""%d %s"", shm->children[index].pid, ANSI_RESET);
+sptr += sprintf(sptr, ""%d %s"", child->pid, ANSI_RESET);
 }
 sptr += sprintf(sptr, ""\n"");
 *sptr = '\0';
",112,26
init_shm: use childdata & syscallrecord struct ptrs," void init_shm(void)
 set_seed(0);
 
 for_each_child(i) {
-shm->children[i].pid = EMPTY_PIDSLOT;
+struct childdata *child = &shm->children[i];
+struct syscallrecord *syscall, *previous;
 
-shm->children[i].previous.nr = shm->children[i].syscall.nr = -1;
+syscall = &child->syscall;
+previous = &child->previous;
 
-shm->children[i].previous.a1 = shm->children[i].syscall.a1 = -1;
-shm->children[i].previous.a2 = shm->children[i].syscall.a2 = -1;
-shm->children[i].previous.a3 = shm->children[i].syscall.a3 = -1;
-shm->children[i].previous.a4 = shm->children[i].syscall.a4 = -1;
-shm->children[i].previous.a5 = shm->children[i].syscall.a5 = -1;
-shm->children[i].previous.a6 = shm->children[i].syscall.a6 = -1;
+child->pid = EMPTY_PIDSLOT;
+
+previous->nr = syscall->nr = -1;
+
+previous->a1 = syscall->a1 = -1;
+previous->a2 = syscall->a2 = -1;
+previous->a3 = syscall->a3 = -1;
+previous->a4 = syscall->a4 = -1;
+previous->a5 = syscall->a5 = -1;
+previous->a6 = syscall->a6 = -1;
 }
 }
",54,4
make check_for_argtype operate on a syscallentry," void display_enabled_syscalls(void)
 display_enabled_syscalls_uniarch();
 }
 
-static bool check_for_argtype(const struct syscalltable *table, unsigned int num, unsigned int argtype)
+static bool check_for_argtype(struct syscallentry *entry, unsigned int argtype)
 {
-struct syscallentry *entry = table[num].entry;
-
 unsigned int i;
 
 for (i = 0; i < entry->num_args; i++) {
 static bool check_for_argtype(const struct syscalltable *table, unsigned int num
 /* Consider anything with an ARG_FD or ARG_SOCKADDR a network syscall. */
 bool is_syscall_net_related(const struct syscalltable *table, unsigned int num)
 {
-if (check_for_argtype(table, num, ARG_FD) == TRUE)
+struct syscallentry *entry = table[num].entry;
+
+if (check_for_argtype(entry, ARG_FD) == TRUE)
 return TRUE;
 
-if (check_for_argtype(table, num, ARG_SOCKADDR) == TRUE)
+if (check_for_argtype(entry, ARG_SOCKADDR) == TRUE)
 return TRUE;
 
 return FALSE;
",409,116
"remove the empty string case in random-pathname

it's covered in generate_random_page"," const char * generate_pathname(void)
 
 len = strlen(pathname);
 
-/* empty string. */
-if ((rand() % 100) == 0) {
-memset(newpath, 0, MAX_PATH_LEN);
-goto out;
-}
-
 generate_random_page(page_rand);
 memcpy(newpath, page_rand, MAX_PATH_LEN);// FIXME: we only want a subset (ascii basically)
 
",45,10
clamp the range of the pathname to the allocation,"
 #include ""maps.h""
 #include ""random.h""
 #include ""sanitise.h""
+#include ""utils.h""
 
 #define MAX_PATH_LEN 4096
 
 const char * generate_pathname(void)
 if (rand_bool())
 goto out;
 
+if (len > MAX_PATH_LEN)
+len = MAX_PATH_LEN;
+
 /* Sometimes, pathname + junk */
 if (rand_bool())
 (void) strncpy(newpath, pathname, len);
",48,11
make sure there's room in the buffer for pushing the extra 2 chars," const char * generate_pathname(void)
 if (rand_bool())
 (void) strncpy(newpath, pathname, len);
 else {
-/* make it look relative to cwd */
-newpath[0] = '.';
-newpath[1] = '/';
-(void) strncpy(newpath + 2, pathname, len);
+if (len < MAX_PATH_LEN - 2) {
+/* make it look relative to cwd */
+newpath[0] = '.';
+newpath[1] = '/';
+(void) strncpy(newpath + 2, pathname, len);
+}
 }
 
 /* Sometimes, remove all /'s */
",50,12
fix another case where we need to make sure we have room in the buffer," const char * generate_pathname(void)
 out:
 /* 50/50 chance of making it look like a dir */
 if (rand_bool()) {
-newpath[len] = '/';
-newpath[len + 1] = 0;
+if (len <= MAX_PATH_LEN - 2) {
+newpath[len] = '/';
+newpath[len + 1] = 0;
+}
 }
 
 return newpath;
",52,13
move the 'block on fd' check out of the signal handler," static bool handle_sigreturn(int childno)
 
 rec = &child->syscall;
 
+/* Check if we're blocked because we were stuck on an fd. */
+if (check_if_fd(childno) == TRUE) {
+/* avoid doing it again from other threads. */
+shm->fd_lifetime = 0;
+
+/* TODO: Somehow mark the fd in the parent not to be used again too. */
+}
+
 output(2, ""<timed out>\n""); /* Flush out the previous syscall output. */
 
 /* Check if we're making any progress at all. */
",242,47
"add a bust_locks function.

As the comment implies, this isn't going to be generally useful,
and should only be used in rare circumstances."," void unlock(lock_t *_lock)
 _lock->lock = UNLOCKED;
 }
 
+/*
+ * Release a lock we already hold.
+ *
+ * This function should be used sparingly. It's pretty much never something
+ * that you'll need, just for rare occasions like when we return from a
+ * signal handler with a lock held.
+ */
+void bust_lock(lock_t *_lock)
+{
+if (_lock->lock != LOCKED)
+return;
+if (getpid() != _lock->owner)
+return;
+unlock(_lock);
+}
+
 /*
 * Check that the processes holding locks are still alive.
 * And if they are, ensure they haven't held them for an
",62,12
"on return from signal handler, drop the syscall lock if we had it."," static bool handle_sigreturn(int childno)
 
 rec = &child->syscall;
 
+bust_lock(&rec->lock);
+
 /* Check if we're blocked because we were stuck on an fd. */
 if (check_if_fd(childno) == TRUE) {
 /* avoid doing it again from other threads. */
",243,47
fix a case where the watchdog code would hang on a lock," void check_all_locks(void)
 
 void lock(lock_t *_lock)
 {
+pid_t pid = getpid();
+
 while (_lock->lock == LOCKED) {
+/* This is pretty horrible. But if we call lock()
+ * from the watchdog code, and a child is hogging a lock
+ * (or worse, a dead child), we'll never call check_lock()
+ * from the watchdog loop because we'll be stuck here.
+ */
+if (pid == watchdog_pid)
+check_lock(_lock);
+
 _lock->contention++;
 usleep(1);
 }
",65,13
"handle the case where we double acquire a lock.

Shouldn't happen now that we do the bust_locks() after the signhandler,
but just in case, add some debug code to catch any stupidity that might
creep in later."," void lock(lock_t *_lock)
 pid_t pid = getpid();
 
 while (_lock->lock == LOCKED) {
+if (_lock->owner == pid) {
+debugf(""lol, already have lock!\n"");
+return;
+}
+
 /* This is pretty horrible. But if we call lock()
  * from the watchdog code, and a child is hogging a lock
  * (or worse, a dead child), we'll never call check_lock()
",69,14
update the syscall rec timeval under the record lock.," static unsigned long do_syscall(int childno)
 call = nr + SYSCALL_OFFSET;
 
 shm->total_syscalls_done++;
-(void)gettimeofday(&rec->tv, NULL);
 
 needalarm = syscalls[nr].entry->flags & NEED_ALARM;
 if (needalarm)
 static unsigned long do_syscall(int childno)
 
 /* We returned! */
 lock(&rec->lock);
+(void)gettimeofday(&rec->tv, NULL);
+
 rec->op_nr++;
 rec->errno_post = errno;
 rec->retval = ret;
",144,22
only increment total_syscalls_done after we completed a syscall.," static unsigned long do_syscall(int childno)
  */
 call = nr + SYSCALL_OFFSET;
 
-shm->total_syscalls_done++;
-
 needalarm = syscalls[nr].entry->flags & NEED_ALARM;
 if (needalarm)
 (void)alarm(1);
 static unsigned long do_syscall(int childno)
 ret = syscall32(call, rec->a1, rec->a2, rec->a3, rec->a4, rec->a5, rec->a6);
 
 /* We returned! */
+shm->total_syscalls_done++;
+
 lock(&rec->lock);
 (void)gettimeofday(&rec->tv, NULL);
 
",144,22
"resurrect the old backtrace code.

It's not always useful, but from time to time it does actually work
and can be useful for tracking down weird cases."," static inline long IS_ERR(unsigned long x)
 void sizeunit(unsigned long size, char *buf);
 
 void kill_pid(pid_t pid);
+
+void show_backtrace(void);
",14,1
dump backtrace if we detect a double lock.," void lock(lock_t *_lock)
 while (_lock->lock == LOCKED) {
 if (_lock->owner == pid) {
 debugf(""lol, already have lock!\n"");
+sleep(3);
+show_backtrace();
 return;
 }
 
",71,14
provide a way for children to become immune from the watchdog killer,"
 #include <stdio.h>
 #include <string.h>
 #include ""log.h""
+#include ""pids.h""
 #include ""utils.h""
 
 /*
 void sizeunit(unsigned long size, char *buf)
 void kill_pid(pid_t pid)
 {
 int ret;
+int childno;
+
+childno = find_childno(pid);
+if (shm->children[childno].dontkillme == TRUE)
+return;
 
 ret = kill(pid, SIGKILL);
 if (ret != 0)
",74,14
"disable child killing when we're dumping backtraces.

in part because of the sleeping we do here, but also because sometimes
it takes a while for backtrace() to gather all the symbols.
It's a mystery to me tbh."," void lock(lock_t *_lock)
 
 while (_lock->lock == LOCKED) {
 if (_lock->owner == pid) {
+int childno;
+
 debugf(""lol, already have lock!\n"");
+childno = find_childno(pid);
+shm->children[childno].dontkillme = TRUE;
 sleep(3);
 show_backtrace();
+shm->children[childno].dontkillme = FALSE;
 return;
 }
 
",75,14
watchdog: replace ptr to timeval with a ptr to the syscall record.," static void check_children(void)
 
 for_each_child(i) {
 struct childdata *child;
-struct timeval tv, *tvptr;
+struct syscallrecord *rec;
+struct timeval tv;
 time_t diff, old, now;
 pid_t pid;
 
 child = &shm->children[i];
+rec = &child->syscall;
 
 pid = child->pid;
 
 if (pid == EMPTY_PIDSLOT)
 continue;
 
-tvptr = &child->syscall.tv;
-old = tvptr->tv_sec;
+old = rec->tv.tv_sec;
 
 if (old == 0)
 continue;
 static void check_children(void)
 /* if we wrapped, just reset it, we'll pick it up next time around. */
 if (old > (now + 3)) {
 output(1, ""child %u wrapped! old=%lu now=%lu\n"", i, old, now);
-tvptr->tv_sec = now;
+rec->tv.tv_sec = now;
 continue;
 }
 
 static void check_children(void)
 /* if we're way off, we're comparing garbage. Reset it. */
 if (diff > 1000) {
 output(0, ""huge delta! child %d [%d]: old:%ld now:%ld diff:%d. Setting to now.\n"", i, pid, old, now, diff);
-tvptr->tv_sec = now;
+rec->tv.tv_sec = now;
 continue;
 }
 
",309,59
watchdog: calculate diff correctly if we wrap.," static void check_children(void)
 gettimeofday(&tv, NULL);
 now = tv.tv_sec;
 
+if (old > now)
+diff = old - now;
+else
+diff = now - old;
+
 /* if we wrapped, just reset it, we'll pick it up next time around. */
 if (old > (now + 3)) {
 output(1, ""child %u wrapped! old=%lu now=%lu\n"", i, old, now);
 static void check_children(void)
 continue;
 }
 
-diff = now - old;
-
 /* if we're way off, we're comparing garbage. Reset it. */
 if (diff > 1000) {
 output(0, ""huge delta! child %d [%d]: old:%ld now:%ld diff:%d. Setting to now.\n"", i, pid, old, now, diff);
",312,60
change wrap calculation to factor in possiblity of adjtime," static void check_children(void)
 diff = now - old;
 
 /* if we wrapped, just reset it, we'll pick it up next time around. */
-if (old > (now + 3)) {
+if (diff > 2145) {/* max adjtime offset. */
 output(1, ""child %u wrapped! old=%lu now=%lu\n"", i, old, now);
 rec->tv.tv_sec = now;
 continue;
",312,60
remove second call to getpid in lock()," void lock(lock_t *_lock)
 }
 
 _lock->contention = 0;
-_lock->owner = getpid();
+_lock->owner = pid;
 _lock->lock = LOCKED;
 }
 
",75,14
add comment explaining why we don't do anything about bad pids in handle_children," static void handle_children(void)
 if (pid == EMPTY_PIDSLOT)
 continue;
 
-if (pid_is_valid(pid) == FALSE)
-return;
+if (pid_is_valid(pid) == FALSE)/* If we find something invalid, we just ignore */
+return;/* it and leave it to the watchdog to clean up. */
 
 pid = waitpid(pid, &childstatus, WUNTRACED | WCONTINUED | WNOHANG);
 if (pid != 0)
",236,51
throw away unneeded sprintf return values," static void render_syscall_prefix(int childno, char *buffer)
 for (i = 1; i < entry->num_args + 1; i++)
 sptr = render_arg(sptr, i, entry, childno);
 
-sptr += sprintf(sptr, ""%s) "", ANSI_RESET);
+(void) sprintf(sptr, ""%s) "", ANSI_RESET);
 }
 
 static void flushbuffer(char *buffer, FILE *fd)
 static void render_syscall_postfix(struct syscallrecord *rec, char *buffer)
 else
 sptr += sprintf(sptr, ""%ld"", (long) rec->retval);
 }
-sptr += sprintf(sptr, ""%s\n"", ANSI_RESET);
+(void) sprintf(sptr, ""%s\n"", ANSI_RESET);
 }
 
 static void __output_syscall(char *buffer, unsigned int len)
",169,45
rename SIZE to BACKTRACE_SIZE," void kill_pid(pid_t pid)
 debugf(""couldn't kill pid %d [%s]\n"", pid, strerror(errno));
 }
 
+#define BACKTRACE_SIZE 100
+
 void show_backtrace(void)
 {
 unsigned int j, nptrs;
-#define SIZE 100
-void *buffer[SIZE];
+void *buffer[BACKTRACE_SIZE];
 char **strings;
 
-nptrs = backtrace(buffer, SIZE);
+nptrs = backtrace(buffer, BACKTRACE_SIZE);
 
 strings = backtrace_symbols(buffer, nptrs);
 if (strings == NULL) {
",74,14
"if we detect corruption, don't wait for children, just get out."," void main_loop(void)
 handle_children();
 }
 
+/* if the pid map is corrupt, we can't trust that we'll
+ * ever successfully finish pidmap_empty, so skip it */
+if ((shm->exit_reason == EXIT_LOST_CHILD) ||
+ (shm->exit_reason == EXIT_SHM_CORRUPTION))
+goto dont_wait;
+
 /* Wait until all children have exited. */
 while (pidmap_empty() == FALSE)
 handle_children();
 
+dont_wait:
 output(0, ""Bailing main loop. Exit reason: %s\n"", decode_exit(shm->exit_reason));
 }
",240,53
"remove the code that removes /'s from path names.

It never found anything interesting. I'm not even sure what I was
originally intending to do here."," const char * generate_pathname(void)
 const char *pathname = get_filename();
 char *newpath;
 unsigned int len;
-unsigned int i;
 
 if (pathname == NULL)/* handle -n correctly. */
 return NULL;
 const char * generate_pathname(void)
 }
 }
 
-/* Sometimes, remove all /'s */
-if (rand_bool()) {
-for (i = 0; i < len; i++) {
-if (newpath[i] == '/')
-newpath[i] = rand();
-}
-}
 out:
 /* 50/50 chance of making it look like a dir */
 if (rand_bool()) {
",45,10
output uid etc as unsigned," void dump_uids(void)
 getresuid(&uid, &euid, &suid);
 getresgid(&gid, &egid, &sgid);
 
-outputstd(""initial uid:%d gid:%d euid:%d egid:%d suid:%d sgid:%d\n"",
+outputstd(""initial uid:%u gid:%u euid:%u egid:%u suid:%u sgid:%u\n"",
 uid, gid, euid, egid, suid, sgid);
 }
 
 void drop_privs(void)
 exit(EXIT_FAILURE);
 }
 
-outputstd(""set uid to %d and gid to %d (nobody)\n"", nobody_uid, nobody_gid);
+outputstd(""set uid to %u and gid to %d (nobody)\n"", nobody_uid, nobody_gid);
 }
 
 void init_uids(void)
 changed:
 if (myuid == 65534)
 return;
 
-output(0, ""uid changed! Was: %d, now %d\n"", orig_uid, myuid);
+output(0, ""uid changed! Was: %u, now %u\n"", orig_uid, myuid);
 
 shm->exit_reason = EXIT_UID_CHANGED;
 _exit(EXIT_FAILURE);
",102,19
move the pid_is_valid output to its caller," void pids_init(void)
 
 int pid_is_valid(pid_t pid)
 {
-if ((pid > pidmax) || (pid < 1)) {
-output(0, ""Sanity check failed! Found pid %d!\n"", pid);
+if ((pid > pidmax) || (pid < 1))
 return FALSE;
-}
 
 return TRUE;
 }
",110,26
"make the post mortem code also dump the previous syscall rec.

and separate each child with an extra newline"," static void dump_syscall_records(void)
 }
 
 for_each_child(i) {
-//dump_syscall_rec(fd, &shm->children[i].previous);
+dump_syscall_rec(fd, &shm->children[i].previous);
 dump_syscall_rec(fd, &shm->children[i].syscall);
+fprintf(fd, ""\n"");
 }
 
 fclose(fd);
",57,10
don't try to reap invalid pids," static unsigned int reap_dead_kids(void)
 if (pid == EMPTY_PIDSLOT)
 continue;
 
+if (pid_is_valid(pid) == FALSE)
+continue;
+
 ret = kill(pid, 0);
 /* If it disappeared, reap it. */
 if (ret == -1) {
",315,61
make sure we wait for our child pid to be set before we do anything.," void init_child(int childno)
 pid_t pid = getpid();
 char childname[17];
 
+/* Wait for parent to set our childno */
+while (child->pid != getpid()) {
+int ret = 0;
+
+/* Make sure parent is actually alive to wait for us. */
+ret = pid_alive(shm->mainpid);
+if (ret != 0) {
+shm->exit_reason = EXIT_SHM_CORRUPTION;
+outputerr(BUGTXT ""parent (%d) went away!\n"", shm->mainpid);
+sleep(20000);
+}
+}
+
 this_child = childno;
 
 reinit_child(child);
 void init_child(int childno)
 
 oom_score_adj(500);
 
-/* Wait for parent to set our childno */
-while (child->pid != getpid()) {
-int ret = 0;
-
-/* Make sure parent is actually alive to wait for us. */
-ret = pid_alive(shm->mainpid);
-if (ret != 0) {
-shm->exit_reason = EXIT_SHM_CORRUPTION;
-outputerr(BUGTXT ""parent (%d) went away!\n"", shm->mainpid);
-sleep(20000);
-}
-}
-
 /* Wait for all the children to start up. */
 while (shm->ready == FALSE)
 sleep(1);
",252,48
remove an unnecessary getpid call," void init_child(int childno)
 char childname[17];
 
 /* Wait for parent to set our childno */
-while (child->pid != getpid()) {
+while (child->pid != pid) {
 int ret = 0;
 
 /* Make sure parent is actually alive to wait for us. */
",252,48
special case the dumping of empty pid slots," void dump_childnos(void)
 
 child = &shm->children[i + j];
 
-if (child->pid != EMPTY_PIDSLOT) {
+if (child->pid == EMPTY_PIDSLOT) {
+sptr += sprintf(sptr, ""[empty] "");
+} else {
 if (pid_alive(child->pid == -1))
 sptr += sprintf(sptr, ""%s"", ANSI_RED);
 }
",112,26
output invalid pids in red too.," void dump_childnos(void)
 if (child->pid == EMPTY_PIDSLOT) {
 sptr += sprintf(sptr, ""[empty] "");
 } else {
+if (pid_is_valid(child->pid) == FALSE)
+sptr += sprintf(sptr, ""%s"", ANSI_RED);
+
 if (pid_alive(child->pid == -1))
 sptr += sprintf(sptr, ""%s"", ANSI_RED);
 }
",114,27
"when dumping empty pid slots, don't also dump the pid number."," void dump_childnos(void)
 
 if (pid_alive(child->pid == -1))
 sptr += sprintf(sptr, ""%s"", ANSI_RED);
-}
 
-sptr += sprintf(sptr, ""%d %s"", child->pid, ANSI_RESET);
+sptr += sprintf(sptr, ""%d %s"", child->pid, ANSI_RESET);
+}
 }
 sptr += sprintf(sptr, ""\n"");
 *sptr = '\0';
",114,27
output valid pids as unsigned values," void dump_childnos(void)
 if (pid_alive(child->pid == -1))
 sptr += sprintf(sptr, ""%s"", ANSI_RED);
 
-sptr += sprintf(sptr, ""%d %s"", child->pid, ANSI_RESET);
+sptr += sprintf(sptr, ""%u %s"", child->pid, ANSI_RESET);
 }
 }
 sptr += sprintf(sptr, ""\n"");
",114,27
"if we find an invalid pid, skip over it instead of bailing out."," static void handle_children(void)
 continue;
 
 if (pid_is_valid(pid) == FALSE)/* If we find something invalid, we just ignore */
-return;/* it and leave it to the watchdog to clean up. */
+continue;/* it and leave it to the watchdog to clean up. */
 
 pid = waitpid(pid, &childstatus, WUNTRACED | WCONTINUED | WNOHANG);
 if (pid != 0)
",240,53
fix incorrect rand_range parameters," void * get_writable_address(unsigned long size)
 i = rand() % 3;
 
 if (size > page_size)
-i = rand_range(2, 3);
+i = rand_range(1, 2);
 
 switch (i) {
 case 0:addr = page_rand;
",115,32
"greatly simplify dirty_every_other_page

Also fixes an overrun."," static void dirty_whole_mapping(struct map *map)
 static void dirty_every_other_page(struct map *map)
 {
 char *p = map->ptr;
-unsigned int i, nr;
+unsigned int i, nr, first;
 
 nr = nr_pages(map);
 
-if (rand_bool()) {
-/* X.X.X.X.... */
-for (i = 0; i < nr; i++) {
-p[i * page_size] = rand();
-i++;
-}
-} else {
-/* .X.X.X.X.... */
-for (i = 0; i < nr; i++) {
-i++;
-p[i * page_size] = rand();
-}
-}
+first = rand_bool();
+
+for (i = first; i < nr; i+=2)
+p[i * page_size] = rand();
 }
 
 static void dirty_mapping_reverse(struct map *map)
",148,27
fix another write past the end of array," static void dirty_mapping_reverse(struct map *map)
 char *p = map->ptr;
 unsigned int i, nr;
 
-nr = nr_pages(map);
+nr = nr_pages(map) - 1;
 
 for (i = nr; i > 0; i--)
 p[i * page_size] = rand();
",148,27
do the same simplification to read_every_other_page," static void read_whole_mapping(struct map *map)
 static void read_every_other_page(struct map *map)
 {
 char *p = map->ptr;
-unsigned int i, nr;
+unsigned int i, nr, first;
 char buf[page_size];
 
 nr = nr_pages(map);
 
-if (rand_bool()) {
-/* X.X.X.X.... */
-for (i = 0; i < nr; i++) {
-memcpy(buf, p + (i * page_size), page_size);
-i++;
-}
-} else {
-/* .X.X.X.X.... */
-for (i = 0; i < nr; i++) {
-i++;
-memcpy(buf, p + (i * page_size), page_size);
-}
-}
+first = rand_bool();
+
+for (i = first; i < nr; i+=2)
+memcpy(buf, p + (i * page_size), page_size);
 }
 
 static void read_mapping_reverse(struct map *map)
",140,25
fix read past end of buffer.," static void read_mapping_reverse(struct map *map)
 unsigned int i, nr;
 char buf[page_size];
 
-nr = nr_pages(map);
+nr = nr_pages(map) - 1;
 
 for (i = nr; i > 0; i--)
 memcpy(buf, p + (i * page_size), page_size);
",140,25
"allocate per-child arrays separately instead of as one big array.

No real functional change, but the difference in allocation patterns
made it easier to track down the corruption that the page dirtying code
was doing."," retry:
 goto retry;
 }
 
-rec = &shm->children[childno].syscall;
+rec = &shm->children[childno]->syscall;
 /* critical section for shm updates. */
 lock(&rec->lock);
 rec->do32bit = do32;
",75,14
handle SIGBUS from child processes," static void handle_childsig(int childpid, int childstatus, int stop)
 case SIGKILL:
 case SIGPIPE:
 case SIGABRT:
+case SIGBUS:
 if (stop == TRUE)
 debugf(""Child %d was stopped by %s\n"", childpid, strsignal(WSTOPSIG(childstatus)));
 else
",241,53
remove unnecessary null check," static void post_move_pages(int childno, __unused__ struct syscallrecord *rec)
 unsigned long *page;
 
 page = (void *) shm->children[childno]->scratch;
-if (page == NULL)
-return;
-
 free(page);
 
 shm->children[childno]->scratch = 0;
",64,5
remove usage of ->scratch from mprotect,"
 #include ""trinity.h""
 #include ""utils.h""
 
+struct map* map;
+
 static void sanitise_mprotect(int childno, __unused__ struct syscallrecord *rec)
 {
-(void) common_set_mmap_ptr_len(childno);
+map = common_set_mmap_ptr_len(childno);
 }
 
 /*
 * If we successfully did an mprotect, update our record of the mappings prot bits.
 */
-static void post_mprotect(int childno, struct syscallrecord *rec)
+static void post_mprotect(__unused__ int childno, struct syscallrecord *rec)
 {
-struct map *map = (struct map *) shm->children[childno]->scratch;
-
 if (rec->retval != 0)
 map->prot = rec->a3;
-
-shm->children[childno]->scratch = 0;
 }
 
 struct syscallentry syscall_mprotect = {
",35,3
make mremap's 'map' variable static,"
 #include ""trinity.h""
 #include ""utils.h""
 
-struct map *map;
+static struct map *map;
 
 static const unsigned long alignments[] = {
 1 * MB, 2 * MB, 4 * MB, 8 * MB,
",58,5
make mprotect's map variable static,"
 #include ""trinity.h""
 #include ""utils.h""
 
-struct map* map;
+static struct map* map;
 
 static void sanitise_mprotect(int childno, __unused__ struct syscallrecord *rec)
 {
",35,3
remove usage of ->scratch from munmap,"
 #include ""sanitise.h""
 #include ""shm.h""
 #include ""syscall.h""
+#include ""trinity.h""
 
 #define WHOLE 1
 static int action;
 
+static struct map *map;
+
 static void sanitise_munmap(int childno, struct syscallrecord *rec)
 {
-struct map *map;
 unsigned long len;
 unsigned long nr_pages;
 unsigned long offset, offsetpagenr;
 static void sanitise_munmap(int childno, struct syscallrecord *rec)
 }
 }
 
-static void post_munmap(int childno, struct syscallrecord *rec)
+static void post_munmap(__unused__ int childno, struct syscallrecord *rec)
 {
-struct map *map = (struct map *) shm->children[childno]->scratch;
-
 if (rec->retval != 0)
 return;
 
 if (action == WHOLE)
 delete_mapping(childno, map);
-
-shm->children[childno]->scratch = 0;
 }
 
 struct syscallentry syscall_munmap = {
",56,7
remove the ->scratch pointer completely.," static void reinit_child(struct childdata *child)
 child->logdirty = FALSE;
 child->mappings = NULL;
 child->num_mappings = 0;
-child->scratch = 0;
 child->seed = 0;
 child->kill_count = 0;
 child->dontkillme = FALSE;
",251,48
cache childdata ptr to simplify code," static struct map * __get_map(struct list_head *head, unsigned int max)
 struct map * get_map(void)
 {
 struct map *map;
+struct childdata *child;
 bool local = FALSE;
 
 /* We can get called by child processes, and also during startup by
 struct map * get_map(void)
  * because main doesn't have any 'local' mappings.
  */
 if (this_child != 0) {
-if (shm->children[this_child]->num_mappings > 0)
+child = shm->children[this_child];
+
+if (child->num_mappings > 0)
 local = rand_bool();
 }
 
-//FIXME: cache child ptr.
 if (local == TRUE)
-map = __get_map(&shm->children[this_child]->mappings->list, shm->children[this_child]->num_mappings);
+map = __get_map(&child->mappings->list, child->num_mappings);
 else
 map = __get_map(&shared_mappings->list, num_shared_mappings);
 
",66,11
"don't bother zeroing out the mappings ptr on reinit

we initialize it right afterwards."," static void reinit_child(struct childdata *child)
 memset(&child->previous, 0, sizeof(struct syscallrecord));
 
 child->logdirty = FALSE;
-child->mappings = NULL;
 child->num_mappings = 0;
 child->seed = 0;
 child->kill_count = 0;
",250,48
change this_child to be a childdata ptr instead of a child number.," static void use_fpu(void)
 asm volatile("""":""+m"" (x));
 }
 
-int this_child = 0;
+struct childdata *this_child = NULL;
 
 static void oom_score_adj(int adj)
 {
 void init_child(int childno)
 }
 }
 
-this_child = childno;
+this_child = child;
 
 reinit_child(child);
 
",250,48
"remove childno uses from delete_mapping

We only ever call this from child context, so it can use this_child"," struct map * get_map(void)
 return map;
 }
 
-static void delete_local_mapping(int childno, struct map *map)
+static void delete_local_mapping(struct map *map)
 {
 list_del(&map->list);
-shm->children[childno]->num_mappings--;
+this_child->num_mappings--;
 }
 
 /* Called from munmap()'s ->post routine. */
-void delete_mapping(int childno, struct map *map)
+void delete_mapping(struct map *map)
 {
 if (map->type == MAP_LOCAL)
-delete_local_mapping(childno, map);
+delete_local_mapping(map);
 
 /* Right now, we don't want to delete MAP_GLOBAL mappings */
 }
",64,11
"remove childno use from do_syscall

This is only used from child context, so can use this_child"," static long syscall32(unsigned int call,
 #define syscall32(a,b,c,d,e,f,g) 0
 #endif /* ARCH_IS_BIARCH */
 
-static unsigned long do_syscall(int childno)
+static unsigned long do_syscall(void)
 {
 struct syscallrecord *rec;
 int nr, call;
 unsigned long ret = 0;
 bool needalarm;
 
-rec = &shm->children[childno]->syscall;
+rec = &this_child->syscall;
 nr = rec->nr;
 
 /* Some architectures (IA64/MIPS) start their Linux syscalls
 bool mkcall(int childno)
 unsigned int call;
 unsigned long ret = 0;
 
-rec = &shm->children[childno]->syscall;
+rec = &this_child->syscall;
 
 call = rec->nr;
 entry = syscalls[call].entry;
 bool mkcall(int childno)
 
 extrapid = fork();
 if (extrapid == 0) {
-ret = do_syscall(childno, &errno_saved);
+ret = do_syscall();
 /* We should never get here. */
 rec->state = GOING_AWAY;
 rec->retval = ret;
 bool mkcall(int childno)
 #endif
 
 rec->state = BEFORE;
-ret = do_syscall(childno);
+ret = do_syscall();
 
 if (IS_ERR(ret))
 shm->failures++;
",144,22
missed a this_child conversion in the do_syscall path," already_done:
  entry->post(childno, rec);
 
 /* store info for debugging. */
-previous = &shm->children[childno]->previous;
+previous = &this_child->previous;
 previous->nr = rec->nr;
 previous->a1 = rec->a1;
 previous->a2 = rec->a2;
",144,22
"remove childno use from this_syscallname

Only ever called from child context, so can use this_child"," already_done:
 return TRUE;
 }
 
-bool this_syscallname(const char *thisname, int childno)
+bool this_syscallname(const char *thisname)
 {
-unsigned int call = shm->children[childno]->syscall.nr;
+unsigned int call = this_child->syscall.nr;
 struct syscallentry *syscall_entry = syscalls[call].entry;
 
 return strcmp(thisname, syscall_entry->name);
",144,22
convert get_argval from childno usage to this_child," bool mkcall(int childno)
 kill(extrapid, SIGKILL);
 }
 //FIXME: Why would we only do this once ?
-generic_free_arg(childno);
+generic_free_arg();
 return FALSE;
 }
 }
 already_done:
 
 check_uid();
 
-generic_free_arg(childno);
+generic_free_arg();
 
 return TRUE;
 }
",144,22
remove childno usage from truncate_log," static void oom_score_adj(int adj)
 fclose(fp);
 }
 
-static void truncate_log(int childno)
+static void truncate_log(void)
 {
-struct childdata *child = shm->children[childno];
 int fd;
 
-child->logdirty = FALSE;
+this_child->logdirty = FALSE;
 
 if (logging == FALSE)
 return;
 
-fd = fileno(child->logfile);
+fd = fileno(this_child->logfile);
 if (ftruncate(fd, 0) == 0)
 lseek(fd, 0, SEEK_SET);
 }
 void init_child(int childno)
 
 reinit_child(child);
 
-truncate_log(childno);
+truncate_log();
 
 set_seed(childno);
 
",249,48
remove duplicate clearing of log dirty flag," static void reinit_child(struct childdata *child)
 memset(&child->syscall, 0, sizeof(struct syscallrecord));
 memset(&child->previous, 0, sizeof(struct syscallrecord));
 
-child->logdirty = FALSE;
 child->num_mappings = 0;
 child->seed = 0;
 child->kill_count = 0;
",248,48
convert handle_sigreturn to use this_child," static const struct child_funcs child_ops[] = {
 // FIXME: when we have different child ops, we're going to need to redo the progress detector.
 static bool handle_sigreturn(int childno)
 {
-struct childdata *child = shm->children[childno];
 struct syscallrecord *rec;
 static unsigned int count = 0;
 static unsigned int last = -1;
 
-rec = &child->syscall;
+rec = &this_child->syscall;
 
 bust_lock(&rec->lock);
 
 static bool handle_sigreturn(int childno)
 output(2, ""<timed out>\n""); /* Flush out the previous syscall output. */
 
 /* Check if we're making any progress at all. */
-if (child->syscall.op_nr == last) {
+if (rec->op_nr == last) {
 count++;
 //output(1, ""no progress for %d tries.\n"", count);
 } else {
 static bool handle_sigreturn(int childno)
 return FALSE;
 }
 
-if (child->kill_count > 0) {
+if (this_child->kill_count > 0) {
 output(1, ""[%d] Missed a kill signal, exiting\n"", getpid());
 return FALSE;
 }
",247,48
convert check_if_fd to work on syscallrec's instead of childno's," static const struct child_funcs child_ops[] = {
 };
 
 // FIXME: when we have different child ops, we're going to need to redo the progress detector.
-static bool handle_sigreturn(int childno)
+static bool handle_sigreturn(void)
 {
 struct syscallrecord *rec;
 static unsigned int count = 0;
 static bool handle_sigreturn(int childno)
 bust_lock(&rec->lock);
 
 /* Check if we're blocked because we were stuck on an fd. */
-if (check_if_fd(childno) == TRUE) {
+if (check_if_fd(rec) == TRUE) {
 /* avoid doing it again from other threads. */
 shm->fd_lifetime = 0;
 
 void child_process(int childno)
 
 ret = sigsetjmp(ret_jump, 1);
 if (ret != 0) {
-if (handle_sigreturn(childno) == FALSE)
+if (handle_sigreturn() == FALSE)
 return;// Exit the child, things are getting too weird.
 }
 
",247,48
make ->decode take a syscallrec as an argument instead of a childno," static char * render_arg(char *buffer, unsigned int argnum, struct syscallentry
 if (entry->decode != NULL) {
 char *str;
 
-str = entry->decode(childno, argnum);
+str = entry->decode(rec, argnum);
 if (str != NULL) {
 sptr += sprintf(sptr, ""%s"", str);
 free(str);
",169,45
convert render_arg to use this_child instead of needing a childno arg,"
 #include ""tables.h""
 #include ""utils.h""
 
-static char * render_arg(char *buffer, unsigned int argnum, struct syscallentry *entry, int childno)
+static char * render_arg(char *buffer, unsigned int argnum, struct syscallentry *entry)
 {
 struct syscallrecord *rec;
 char *sptr = buffer;
 static char * render_arg(char *buffer, unsigned int argnum, struct syscallentry
 unsigned long reg = 0;
 enum argtype type = 0;
 
-rec = &shm->children[childno]->syscall;
+rec = &this_child->syscall;
 
 switch (argnum) {
 case 1:type = entry->arg1type;
 static void render_syscall_prefix(int childno, char *buffer)
 sptr += sprintf(sptr, ""%s%s("", entry->name, ANSI_RESET);
 
 for (i = 1; i < entry->num_args + 1; i++)
-sptr = render_arg(sptr, i, entry, childno);
+sptr = render_arg(sptr, i, entry);
 
 (void) sprintf(sptr, ""%s) "", ANSI_RESET);
 }
",169,45
convert output_syscall_postfix to use this_child instead of needing a childno arg," void output_syscall_prefix(int childno)
 __output_syscall(buffer, PREBUFFER_LEN);
 }
 
-void output_syscall_postfix(int childno)
+void output_syscall_postfix(void)
 {
-struct syscallrecord *rec = &shm->children[childno]->syscall;
+struct syscallrecord *rec = &this_child->syscall;
 char *buffer = rec->postbuffer;
 
 memset(buffer, 0, POSTBUFFER_LEN);// TODO: optimize to only strip ending post render.
",169,45
remove childno argument from common_set_mmap_ptr_len," void delete_mapping(struct map *map)
 }
 
 /* used in several sanitise_* functions. */
-struct map * common_set_mmap_ptr_len(int childno)
+struct map * common_set_mmap_ptr_len(void)
 {
 struct syscallrecord *rec;
 struct map *map;
 
-rec = &shm->children[childno]->syscall;
+rec = &this_child->syscall;
 map = (struct map *) rec->a1;
 if (map == NULL) {
 rec->a1 = 0;
",64,11
make the ioctl code work with syscall records instead of child numbers," static const char *const autofs_devs[] = {
 ""autofs"",
 };
 
-static void autofs_sanitise(const struct ioctl_group *grp, int childno)
+static void autofs_sanitise(const struct ioctl_group *grp, struct syscallrecord *rec)
 {
-struct syscallrecord *rec;
 struct autofs_dev_ioctl *arg;
 
-rec = &shm->children[childno]->syscall;
-
-pick_random_ioctl(grp, childno);
+pick_random_ioctl(grp, rec);
 
 rec->a3 = (unsigned long) page_rand;
 
",180,18
remove childno argument from ->sanitise," static int open_perf_fds(void)
 int fd;
 
 rec = &shm->children[0]->syscall;
-sanitise_perf_event_open(0, rec);
+sanitise_perf_event_open(rec);
 
 fd = syscall(__NR_perf_event_open, rec->a1, rec->a2, rec->a3, rec->a4, rec->a5);
 if (fd != -1) {
",41,6
convert post_mmap to use this_child," static void sanitise_mmap(struct syscallrecord *rec)
 }
 }
 
-static void post_mmap(int childno, struct syscallrecord *rec)
+static void post_mmap(__unused__ int childno, struct syscallrecord *rec)
 {
 char *p;
 struct list_head *list;
 static void post_mmap(int childno, struct syscallrecord *rec)
 new->type = MAP_LOCAL;
 
 // Add this to a list for use by subsequent syscalls.
-list = &shm->children[childno]->mappings->list;
+list = &this_child->mappings->list;
 list_add_tail(&new->list, list);
-shm->children[childno]->num_mappings++;
+this_child->num_mappings++;
 
 /* Sometimes dirty the mapping. */
 if (rand_bool())
",150,16
remove childno argument from ->post," already_done:
 }
 
 if (entry->post)
- entry->post(childno, rec);
+ entry->post(rec);
 
 /* store info for debugging. */
 previous = &this_child->previous;
",144,22
convert ARG_ADDRESS handling from childno's to syscallrecords," static bool is_arg_address(enum argtype argtype)
 return FALSE;
 }
 
-unsigned long find_previous_arg_address(int childno, unsigned int argnum)
+unsigned long find_previous_arg_address(struct syscallrecord *rec, unsigned int argnum)
 {
-struct syscallrecord *rec;
 struct syscallentry *entry;
 unsigned long addr = 0;
 unsigned int call;
 
-rec = &shm->children[childno]->syscall;
 call = rec->nr;
 entry = syscalls[call].entry;
 
",113,32
convert generic_sanitise to take a syscallrecord," static unsigned long fill_arg(struct syscallrecord *rec, unsigned int argnum)
 BUG(""unreachable!\n"");
 }
 
-void generic_sanitise(__unused__ int childno)
+void generic_sanitise(struct syscallrecord *rec)
 {
-struct syscallrecord *rec;
 struct syscallentry *entry;
 unsigned int call;
 
-rec = &this_child->syscall;
 call = rec->nr;
 entry = syscalls[call].entry;
 
",358,123
"stash the child number in the child struct

eventually we'll move to place where we don't pass this around, but
there's still a few places we will need to know it."," void init_child(int childno)
 
 this_child = child;
 
+child->num = childno;
+
 reinit_child(child);
 
 truncate_log();
",248,48
make output_syscall_prefix use this_child,"
 #include ""params.h""
 #include ""maps.h""
 #include ""tables.h""
+#include ""trinity.h""
 #include ""uid.h""
 #include ""utils.h""
 
 static unsigned long do_syscall(void)
 * returns a bool that determines whether we can keep doing syscalls
 * in this child.
 */
-bool mkcall(int childno)
+bool mkcall(__unused__ int childno)
 {
 struct syscallentry *entry;
 struct syscallrecord *rec, *previous;
 bool mkcall(int childno)
 
 unlock(&rec->lock);
 
-output_syscall_prefix(childno);
+output_syscall_prefix();
 
 /* If we're going to pause, might as well sync pre-syscall */
 if (dopause == TRUE)
",145,22
remove childno arg from mkcall," retry:
 }
 
 /* Do the actual syscall. */
-return mkcall(childno);
+return mkcall();
 }
",75,14
don't pass childno down to the child_funcs," static void periodic_work(void)
 
 struct child_funcs {
 const char *name;
-bool (*func)(int childno);
+bool (*func)(void);
 unsigned char likelyhood;
 };
 
 void child_process(int childno)
 lastop = child_ops[i].name;
 }
 
-ret = child_ops[i].func(childno);
+ret = child_ops[i].func();
 if (ret == FAIL)
 return;
 }
",248,48
this_child conversion in child_process," void child_process(int childno)
 periodic_work();
 
 /* If the parent reseeded, we should reflect the latest seed too. */
-if (shm->seed != shm->children[childno]->seed)
+if (shm->seed != this_child->seed)
 set_seed(childno);
 
 /* Choose operations for this iteration. */
",248,48
make set_seed work on a childdata struct instead of a child num," void init_child(int childno)
 
 truncate_log();
 
-set_seed(childno);
+set_seed(this_child);
 
 child->mappings = zmalloc(sizeof(struct map));
 INIT_LIST_HEAD(&child->mappings->list);
 static bool handle_sigreturn(void)
 return TRUE;
 }
 
-void child_process(int childno)
+void child_process(__unused__ int childno)
 {
 const char *lastop = NULL;
 int ret;
 void child_process(int childno)
 
 /* If the parent reseeded, we should reflect the latest seed too. */
 if (shm->seed != this_child->seed)
-set_seed(childno);
+set_seed(this_child);
 
 /* Choose operations for this iteration. */
 i = rand() % ARRAY_SIZE(child_ops);
",248,48
remove childno arg from child_process()," static bool handle_sigreturn(void)
 return TRUE;
 }
 
-void child_process(__unused__ int childno)
+void child_process(void)
 {
 const char *lastop = NULL;
 int ret;
",248,48
make sure lock only sets dontkillme in child context.," void check_all_locks(void)
 check_lock(&shm->children[i]->syscall.lock);
 }
 
+static void set_dontkillme(pid_t pid, bool state)
+{
+int childno;
+
+childno = find_childno(pid);
+if (childno == CHILD_NOT_FOUND)/* possible, we might be the watchdog for example */
+return;
+shm->children[childno]->dontkillme = state;
+}
+
 void lock(lock_t *_lock)
 {
 pid_t pid = getpid();
 
 while (_lock->lock == LOCKED) {
 if (_lock->owner == pid) {
-int childno;
-
 debugf(""lol, already have lock!\n"");
-childno = find_childno(pid);
-shm->children[childno]->dontkillme = TRUE;
+set_dontkillme(pid, TRUE);
 sleep(3);
 show_backtrace();
-shm->children[childno]->dontkillme = FALSE;
+set_dontkillme(pid, FALSE);
 return;
 }
 
",81,16
pass the rec struct into render_syscall_prefix," static char * render_arg(char *buffer, unsigned int argnum, struct syscallentry
 /*
 * Used from output_syscall_prefix, and also from postmortem dumper
 */
-static void render_syscall_prefix(char *buffer)
+static void render_syscall_prefix(struct syscallrecord *rec)
 {
 struct syscallentry *entry;
-struct syscallrecord *rec;
+char *buffer = rec->prebuffer;
 char *sptr = buffer;
 unsigned int i;
 unsigned int syscallnr;
 
-rec = &this_child->syscall;
 syscallnr = rec->nr;
 entry = get_syscall_entry(syscallnr, rec->do32bit);
 
 void output_syscall_prefix(void)
 
 memset(buffer, 0, PREBUFFER_LEN);// TODO: optimize to only strip ending
 
-render_syscall_prefix(buffer);
+render_syscall_prefix(rec);
 
 __output_syscall(buffer, PREBUFFER_LEN);
 }
",167,45
make render_syscall_postfix figure out where the buffer is," static void flushbuffer(char *buffer, FILE *fd)
 fflush(fd);
 }
 
-static void render_syscall_postfix(struct syscallrecord *rec, char *buffer)
+static void render_syscall_postfix(struct syscallrecord *rec)
 {
+char *buffer = rec->postbuffer;
 char *sptr = buffer;
 
 if (IS_ERR(rec->retval)) {
 void output_syscall_postfix(void)
 
 memset(buffer, 0, POSTBUFFER_LEN);// TODO: optimize to only strip ending post render.
 
-render_syscall_postfix(rec, buffer);
+render_syscall_postfix(rec);
 
 __output_syscall(buffer, POSTBUFFER_LEN);
 }
",168,45
pass the rec struct down to the log renderer routines.," static void __output_syscall(char *buffer, unsigned int len)
 }
 }
 
-/* This function is always called from a fuzzing child. */
-void output_syscall_prefix(void)
+/* These next two functions are always called from mkcall by a fuzzing child.
+ * They render the buffer, and output it (to both stdout and logs).
+ * Other contexts (like post-mortem directly use the buffers).
+ */
+void output_syscall_prefix(struct syscallrecord *rec)
 {
-struct syscallrecord *rec = &this_child->syscall;
 char *buffer = rec->prebuffer;
 
 memset(buffer, 0, PREBUFFER_LEN);// TODO: optimize to only strip ending
 void output_syscall_prefix(void)
 __output_syscall(buffer, PREBUFFER_LEN);
 }
 
-void output_syscall_postfix(void)
+void output_syscall_postfix(struct syscallrecord *rec)
 {
-struct syscallrecord *rec = &this_child->syscall;
 char *buffer = rec->postbuffer;
 
 memset(buffer, 0, POSTBUFFER_LEN);// TODO: optimize to only strip ending post render.
",166,45
move __syscall_return to syscall.h,"
 #include ""uid.h""
 #include ""utils.h""
 
-#define __syscall_return(type, res) \
-do { \
-if ((unsigned long)(res) >= (unsigned long)(-125)) { \
-errno = -(res); \
-res = -1; \
-} \
-return (type) (res); \
-} while (0)
-
 #ifdef ARCH_IS_BIARCH
 /*
 * This routine does 32 bit syscalls on 64 bit kernel.
",144,22
remove some unnecessary includes,"
 * Functions for actually doing the system calls.
 */
 
-#include <fcntl.h>
 #include <errno.h>
-#include <stdlib.h>
 #include <string.h>
-#include <unistd.h>
-#include <sys/types.h>
-#include <sys/ptrace.h>
 #include <sys/syscall.h>
-#include <sys/wait.h>
 
 #include ""arch.h""
 #include ""child.h""

 #include ""sanitise.h""
 #include ""shm.h""
 #include ""syscall.h""
-#include ""pids.h""
 #include ""log.h""
-#include ""params.h""
-#include ""maps.h""
 #include ""tables.h""
 #include ""uid.h""
 #include ""utils.h""
",135,22
pass the syscall record down to generic_free_arg," void generic_sanitise(struct syscallrecord *rec)
 rec->a6 = fill_arg(rec, 6);
 }
 
-void generic_free_arg(void)
+void generic_free_arg(struct syscallrecord *rec)
 {
-struct syscallrecord *rec;
 struct syscallentry *entry;
 unsigned int i, call;
 
-rec = &this_child->syscall;
-
 call = rec->nr;
 
 entry = syscalls[call].entry;
",356,123
pass the syscallrec to render_arg,"
 #include ""tables.h""
 #include ""utils.h""
 
-static char * render_arg(char *buffer, unsigned int argnum, struct syscallentry *entry)
+static char * render_arg(struct syscallrecord *rec, char *buffer, unsigned int argnum, struct syscallentry *entry)
 {
-struct syscallrecord *rec;
 char *sptr = buffer;
 const char *name = NULL;
 unsigned long reg = 0;
 enum argtype type = 0;
 
-rec = &this_child->syscall;
-
 switch (argnum) {
 case 1:type = entry->arg1type;
 name = entry->arg1name;
 static void render_syscall_prefix(struct syscallrecord *rec)
 sptr += sprintf(sptr, ""%s%s("", entry->name, ANSI_RESET);
 
 for (i = 1; i < entry->num_args + 1; i++)
-sptr = render_arg(sptr, i, entry);
+sptr = render_arg(rec, sptr, i, entry);
 
 (void) sprintf(sptr, ""%s) "", ANSI_RESET);
 }
",164,45
remove duplicate variable,"
 #include ""tables.h""
 #include ""utils.h""
 
-static char * render_arg(struct syscallrecord *rec, char *buffer, unsigned int argnum, struct syscallentry *entry)
+static char * render_arg(struct syscallrecord *rec, char *sptr, unsigned int argnum, struct syscallentry *entry)
 {
-char *sptr = buffer;
 const char *name = NULL;
 unsigned long reg = 0;
 enum argtype type = 0;
",163,45
check we're in child context before dereferencing ->child," unsigned int init_seed(unsigned int seedparam)
 */
 void set_seed(struct childdata *child)
 {
+if (child == NULL) {
+/* not in child context, must be main. */
+srand(shm->seed);
+return;
+}
 srand(shm->seed + (child->num + 1));
 child->seed = shm->seed;
 }
",63,13
"use the git-descibe output in the version number.

caveat: needs to re-run configure.sh, which kinda sucks.
Maybe I'll revisit it later and have Make do it instead."," int main(int argc, char* argv[])
 pid_t pid;
 const char taskname[13]=""trinity-main"";
 
-outputstd(""Trinity v"" __stringify(VERSION) "" Dave Jones <davej@redhat.com>\n"");
+outputstd(""Trinity "" VERSION "" Dave Jones <davej@redhat.com>\n"");
 
 progname = argv[0];
 
",121,17
argument numbers are always unsigned," static void post_mmap(struct syscallrecord *rec)
 dirty_mapping(new);
 }
 
-static char * decode_mmap(struct syscallrecord *rec, int argnum)
+static char * decode_mmap(struct syscallrecord *rec, unsigned int argnum)
 {
 char *buf;
 
",150,16
fix signedness of variable initialization," static bool handle_sigreturn(void)
 {
 struct syscallrecord *rec;
 static unsigned int count = 0;
-static unsigned int last = -1;
+static unsigned int last = 0;
 
 rec = &this_child->syscall;
 
",248,48
make set_dontkillme available outside the locking code.," static const struct child_funcs child_ops[] = {
 { .name = ""rand_syscalls"", .func = child_random_syscalls, .likelyhood = 100 },
 };
 
+/*
+ * Provide temporary immunity from the watchdog.
+ * This is useful if we're going to do something that might take
+ * longer than the time the watchdog is prepared to wait, especially if
+ * we're doing something critical, like handling a lock, or dumping a log.
+ */
+void set_dontkillme(pid_t pid, bool state)
+{
+int childno;
+
+childno = find_childno(pid);
+if (childno == CHILD_NOT_FOUND)/* possible, we might be the watchdog for example */
+return;
+shm->children[childno]->dontkillme = state;
+}
+
 /*
 * For the child processes, we don't want core dumps (unless we're running with -D)
 * This is because it's not uncommon for us to get segfaults etc when we're doing
",256,50
have the children wait for post-mortem to be done before they exit.," void child_process(void)
 }
 
 enable_coredumps();
+
+/* If we're exiting because we tainted, wait here for it to be done. */
+while (shm->postmortem_in_progress == TRUE) {
+/* Make sure the main process & watchdog are still around. */
+if (pid_alive(shm->mainpid) == -1)
+return;
+
+if (pid_alive(watchdog_pid) == -1)
+return;
+
+usleep(1);
+}
 }
",263,53
"taint_tv doesn't need to be in the shm

it only gets used in the post-mortem code, which is run from
watchdog context"," static void dump_syscall_records(void)
 
 void tainted_postmortem(int taint)
 {
+struct timeval taint_tv;
+
 shm->postmortem_in_progress = TRUE;
 
-shm->exit_reason = EXIT_KERNEL_TAINTED;
+//TODO: Sort syscall rec output by timeval, and mark when we detected taint_tv.
+gettimeofday(&taint_tv, NULL);
 
-gettimeofday(&shm->taint_tv, NULL);
+shm->exit_reason = EXIT_KERNEL_TAINTED;
 
 output(0, ""kernel became tainted! (%d/%d) Last seed was %u\n"",
 taint, kernel_taint_initial, shm->seed);
",60,10
"log.h doesn't need params.h any more.

fix missing include in syscall that the indirect include was papering over.","
 
 #include ""arch.h""
 #include ""child.h""
+#include ""params.h""// dopause
 #include ""random.h""
 #include ""sanitise.h""
 #include ""shm.h""
",136,22
move the backtrace code to debug.c,"
 * Various routines useful for debugging.
 */
 
+#include <execinfo.h>
 #include <stdio.h>
 #include ""config.h""
+#include ""debug.h""
 #include ""log.h""
 #include ""shm.h""
 
+#define BACKTRACE_SIZE 100
+
+void show_backtrace(void)
+{
+unsigned int j, nptrs;
+void *buffer[BACKTRACE_SIZE];
+char **strings;
+
+nptrs = backtrace(buffer, BACKTRACE_SIZE);
+
+strings = backtrace_symbols(buffer, nptrs);
+if (strings == NULL) {
+perror(""backtrace_symbols"");
+return;
+}
+
+for (j = 0; j < nptrs; j++)
+output(0, ""%s\n"", strings[j]);
+
+free(strings);
+}
+
 void __BUG(const char *bugtxt, const char *filename, const char *funcname, unsigned int lineno)
 {
 printf(""BUG!: %s%s%s\n"", ANSI_RED, bugtxt, ANSI_RESET);
",33,6
move BUG() to debug.h,"
 #include <sys/socket.h>
 #include <sys/stat.h>
 
+#include ""debug.h""
 #include ""log.h""
 #include ""net.h""
 #include ""maps.h""
",275,63
set the dontkillme flag while we spin in BUG," void __BUG(const char *bugtxt, const char *filename, const char *funcname, unsig
 show_backtrace();
 
 /* Now spin indefinitely (but allow ctrl-c) */
+
+set_dontkillme(getpid(), TRUE);
+
 while (1) {
-if (shm->exit_reason == EXIT_SIGINT)
+if (shm->exit_reason == EXIT_SIGINT) {
+set_dontkillme(getpid(), FALSE);
 exit(EXIT_FAILURE);
+}
 sleep(1);
 }
 }
",36,6
"after freeing the ldt, destroy the pointer, so we don't double free."," static void sanitise_modify_ldt(struct syscallrecord *rec)
 static void post_modify_ldt(__unused__ struct syscallrecord *rec)
 {
 free(ldt);
+ldt = NULL;
 }
 
 struct syscallentry syscall_modify_ldt = {
",44,5
silence the param parser when passing -qq," void parse_args(int argc, char *argv[])
 
 quiet_level = MAX_LOGLEVEL - quiet_level;
 
-outputstd(""Done parsing arguments.\n"");
+output(1, ""Done parsing arguments.\n"");
 }
",240,40
make kill_pid able to be called from watchdog context again.," void kill_pid(pid_t pid)
 int childno;
 
 childno = find_childno(pid);
-if (shm->children[childno]->dontkillme == TRUE)
-return;
+if (childno != CHILD_NOT_FOUND) {
+if (shm->children[childno]->dontkillme == TRUE)
+return;
+}
 
 ret = kill(pid, SIGKILL);
 if (ret != 0)
",60,12
add a special case to the child progress checker for the 'normal' case.," static void check_child_progress(struct childdata *child)
 else
 diff = now - old;
 
+/* hopefully the common case. */
+if (diff < 30)
+return;
+
 /* if we wrapped, just reset it, we'll pick it up next time around. */
 if (diff > 2145) {/* max adjtime offset. */
 output(1, ""child %u wrapped! old=%lu now=%lu\n"", child->num, old, now);
",303,59
create common kill path for stuck pids," static void check_child_progress(struct childdata *child)
 stuck_syscall_info(child);
 debugf(""child %d (pid %u) hasn't made progress in 30 seconds! Sending SIGKILL\n"",
 child->num, pid);
-child->kill_count++;
-kill_pid(pid);
+goto kill;
 }
 
 /* if we're still around after 40s, repeatedly send SIGKILLs every second. */
 if (diff >= 40) {
 debugf(""sending another SIGKILL to child %d (pid %u). [kill count:%d] [diff:%d]\n"",
 child->num, pid, child->kill_count, diff);
-child->kill_count++;
-kill_pid(pid);
+goto kill;
 }
+
+return;
+
+kill:
+child->kill_count++;
+kill_pid(pid);
 }
 
 static void watchdog(void)
",303,59
"remove unreachable test.

This is leftovers from before we had the >2145 test"," static void check_child_progress(struct childdata *child)
 return;
 }
 
-/* if we're way off, we're comparing garbage. Reset it. */
-if (diff > 1000) {
-output(0, ""huge delta! child %d [%d]: old:%ld now:%ld diff:%d. Setting to now.\n"",
-child->num, pid, old, now, diff);
-rec->tv.tv_sec = now;
-return;
-}
-
 /* After 30 seconds of no progress, send a kill signal. */
 if (diff == 30) {
 stuck_syscall_info(child);
",297,58
sort the time checks.," static void check_child_progress(struct childdata *child)
 if (diff < 30)
 return;
 
-/* if we wrapped, just reset it, we'll pick it up next time around. */
-if (diff > 2145) {/* max adjtime offset. */
-output(1, ""child %u wrapped! old=%lu now=%lu\n"", child->num, old, now);
-rec->tv.tv_sec = now;
-return;
-}
-
 /* After 30 seconds of no progress, send a kill signal. */
 if (diff == 30) {
 stuck_syscall_info(child);
 static void check_child_progress(struct childdata *child)
 goto kill;
 }
 
+/* if we wrapped, just reset it, we'll pick it up next time around. */
+if (diff > 2145) {/* max adjtime offset. */
+output(1, ""child %u wrapped! old=%lu now=%lu\n"", child->num, old, now);
+rec->tv.tv_sec = now;
+return;
+}
+
 return;
 
 kill:
",297,58
reorder the checks in check_if_fd so the argtype check is first.," unsigned int check_if_fd(struct syscallrecord *rec)
 do32 = rec->do32bit;
 unlock(&rec->lock);
 
-/* shortcut, if it's out of range, it's not going to be valid. */
+entry = get_syscall_entry(callno, do32);
+if (entry->arg1type != ARG_FD)
+return FALSE;
+
+/* if it's out of range, it's not going to be valid. */
 if (fd > 1024)
 return FALSE;
 
 unsigned int check_if_fd(struct syscallrecord *rec)
 if (fd < highest)
 return FALSE;
 
-entry = get_syscall_entry(callno, do32);
-
-if (entry->arg1type == ARG_FD)
-return TRUE;
-
-return FALSE;
+return TRUE;
 }
 
 static void stuck_syscall_info(struct childdata *child)
",297,58
move this_syscallname to tables.c," bool mkcall(void)
 
 return TRUE;
 }
-
-
-bool this_syscallname(const char *thisname)
-{
-unsigned int call = this_child->syscall.nr;
-struct syscallentry *syscall_entry = syscalls[call].entry;
-
-return strcmp(thisname, syscall_entry->name);
-}
",140,24
move mkcall innards into child_random_syscalls,"
 #include ""syscall.h""
 #include ""locks.h""
 #include ""log.h""
+#include ""params.h""// dopause
 #include ""random.h""
 #include ""shm.h""
 #include ""signals.h""
 retry:
 shm->exit_reason = EXIT_REACHED_COUNT;
 }
 
-/* Do the actual syscall. */
-return mkcall();
+/* Generate arguments, print them out */
+
+generate_syscall_args(rec);
+output_syscall_prefix(rec);
+
+/* If we're going to pause, might as well sync pre-syscall */
+if (dopause == TRUE)
+synclogs();
+
+do_syscall(rec);
+
+/* we're back. Output what happened, and clean up */
+output_syscall_postfix(rec);
+
+if (dopause == TRUE)
+sleep(1);
+
+handle_syscall_ret(rec);
+
+return TRUE;
 }
",85,16
move generate_syscall_args to generic-sanitise.c,"
 
 #include ""arch.h""// biarch
 #include ""child.h""
-#include ""syscall.h""
 #include ""locks.h""
 #include ""log.h""
 #include ""params.h""// dopause
+#include ""pids.h""
 #include ""random.h""
 #include ""shm.h""
 #include ""signals.h""
-#include ""pids.h""
+#include ""sanitise.h""
+#include ""syscall.h""
 #include ""tables.h""
 #include ""trinity.h""
 
",86,16
move the this_syscallname prototype to the right header,"
 #include ""compat.h""
 #include ""random.h""
 #include ""syscall.h""
+#include ""tables.h""
 #include ""trinity.h""
 #include ""utils.h""//ARRAY_SIZE
 
",151,16
"set GOING_AWAY rec->state before we do the execve call

as we'll never return."," void do_syscall(struct syscallrecord *rec)
 
 extrapid = fork();
 if (extrapid == 0) {
-__do_syscall();
-/* We should never get here. */
 rec->state = GOING_AWAY;
+__do_syscall(rec);
+/* We should never get here. */
 _exit(EXIT_SUCCESS);
 } else {
 if (pid_alive(extrapid)) {
",107,19
"in the child pid, wait for the sub-child to set state before killing."," void do_syscall(struct syscallrecord *rec)
 /* We should never get here. */
 _exit(EXIT_SUCCESS);
 } else {
-if (pid_alive(extrapid)) {
-sleep(1);
-kill(extrapid, SIGKILL);
-}
+while (rec->state != GOING_AWAY)
+usleep(1);
+
+kill(extrapid, SIGKILL);
 generic_free_arg();
 return;
 }
",106,19
set the subchild process name,"
 #include <errno.h>
 #include <string.h>
 #include <signal.h>
+#include <sys/prctl.h>
 #include <sys/syscall.h>
 
 #include ""arch.h""
 void do_syscall(struct syscallrecord *rec)
 
 extrapid = fork();
 if (extrapid == 0) {
+char childname[]=""trinity-subchild"";
+prctl(PR_SET_NAME, (unsigned long) &childname);
+
 rec->state = GOING_AWAY;
 __do_syscall(rec);
 /* We should never get here. */
",114,19
"add subchild waiting to the extra fork case, and unifdef it.

It seems to be doing the right thing now.","
 #include <signal.h>
 #include <sys/prctl.h>
 #include <sys/syscall.h>
+#include <sys/types.h>
+#include <sys/wait.h>
 
 #include ""arch.h""
 #include ""child.h""
+#include ""pids.h""
 #include ""random.h""
 #include ""sanitise.h""
 #include ""shm.h""
 static void __do_syscall(struct syscallrecord *rec)
 
 void do_syscall(struct syscallrecord *rec)
 {
-#if 0
+//#if 0
 struct syscallentry *entry;
 unsigned int call;
 
 void do_syscall(struct syscallrecord *rec)
 /* We should never get here. */
 _exit(EXIT_SUCCESS);
 } else {
+int childstatus;
+pid_t pid = 0;
+
 while (rec->state != GOING_AWAY)
 usleep(1);
 
-kill(extrapid, SIGKILL);
+while (pid == 0) {
+pid = waitpid(extrapid, &childstatus, WUNTRACED | WCONTINUED | WNOHANG);
+if (pid != 0)
+return;
+if (pid_alive(extrapid) == TRUE)
+kill(extrapid, SIGKILL);
+}
 generic_free_arg(rec);
 return;
 }
 }
-#endif
+//#endif
 
 /* common-case, do the syscall in this child process. */
 rec->state = BEFORE;
",125,21
sub-childs need to update the stats too.," void do_syscall(struct syscallrecord *rec)
 call = rec->nr;
 entry = syscalls[call].entry;
 
-if (entry->flags & EXTRA_FORK) {
-do_extrafork(rec);
-return;
-}
-
-/* common-case, do the syscall in this child process. */
 rec->state = BEFORE;
-__do_syscall(rec);
+
+if (entry->flags & EXTRA_FORK)
+do_extrafork(rec);
+else
+ /* common-case, do the syscall in this child process. */
+__do_syscall(rec);
 
 if (IS_ERR(rec->retval))
 shm->failures++;
",126,22
"if the subchild fails, we'll be in state 'AFTER' rather than GOING_AWAY"," static void do_extrafork(struct syscallrecord *rec)
 
 rec->state = GOING_AWAY;
 __do_syscall(rec);
-/* We should never get here. */
+/* if this was for eg. an successful execve, we should never get here.
+ * if it failed though... */
 _exit(EXIT_SUCCESS);
 }
 
 /* child */
-while (rec->state != GOING_AWAY)
-usleep(1);
-
 while (pid == 0) {
 int childstatus;
 
",124,21
ugly hackaround for when children spin forever when watchdog/main crashes," void lock(lock_t *_lock)
 
 _lock->contention++;
 usleep(1);
+
+/* if something bad happened, like main/watchdog crashed,
+ * we don't want to spin forever, so just get out.
+ */
+if (shm->exit_reason != STILL_RUNNING)
+_exit(EXIT_FAILURE);
 }
 
 _lock->contention = 0;
",76,15
dump some info about the child when we find a weird pid.,"
 
 #include <execinfo.h>
 #include <stdio.h>
+#include ""child.h""
 #include ""config.h""
 #include ""debug.h""
 #include ""log.h""
 void __BUG(const char *bugtxt, const char *filename, const char *funcname, unsig
 sleep(1);
 }
 }
+
+void dump_childdata(struct childdata *child)
+{
+output(0, ""syscall: %p\n"", child->syscall);
+output(0, ""previous syscall: %p\n"", child->previous);
+
+output(0, ""logfile: %p (dirty:%d)\n"", child->logfile, child->logdirty);
+
+output(0, ""mappings: %p (num:%d)\n"", child->mappings, child->num_mappings);
+
+output(0, ""seed: %ld\n"", child->seed);
+output(0, ""pid: %d\n"", child->pid);
+output(0, ""childnum: %d\n"", child->num);
+
+output(0, ""killcount: %d\n"", child->kill_count);
+output(0, ""dontkillme: %d\n"", child->dontkillme);
+};
",49,7
"make the mremap 'new' address shift higher.

Less chance of it colliding with something mapped low, which on
occasion causes random corruption of the shm."," static void sanitise_mremap(struct syscallrecord *rec)
 unsigned int shift = (__WORDSIZE / 2) - 1;
 
 newaddr = rand() % 256;
-newaddr <<= rand() % shift;
+newaddr <<= shift;
 newaddr |= align;
 newaddr &= ~(align - 1);
 }
",58,5
introduce wrapper for setting shm->exit_reason and use it everywhere," void init_child(int childno)
 /* Make sure parent is actually alive to wait for us. */
 ret = pid_alive(shm->mainpid);
 if (ret != 0) {
-shm->exit_reason = EXIT_SHM_CORRUPTION;
+panic(EXIT_SHM_CORRUPTION);
 outputerr(""BUG!: parent (%d) went away!\n"", shm->mainpid);
 sleep(20000);
 }
 static void check_parent_pid(void)
 print_syscall_name(child->previous.nr, child->previous.do32bit),
 child->syscall.op_nr);
 }
-shm->exit_reason = EXIT_REPARENT_PROBLEM;
+panic(EXIT_REPARENT_PROBLEM);
 
 out:
 unlock(&shm->buglock);
",263,53
"when we panic, set the flag to stop main spawning new pids."," dont_wait:
 output(0, ""Bailing main loop. Exit reason: %s\n"", decode_exit(shm->exit_reason));
 }
 
+/*
+ * Something potentially bad happened. Alert all processes by setting appropriate shm vars.
+ * (not always 'bad', reaching max count for eg is one example).
+ */
 void panic(int reason)
 {
+shm->spawn_no_more = TRUE;
 shm->exit_reason = reason;
 }
",247,54
reword child creation text," static void fork_children(void)
 shm->children[childno]->pid = pid;
 shm->running_childs++;
 
-debugf(""Created child %d in childno %d [total:%d/%d]\n"",
-pid, childno, shm->running_childs, max_children);
+debugf(""Created child %d (pid:%d) [total:%d/%d]\n"",
+childno, pid, shm->running_childs, max_children);
 
 if (shm->exit_reason != STILL_RUNNING)
 return;
",247,54
"the 'something bad' path is only for child processes, not the watchdog"," void lock(lock_t *_lock)
  * (or worse, a dead child), we'll never call check_lock()
  * from the watchdog loop because we'll be stuck here.
  */
-if (pid == watchdog_pid)
+if (pid == watchdog_pid) {
 check_lock(_lock);
+} else {
+/* Ok, we're a child pid.
+ * if something bad happened, like main/watchdog crashed,
+ * we don't want to spin forever, so just get out.
+ */
+if (shm->exit_reason != STILL_RUNNING)
+_exit(EXIT_FAILURE);
+}
 
 _lock->contention++;
 usleep(1);
-
-/* if something bad happened, like main/watchdog crashed,
- * we don't want to spin forever, so just get out.
- */
-if (shm->exit_reason != STILL_RUNNING)
-_exit(EXIT_FAILURE);
 }
 
 _lock->contention = 0;
",78,15
don't bail early if we're exiting because EXIT_REACHED_COUNT," void lock(lock_t *_lock)
  * if something bad happened, like main/watchdog crashed,
  * we don't want to spin forever, so just get out.
  */
-if (shm->exit_reason != STILL_RUNNING)
+if ((shm->exit_reason != STILL_RUNNING) &&
+ (shm->exit_reason != EXIT_REACHED_COUNT)) {
 _exit(EXIT_FAILURE);
+}
 }
 
 _lock->contention++;
",80,16
"always skip over EMPTY_PIDSLOT, regardless of syscallrecord contents"," static void check_parent_pid(void)
 child = shm->children[i];
 
 // Skip over 'boring' entries.
-if ((child->pid == EMPTY_PIDSLOT) &&
- (child->previous.nr == 0) &&
- (child->syscall.op_nr == 0))
+if (child->pid == EMPTY_PIDSLOT)
 continue;
 
 output(0, ""[%d] pid:%d call:%s callno:%d\n"",
",261,51
only spew the sanity check fail msg once.," static unsigned int reap_dead_kids(void)
 continue;
 
 if (pid_is_valid(pid) == FALSE) {
+static bool once = FALSE;
+
+if (once != FALSE)
+return 0;
+
 output(0, ""Sanity check failed! Found pid %u at pidslot %u!\n"", pid, i);
 
 if (shm->exit_reason == STILL_RUNNING)
 panic(EXIT_PID_OUT_OF_RANGE);
 dump_childdata(child);
+once = TRUE;
 return 0;
 }
 
",305,59
"only re-output the ""still running"" message if it's changed since last time."," main_dead:
 if (pidmap_empty() == TRUE)
 watchdog_exit = TRUE;
 else {
-output(0, ""exit_reason=%d, but %d children still running.\n"",
-shm->exit_reason, shm->running_childs);
+static unsigned int last = 0;
+
+if (last != shm->running_childs) {
+last = shm->running_childs;
+
+output(0, ""exit_reason=%d, but %d children still running.\n"",
+shm->exit_reason, shm->running_childs);
+}
 kill_all_kids();
 }
 }
",309,60
"move the opening of child logfiles into the child process.

Instead of using up fd's in main, and inheriting them on fork.
If we ran with a large -C, we'd eat up a lot of fd's in every
process because of this. Now we just have one logfile fd per child."," static void oom_score_adj(int adj)
 fclose(fp);
 }
 
-/*
- * Reset a log file contents.
- * If we successfully exited and respawned, we don't care about what
- * happened last time.
- */
-static void truncate_log(void)
-{
-int fd;
-
-this_child->logdirty = FALSE;
-
-if (logging == FALSE)
-return;
-
-fd = fileno(this_child->logfile);
-if (ftruncate(fd, 0) == 0)
-lseek(fd, 0, SEEK_SET);
-}
-
 /*
 * Wipe out any state left from a previous child running in this slot.
 * Right now the logfile entry is the only persistent thing across instances.
 void init_child(int childno)
 
 reinit_child(child);
 
-truncate_log();
+open_child_logfile(child);
 
 set_seed(this_child);
 
",251,48
"clear the guard page after the rand page, and check it.

it's sort of lazy right now, and only shouts if the first byte
is non-zero. In most scribbles historically though, that has
triggered. It seems pretty safe right now, but I want to keep this
around at least during development."," retry:
 synclogs();
 
 do_syscall(rec);
+check_page_rand_redzone();
 
 /* we're back. Output what happened, and clean up */
 output_syscall_postfix(rec);
",87,16
"remove highest_logfile()

Now that the logfiles are opened by the child process, this needs
to read the fd number from the child struct instead."," static bool handle_sigreturn(void)
 bust_lock(&rec->lock);
 
 /* Check if we're blocked because we were stuck on an fd. */
-if (check_if_fd(rec) == TRUE) {
+if (check_if_fd(this_child, rec) == TRUE) {
 /* avoid doing it again from other threads. */
 shm->fd_lifetime = 0;
 
",251,48
"an experiment to check expected return values.

unsure if I'll keep this, but maybe it'll be useful at least for
finding gaps in man pages.","
 *
 * TODO: Redirect stdin/stdout.
 */
+#include <errno.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include ""arch.h""// page_size
 struct syscallentry syscall_execve = {
 .sanitise = sanitise_execve,
 .group = GROUP_VFS,
 .flags = EXTRA_FORK,
+.retvals = {
+.num = 17,
+.values = {
+E2BIG, EACCES, EFAULT, EINVAL, EIO, EISDIR, ELIBBAD, ELOOP,
+EMFILE, ENOENT, ENOEXEC, ENOMEM, ENOTDIR, EPERM, ETXTBSY,
+/* currently undocumented in man page. */
+ENAMETOOLONG, ENXIO,
+},
+},
 };
",51,5
"fix ""not filled out yet"" check on return code checker."," static void check_retval_documented(struct syscallrecord *rec, struct syscallent
 
 /* Only check syscalls we've documented so far. */
 retvals = &entry->retvals;
-if (retvals == NULL)
+if (retvals->num == 0)
 return;
 
 lock(&shm->syscalltable_lock);
",152,29
rename retvals to errnos," struct syscallentry syscall_execve = {
 .sanitise = sanitise_execve,
 .group = GROUP_VFS,
 .flags = EXTRA_FORK,
-.retvals = {
+.errnos = {
 .num = 17,
 .values = {
 E2BIG, EACCES, EFAULT, EINVAL, EIO, EISDIR, ELIBBAD, ELOOP,
",51,5
only do the ENOSYS check in AFTER state.," static void check_retval_documented(struct syscallrecord *rec, struct syscallent
 struct errnos *errnos;
 unsigned int i;
 
-/* only check syscalls that completed. */
-if (rec->state != AFTER)
-return;
-
 /* Only check syscalls we've documented so far. */
 errnos = &entry->errnos;
 if (errnos->num == 0)
 void handle_syscall_ret(struct syscallrecord *rec)
 entry = syscalls[call].entry;
 
 if (rec->retval == -1UL) {
-check_retval_documented(rec, entry);
-
-deactivate_enosys(rec, entry, call);
+/* only check syscalls that completed. */
+if (rec->state == AFTER) {
+check_retval_documented(rec, entry);
+deactivate_enosys(rec, entry, call);
+}
 }
 
 if (entry->post)
",158,29
dump childnos from watchdog when sanity check fails," static unsigned int reap_dead_kids(void)
 
 output(0, ""Sanity check failed! Found pid %u at pidslot %u!\n"", pid, i);
 
+dump_childnos();
+
 if (shm->exit_reason == STILL_RUNNING)
 panic(EXIT_PID_OUT_OF_RANGE);
 dump_childdata(child);
",308,60
add missing printf parameter to locking debug statement," static void check_lock(lock_t *_lock)
 
 /* If a pid has had a lock a long time, something is up. */
 if (_lock->contention > STEAL_THRESHOLD) {
-debugf(""pid %d has held lock for too long. Releasing, and killing.\n"");
+debugf(""pid %d has held lock for too long. Releasing, and killing.\n"", pid);
 kill_pid(pid);
 unlock(_lock);
 return;
",80,16
"remove unnecessary pid check.

if pid becomes non-zero we bail the while loop and return anyway."," static void do_extrafork(struct syscallrecord *rec)
 int childstatus;
 
 pid = waitpid(extrapid, &childstatus, WUNTRACED | WCONTINUED | WNOHANG);
-if (pid != 0)
-return;
 if (pid_alive(extrapid) == TRUE)
 kill(extrapid, SIGKILL);
 }
",156,28
"fix unreachable code in watchdog

the >40s code was never executed."," static void check_child_progress(struct childdata *child)
 stuck_syscall_info(child);
 debugf(""child %d (pid %u) hasn't made progress in 30 seconds! Sending SIGKILL\n"",
 child->num, pid);
-goto kill;
+child->kill_count++;
+kill_pid(pid);
 }
 
 /* if we're still around after 40s, repeatedly send SIGKILLs every second. */
-if (diff >= 40) {
-debugf(""sending another SIGKILL to child %d (pid %u). [kill count:%d] [diff:%d]\n"",
-child->num, pid, child->kill_count, diff);
-goto kill;
-}
+if (diff < 40)
+return;
+
+debugf(""sending another SIGKILL to child %d (pid %u). [kill count:%d] [diff:%d]\n"",
+child->num, pid, child->kill_count, diff);
+child->kill_count++;
+kill_pid(pid);
 
 /* if we wrapped, just reset it, we'll pick it up next time around. */
 if (diff > 2145) {/* max adjtime offset. */
 static void check_child_progress(struct childdata *child)
 rec->tv.tv_sec = now;
 return;
 }
-
-return;
-
-kill:
-child->kill_count++;
-kill_pid(pid);
 }
 
 static void watchdog(void)
",306,60
export dump_syscallrec," void __BUG(const char *bugtxt, const char *filename, const char *funcname, unsig
 }
 }
 
-static void dump_syscallrec(struct syscallrecord *rec)
+void dump_syscallrec(struct syscallrecord *rec)
 {
 output(0, "" tv.tvsec=%d tv.usec=%d\n"", rec->tv.tv_sec, rec->tv.tv_usec);
 output(0, "" nr:%d a1:%lx a2:%lx a3:%lx a4:%lx a5:%lx a6:%lx retval:%ld errno_post:%d\n"",
",67,8
don't try to fclose the logfile if it hasn't been opened," void open_child_logfile(struct childdata *child)
 
 void close_logfile(FILE **filehandle)
 {
+if (*filehandle == NULL)
+return;
+
 fclose(*filehandle);
 *filehandle = NULL;
 }
",228,47
watchdog: don't do fileno on child logfile fd if it hasn't been set yet.," unsigned int check_if_fd(struct childdata *child, struct syscallrecord *rec)
 if (fd > 1024)
 return FALSE;
 
+if (child->logfile == NULL)
+return FALSE;
+
 if (fd <= (unsigned int) fileno(child->logfile))
 return FALSE;
 
",308,61
output the parent pid when we get reparented.," void init_child(int childno)
 static void check_parent_pid(void)
 {
 struct childdata *child;
-pid_t pid;
+pid_t pid, ppid;
 unsigned int i;
 
-if (getppid() == shm->mainpid)
+ppid = getppid();
+if (ppid == shm->mainpid)
 return;
 
 pid = getpid();
 static void check_parent_pid(void)
 goto out;
 
 output(0, ""BUG!: CHILD (pid:%d) GOT REPARENTED! ""
-""parent pid:%d. Watchdog pid:%d\n"",
-pid, shm->mainpid, watchdog_pid);
+""main pid:%d. ppid=%d Watchdog pid:%d\n"",
+pid, shm->mainpid, ppid, watchdog_pid);
 output(0, ""BUG!: Last syscalls:\n"");
 
 //TODO: replace all this with calls to postmortem()
",252,48
"handle some common reparent cases.

Screwing around with setns and friends can cause our ppid to change.
We don't handle this well at all, so we'll have to just exit the child
for now until we come up with a better plan."," static void check_parent_pid(void)
 
 pid = getpid();
 
+/* TODO: it'd be neat to do stuff inside pidns's, but right now
+ * we shit ourselves when we exit and get reparented to pid 1
+ */
+if (pid == ppid) {
+debugf(""pid became ppid! exiting child.\n"");
+_exit(EXIT_FAILURE);
+}
+
+if (ppid == 0) {
+debugf(""ppid == 0. pidns? exiting child.\n"");
+_exit(EXIT_FAILURE);;
+}
+
 lock(&shm->buglock);
 
 if (shm->exit_reason == EXIT_REPARENT_PROBLEM)
 static void check_parent_pid(void)
 output(0, ""BUG!: CHILD (pid:%d) GOT REPARENTED! ""
 ""main pid:%d. ppid=%d Watchdog pid:%d\n"",
 pid, shm->mainpid, ppid, watchdog_pid);
+
 output(0, ""BUG!: Last syscalls:\n"");
 
 //TODO: replace all this with calls to postmortem()
",260,50
output whether or not main is still alive when we get reparented," static void check_parent_pid(void)
 ""main pid:%d. ppid=%d Watchdog pid:%d\n"",
 pid, shm->mainpid, ppid, watchdog_pid);
 
+if (pid_alive(shm->mainpid) == -1)
+output(0, ""main pid %d is dead.\n"", shm->mainpid);
+
 output(0, ""BUG!: Last syscalls:\n"");
 
 //TODO: replace all this with calls to postmortem()
",262,51
"remove the 'dump previous syscalls' from check_parent_pid

we only call this periodically, so the last syscalls are likely irrelevant.
For the same reason, remove the TODO about postmortem"," static void check_parent_pid(void)
 
 output(0, ""BUG!: Last syscalls:\n"");
 
-//TODO: replace all this with calls to postmortem()
-for_each_child(i) {
-child = shm->children[i];
-
-// Skip over 'boring' entries.
-if (child->pid == EMPTY_PIDSLOT)
-continue;
-
-output(0, ""[%d] pid:%d call:%s callno:%d\n"",
-i, child->pid,
-print_syscall_name(child->previous.nr, child->previous.do32bit),
-child->syscall.op_nr);
-}
 panic(EXIT_REPARENT_PROBLEM);
 
 out:
",253,50
"do the sleep /after/ the backtrace, not before."," void lock(lock_t *_lock)
 if (_lock->owner == pid) {
 debugf(""lol, already have lock!\n"");
 set_dontkillme(pid, TRUE);
-sleep(3);
 show_backtrace();
+sleep(3);
 set_dontkillme(pid, FALSE);
 return;
 }
",80,16
increase the lock steal threshold,"
 * And if they are, ensure they haven't held them for an
 * excessive length of time.
 */
-#define STEAL_THRESHOLD 100000
+#define STEAL_THRESHOLD 1000000
 
 static void check_lock(lock_t *_lock)
 {
",80,16
fold create_child_structs into init_shm," void create_shm(void)
 shm = p + SHM_PROT_PAGES * page_size;
 }
 
-void create_child_structs(void)
-{
-unsigned int i;
-
-shm->children = alloc_shared(max_children * sizeof(struct childdata *));
-
-for_each_child(i)
-shm->children[i] = (struct childdata *) alloc_shared(sizeof(struct childdata));
-}
-
 void init_shm(void)
 {
 unsigned int i;
 void init_shm(void)
 /* Set seed in parent thread */
 set_seed(NULL);
 
+shm->children = alloc_shared(max_children * sizeof(struct childdata *));
+
 for_each_child(i) {
-struct childdata *child = shm->children[i];
+struct childdata *child;
 struct syscallrecord *syscall, *previous;
 
+child = alloc_shared(sizeof(struct childdata));
+shm->children[i] = child;
+
 syscall = &child->syscall;
 previous = &child->previous;
 
",53,3
wipe the child->syscallrec structs with memset instead of by hand," void init_shm(void)
 
 for_each_child(i) {
 struct childdata *child;
-struct syscallrecord *syscall, *previous;
 
 child = alloc_shared(sizeof(struct childdata));
 shm->children[i] = child;
 
-syscall = &child->syscall;
-previous = &child->previous;
+memset(&child->syscall, 0, sizeof(struct syscallrecord));
+memset(&child->previous, 0, sizeof(struct syscallrecord));
 
 child->pid = EMPTY_PIDSLOT;
-
-previous->nr = syscall->nr = -1;
-
-previous->a1 = syscall->a1 = -1;
-previous->a2 = syscall->a2 = -1;
-previous->a3 = syscall->a3 = -1;
-previous->a4 = syscall->a4 = -1;
-previous->a5 = syscall->a5 = -1;
-previous->a6 = syscall->a6 = -1;
 }
 }
",45,3
remove leftover output from reparent debug," static void check_parent_pid(void)
 if (pid_alive(shm->mainpid) == -1)
 output(0, ""main pid %d is dead.\n"", shm->mainpid);
 
-output(0, ""BUG!: Last syscalls:\n"");
-
 panic(EXIT_REPARENT_PROBLEM);
 
 out:
",250,50
exit immediately when reparented," static void check_parent_pid(void)
 
 out:
 unlock(&shm->buglock);
-exit(EXIT_FAILURE);
+_exit(EXIT_FAILURE);
 }
 
 /*
",250,50
"if a child gets reparented to init, exit."," static void check_parent_pid(void)
 _exit(EXIT_FAILURE);
 }
 
-if (ppid == 0) {
-debugf(""ppid == 0. pidns? exiting child.\n"");
+if (ppid < 2) {
+debugf(""ppid == %d. pidns? exiting child.\n"", ppid);
 _exit(EXIT_FAILURE);;
 }
 
",250,50
"when acquiring the lock, do the state transition first.

There was a tiny race here where two pids could get the same lock."," void lock(lock_t *_lock)
 usleep(1);
 }
 
+_lock->lock = LOCKED;
 _lock->contention = 0;
 _lock->owner = pid;
-_lock->lock = LOCKED;
 }
 
 void unlock(lock_t *_lock)
",80,16
remove the sleep from after the log debug," void lock(lock_t *_lock)
 debugf(""lol, already have lock!\n"");
 set_dontkillme(pid, TRUE);
 show_backtrace();
-sleep(3);
 set_dontkillme(pid, FALSE);
 return;
 }
",79,16
"move the dontkillme setting into show_backtrace

I still don't know why sometimes show_backtrace hangs for several
seconds. My guess is some fuzzing has corrupted the symbol table,
and the unwinder goes crazy. It always seems to coincide with
getting an empty trace."," void show_backtrace(void)
 void *buffer[BACKTRACE_SIZE];
 char **strings;
 
+set_dontkillme(getpid(), FALSE);
+
 nptrs = backtrace(buffer, BACKTRACE_SIZE);
 
 strings = backtrace_symbols(buffer, nptrs);
 if (strings == NULL) {
 perror(""backtrace_symbols"");
-return;
+goto out;
 }
 
 for (j = 0; j < nptrs; j++)
 output(0, ""%s\n"", strings[j]);
 
 free(strings);
+out:
+set_dontkillme(getpid(), TRUE);
 }
 
 void __BUG(const char *bugtxt, const char *filename, const char *funcname, unsigned int lineno)
",70,8
"if we double take a lock, we should fail hard"," void lock(lock_t *_lock)
 if (_lock->owner == pid) {
 debugf(""lol, already have lock!\n"");
 show_backtrace();
-return;
+_exit(EXIT_FAILURE);
 }
 
 /* This is pretty horrible. But if we call lock()
",77,16
"if we double lock, tell other children to die too.","
 #include ""locks.h""
 #include ""log.h""
 #include ""pids.h""
+#include ""trinity.h""
 #include ""utils.h""
 
 /*
 void lock(lock_t *_lock)
 if (_lock->owner == pid) {
 debugf(""lol, already have lock!\n"");
 show_backtrace();
+panic(EXIT_LOCKING_CATASTROPHE);
 _exit(EXIT_FAILURE);
 }
 
",79,16
"wholesize is always multed by page_size, so just do it once"," void create_shm(void)
 
 /* round up shm to nearest page size */
 shm_pages = ((sizeof(struct shm_s) + page_size - 1) & PAGE_MASK) / page_size;
-wholesize = SHM_PROT_PAGES + shm_pages + SHM_PROT_PAGES;
+wholesize = (SHM_PROT_PAGES + shm_pages + SHM_PROT_PAGES) * page_size;
 
 /* Waste some address space to set up some ""protection"" near the SHM location. */
-p = alloc_shared(wholesize * page_size);
+p = alloc_shared(wholesize);
 
 redbefore = p;
 redafter = p + (SHM_PROT_PAGES + shm_pages) * page_size;
 void create_shm(void)
 shm = p + (SHM_PROT_PAGES * page_size);
 memset(shm, 0, shm_pages * page_size);
 printf(""shm: redzone:%p. shmdata:%p. redzone:%p end:%p.\n"",
-redbefore, shm, redafter,
-p + (wholesize * page_size));
+redbefore, shm, redafter, p + wholesize);
 }
 
 void init_shm(void)
",53,3
"remove unnecessary sleep

we never stay here long enough that this is a big deal, and the sleep
actually means in some cases the children start running slightly
before the watchdog starts its main loop.

In practise, not a problem, but the text output looks odd."," static void watchdog(void)
 int ret = 0;
 
 while (shm->ready == FALSE) {
-sleep(1);
 if (shm->exit_reason != STILL_RUNNING)
 return;
 }
",307,61
move the check_if_fd lock-taking up into the caller.," static bool handle_sigreturn(void)
 bust_lock(&rec->lock);
 
 /* Check if we're blocked because we were stuck on an fd. */
+lock(&rec->lock);
 if (check_if_fd(this_child, rec) == TRUE) {
 /* avoid doing it again from other threads. */
 shm->fd_lifetime = 0;
 
 /* TODO: Somehow mark the fd in the parent not to be used again too. */
 }
+unlock(&rec->lock);
 
 output(2, ""<timed out>\n""); /* Flush out the previous syscall output. */
 
",252,50
"make stuck_syscall_info check the rec->state first

In any other state, we can't possibly be still blocked on the fd."," static void stuck_syscall_info(struct childdata *child)
 do32 = rec->do32bit;
 callno = rec->nr;
 
-if (check_if_fd(child, rec) == TRUE)
-sprintf(fdstr, ""(fd = %d)"", (unsigned int) rec->a1);
+/* we can only be 'stuck' if we're still doing the syscall. */
+if (rec->state == BEFORE) {
+if (check_if_fd(child, rec) == TRUE)
+sprintf(fdstr, ""(fd = %d)"", (unsigned int) rec->a1);
+}
 
 unlock(&rec->lock);
 
",307,62
"reintroduce sleep in watchdog startup.

5bff6ff1e011236e495a124a9a6e78daf8cddba7 was actually necessary,
otherwise we seem to just spin there for the entire time the watchdog
process runs.

We can get by with a much smaller sleep however."," static void watchdog(void)
 int ret = 0;
 
 while (shm->ready == FALSE) {
+usleep(1);
 if (shm->exit_reason != STILL_RUNNING)
 return;
 }
",308,62
dump reason why watchdog exits," static const char *reasons[NUM_EXIT_REASONS] = {
 ""some kind of locking catastrophe"",
 };
 
-static const char * decode_exit(unsigned int reason)
+const char * decode_exit(unsigned int reason)
 {
 return reasons[reason];
 }
",249,54
decode_exit will only ever take shm->exit_reason," static const char *reasons[NUM_EXIT_REASONS] = {
 ""some kind of locking catastrophe"",
 };
 
-const char * decode_exit(unsigned int reason)
+const char * decode_exit(void)
 {
-return reasons[reason];
+return reasons[shm->exit_reason];
 }
 
 void main_loop(void)
 void main_loop(void)
 handle_children();
 
 dont_wait:
-output(0, ""Bailing main loop. Exit reason: %s\n"", decode_exit(shm->exit_reason));
+output(0, ""Bailing main loop because %s.\n"", decode_exit());
 }
 
 /*
",249,54
"replace the crappy pagerand dumper with a write to a file.

feeding this to hexdump/strings etc is more useful than
reimplementing the same thing within trinity.","
+#include <errno.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 static void fabricate_onepage_struct(char *page)
 
 void check_page_rand_redzone(void)
 {
-unsigned int i;
+FILE *fd;
 
 if (page_rand[page_size] == 0)
 return;
 
 output(0, ""Something stomped the rand page guard page at %p!\n"", page_rand + page_size);
 
-for (i = 0; i < page_size; i++) {
-if (page_rand[page_size + i] != 0)
-printf (""%d: %x\n"", i, page_rand[page_size + i]);
+fd = fopen(""trinity-pagerand.log"", ""w"");
+if (!fd) {
+outputerr(""Failed to dump page_rand log (%s)\n"", strerror(errno));
+return;
 }
 
-dump_childdata(this_child);
-sleep(60);
+fwrite(page_rand, page_size, 2, fd);
+
+fclose(fd);
 }
 
 
",135,38
"generate the version string at make time, instead of configure time.","
 #include ""log.h""
 #include ""shm.h""
 #include ""syscall.h""
+#include ""version.h""
 
 #define BACKTRACE_SIZE 100
 
",71,8
output pid of exiting child as well as childno," static void fork_children(void)
 /* Child process. */
 init_child(childno);
 child_process();
-debugf(""child %d exiting.\n"", childno);
+debugf(""child %d %d exiting.\n"", childno, getpid());
 close_logfile(&this_child->logfile);
 _exit(EXIT_SUCCESS);
 } else {
",249,54
convert alloc_zero_map to use zmalloc," static void alloc_zero_map(unsigned long size, int prot, const char *name)
 exit(EXIT_FAILURE);
 }
 
-newnode->name = malloc(80);
-if (!newnode->name) {
-outputerr(""malloc() failed in %s()."", __func__);
-exit(EXIT_FAILURE);
-}
+newnode->name = zmalloc(80);
 
 sprintf(newnode->name, ""anon(%s)"", name);
 
",83,7
proto-alg: zmalloc conversion,"
 #include <stdlib.h>
 #include ""config.h""
 #include ""net.h""
+#include ""utils.h""
 #include ""compat.h""
 
 #define SOL_ALG 279
 void alg_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 struct sockaddr_alg *alg;
 unsigned int i;
 
-alg = malloc(sizeof(struct sockaddr_alg));
-if (alg == NULL)
-return;
+alg = zmalloc(sizeof(struct sockaddr_alg));
 
 alg->salg_family = PF_ALG;
 for (i = 0; i < 14; i++)
",29,4
proto-appletalk: zmalloc conversion,"
 #include <linux/atalk.h>
 #include ""random.h""
 #include ""net.h""
+#include ""utils.h""
 
 void atalk_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 {
 struct sockaddr_at *atalk;
 
-atalk = malloc(sizeof(struct sockaddr_at));
-if (atalk == NULL)
-return;
+atalk = zmalloc(sizeof(struct sockaddr_at));
 
 atalk->sat_family = PF_APPLETALK;
 atalk->sat_port = rand();
",35,4
proto-atm: zmalloc conversions," void atmpvc_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 {
 struct sockaddr_atmpvc *atmpvc;
 
-atmpvc = malloc(sizeof(struct sockaddr_atmpvc));
-if (atmpvc == NULL)
-return;
+atmpvc = zmalloc(sizeof(struct sockaddr_atmpvc));
 
 atmpvc->sap_family = PF_ATMPVC;
 atmpvc->sap_addr.itf = rand();
 void atmsvc_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 struct sockaddr_atmsvc *atmsvc;
 unsigned int i;
 
-atmsvc = malloc(sizeof(struct sockaddr_atmsvc));
-if (atmsvc == NULL)
-return;
+atmsvc = zmalloc(sizeof(struct sockaddr_atmsvc));
 
 atmsvc->sas_family = PF_ATMSVC;
 for (i = 0; i < ATM_ESA_LEN; i++)
",47,5
proto-ax25: zmalloc conversion," void ax25_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 {
 struct sockaddr_ax25 *ax25;
 
-ax25 = malloc(sizeof(struct sockaddr_ax25));
-if (ax25 == NULL)
-return;
+ax25 = zmalloc(sizeof(struct sockaddr_ax25));
 
 ax25->sax25_family = PF_AX25;
 memcpy(ax25->sax25_call.ax25_call, page_rand, 7);
",62,6
proto-caif: zmalloc conversion," void caif_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 struct sockaddr_caif *caif;
 unsigned int i;
 
-caif = malloc(sizeof(struct sockaddr_caif));
-if (caif == NULL)
-return;
+caif = zmalloc(sizeof(struct sockaddr_caif));
 
 caif->family = PF_CAIF;
 caif->u.at.type = rand();
",50,7
proto-can: zmalloc conversion,"
 #include <stdlib.h>
 #include ""net.h""
 #include ""random.h""
+#include ""utils.h""
 #include ""compat.h""
 
 void can_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 {
 struct sockaddr_can *can;
 
-can = malloc(sizeof(struct sockaddr_can));
-if (can == NULL)
-return;
+can = zmalloc(sizeof(struct sockaddr_can));
+
 can->can_family = AF_CAN;
 can->can_ifindex = rand();
 can->can_addr.tp.rx_id = rand();
",26,2
proto-decnet: zmalloc conversion," void decnet_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 struct sockaddr_dn *dn;
 unsigned int i;
 
-dn = malloc(sizeof(struct sockaddr_dn));
-if (dn == NULL)
-return;
+dn = zmalloc(sizeof(struct sockaddr_dn));
 
 dn->sdn_family = PF_DECnet;
 dn->sdn_flags = rand();
",52,5
proto-econet: zmalloc conversion,"
 #include <neteconet/ec.h>
 #include <stdlib.h>
 #include ""net.h""
+#include ""utils.h""
 
 void econet_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 {
 struct sockaddr_ec *ec;
 
-ec = malloc(sizeof(struct sockaddr_ec));
-if (ec == NULL)
-return;
+ec = zmalloc(sizeof(struct sockaddr_ec));
 
 ec->sec_family = PF_ECONET;
 ec->port = rand();
",22,1
proto-ipv6: zmalloc conversion," void ipv6_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 {
 struct sockaddr_in6 *ipv6;
 
-ipv6 = malloc(sizeof(struct sockaddr_in6));
-if (ipv6 == NULL)
-return;
+ipv6 = zmalloc(sizeof(struct sockaddr_in6));
 
 ipv6->sin6_family = PF_INET6;
 ipv6->sin6_addr.s6_addr32[0] = 0;
",58,7
proto-ipx: zmalloc conversion,"
 #include <netipx/ipx.h>
 #include ""net.h""
 #include ""random.h""
+#include ""utils.h""
 
 void ipx_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 {
 struct sockaddr_ipx *ipx;
 unsigned int i;
 
-ipx = malloc(sizeof(struct sockaddr_ipx));
-if (ipx == NULL)
-return;
+ipx = zmalloc(sizeof(struct sockaddr_ipx));
 
 ipx->sipx_family = PF_IPX;
 ipx->sipx_port = rand();
",34,4
proto-irda: zmalloc conversion," void irda_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 struct sockaddr_irda *irda;
 unsigned int i;
 
-irda = malloc(sizeof(struct sockaddr_irda));
-if (irda == NULL)
-return;
+irda = zmalloc(sizeof(struct sockaddr_irda));
 
 irda->sir_family = PF_IRDA;
 irda->sir_lsap_sel = rand();
",54,8
proto-llc: zmalloc conversion," void llc_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 struct sockaddr_llc *llc;
 unsigned int i;
 
-llc = malloc(sizeof(struct sockaddr_llc));
-if (llc == NULL)
-return;
+llc = zmalloc(sizeof(struct sockaddr_llc));
+
 llc->sllc_family = AF_LLC;
 llc->sllc_arphrd = ARPHRD_ETHER;
 llc->sllc_test = rand();
",50,5
proto-netlink: zmalloc conversion," void netlink_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 {
 struct sockaddr_nl *nl;
 
-nl = malloc(sizeof(struct sockaddr_nl));
-if (nl == NULL)
-return;
+nl = zmalloc(sizeof(struct sockaddr_nl));
 
 nl->nl_family = PF_NETLINK;
 nl->nl_pid = get_pid();
",41,4
proto-nfc: zmalloc conversion,"
 #include ""compat.h""
 #include ""net.h""
 #include ""random.h""
+#include ""utils.h""
 
 void nfc_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 {
 struct sockaddr_nfc *nfc;
 
 // TODO: See also sockaddr_nfc_llcp
-nfc = malloc(sizeof(struct sockaddr_nfc));
-if (nfc == NULL)
-return;
+nfc = zmalloc(sizeof(struct sockaddr_nfc));
 
 nfc->sa_family = PF_NFC;
 nfc->dev_idx = rand();
",38,5
proto-packet: zmalloc conversion," void packet_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 unsigned int i;
 
 //TODO: See also sockaddr_ll
-pkt = malloc(sizeof(struct sockaddr_pkt));
-if (pkt == NULL)
-return;
+pkt = zmalloc(sizeof(struct sockaddr_pkt));
 
 pkt->spkt_family = PF_PACKET;
 for (i = 0; i < 14; i++)
",65,13
proto-phonet: zmalloc conversion,"
 #include <stdlib.h>
 #include ""net.h""
 #include ""random.h""
+#include ""utils.h""
 
 void phonet_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 {
 struct sockaddr_pn *pn;
 
-pn = malloc(sizeof(struct sockaddr_pn));
-if (pn == NULL)
-return;
+pn = zmalloc(sizeof(struct sockaddr_pn));
 
 pn->spn_family = PF_PHONET;
 pn->spn_obj = rand();
",28,3
proto-rds: zmalloc conversion," void rds_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 {
 struct sockaddr_in *rds;
 
-rds = malloc(sizeof(struct sockaddr_in));
-if (rds == NULL)
-return;
+rds = zmalloc(sizeof(struct sockaddr_in));
+
 rds->sin_family = AF_INET;
 rds->sin_addr.s_addr = random_ipv4_address();
 rds->sin_port = rand() % 65535;
",36,4
proto-rose: zmalloc conversion," void rose_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 {
 struct sockaddr_rose *rose;
 
-rose = malloc(sizeof(struct sockaddr_rose));
-if (rose == NULL)
-return;
+rose = zmalloc(sizeof(struct sockaddr_rose));
 
 rose->srose_family = PF_ROSE;
 rose->srose_addr.rose_addr[0] = rand();
",39,2
proto-tipc: zmalloc conversion," void tipc_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 {
 struct sockaddr_tipc *tipc;
 
-tipc = malloc(sizeof(struct sockaddr_tipc));
-if (tipc == NULL)
-return;
+tipc = zmalloc(sizeof(struct sockaddr_tipc));
+
 tipc->family = AF_TIPC;
 tipc->addrtype = rand();
 tipc->scope = rand();
",52,6
proto-unix: zmalloc conversion,"
 #include <stdlib.h>
 #include ""maps.h""
 #include ""net.h""
+#include ""utils.h""
 
 void unix_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 {
 struct sockaddr_un *unixsock;
 unsigned int len;
 
-unixsock = malloc(sizeof(struct sockaddr_un));
-if (unixsock == NULL)
-return;
+unixsock = zmalloc(sizeof(struct sockaddr_un));
 
 unixsock->sun_family = PF_UNIX;
 len = rand() % 20;
",34,5
proto-x25: zmalloc conversion,"
 #include ""net.h""
 #include ""maps.h""// page_rand
 #include ""random.h""
+#include ""utils.h""
 
 void x25_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 {
 struct sockaddr_x25 *x25;
 unsigned int len;
 
-x25 = malloc(sizeof(struct sockaddr_x25));
-if (x25 == NULL)
-return;
+x25 = zmalloc(sizeof(struct sockaddr_x25));
 
 x25->sx25_family = PF_X25;
 len = rand() % 15;
",33,3
convert alloc_iovec to use zmalloc," unsigned long find_previous_arg_address(struct syscallrecord *rec, unsigned int
 struct iovec * alloc_iovec(unsigned int num)
 {
 struct iovec *iov;
+unsigned int i;
 
-iov = malloc(num * sizeof(struct iovec));/* freed by generic_free_arg */
-if (iov != NULL) {
-unsigned int i;
+iov = zmalloc(num * sizeof(struct iovec));/* freed by generic_free_arg */
 
-for (i = 0; i < num; i++) {
-struct map *map;
+for (i = 0; i < num; i++) {
+struct map *map;
 
-map = get_map();
-iov[i].iov_base = map->ptr;
-iov[i].iov_len = rand() % map->size;
-}
+map = get_map();
+iov[i].iov_base = map->ptr;
+iov[i].iov_len = rand() % map->size;
 }
+
 return iov;
 }
",111,31
"remove the 'put junk in pathnames' code.

it doesn't find bugs, and just causes a mess.
It also occasionally causes trinity to corrupt itself due to lack
of bounds checking in pathname users."," const char * generate_pathname(void)
 return pathname;
 
 /* Create a bogus filename. */
-newpath = malloc(MAX_PATH_LEN);// FIXME: We leak this.
-if (newpath == NULL)
-return pathname;// give up.
+newpath = zmalloc(MAX_PATH_LEN);// FIXME: We leak this.
 
 len = strlen(pathname);
 
-generate_random_page(page_rand);
-memcpy(newpath, page_rand, MAX_PATH_LEN);// FIXME: we only want a subset (ascii basically)
-
-/* sometimes, just complete junk. */
-if (rand_bool())
-goto out;
-
-if (len > MAX_PATH_LEN)
-len = MAX_PATH_LEN;
-
-/* Sometimes, pathname + junk */
 if (rand_bool())
 (void) strncpy(newpath, pathname, len);
 else {
 const char * generate_pathname(void)
 }
 }
 
-out:
 /* 50/50 chance of making it look like a dir */
 if (rand_bool()) {
 if (len <= MAX_PATH_LEN - 2) {
",36,7
"Allow seeding from the init process.

Right now we don't do any rand uses in the init processes, but later
patches will, so will require this."," unsigned int init_seed(unsigned int seedparam)
 */
 void set_seed(struct childdata *child)
 {
+/* if no shm yet, we must be the init process. */
+if (shm == NULL) {
+srand(new_seed());
+return;
+}
+
+/* if not in child context, we must be main. */
 if (child == NULL) {
-/* not in child context, must be main. */
 srand(shm->seed);
 return;
 }
",67,14
use memcpy to copy syscall record to previous," void handle_syscall_ret(struct syscallrecord *rec)
 
 /* store info for debugging. */
 previous = &this_child->previous;
-previous->nr = rec->nr;
-previous->a1 = rec->a1;
-previous->a2 = rec->a2;
-previous->a3 = rec->a3;
-previous->a4 = rec->a4;
-previous->a5 = rec->a5;
-previous->a6 = rec->a6;
-previous->do32bit = rec->do32bit;
+memcpy(previous, rec, sizeof(struct syscallrecord));
 previous->state = DONE;
 
 check_uid();
",149,28
"the array of child struct ptrs doesn't need to be a shared map.

having them just be COW'd is fine (in reality we never write to
them again after shm setup)."," void init_shm(void)
 /* Set seed in parent thread */
 set_seed(NULL);
 
-shm->children = alloc_shared(max_children * sizeof(struct childdata *));
+shm->children = zmalloc(max_children * sizeof(struct childdata *));
 
 for_each_child(i) {
 struct childdata *child;
",53,3
explicitly clear the logfile ptr on child init," void init_shm(void)
 memset(&child->previous, 0, sizeof(struct syscallrecord));
 
 child->pid = EMPTY_PIDSLOT;
+
+child->logfile = NULL;
 }
 }
",54,3
execve: zmalloc conversion,"
 #include ""shm.h""
 #include ""syscall.h""
 #include ""trinity.h""// __unused__
+#include ""utils.h""
 
 static unsigned long ** gen_ptrs_to_crap(void)
 {
 static unsigned long ** gen_ptrs_to_crap(void)
 unsigned int count = rand() % 32;
 
 /* Fabricate argv */
-ptr = malloc(count * sizeof(void *));// FIXME: LEAK
-if (ptr == NULL)
-return NULL;
+ptr = zmalloc(count * sizeof(void *));// FIXME: LEAK
 
 for (i = 0; i < count; i++) {
-ptr[i] = malloc(page_size);// FIXME: LEAK
-if (ptr[i] != NULL)
-generate_random_page((char *) ptr[i]);
+ptr[i] = zmalloc(page_size);// FIXME: LEAK
+generate_random_page((char *) ptr[i]);
 }
 
 return (unsigned long **) ptr;
",49,3
mincore: zmalloc conversion,"
 #include ""shm.h""
 #include ""syscall.h""
 #include ""trinity.h""
+#include ""utils.h""
 
 static void sanitise_mincore(struct syscallrecord *rec)
 {
 static void sanitise_mincore(struct syscallrecord *rec)
 
 len = map->size + (page_size - 1) / page_size;
 
-rec->a3 = (unsigned long) malloc(len);// FIXME: LEAK
+rec->a3 = (unsigned long) zmalloc(len);// FIXME: LEAK
 }
 
 static void post_mincore(struct syscallrecord *rec)
",31,2
modify_ldt: zmalloc conversion,"
 #include ""shm.h""
 #include ""syscall.h""
 #include ""trinity.h""
+#include ""utils.h""
 
 #define ALLOCSIZE LDT_ENTRIES * LDT_ENTRY_SIZE
 
 static void sanitise_modify_ldt(struct syscallrecord *rec)
 case 0:
 /* read the ldt into the memory pointed to by ptr.
  The number of bytes read is the smaller of bytecount and the actual size of the ldt. */
-ldt = malloc(ALLOCSIZE);
-if (ldt == NULL)
-return;
+ldt = zmalloc(ALLOCSIZE);
 rec->a2 = (unsigned long) ldt;
 rec->a3 = ALLOCSIZE;
 break;
",43,4
pread64: set size to be at most 1 page.,"
 /*
 * SYSCALL_DEFINE(pread64)(unsigned int fd, char __user *buf, size_t count, loff_t pos)
 */
+#include <stdlib.h>
+#include ""arch.h""
 #include ""random.h""
 #include ""sanitise.h""
 #include ""shm.h""

 
 static void sanitise_pread64(struct syscallrecord *rec)
 {
+rec->a3 = rand() % page_size;
 
 retry_pos:
 if ((int) rec->a4 < 0) {
",28,2
"remap_file_pages: better sanitize for start/len/offset args

Allow start to be something other than the beginning of the mapping.","
 static void sanitise_remap_file_pages(struct syscallrecord *rec)
 {
 struct map *map;
-size_t size;
+size_t size, offset;
+size_t start = 0;
 
 map = common_set_mmap_ptr_len();
 
+if (rand_bool()) {
+start = rand() % map->size;
+start &= PAGE_MASK;
+rec->a1 += start;
+}
+
 /* We just want to remap a part of the mapping. */
-size = rand() % map->size;
+if (rand_bool())
+size = page_size;
+else {
+size = rand() % map->size;
+
+/* if we screwed with the start, we need to take it
+ * into account so we don't go off the end.
+ */
+if (start != 0)
+size -= start;
+}
 rec->a2 = size;
 
 /* ""The prot argument must be specified as 0"" */
 rec->a3 = 0;
 
 /* Pick a random pgoff. */
-rec->a4 = rand() & (size / page_size);
+if (rand_bool())
+offset = rand() & (size / page_size);
+else
+offset = 0;
+rec->a4 = offset;
 }
 
 struct syscallentry syscall_remap_file_pages = {
",53,5
send: zmalloc conversion,"
 #include ""shm.h""
 #include ""syscall.h""
 #include ""trinity.h""
+#include ""utils.h""
 #include ""compat.h""
 
 struct syscallentry syscall_send = {
 static void sanitise_sendmsg(struct syscallrecord *rec)
 struct sockaddr *sa = NULL;
 socklen_t salen;
 
- msg = malloc(sizeof(struct msghdr));
-if (msg == NULL) {
-// just do something weird.
-rec->a2 = (unsigned long) get_address();
-return;
-}
+msg = zmalloc(sizeof(struct msghdr));
 
 generate_sockaddr((struct sockaddr **) &sa, (socklen_t *) &salen, rand() % TRINITY_PF_MAX);
 
",122,4
socketcall: zmalloc conversion," static void sanitise_socketcall(struct syscallrecord *rec)
 unsigned long *args;
 unsigned int i;
 
-args = malloc(6 * sizeof(unsigned long));
+args = zmalloc(6 * sizeof(unsigned long));
 
 //rec->a1 = rand() % ARRAY_SIZE(socketcallptrs);
 rec->a1 = SYS_SOCKET;//FIXME: Add other options and remove this hardcode.
",46,4
initialise random seed in init process.," int main(int argc, char* argv[])
 num_online_cpus = sysconf(_SC_NPROCESSORS_ONLN);
 max_children = num_online_cpus;/* possibly overridden in params. */
 
+set_seed(0);
+
 select_syscall_tables();
 
 create_shm();
",122,17
poison alloc_shared allocations to make sure things get initialized.," void * alloc_shared(unsigned int size)
 printf(""mmap %u failure\n"", size);
 exit(EXIT_FAILURE);
 }
+/* poison, to force users to set it to something sensible. */
+memset(ret, rand(), size);
 return ret;
 }
 
",61,12
"remove the unicode generator.

This isn't really useful in kernel context, and hasn't seen any
real activity in a while. It just causes a mess of mangled filenames.
Interesting for finding userspace bugs, but not so much for the kernel.

I'll do something with it as a standalone project some time."," void generate_random_page(char *page)
 unsigned int i;
 unsigned int p = 0;
 
-switch (rand() % 9) {
+switch (rand() % 8) {
 
 case 0:
 memset(page, 0, page_size);
 void generate_random_page(char *page)
 case 5:fabricate_onepage_struct(page);
 return;
 
-/* return a page of unicode nonsense. */
-case 6:gen_unicode_page(page);
-return;
-
 /* page full of format strings. */
-case 7:
+case 6:
 for (i = 0; i < page_size; ) {
 page[i++] = '%';
 switch (rand_bool()) {
 void generate_random_page(char *page)
 return;
 
 /* ascii representation of a random number */
-case 8:
+case 7:
 switch (rand() % 3) {
 case 0:
 switch (rand() % 3) {
",133,37
"rename variable in handle_arg_op

also add commentary"," static void get_num_and_values(struct syscallentry *entry, unsigned int argnum,
 BUG(""ARG_OP/LIST with no values.\n"");
 }
 
+/*
+ * Get a single entry from the list of values.
+ */
 static unsigned long handle_arg_op(struct syscallentry *entry, unsigned int argnum)
 {
 const unsigned long *values = NULL;
 unsigned int num = 0;
-unsigned long mask = 0;
+unsigned long op = 0;
 
 get_num_and_values(entry, argnum, &num, &values);
 
-mask |= values[rand() % num];
-return mask;
+op = values[rand() % num];
+return op;
 }
 
 unsigned long set_rand_bitmask(unsigned int num, const unsigned long *values)
 unsigned long set_rand_bitmask(unsigned int num, const unsigned long *values)
 return mask;
 }
 
+/*
+ * OR a random number of bits from the list of values into a bitmask, and return it.
+ */
 static unsigned long handle_arg_list(struct syscallentry *entry, unsigned int argnum)
 {
 unsigned long mask = 0;
",356,118
move set_rand_bitmask into utils.h," static unsigned long handle_arg_op(struct syscallentry *entry, unsigned int argn
 return op;
 }
 
-unsigned long set_rand_bitmask(unsigned int num, const unsigned long *values)
-{
-unsigned long i;
-unsigned long mask = 0;
-unsigned int bits;
-
-bits = rand_range(1, num);/* num of bits to OR */
-for (i = 0; i < bits; i++)
-mask |= values[rand() % num];
-
-return mask;
-}
-
 /*
 * OR a random number of bits from the list of values into a bitmask, and return it.
 */
",346,116
move debugf to debug.c,"
 
 #include <execinfo.h>
 #include <stdio.h>
+#include <stdarg.h>
 #include ""child.h""
 #include ""config.h""
 #include ""debug.h""
 #include ""log.h""
+#include ""params.h""
 #include ""shm.h""
 #include ""syscall.h""
 #include ""version.h""
 void dump_childdata(struct childdata *child)
 output(0, ""dontkillme: %d\n"", child->dontkillme);
 output(0, ""\n"");
 };
+
+/*
+ * debugging output.
+ * This is just a convenience helper to avoid littering the code
+ * with dozens of 'if debug == TRUE' comparisons causing unnecessary nesting.
+ */
+#define BUFSIZE 1024
+
+void debugf(const char *fmt, ...)
+{
+char debugbuf[BUFSIZE];
+va_list args;
+
+if (debug == FALSE)
+return;
+
+va_start(args, fmt);
+vsprintf(debugbuf, fmt, args);
+va_end(args);
+output(0, debugbuf);
+}
",84,10
replace open-coded rand_bool,"
 
 static void sanitise_write(struct syscallrecord *rec)
 {
-if ((rand() % 100) > 50)
+if (rand_bool())
 rec->a3 = 1;
 else
 rec->a3 = rand() % page_size;
",72,4
sanitise/post for socketpair,"
 /*
 * SYSCALL_DEFINE4(socketpair, int, family, int, type, int, protocol, int __user *, usockvec)
 */
+#include <stdlib.h>
+#include <sys/socket.h>
 #include ""sanitise.h""
 
+static void sanitise_socketpair(struct syscallrecord *rec)
+{
+rec->a1 = AF_UNIX;
+rec->a4 = (unsigned long) malloc(sizeof(int) * 2);
+}
+
+static void post_socketpair(struct syscallrecord *rec)
+{
+void *ptr;
+
+//TODO: on success we should put the fd's that
+// were created into a child-local fd array.
+
+ptr = (void *) rec->a1;
+free(ptr);
+}
+
 struct syscallentry syscall_socketpair = {
 .name = ""socketpair"",
 .num_args = 4,
 struct syscallentry syscall_socketpair = {
 .arg3name = ""protocol"",
 .arg4name = ""usockvec"",
 .arg4type = ARG_ADDRESS,
+.sanitise = sanitise_socketpair,
+.post = post_socketpair,
 };
",25,2
socketpair: get the pointer to free from the right register.," static void post_socketpair(struct syscallrecord *rec)
 //TODO: on success we should put the fd's that
 // were created into a child-local fd array.
 
-ptr = (void *) rec->a1;
+ptr = (void *) rec->a4;
 free(ptr);
 }
 
",25,2
Allow set_rand_bitmask to return without setting any bits.," unsigned long set_rand_bitmask(unsigned int num, const unsigned long *values)
 unsigned long mask = 0;
 unsigned int bits;
 
-bits = rand_range(1, num); /* num of bits to OR */
+bits = rand_range(0, num); /* num of bits to OR */
+if (bits == 0)
+return mask;
+
 for (i = 0; i < bits; i++)
 mask |= values[rand() % num];
 
",74,15
replace open-coded rand_bool()," void init_child(int childno)
 
 set_make_it_fail();
 
-if (rand() % 100 < 50)
+if (rand_bool())
 use_fpu();
 
 mask_signals_child();
",252,50
"add beginning of forthcoming getrandom syscall

not wired up to syscall tables yet, until the syscall no is confirmed.","
+/*
+ * SYSCALL_DEFINE3(getrandom, char __user *, buf, size_t, count, unsigned int, flags)
+ */
+#include <errno.h>
+#include ""maps.h""
+#include ""sanitise.h""
+#include ""trinity.h""
+
+#define GRND_NONBLOCK 0x0001
+#define GRND_RANDOM 0x0002
+
+static void sanitise_getrandom(__unused__ struct syscallrecord *rec)
+{
+(void) common_set_mmap_ptr_len();
+}
+
+struct syscallentry syscall_getrandom = {
+.name = ""getrandom"",
+.num_args = 3,
+.arg1name = ""buf"",
+.arg1type = ARG_MMAP,
+.arg2name = ""count"",
+.arg3name = ""flags"",
+.arg3type = ARG_LIST,
+.arg3list = {
+.num = 2,
+.values = {
+GRND_NONBLOCK, GRND_RANDOM,
+},
+},
+.errnos = {
+.num = 4,
+.values = {
+EINVAL, EFAULT, EAGAIN, EINTR,
+},
+},
+.sanitise = sanitise_getrandom,
+};
",30,1
"remove pointless ARG_RANDOM_LONG

This is the default case when we don't have an ARG_* set, so just
use the fallback."," static char * render_arg(struct syscallrecord *rec, char *sptr, unsigned int arg
 case ARG_LEN:
 case ARG_RANGE:
 case ARG_CPU:
-case ARG_RANDOM_LONG:
 case ARG_IOVECLEN:
 case ARG_SOCKADDRLEN:
 if (((long) reg < -16384) || ((long) reg > 16384)) {
",162,44
"rename robust_find_logfile_handle -> find_logfile_handle

old find_logfile_handle -> __find_logfile_handle"," static void __output_syscall(char *buffer, unsigned int len)
 if (logging == TRUE) {
 FILE *log_handle;
 
-log_handle = robust_find_logfile_handle();
+log_handle = find_logfile_handle();
 if (log_handle != NULL) {
 strip_ansi(buffer, len);
 flushbuffer(buffer, log_handle);
",162,44
rename __find_logfile_handle > find_child_logfile_handle," void close_logfile(FILE **filehandle)
 *filehandle = NULL;
 }
 
-static FILE * __find_logfile_handle(pid_t pid)
+static FILE * find_child_logfile_handle(pid_t pid)
 {
 int i;
 
 FILE *find_logfile_handle(void)
 if (pid == watchdog_pid)
 return mainlogfile;
 
-handle = __find_logfile_handle(pid);
+handle = find_child_logfile_handle(pid);
 if (!handle) {
 unsigned int j;
 
 FILE *find_logfile_handle(void)
 for_each_child(j)
 shm->children[j]->logfile = mainlogfile;
 sleep(5);
-handle = __find_logfile_handle(pid);
+handle = find_child_logfile_handle(pid);
 }
 }
 return handle;
",217,45
add timerfd creation to the fd generators," static void setup_fd_providers(void)
 add_to_prov_list(&epoll_fd_provider);
 add_to_prov_list(&eventfd_fd_provider);
 add_to_prov_list(&file_fd_provider);
+add_to_prov_list(&timerfd_fd_provider);
 }
 
 unsigned int setup_fds(void)
",93,11
"once we've picked an fd provider, stop searching."," static int get_new_random_fd(void)
 if (i == j) {
 provider = (struct fd_provider *) node;
 fd = provider->get();
+break;
 }
 j++;
 }
",94,11
move statistics out to separate structure," retry:
 unlock(&rec->lock);
 
 if (syscalls_todo) {
-if (shm->total_syscalls_done >= syscalls_todo)
+if (shm->stats.total_syscalls_done >= syscalls_todo)
 shm->exit_reason = EXIT_REACHED_COUNT;
 }
 
",87,16
remove unnecessary local variable," static struct bdevlist *bdevs = NULL;
 static void add_to_bdevlist(const char *name)
 {
 struct bdevlist *newnode;
-struct list_head *list = (struct list_head *) bdevs;
 
 //TODO: Check if it's a valid /dev node (also check if passed without leading ""/dev/"")
 
 newnode = zmalloc(sizeof(struct bdevlist));
 newnode->name = strdup(name);
-list_add_tail(&newnode->list, list);
+list_add_tail(&newnode->list, &bdevs->list);
 nr_blockdevs++;
 }
 
",66,9
"net: add inet/inet6 rand_socket sctp support

Acked-by: Daniel Borkmann <dborkman@redhat.com>
Signed-off-by: Hangbin Liu <liuhangbin@gmail.com>"," void ipv4_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 
 void inet_rand_socket(struct socket_triplet *st)
 {
-switch (rand() % 3) {
-case 0: st->type = SOCK_STREAM; // TCP
-if (rand_bool())
+switch (rand() % 4) {
+case 0: st->type = SOCK_STREAM; // TCP/SCTP
+switch (rand() % 3) {
+case 0:
 st->protocol = 0;
-else
+break;
+case 1:
 st->protocol = IPPROTO_TCP;
-break;
+break;
+case 2:
+st->protocol = IPPROTO_SCTP;
+break;
+default:
+break;
+}
 
 case 1: st->type = SOCK_DGRAM; // UDP
 if (rand_bool())
 void inet_rand_socket(struct socket_triplet *st)
 st->protocol = IPPROTO_UDP;
 break;
 
-case 2: st->type = SOCK_RAW;
+case 2: st->type = SOCK_SEQPACKET; // SCTP
+if (rand_bool())
+st->protocol = 0;
+else
+st->protocol = IPPROTO_SCTP;
+break;
+
+case 3: st->type = SOCK_RAW;
 st->protocol = rand() % PROTO_MAX;
 break;
 
-default:break;
+default:
+break;
 }
 }
 
",231,72
begin some infrastructure to use a bunch of test files for fsx like ops.,"
 #include ""sanitise.h""
 #include ""shm.h""
 #include ""trinity.h""
+#include ""testfile.h""
 #include ""utils.h""
 
 static int num_fd_providers;
 static void setup_fd_providers(void)
 add_to_prov_list(&eventfd_fd_provider);
 add_to_prov_list(&file_fd_provider);
 add_to_prov_list(&timerfd_fd_provider);
+add_to_prov_list(&testfile_fd_provider);
 }
 
 unsigned int setup_fds(void)
",96,11
fix potential null dereference if the open fails," static int open_testfile(unsigned int i)
 {
 FILE *file;
 char *filename;
+int fd = -1;
 
 filename = zmalloc(64);
 sprintf(filename, ""trinity-testfile%d"", i);
 static int open_testfile(unsigned int i)
 file = fopen(filename, ""w"");
 if (!file)
 outputerr(""Couldn't open testfile %d for writing.\n"", i);
+else
+fd = fileno(file);
 
 free(filename);
 
-return fileno(file);
+return fd;
 }
 
 static int open_testfile_fds(void)
",49,6
"if opening one testfile fails, don't keep trying."," static int open_testfile_fds(void)
 int fd;
 
 fd = open_testfile(i + 1);
-if (fd != -1) {
-shm->testfile_fds[i] = fd;
-output(2, ""fd[%d] = testfile%d\n"", fd, i + 1);
-i++;
-}
+if (fd == -1)
+return FALSE;
+
+shm->testfile_fds[i] = fd;
+output(2, ""fd[%d] = testfile%d\n"", fd, i + 1);
+i++;
 }
 
 return TRUE;
",49,6
add another missing break," void inet_rand_socket(struct socket_triplet *st)
 default:
 break;
 }
+break;
 
 case 1: st->type = SOCK_DGRAM; // UDP
 if (rand_bool())
",232,72
rewrite the testfile creation to use open instead of fopen,"
 #include <errno.h>
+#include <fcntl.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
 #include <asm/unistd.h>
+#include <sys/types.h>
+#include <sys/stat.h>
 
 #include ""fd.h""
 #include ""shm.h""

 
 static int open_testfile(unsigned int i)
 {
-FILE *file;
 char *filename;
-int fd = -1;
+int fd;
 
 filename = zmalloc(64);
 sprintf(filename, ""trinity-testfile%d"", i);
 
 unlink(filename);
 
-file = fopen(filename, ""w"");
-if (!file)
+fd = open(filename, O_CREAT, 0666);
+if (fd == -1)
 outputerr(""Couldn't open testfile %d for writing.\n"", i);
-else
-fd = fileno(file);
 
 free(filename);
 
",49,6
use some random O_ flags when opening test files.,"
 #include ""fd.h""
 #include ""shm.h""
 #include ""log.h""
+#include ""random.h""
 #include ""sanitise.h""
 #include ""testfile.h""
 
 static int open_testfile(unsigned int i)
 {
 char *filename;
 int fd;
+int flags = 0;
 
 filename = zmalloc(64);
 sprintf(filename, ""trinity-testfile%d"", i);
 
 unlink(filename);
 
-fd = open(filename, O_CREAT, 0666);
+if (rand_bool())
+flags |= O_DIRECT;
+
+if (rand_bool())
+flags |= O_DSYNC;
+
+if (rand_bool())
+flags |= O_SYNC;
+
+fd = open(filename, O_CREAT | flags, 0666);
 if (fd == -1)
 outputerr(""Couldn't open testfile %d for writing.\n"", i);
+else
+output(2, ""fd[%d] = testfile%d (flags:%x)\n"", fd, i, flags);//TODO: decode flags
 
 free(filename);
 
 static int open_testfile_fds(void)
 return FALSE;
 
 shm->testfile_fds[i] = fd;
-output(2, ""fd[%d] = testfile%d\n"", fd, i + 1);
 i++;
 }
 
",58,9
create a separate function for random 8 bit values," static unsigned int plus_minus_two(unsigned int num)
 return num;
 }
 
+static char get_interesting_8bit_value(void)
+{
+char num = 0;
+
+switch (rand() % 7) {
+case 0:num = -128;
+break;
+case 1:num = -1;
+break;
+case 2:num = 0;
+break;
+case 3:num = 1;
+break;
+case 4:num = 1UL << (rand() % 7);
+break;
+case 5:num = 127;
+break;
+case 6:num = rand() % 256;// 00-0xff
+break;
+}
+
+return num;
+}
+
 unsigned int get_interesting_32bit_value(void)
 {
 unsigned int num = 0;
 
 switch (rand() % 10) {
-case 0:num = 0x00000000;
+case 0:num = 0;
 break;
-case 1:num = rand() % 256;// 00-0xff
+case 1:num = get_interesting_8bit_value();
 break;
 case 2:num = 1UL << (rand() % 32);// set a single bit.
 break;
",106,47
"don't try to flush logs from watchdog context.

Since we made log fd's be child local data, the watchdog
can't actually see those fd's, so trying to flush them could segfault."," static void watchdog(void)
 panic(EXIT_REACHED_COUNT);
 }
 
-// Periodic log syncing. FIXME: This is kinda ugly, and mostly unnecessary.
-if (shm->stats.total_syscalls_done % 1000 == 0)
-synclogs();
-
 for_each_child(i) {
 struct childdata *child = shm->children[i];
 struct syscallrecord *rec = &child->syscall;
",307,61
"add back the filemode to the open(O_CREAT)

somehow inadvertantly dropped this."," static int open_testfile(unsigned int i)
 if (rand_bool())
 fd = open_with_fopen(filename, O_RDWR);
 else
-fd = open(filename, O_CREAT | flags);
+fd = open(filename, O_CREAT | flags, 0666);
 
 free(filename);
 
",57,9
re-add the logging of creation of the testfile fd's," static int open_testfile(unsigned int i)
 filename = zmalloc(64);
 sprintf(filename, ""trinity-testfile%d"", i);
 
-if (rand_bool())
+if (rand_bool()) {
 fd = open_with_fopen(filename, O_RDWR);
-else
+if (fd != -1)
+output(2, ""fd[%d] = fopen(\""%s\"", O_RDWR)\n"", fd, filename);
+} else {
 fd = open(filename, O_CREAT | flags, 0666);
+if (fd != -1)
+output(2, ""fd[%d] = open(\""%s\"", flags:%x)\n"", fd, filename, flags);//TODO: decode flags
+}
 
 free(filename);
 
",62,11
"correctly terminate mode array

we were always clearing mode[2], but mode[1] might be non-zero
in the 'r' or 'w' cases."," int open_with_fopen(const char *filename, int flags)
 char mode[3];
 
 switch (flags) {
-case O_RDONLY: strncpy(mode, ""r"", 1); break;
-case O_WRONLY: strncpy(mode, ""w"", 1); break;
-case O_RDWR: strncpy(mode, ""w+"", 2); break;
+case O_RDONLY: mode[0] = 'r';
+mode[1] = 0;
+break;
+case O_WRONLY: mode[0] = 'w';
+mode[1] = 0;
+break;
+case O_RDWR: mode[0] = 'w';
+mode[1] = '+';
+mode[2] = 0;
+break;
 }
-mode[2] = 0;
 
 file = fopen(filename, mode);
 if (file)
",299,68
add the flags and special cases to seccomp sanitise,"
 #define SECCOMP_SET_MODE_STRICT 0
 #define SECCOMP_SET_MODE_FILTER 1
 
+#define SECCOMP_FILTER_FLAG_TSYNC 1
+
+static void sanitise_seccomp(struct syscallrecord *rec)
+{
+if (rec->a1 == SECCOMP_SET_MODE_STRICT) {
+rec->a2 = 0;
+rec->a3 = 0;
+}
+}
+
 struct syscallentry syscall_seccomp = {
 .name = ""seccomp"",
 .num_args = 3,
 struct syscallentry syscall_seccomp = {
 .values = { SECCOMP_SET_MODE_STRICT, SECCOMP_SET_MODE_FILTER },
 },
 .arg2name = ""flags"",
+.arg2type = ARG_LIST,
+.arg2list = {
+.num = 1,
+.values= { SECCOMP_FILTER_FLAG_TSYNC },
+},
 .arg3name = ""uargs"",
 .arg3type = ARG_ADDRESS,
+.sanitise = sanitise_seccomp,
 };
",28,2
"remove commented out bind/listen error checking.

This all needs to be rewritten someday anyway, and it won't look
anything like this."," static const char *cachefilename=""trinity.socketcache"";
 static int open_socket(unsigned int domain, unsigned int type, unsigned int protocol)
 {
 int fd;
-__unused__ int ret;
 struct sockaddr *sa = NULL;
 socklen_t salen;
 struct sockopt so = { 0, 0, 0, 0 };
 static int open_socket(unsigned int domain, unsigned int type, unsigned int prot
 
 /* Sometimes, listen on created sockets. */
 if (rand_bool()) {
+int ret;
+
 /* fake a sockaddr. */
 generate_sockaddr((struct sockaddr **) &sa, (socklen_t *) &salen, domain);
 
 ret = bind(fd, sa, salen);
-/*if (ret == -1)
-debugf(""bind: %s\n"", strerror(errno));
-else
-debugf(""bind: success!\n"");
-*/
-ret = listen(fd, rand_range(1, 128));
-/*if (ret == -1)
-debugf(""listen: %s\n"", strerror(errno));
-else
-debugf(""listen: success!\n"");
-*/
+if (ret != -1) {
+(void) listen(fd, rand_range(1, 128));
+}
 }
 
 /* If we didn't have a function for this sockaddr type, we would
",277,64
add memfd as a fd provider,"
 #include ""files.h""
 #include ""log.h""
 #include ""list.h""
+#include ""memfd.h""
 #include ""net.h""
 #include ""params.h""
 #include ""perf.h""
 static void setup_fd_providers(void)
 add_to_prov_list(&file_fd_provider);
 add_to_prov_list(&timerfd_fd_provider);
 add_to_prov_list(&testfile_fd_provider);
+add_to_prov_list(&memfd_fd_provider);
 }
 
 unsigned int setup_fds(void)
",98,11
remove out of date comment," static void oom_score_adj(int adj)
 
 /*
 * Wipe out any state left from a previous child running in this slot.
- * Right now the logfile entry is the only persistent thing across instances.
 */
 static void reinit_child(struct childdata *child)
 {
",252,50
"allocate the output buffers on child startup.

by doing this, when these buffers overrun, we'll crash the child
rather than spewing over the shm and destroying trinitys state.

The better answer is to fix the overruns, but that's a longer term FIXME"," static void oom_score_adj(int adj)
 static void reinit_child(struct childdata *child)
 {
 memset(&child->syscall, 0, sizeof(struct syscallrecord));
+child->syscall.prebuffer = zmalloc(PREBUFFER_LEN);
+child->syscall.postbuffer = zmalloc(POSTBUFFER_LEN);
+
 memset(&child->previous, 0, sizeof(struct syscallrecord));
+child->previous.prebuffer = zmalloc(PREBUFFER_LEN);
+child->previous.postbuffer = zmalloc(POSTBUFFER_LEN);
 
 child->num_mappings = 0;
 child->seed = 0;
",256,50
"trinity: add connection support for AF_INET and AF_INET6

Trinity is a syscall fuzz tool for local host testing. But it would also be
very useful to fuzz during established sessions over the network. This patch
add simple connection ability for IPv4/IPv6 so user can use it as a
client/server and simulate as a real environment.

Signed-off-by: Hangbin Liu <liuhangbin@gmail.com>"," in_addr_t random_ipv4_address(void)
 void ipv4_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 {
 struct sockaddr_in *ipv4;
+struct in_addr serv_addr;
 
 ipv4 = zmalloc(sizeof(struct sockaddr_in));
 
 ipv4->sin_family = PF_INET;
 ipv4->sin_addr.s_addr = random_ipv4_address();
 ipv4->sin_port = htons(rand() % 65535);
+
+/* Client side if we supplied server_addr */
+if (inet_pton(PF_INET, server_addr, &serv_addr) == 1)
+ipv4->sin_addr = serv_addr;
+/* Server side if we supplied port without addr, so listen on INADDR_ANY */
+else if (server_port != 0)
+ipv4->sin_addr.s_addr = htonl(INADDR_ANY);
+
+/* Fuzz from port to (port + 100) if supplied */
+if (server_port != 0)
+ipv4->sin_port = htons(server_port + rand() % 100);
+
 *addr = (struct sockaddr *) ipv4;
 *addrlen = sizeof(struct sockaddr_in);
 }
",239,75
fix off by one in loglevel checking that meant [init] messages were skipped," void output(unsigned char level, const char *fmt, ...)
 }
 
 /* stdout output if needed */
-if (quiet_level > level) {
+if (quiet_level >= level) {
 printf(""%s %s"", prefix, outputbuf);
 (void)fflush(stdout);
 }
",206,43
split the fd provider list creation & fd open functions.," static void add_to_prov_list(struct fd_provider *prov)
 list_add_tail(&newnode->list, &fd_providers->list);
 }
 
-static void setup_fd_providers(void)
+void setup_fd_providers(void)
 {
 fd_providers = zmalloc(sizeof(struct fd_provider));
 INIT_LIST_HEAD(&fd_providers->list);
 static void setup_fd_providers(void)
 add_to_prov_list(&timerfd_fd_provider);
 add_to_prov_list(&testfile_fd_provider);
 add_to_prov_list(&memfd_fd_provider);
+
+output(0, ""Registered %d fd providers.\n"", num_fd_providers);
 }
 
 unsigned int setup_fds(void)
 {
 struct list_head *node;
 
-setup_fd_providers();
-
-output(0, ""Registered %d fd providers.\n"", num_fd_providers);
-
 list_for_each(node, &fd_providers->list) {
 struct fd_provider *provider;
 int ret;
",97,11
"rename setup_fds to open_fds

rename fd-files local 'open_fds' to not clash with new global."," static int file_tree_callback(const char *fpath, const struct stat *sb, int type
 }
 
 
-static void open_fds(const char *dirpath)
+static void open_fds_from_path(const char *dirpath)
 {
 int before = files_in_index;
 int flags = FTW_DEPTH | FTW_ACTIONRETVAL | FTW_MOUNT;
 static void generate_filelist(void)
 output(1, ""Generating file descriptors\n"");
 
 if (victim_path != NULL) {
-open_fds(victim_path);
+open_fds_from_path(victim_path);
 } else {
-open_fds(""/dev"");
-open_fds(""/proc"");
-open_fds(""/sys"");
+open_fds_from_path(""/dev"");
+open_fds_from_path(""/proc"");
+open_fds_from_path(""/sys"");
 }
 
 if (shm->exit_reason != STILL_RUNNING)
",299,68
add a .name to the fd provider structs," static int get_rand_epoll_fd(void)
 }
 
 struct fd_provider epoll_fd_provider = {
+.name = ""epoll"",
 .open = &open_epoll_fds,
 .get = &get_rand_epoll_fd,
 };
",45,5
add a ->enabled flag to the fd_provider struct," static int get_rand_epoll_fd(void)
 
 struct fd_provider epoll_fd_provider = {
 .name = ""epoll"",
+.enabled = TRUE,
 .open = &open_epoll_fds,
 .get = &get_rand_epoll_fd,
 };
",46,5
"shut up a coverity warning about uninitialised var

It's not possible to get here with flags set to anything other
than the three cases in the switch, but it doesn't hurt to silence it"," int open_with_fopen(const char *filename, int flags)
 {
 FILE *file;
 int fd = -1;
-char mode[3];
+char mode[3]="" "";
 
 switch (flags) {
 case O_RDONLY: mode[0] = 'r';
",301,68
constify fd_provider structs," static int get_rand_epoll_fd(void)
 return shm->epoll_fds[rand() % MAX_EPOLL_FDS];
 }
 
-struct fd_provider epoll_fd_provider = {
+const struct fd_provider epoll_fd_provider = {
 .name = ""epoll"",
 .enabled = TRUE,
 .open = &open_epoll_fds,
",46,5
"proto-phonet: Include compat.h.

Fix build error when missing PF_PHONET with glibc < 2.10.

 CC	net/proto-phonet.o
net/proto-phonet.c: In function phonet_gen_sockaddr:
net/proto-phonet.c:17:19: error: PF_PHONET undeclared (first use in this function)
 pn->spn_family = PF_PHONET;
 ^

Signed-off-by: Vinson Lee <vlee@twitter.com>","
 #include ""net.h""
 #include ""random.h""
 #include ""utils.h""
+#include ""compat.h""
 
 void phonet_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 {
",29,3
add memfd_create for sparc,"
 #ifdef __i386__
 #define SYS_memfd_create 356
 #endif
+#ifdef __sparc__
+#define SYS_memfd_create 348
+#endif
 #endif
 
 static int memfd_create(const char *uname, unsigned int flag)
",46,5
fix compilation for arches that don't have memfd_create yet,"
 
 static int memfd_create(const char *uname, unsigned int flag)
 {
+#ifdef SYS_memfd_create
 return syscall(SYS_memfd_create, uname, flag);
+#else
+return -ENOSYS;
+#endif
 }
 
 static int open_memfd_fds(void)
",47,6
move memfd_create syscall definitions to the memfd header,"
 #include <unistd.h>
 #include <sys/epoll.h>
 
-#include ""memfd.h""
 #include ""fd.h""
 #include ""log.h""
+#include ""memfd.h""
 #include ""net.h""
 #include ""params.h""
 #include ""pids.h""

 #include ""shm.h""
 #include ""compat.h""
 
-// FIXME: Keep all this here until glibc supports it.
-#ifndef SYS_memfd_create
-#ifdef __x86_64__
-#define SYS_memfd_create 319
-#endif
-#ifdef __i386__
-#define SYS_memfd_create 356
-#endif
-#ifdef __sparc__
-#define SYS_memfd_create 348
-#endif
-#endif
-
 static int memfd_create(const char *uname, unsigned int flag)
 {
 #ifdef SYS_memfd_create
",47,6
"Fix two shadow compiler warnings

 CC	fd-files.o
fd-files.c: In function list_to_index:
fd-files.c:216:15: warning: declaration of index shadows a global declaration [-Wshadow]
 CC	fds.o
fds.c: In function process_disable_fds_param:
fds.c:164:38: warning: declaration of optarg shadows a global declaration [-Wshadow]

Signed-off-by: Brian Haley <brian.haley@hp.com>"," static const char ** list_to_index(struct namelist *namelist)
 {
 struct list_head *node, *tmp;
 struct namelist *nl;
-const char **index;
+const char **findex;
 unsigned int i = 0;
 
-index = zmalloc(sizeof(char *) * files_in_index);
+findex = zmalloc(sizeof(char *) * files_in_index);
 
 list_for_each_safe(node, tmp, &namelist->list) {
 nl = (struct namelist *) node;
-index[i++] = nl->name;
+findex[i++] = nl->name;
 
 /* Destroy the list head, but keep the ->name alloc because
  * now the index points to it.
 static const char ** list_to_index(struct namelist *namelist)
 free(names);
 names = NULL;
 
-return index;
+return findex;
 }
 
 static void generate_filelist(void)
",301,68
"simplify get_random_fd

the ""25% chance"" over-ride is kind of pointless given we give fd's
a random lifetime."," retry:
 
 int get_random_fd(void)
 {
-/* 25% chance of returning something new. */
-if ((rand() % 4) == 0)
-return get_new_random_fd();
-
-/* the rest of the time, return the same fd as last time. */
+/* return the same fd as last time if we haven't over-used it yet. */
 regen:
 if (shm->fd_lifetime == 0) {
 shm->current_fd = get_new_random_fd();
",139,19
add list_move from the kernels list.h," static inline void list_del(struct list_head *entry)
 entry->next = entry->prev = NULL;
 }
 
+static inline void __list_del_entry(struct list_head *entry)
+{
+__list_del(entry->prev, entry->next);
+}
+
+/**
+ * list_move - delete from one list and add as another's head
+ * @list: the entry to move
+ * @head: the head that will precede our entry
+ */
+static inline void list_move(struct list_head *list, struct list_head *head)
+{
+__list_del_entry(list);
+list_add(list, head);
+}
+
 #define list_for_each(pos, head) \
 for (pos = (head)->next; pos != (head); pos = pos->next)
 
",49,9
"move the debug flag into the shm.

This allows us to gdb to the mainpid for eg, and enable the flag
when for whatever reason we can't gdb to a child process.

.. or when we just want it enabled globally rather than just within
one process.","
 #include ""list.h""
 #include ""log.h""
 #include ""maps.h""
-#include ""params.h""// for 'debug'
 #include ""pids.h""
 #include ""random.h""
 #include ""shm.h""
 static void disable_coredumps(void)
 {
 struct rlimit limit = { .rlim_cur = 0, .rlim_max = 0 };
 
-if (debug == TRUE) {
+if (shm->debug == TRUE) {
 (void)signal(SIGABRT, SIG_DFL);
 (void)signal(SIGSEGV, SIG_DFL);
 return;
 static void enable_coredumps(void)
 .rlim_max = RLIM_INFINITY
 };
 
-if (debug == TRUE)
+if (shm->debug == TRUE)
 return;
 
 prctl(PR_SET_DUMPABLE, TRUE);
",255,50
munge the size in common_set_mmap_ptr_len," struct map * common_set_mmap_ptr_len(void)
 }
 
 rec->a1 = (unsigned long) map->ptr;
-rec->a2 = map->size; //TODO: Munge this.
+rec->a2 = rand() % map->size;
+rec->a2 &= PAGE_MASK;
 
 return map;
 }
",65,11
"watchdog: if main died, clear its pid."," static int check_main_alive(void)
 if (ret == TRUE) {
 sleep(1);
 kill_all_kids();
+} else {
+shm->mainpid = 0;
 }
 }
 return FALSE;
",309,61
pass a child struct into init_child," static void reinit_child(struct childdata *child)
 /*
 * Called from the fork_children loop in the main process.
 */
-void init_child(int childno)
+void init_child(struct childdata *child, int childno)
 {
-struct childdata *child = shm->children[childno];
 cpu_set_t set;
 pid_t pid = getpid();
 char childname[17];
",254,50
fix possible off-by-one when printing units of bytes," static void alloc_zero_map(unsigned long size, int prot, const char *name)
 {
 struct map *newnode;
 int fd;
-char buf[10];
+char buf[11];
 
 fd = open(""/dev/zero"", O_RDWR);
 if (fd == -1) {
",83,7
change sizeunit to print bytes when passed a non KB aligned size," done:
 
 void sizeunit(unsigned long size, char *buf)
 {
-if (size < 1024 * 1024) {
+/* non kilobyte aligned size? */
+if (size & 1023) {
 sprintf(buf, ""%lu bytes"", size);
 return;
 }
 
+/* < 1MB ? */
+if (size < (1024 * 1024)) {
+sprintf(buf, ""%luKB"", size / 1024);
+return;
+}
+
+/* < 1GB ? */
 if (size < (1024 * 1024 * 1024)) {
 sprintf(buf, ""%ldMB"", (size / 1024) / 1024);
 return;
",78,16
abort if we fail to open logfiles.," void open_child_logfile(struct childdata *child)
 sprintf(logfilename, ""trinity-child%u.log"", child->num);
 
 child->logfile = open_logfile(logfilename);
-if (!child->logfile)
+if (!child->logfile) {
+shm->exit_reason = EXIT_LOGFILE_OPEN_ERROR;
 exit(EXIT_FAILURE);
+}
 
 free(logfilename);
 
",208,43
"when creating random ints/chars, we only need rand32() output"," void generate_random_page(char *page)
 
 case 1:
 switch (rand() % 3) {
-case 0:p = sprintf(page, ""%u"", (unsigned int) rand64());
+case 0:p = sprintf(page, ""%u"", (unsigned int) rand32());
 break;
-case 1:p = sprintf(page, ""%d"", (int) rand64());
+case 1:p = sprintf(page, ""%d"", (int) rand32());
 break;
-case 2:p = sprintf(page, ""%x"", (int) rand64());
+case 2:p = sprintf(page, ""%x"", (int) rand32());
 break;
 }
 break;
 
 case 2:
 switch (rand() % 3) {
-case 0:p = sprintf(page, ""%u"", (unsigned char) rand64());
+case 0:p = sprintf(page, ""%u"", (unsigned char) rand32());
 break;
-case 1:p = sprintf(page, ""%d"", (char) rand64());
+case 1:p = sprintf(page, ""%d"", (char) rand32());
 break;
-case 2:p = sprintf(page, ""%x"", (char) rand64());
+case 2:p = sprintf(page, ""%x"", (char) rand32());
 break;
 }
 break;
",133,37
"for the char's we can go further, and just use rand()"," void generate_random_page(char *page)
 
 case 2:
 switch (rand() % 3) {
-case 0:p = sprintf(page, ""%u"", (unsigned char) rand32());
+case 0:p = sprintf(page, ""%u"", (unsigned char) rand());
 break;
-case 1:p = sprintf(page, ""%d"", (char) rand32());
+case 1:p = sprintf(page, ""%d"", (char) rand());
 break;
-case 2:p = sprintf(page, ""%x"", (char) rand32());
+case 2:p = sprintf(page, ""%x"", (char) rand());
 break;
 }
 break;
",133,37
"Fix build break when SYS_memfd_create doesn't exist

In memfd_create() if SYS_memfd_create is not defined then uname and
flag are unused and gcc complains.","
 #include ""sanitise.h""
 #include ""shm.h""
 #include ""compat.h""
+#include ""trinity.h""
 
-static int memfd_create(const char *uname, unsigned int flag)
+static int memfd_create(__unused__ const char *uname, __unused__ unsigned int flag)
 {
 #ifdef SYS_memfd_create
 return syscall(SYS_memfd_create, uname, flag);
",48,6
"Fix mbind flags definition.

What we had in the 'flags' field should have been OR'd into the 'mode' field.
Move them to the right place, and then add the actual flags that should have
been in the flags field."," struct syscallentry syscall_mbind = {
 .arg3name = ""mode"",
 .arg3type = ARG_LIST,
 .arg3list = {
-.num = 4,
-.values = { MPOL_DEFAULT, MPOL_BIND, MPOL_INTERLEAVE, MPOL_PREFERRED },
+.num = 6,
+.values = { MPOL_DEFAULT, MPOL_BIND, MPOL_INTERLEAVE, MPOL_PREFERRED,
+MPOL_F_STATIC_NODES, MPOL_F_RELATIVE_NODES },
 },
 
 .arg4name = ""nmask"",
 struct syscallentry syscall_mbind = {
 .arg6name = ""flags"",
 .arg6type = ARG_LIST,
 .arg6list = {
-.num = 2,
-.values = { MPOL_F_STATIC_NODES, MPOL_F_RELATIVE_NODES },
+.num = 3,
+.values = { MPOL_MF_STRICT, MPOL_MF_MOVE, MPOL_MF_MOVE_ALL, },
 },
 .sanitise = sanitise_mbind,
 .group = GROUP_VM,
",48,3
re-use testfile filename buffer instead of re-allocating it,"
 #include ""sanitise.h""
 #include ""testfile.h""
 
-static int open_testfile(unsigned int i)
+static int open_testfile(char *filename)
 {
-char *filename;
 int fd;
 int flags = 0;
 
 static int open_testfile(unsigned int i)
 if (rand_bool())
 flags |= O_SYNC;
 
-filename = zmalloc(64);
-sprintf(filename, ""trinity-testfile%d"", i);
-
 if (rand_bool()) {
 fd = open_with_fopen(filename, O_RDWR);
 if (fd != -1)
 static int open_testfile(unsigned int i)
 output(2, ""fd[%d] = open(\""%s\"", flags:%x)\n"", fd, filename, flags);//TODO: decode flags
 }
 
-free(filename);
-
 return fd;
 }
 
 static int open_testfile_fds(void)
 {
-unsigned int i = 0;
+char *filename;
+unsigned int i = 1;
+
+filename = zmalloc(64);
 
 while (i < MAX_TESTFILE_FDS) {
 int fd;
 
-fd = open_testfile(i + 1);
+sprintf(filename, ""trinity-testfile%d"", i);
+
+fd = open_testfile(filename);
 if (fd == -1)
 return FALSE;
 
-shm->testfile_fds[i] = fd;
+shm->testfile_fds[i - 1] = fd;
 i++;
 }
 
+free(filename);
 return TRUE;
 }
 
",64,11
remove old testfiles on startup if they exist," static int open_testfile(char *filename)
 int fd;
 int flags = 0;
 
+/* file might be around from an earlier run, nuke it. */
+(void) chmod(filename, 0666);
+(void) unlink(filename);
+
 if (rand_bool())
 flags |= O_DIRECT;
 
",66,11
"if testfile creation fails, retry instead of failing hard"," static int open_testfile_fds(void)
 sprintf(filename, ""trinity-testfile%d"", i);
 
 fd = open_testfile(filename);
-if (fd == -1)
-return FALSE;
-
-shm->testfile_fds[i - 1] = fd;
-i++;
+if (fd != -1) {
+shm->testfile_fds[i - 1] = fd;
+i++;
+}
 }
 
 free(filename);
",66,11
"if testfile creation is spinning without progress, output errno"," static int open_testfile_fds(void)
 {
 char *filename;
 unsigned int i = 1;
+unsigned int fails = 0;
 
 filename = zmalloc(64);
 
 static int open_testfile_fds(void)
 if (fd != -1) {
 shm->testfile_fds[i - 1] = fd;
 i++;
+fails = 0;
+} else {
+fails++;
+if (fails == 100) {
+output(2, ""testfile creation is failing a lot. last error:%s\n"", strerror(errno));
+}
 }
 }
 
",73,12
"remove pointless chmod

Any permissions problems will be on the directory, not the filename,
so modifying the perms of the file before we unlink it is pointless."," static int open_testfile(char *filename)
 int flags = 0;
 
 /* file might be around from an earlier run, nuke it. */
-(void) chmod(filename, 0666);
 (void) unlink(filename);
 
 if (rand_bool())
",72,12
flesh out generation of epoll structs a bit,"
 */
 #include <sys/epoll.h>
 #include ""sanitise.h""
+#include ""utils.h""
+
+static const unsigned long epoll_flags[] = {
+EPOLLIN, EPOLLOUT, EPOLLRDHUP, EPOLLPRI,
+EPOLLERR, EPOLLHUP, EPOLLET, EPOLLONESHOT,
+EPOLLWAKEUP,
+};
+
+static void sanitise_epoll_ctl(struct syscallrecord *rec)
+{
+struct epoll_event *ep;
+
+ep = zmalloc(sizeof(struct epoll_event));
+ep->events = set_rand_bitmask(ARRAY_SIZE(epoll_flags), epoll_flags);
+rec->a4 = (unsigned long) ep;
+}
+
+static void post_epoll_ctl(struct syscallrecord *rec)
+{
+free((void *)rec->a4);
+}
 
 struct syscallentry syscall_epoll_ctl = {
 .name = ""epoll_ctl"",
 struct syscallentry syscall_epoll_ctl = {
 .arg3name = ""fd"",
 .arg3type = ARG_FD,
 .arg4name = ""event"",
-.arg4type = ARG_ADDRESS,
 .rettype = RET_ZERO_SUCCESS,
 .flags = NEED_ALARM,
+.sanitise = sanitise_epoll_ctl,
+.post = post_epoll_ctl,
 };
",38,2
put a random fd in the epoll struct too," static void sanitise_epoll_ctl(struct syscallrecord *rec)
 struct epoll_event *ep;
 
 ep = zmalloc(sizeof(struct epoll_event));
+ep->data.fd = get_random_fd();
 ep->events = set_rand_bitmask(ARRAY_SIZE(epoll_flags), epoll_flags);
 rec->a4 = (unsigned long) ep;
 }
",39,2
"Add missing EPOLLWAKEUP define to compat.h for older distros

 CC syscalls/epoll_ctl.o
syscalls/epoll_ctl.c:14:2: error: EPOLLWAKEUP undeclared here (not in a function)

Signed-off-by: Brian Haley <brian.haley@hp.com>","
 #include <sys/epoll.h>
 #include ""sanitise.h""
 #include ""utils.h""
+#include ""compat.h""
 
 static const unsigned long epoll_flags[] = {
 EPOLLIN, EPOLLOUT, EPOLLRDHUP, EPOLLPRI,
",40,2
"Revert ""allocate the output buffers on child startup.""

This reverts commit 10e37a39ed8686cb1801adc42bfbb67ce39975ce.

While this had the effect of avoiding the occasional corruption
to the child structs, it had the unwanted side-effect of breaking
the post-mortem code, because it could no longer dereference
the buffers from outside the child process.

I still need to spend some time hardening the output functions
to not overrun these buffers, but since 1280b9854b, we should
at least not hang when we hit corrupted states any more, which
is a good enough stop-gap until I fix things up properly."," static void oom_score_adj(int adj)
 static void reinit_child(struct childdata *child)
 {
 memset(&child->syscall, 0, sizeof(struct syscallrecord));
-child->syscall.prebuffer = zmalloc(PREBUFFER_LEN);
-child->syscall.postbuffer = zmalloc(POSTBUFFER_LEN);
-
 memset(&child->previous, 0, sizeof(struct syscallrecord));
-child->previous.prebuffer = zmalloc(PREBUFFER_LEN);
-child->previous.postbuffer = zmalloc(POSTBUFFER_LEN);
 
 child->num_mappings = 0;
 child->seed = 0;
",250,50
"introduce for_each_arg helper, and use everywhere"," static void render_syscall_prefix(struct syscallrecord *rec)
 
 sptr += sprintf(sptr, ""%s%s("", entry->name, ANSI_RESET);
 
-for (i = 1; i <= entry->num_args; i++)
+for_each_arg(i) {
 sptr = render_arg(rec, sptr, i, entry);
+}
 
 (void) sprintf(sptr, ""%s) "", ANSI_RESET);
 }
",163,43
simplify no_syscalls_enabled," void init_syscalls(void)
 
 bool no_syscalls_enabled(void)
 {
-if (biarch == TRUE) {
-if ((shm->nr_active_32bit_syscalls == 0) && (shm->nr_active_64bit_syscalls == 0))
-return TRUE;
-else
-return FALSE;
-}
+unsigned int total;
 
-/* non-biarch */
-if (shm->nr_active_syscalls == 0)
+if (biarch == TRUE)
+total = shm->nr_active_32bit_syscalls + shm->nr_active_64bit_syscalls;
+else
+total = shm->nr_active_syscalls;
+
+if (total == 0)
 return TRUE;
 else
 return FALSE;
",414,114
prebuffer sanity check across system calls," bool child_random_syscalls(void)
 struct syscallrecord *rec;
 unsigned int syscallnr;
 bool do32;
+unsigned int len;
 
 retry:
 if (no_syscalls_enabled() == TRUE) {
 retry:
 generate_syscall_args(rec);
 output_syscall_prefix(rec);
 
+/* Sanity check: Make sure the length of the buffer remains
+ * constant across the syscall.
+ */
+len = strlen(rec->prebuffer);
+
 /* If we're going to pause, might as well sync pre-syscall */
 if (dopause == TRUE)
 synclogs();
 
 do_syscall(rec);
+
+/* post syscall sanity checks. */
+if (len != strlen(rec->prebuffer)) {
+output(0, ""Sanity check failed: prebuffer length changed from %d to %d.\n"",
+len, strlen(rec->prebuffer));
+}
+
 check_page_rand_redzone();
 
-/* we're back. Output what happened, and clean up */
+/* Output the syscall result, and clean up */
 output_syscall_postfix(rec);
 
 if (dopause == TRUE)
",93,17
move sso_socket to fd-sockets.c as it's now the only user.," unsigned int nr_sockets = 0;
 
 static const char *cachefilename=""trinity.socketcache"";
 
+static void sso_socket(struct socket_triplet *triplet, struct sockopt *so, int fd)
+{
+int ret;
+unsigned int tries = 0;
+
+/* skip over bluetooth due to weird linger bug */
+if (triplet->family == PF_BLUETOOTH)
+return;
+
+retry:
+do_setsockopt(so);
+
+ret = setsockopt(fd, so->level, so->optname, (void *)so->optval, so->optlen);
+if (ret == 0) {
+output(2, ""setsockopt(%lx %lx %lx %lx) on fd %d [%d:%d:%d]\n"",
+so->level, so->optname, so->optval, so->optlen, fd,
+triplet->family, triplet->type, triplet->protocol);
+} else {
+tries++;
+if (tries == 100)
+return;
+
+goto retry;
+}
+}
+
 static int open_socket(unsigned int domain, unsigned int type, unsigned int protocol)
 {
 int fd;
",299,68
rename __output_syscall," static unsigned int render_syscall_postfix(struct syscallrecord *rec, char *buff
 return sptr - bufferstart;
 }
 
-static void __output_syscall(char *buffer, unsigned int len)
+static void output_rendered_buffer(char *buffer, unsigned int len)
 {
 /* Output to stdout only if -q param is not specified */
 if (quiet_level == MAX_LOGLEVEL)
 void output_syscall_prefix(struct syscallrecord *rec)
 memcpy(rec->prebuffer, buffer, len);
 memset(rec->prebuffer + len, 0, PREBUFFER_LEN - len);
 
-__output_syscall(rec->prebuffer, PREBUFFER_LEN);
+output_rendered_buffer(rec->prebuffer, PREBUFFER_LEN);
 }
 
 void output_syscall_postfix(struct syscallrecord *rec)
 void output_syscall_postfix(struct syscallrecord *rec)
 memcpy(rec->postbuffer, buffer, len);
 memset(rec->postbuffer + len, 0, POSTBUFFER_LEN - len);
 
-__output_syscall(rec->postbuffer, POSTBUFFER_LEN);
+output_rendered_buffer(rec->postbuffer, POSTBUFFER_LEN);
 }
",176,46
describe usage of poorly named 'BUFSIZE' define,"
 #include ""trinity.h""
 #include ""utils.h""
 
-#define BUFSIZE 1024
+#define BUFSIZE 1024// decoded syscall args are fprintf'd directly, this is for everything else.
 
 char ANSI_RED[] = ""[1;31m"";
 char ANSI_GREEN[] = ""[1;32m"";
",210,42
"remove all the 'no_files' code.

This was a mess, and never really worked as intended.
With the arrival of dynamic fd providers, it got even more broken."," static int open_files(void)
 {
 unsigned int i, nr_to_open;
 
-if (no_files == TRUE)
-return TRUE;
-
 generate_filelist();
 
 if (files_in_index == 0) {
 static int get_rand_file_fd(void)
 {
 unsigned int fd_index;
 
-if (no_files == TRUE)// FIXME: This should go away when we have dynamic fd reg
-return -1;
-
 if (nr_file_fds == 0)
 return -1;
 
",297,66
update -g help to mention vfs group," static void usage(void)
 outputerr("" --dropprivs, -X: if run as root, switch to nobody [EXPERIMENTAL]\n"");
 outputerr("" --exclude,-x: don't call a specific syscall\n"");
 enable_disable_fd_usage();
-outputerr("" --group,-g: only run syscalls from a certain group (So far just 'vm').\n"");
+outputerr("" --group,-g = {vfs,vm}: only run syscalls from a certain group.\n"");
 outputerr("" --ioctls,-I: list all ioctls.\n"");
 outputerr("" --kernel_taint, -T: controls which kernel taint flags should be considered, for more details refer to README file. \n"");
 outputerr("" --list,-L: list all syscalls known on this architecture.\n"");
",268,45
"fix --group

Syscalls weren't actually being enabled."," int setup_syscall_group_biarch(unsigned int group)
 
 for_each_32bit_syscall(i) {
 if (syscalls_32bit[i].entry->group == group)
-activate_syscall32(i);
+toggle_syscall(syscalls_32bit[i].entry->name, TRUE);
 }
 
 if (shm->nr_active_32bit_syscalls == 0)
 int setup_syscall_group_biarch(unsigned int group)
 /* now the 64 bit table*/
 for_each_64bit_syscall(i) {
 if (syscalls_64bit[i].entry->group == group)
-activate_syscall64(i);
+toggle_syscall(syscalls_64bit[i].entry->name, TRUE);
 }
 
 if (shm->nr_active_64bit_syscalls == 0) {
",273,62
make sanitise_mmap use set_rand_bitmask()," static void do_anon(struct syscallrecord *rec)
 
 static void sanitise_mmap(struct syscallrecord *rec)
 {
-unsigned int i;
-unsigned int flagvals[NUM_FLAGS] = { MAP_FIXED, MAP_ANONYMOUS,
+unsigned long mmap_flags[NUM_FLAGS] = { MAP_FIXED, MAP_ANONYMOUS,
 MAP_GROWSDOWN, MAP_DENYWRITE, MAP_EXECUTABLE, MAP_LOCKED,
 MAP_NORESERVE, MAP_POPULATE, MAP_NONBLOCK, MAP_STACK,
 MAP_HUGETLB, MAP_UNINITIALIZED,
 static void sanitise_mmap(struct syscallrecord *rec)
 MAP_32BIT,
 #endif
 };
-unsigned int numflags = rand() % NUM_FLAGS;
 unsigned long sizes[] = {
 -1,/* over-written with page_size below */
 1 * MB, 2 * MB, 4 * MB, 10 * MB,
 static void sanitise_mmap(struct syscallrecord *rec)
 rec->a1 = 0;
 
 // set additional flags
-for (i = 0; i < numflags; i++)
-rec->a4 |= flagvals[rand() % NUM_FLAGS];
+rec->a4 = set_rand_bitmask(ARRAY_SIZE(mmap_flags), mmap_flags);
 
 if (rec->a4 & MAP_ANONYMOUS) {
 rec->a2 = sizes[rand() % ARRAY_SIZE(sizes)];
",148,15
"rename 'proto' to 'domain' where necessary

To avoid confusion with the actual protocol argument to socket()","
 #include ""maps.h""
 #include ""config.h""
 #include ""random.h""
-#include ""params.h""// do_specific_proto
+#include ""params.h""// do_specific_domain
 #include ""utils.h""// ARRAY_SIZE
 
 struct sa_func_entry {
 void generate_sockaddr(struct sockaddr **addr, socklen_t *addrlen, int pf)
 unsigned int i;
 
 /* If we want sockets of a specific type, we'll want sockaddrs that match. */
-if (do_specific_proto == TRUE)
-pf = specific_proto;
+if (do_specific_domain == TRUE)
+pf = specific_domain;
 
 /* If we got no hint passed down, pick a random proto. */
 if (pf == -1)
",60,5
"fix up warning in analyze-sockets

This will be removed when I add argument parsing tomorrow"," static void open_sockets(void)
 close(cachefile);
 }
 
-int main(int argc, char* argv[])
+int main(__attribute((unused)) int argc, __attribute((unused)) char* argv[])
 {
  open_sockets();
 }
",161,20
show a backtrace if we hit the BUG in exit_main_fail,"
 */
 void exit_main_fail(void)
 {
-if (getpid() != shm->mainpid)
+if (getpid() != shm->mainpid) {
+show_backtrace();
 BUG(""wtf, exit_main_fail called from non main pid!\n"");
+}
 
 shm->mainpid = 0;
 exit(EXIT_FAILURE);
",253,54
"dump the random-page to /tmp

because cwd might be somewhere unwritable."," void check_page_rand_redzone(void)
 
 output(0, ""Something stomped the rand page guard page at %p!\n"", page_rand + page_size);
 
-fd = fopen(""trinity-pagerand.log"", ""w"");
+fd = fopen(""/tmp/trinity-pagerand.log"", ""w"");
 if (!fd) {
 outputerr(""Failed to dump page_rand log (%s)\n"", strerror(errno));
 return;
",133,37
"check the whole page_rand redzone, not just the first byte"," static void fabricate_onepage_struct(char *page)
 void check_page_rand_redzone(void)
 {
 FILE *fd;
+unsigned int i;
+char total = 0;
+
+for (i = 0; i < page_size; i++)
+total |= page_rand[page_size + i];
 
-if (page_rand[page_size] == 0)
+if (total == 0)
 return;
 
 output(0, ""Something stomped the rand page guard page at %p!\n"", page_rand + page_size);
",137,38
parse argv in analyze-sockets," static const char *decode_type(unsigned int type)
 }
 
 
-static const char *cachefilename=""trinity.socketcache"";
-
-static void open_sockets(void)
+static void open_sockets(char *cachefilename)
 {
 int cachefile;
 unsigned int family, type, protocol;
 static void open_sockets(void)
 close(cachefile);
 }
 
-int main(__attribute((unused)) int argc, __attribute((unused)) char* argv[])
+int main(int argc, char* argv[])
 {
- open_sockets();
+if (argc < 1) {
+printf(""Pass filename of socket file as argument.\n"");
+exit(EXIT_FAILURE);
+}
+
+open_sockets(argv[1]);
 }
",164,21
"use mkstemp for pagerand dumper

Otherwise we fail to write over the existing file if we've already dumped"," static void fabricate_onepage_struct(char *page)
 
 void check_page_rand_redzone(void)
 {
-FILE *fd;
+int fd;
 unsigned int i;
 char total = 0;
+char filename[] = ""/tmp/trinity-pagerand-XXXXXX"";
 
 for (i = 0; i < page_size; i++)
 total |= page_rand[page_size + i];
 void check_page_rand_redzone(void)
 
 output(0, ""Something stomped the rand page guard page at %p!\n"", page_rand + page_size);
 
-fd = fopen(""/tmp/trinity-pagerand.log"", ""w"");
-if (!fd) {
-outputerr(""Failed to dump page_rand log (%s)\n"", strerror(errno));
+fd = mkstemp(filename);
+if (fd == -1) {
+perror(""Failed to mkstemp page_rand log"");
 return;
 }
+output(0, ""Dumped page_rand and guard page to %s\n"", filename);
 
-fwrite(page_rand, page_size, 2, fd);
+if (write(fd, page_rand, page_size * 2) == -1)
+perror(""failed to write page_rand log"");
 
-fclose(fd);
+close(fd);
 }
 
 
",140,39
"uclibc can be configured without backtrace support, so check for it.","
 * Various routines useful for debugging.
 */
 
+#include ""config.h""
+
+#ifdef USE_BACKTRACE
 #include <execinfo.h>
+#endif
 #include <stdio.h>
 #include <stdarg.h>
 #include ""child.h""
-#include ""config.h""
 #include ""debug.h""
 #include ""log.h""
 #include ""params.h""

 
 void show_backtrace(void)
 {
+#ifdef USE_BACKTRACE
 unsigned int j, nptrs;
 void *buffer[BACKTRACE_SIZE];
 char **strings;
 void show_backtrace(void)
 free(strings);
 out:
 set_dontkillme(getpid(), TRUE);
+#endif
 }
 
 void __BUG(const char *bugtxt, const char *filename, const char *funcname, unsigned int lineno)
",84,11
add a check for appletalk headers,"
+#include ""config.h""
+
+#ifdef USE_APPLETALK
 #include <stdlib.h>
 #include <sys/types.h>
 #include <sys/socket.h>
 void atalk_setsockopt(struct sockopt *so)
 {
 so->level = SOL_ATALK;
 }
+#endif
",36,4
"Disable icmp6 if there is no support for ipv6

Signed-off-by: Vicente Olivert Riera <Vincent.Riera@imgtec.com>","
+#include ""config.h""
+
+#ifdef USE_IPV6
 #include <stdlib.h>
 #include <linux/icmpv6.h>
 #include ""net.h""
 void icmpv6_setsockopt(struct sockopt *so)
 val = rand() % NR_SOL_ICMPV6_OPTS;
 so->optname = icmpv6_opts[val];
 }
+#endif
",14,1
"Disable ipv6 if there is no ipv6 support

Signed-off-by: Vicente Olivert Riera <Vincent.Riera@imgtec.com>","
+#include ""config.h""
+
+#ifdef USE_IPV6
 #include <sys/types.h>
 #include <sys/socket.h>
 #include <sys/un.h>
 void inet6_setsockopt(struct sockopt *so)
 val = rand() % NR_SOL_INET6_OPTS;
 so->optname = inet6_opts[val];
 }
+#endif
",85,15
"Add a check for netrom headers

Signed-off-by: Vicente Olivert Riera <Vincent.Riera@imgtec.com>","
+#include ""config.h""
+
+#ifdef USE_NETROM
 #include <stdlib.h>
 #include <netrom/netrom.h>
 #include ""net.h""
 void netrom_setsockopt(struct sockopt *so)
 val = rand() % NR_SOL_NETROM_OPTS;
 so->optname = netrom_opts[val];
 }
+#endif
",15,1
"Add a check for rose headers

Signed-off-by: Vicente Olivert Riera <Vincent.Riera@imgtec.com>","
+#include ""config.h""
+
+#ifdef USE_ROSE
 #include <sys/types.h>
 #include <sys/socket.h>
 #include <sys/un.h>
 void rose_setsockopt(struct sockopt *so)
 val = rand() % NR_SOL_ROSE_OPTS;
 so->optname = rose_opts[val];
 }
+#endif
",40,2
"inline __syscall_return in the 32-bit path.

Also update maximum errno"," static long syscall32(unsigned int call,
 
 #if defined(DO_32_SYSCALL)
 DO_32_SYSCALL
-__syscall_return(long, __res);
+
+if ((unsigned long)(__res) >= (unsigned long)(-133)) {
+errno = -(__res);
+__res = -1;
+}
+
 #else
 #error Implement 32-on-64 syscall macro for this architecture.
 #endif
",152,29
"watchdog: check dead children aren't holding locks.

As well as the main watchdog loop, we need to do this
in kill_all_kids() as it can spin indefinitely."," static void kill_all_kids(void)
 kill(pid, SIGKILL);
 }
 
+/* Check that no dead children hold locks. */
+check_all_locks();
+
 /* wait a second to give kids a chance to exit. */
 sleep(1);
 }
",313,62
"watchdog: reap dead kids in the kill_all_kids loop

Again, because we're spinning here, we may need to do
periodic cleanup, like the watchdog main loop does.

[ A future cleanup might be to split out the common parts
 of the two 'spin indefinitely' loops to a single function. ]"," static void kill_all_kids(void)
 /* Ok, some kids are still alive. 'help' them along with a SIGKILL */
 for_each_child(i) {
 pid_t pid;
+int ret;
 
 pid = shm->children[i]->pid;
 if (pid == EMPTY_PIDSLOT)
 static void kill_all_kids(void)
 if (pid_is_valid(pid) == FALSE)
 continue;
 
-kill(pid, SIGKILL);
+ret = kill(pid, SIGKILL);
+/* check we don't have anything stale in the pidlist */
+if (ret == -1) {
+if (errno == ESRCH)
+reap_child(pid);
+}
 }
 
 /* Check that no dead children hold locks. */
",318,64
"watchdog: sanity check that shm->running_childs is correct.

If we end up with nothing but empty pid slots, and somehow
shm->running_childs isn't right, correct it.

It would be nice if shm->running_childs was never wrong, but
on occasion things go awry. There's probably a bug or two
in the child handling somewhere, but this works around it for now."," static void kill_all_kids(void)
 /* Wait for all the children to exit. */
 while (shm->running_childs > 0) {
 
+int children_seen = 0;
+
 /* Ok, some kids are still alive. 'help' them along with a SIGKILL */
 for_each_child(i) {
 pid_t pid;
 static void kill_all_kids(void)
 if (pid_is_valid(pid) == FALSE)
 continue;
 
+children_seen++;
+
 ret = kill(pid, SIGKILL);
 /* check we don't have anything stale in the pidlist */
 if (ret == -1) {
 static void kill_all_kids(void)
 }
 }
 
+if (children_seen == 0)
+shm->running_childs = 0;
+
 /* Check that no dead children hold locks. */
 check_all_locks();
 
",322,65
"make the child reap itself before it exits.

This seems to fix a bug I was seeing when running with _MALLOC_PERTURB set.
The symptoms looked like a use-after-free in the child struct,
which is puzzling as they are allocated during startup and never freed
until we exit. I don't fully understand it, but this is a nice
code cleanup while also making the problem disappear."," static void fork_children(void)
 
 debugf(""child %d %d exiting.\n"", childno, getpid());
 close_logfile(&this_child->logfile);
+reap_child(child->pid);
 _exit(EXIT_SUCCESS);
 } else {
 if (pid == -1) {
 static void handle_child(pid_t childpid, int childstatus)
 int childno;
 
 childno = find_childno(childpid);
-if (childno == CHILD_NOT_FOUND) {
-/* If we reaped it, it wouldn't show up, so check that. */
-if (shm->last_reaped != childpid) {
-outputerr(""## Couldn't find %d in list of pids.\n"", childpid);
-panic(EXIT_LOST_CHILD);
-dump_childnos();
-}
-} else {
+if (childno != CHILD_NOT_FOUND) {
 debugf(""Child %d exited after %ld operations.\n"",
 childpid, shm->children[childno]->syscall.op_nr);
 reap_child(childpid);
",248,53
"micro-cleanup in page-random

use 3rd arg of for statement instead of incrementing in the loop"," void generate_random_page(char *page)
 
 /* page full of format strings. */
 case 6:
-for (i = 0; i < page_size; ) {
-page[i++] = '%';
+for (i = 0; i < page_size; i += 2) {
+page[i] = '%';
 switch (rand_bool()) {
-case 0:page[i++] = 'd';
+case 0:page[i + 1] = 'd';
 break;
-case 1:page[i++] = 's';
+case 1:page[i + 1] = 's';
 break;
 }
 }
",140,39
"switch rand-page dumper to use pid in its filename

mkstemp was only used to generate something unique. But we only
really want one per process, because we'll keep hitting the
same corruption, and dump it multiple times."," static void fabricate_onepage_struct(char *page)
 
 void check_page_rand_redzone(void)
 {
-int fd;
+FILE *fd;
 unsigned int i;
 char total = 0;
 char filename[] = ""/tmp/trinity-pagerand-XXXXXX"";
 void check_page_rand_redzone(void)
 
 output(0, ""Something stomped the rand page guard page at %p!\n"", page_rand + page_size);
 
-fd = mkstemp(filename);
-if (fd == -1) {
-perror(""Failed to mkstemp page_rand log"");
+sprintf(filename, ""/tmp/trinity-pagerand-%d"", getpid());
+fd = fopen(filename, ""w"");
+if (!fd) {
+perror(""Failed to open randpage log"");
 return;
 }
 output(0, ""Dumped page_rand and guard page to %s\n"", filename);
 
-if (write(fd, page_rand, page_size * 2) == -1)
-perror(""failed to write page_rand log"");
+fwrite(page_rand, page_size, 2, fd);
 
-close(fd);
+fclose(fd);
 }
 
 
",140,38
watchdog: fix off by one in adjtimex compensation.," static void check_child_progress(struct childdata *child)
 kill_pid(pid);
 
 /* if we wrapped, just reset it, we'll pick it up next time around. */
-if (diff > 2145) {/* max adjtime offset. */
+if (diff > 2146) {/* max adjtime offset, + the 1 second since last time. */
 output(1, ""child %u wrapped! old=%lu now=%lu\n"", child->num, old, now);
 rec->tv.tv_sec = now;
 return;
",322,65
commentary for reap_child()," static void fork_children(void)
 debugf(""created enough children\n"");
 }
 
+/*
+ * reap_child: Remove all references to a running child.
+ *
+ * This can get called from three possible places.
+ * 1. A child calls this itself just before it exits to clear out
+ * its child struct in the shm.
+ * 2. From the watchdog if it finds reference to a pid that no longer exists.
+ * 3. From the main pid if it gets a SIGBUS or SIGSTOP from the child.
+ *
+ * The reaper lock protects against these happening at the same time.
+ */
 void reap_child(pid_t childpid)
 {
 struct childdata *child;
",248,53
fix up optlen/optval confusion in proto-iucv setsockopt," void iucv_setsockopt(struct sockopt *so)
 val = rand() % NR_SOL_IUCV_OPTS;
 so->optname = iucv_opts[val];
 
-so->optval = sizeof(int);
+so->optlen = sizeof(int);
 }
",14,1
fix optlen/optval confusion in proto-pppol2tp setsockopt," void pppol2tp_setsockopt(struct sockopt *so)
 val = rand() % NR_SOL_PPPOL2TP_OPTS;
 so->optname = pppol2tp_opts[val];
 
-so->optval = sizeof(int);
+so->optlen = sizeof(int);
 }
",17,1
remove double inclusion of maps.h,"
 #include <linux/ax25.h> /* for ax25_address in rose.h */
 #include <netrose/rose.h>
 #include <stdlib.h>
-#include ""maps.h""// page_rand
 #include ""net.h""
 #include ""maps.h""// page_rand
 #include ""utils.h""// ARRAY_SIZE
",39,2
fix optlen/optval confusion in proto-tipc setsockopt," void tipc_setsockopt(struct sockopt *so)
 val = rand() % NR_SOL_TIPC_OPTS;
 so->optname = tipc_opts[val];
 
-so->optval = sizeof(__u32);
+so->optlen = sizeof(__u32);
 }
",52,6
mark some TODO's for page_rand removal later.," void unix_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 
 unixsock->sun_family = PF_UNIX;
 len = rand() % 20;
-memset(&page_rand[len], 0, 1);
-strncpy(unixsock->sun_path, page_rand, len);
+strncpy(unixsock->sun_path, page_rand, len);// TODO: generate_rand_bytes()
 *addr = (struct sockaddr *) unixsock;
 *addrlen = sizeof(struct sockaddr_un);
 }
",33,5
setsockopt: so->optval needs writable memory,"
 #include <sys/types.h>
 #include <sys/socket.h>
 #include <linux/types.h>
+#include ""arch.h""
 #include ""config.h""
 #include ""log.h""
 #include ""maps.h""
 static const struct sso_funcptr ssoptrs[] = {
 */
 void do_setsockopt(struct sockopt *so)
 {
-so->optval = (unsigned long) get_non_null_address();
+/* get a page for the optval to live in.
+ * TODO: push this down into the per-proto .func calls
+ */
+so->optval = (unsigned long) get_writable_address(page_size);
 
 // pick a size for optlen. At the minimum, we want an int (overridden below)
 if (rand_bool())
",97,6
move generate_sockaddr away from page_rand usage.," void generate_sockaddr(struct sockaddr **addr, socklen_t *addrlen, int pf)
 }
 
 /* Make something up for unknown protocols. */
-*addr = (struct sockaddr *) page_rand;
+*addr = (struct sockaddr *) get_writable_address(100);
 *addrlen = rand() % 100;
 }
",60,5
make ip_setsockopt use the so->optval passed down.," void ip_setsockopt(struct sockopt *so)
 case IP_DROP_MEMBERSHIP:
 mcaddr = 0xe0000000 | rand() % 0xff;
 
-mr = zmalloc(sizeof(struct ip_mreqn));
+mr = (struct ip_mreqn *) so->optval;
 mr->imr_multiaddr.s_addr = mcaddr;
 mr->imr_address.s_addr = random_ipv4_address();
 mr->imr_ifindex = rand32();
 
-so->optval = (unsigned long) mr;
 so->optlen = sizeof(struct ip_mreqn);
 break;
 
 void ip_setsockopt(struct sockopt *so)
 case IP_DROP_SOURCE_MEMBERSHIP:
 mcaddr = 0xe0000000 | rand() % 0xff;
 
-ms = zmalloc(sizeof(struct ip_mreq_source));
+ms = (struct ip_mreq_source *) so->optval;
 ms->imr_multiaddr.s_addr = mcaddr;
 ms->imr_interface.s_addr = random_ipv4_address();
 ms->imr_sourceaddr.s_addr = random_ipv4_address();
 
-so->optval = (unsigned long) ms;
 so->optlen = sizeof(struct ip_mreq_source);
 break;
 
",224,70
make udp_setsockopt use the optval passed down,"
 #include <stdlib.h>
 #include <netinet/udp.h>
 #include ""net.h""
-#include ""maps.h""// page_rand
-#include ""compat.h""
+#include ""random.h""
 #include ""utils.h""// ARRAY_SIZE
+#include ""compat.h""
 
 #define NR_SOL_UDP_OPTS ARRAY_SIZE(udp_opts)
 static const unsigned int udp_opts[] = { UDP_CORK, UDP_ENCAP };
 static const unsigned int udp_opts[] = { UDP_CORK, UDP_ENCAP };
 void udp_setsockopt(struct sockopt *so)
 {
 unsigned char val;
+char *optval;
 
 so->level = SOL_UDP;
 
 void udp_setsockopt(struct sockopt *so)
 case UDP_CORK:
 break;
 case UDP_ENCAP:
-page_rand[0] = (rand() % 3) + 1; // Encapsulation types.
+optval = (char *) so->optval;
+optval[0] = rand_range(1, 3); // Encapsulation types.
 break;
 default:
 break;
",25,3
make udplite_setsockopt use the optval passed down,"
 #include <stdlib.h>
 #include <linux/udp.h>
 #include ""net.h""
-#include ""maps.h""// page_rand
-#include ""compat.h""
+#include ""random.h""
 #include ""utils.h""// ARRAY_SIZE
+#include ""compat.h""
 
 #define SOL_UDPLITE 136
 
 static const unsigned int udplite_opts[] = { UDP_CORK, UDP_ENCAP, UDPLITE_SEND_C
 
 void udplite_setsockopt(struct sockopt *so)
 {
+char *optval;
 unsigned char val;
 
 so->level = SOL_UDPLITE;
 void udplite_setsockopt(struct sockopt *so)
 case UDP_CORK:
 break;
 case UDP_ENCAP:
-page_rand[0] = (rand() % 3) + 1; // Encapsulation types.
+optval = (char *) so->optval;
+optval[0] = rand_range(1, 3); // Encapsulation types.
 break;
 case UDPLITE_SEND_CSCOV:
 break;
",29,5
make x25_setsockopt use the optval passed down," void x25_rand_socket(struct socket_triplet *st)
 
 void x25_setsockopt(struct sockopt *so)
 {
+unsigned int *optval;
+
 so->level = SOL_X25;
 
-page_rand[0] = rand_bool();
-so->optval = sizeof(int);
+optval = (unsigned int *) so->optval;
+*optval = rand_bool();
+
+so->optlen = sizeof(int);
 }
",34,3
"simply get_writable_address to just use mmaps.

The leaking of zmalloc'd pages was pretty crappy, and now that
we have better mmap support, this should give us good enough
results.

Also, it's another step towards being rid of page_rand"," void * get_writable_address(unsigned long size)
 {
 struct map *map;
 void *addr = NULL;
-int i;
 
 /* Because we get called during startup when we create fd's, we need
  * to special case this, as we can't use get_non_null_address at that point */
+//FIXME: This sucks, and needs to go away when page_rand dies.
 if (getpid() == shm->mainpid)
 return page_rand;
 
-i = rand() % 3;
-
-if (size > page_size)
-i = rand_range(1, 2);
-
-switch (i) {
-case 0:addr = page_rand;
-break;
+retry:
+map = get_map();
 
-case 1: map = get_map();
-addr = map->ptr;
-mprotect(addr, map->size, PROT_READ|PROT_WRITE);
+if (map->size < size)
+goto retry;
 
-//if (rand_bool()) {
-//addr += map->size;
-//addr -= size;
-//}
-break;
-
-case 2: addr = zmalloc(size);// FIXME: We leak this.
-//if (rand_bool()) {
-///* place object at end of page. */
-//addr += page_size;
-//addr -= size;
-//}
-break;
-}
+addr = map->ptr;
+mprotect(addr, map->size, PROT_READ | PROT_WRITE);
 
 return addr;
 }
",103,28
make ARG_UNDEFINED sometimes return a mapping," static unsigned long fill_arg(struct syscallrecord *rec, unsigned int argnum)
 
 switch (argtype) {
 case ARG_UNDEFINED:
-return (unsigned long) rand64();
+if (rand_bool())
+return (unsigned long) rand64();
+return (unsigned long) get_writable_address(page_size);
 
 case ARG_FD:
 return get_random_fd();
",347,115
kill off ARG_RANDPAGE," static char * decode_argtype(char *sptr, unsigned long reg, enum argtype type)
 sptr += sprintf(sptr, ""%p"", (void *) reg);
 break;
 
-case ARG_RANDPAGE:
-sptr += sprintf(sptr, ""0x%lx [page_rand]"", reg);
-break;
-
 case ARG_OP:
 case ARG_LIST:
 sptr += sprintf(sptr, ""0x%lx"", reg);
",173,45
"fix generate_sockaddr allocation.

This needs to be an actual allocation in the case we don't have a proto
definition doing an allocation already. This is because open_socket()
will try to free it on startup.","
 #include ""debug.h""
 #include ""log.h""
 #include ""net.h""
-#include ""maps.h""
 #include ""params.h""// verbose, do_specific_domain
 #include ""domains.h""
 #include ""random.h""
 static int open_socket(unsigned int domain, unsigned int type, unsigned int prot
 }
 }
 
-/* If we didn't have a function for this sockaddr type, we would
- * have returned page_rand, so don't free() it or we segv. */
-if (sa == (struct sockaddr *) page_rand)
-return fd;
-
 if (sa != NULL)
 free(sa);
 
",296,67
sockaddr in post_sendmsg is now always freeable.," static void sanitise_sendmsg(struct syscallrecord *rec)
 static void post_sendmsg(__unused__ struct syscallrecord *rec)
 {
 if (msg != NULL) {
-if (msg->msg_name != page_rand)// FIXME: What about other kinds of pages ?
-free(msg->msg_name);// free sockaddr
+free(msg->msg_name);// free sockaddr
 free(msg);
 }
 }
",121,3
add generate_rand_bytes function to generate a stream of randomness,"
 #include ""types.h""
 #include ""utils.h""
 
+void generate_rand_bytes(unsigned char *ptr, unsigned int len)
+{
+unsigned int i;
+
+for (i = 0; i < len; i++) {
+ptr[i] = rand();
+}
+}
+
 unsigned int rand_range(unsigned int min, unsigned int max)
 {
 if (min > max)
",186,59
use generate_rand_bytes in unix_gen_sockaddr,"
 #include <stdlib.h>
 #include ""maps.h""
 #include ""net.h""
+#include ""random.h""
 #include ""utils.h""
 
 void unix_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 void unix_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 
 unixsock->sun_family = PF_UNIX;
 len = rand() % 20;
-strncpy(unixsock->sun_path, page_rand, len);// TODO: generate_rand_bytes()
+generate_rand_bytes((unsigned char *)unixsock->sun_path, len);
 *addr = (struct sockaddr *) unixsock;
 *addrlen = sizeof(struct sockaddr_un);
 }
",34,5
use generate_rand_bytes in x25_gen_sockaddr,"
 #include <linux/x25.h>
 #include <stdlib.h>
 #include ""net.h""
-#include ""maps.h""// page_rand
 #include ""random.h""
 #include ""utils.h""
 
 void x25_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 
 x25->sx25_family = PF_X25;
 len = rand() % 15;
-strncpy(x25->sx25_addr.x25_addr, page_rand, len);// TODO: generate_rand_bytes()
+generate_rand_bytes((unsigned char *) x25->sx25_addr.x25_addr, len);
 *addr = (struct sockaddr *) x25;
 *addrlen = sizeof(struct sockaddr_x25);
 }
",33,3
remove unnecessary maps.h include now we don't use page_rand,"
 #include <netinet/in.h>
 #include <linux/dn.h>
 #include <stdlib.h>
-#include ""maps.h""
 #include ""net.h""
 #include ""random.h""
 #include ""utils.h""
",33,5
use generate_rand_bytes in ax25_gen_sockaddr,"
 #include <sys/un.h>
 #include <netinet/in.h>
 #include <netax25/ax25.h>
-#include ""maps.h""// page_rand
 #include ""net.h""
 #include ""random.h""
 #include ""utils.h""// ARRAY_SIZE
 void ax25_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 ax25 = zmalloc(sizeof(struct sockaddr_ax25));
 
 ax25->sax25_family = PF_AX25;
-memcpy(ax25->sax25_call.ax25_call, page_rand, 7);
+generate_rand_bytes((unsigned char *) ax25->sax25_call.ax25_call, 7);
 ax25->sax25_ndigis = rand();
 *addr = (struct sockaddr *) ax25;
 *addrlen = sizeof(struct sockaddr_ax25);
",61,6
convert packet_setsockopt to use passed down optval instead of page_rand,"
 #include <linux/if_ether.h>
 #include <stdlib.h>
 #include ""net.h""
-#include ""maps.h""// page_rand
 #include ""random.h""
 #include ""utils.h""// ARRAY_SIZE
 #include ""compat.h""
 static const unsigned int packet_opts[] = {
 void packet_setsockopt(struct sockopt *so)
 {
 unsigned char val;
+char *optval;
 
 so->level = SOL_PACKET;
 
+optval = (char *) so->optval;
+
 val = rand() % NR_SOL_PACKET_OPTS;
 so->optname = packet_opts[val];
 
 /* Adjust length according to operation set. */
 switch (so->optname) {
 case PACKET_VERSION:
-page_rand[0] = rand() % 3; /* tpacket versions 1/2/3 */
+optval[0] = rand() % 3; /* tpacket versions 1/2/3 */
 break;
 
 case PACKET_TX_RING:
",66,13
convert rose_gen_sockaddr to use generate_rand_bytes,"
 #include <netrose/rose.h>
 #include <stdlib.h>
 #include ""net.h""
-#include ""maps.h""// page_rand
 #include ""utils.h""// ARRAY_SIZE
 #include ""compat.h""
 
 void rose_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 rose->srose_addr.rose_addr[3] = rand();
 rose->srose_addr.rose_addr[4] = rand();
 
-memcpy(rose->srose_call.ax25_call, page_rand, 7);
+generate_rand_bytes((unsigned char *) rose->srose_call.ax25_call, 7 * 2);
 
 rose->srose_ndigis = rand();
 
-memcpy(rose->srose_digi.ax25_call, page_rand + 7, 7);
-
 *addr = (struct sockaddr *) rose;
 *addrlen = sizeof(struct sockaddr_rose);
 }
",37,2
move autofs ioctl code away from page_rand," static void autofs_sanitise(const struct ioctl_group *grp, struct syscallrecord
 
 pick_random_ioctl(grp, rec);
 
-rec->a3 = (unsigned long) page_rand;
+rec->a3 = (unsigned long) get_address();
 
 switch (rec->a2) {
 case AUTOFS_DEV_IOCTL_VERSION:
",180,18
move device mapper ioctl code away from page_rand,"
 #include ""utils.h""
 #include ""ioctls.h""
 #include ""random.h""
+#include ""sanitise.h""
 
 static const struct ioctl dm_ioctls[] = {
 IOCTL(DM_VERSION),
 static void dm_sanitise(const struct ioctl_group *grp, struct syscallrecord *rec
 
 pick_random_ioctl(grp, rec);
 
-rec->a3 = (unsigned long) page_rand;
+rec->a3 = (unsigned long) get_address();
 dm = (struct dm_ioctl *) rec->a3;
 
 /* set a sensible version to get past the initial checks */
",61,2
move scsi ioctl away from page_rand," static void scsi_sg_io_sanitise(struct syscallrecord *rec)
 {
 struct sgio *sgio;
 
-sgio = (struct sgio *) page_rand;// FIXME: Do we always want to use page_rand ?
+sgio = (struct sgio *) get_address();
 
 sgio->cmd[0] = 0x12;
 sgio->cmd[3] = 0x2;
 static void scsi_sg_io_sanitise(struct syscallrecord *rec)
 sgio->ioh.usr_ptr = NULL;
 sgio->ioh.flags |= SG_FLAG_DIRECT_IO;
 
-rec->a3 = (unsigned long) page_rand;
+rec->a3 = (unsigned long) get_address();
 }
 
 static void scsi_sanitise(const struct ioctl_group *grp, struct syscallrecord *rec)
",114,10
convert execve to use generate_rand_bytes,"
 #include <stdio.h>
 #include <stdlib.h>
 #include ""arch.h""// page_size
-#include ""random.h""// generate_random_page
+#include ""random.h""// generate_rand_bytes
 #include ""sanitise.h""
 #include ""shm.h""
 #include ""syscall.h""
 static unsigned long ** gen_ptrs_to_crap(void)
 
 for (i = 0; i < count; i++) {
 ptr[i] = zmalloc(page_size);// FIXME: LEAK
-generate_random_page((char *) ptr[i]);
+generate_rand_bytes((unsigned char *) ptr[i], rand() % page_size);
 }
 
 return (unsigned long **) ptr;
",49,3
"Removal of page_rand and all supporting code.

We now only use mappings for random pages.
There needs to be more work done to periodically dirty mappings,
as we only do that on mmap/mremap right now.","
 #include <stdio.h>
 #include ""arch.h""//PAGE_MASK
 #include ""log.h""
-#include ""maps.h""// page_rand
 #include ""params.h""// logging, monochrome, quiet_level
 #include ""pids.h""
 #include ""shm.h""
 static char * decode_argtype(char *sptr, unsigned long reg, enum argtype type)
 break;
 }
 
-if ((reg & PAGE_MASK) == (unsigned long) page_rand)
-sptr += sprintf(sptr, ""[page_rand]"");
-
 return sptr;
 }
 
",170,44
periodic dirtying of mmaps.," void init_child(struct childdata *child, int childno)
 child->mappings = zmalloc(sizeof(struct map));
 INIT_LIST_HEAD(&child->mappings->list);
 
+dirty_random_mapping();
+
 if (sched_getaffinity(pid, sizeof(set), &set) == 0) {
 CPU_ZERO(&set);
 CPU_SET(childno, &set);
 static void periodic_work(void)
 if (!(periodic_counter % 10))
 check_parent_pid();
 
-if (periodic_counter == 100)
+/* Every 100 iterations. */
+if (!(periodic_counter % 100))
+dirty_random_mapping();
+
+if (periodic_counter == 1000)
 periodic_counter = 0;
 }
 
",250,50
get_map is no longer called from main process.," struct map * get_map(void)
 struct map *map;
 bool local = FALSE;
 
-/* If we're not running in child context, just do shared mappings.
- * because main doesn't have any 'local' mappings.
- * FIXME: do we still need this? Are we still calling this from main
- * since the removal of page_rand ?
- */
-if (this_child != NULL) {
-if (this_child->num_mappings > 0)
-local = rand_bool();
-}
+/* If a child hasn't done any mmaps yet, we won't have any local maps. */
+if (this_child->num_mappings > 0)
+local = rand_bool();
 
 if (local == TRUE)
 map = __get_map(&this_child->mappings->list, this_child->num_mappings);
",63,10
move delete_local_mapping into delete_mapping," struct map * get_map(void)
 return map;
 }
 
-static void delete_local_mapping(struct map *map)
-{
-list_del(&map->list);
-this_child->num_mappings--;
-}
-
 /* Called from munmap()'s ->post routine. */
 void delete_mapping(struct map *map)
 {
-if (map->type == TRINITY_MAP_LOCAL)
-delete_local_mapping(map);
-
-/* Right now, we don't want to delete TRINITY_MAP_GLOBAL mappings */
+if (map->type == TRINITY_MAP_LOCAL) {
+list_del(&map->list);
+this_child->num_mappings--;
+}
 }
 
 /* used in several sanitise_* functions. */
",60,9
"introduce init_child_mappings

Make a copy of the global mappings on starting a new child.
Any manipulations that happens on those mappings will happen to
the copied map structs.

This has the nice side-effect of simplifying get_map() as it now
only has to ever iterate the one list."," void init_child(struct childdata *child, int childno)
 
 set_seed(this_child);
 
-child->mappings = zmalloc(sizeof(struct map));
-INIT_LIST_HEAD(&child->mappings->list);
+init_child_mappings(child);
 
 dirty_random_mapping();
 
",249,50
remove bogus includes that crept in while debugging," struct map * get_map(void)
 map = __get_map(&this_child->mappings->list, this_child->num_mappings);
 return map;
 }
- #include <sys/types.h>
- #include <unistd.h>
-
 
 /*
 * Set up a childs local mapping list.
",71,7
fold __get_map() into get_map(),"
 #include ""shm.h""
 #include ""utils.h""
 
-/* Walk a list, get a random element */
-static struct map * __get_map(struct list_head *head, unsigned int max)
+/*
+ * Return a pointer a previous mmap() that we did, either during startup,
+ * or from a fuzz result.
+ */
+struct map * get_map(void)
 {
 struct list_head *node;
 
 unsigned int i, j = 0;
 
-i = rand() % max;
+i = rand() % this_child->num_mappings;
 
-list_for_each(node, head) {
+list_for_each(node, &this_child->mappings->list) {
 struct map *m;
 
 m = (struct map *) node;
 static struct map * __get_map(struct list_head *head, unsigned int max)
 return NULL;
 }
 
-/* Return a pointer a previous mmap() that we did, either during startup,
- * or from a fuzz result. */
-struct map * get_map(void)
-{
-struct map *map;
-
-map = __get_map(&this_child->mappings->list, this_child->num_mappings);
-return map;
-}
-
 /*
 * Set up a childs local mapping list.
 * A child inherits the global mappings, and will add to them
",65,6
rename 'shared mappings' to 'initial mappings'," void init_child_mappings(struct childdata *child)
  * Note we're only copying pointers here, the actual mmaps
  * will be faulted into the child when they get accessed.
  */
-list_for_each(node, &shared_mappings->list) {
+list_for_each(node, &initial_mappings->list) {
 struct map *m, *new;
 
 m = (struct map *) node;
",65,6
fix up some comments missed in the global->initial renaming," struct map * get_map(void)
 
 /*
 * Set up a childs local mapping list.
- * A child inherits the global mappings, and will add to them
+ * A child inherits the initial mappings, and will add to them
 * when it successfully completes mmap() calls.
 */
 void init_child_mappings(struct childdata *child)
 void init_child_mappings(struct childdata *child)
 child->mappings = zmalloc(sizeof(struct map));
 INIT_LIST_HEAD(&child->mappings->list);
 
-/* Copy the global mapping list to the child.
+/* Copy the initial mapping list to the child.
  * Note we're only copying pointers here, the actual mmaps
  * will be faulted into the child when they get accessed.
  */
",65,6
rename TRINITY_MAP_GLOBAL -> TRINITY_MAP_INITIAL," static void alloc_zero_map(unsigned long size, int prot, const char *name)
 newnode->name = strdup(name);
 newnode->size = size;
 newnode->prot = prot;
-newnode->type = TRINITY_MAP_GLOBAL;
+newnode->type = TRINITY_MAP_INITIAL;
 newnode->ptr = mmap(NULL, size, prot, MAP_ANONYMOUS | MAP_SHARED, fd, 0);
 if (newnode->ptr == MAP_FAILED) {
 outputerr(""mmap failure\n"");
",83,7
"When we copy the initial map list, leave the ->type as MAP_INITIAL"," void init_child_mappings(struct childdata *child)
 new->name = strdup(m->name);
 new->size = m->size;
 new->prot = m->prot;
-new->type = TRINITY_MAP_LOCAL;
+/* We leave type as 'INITIAL' until we change the mapping
+ * by mprotect/mremap/munmap etc..
+ */
+new->type = TRINITY_MAP_INITIAL;
 
 list_add_tail(&new->list, &this_child->mappings->list);
 this_child->num_mappings++;
",65,6
rename TRINITY_MAP_LOCAL -> TRINITY_MAP_CHILD," static void post_mmap(struct syscallrecord *rec)
 new->prot = rec->a3;
 //TODO: store fd if !anon
 new->ptr = p;
-new->type = TRINITY_MAP_LOCAL;
+new->type = TRINITY_MAP_CHILD;
 
 // Add this to a list for use by subsequent syscalls.
 list = &this_child->mappings->list;
",148,15
fold the remnants of maps-fault back into maps.c," struct map * common_set_mmap_ptr_len(void)
 
 return map;
 }
+
+/*
+ * Routine to perform various kinds of write operations to a mapping
+ * that we created.
+ */
+void dirty_mapping(struct map *map)
+{
+bool rw = rand_bool();
+
+if (rw == TRUE) {
+/* Check mapping is writable, or we'll segv.
+ * TODO: Perhaps we should do that, and trap it, mark it writable,
+ * then reprotect after we dirtied it ? */
+if (!(map->prot & PROT_WRITE))
+return;
+
+random_map_writefn(map);
+return;
+
+} else {
+if (!(map->prot & PROT_READ))
+return;
+
+random_map_readfn(map);
+}
+}
+
+void dirty_random_mapping(void)
+{
+struct map *map;
+
+map = get_map();
+dirty_mapping(map);
+}
",85,11
add header comment for dirty_random_mapping()," void dirty_mapping(struct map *map)
 }
 }
 
+/*
+ * Pick a random mapping, and perform some r/w op on it.
+ * Called from child on child init, and also periodically
+ * from periodic_work()
+ */
 void dirty_random_mapping(void)
 {
 struct map *map;
",85,11
header comment for maps-initial,"
+/*
+ * These routines create initial mmaps in the main process that every
+ * child process will end up inheriting.
+ *
+ * Children will copy the whole initial_mappings list to their own
+ * private copies, and then perform operations upon them.
+ */
 #include <fcntl.h>
 #include <stdio.h>
 #include <stdlib.h>
",83,7
"partial revert some of the get_map() cleanups.

Turns out we _do_ do get_map from main pid context.
As the comment describes, the setsockopt code uses it when
we do socket creation on startup.","
 */
 struct map * get_map(void)
 {
-struct list_head *node;
+struct list_head *node, *list;
+unsigned int num;
 
 unsigned int i, j = 0;
 
-i = rand() % this_child->num_mappings;
+/* FIXME: We still call this from one place in the main process.
+ * The code that creates sockets calls into do_setsockopt which
+ * wants a writable mapping.
+ * We used to cheat around this and just pass page_rand, but now
+ * we have to pass something realistic.
+ *
+ * It's unfortunate, because get_map was a lot simpler with just one list.
+ * I'll think up some better solution for this later.
+ */
+if (this_child == NULL) {
+list = &initial_mappings->list;
+num = num_initial_mappings;
+} else {
+list = &this_child->mappings->list;
+num = this_child->num_mappings;
+}
+
+i = rand() % num;
 
-list_for_each(node, &this_child->mappings->list) {
+list_for_each(node, list) {
 struct map *m;
 
 m = (struct map *) node;
",93,12
"make setsockopt use zmalloc/free rather than get_writable_page

This removes one case where get_map() needs to care about non-child mappings."," static void sso_socket(struct socket_triplet *triplet, struct sockopt *so, int f
 if (triplet->family == PF_BLUETOOTH)
 return;
 
+so->optval = 0;
+
 retry:
+if (so->optval != 0)
+free((void *) so->optval);
+
 do_setsockopt(so);
 
 ret = setsockopt(fd, so->level, so->optname, (void *)so->optval, so->optlen);
 retry:
 triplet->family, triplet->type, triplet->protocol);
 } else {
 tries++;
-if (tries == 100)
-return;
-
-goto retry;
+if (tries != 100)
+goto retry;
 }
+
+if (so->optval != 0)
+free((void *) so->optval);
 }
 
 static int open_socket(unsigned int domain, unsigned int type, unsigned int protocol)
",300,69
"make perf_event_open allocate perf_event_attr struct with zmalloc

and free in ->post"," void sanitise_perf_event_open(struct syscallrecord *rec)
 int group_leader=0;
 void *addr;
 
-addr = get_writable_address(sizeof(struct perf_event_attr));
+addr = zmalloc(sizeof(struct perf_event_attr));
 rec->a1 = (unsigned long) addr;
 attr = (struct perf_event_attr *) addr;
 
-/* this makes sure we clear out the reserved fields. */
-memset(addr, 0, sizeof(struct perf_event_attr));
-
 /* cpu */
 /* requires ROOT to select specific CPU if pid==-1 (all processes) */
 /* -1 means all CPUs */
 void sanitise_perf_event_open(struct syscallrecord *rec)
 }
 }
 
+static void post_perf_event_open(struct syscallrecord *rec)
+{
+free((void *) rec->a1);
+}
+
 struct syscallentry syscall_perf_event_open = {
 .name = ""perf_event_open"",
 .num_args = 5,
 struct syscallentry syscall_perf_event_open = {
 },
 },
 .sanitise = sanitise_perf_event_open,
+.post = post_perf_event_open,
 .init = init_pmus,
 .flags = NEED_ALARM | IGNORE_ENOSYS,
 };
",1049,254
"after setting mapping to MAP_RW, update its prot in the map struct."," retry:
 
 addr = map->ptr;
 mprotect(addr, map->size, PROT_READ | PROT_WRITE);
+map->prot = PROT_READ | PROT_WRITE;
 
 return addr;
 }
",100,26
"update the get_map() FIXME

it's not really a big deal to have to care about initial_mappings
before we have child processes running. It's still a lot better
than when we had page_rand"," struct map * get_map(void)
 
 unsigned int i, j = 0;
 
-/* FIXME: We still call this from one place in the main process.
- * The code that creates sockets calls into do_setsockopt which
- * wants a writable mapping.
- * We used to cheat around this and just pass page_rand, but now
- * we have to pass something realistic.
- *
- * It's unfortunate, because get_map was a lot simpler with just one list.
- * I'll think up some better solution for this later.
+/*
+ * Some of the fd providers need weird mappings on startup.
+ * (fd-perf for eg), these are called from the main process,
+ * and hence don't have a valid this_child, so we address the
+ * initial mappings list directly.
  */
 if (this_child == NULL) {
 list = &initial_mappings->list;
",93,12
factor out the random fcntl SETFL flag generator,"
 #include ""random.h""
 #include ""sanitise.h""
 #include ""shm.h""
+#include ""syscalls.h""
 #include ""syscall.h""
 #include ""trinity.h""
 #include ""compat.h""

 #define HAVE_LK64
 #endif
 
+unsigned int random_fcntl_setfl_flags(void)
+{
+unsigned int val = 0;
+
+if (rand_bool())
+val |= O_APPEND;
+if (rand_bool())
+val |= O_ASYNC;
+if (rand_bool())
+val |= O_DIRECT;
+if (rand_bool())
+val |= O_NOATIME;
+if (rand_bool())
+val |= O_NONBLOCK;
+
+return val;
+}
+
 static void sanitise_fcntl(struct syscallrecord *rec)
 {
 switch (rec->a2) {
 static void sanitise_fcntl(struct syscallrecord *rec)
 break;
 
 case F_SETFL:
-rec->a3 = 0L;
-if (rand_bool())
-rec->a3 |= O_APPEND;
-if (rand_bool())
-rec->a3 |= O_ASYNC;
-if (rand_bool())
-rec->a3 |= O_DIRECT;
-if (rand_bool())
-rec->a3 |= O_NOATIME;
-if (rand_bool())
-rec->a3 |= O_NONBLOCK;
+rec->a3 = (unsigned long) random_fcntl_setfl_flags();
 break;
 
 /* arg = (struct flock *) */
",112,39
use random fcntl flags if we open testfile fds with fopen,"
 
 #include ""fd.h""
 #include ""files.h""
-#include ""shm.h""
 #include ""log.h""
 #include ""random.h""
 #include ""sanitise.h""
+#include ""shm.h""
+#include ""syscalls/syscalls.h""
 #include ""testfile.h""
 
 static int open_testfile(char *filename)
 static int open_testfile(char *filename)
 fd = open_with_fopen(filename, O_RDWR);
 if (fd != -1)
 output(2, ""fd[%d] = fopen(\""%s\"", O_RDWR)\n"", fd, filename);
+fcntl(fd, F_SETFL, random_fcntl_setfl_flags());
 } else {
 fd = open(filename, O_CREAT | flags, 0666);
 if (fd != -1)
",74,12
make generate_rand_bytes sometimes generate printable ascii,"
 #include ""types.h""
 #include ""utils.h""
 
+static unsigned char rand_ascii(void)
+{
+unsigned char c;
+
+c = 32 + rand() % (0x7f - 32);
+
+return c;
+}
+
 void generate_rand_bytes(unsigned char *ptr, unsigned int len)
 {
 unsigned int i;
 
 for (i = 0; i < len; i++) {
-ptr[i] = rand();
+if (rand_bool()) {
+/* Complete garbage. */
+ptr[i] = rand();
+} else {
+/* printable text strings. */
+ptr[i] = rand_ascii();
+}
 }
 }
 
",196,61
don't do the coin-toss on every loop iteration," static unsigned char rand_ascii(void)
 void generate_rand_bytes(unsigned char *ptr, unsigned int len)
 {
 unsigned int i;
+bool choice = rand_bool();
 
 for (i = 0; i < len; i++) {
-if (rand_bool()) {
+if (choice) {
 /* Complete garbage. */
 ptr[i] = rand();
 } else {
",197,61
make generate_rand_bytes sometimes generate just strings of numbers," static unsigned char rand_ascii(void)
 return c;
 }
 
+static unsigned char rand_ascii_nums(void)
+{
+unsigned char c;
+
+c = '0' + rand() % 10;
+
+return c;
+}
+
 void generate_rand_bytes(unsigned char *ptr, unsigned int len)
 {
 unsigned int i;
-bool choice = rand_bool();
+unsigned char choice = rand() % 3;
 
 for (i = 0; i < len; i++) {
-if (choice) {
+switch (choice) {
+case 0:
 /* Complete garbage. */
 ptr[i] = rand();
-} else {
+break;
+case 1:
 /* printable text strings. */
 ptr[i] = rand_ascii();
+break;
+case 2:
+/* numbers */
+ptr[i] = rand_ascii_nums();
+break;
 }
 }
 }
",209,64
the new rand string code doesn't need to be in one-line functions.,"
 #include ""types.h""
 #include ""utils.h""
 
-static unsigned char rand_ascii(void)
-{
-unsigned char c;
-
-c = 32 + rand() % (0x7f - 32);
-
-return c;
-}
-
-static unsigned char rand_ascii_nums(void)
-{
-unsigned char c;
-
-c = '0' + rand() % 10;
-
-return c;
-}
-
 void generate_rand_bytes(unsigned char *ptr, unsigned int len)
 {
 unsigned int i;
 void generate_rand_bytes(unsigned char *ptr, unsigned int len)
 break;
 case 1:
 /* printable text strings. */
-ptr[i] = rand_ascii();
+ptr[i] = 32 + rand() % (0x7f - 32);
 break;
 case 2:
 /* numbers */
-ptr[i] = rand_ascii_nums();
+ptr[i] = '0' + rand() % 10;
 break;
 }
 }
",197,62
make random_fcntl_setfl_flags use set_rand_bitmask,"
 #include ""syscalls.h""
 #include ""syscall.h""
 #include ""trinity.h""
+#include ""utils.h""
 #include ""compat.h""
 
 #if F_GETLK64 != F_GETLK
 #define HAVE_LK64
 #endif
 
+static const unsigned long fcntl_o_flags[] = {
+O_APPEND, O_ASYNC, O_DIRECT, O_NOATIME, O_NONBLOCK,
+};
+
 unsigned int random_fcntl_setfl_flags(void)
 {
-unsigned int val = 0;
-
-if (rand_bool())
-val |= O_APPEND;
-if (rand_bool())
-val |= O_ASYNC;
-if (rand_bool())
-val |= O_DIRECT;
-if (rand_bool())
-val |= O_NOATIME;
-if (rand_bool())
-val |= O_NONBLOCK;
-
-return val;
+return set_rand_bitmask(ARRAY_SIZE(fcntl_o_flags), fcntl_o_flags);
 }
 
 static void sanitise_fcntl(struct syscallrecord *rec)
",105,34
make open_testfile's open flag chooser use set_rand_bitmask,"
 #include ""shm.h""
 #include ""syscalls/syscalls.h""
 #include ""testfile.h""
+#include ""utils.h""
 
 static int open_testfile(char *filename)
 {
 static int open_testfile(char *filename)
 output(2, ""fd[%d] = fopen(\""%s\"", O_RDWR)\n"", fd, filename);
 fcntl(fd, F_SETFL, random_fcntl_setfl_flags());
 } else {
+const unsigned long open_flags[] = { O_DIRECT, O_DSYNC, O_SYNC, };
 int flags = 0;
 
-if (rand_bool())
-flags |= O_DIRECT;
-
-if (rand_bool())
-flags |= O_DSYNC;
-
-if (rand_bool())
-flags |= O_SYNC;
+flags = set_rand_bitmask(ARRAY_SIZE(open_flags), open_flags);;
 
 fd = open(filename, O_CREAT | flags, 0666);
 if (fd != -1)
",71,9
move set_rand_bitmask to random.c," void kill_pid(pid_t pid);
 #define __stringify(x...) __stringify_1(x)
 
 #define unreachable() do { } while (1)
-
-unsigned long set_rand_bitmask(unsigned int num, const unsigned long *values);
",12,1
fix off-by-one in testfile generator," static int open_testfile_fds(void)
 
 filename = zmalloc(64);
 
-while (i < MAX_TESTFILE_FDS) {
+while (i <= MAX_TESTFILE_FDS) {
 int fd;
 
 sprintf(filename, ""trinity-testfile%d"", i);
",71,9
dm_sanitise needs a writable address," static void dm_sanitise(const struct ioctl_group *grp, struct syscallrecord *rec
 
 pick_random_ioctl(grp, rec);
 
-rec->a3 = (unsigned long) get_address();
+rec->a3 = (unsigned long) get_writable_address(sizeof(struct dm_ioctl));
 dm = (struct dm_ioctl *) rec->a3;
 
 /* set a sensible version to get past the initial checks */
",61,2
"remove double include in generate-args.c

Spotted by Harrison <hbowden@securelabsllc.com>","
 #include ""maps.h""
 #include ""net.h""
 #include ""random.h""
-#include ""random.h""
 #include ""sanitise.h""
 #include ""shm.h""
 #include ""syscall.h""
",340,113
update email address.," int main(int argc, char* argv[])
 pid_t pid;
 const char taskname[13]=""trinity-main"";
 
-outputstd(""Trinity "" VERSION "" Dave Jones <davej@redhat.com>\n"");
+outputstd(""Trinity "" VERSION "" Dave Jones <davej@codemonkey.org.uk>\n"");
 
 progname = argv[0];
 
",122,17
add new SO_INCOMING_CPU socket option," static const unsigned int socket_opts[] = { SO_DEBUG, SO_REUSEADDR, SO_TYPE, SO_
 SO_PASSSEC, SO_TIMESTAMPNS, SO_MARK, SO_TIMESTAMPING,
 SO_PROTOCOL, SO_DOMAIN, SO_RXQ_OVFL, SO_WIFI_STATUS,
 SO_PEEK_OFF, SO_NOFCS, SO_LOCK_FILTER, SO_SELECT_ERR_QUEUE,
-SO_BUSY_POLL, SO_MAX_PACING_RATE, SO_BPF_EXTENSIONS };
+SO_BUSY_POLL, SO_MAX_PACING_RATE, SO_BPF_EXTENSIONS, SO_INCOMING_CPU };
 
 void socket_setsockopt(struct sockopt *so)
 {
",42,5
alphabetical order for params.," void parse_args(int argc, char *argv[])
 outputstd(""opt:%c\n"", opt);
 return;
 
-case 'b':
-init_bdev_list();
-process_bdev_param(optarg);
-dump_bdev_list();
-outputstd(""--bdev doesn't do anything useful yet.\n"");
-exit(EXIT_SUCCESS);
-
-case 'c':
-/* syscalls are all disabled at this point. enable the syscall we care about. */
-do_specific_syscall = TRUE;
-toggle_syscall(optarg, TRUE);
-break;
-
 case 'a':
 /* One of the architectures selected*/
 do_32_arch = FALSE;
 void parse_args(int argc, char *argv[])
 }
 break;
 
+case 'b':
+init_bdev_list();
+process_bdev_param(optarg);
+dump_bdev_list();
+outputstd(""--bdev doesn't do anything useful yet.\n"");
+exit(EXIT_SUCCESS);
+
+case 'c':
+/* syscalls are all disabled at this point. enable the syscall we care about. */
+do_specific_syscall = TRUE;
+toggle_syscall(optarg, TRUE);
+break;
+
 case 'C':
 user_specified_children = strtoll(optarg, NULL, 10);
 max_children = user_specified_children;
",268,45
bare-bones fuzzer for send(),"
 #include ""utils.h""
 #include ""compat.h""
 
+static void sanitise_send(struct syscallrecord *rec)
+{
+void *ptr;
+
+ptr = malloc(page_size);
+if (ptr == NULL)
+return;
+rec->a2 = (unsigned long) ptr;
+
+if (rand_bool())
+rec->a3 = 1;
+else
+rec->a3 = rand() % page_size;
+
+// TODO: only use this as a fallback, and actually have
+// some per-proto generators here.
+generate_rand_bytes(ptr, rec->a3);
+}
+
+static void post_send(struct syscallrecord *rec)
+{
+void *ptr = (void *) rec->a2;
+
+if (ptr != NULL)
+free(ptr);
+rec->a2 = 0L;
+}
+
 struct syscallentry syscall_send = {
 .name = ""send"",
 .num_args = 4,
 .arg1name = ""fd"",
 .arg1type = ARG_FD,
 .arg2name = ""buff"",
-.arg2type = ARG_ADDRESS,
 .arg3name = ""len"",
-.arg3type = ARG_LEN,
 .arg4name = ""flags"",
 .arg4type = ARG_LIST,
 .arg4list = {
 struct syscallentry syscall_send = {
  MSG_WAITFORONE, MSG_FASTOPEN, MSG_CMSG_CLOEXEC, MSG_CMSG_COMPAT,
 },
 },
+.sanitise = sanitise_send,
+.post = post_send,
 };
 
 
",141,8
helper function to zero out pointers after freeing.," void sizeunit(unsigned long size, char *buf);
 
 void kill_pid(pid_t pid);
 
+void freeptr(unsigned long *p);
+
 #define __stringify_1(x...) #x
 #define __stringify(x...) __stringify_1(x)
 
",13,1
don't allocate a whole page in send_sanitise if we need less.,"
 
 static void sanitise_send(struct syscallrecord *rec)
 {
+unsigned int size;
 void *ptr;
 
-ptr = malloc(page_size);
+if (rand_bool())
+size = 1;
+else
+size = rand() % page_size;
+
+ptr = malloc(size);
 if (ptr == NULL)
 return;
-rec->a2 = (unsigned long) ptr;
 
-if (rand_bool())
-rec->a3 = 1;
-else
-rec->a3 = rand() % page_size;
+rec->a2 = (unsigned long) ptr;
+rec->a3 = size;
 
 // TODO: only use this as a fallback, and actually have
 // some per-proto generators here.
-generate_rand_bytes(ptr, rec->a3);
+generate_rand_bytes(ptr, size);
 }
 
 static void post_send(struct syscallrecord *rec)
",141,7
sendto can use the same sanitise/post as send," struct syscallentry syscall_sendto = {
 .arg6name = ""addr_len"",
 .arg6type = ARG_SOCKADDRLEN,
 .flags = NEED_ALARM,
+.sanitise = sanitise_send,
+.post = post_send,
 };
 
 /*
",143,7
generate random data into the buffer for write()," static void sanitise_write(struct syscallrecord *rec)
 if (ptr == NULL)
 return;
 
+generate_rand_bytes(ptr, size);
+
 rec->a2 = (unsigned long) ptr;
 rec->a3 = size;
 }
",88,6
"freeptr missed an indirection, and was freeing the ptr to the ptr instead."," void kill_pid(pid_t pid)
 
 void freeptr(unsigned long *p)
 {
-void *ptr = (void *) p;
+void *ptr = (void *) *p;
 
 if (ptr != NULL)
 free(ptr);
",73,15
"update perf_event_open() for Linux 3.19

This updates the perf_event_open support to match changes made with the
upcoming 3.19 release.

Signed-off-by: Vince Weaver <vincent.weaver@maine.edu>"," static long long random_sample_type(void)
 sample_type |= PERF_SAMPLE_IDENTIFIER;
 if (rand_bool())
 sample_type |= PERF_SAMPLE_TRANSACTION;
+if (rand_bool())
+sample_type |= PERF_SAMPLE_REGS_INTR;
 
 return sample_type;
 }
 static int random_attr_size(void) {
 
 int size=0;
 
-switch(rand() % 8) {
+switch(rand() % 9) {
 case 0:size = PERF_ATTR_SIZE_VER0;
 break;
 case 1: size = PERF_ATTR_SIZE_VER1;
 static int random_attr_size(void) {
 break;
 case 3: size = PERF_ATTR_SIZE_VER3;
 break;
-case 4: size = sizeof(struct perf_event_attr);
+case 4: size = PERF_ATTR_SIZE_VER4;
+break;
+case 5: size = sizeof(struct perf_event_attr);
 break;
-case 5: size = rand32();
+case 6: size = rand32();
 break;
-case 6:size = get_len();
+case 7:size = get_len();
 break;
-case 7: size = 0;
+case 8: size = 0;
 break;
 default:
 break;
",1053,256
Remove value modification decision from plus_minus_two(),"
 static unsigned int plus_minus_two(unsigned int num)
 {
 /* Now munge it for off-by-ones. */
-switch (rand() % 5) {
+switch (rand() % 4) {
 case 0:num -= 2;
 break;
 case 1:num -= 1;
 break;
-case 2:return num;
-case 3:num += 1;
+case 2:num += 1;
 break;
-case 4:num += 2;
+case 3:num += 2;
 break;
 }
 return num;
",129,56
"Simplified get_interesting_8bit_value()

2^n case will now cover up to 128 where previously it only went to 64.
Removed -128, 127, -1 cases, they will be covered by the 2^n and 0xff
cases with plus_minus_two() call."," static unsigned int plus_minus_two(unsigned int num)
 return num;
 }
 
-static char get_interesting_8bit_value(void)
+static unsigned char get_interesting_8bit_value(void)
 {
-char num = 0;
-
-switch (rand() % 7) {
-case 0:num = -128;
-break;
-case 1:num = -1;
-break;
-case 2:num = 0;
-break;
-case 3:num = 1;
-break;
-case 4:num = 1UL << (rand() % 7);
-break;
-case 5:num = 127;
-break;
-case 6:num = rand() % 256;// 00-0xff
-break;
+switch (rand() % 5) {
+case 0: return 1;// one
+case 1: return 0xff;// max
+case 2: return 1UL << (rand() & 7);// 2^n (1 -> 128)
+case 3: return rand() & 0xff;// 0 -> 0xff
+default: return 0;// zero
 }
-
-return num;
 }
 
 static int get_interesting_16bit_value(void)
 unsigned int get_interesting_32bit_value(void)
 break;
 }
 
-num = plus_minus_two(num);
+num = rand() & 0xf ? num : plus_minus_two(num);// 1 in 16 call plus_minus_two
+
 return num;
 }
 
",118,54
"Make get_interesting_32bit_value() static

All calls to get_interesting_32bit_value() should now be made to
get_interesting_value() to help simplify generating interesting values."," static int get_interesting_16bit_value(void)
 return num;
 }
 
-unsigned int get_interesting_32bit_value(void)
+static unsigned int get_interesting_32bit_value(void)
 {
 unsigned int num = 0;
 
",117,53
"Simplify get_interesting_16bit_value()

Removed values that overlap with get_interesting_8bit_value() and others
that are covered by the 2^n case and 2^n with plus_minus_two()."," static unsigned char get_interesting_8bit_value(void)
 }
 }
 
-static int get_interesting_16bit_value(void)
+static unsigned short get_interesting_16bit_value(void)
 {
-int num = 0;
-
-switch (rand() % 7) {
-case 0:num = 0;
-break;
-case 1:num = -32768;
-break;
-case 2:num = -129;
-break;
-case 3:num = 255;
-break;
-case 4:num = 32767;
-break;
-case 5:num = 1UL << (rand() % 15);
-break;
-case 6:num = rand() % 0xffff;
-break;
+switch (rand() % 4) {
+case 0: return 0x8000 >> (rand() & 7);// 2^n (0x100 -> 0x8000)
+case 1: return rand() & 0xffff;// 0 -> 0xffff
+case 2: return 0xff00 | (rand() & 0xff);// 0xff00 -> 0xffff
+default: return 0xffff;// max
 }
-
-return num;
 }
 
 static unsigned int get_interesting_32bit_value(void)
",105,49
"Created ONE_IN(x) macro

It takes a positive value and it can be used to express how often a branch
should randomly be taken. Made substitutions where possible."," static bool choose_syscall_table(void)
 /* If both tables enabled, pick randomly. */
 if ((use_64bit == TRUE) && (use_32bit == TRUE)) {
 /* 10% possibility of a 32bit syscall */
-if (rand() % 100 < 10)
+if (ONE_IN(10))
 do32 = TRUE;
 }
 
",92,17
"Created RAND_32 and RAND_64 macros.

These macros will generate a random number between 0 and 2^32 - 1 or
2^64 - 1 respectively. There is also a compile time check to verify
that a full 2^n bits of randomness will be generated (depends on RAND_MAX)."," static unsigned int __rand32(void)
 break;
 case 1:r = randbits(32);
 break;
-case 2: r = rand();
+case 2: r = RAND_32();
 break;
 case 3:r = rand8x8();
 break;
 u64 rand64(void)
 break;
 case 1:r = randbits(64);
 break;
-case 2:r = rand32() | rand32() << 31;
+case 2:r = RAND_64();
 break;
 case 3:r = rand8x8();
 break;
",178,52
"Remove static from rand_single_bit()

Added a check to verify input value is between 0 and 32 or 64 bits
depending on __WORDSIZE."," unsigned int rand_bool(void)
 return rand() % 2;
 }
 
-static unsigned int rand_single_bit(unsigned char size)
+/*
+ * Pick a random power of two between 2^0 and 2^(__WORDSIZE-1)
+ */
+unsigned long rand_single_bit(unsigned char size)
 {
+if (size > __WORDSIZE)
+size = __WORDSIZE;
+
 return (1UL << (rand() % size));
 }
 
",168,49
"Make rand_bool a macro

Since rand_bool is used a heavily used operation simplifying it may
shave off some cycles here and there. Also replaced %2 with &1 with the
same intention."," unsigned long set_rand_bitmask(unsigned int num, const unsigned long *values)
 return mask;
 }
 
-unsigned int rand_bool(void)
-{
-return rand() % 2;
-}
-
 /*
 * Pick a random power of two between 2^0 and 2^(__WORDSIZE-1)
 */
",164,48
"Added RAND_BYTE() macro

This will prevent open coding rand() & ff to get a random byte and the
off-by-one's that accompany it (rand() % ff or rand() & 255). Made
substitutions where possible which led to fixing existing off-by-ones."," static void generate_random_page(char *page)
 return;
 
 case 2:
-memset(page, rand() % 0xff, page_size);
+memset(page, RAND_BYTE(), page_size);
 return;
 
 case 3:
",181,51
"Cleaned up rept8() and renamed to rept_byte()

This function basically generates 256 different values. These values do not
seem to have much significance and unless it has triggered results in the
past it should likely be removed."," static unsigned long randbits(int limit)
 /*
 * Pick 1 random byte, and repeat it through a long.
 */
-static unsigned long rept8(unsigned int num)
+static unsigned long rept_byte(void)
 {
-unsigned long r = 0UL;
-unsigned int i;
-unsigned char c;
-
-c = RAND_BYTE();
-for (i = rand() % (num - 1) ; i > 0; --i)
-r = (r << 8) | c;
+unsigned long r = RAND_BYTE();
 
+r = (r << 8) | r;
+r = (r << 16) | r;
+#if __WORDSIZE == 64
+r = (r << 32) | r;
+#endif
 return r;
 }
 
 static unsigned int __rand32(void)
 break;
 case 2: r = RAND_32();
 break;
-case 3:r = rept8(4);
+case 3:r = rept_byte();
 break;
 case 4:return get_interesting_value();
 }
 u64 rand64(void)
 break;
 case 2:r = RAND_64();
 break;
-case 3:r = rept8(8);
+case 3:r = rept_byte();
 break;
 /* Sometimes pick a not-so-random number. */
 case 4:return get_interesting_value();
",162,48
"Cleaned up rand32() and remove __rand32()

Removed the block at the beginning of rand32() that just basically |s and ^s
rand() with rand() or a more interesting number to basically get rand again.
This is just an expensive way of getting a random number. Merged the small
switch case from __rand32() in to rand32() now that there is room."," static unsigned long rept_byte(void)
 }
 
 /*
- * ""selector"" function for 32bit random.
- * only called from rand32()
+ * Generate, and munge a 32bit number.
 */
-static unsigned int __rand32(void)
+unsigned int rand32(void)
 {
 unsigned long r = 0;
 
 static unsigned int __rand32(void)
 case 4:return get_interesting_value();
 }
 
-return r;
-}
-
-/*
- * Generate, and munge a 32bit number.
- */
-unsigned int rand32(void)
-{
-unsigned long r = 0;
-
-r = __rand32();
-
-if (rand_bool()) {
-unsigned int i;
-unsigned int rounds;
-
-/* mangle it. */
-rounds = rand() % 3;
-for (i = 0; i < rounds; i++) {
-if (rand_bool())
-r |= __rand32();
-else
-r ^= __rand32();
-}
-}
-
 /* Sometimes deduct it from INT_MAX */
 if (rand_bool())
 r = INT_MAX - r;
",145,44
"Actually flip the sign of the value (1 -> -1)

I believe this is what was intended, previously the high bit was just being set.
Perhaps it was meant to be toggled? If that is the case we can add that too."," unsigned int rand32(void)
 
 /* Sometimes flip sign */
 if (rand_bool())
-r |= (1L << 31);
+r = ~r + 1;
 
 /* we might get lucky if something is counting ints/longs etc. */
 if (ONE_IN(4)) {
 u64 rand64(void)
 r |= (1UL << ((__WORDSIZE - 1) - (rand() % 8)));
 }
 
-/* randomly flip sign bit. */
+/* Sometimes flip sign */
 if (rand_bool())
-r |= (1UL << (__WORDSIZE - 1));
+r = ~r + 1;
 
 return r;
 }
",145,44
"Decrease the likelihood of performing mangling operations

These operations provide value however if they happen too often it prevents
the use of unmodified values that are generated that are more significant."," unsigned int rand32(void)
 }
 
 /* Sometimes deduct it from INT_MAX */
-if (rand_bool())
+if (ONE_IN(25))
 r = INT_MAX - r;
 
 /* Sometimes flip sign */
-if (rand_bool())
+if (ONE_IN(25))
 r = ~r + 1;
 
 /* we might get lucky if something is counting ints/longs etc. */
 u64 rand64(void)
 }
 
 /* Sometimes invert the generated number. */
-if (rand_bool())
+if (ONE_IN(25))
 r = ~r;
 
 /* increase distribution in MSB */
-if ((rand() % 10)) {
+if (ONE_IN(10)) {
 unsigned int i;
 unsigned int rounds;
 
 u64 rand64(void)
 }
 
 /* Sometimes flip sign */
-if (rand_bool())
+if (ONE_IN(25))
 r = ~r + 1;
 
 return r;
",145,44
Rename rand_bool() to RAND_BOOL() to match other macros," void init_child(struct childdata *child, int childno)
 
 set_make_it_fail();
 
-if (rand_bool())
+if (RAND_BOOL())
 use_fpu();
 
 mask_signals_child();
",249,50
"Make RAND_RANGE() a macro

Renamed to uppercase to match other macros. Removed swap call. This should
be done outside of the call."," static int open_socket(unsigned int domain, unsigned int type, unsigned int prot
 
 ret = bind(fd, sa, salen);
 if (ret != -1) {
-(void) listen(fd, rand_range(1, 128));
+(void) listen(fd, RAND_RANGE(1, 128));
 }
 }
 
",300,69
proto-rose: Fix overrun pointed out by coverity.," void rose_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 rose->srose_addr.rose_addr[3] = rand();
 rose->srose_addr.rose_addr[4] = rand();
 
-generate_rand_bytes((unsigned char *) rose->srose_call.ax25_call, 7 * 2);
+generate_rand_bytes((unsigned char *) rose->srose_call.ax25_call, sizeof(ax25_address));
 
 rose->srose_ndigis = rand();
 
",38,2
ignore return from fcntl when randomly setting flags.," static int open_testfile(char *filename)
 fd = open_with_fopen(filename, O_RDWR);
 if (fd != -1)
 output(2, ""fd[%d] = fopen(\""%s\"", O_RDWR)\n"", fd, filename);
-fcntl(fd, F_SETFL, random_fcntl_setfl_flags());
+(void) fcntl(fd, F_SETFL, random_fcntl_setfl_flags());
 } else {
 const unsigned long open_flags[] = { O_DIRECT, O_DSYNC, O_SYNC, };
 int flags = 0;
",71,9
clarify the intent of an extra case in the rand64() limiting switch," u64 rand64(void)
 break;
 case 2: r &= 0x00ffffffffffffffULL;
 break;
+default: /* no limiting. */
+break;
 }
 }
 
",141,42
ipv6: only generate v4 addresses where necessary,"
 
 static void gen_random_ipv6_address(struct in6_addr *v6)
 {
-in_addr_t v4 = random_ipv4_address();
+in_addr_t v4;
 
 switch (rand() % 9) {
 case 0:
 /* deprecated ipv4 style ::v4 */
+v4 = random_ipv4_address();
 v6->s6_addr32[0] = 0;
 v6->s6_addr32[1] = 0;
 v6->s6_addr32[2] = 0;
 static void gen_random_ipv6_address(struct in6_addr *v6)
 break;
 case 1:
 /* v4 in v6 ::ffff:0:0/96 */
+v4 = random_ipv4_address();
 v6->s6_addr32[0] = 0;
 v6->s6_addr32[1] = 0;
 v6->s6_addr32[2] = 0xffffffff;
 static void gen_random_ipv6_address(struct in6_addr *v6)
 case 4:
 /* 2002::/16 ""6to4"" */
 inet_pton(AF_INET6, ""2002::"", v6);
+v4 = random_ipv4_address();
 v6->s6_addr32[3] = htonl(v4);
 break;
 case 5:
",132,25
use inet_pton to simplify code," static void gen_random_ipv6_address(struct in6_addr *v6)
 break;
 case 2:
 /* ::1/128 loopback */
-v6->s6_addr32[0] = 0;
-v6->s6_addr32[1] = 0;
-v6->s6_addr32[2] = 0;
-v6->s6_addr32[3] = htonl(1);
+inet_pton(AF_INET6, ""::1"", v6);
 break;
 case 3:
 /* ::/128 unspecified */
-v6->s6_addr32[0] = 0;
-v6->s6_addr32[1] = 0;
-v6->s6_addr32[2] = 0;
-v6->s6_addr32[3] = 0;
+inet_pton(AF_INET6, ""::"", v6);
 break;
 case 4:
 /* 2002::/16 ""6to4"" */
",126,25
simplify v4-in-v6 using inet_pton," static void gen_random_ipv6_address(struct in6_addr *v6)
 break;
 case 1:
 /* v4 in v6 ::ffff:0:0/96 */
+inet_pton(AF_INET6, ""::ffff:0:0"", v6);
 v4 = random_ipv4_address();
-v6->s6_addr32[0] = 0;
-v6->s6_addr32[1] = 0;
-v6->s6_addr32[2] = 0xffffffff;
 v6->s6_addr32[3] = htonl(v4);
 break;
 case 2:
",124,25
ipv6: formatting cleanups," static void gen_random_ipv6_address(struct in6_addr *v6)
 { ""::ffff:0:0:0"" },/* stateless IP/ICMP translation (SIIT) ::ffff:0:0:0/96 */
 { ""2002::"" },/* 2002::/16 ""6to4"" */
 };
+
 p = v4_in_v6_addresses[rand() % ARRAY_SIZE(v4_in_v6_addresses)].name;
+inet_pton(AF_INET6, p, v6);
 
 v4 = random_ipv4_address();
-
-
-inet_pton(AF_INET6, p, v6);
 v6->s6_addr32[3] = htonl(v4);
 
 } else {
 static void gen_random_ipv6_address(struct in6_addr *v6)
 { ""64:ff9b::"" },/* 64:ff9b::/96 ""Well known"" prefix */
 { ""0100::"" },/* 0100::/64 remotely triggered blackhole */
 };
-p = v6_addresses[rand() % ARRAY_SIZE(v6_addresses)].name;
 
+p = v6_addresses[rand() % ARRAY_SIZE(v6_addresses)].name;
 inet_pton(AF_INET6, p, v6);
 }
 }
",114,17
split up the ipv4 random address generation,"
 static int previous_ip;
 static unsigned int ip_lifetime = 0;
 
-in_addr_t random_ipv4_address(void)
+static in_addr_t new_ipv4_addr(void)
 {
 int addr = 0;
 int class = 0;
 
-if (ip_lifetime != 0) {
-ip_lifetime--;
-return previous_ip;
-}
-
 switch (rand() % 9) {
 case 0:addr = 0;/* 0.0.0.0 */
 class = 8;
 in_addr_t random_ipv4_address(void)
 break;
 default: break;
 }
+return addr;
+}
+
+in_addr_t random_ipv4_address(void)
+{
+int addr;
+
+if (ip_lifetime != 0) {
+ip_lifetime--;
+return previous_ip;
+}
+
+addr = new_ipv4_addr();
 
 previous_ip = addr;
 ip_lifetime = 5;
",230,71
ipv4: avoid potential divide by 0 when using /32 masks," static in_addr_t new_ipv4_addr(void)
 
 inet_pton(AF_INET, p, &v4);
 
-v4 |= htonl(rand() % addresses[entry].classmask);
+if (addresses[entry].classmask != SLASH32)
+v4 |= htonl(rand() % addresses[entry].classmask);
 
 return v4;
 }
",208,59
"netlink: nl_pid is a port id, not a process id"," void netlink_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 nl = zmalloc(sizeof(struct sockaddr_nl));
 
 nl->nl_family = PF_NETLINK;
-nl->nl_pid = get_pid();
+nl->nl_pid = rand32();
 nl->nl_groups = rand32();
 *addr = (struct sockaddr *) nl;
 *addrlen = sizeof(struct sockaddr_nl);
",40,4
remove only-used-once define.," void inet6_rand_socket(struct socket_triplet *st)
 }
 }
 
-#define NR_SOL_INET6_OPTS ARRAY_SIZE(inet6_opts)
 static const unsigned int inet6_opts[] = {
 IPV6_ADDRFORM, IPV6_2292PKTINFO, IPV6_2292HOPOPTS, IPV6_2292DSTOPTS,
 IPV6_2292RTHDR, IPV6_2292PKTOPTIONS, IPV6_CHECKSUM, IPV6_2292HOPLIMIT,
 void inet6_setsockopt(struct sockopt *so)
 
 so->level = SOL_IPV6;
 
-val = rand() % NR_SOL_INET6_OPTS;
+val = rand() % ARRAY_SIZE(inet6_opts);
 so->optname = inet6_opts[val];
 }
 #endif
",126,17
remove another pair of pointless macros," void inet_rand_socket(struct socket_triplet *st)
 IPPROTO_MTP, IPPROTO_BEETPH, IPPROTO_ENCAP, IPPROTO_PIM,
 IPPROTO_COMP, IPPROTO_SCTP, IPPROTO_UDPLITE, IPPROTO_RAW,
 };
-#define NR_IPPROTOS ARRAY_SIZE(ipprotos)
 unsigned char val;
 
-val = rand() % NR_IPPROTOS;
+val = rand() % ARRAY_SIZE(ipprotos);
 st->protocol = ipprotos[val];
 
 //TODO: Match the type to the proto instead of being rand
 void inet_rand_socket(struct socket_triplet *st)
 }
 
 //TODO: Pair the sizeof's of the associated arrays
-#define NR_SOL_IP_OPTS ARRAY_SIZE(ip_opts)
 static const unsigned int ip_opts[] = { IP_TOS, IP_TTL, IP_HDRINCL, IP_OPTIONS,
 IP_ROUTER_ALERT, IP_RECVOPTS, IP_RETOPTS, IP_PKTINFO,
 IP_PKTOPTIONS, IP_MTU_DISCOVER, IP_RECVERR, IP_RECVTTL,
 void ip_setsockopt(struct sockopt *so)
 
 so->level = SOL_IP;
 
-val = rand() % NR_SOL_IP_OPTS;
+val = rand() % ARRAY_SIZE(ip_opts);
 so->optname = ip_opts[val];
 
 switch (ip_opts[val]) {
",208,59
mips: add new prctl's," static int prctl_opts[] = {
 PR_SET_MM, PR_SET_CHILD_SUBREAPER, PR_GET_CHILD_SUBREAPER, PR_SET_NO_NEW_PRIVS,
 PR_GET_NO_NEW_PRIVS, PR_GET_TID_ADDRESS, PR_SET_THP_DISABLE, PR_GET_THP_DISABLE,
 PR_MPX_ENABLE_MANAGEMENT, PR_MPX_DISABLE_MANAGEMENT,
+#ifdef __mips__
+GET_FP_MODE, SET_FP_MODE,
+#endif
 };
 #define NR_PRCTL_OPTS ARRAY_SIZE(prctl_opts)
 
",61,4
"DRM dumb buffer file descriptors

Use the DRM_IOCTL_MODE_CREATE_DUMB ioctl to make ""dumb"" buffers; then use
the DRM_IOCTL_PRIME_HANDLE_TO_FD ioctl to get file descriptors."," void setup_fd_providers(void)
 add_to_prov_list(&timerfd_fd_provider);
 add_to_prov_list(&testfile_fd_provider);
 add_to_prov_list(&memfd_fd_provider);
+add_to_prov_list(&drm_fd_provider);
 
 output(0, ""Registered %d fd providers.\n"", num_fd_providers);
 }
",174,25
fix off by one in domain parser," void find_specific_domain(const char *domainarg)
 return;
 }
 
-outputerr(""Domain unknown. Pass a numeric value [0-%d] or one of "", TRINITY_PF_MAX);
+outputerr(""Domain unknown. Pass a numeric value [0-%d] or one of "", TRINITY_PF_MAX - 1);
 for (i = 0; i < ARRAY_SIZE(domains); i++)
 outputerr(""%s "", domains[i].name);
 outputerr(""\n"");
",132,22
"bare beginnings of proper proto-alg sockaddr generation

obviously lots more to do here, for a start adding in all
the other algorithms.","
 #ifdef USE_IF_ALG
 #include <linux/if_alg.h>
 
+static const char *hashes[] = {
+""md5"", ""sha1"",
+};
+
 void alg_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 {
 struct sockaddr_alg *alg;
-unsigned int i;
+unsigned int i, type;
+const char *types[] = { ""aead"", ""hash"", ""rng"", ""skcipher"", };
 
 alg = zmalloc(sizeof(struct sockaddr_alg));
 
 alg->salg_family = PF_ALG;
-for (i = 0; i < 14; i++)
-alg->salg_type[i] = rand();
+
+type = rand() % 4;
+strncpy((char *)alg->salg_type, types[type], strlen(types[type]));
+
+switch (type) {
+case 0:
+break;
+case 1:
+i = rand() % ARRAY_SIZE(hashes);
+strncpy((char *)alg->salg_name, hashes[i], strlen(hashes[i]));
+break;
+case 2:
+break;
+case 3:
+break;
+}
+
 alg->salg_feat = rand();
 alg->salg_mask = rand();
-for (i = 0; i < 64; i++)
-alg->salg_name[i] = rand();
+
 *addr = (struct sockaddr *) alg;
 *addrlen = sizeof(struct sockaddr_alg);
 }
",43,6
"introduce ARG_SOCKETINFO

For networking related syscalls, passing anything but a network
socket as an fd is a waste of time for the most part.

This will also allow us to do things like match up the right protocol
for things like setsockopt() with the right kind of socket."," static int get_rand_socket_fd(void)
 return fd;
 }
 
+struct socketinfo * get_rand_socketinfo(void)
+{
+/* When using victim files, sockets can be 0. */
+if (nr_sockets == 0)
+return NULL;
+
+return &shm->sockets[rand() % nr_sockets];
+}
+
 const struct fd_provider socket_fd_provider = {
 .name = ""sockets"",
 .enabled = TRUE,
",313,73
"in some cases, we'll still want to pass a non-socket, just for fun."," static void sanitise_setsockopt(struct syscallrecord *rec)
 {
 struct sockopt so = { 0, 0, 0, 0 };
 struct socketinfo *si;
-si = (struct socketinfo *) rec->a1;
+int fd;
+
+if (ONE_IN(1000)) {
+fd = get_random_fd();
+} else {
+si = (struct socketinfo *) rec->a1;
+fd = si->fd;
+}
+
+rec->a1 = fd;
 
-rec->a1 = si->fd;
 // TODO, pass the si->triplet down.
 do_setsockopt(&so);
 
",112,8
add ARG_SOCKETINFO to arg decoder,"
 
 static char * decode_argtype(char *sptr, unsigned long reg, enum argtype type)
 {
+struct socketinfo *si;
+
 switch (type) {
 case ARG_PATHNAME:
 sptr += sprintf(sptr, ""\""%s\"""", (char *) reg);
 static char * decode_argtype(char *sptr, unsigned long reg, enum argtype type)
 }
 sptr += sprintf(sptr, ""%s"", ANSI_RESET);
 break;
+
+case ARG_SOCKETINFO:
+si = (struct socketinfo *) reg;
+if (si != NULL)
+sptr += sprintf(sptr, ""fd:%d"", si->fd);
+break;
 }
 
 return sptr;
",176,46
"cap the max length we copy into salg_name

(shut up coverity)."," static const char *hashes[] = {
 void alg_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 {
 struct sockaddr_alg *alg;
-unsigned int i, type;
+unsigned int i, type, len;
 const char *types[] = { ""aead"", ""hash"", ""rng"", ""skcipher"", };
 
 alg = zmalloc(sizeof(struct sockaddr_alg));
 void alg_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 alg->salg_family = PF_ALG;
 
 type = rand() % 4;
-strncpy((char *)alg->salg_type, types[type], strlen(types[type]));
+len = min(strlen(types[type]), sizeof(alg->salg_type));
+strncpy((char *)alg->salg_type, types[type], len);
 
 switch (type) {
 case 0:
 break;
 case 1:
 i = rand() % ARRAY_SIZE(hashes);
-strncpy((char *)alg->salg_name, hashes[i], strlen(hashes[i]));
+len = min(strlen(hashes[i]), sizeof(alg->salg_type));
+strncpy((char *)alg->salg_name, hashes[i], len);
 break;
 case 2:
 break;
",45,6
invert early error path in write_socket_to_cache," static bool write_socket_to_cache(int cachefile, struct socket_triplet *st)
 unsigned int buffer[3];
 int n;
 
-if (cachefile != -1) {
-buffer[0] = st->family;
-buffer[1] = st->type;
-buffer[2] = st->protocol;
-n = write(cachefile, &buffer, sizeof(int) * 3);
-if (n == -1) {
-outputerr(""something went wrong writing the cachefile!\n"");
-return FALSE;
-}
+if (cachefile == -1)
+return FALSE;
+
+buffer[0] = st->family;
+buffer[1] = st->type;
+buffer[2] = st->protocol;
+n = write(cachefile, &buffer, sizeof(int) * 3);
+if (n == -1) {
+outputerr(""something went wrong writing the cachefile!\n"");
+return FALSE;
 }
 return TRUE;
 }
",313,73
don't evaluate switch each iteration in generate_rand_bytes()," void generate_rand_bytes(unsigned char *ptr, unsigned int len)
 unsigned int i;
 unsigned char choice = rand() % 3;
 
-for (i = 0; i < len; i++) {
-switch (choice) {
-case 0:
-/* Complete garbage. */
+switch (choice) {
+case 0:
+/* Complete garbage. */
+for (i = 0; i < len; i++)
 ptr[i] = RAND_BYTE();
-break;
-case 1:
-/* printable text strings. */
+break;
+case 1:
+/* printable text strings. */
+for (i = 0; i < len; i++)
 ptr[i] = 32 + rand() % (0x7f - 32);
-break;
-case 2:
-/* numbers */
+break;
+case 2:
+/* numbers */
+for (i = 0; i < len; i++)
 ptr[i] = '0' + rand() % 10;
-break;
-}
+break;
 }
 }
 
",142,44
"pass down the socket triplet to setsockopt

We don't do anything with it yet, but this at least wires things up."," retry:
 if (so->optval != 0)
 free((void *) so->optval);
 
-do_setsockopt(so);
+do_setsockopt(so, triplet);
 
 ret = setsockopt(fd, so->level, so->optname, (void *)so->optval, so->optlen);
 if (ret == 0) {
",313,73
centralise SOL_* definitions into net.h,"
 #include ""utils.h""
 #include ""compat.h""
 
-#define SOL_ALG 279
-
 #ifdef USE_IF_ALG
 #include <linux/if_alg.h>
 
",45,6
"instead of looping in do_random_sso, fall back to the generic socket opts."," static const struct sso_funcptr ssoptrs[] = {
 { .family = AF_VSOCK, .func = NULL },
 };
 
-// TODO: Wildcard match
-//{ .func = &socket_setsockopt },
-//
 //TODO: How shall we match these ?
 //{ .func = &atm_setsockopt },
 //{ .func = &aal_setsockopt },
 static void do_random_sso(struct sockopt *so)
 {
 int i;
 
-again:
 i = rand() % ARRAY_SIZE(ssoptrs);
 
-if (ssoptrs[i].func == NULL)
-goto again;
+if (ssoptrs[i].func == NULL) {
+socket_setsockopt(so);
+return;
+}
 
 ssoptrs[i].func(so);
 }
",182,16
split out the calling of the sso function ptr to its own routine," static void do_random_sso(struct sockopt *so)
 ssoptrs[i].func(so);
 }
 
+static void call_sso_ptr(struct sockopt *so, struct socket_triplet *triplet)
+{
+unsigned int i;
+
+for (i = 0; i < ARRAY_SIZE(ssoptrs); i++) {
+if (ssoptrs[i].family == triplet->family) {
+if (ssoptrs[i].func != NULL)
+ssoptrs[i].func(so);
+else // unimplented yet, or no sso for this family.
+do_random_sso(so);
+}
+}
+}
+
 /*
 * Call a proto specific setsockopt routine from the table above.
 *
 void do_setsockopt(struct sockopt *so, struct socket_triplet *triplet)
 so->optname = RAND_BYTE();/* random operation. */
 } else {
 if (triplet != NULL) {
-unsigned int i;
-for (i = 0; i < ARRAY_SIZE(ssoptrs); i++) {
-if (ssoptrs[i].family == triplet->family) {
-if (ssoptrs[i].func != NULL)
-ssoptrs[i].func(so);
-else// unimplented yet, or no sso for this family.
-do_random_sso(so);
-}
-}
+call_sso_ptr(so, triplet);
 } else {
 // fd probably isn't a socket.
 do_random_sso(so);
",186,17
"add generic_fd_from_socketinfo()

This will be used for networking related functions that don't
care about the triplet, but just want an fd (most the time).","
 #include ""params.h""// verbose, do_specific_domain
 #include ""domains.h""
 #include ""random.h""
+#include ""sanitise.h""
 #include ""shm.h""
 #include ""trinity.h""
 #include ""uid.h""
 struct socketinfo * get_rand_socketinfo(void)
 return &shm->sockets[rand() % nr_sockets];
 }
 
+int generic_fd_from_socketinfo(struct socketinfo *si)
+{
+if (ONE_IN(1000))
+return get_random_fd();
+else
+return si->fd;
+}
+
 const struct fd_provider socket_fd_provider = {
 .name = ""sockets"",
 .enabled = TRUE,
",321,75
switch accept() to use ARG_SOCKETINFO,"
 * On success, these system calls return a nonnegative integer that is a descriptor for the accepted socket.
 * On error, -1 is returned, and errno is set appropriately.
 */
+#include ""net.h""
 #include ""sanitise.h""
 
+static void sanitise_accept(struct syscallrecord *rec)
+{
+rec->a1 = generic_fd_from_socketinfo((struct socketinfo *) rec->a1);
+}
+
 struct syscallentry syscall_accept = {
 .name = ""accept"",
 .num_args = 3,
 .arg1name = ""fd"",
-.arg1type = ARG_FD,
+.arg1type = ARG_SOCKETINFO,
 .arg2name = ""upeer_sockaddr"",
 .arg2type = ARG_SOCKADDR,
 .arg3name = ""upeer_addrlen"",
 .arg3type = ARG_SOCKADDRLEN,
 .rettype = RET_FD,
 .flags = NEED_ALARM,
+.sanitise = sanitise_accept,
 };
 
 
 struct syscallentry syscall_accept = {
 *
 */
 
-#define SOCK_CLOEXEC 02000000
-#define SOCK_NONBLOCK 04000
-
 struct syscallentry syscall_accept4 = {
 .name = ""accept4"",
 .num_args = 4,
",37,1
switch accept4 to use ARG_SOCKETINFO," struct syscallentry syscall_accept4 = {
 .name = ""accept4"",
 .num_args = 4,
 .arg1name = ""fd"",
-.arg1type = ARG_FD,
+.arg1type = ARG_SOCKETINFO,
 .arg2name = ""upeer_sockaddr"",
 .arg2type = ARG_SOCKADDR,
 .arg3name = ""upeer_addrlen"",
 struct syscallentry syscall_accept4 = {
 },
 .rettype = RET_FD,
 .flags = NEED_ALARM,
+.sanitise = sanitise_accept,// use same as accept.
 };
",38,1
switch bind() to use ARG_SOCKETINFO,"
 #include ""sanitise.h""
 #include ""shm.h""
 
+static void sanitise_bind(struct syscallrecord *rec)
+{
+rec->a1 = generic_fd_from_socketinfo((struct socketinfo *) rec->a1);
+}
+
 /*
 static void dump(struct syscallrecord *rec)
 {
 struct syscallentry syscall_bind = {
 .name = ""bind"",
 .num_args = 3,
 .arg1name = ""fd"",
-.arg1type = ARG_FD,
+.arg1type = ARG_SOCKETINFO,
 .arg2name = ""umyaddr"",
 .arg2type = ARG_SOCKADDR,
 .arg3name = ""addrlen"",
 struct syscallentry syscall_bind = {
 //.sanitise = dump,
 .rettype = RET_ZERO_SUCCESS,
 .flags = NEED_ALARM,
+.sanitise = sanitise_bind,
 };
",21,1
switch connect to use ARG_SOCKETINFO,"
 * If the connection or binding succeeds, zero is returned.
 * On error, -1 is returned, and errno is set appropriately.
 */
+#include ""net.h""
 #include ""sanitise.h""
 
+static void sanitise_connect(struct syscallrecord *rec)
+{
+rec->a1 = generic_fd_from_socketinfo((struct socketinfo *) rec->a1);
+}
+
 struct syscallentry syscall_connect = {
 .name = ""connect"",
 .num_args = 3,
 .arg1name = ""fd"",
-.arg1type = ARG_FD,
+.arg1type = ARG_SOCKETINFO,
 .arg2name = ""uservaddr"",
 .arg2type = ARG_SOCKADDR,
 .arg3name = ""addrlen"",
 .arg3type = ARG_SOCKADDRLEN,
 .rettype = RET_ZERO_SUCCESS,
 .flags = NEED_ALARM,
+.sanitise = sanitise_connect,
 };
",19,1
switch getpeername to use ARG_SOCKETINFO,"
 /*
 * SYSCALL_DEFINE3(getpeername, int, fd, struct sockaddr __user *, usockaddr, int __user *, usockaddr_len)
 */
+#include ""net.h""
 #include ""sanitise.h""
 
+static void sanitise_getpeername(struct syscallrecord *rec)
+{
+rec->a1 = generic_fd_from_socketinfo((struct socketinfo *) rec->a1);
+}
+
 struct syscallentry syscall_getpeername = {
 .name = ""getpeername"",
 .num_args = 3,
 .arg1name = ""fd"",
-.arg1type = ARG_FD,
+.arg1type = ARG_SOCKETINFO,
 .arg2name = ""usockaddr"",
 .arg2type = ARG_SOCKADDR,
 .arg3name = ""usockaddr_len"",
 .arg3type = ARG_SOCKADDRLEN,
 .rettype = RET_ZERO_SUCCESS,
 .flags = NEED_ALARM,
+.sanitise = sanitise_getpeername,
 };
",19,1
switch getsockname to use ARG_SOCKINFO,"
 /*
 * SYSCALL_DEFINE3(getsockname, int, fd, struct sockaddr __user *, usockaddr, int __user *, usockaddr_len)
 */
+#include ""net.h""
 #include ""sanitise.h""
 
+static void sanitise_getsockname(struct syscallrecord *rec)
+{
+rec->a1 = generic_fd_from_socketinfo((struct socketinfo *) rec->a1);
+}
+
 struct syscallentry syscall_getsockname = {
 .name = ""getsockname"",
 .num_args = 3,
 .arg1name = ""fd"",
-.arg1type = ARG_FD,
+.arg1type = ARG_SOCKETINFO,
 .arg2name = ""usockaddr"",
 .arg2type = ARG_SOCKADDR,
 .arg3name = ""usockaddr_len"",
 .arg3type = ARG_SOCKADDRLEN,
 .flags = NEED_ALARM,
+.sanitise = sanitise_getsockname,
 };
",18,1
"clear send() buff ptr on failure, so we don't free() junk"," static void sanitise_send(struct syscallrecord *rec)
 size = rand() % page_size;
 
 ptr = malloc(size);
+rec->a2 = (unsigned long) ptr;
 if (ptr == NULL)
 return;
 
-rec->a2 = (unsigned long) ptr;
 rec->a3 = size;
 
 // TODO: only use this as a fallback, and actually have
",150,8
add inotify fd provider," void setup_fd_providers(void)
 add_to_prov_list(&testfile_fd_provider);
 add_to_prov_list(&memfd_fd_provider);
 add_to_prov_list(&drm_fd_provider);
+add_to_prov_list(&inotify_fd_provider);
 
 output(0, ""Registered %d fd providers.\n"", num_fd_providers);
 }
",175,25
remove more unnecessary includes,"
 #include ""fd.h""
 #include ""files.h""
 #include ""log.h""
-#include ""net.h""
-#include ""params.h""
-#include ""pids.h""
 #include ""pipes.h""
 #include ""random.h""
 #include ""sanitise.h""
",48,4
check for timerfd_create returning ENOSYS," static int open_timerfd_fds(void)
 unsigned int i;
 
 shm->timerfd_fds[0] = timerfd_create(CLOCK_REALTIME, 0);
+if (shm->timerfd_fds[0] == -1)
+if (errno == ENOSYS)
+return FALSE;
+
 shm->timerfd_fds[1] = timerfd_create(CLOCK_REALTIME, TFD_NONBLOCK);
 shm->timerfd_fds[2] = timerfd_create(CLOCK_REALTIME, TFD_CLOEXEC);
 shm->timerfd_fds[3] = timerfd_create(CLOCK_REALTIME, TFD_NONBLOCK | TFD_CLOEXEC);
 static int open_timerfd_fds(void)
 shm->timerfd_fds[6] = timerfd_create(CLOCK_MONOTONIC, TFD_CLOEXEC);
 shm->timerfd_fds[7] = timerfd_create(CLOCK_MONOTONIC, TFD_NONBLOCK | TFD_CLOEXEC);
 
-// TODO: Check for ENOSYS
-
 for (i = 0; i < MAX_TIMERFD_FDS; i++)
 output(2, ""fd[%d] = timerfd\n"", shm->timerfd_fds[i]);
 
",42,5
switch getsockopt to use ARG_SOCKETINFO,"
 /*
 * SYSCALL_DEFINE5(getsockopt, int, fd, int, level, int, optname, char __user *, optval, int __user *, optlen)
 */
+#include ""net.h""
 #include ""sanitise.h""
 
+static void sanitise_getsockopt(struct syscallrecord *rec)
+{
+rec->a1 = generic_fd_from_socketinfo((struct socketinfo *) rec->a1);
+}
+
 struct syscallentry syscall_getsockopt = {
 .name = ""getsockopt"",
 .num_args = 5,
 .arg1name = ""fd"",
-.arg1type = ARG_FD,
+.arg1type = ARG_SOCKETINFO,
 .arg2name = ""level"",
 .arg3name = ""optname"",
 .arg4name = ""optval"",
 struct syscallentry syscall_getsockopt = {
 .arg5name = ""optlen"",
 .arg5type = ARG_LEN,
 .flags = NEED_ALARM,
+.sanitise = sanitise_getsockopt,
 };
",20,1
"extract call_inet_sso_ptr, and make it search for matching protocol"," static void call_sso_ptr(struct sockopt *so, struct socket_triplet *triplet)
 }
 }
 
+static void call_inet_sso_ptr(struct sockopt *so, struct socket_triplet *triplet)
+{
+unsigned int i;
+
+for (i = 0; i < ARRAY_SIZE(ip_ssoptrs); i++) {
+if (ip_ssoptrs[i].proto == triplet->protocol) {
+if (ip_ssoptrs[i].func != NULL)
+ip_ssoptrs[i].func(so);
+else// unimplented yet, or no sso for this proto.
+do_random_sso(so);
+}
+}
+}
+
 /*
 * Call a proto specific setsockopt routine from the table above.
 *
 void do_setsockopt(struct sockopt *so, struct socket_triplet *triplet)
 } else {
 if (triplet != NULL) {
 if (triplet->family == AF_INET) {
-//TODO: Later, be smarter, and look up the rest of the triplet.
-int randsso = rand() % ARRAY_SIZE(ip_ssoptrs);
-if (ip_ssoptrs[randsso].func != NULL)
-ip_ssoptrs[randsso].func(so);
+call_inet_sso_ptr(so, triplet);
 } else {
 call_sso_ptr(so, triplet);
 }
",196,20
occasionally do the generic socket options.," void do_setsockopt(struct sockopt *so, struct socket_triplet *triplet)
 so->optlen = rand() % 256;
 
 if (ONE_IN(100)) {
-so->level = rand();
-so->optname = RAND_BYTE();/* random operation. */
+if (RAND_BOOL()) {
+so->level = rand();
+so->optname = RAND_BYTE();/* completely random operation. */
+} else {
+// Fall back to generic socket options.
+socket_setsockopt(so);
+}
 } else {
 if (triplet != NULL) {
 if (triplet->family == AF_INET) {
",200,21
invert tests in do_random_sso for code clarity," static void do_random_sso(struct sockopt *so)
 
 i = rand() % ARRAY_SIZE(ssoptrs);
 
-if (ssoptrs[i].func == NULL) {
-socket_setsockopt(so);
-return;
-}
-
-ssoptrs[i].func(so);
+if (ssoptrs[i].func != NULL)
+ssoptrs[i].func(so);
+else
+socket_setsockopt(so);// Last resort: Generic socket options.
 }
 
 static void call_sso_ptr(struct sockopt *so, struct socket_triplet *triplet)
",199,21
add '\0' as a potential separator in generate_rand_bytes()," void generate_rand_bytes(unsigned char *ptr, unsigned int len)
 unsigned int i;
 unsigned char choice = rand() % 3;
 unsigned int startoffset = 0, remain, runlen;
+unsigned char separators[3] = { ' ', '-', '\0' };
 unsigned char separator;
 
 switch (choice) {
 void generate_rand_bytes(unsigned char *ptr, unsigned int len)
 break;
 case 2:
 /* numbers (for now, decimal only) */
-if (RAND_BOOL())
-separator = ',';
-else
-separator = ' ';
+
+separator = separators[rand() % 3];
 
 remain = len;
 
",163,48
add missing argument to format string in inotify fd init," static int create_inotify(unsigned int i, int flags)
 
 fd = inotify_init1(flags);
 if (fd != -1) {
-output(2, ""fd[%d] = inotify(%d)\n"", fd);
+output(2, ""fd[%d] = inotify(%d)\n"", fd, flags);
 shm->inotify_fds[i] = fd;
 return TRUE;
 } else {
",53,8
match AF_PPPOX up with pppol2tp_setsockopt," static const struct sso_funcptr ssoptrs[] = {
 { .family = AF_RDS, .func = &rds_setsockopt },
 { .family = AF_SNA, .func = NULL },
 { .family = AF_IRDA, .func = &irda_setsockopt },
-{ .family = AF_PPPOX, .func = NULL },
+{ .family = AF_PPPOX, .func = &pppol2tp_setsockopt },
 { .family = AF_WANPIPE, .func = NULL },
 { .family = AF_LLC, .func = &llc_setsockopt },
 { .family = AF_IB, .func = NULL },
 static const struct sso_funcptr ssoptrs[] = {
 //TODO: How shall we match these ?
 //{ .func = &atm_setsockopt },
 //{ .func = &aal_setsockopt },
-//{ .func = &pppol2tp_setsockopt },
 //{ .func = &pnpipe_setsockopt },
 
 /*
",206,23
match AF_PHONET up with pnpipe_setsockopt," static const struct sso_funcptr ssoptrs[] = {
 { .family = AF_IUCV, .func = &iucv_setsockopt },
 { .family = AF_RXRPC, .func = &rxrpc_setsockopt },
 { .family = AF_ISDN, .func = NULL },
-{ .family = AF_PHONET, .func = NULL },
+{ .family = AF_PHONET, .func = &pnpipe_setsockopt },
 { .family = AF_IEEE802154, .func = NULL },
 #ifdef USE_CAIF
 { .family = AF_CAIF, .func = &caif_setsockopt },
 static const struct sso_funcptr ssoptrs[] = {
 //TODO: How shall we match these ?
 //{ .func = &atm_setsockopt },
 //{ .func = &aal_setsockopt },
-//{ .func = &pnpipe_setsockopt },
 
 /*
 * We do this if for eg, we've ended up being passed
",206,23
remove pointless NR_SOL_ATM_OPTS define," void atmsvc_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 *addrlen = sizeof(struct sockaddr_atmsvc);
 }
 
-#define NR_SOL_ATM_OPTS ARRAY_SIZE(atm_opts)
 static const unsigned int atm_opts[] = {
 SO_SETCLP, SO_CIRANGE, SO_ATMQOS, SO_ATMSAP, SO_ATMPVC, SO_MULTIPOINT };
 
 void atm_setsockopt(struct sockopt *so)
 
 so->level = SOL_ATM;
 
-val = rand() % NR_SOL_ATM_OPTS;
+val = rand() % ARRAY_SIZE(atm_opts);
 so->optname = atm_opts[val];
 }
",46,5
"ATM setsockopt cleanup

Keep it simple and just use one function for both pvc and svc.
Also throw away the aal file, as it doesn't even do anything."," void atmsvc_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 *addrlen = sizeof(struct sockaddr_atmsvc);
 }
 
+// TODO: If anyone gives a crap about ATM, we could do better
+// here and separate the pvc and svc ops.
+// Personally, I couldn't care less, so throw everything in the same array
+// just to make this simpler.
 static const unsigned int atm_opts[] = {
-SO_SETCLP, SO_CIRANGE, SO_ATMQOS, SO_ATMSAP, SO_ATMPVC, SO_MULTIPOINT };
+SO_SETCLP, SO_CIRANGE, SO_ATMQOS, SO_ATMSAP, SO_ATMPVC, SO_MULTIPOINT,
+};
 
 void atm_setsockopt(struct sockopt *so)
 {
",47,5
"once we've matched the protocol, stop searching."," static void call_sso_ptr(struct sockopt *so, struct socket_triplet *triplet)
 
 for (i = 0; i < ARRAY_SIZE(ssoptrs); i++) {
 if (ssoptrs[i].family == triplet->family) {
-if (ssoptrs[i].func != NULL)
+if (ssoptrs[i].func != NULL) {
 ssoptrs[i].func(so);
-else// unimplented yet, or no sso for this family.
+return;
+} else {// unimplented yet, or no sso for this family.
 do_random_sso(so);
+return;
+}
 }
 }
 }
 static void call_inet_sso_ptr(struct sockopt *so, struct socket_triplet *triplet
 
 for (i = 0; i < ARRAY_SIZE(ip_ssoptrs); i++) {
 if (ip_ssoptrs[i].proto == triplet->protocol) {
-if (ip_ssoptrs[i].func != NULL)
+if (ip_ssoptrs[i].func != NULL) {
 ip_ssoptrs[i].func(so);
-else// unimplented yet, or no sso for this proto.
+return;
+} else {// unimplented yet, or no sso for this proto.
 do_random_sso(so);
+return;
+}
 }
 }
 }
",212,23
move the setting of so->level into do_setsockopt and helpers.," void alg_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 *addrlen = sizeof(struct sockaddr_alg);
 }
 #endif
-
-void alg_setsockopt(struct sockopt *so)
-{
-so->level = SOL_ALG;
-}
",41,5
do IP protocols as one of the random fallbacks in setsockopt," static void do_random_sso(struct sockopt *so)
 unsigned int i;
 
 retry:
-switch (rand() % 3) {
+switch (rand() % 4) {
 case 0:/* do a random protocol, even if it doesn't match this socket. */
 i = rand() % ARRAY_SIZE(ssoptrs);
 if (ssoptrs[i].func != NULL) {
-// TODO: Also pick from ip_ssoptrs.
 so->level = ssoptrs[i].sol;
 ssoptrs[i].func(so);
 } else {
 retry:
 }
 break;
 
-case 1:/* Last resort: Generic socket options. */
+case 1:/* do a random IP protocol, even if it doesn't match this socket. */
+i = rand() % ARRAY_SIZE(ip_ssoptrs);
+if (ip_ssoptrs[i].func != NULL) {
+so->level = ip_ssoptrs[i].sol;
+ip_ssoptrs[i].func(so);
+} else {
+goto retry;
+}
+break;
+
+case 2:/* Last resort: Generic socket options. */
 socket_setsockopt(so);
 break;
 
-case 2:/* completely random operation. */
+case 3:/* completely random operation. */
 so->level = rand();
 so->optname = RAND_BYTE();
 break;
",231,25
merge net/proto-pppol2tp.c into net/proto-pppox.c,"
 #include <linux/if.h>
 #include <linux/if_ether.h> /* for ETH_ALEN in if_pppox.h */
 #include <linux/if_pppox.h>
+#include <linux/if_pppol2tp.h>
 #include <stdlib.h>
 #include ""config.h""
 #include ""net.h""
 #include ""sanitise.h""
 #include ""utils.h""
+#include ""compat.h""
 
 //TODO: Split out each case into separate function.
 
 void pppox_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 break;
 }
 }
+
+#define NR_SOL_PPPOL2TP_OPTS ARRAY_SIZE(pppol2tp_opts)
+static const unsigned int pppol2tp_opts[] = {
+PPPOL2TP_SO_DEBUG, PPPOL2TP_SO_RECVSEQ, PPPOL2TP_SO_SENDSEQ, PPPOL2TP_SO_LNSMODE,
+PPPOL2TP_SO_REORDERTO };
+
+void pppol2tp_setsockopt(struct sockopt *so)
+{
+unsigned char val;
+
+val = rand() % NR_SOL_PPPOL2TP_OPTS;
+so->optname = pppol2tp_opts[val];
+
+so->optlen = sizeof(int);
+}
",136,16
remove a bunch of pointless defines," void ax25_rand_socket(struct socket_triplet *st)
 }
 }
 
-#define NR_SOL_AX25_OPTS ARRAY_SIZE(ax25_opts)
 static const unsigned int ax25_opts[] = {
 AX25_WINDOW, AX25_T1, AX25_N2, AX25_T3,
 AX25_T2, AX25_BACKOFF, AX25_EXTSEQ, AX25_PIDINCL,
 AX25_IDLE, AX25_PACLEN, AX25_IAMDIGI,
-SO_BINDTODEVICE };
+SO_BINDTODEVICE
+};
 
 void ax25_setsockopt(struct sockopt *so)
 {
 unsigned char val;
 
-val = rand() % NR_SOL_AX25_OPTS;
+val = rand() % ARRAY_SIZE(ax25_opts);
 so->optname = ax25_opts[val];
 }
",61,6
use the same socket generator for ipv6 and ipv4," void ipv6_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 
 void inet6_rand_socket(struct socket_triplet *st)
 {
-switch (rand() % 4) {
-case 0: st->type = SOCK_STREAM; // TCP/SCTP
-switch (rand() % 3) {
-case 0:
-st->protocol = 0;
-break;
-case 1:
-st->protocol = IPPROTO_TCP;
-break;
-case 2:
-st->protocol = IPPROTO_SCTP;
-break;
-default:
-break;
-}
-break;
-
-case 1: st->type = SOCK_DGRAM; // UDP
-if (RAND_BOOL())
-st->protocol = 0;
-else
-st->protocol = IPPROTO_UDP;
-break;
-
-case 2: st->type = SOCK_SEQPACKET; // SCTP
-if (RAND_BOOL())
-st->protocol = 0;
-else
-st->protocol = IPPROTO_SCTP;
-break;
-
-case 3: st->type = SOCK_RAW;
-st->protocol = rand() % PROTO_MAX;
-break;
-
-default:
-break;
-}
+// Use the same socket generator as ipv4
+inet_rand_socket(st);
 }
 
 static const unsigned int inet6_opts[] = {
",92,8
add TCP_TIMESTAMP & TCP_NOTSENT_LOWAT socket options," static const unsigned int tcp_opts[] = {
 TCP_DEFER_ACCEPT, TCP_WINDOW_CLAMP, TCP_INFO, TCP_QUICKACK,
 TCP_CONGESTION, TCP_MD5SIG, TCP_COOKIE_TRANSACTIONS, TCP_THIN_LINEAR_TIMEOUTS,
 TCP_THIN_DUPACK, TCP_USER_TIMEOUT, TCP_REPAIR, TCP_REPAIR_QUEUE,
-TCP_QUEUE_SEQ, TCP_REPAIR_OPTIONS, TCP_FASTOPEN,
+TCP_QUEUE_SEQ, TCP_REPAIR_OPTIONS, TCP_FASTOPEN, TCP_TIMESTAMP,
+TCP_NOTSENT_LOWAT,
 };
 
 void tcp_setsockopt(struct sockopt *so)
",20,1
mark IPPROTO_ICMP .type as SOCK_DGRAM," void inet_rand_socket(struct socket_triplet *st)
 {
 struct ipproto ipprotos[] = {
 { .proto = IPPROTO_IP, },
-{ .proto = IPPROTO_ICMP, },
+{ .proto = IPPROTO_ICMP, .type = SOCK_DGRAM },
 { .proto = IPPROTO_IGMP, },
 { .proto = IPPROTO_IPIP, },
 { .proto = IPPROTO_TCP, .type = SOCK_STREAM },
",215,21
convert ipv6 to use ip_option struct.," void inet_rand_socket(struct socket_triplet *st)
 st->type = SOCK_RAW;
 }
 
-struct ip_option {
-unsigned int name;
-unsigned int len;
-};
-
 static const struct ip_option ip_opts[] = {
 { .name = IP_TOS, .len = sizeof(int) },
 { .name = IP_TTL, .len = sizeof(int) },
",211,21
add sizes for the ipv6 multicast socketopts," static const struct ip_option inet6_opts[] = {
 { .name = IPV6_FLOWINFO_SEND, },
 { .name = IPV6_IPSEC_POLICY, },
 { .name = IPV6_XFRM_POLICY, },
-{ .name = MCAST_JOIN_GROUP, },
-{ .name = MCAST_BLOCK_SOURCE, },
-{ .name = MCAST_UNBLOCK_SOURCE, },
-{ .name = MCAST_LEAVE_GROUP, },
-{ .name = MCAST_JOIN_SOURCE_GROUP, },
-{ .name = MCAST_LEAVE_SOURCE_GROUP, },
+{ .name = MCAST_JOIN_GROUP, .len = sizeof(struct group_req) },
+{ .name = MCAST_BLOCK_SOURCE, .len = sizeof(struct group_source_req) },
+{ .name = MCAST_UNBLOCK_SOURCE, .len = sizeof(struct group_source_req) },
+{ .name = MCAST_LEAVE_GROUP, sizeof(struct group_req) },
+{ .name = MCAST_JOIN_SOURCE_GROUP, .len = sizeof(struct group_source_req) },
+{ .name = MCAST_LEAVE_SOURCE_GROUP, .len = sizeof(struct group_source_req) },
 { .name = MCAST_MSFILTER, },
 { .name = IPV6_RECVPKTINFO, },
 { .name = IPV6_PKTINFO, },
",139,9
do SO_REUSEADDR before attemping to bind to random sockets," static int open_socket(unsigned int domain, unsigned int type, unsigned int prot
 
 /* Sometimes, listen on created sockets. */
 if (RAND_BOOL()) {
-int ret;
+int ret, one = 1;
 
 /* fake a sockaddr. */
 generate_sockaddr((struct sockaddr **) &sa, (socklen_t *) &salen, domain);
 
+ret = setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &one, sizeof(one));
+if (ret != -1)
+goto skip_bind;
 ret = bind(fd, sa, salen);
-if (ret != -1) {
+if (ret != -1)
 (void) listen(fd, RAND_RANGE(1, 128));
-}
 }
+skip_bind:
 
 if (sa != NULL)
 free(sa);
",324,76
"fix SOCKETINFO arg-decoder.

at this point, we only have the fd, not the socketinfo","
 
 static char * decode_argtype(char *sptr, unsigned long reg, enum argtype type)
 {
-struct socketinfo *si;
-
 switch (type) {
 case ARG_PATHNAME:
 sptr += sprintf(sptr, ""\""%s\"""", (char *) reg);
 break;
 case ARG_PID:
 case ARG_FD:
+case ARG_SOCKETINFO:
 sptr += sprintf(sptr, ""%s%ld"", ANSI_RESET, (long) reg);
 break;
 case ARG_MODE_T:
 static char * decode_argtype(char *sptr, unsigned long reg, enum argtype type)
 }
 sptr += sprintf(sptr, ""%s"", ANSI_RESET);
 break;
-
-case ARG_SOCKETINFO:
-si = (struct socketinfo *) reg;
-if (si != NULL)
-sptr += sprintf(sptr, ""fd:%d"", si->fd);
-break;
 }
 
 return sptr;
",171,45
fix syscall_sendto 'fd' argtype. (it's a socketinfo),"
 
 static void sanitise_send(struct syscallrecord *rec)
 {
-unsigned int size;
 void *ptr;
+unsigned int size;
 
 rec->a1 = generic_fd_from_socketinfo((struct socketinfo *) rec->a1);
 
 struct syscallentry syscall_sendto = {
 .name = ""sendto"",
 .num_args = 6,
 .arg1name = ""fd"",
-.arg1type = ARG_FD,
+.arg1type = ARG_SOCKETINFO,
 .arg2name = ""buff"",
 .arg2type = ARG_ADDRESS,
 .arg3name = ""len"",
",150,8
fix get_rand_socketinfo offset confusion," struct socketinfo * get_rand_socketinfo(void)
 if (nr_sockets == 0)
 return NULL;
 
-return &shm->sockets[rand() % nr_sockets];
+return shm->sockets + (rand() % nr_sockets);
 }
 
 int generic_fd_from_socketinfo(struct socketinfo *si)
",329,78
generic_fd_from_socketinfo can be called with a NULL si," struct socketinfo * get_rand_socketinfo(void)
 
 int generic_fd_from_socketinfo(struct socketinfo *si)
 {
-if (ONE_IN(1000))
-return get_random_fd();
-else
-return si->fd;
+if (si != NULL) {
+if (!(ONE_IN(1000)))
+return si->fd;
+}
+return get_random_fd();
 }
 
 const struct fd_provider socket_fd_provider = {
",330,79
some of the multicast sockopts can take two struct types.," static const struct ip_option ip_opts[] = {
 void ip_setsockopt(struct sockopt *so)
 {
 unsigned char val;
-struct ip_mreqn *mr;
+struct ip_mreq *mr;
+struct ip_mreqn *mrn;
 struct ip_mreq_source *ms;
 int mcaddr;
 
 void ip_setsockopt(struct sockopt *so)
 case IP_ADD_MEMBERSHIP:
 case IP_DROP_MEMBERSHIP:
 mcaddr = 0xe0000000 | rand() % 0xff;
-
-mr = (struct ip_mreqn *) so->optval;
-mr->imr_multiaddr.s_addr = mcaddr;
-mr->imr_address.s_addr = random_ipv4_address();
-mr->imr_ifindex = rand32();
+if (RAND_BOOL()) {
+mrn = (struct ip_mreqn *) so->optval;
+mrn->imr_multiaddr.s_addr = htonl(mcaddr);
+mrn->imr_address.s_addr = random_ipv4_address();
+mrn->imr_ifindex = rand32();
+so->optlen = sizeof(struct ip_mreqn);
+} else {
+mr = (struct ip_mreq *) so->optval;
+mr->imr_multiaddr.s_addr = htonl(mcaddr);
+mr->imr_interface.s_addr = random_ipv4_address();
+so->optlen = sizeof(struct ip_mreq);
+}
 break;
 
 case IP_MSFILTER:
",223,23
add TCP_CC_INFO setsockopt," static const unsigned int tcp_opts[] = {
 TCP_CONGESTION, TCP_MD5SIG, TCP_COOKIE_TRANSACTIONS, TCP_THIN_LINEAR_TIMEOUTS,
 TCP_THIN_DUPACK, TCP_USER_TIMEOUT, TCP_REPAIR, TCP_REPAIR_QUEUE,
 TCP_QUEUE_SEQ, TCP_REPAIR_OPTIONS, TCP_FASTOPEN, TCP_TIMESTAMP,
-TCP_NOTSENT_LOWAT,
+TCP_NOTSENT_LOWAT, TCP_CC_INFO,
 };
 
 void tcp_setsockopt(struct sockopt *so)
",20,1
"rename ip_option to sock_option

Other non-IP setsockopt functions will end up using this."," void inet_rand_socket(struct socket_triplet *st)
 st->type = SOCK_RAW;
 }
 
-static const struct ip_option ip_opts[] = {
+static const struct sock_option ip_opts[] = {
 { .name = IP_TOS, },
 { .name = IP_TTL, },
 { .name = IP_HDRINCL, },
",223,23
"some of the ip socket options take chars

instead of annotating them, just randomly choose between int/char
for the fallback case."," void ip_setsockopt(struct sockopt *so)
 
 val = rand() % ARRAY_SIZE(ip_opts);
 so->optname = ip_opts[val].name;
-if (ip_opts[val].len == 0)
-so->optlen = sizeof(int);
-else
+if (ip_opts[val].len == 0) {
+if (RAND_BOOL())
+so->optlen = sizeof(char);
+else
+so->optlen = sizeof(int);
+} else
 so->optlen = ip_opts[val].len;
 
 switch (so->optname) {
",226,24
move the sock_option len setting to a common function," void ip_setsockopt(struct sockopt *so)
 
 val = rand() % ARRAY_SIZE(ip_opts);
 so->optname = ip_opts[val].name;
-if (ip_opts[val].len == 0) {
-if (RAND_BOOL())
-so->optlen = sizeof(char);
-else
-so->optlen = sizeof(int);
-} else
-so->optlen = ip_opts[val].len;
+so->optlen = get_so_len(ip_opts[val].len);
 
 switch (so->optname) {
 case IP_OPTIONS:
",220,22
rename get_so_len to sockoptlen," void ip_setsockopt(struct sockopt *so)
 
 val = rand() % ARRAY_SIZE(ip_opts);
 so->optname = ip_opts[val].name;
-so->optlen = get_so_len(ip_opts[val].len);
+so->optlen = sockoptlen(ip_opts[val].len);
 
 switch (so->optname) {
 case IP_OPTIONS:
",220,22
make ARG_LEN return some common sizeof's," unsigned long get_len(void)
 {
 int i = 0;
 
+if (RAND_BOOL()) {
+switch (rand() % 3) {
+case 0:return sizeof(char);
+case 1:return sizeof(int);
+case 2:return sizeof(long);
+}
+}
+
 i = rand32();
 
 /* short circuit if 0 */
 unsigned long get_len(void)
 return 0;
 
 switch (rand() % 6) {
-
 case 0:i &= 0xff;
 break;
 case 1: i &= page_size - 1;
",39,14
set the pass/fail statistics correctly in the execve case," static void __do_syscall(struct syscallrecord *rec)
 rec->state = AFTER;
 unlock(&rec->lock);
 
+if (IS_ERR(ret))
+shm->stats.failures++;
+else
+shm->stats.successes++;
+
 if (needalarm)
 (void)alarm(0);
 }
 static void do_extrafork(struct syscallrecord *rec)
 __do_syscall(rec);
 /* if this was for eg. an successful execve, we should never get here.
  * if it failed though... */
+shm->stats.failures++;
 _exit(EXIT_SUCCESS);
 }
 
 static void do_extrafork(struct syscallrecord *rec)
 if (pid_alive(extrapid) == TRUE)
 kill(extrapid, SIGKILL);
 }
+shm->stats.successes++;
 }
 
 
 void do_syscall(struct syscallrecord *rec)
 else
  /* common-case, do the syscall in this child process. */
 __do_syscall(rec);
-
-if (IS_ERR(rec->retval))
-shm->stats.failures++;
-else
-shm->stats.successes++;
 }
 
 static void check_retval_documented(struct syscallrecord *rec, struct syscallentry *entry)
",173,34
remove hand-coded instance of sockoptlen in do_setsockopt," void do_setsockopt(struct sockopt *so, struct socket_triplet *triplet)
  */
 so->optval = (unsigned long) zmalloc(page_size);
 
-// pick a size for optlen. At the minimum, we want an int (overridden below)
-if (RAND_BOOL())
-so->optlen = sizeof(int);
-else
-so->optlen = rand() % 256;
+/* At the minimum, we want len to be a char or int.
+ * It gets (overridden below in the per-proto sso->func, so this
+ * is just for the unannotated protocols.
+ */
+so->optlen = sockoptlen(0);
 
 if (ONE_IN(100)) {
 do_random_sso(so);
",237,27
split the mapping write functions into single/multi variants," static void dirty_last_page(struct map *map)
 memset((void *) p + ((map->size - 1) - page_size), 'A', page_size);
 }
 
-static const struct faultfn write_faultfns[] = {
+static const struct faultfn write_faultfns_single[] = {
 { .func = dirty_one_page },
+{ .func = dirty_first_page },
+};
+
+static const struct faultfn write_faultfns[] = {
 { .func = dirty_whole_mapping },
 { .func = dirty_every_other_page },
 { .func = dirty_mapping_reverse },
 { .func = dirty_random_pages },
-{ .func = dirty_first_page },
 { .func = dirty_last_page },
 };
 
 void random_map_writefn(struct map *map)
 {
-write_faultfns[rand() % ARRAY_SIZE(write_faultfns)].func(map);
+if (map->size == page_size)
+write_faultfns[rand() % ARRAY_SIZE(write_faultfns_single)].func(map);
+else {
+if (RAND_BOOL())
+write_faultfns[rand() % ARRAY_SIZE(write_faultfns)].func(map);
+else
+write_faultfns[rand() % ARRAY_SIZE(write_faultfns_single)].func(map);
+}
 }
",190,53
ignore RT signals from children," static void handle_childsig(int childpid, int childstatus, int stop)
 return;
 
 default:
+if (__sig >= SIGRTMIN) {
+debugf(""Child %d got RT signal (%d). Ignoring.\n"", childpid, __sig);
+return;
+}
+
 if (stop == TRUE)
 debugf(""Child %d was stopped by unhandled signal (%s).\n"", childpid, strsignal(WSTOPSIG(childstatus)));
 else
",252,54
"blacklist /dev/sd* from the file list on startup

if we run as root, even with --dropprivs, we should disallow
direct access to disks, in case we scribble over the root disk."," static int ignore_files(const char *path)
 debugf(""Skipping %s\n"", path);
 return 1;
 }
+
+/* seriously though, I should add globbing */
+if (!strncmp(path + offset, ""sd"", 2)) {
+debugf(""Skipping %s\n"", path);
+return 1;
+}
+
 return 0;
 }
 
",306,67
"if we detect corruption in the child, behave like the watchdog does.","
 
 #include ""arch.h""// biarch
 #include ""child.h""
+#include ""debug.h""
 #include ""locks.h""
 #include ""log.h""
 #include ""params.h""// dopause
 retry:
 if (len != strlen(rec->prebuffer)) {
 output(0, ""Sanity check failed: prebuffer length changed from %d to %d.\n"",
 len, strlen(rec->prebuffer));
+dump_childnos();
+dump_childdata(this_child);
+panic(EXIT_PID_OUT_OF_RANGE);
 }
 
 /* Output the syscall result, and clean up */
",96,17
"remove magic '500000' threshold from watchdog progress detector.

On a machine with enough fast cores, we can trip this easily.
Just remove the check, and replace it with a check to make sure
it didn't go backwards.

I'm torn between just removing this completely, and may do so later."," static int shm_is_corrupt(void)
 {
 unsigned int i;
 
-// FIXME: The '500000' is magic, and should be dynamically calculated.
-// On startup, we should figure out how many getpid()'s per second we can do,
-// and use that.
-if (shm->stats.total_syscalls_done - shm->stats.previous_op_count > 500000) {
-output(0, ""Execcount increased dramatically! (old:%ld new:%ld):\n"",
+if (shm->stats.total_syscalls_done < shm->stats.previous_op_count) {
+output(0, ""Execcount went backwards! (old:%ld new:%ld):\n"",
 shm->stats.previous_op_count, shm->stats.total_syscalls_done);
 panic(EXIT_SHM_CORRUPTION);
 return TRUE;
",322,65
"watchdog: tweak the wraparound detector.

still triggers too easily when run with lots of children"," static void check_child_progress(struct childdata *child)
 child->kill_count++;
 kill_pid(pid);
 
-/* if we wrapped, just reset it, we'll pick it up next time around. */
-if (diff > 2146) {/* max adjtime offset, + the 1 second since last time. */
+/* Check if we wrapped. Difference should be no more than the max adjtime
+ * offset, + the 1 second since last time, but sometimes it does happen
+ * if we don't get scheduled in time on a busy machine. So build in an
+ * extra 30 seconds to be sure.
+ */
+if (diff > 2145 + 30) {
+/* if we did wrap, just reset it, we'll pick it up next time around. */
 output(1, ""child %u wrapped! old=%lu now=%lu\n"", child->num, old, now);
 rec->tv.tv_sec = now;
 return;
",322,65
"delete_mapping is only called from post_munmap, so inline it."," void init_child_mappings(struct childdata *child)
 }
 }
 
-/* Called from munmap()'s ->post routine. */
-void delete_mapping(struct map *map)
-{
-list_del(&map->list);
-this_child->num_mappings--;
-}
-
 /* used in several sanitise_* functions. */
 struct map * common_set_mmap_ptr_len(void)
 {
",88,11
"don't try to bind to cpus outside the cpuset

when running with more child processes than cpu cores, we
tried to do stupid things."," void init_child(struct childdata *child, int childno)
 cpu_set_t set;
 pid_t pid = getpid();
 char childname[17];
+unsigned int cpudest;
 
 /* Wait for parent to set our childno */
 while (child->pid != pid) {
 void init_child(struct childdata *child, int childno)
 dirty_random_mapping();
 
 if (sched_getaffinity(pid, sizeof(set), &set) == 0) {
+if ((unsigned int) childno > num_online_cpus)
+cpudest = childno % num_online_cpus;
+else
+cpudest = childno;
 CPU_ZERO(&set);
-CPU_SET(childno, &set);
+CPU_SET(cpudest, &set);
 sched_setaffinity(pid, sizeof(set), &set);
 }
 
",254,51
"special case ENOSYS in check_retval_documented

Now instead of ..

[child23:21426] getrandom returned an undocumented return value (38:Function not implemented)
[child23:21426] getrandom (317) returned ENOSYS, marking as inactive.
[child0:21403] execveat returned an undocumented return value (38:Function not implemented)
[child0:21403] execveat (322) returned ENOSYS, marking as inactive.

We'll just get the latter message."," static void check_retval_documented(struct syscallrecord *rec, struct syscallent
 struct errnos *errnos;
 unsigned int i;
 
+/* Just return silently if ENOSYS, we'll disable it immediately afterwards. */
+if (rec->errno_post == ENOSYS)
+return;
+
 /* Only check syscalls we've documented so far. */
 errnos = &entry->errnos;
 if (errnos->num == 0)
",175,35
use the right function table when choosing fault write routines.," static const struct faultfn write_faultfns[] = {
 void random_map_writefn(struct map *map)
 {
 if (map->size == page_size)
-write_faultfns[rand() % ARRAY_SIZE(write_faultfns_single)].func(map);
+write_faultfns_single[rand() % ARRAY_SIZE(write_faultfns_single)].func(map);
 else {
 if (RAND_BOOL())
 write_faultfns[rand() % ARRAY_SIZE(write_faultfns)].func(map);
 else
-write_faultfns[rand() % ARRAY_SIZE(write_faultfns_single)].func(map);
+write_faultfns_single[rand() % ARRAY_SIZE(write_faultfns_single)].func(map);
 }
 }
",190,53
page align the page that dirty_last_page writes to," static void dirty_last_page(struct map *map)
 {
 char *p = map->ptr;
 
-memset((void *) p + ((map->size - 1) - page_size), 'A', page_size);
+memset((void *) p + (map->size - page_size), 'A', page_size);
 }
 
 static const struct faultfn write_faultfns_single[] = {
",190,53
invert test to reduce indentation," static void bind_child_to_cpu(struct childdata *child)
 cpu_set_t set;
 unsigned int cpudest;
 
-if (sched_getaffinity(child->pid, sizeof(set), &set) == 0) {
-if (child->num > num_online_cpus)
-cpudest = child->num % num_online_cpus;
-else
-cpudest = child->num;
-
-CPU_ZERO(&set);
-CPU_SET(cpudest, &set);
-sched_setaffinity(child->pid, sizeof(set), &set);
-}
+if (sched_getaffinity(child->pid, sizeof(set), &set) != 0)
+return;
+
+if (child->num > num_online_cpus)
+cpudest = child->num % num_online_cpus;
+else
+cpudest = child->num;
+
+CPU_ZERO(&set);
+CPU_SET(cpudest, &set);
+sched_setaffinity(child->pid, sizeof(set), &set);
 }
 
 /*
",259,53
replace switch in pppox_gen_sockaddr with jump table," static void pppox_PX_PROTO_OL2TP(struct sockaddr **addr, socklen_t *addrlen)
 
 void pppox_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 {
-unsigned int proto;
-
-proto = rand() % 3;
-
-switch (proto) {
-
-case PX_PROTO_OE:
-pppox_PX_PROTO_OE(addr, addrlen);
-break;
-
-case PX_PROTO_OL2TP:
-pppox_PX_PROTO_OL2TP(addr, addrlen);
-
+const struct ppp_funcptr pppox_protos[] = {
+{ .func = pppox_PX_PROTO_OE },
+{ .func = pppox_PX_PROTO_OL2TP },
 #ifdef USE_PPPOX_PPTP
-case PX_PROTO_PPTP:
-//FIXME: What do we do here?
-break;
+//{ .func = pppox_PX_PROTO_PPTP },// TBD
 #endif
+};
 
-default:
-break;
-}
+pppox_protos[rand() % ARRAY_SIZE(pppox_protos)].func(addr, addrlen);
 }
 
 static const unsigned int pppol2tp_opts[] = {
",140,15
add RAND_ELEMENT for getting a random array element," void freeptr(unsigned long *p);
 #define __stringify(x...) __stringify_1(x)
 
 #define unreachable() do { } while (1)
+
+#define RAND_ELEMENT(_array, _element) \
+_array[rand() % ARRAY_SIZE(_array)]._element;
",13,1
use RAND_ELEMENT in ipv6," static void gen_random_ipv6_address(struct in6_addr *v6)
 { ""2002::"" },/* 2002::/16 ""6to4"" */
 };
 
-p = v4_in_v6_addresses[rand() % ARRAY_SIZE(v4_in_v6_addresses)].name;
+p = RAND_ELEMENT(v4_in_v6_addresses, name);
 inet_pton(AF_INET6, p, v6);
 
 v4 = random_ipv4_address();
 static void gen_random_ipv6_address(struct in6_addr *v6)
 { ""0100::"" },/* 0100::/64 remotely triggered blackhole */
 };
 
-p = v6_addresses[rand() % ARRAY_SIZE(v6_addresses)].name;
+p = RAND_ELEMENT(v6_addresses, name);
 inet_pton(AF_INET6, p, v6);
 }
 }
",159,16
remove unnecessary define in mmap syscall,"
 #include ""trinity.h""
 #include ""utils.h""//ARRAY_SIZE
 
-#ifdef __x86_64__
-#define NUM_FLAGS 13
-#else
-#define NUM_FLAGS 12
-#endif
-
 // need this to actually get MAP_UNINITIALIZED defined
 #define CONFIG_MMAP_ALLOW_UNINITIALIZED
 
 static void do_anon(struct syscallrecord *rec)
 
 static void sanitise_mmap(struct syscallrecord *rec)
 {
-unsigned long mmap_flags[NUM_FLAGS] = { MAP_FIXED, MAP_ANONYMOUS,
-MAP_GROWSDOWN, MAP_DENYWRITE, MAP_EXECUTABLE, MAP_LOCKED,
-MAP_NORESERVE, MAP_POPULATE, MAP_NONBLOCK, MAP_STACK,
-MAP_HUGETLB, MAP_UNINITIALIZED,
+unsigned long mmap_flags[] = {
+MAP_FIXED, MAP_ANONYMOUS, MAP_GROWSDOWN, MAP_DENYWRITE,
+MAP_EXECUTABLE, MAP_LOCKED, MAP_NORESERVE, MAP_POPULATE,
+MAP_NONBLOCK, MAP_STACK, MAP_HUGETLB, MAP_UNINITIALIZED,
 #ifdef __x86_64__
-MAP_32BIT,
+MAP_32BIT,
 #endif
 };
 unsigned long sizes[] = {
",148,15
add a RAND_ARRAY variant for unnamed elements," void freeptr(unsigned long *p);
 
 #define RAND_ELEMENT(_array, _element) \
 _array[rand() % ARRAY_SIZE(_array)]._element;
+
+#define RAND_ARRAY(_array) _array[rand() % ARRAY_SIZE(_array)];
",13,1
use RAND_ARRAY in mmap," static void sanitise_mmap(struct syscallrecord *rec)
 rec->a4 = set_rand_bitmask(ARRAY_SIZE(mmap_flags), mmap_flags);
 
 if (rec->a4 & MAP_ANONYMOUS) {
-rec->a2 = sizes[rand() % ARRAY_SIZE(sizes)];
+rec->a2 = RAND_ARRAY(sizes);
 do_anon(rec);
 } else {
 if (this_syscallname(""mmap2"") == TRUE) {
",148,15
remove trailing ;'s from macros," void freeptr(unsigned long *p);
 #define unreachable() do { } while (1)
 
 #define RAND_ELEMENT(_array, _element) \
-_array[rand() % ARRAY_SIZE(_array)]._element;
+_array[rand() % ARRAY_SIZE(_array)]._element
 
-#define RAND_ARRAY(_array) _array[rand() % ARRAY_SIZE(_array)];
+#define RAND_ARRAY(_array) _array[rand() % ARRAY_SIZE(_array)]
",13,1
use RAND_ARRAY in tipc,"
 #include <stdlib.h>
 #include ""net.h""
 #include ""random.h""
-#include ""utils.h""// ARRAY_SIZE
+#include ""utils.h""// RAND_ARRAY
 #include ""compat.h""
 
 void tipc_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 void tipc_setsockopt(struct sockopt *so)
 {
 unsigned char val;
 
-val = rand() % ARRAY_SIZE(tipc_opts);
+val = RAND_ARRAY(tipc_opts);
 so->optname = tipc_opts[val];
 
 so->optlen = sizeof(__u32);
",52,6
use RAND_ARRAY in pppox," void pppol2tp_setsockopt(struct sockopt *so)
 {
 unsigned char val;
 
-val = rand() % ARRAY_SIZE(pppol2tp_opts);
+val = RAND_ARRAY(pppol2tp_opts);
 so->optname = pppol2tp_opts[val];
 
 so->optlen = sizeof(int);
",140,15
use RAND_ARRAY in tcp,"
 #include <linux/tcp.h>
 #include ""net.h""
 #include ""compat.h""
-#include ""utils.h""// ARRAY_SIZE
+#include ""utils.h""// RAND_ARRAY
 
 static const unsigned int tcp_opts[] = {
 TCP_NODELAY, TCP_MAXSEG, TCP_CORK, TCP_KEEPIDLE,
 void tcp_setsockopt(struct sockopt *so)
 {
 unsigned char val;
 
-val = rand() % ARRAY_SIZE(tcp_opts);
+val = RAND_ARRAY(tcp_opts);
 so->optname = tcp_opts[val];
 }
",20,1
use RAND_ARRAY in packet,"
 #include <stdlib.h>
 #include ""net.h""
 #include ""random.h""
-#include ""utils.h""// ARRAY_SIZE
+#include ""utils.h""// RAND_ARRAY
 #include ""compat.h""
 
 void packet_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 void packet_setsockopt(struct sockopt *so)
 
 optval = (char *) so->optval;
 
-val = rand() % ARRAY_SIZE(packet_opts);
+val = RAND_ARRAY(packet_opts);
 so->optname = packet_opts[val];
 
 /* Adjust length according to operation set. */
",66,13
use ARRAY_RAND in dccp,"
 #include ""net.h""
 #include ""compat.h""
 #include ""config.h""
-#include ""utils.h""// ARRAY_SIZE
+#include ""utils.h""// RAND_ARRAY
 
 static const unsigned int dccp_opts[] = {
 DCCP_SOCKOPT_PACKET_SIZE, DCCP_SOCKOPT_SERVICE, DCCP_SOCKOPT_CHANGE_L, DCCP_SOCKOPT_CHANGE_R,
 void dccp_setsockopt(struct sockopt *so)
 {
 unsigned char val;
 
-val = rand() % ARRAY_SIZE(dccp_opts);
+val = RAND_ARRAY(dccp_opts);
 so->optname = dccp_opts[val];
 }
",18,1
use ARRAY_RAND in atm,"
 #include <netinet/in.h>
 #include <stdlib.h>
 #include ""net.h""
-#include ""utils.h""// ARRAY_SIZE
+#include ""utils.h""// RAND_ARRAY
 #include ""compat.h""
 
 void atmpvc_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 void atm_setsockopt(struct sockopt *so)
 {
 unsigned char val;
 
-val = rand() % ARRAY_SIZE(atm_opts);
+val = RAND_ARRAY(atm_opts);
 so->optname = atm_opts[val];
 }
",46,5
use ARRAY_RAND in proto ax25,"
 #include <netax25/ax25.h>
 #include ""net.h""
 #include ""random.h""
-#include ""utils.h""// ARRAY_SIZE
+#include ""utils.h""// RAND_ARRAY
 #include ""compat.h""
 
 void ax25_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 void ax25_setsockopt(struct sockopt *so)
 {
 unsigned char val;
 
-val = rand() % ARRAY_SIZE(ax25_opts);
+val = RAND_ARRAY(ax25_opts);
 so->optname = ax25_opts[val];
 }
",61,6
use ARRAY_RAND in proto bluetooth,"
 #include <stdlib.h>
 #include ""net.h""
 #include ""compat.h""
-#include ""utils.h""// ARRAY_SIZE
+#include ""utils.h""// RAND_ARRAY
 
 static const unsigned int bluetooth_opts[] = {
 BT_SECURITY, BT_DEFER_SETUP, BT_FLUSHABLE, BT_POWER,
 void bluetooth_setsockopt(struct sockopt *so)
 
 switch (so->level) {
 case SOL_HCI:
-val = rand() % ARRAY_SIZE(bluetooth_hci_opts);
+val = RAND_ARRAY(bluetooth_hci_opts);
 so->optname = bluetooth_hci_opts[val];
 break;
 
 case SOL_L2CAP:
-val = rand() % ARRAY_SIZE(bluetooth_l2cap_opts);
+val = RAND_ARRAY(bluetooth_l2cap_opts);
 so->optname = bluetooth_l2cap_opts[val];
 break;
 
 void bluetooth_setsockopt(struct sockopt *so)
 break;
 
 case SOL_RFCOMM:
-val = rand() % ARRAY_SIZE(bluetooth_rfcomm_opts);
+val = RAND_ARRAY(bluetooth_rfcomm_opts);
 so->optname = bluetooth_rfcomm_opts[val];
 break;
 
 case SOL_BLUETOOTH:
-val = rand() % ARRAY_SIZE(bluetooth_opts);
+val = RAND_ARRAY(bluetooth_opts);
 so->optname = bluetooth_opts[val];
 break;
 
",50,11
use ARRAY_RAND in proto caif,"
 #include ""config.h""
 #include ""net.h""
 #include ""random.h""
-#include ""utils.h""// ARRAY_SIZE
+#include ""utils.h""// RAND_ARRAY
 #include ""compat.h""
 
 #ifdef USE_CAIF
 void caif_setsockopt(struct sockopt *so)
 {
 unsigned char val;
 
-val = rand() % ARRAY_SIZE(caif_opts);
+val = RAND_ARRAY(caif_opts);
 so->optname = caif_opts[val];
 }
 #else
",50,7
use ARRAY_RAND in proto decnet,"
 #include <stdlib.h>
 #include ""net.h""
 #include ""random.h""
-#include ""utils.h""// ARRAY_SIZE
+#include ""utils.h""// RAND_ARRAY
 #include ""compat.h""
 
 void decnet_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 void decnet_setsockopt(struct sockopt *so)
 {
 unsigned char val;
 
-val = rand() % ARRAY_SIZE(decnet_opts);
+val = RAND_ARRAY(decnet_opts);
 so->optname = decnet_opts[val];
 
 // TODO: set optlen correctly
",50,5
use ARRAY_RAND in proto icmp6,"
 #include <linux/icmpv6.h>
 #include ""net.h""
 #include ""compat.h""
-#include ""utils.h""// ARRAY_SIZE
+#include ""utils.h""// RAND_ARRAY
 
 static const unsigned int icmpv6_opts[] = { ICMPV6_FILTER };
 
 void icmpv6_setsockopt(struct sockopt *so)
 {
 unsigned char val;
 
-val = rand() % ARRAY_SIZE(icmpv6_opts);
+val = RAND_ARRAY(icmpv6_opts);
 so->optname = icmpv6_opts[val];
 }
 #endif
",13,1
use ARRAY_RAND in proto irda,"
 #include <stdlib.h>
 #include ""net.h""
 #include ""random.h""
-#include ""utils.h""// ARRAY_SIZE
+#include ""utils.h""// RAND_ARRAY
 #include ""compat.h""
 
 void irda_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 void irda_setsockopt(struct sockopt *so)
 {
 unsigned char val;
 
-val = rand() % ARRAY_SIZE(irda_opts);
+val = RAND_ARRAY(irda_opts);
 so->optname = irda_opts[val];
 }
",53,8
use ARRAY_RAND in proto iucv,"
 #include <stdlib.h>
 #include ""net.h""
 #include ""compat.h""
-#include ""utils.h""// ARRAY_SIZE
+#include ""utils.h""// RAND_ARRAY
 
 static const unsigned int iucv_opts[] = {
 SO_IPRMDATA_MSG, SO_MSGLIMIT, SO_MSGSIZE
 void iucv_setsockopt(struct sockopt *so)
 {
 unsigned char val;
 
-val = rand() % ARRAY_SIZE(iucv_opts);
+val = RAND_ARRAY(iucv_opts);
 so->optname = iucv_opts[val];
 
 so->optlen = sizeof(int);
",14,1
use ARRAY_RAND in proto llc,"
 #include ""config.h""
 #include ""net.h""
 #include ""random.h""
-#include ""utils.h""// ARRAY_SIZE
+#include ""utils.h""// RAND_ARRAY
 #include ""compat.h""
 
 void llc_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 void llc_setsockopt(struct sockopt *so)
 {
 unsigned char val;
 
-val = rand() % ARRAY_SIZE(llc_opts);
+val = RAND_ARRAY(llc_opts);
 so->optname = llc_opts[val];
 }
",48,5
use ARRAY_RAND in proto netlink,"
 #include ""net.h""
 #include ""random.h""
 #include ""sanitise.h""
-#include ""utils.h""// ARRAY_SIZE
+#include ""utils.h""// RAND_ARRAY
 #include ""compat.h""
 
 
 void netlink_setsockopt(struct sockopt *so)
 {
 unsigned char val;
 
-val = rand() % ARRAY_SIZE(netlink_opts);
+val = RAND_ARRAY(netlink_opts);
 so->optname = netlink_opts[val];
 }
",40,4
use ARRAY_RAND in proto netrom,"
 #include <netrom/netrom.h>
 #include ""net.h""
 #include ""compat.h""
-#include ""utils.h""// ARRAY_SIZE
+#include ""utils.h""// RAND_ARRAY
 
 static const unsigned int netrom_opts[] = {
 NETROM_T1, NETROM_T2, NETROM_N2, NETROM_T4, NETROM_IDLE
 void netrom_setsockopt(struct sockopt *so)
 {
 unsigned char val;
 
-val = rand() % ARRAY_SIZE(netrom_opts);
+val = RAND_ARRAY(netrom_opts);
 so->optname = netrom_opts[val];
 }
 #endif
",15,1
use ARRAY_RAND in proto rose,"
 #include <stdlib.h>
 #include ""net.h""
 #include ""random.h""
-#include ""utils.h""// ARRAY_SIZE
+#include ""utils.h""// RAND_ARRAY
 #include ""compat.h""
 
 void rose_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 void rose_setsockopt(struct sockopt *so)
 {
 unsigned char val;
 
-val = rand() % ARRAY_SIZE(rose_opts);
+val = RAND_ARRAY(rose_opts);
 so->optname = rose_opts[val];
 }
 #endif
",38,2
use ARRAY_RAND in proto rds,"
 #endif
 
 #include ""compat.h""
-#include ""utils.h""// ARRAY_SIZE
+#include ""utils.h""// RAND_ARRAY
 
 void rds_rand_socket(struct socket_triplet *st)
 {
 void rds_setsockopt(struct sockopt *so)
 {
 unsigned char val;
 
-val = rand() % ARRAY_SIZE(rds_opts);
+val = RAND_ARRAY(rds_opts);
 so->optname = rds_opts[val];
 }
 
",35,4
use ARRAY_RAND in proto rxrpc,"
 #include <stdlib.h>
 #include ""net.h""
 #include ""compat.h""
-#include ""utils.h""// ARRAY_SIZE
+#include ""utils.h""// RAND_ARRAY
 
 static const unsigned int rxrpc_opts[] = {
 RXRPC_USER_CALL_ID, RXRPC_ABORT, RXRPC_ACK, RXRPC_NET_ERROR,
 void rxrpc_setsockopt(struct sockopt *so)
 {
 unsigned char val;
 
-val = rand() % ARRAY_SIZE(rxrpc_opts);
+val = RAND_ARRAY(rxrpc_opts);
 so->optname = rxrpc_opts[val];
 }
",14,1
use ARRAY_RAND in proto sctp,"
 #include <stdlib.h>
 #include ""net.h""
 #include ""compat.h""
-#include ""utils.h""// ARRAY_SIZE
+#include ""utils.h""// RAND_ARRAY
 
 static const unsigned int sctp_opts[] = {
 SCTP_RTOINFO, SCTP_ASSOCINFO, SCTP_INITMSG, SCTP_NODELAY,
 void sctp_setsockopt(struct sockopt *so)
 {
 unsigned char val;
 
-val = rand() % ARRAY_SIZE(sctp_opts);
+val = RAND_ARRAY(sctp_opts);
 so->optname = sctp_opts[val];
 }
",23,1
use ARRAY_RAND in proto socket,"
 #include <linux/filter.h>
 #include ""net.h""
 #include ""compat.h""
-#include ""utils.h""// ARRAY_SIZE
+#include ""utils.h""// RAND_ARRAY
 
 static const unsigned int socket_opts[] = {
 SO_DEBUG, SO_REUSEADDR, SO_TYPE, SO_ERROR,
 void socket_setsockopt(struct sockopt *so)
 
 so->level = SOL_SOCKET;
 
-val = rand() % ARRAY_SIZE(socket_opts);
+val = RAND_ARRAY(socket_opts);
 so->optname = socket_opts[val];
 
 /* Adjust length according to operation set. */
",44,5
use ARRAY_RAND in proto udp,"
 #include <netinet/udp.h>
 #include ""net.h""
 #include ""random.h""
-#include ""utils.h""// ARRAY_SIZE
+#include ""utils.h""// RAND_ARRAY
 #include ""compat.h""
 
 static const unsigned int udp_opts[] = {
 void udp_setsockopt(struct sockopt *so)
 unsigned char val;
 char *optval;
 
-val = rand() % ARRAY_SIZE(udp_opts);
+val = RAND_ARRAY(udp_opts);
 so->optname = udp_opts[val];
 
 switch (so->optname) {
",26,3
use ARRAY_RAND in proto udplite,"
 #include <linux/udp.h>
 #include ""net.h""
 #include ""random.h""
-#include ""utils.h""// ARRAY_SIZE
+#include ""utils.h""// RAND_ARRAY
 #include ""compat.h""
 
 static const unsigned int udplite_opts[] = {
 void udplite_setsockopt(struct sockopt *so)
 char *optval;
 unsigned char val;
 
-val = rand() % ARRAY_SIZE(udplite_opts);
+val = RAND_ARRAY(udplite_opts);
 so->optname = udplite_opts[val];
 
 switch (so->optname) {
",30,5
use RAND_ARRAY in mremap," static void sanitise_mremap(struct syscallrecord *rec)
 rec->a3 = map->size;//TODO: Munge this.
 
 if (rec->a4 & MREMAP_FIXED) {
-unsigned long align = alignments[rand() % ARRAY_SIZE(alignments)];
+unsigned long align = RAND_ARRAY(alignments);
 unsigned int shift = (__WORDSIZE / 2) - 1;
 
 newaddr = RAND_BYTE();
",58,5
replace huge compound if in munge_tables with function.," void enable_random_syscalls(void)
 }
 }
 
+/* By default, all syscall entries will be disabled.
+ * If we didn't pass -c, -x, -r, or -g then mark all syscalls active.
+ */
+static void decide_if_active(void)
+{
+if (do_specific_syscall == TRUE)
+return;
+if (do_exclude_syscall == TRUE)
+return;
+if (random_selection == TRUE)
+return;
+if (desired_group != GROUP_NONE)
+return;
+
+mark_all_syscalls_active();
+}
 
 /* This is run *after* we've parsed params */
 int munge_tables(void)
 {
-/* By default, all syscall entries will be disabled.
- * If we didn't pass -c, -x or -r, mark all syscalls active.
- */
-if ((do_specific_syscall == FALSE) && (do_exclude_syscall == FALSE) && (random_selection == FALSE) && (desired_group == GROUP_NONE))
-mark_all_syscalls_active();
+decide_if_active();
 
 if (desired_group != GROUP_NONE) {
 unsigned int ret;
",378,96
give read fault the same single-page treatment we did for writes.," static void read_last_page(struct map *map)
 }
 
 static const struct faultfn read_faultfns[] = {
-{ .func = read_one_page },
 { .func = read_whole_mapping },
 { .func = read_every_other_page },
 { .func = read_mapping_reverse },
 static const struct faultfn read_faultfns[] = {
 
 void random_map_readfn(struct map *map)
 {
-read_faultfns[rand() % ARRAY_SIZE(read_faultfns)].func(map);
+if (map->size == page_size)
+read_one_page(map);
+else {
+if (RAND_BOOL())
+read_one_page(map);
+else
+read_faultfns[rand() % ARRAY_SIZE(read_faultfns)].func(map);
+}
 }
",77,14
make sure we don't try to dump children that don't exist," void dump_childnos(void)
 for (j = 0; j < 8; j++) {
 struct childdata *child;
 
+if (i + j > max_children)
+break;
+
 child = shm->children[i + j];
 
 if (child->pid == EMPTY_PIDSLOT) {
",116,28
"remove guard pages from single page mappings.

They aren't really useful"," void setup_initial_mappings(void)
 initial_mappings = zmalloc(sizeof(struct map));
 INIT_LIST_HEAD(&initial_mappings->list);
 
-/* page_size * 2, so we have a guard page afterwards.
- * This is necessary for when we want to test page boundaries.
- * see end of _get_address() for details.
- */
-alloc_zero_map(page_size * 2, PROT_READ | PROT_WRITE, ""PROT_READ | PROT_WRITE"");
-alloc_zero_map(page_size * 2, PROT_READ, ""PROT_READ"");
-alloc_zero_map(page_size * 2, PROT_WRITE, ""PROT_WRITE"");
+alloc_zero_map(page_size, PROT_READ | PROT_WRITE, ""PROT_READ | PROT_WRITE"");
+alloc_zero_map(page_size, PROT_READ, ""PROT_READ"");
+alloc_zero_map(page_size, PROT_WRITE, ""PROT_WRITE"");
 
 /*
  * multi megabyte page mappings.
",83,7
"add some functions to (un)write-protect the shm

Use them in critical places"," void child_process(void)
 return;// Exit the child, things are getting too weird.
 }
 
+shm_rw();
+
 while (shm->exit_reason == STILL_RUNNING) {
 unsigned int i;
 
",260,53
change the priority of the watchdog process," void init_watchdog(void)
 pid = fork();
 
 if (pid == 0) {
+__unused__ int ret = nice(-20);
+
 watchdog_pid = getpid();
+
 watchdog();
 output(0, ""[%d] Watchdog exiting because %s.\n"",
 watchdog_pid, decode_exit());
",325,66
don't print stall stats if zero," static void watchdog(void)
 
 if (shm->stats.total_syscalls_done > 1) {
 if (shm->stats.total_syscalls_done - lastcount > 10000) {
-output(0, ""%ld iterations. [F:%ld S:%ld HI:%ld STALLED:%d]\n"",
+char stalltxt[]="" STALLED:XXXX"";
+
+if (stall_count > 0)
+sprintf(stalltxt, "" STALLED:%d"", stall_count);
+output(0, ""%ld iterations. [F:%ld S:%ld HI:%ld%s]\n"",
 shm->stats.total_syscalls_done,
 shm->stats.failures, shm->stats.successes,
-hiscore, stall_count);
+hiscore,
+stall_count ? stalltxt : """");
 lastcount = shm->stats.total_syscalls_done;
 }
 }
",329,68
"remove the watchdog wrap-check.

It needs to be way smarter, and interferes with some later work."," static bool is_child_making_progress(struct childdata *child)
 child->kill_count++;
 kill_pid(pid);
 
-/* Check if we wrapped. Difference should be no more than the max adjtime
- * offset, + the 1 second since last time, but sometimes it does happen
- * if we don't get scheduled in time on a busy machine. So build in an
- * extra 30 seconds to be sure.
- */
-if (diff > 2145 + 30) {
-/* if we did wrap, just reset it, we'll pick it up next time around. */
-output(1, ""child %u wrapped! old=%lu now=%lu\n"", child->num, old, now);
-rec->tv.tv_sec = now;
-}
 return FALSE;
 }
 
",325,67
"page align the page that read_last_page writes to

copying the similar change from 600a071dbdd0d6fbc9afe4ee61ae09d3977a8510"," static void read_last_page(struct map *map)
 char *p = map->ptr;
 char buf[page_size];
 
-memcpy(buf, p + ((map->size - 1) - page_size), page_size);
+memcpy(buf, p + (map->size - page_size), page_size);
 }
 
 static const struct faultfn read_faultfns[] = {
",77,14
Move output buffer rendering to log.c," void outputstd(const char *fmt, ...)
 vfprintf(stdout, fmt, args);
 va_end(args);
 }
+
+
+// TODO: combine the below with output()
+static void flushbuffer(char *buffer, FILE *fd)
+{
+fprintf(fd, ""%s"", buffer);
+fflush(fd);
+}
+
+void output_rendered_buffer(char *buffer)
+{
+/* Output to stdout only if -q param is not specified */
+if (quiet_level == MAX_LOGLEVEL)
+flushbuffer(buffer, stdout);
+
+/* Exit if should not continue at all. */
+if (logging == TRUE) {
+FILE *log_handle;
+
+log_handle = find_logfile_handle();
+if (log_handle != NULL) {
+strip_ansi(buffer);
+flushbuffer(buffer, log_handle);
+}
+}
+}
",228,47
just inline flushbuffer," void outputstd(const char *fmt, ...)
 
 
 // TODO: combine the below with output()
-static void flushbuffer(char *buffer, FILE *fd)
-{
-fprintf(fd, ""%s"", buffer);
-fflush(fd);
-}
-
 void output_rendered_buffer(char *buffer)
 {
 /* Output to stdout only if -q param is not specified */
-if (quiet_level == MAX_LOGLEVEL)
-flushbuffer(buffer, stdout);
+if (quiet_level == MAX_LOGLEVEL) {
+fprintf(stdout, ""%s"", buffer);
+fflush(stdout);
+}
 
 /* Exit if should not continue at all. */
 if (logging == TRUE) {
 void output_rendered_buffer(char *buffer)
 log_handle = find_logfile_handle();
 if (log_handle != NULL) {
 strip_ansi(buffer);
-flushbuffer(buffer, log_handle);
+fprintf(log_handle, ""%s"", buffer);
+fflush(log_handle);
 }
 }
 }
",226,46
preparation for different forms of logging.," bool verbose = FALSE;
 bool monochrome = FALSE;
 bool dangerous = FALSE;
 bool dropprivs = FALSE;
-bool logging = TRUE;
 bool do_syslog = FALSE;
 bool random_selection = FALSE;
 unsigned int random_selection_num;
 char *specific_domain_optarg = NULL;
 
 char *victim_path = NULL;
 
+int logging = LOGGING_FILES;
+
 unsigned int kernel_taint_mask = 0xFFFFFFFF;
 bool kernel_taint_param_occured = FALSE;
 
 void parse_args(int argc, char *argv[])
 break;
 
 case 'l':
-if (!strcmp(optarg, ""off""))
-logging = FALSE;
+if (!strncmp(optarg, ""off"", 3))
+logging = LOGGING_DISABLED;
 break;
 
 case 'L':
",268,45
move file logging details from main()," void output_rendered_buffer(char *buffer)
 fflush(log_handle);
 }
 }
+
+void init_logging(void)
+{
+switch (logging) {
+case LOGGING_DISABLED:
+return;
+case LOGGING_FILES:
+open_main_logfile();
+return;
+}
+}
+
+void shutdown_logging(void)
+{
+switch (logging) {
+case LOGGING_DISABLED:
+return;
+case LOGGING_FILES:
+close_logfile(&mainlogfile);
+return;
+}
+}
",138,29
only log at child logfile fd's if logging to files is enabled.," unsigned int check_if_fd(struct childdata *child, struct syscallrecord *rec)
 if (fd > 1024)
 return FALSE;
 
-if (child->logfile == NULL)
-return FALSE;
+if (logging == LOGGING_FILES) {
+if (child->logfile == NULL)
+return FALSE;
 
-if (fd <= (unsigned int) fileno(child->logfile))
-return FALSE;
+if (fd <= (unsigned int) fileno(child->logfile))
+return FALSE;
+}
 
 return TRUE;
 }
",346,73
prepare child logging for multiple logging types," void init_child(struct childdata *child, int childno)
 
 reinit_child(child);
 
-open_child_logfile(child);
+init_child_logging(child);
 
 set_seed(this_child);
 
",260,53
"if we're not logging to an fd, we should return false"," unsigned int check_if_fd(struct childdata *child, struct syscallrecord *rec)
 
 if (fd <= (unsigned int) fileno(child->logfile))
 return FALSE;
+return TRUE;
 }
 
-return TRUE;
+return FALSE;
 }
 
 static void stuck_syscall_info(struct childdata *child)
",347,73
"wait for main process to start.

There was a tiny window where we would crash if the main process
failed to start for some reason. By checking that main actually
starts up, we eliminate that problem."," static void watchdog(void)
 bool watchdog_exit = FALSE;
 
 while (shm->ready == FALSE) {
-usleep(1);
-if (shm->exit_reason != STILL_RUNNING)
-return;
+unsigned int counter = 0;
+
+while (shm->mainpid == 0) {
+
+if (check_main_alive() == FALSE)
+counter++;
+
+if (counter == 1000) {
+output(0, ""Can't find main at %d\n"", shm->mainpid);
+return;
+}
+
+if (shm->exit_reason != STILL_RUNNING)
+return;
+
+usleep(1);
+}
 }
 
 output(0, ""Watchdog is alive. (pid:%d)\n"", watchdog_pid);
",356,76
"mm: mark mmaps as writable before writing to them

instead of just segfaulting if they've become read-only.

Later, be smarter and split mappings when sub-regions get mprotect'd"," static const struct faultfn write_faultfns[] = {
 
 void random_map_writefn(struct map *map)
 {
-if (map->size == page_size)
+if (map->size == page_size) {
+mprotect(map->ptr, page_size, PROT_READ|PROT_WRITE);
 write_faultfns_single[rand() % ARRAY_SIZE(write_faultfns_single)].func(map);
-else {
-if (RAND_BOOL())
+} else {
+if (RAND_BOOL()) {
+mprotect(map->ptr, map->size, PROT_READ|PROT_WRITE);
 write_faultfns[rand() % ARRAY_SIZE(write_faultfns)].func(map);
-else
+} else {
+mprotect(map->ptr, page_size, PROT_READ|PROT_WRITE);
 write_faultfns_single[rand() % ARRAY_SIZE(write_faultfns_single)].func(map);
+}
 }
 }
",194,53
"only do the shm write protecting in debug mode.

This is quite high overhead."," void create_shm(void)
 
 void shm_ro(void)
 {
-mprotect(shm, shm_size, PROT_READ);
+if (shm->debug == TRUE)
+mprotect(shm, shm_size, PROT_READ);
 }
 
 void shm_rw(void)
 {
-mprotect(shm, shm_size, PROT_READ|PROT_WRITE);
+if (shm->debug == TRUE)
+mprotect(shm, shm_size, PROT_READ|PROT_WRITE);
 }
 
 void init_shm(void)
",56,8
explain why we use alloc_shared for the childdata structs," void init_shm(void)
 
 shm->children = zmalloc(max_children * sizeof(struct childdata *));
 
+/* We allocate the childdata structs as shared mappings, because
+ * the watchdog process needs to peek into each childs syscall records
+ * to make sure they are making progress.
+ */
 for_each_child(i) {
 struct childdata *child;
 
",56,8
write protect the child ptrs after allocation,"
 * Shared mapping creation.
 */
 
+#include <malloc.h>
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
 void shm_rw(void)
 void init_shm(void)
 {
 unsigned int i;
+unsigned int childptrslen;
 
 output(2, ""shm is at %p\n"", shm);
 
 void init_shm(void)
 /* Set seed in parent thread */
 set_seed(NULL);
 
-shm->children = zmalloc(max_children * sizeof(struct childdata *));
+childptrslen = max_children * sizeof(struct childdata *);
+/* round up to page size */
+childptrslen += page_size - 1;
+childptrslen &= PAGE_MASK;
+
+shm->children = memalign(page_size, childptrslen);
+memset(shm->children, 0, childptrslen);
 
 /* We allocate the childdata structs as shared mappings, because
  * the watchdog process needs to peek into each childs syscall records
 void init_shm(void)
 
 child->logfile = NULL;
 }
+mprotect(shm->children, childptrslen, PROT_READ);
 }
",63,8
use .init for mmap size initialization,"
 // need this to actually get MAP_UNINITIALIZED defined
 #define CONFIG_MMAP_ALLOW_UNINITIALIZED
 
+static long sizes[] = {
+-1,/* over-written with page_size below */
+1 * MB, 2 * MB, 4 * MB, 10 * MB,
+1 * GB,
+};
+
+static int init_mmap(void)
+{
+if (sizes[0] != -1)
+return 0;
+
+sizes[0] = page_size;
+return 0;
+}
+
 static void do_anon(struct syscallrecord *rec)
 {
 /* no fd if anonymous mapping. */
 static void sanitise_mmap(struct syscallrecord *rec)
 MAP_32BIT,
 #endif
 };
-unsigned long sizes[] = {
--1,/* over-written with page_size below */
-1 * MB, 2 * MB, 4 * MB, 10 * MB,
-1 * GB,
-};
-
-sizes[0] = page_size;
 
 /* Don't actually set a hint right now. */
 rec->a1 = 0;
 struct syscallentry syscall_mmap = {
 
 .group = GROUP_VM,
 .flags = NEED_ALARM,
+.init = init_mmap,
 };
 
 struct syscallentry syscall_mmap2 = {
 struct syscallentry syscall_mmap2 = {
 
 .group = GROUP_VM,
 .flags = NEED_ALARM,
+.init = init_mmap,
 };
",156,17
redesign the GB/MB macros to take an arg,"
 #include <stdio.h>
 #include <string.h>
 
-#define MB (1024 * 1024UL)
-#define GB (1024 * MB)
+#define MB(_x) (_x * 1024UL * 1024UL)
+#define GB(_x) (_x * 1024UL * MB(1))
 
 void * alloc_shared(unsigned int size);
 
",13,1
don't mmap large pages if we're low on memory," static long sizes[] = {
 
 static int init_mmap(void)
 {
+FILE *fp;
+char *buffer;
+size_t n = 0;
+
 if (sizes[0] != -1)
 return 0;
 
 sizes[0] = page_size;
+
+fp = fopen(""/proc/meminfo"", ""r"");
+if (!fp)
+return -1;
+
+buffer = malloc(4096);
+if (!buffer) {
+fclose(fp);
+return -1;
+}
+
+while (getline(&buffer, &n, fp) >= 0) {
+unsigned int free;
+
+if (sscanf(buffer, ""MemFree: %u"", &free) == 1) {
+unsigned long freegb;
+
+freegb = free / 1024;
+
+if (freegb < GB(8UL)) {
+printf(""Free memory: %.2fGB\n"", (double) freegb / 1024);
+printf(""Low on memory, disabling mmaping of 1GB pages\n"");
+sizes[5] = page_size;
+return 0;
+}
+}
+}
+
+free(buffer);
+fclose(fp);
 return 0;
 }
 
",182,22
add TCP_SAVE_SYN/TCP_SAVED_SYN," static const unsigned int tcp_opts[] = {
 TCP_CONGESTION, TCP_MD5SIG, TCP_COOKIE_TRANSACTIONS, TCP_THIN_LINEAR_TIMEOUTS,
 TCP_THIN_DUPACK, TCP_USER_TIMEOUT, TCP_REPAIR, TCP_REPAIR_QUEUE,
 TCP_QUEUE_SEQ, TCP_REPAIR_OPTIONS, TCP_FASTOPEN, TCP_TIMESTAMP,
-TCP_NOTSENT_LOWAT, TCP_CC_INFO,
+TCP_NOTSENT_LOWAT, TCP_CC_INFO, TCP_SAVE_SYN, TCP_SAVED_SYN,
 };
 
 void tcp_setsockopt(struct sockopt *so)
",20,1
add IP_CHECKSUM setsockopt," static const struct sock_option ip_opts[] = {
 { .name = IP_ORIGDSTADDR, },
 { .name = IP_MINTTL, },
 { .name = IP_NODEFRAG, },
+{ .name = IP_CHECKSUM, },
 { .name = IP_MULTICAST_IF, .len = sizeof(struct ip_mreqn) },
 { .name = IP_MULTICAST_TTL, },
 { .name = IP_MULTICAST_LOOP, },
",221,22
add IP_BIND_ADDRESS_NO_PORT setsockopt," static const struct sock_option ip_opts[] = {
 { .name = IP_MINTTL, },
 { .name = IP_NODEFRAG, },
 { .name = IP_CHECKSUM, },
+{ .name = IP_BIND_ADDRESS_NO_PORT, },
 { .name = IP_MULTICAST_IF, .len = sizeof(struct ip_mreqn) },
 { .name = IP_MULTICAST_TTL, },
 { .name = IP_MULTICAST_LOOP, },
",222,22
add NETLINK_LISTEN_ALL_NSID setsockopt," void netlink_rand_socket(struct socket_triplet *st)
 
 static const unsigned int netlink_opts[] = {
 NETLINK_ADD_MEMBERSHIP, NETLINK_DROP_MEMBERSHIP, NETLINK_PKTINFO, NETLINK_BROADCAST_ERROR,
-NETLINK_NO_ENOBUFS, NETLINK_RX_RING, NETLINK_TX_RING,
+NETLINK_NO_ENOBUFS, NETLINK_RX_RING, NETLINK_TX_RING, NETLINK_LISTEN_ALL_NSID,
 };
 
 void netlink_setsockopt(struct sockopt *so)
",40,4
add NETLINK_LIST_MEMBERSHIPS setsockopt," void netlink_rand_socket(struct socket_triplet *st)
 static const unsigned int netlink_opts[] = {
 NETLINK_ADD_MEMBERSHIP, NETLINK_DROP_MEMBERSHIP, NETLINK_PKTINFO, NETLINK_BROADCAST_ERROR,
 NETLINK_NO_ENOBUFS, NETLINK_RX_RING, NETLINK_TX_RING, NETLINK_LISTEN_ALL_NSID,
+NETLINK_LIST_MEMBERSHIPS,
 };
 
 void netlink_setsockopt(struct sockopt *so)
",41,4
"don't touch rec-> when sanity checks fail.

If the checks have failed, everything there is suspect.
Use the on-stack copies instead."," retry:
 
 if (this_child->pid == 0) {
 output(0, ""Sanity check failed. my pid became zero after syscall:%s(%lx, %lx, %lx) was:%d\n"",
-print_syscall_name(rec->nr, rec->do32bit),
+print_syscall_name(syscallnr, do32),
 a1, a2, a3, oldpid);
 dump_childnos();
 dump_childdata(this_child);
 retry:
 if (old != 0) {
 if (rec->tv.tv_sec - old > 60) {
 output(0, ""Sanity check failed. Something stomped on rec->tv after syscall:%s(%lx, %lx, %lx) was:%lx now:%lx.\n"",
-print_syscall_name(rec->nr, rec->do32bit),
+print_syscall_name(syscallnr, do32),
 a1, a2, a3, old, rec->tv.tv_sec);
 dump_childnos();
 dump_childdata(this_child);
 retry:
 if (len != strlen(rec->prebuffer)) {
 output(0, ""Sanity check failed: prebuffer length changed from %d to %d after syscall:%s(%lx, %lx, %lx).\n"",
 len, strlen(rec->prebuffer),
-print_syscall_name(rec->nr, rec->do32bit),
+print_syscall_name(syscallnr, do32),
 a1, a2, a3);
 dump_childnos();
 dump_childdata(this_child);
",124,20
nr_blockdevs can't be negative,"
 #include ""types.h""
 #include ""utils.h""
 
-static int nr_blockdevs = 0;
+static unsigned int nr_blockdevs = 0;
 
 struct bdevlist {
 struct list_head list;
",66,9
printf signedness fix," void __BUG(const char *bugtxt, const char *filename, const char *funcname, unsig
 {
 printf(""BUG!: %s%s%s\n"", ANSI_RED, bugtxt, ANSI_RESET);
 printf(""BUG!: %s\n"", VERSION);
-printf(""BUG!: [%d] %s:%s:%d\n"", getpid(), filename, funcname, lineno);
+printf(""BUG!: [%d] %s:%s:%u\n"", getpid(), filename, funcname, lineno);
 
 show_backtrace();
 
",84,11
printf signedness fixes," static void open_sockets(char *cachefilename)
 type = buffer[1];
 protocol = buffer[2];
 
-printf(""family:%s type:%s protocol:%s (%d)\n"",
+printf(""family:%s type:%s protocol:%s (%u)\n"",
 get_family_name(family),
 decode_type(type),
 get_proto_name(family, protocol), protocol);
 static void open_sockets(char *cachefilename)
 
 }
 
-printf(""%d entries in socket cachefile.\n"", nr_sockets);
+printf(""%u entries in socket cachefile.\n"", nr_sockets);
 
 close(cachefile);
 }
",164,21
seconds won't go negative," void do_uid0_check(void)
 
 outputstd(""ctrl-c now unless you really know what you are doing.\n"");
 for (i = 10; i > 0; i--) {
-outputstd(""Continuing in %d seconds.\r"", i);
+outputstd(""Continuing in %u seconds.\r"", i);
 (void)fflush(stdout);
 sleep(1);
 }
",103,19
Increase length of string when prefixing with ./," const char * generate_pathname(void)
 newpath[0] = '.';
 newpath[1] = '/';
 (void) strncpy(newpath + 2, pathname, len);
+len += 2;
 }
 }
 
",37,7
unsigned var will never be negative," void generate_rand_bytes(unsigned char *ptr, unsigned int len)
 if (RAND_BOOL()) {
 ptr[startoffset++] = '-';
 remain--;
-if (remain <= 0)
+if (remain == 0)
 break;
 }
 
",164,48
fix warning about main not having a return value," int main(int argc, char* argv[])
 }
 
 open_sockets(argv[1]);
+
+exit(EXIT_SUCCESS);
 }
",165,21
make ppoll impossible to fail allocations," static void sanitise_ppoll(struct syscallrecord *rec)
 fds[i].revents = rand_events();
 }
 
-ts = malloc(sizeof(struct timespec));
+ts = zmalloc(sizeof(struct timespec));
 rec->a3 = (unsigned long) ts;
-if (ts == NULL) {
-/* if we set ts to null, ppoll will block indefinitely */
-rec->a3 = 1;
-return;
-}
 ts->tv_sec = 1;
 ts->tv_nsec = 0;
 
",91,9
replace open-coded freeptr," static void sanitise_ppoll(struct syscallrecord *rec)
 
 static void post_ppoll(struct syscallrecord *rec)
 {
-void *ptr;
-
-ptr = (void *) rec->a1;
-if (ptr != NULL)
-free(ptr);
-
-ptr = (void *) rec->a4;
-free(ptr);
+freeptr(&rec->a1);
+freeptr(&rec->a4);
 }
 
 struct syscallentry syscall_ppoll = {
",87,8
remove remaining duplicate code from poll/ppoll unification," struct syscallentry syscall_poll = {
 .post = post_poll,
 };
 
-static short rand_events(void)
-{
-unsigned long r;
-
-r = set_rand_bitmask(ARRAY_SIZE(poll_events), poll_events);
-
-return r;
-}
-
 /*
 * SYSCALL_DEFINE5(ppoll, struct pollfd __user *, ufds, unsigned int, nfds,
  struct timespec __user *, tsp, const sigset_t __user *, sigmask, size_t, sigsetsize)
 static void sanitise_ppoll(struct syscallrecord *rec)
 {
 struct pollfd *fds;
 struct timespec *ts;
-unsigned int num = rand() % 1024;
-unsigned int i;
 
 sanitise_poll(rec);
 
 static void sanitise_ppoll(struct syscallrecord *rec)
 if (fds == NULL)
 return;
 
-for (i = 0 ; i < num; i++) {
-fds[i].fd = get_random_fd();
-fds[i].events = rand_events();
-fds[i].revents = rand_events();
-}
-
 ts = zmalloc(sizeof(struct timespec));
 rec->a3 = (unsigned long) ts;
 ts->tv_sec = 1;
",74,6
pretty print the 'all disabled' case for 32bit.," void deactivate_syscall(unsigned int call, bool do32bit)
 
 void count_syscalls_enabled(void)
 {
+char enablednr[20];
+
 if (biarch == TRUE) {
-output(0, ""32-bit syscalls: %d enabled, %d disabled. ""
+memset(enablednr, 0, sizeof(enablednr));
+
+if (shm->nr_active_32bit_syscalls != 0)
+sprintf(enablednr, ""%d enabled, %d"",
+shm->nr_active_32bit_syscalls,
+max_nr_32bit_syscalls - shm->nr_active_32bit_syscalls);
+else
+sprintf(enablednr, ""all"");
+
+output(0, ""32-bit syscalls: %s disabled. ""
 ""64-bit syscalls: %d enabled, %d disabled.\n"",
-shm->nr_active_32bit_syscalls, max_nr_32bit_syscalls - shm->nr_active_32bit_syscalls,
+enablednr,
 shm->nr_active_64bit_syscalls, max_nr_64bit_syscalls - shm->nr_active_64bit_syscalls);
 } else {
 output(0, ""Enabled %d syscalls. Disabled %d syscalls.\n"",
",386,97
"rename enablednr -> enabledstr.

Also reduce scoping"," void deactivate_syscall(unsigned int call, bool do32bit)
 
 void count_syscalls_enabled(void)
 {
-char enablednr[20];
-
 if (biarch == TRUE) {
-memset(enablednr, 0, sizeof(enablednr));
+char enabledstr[20];
+
+memset(enabledstr, 0, sizeof(enabledstr));
 
 if (shm->nr_active_32bit_syscalls != 0)
-sprintf(enablednr, ""%d enabled, %d"",
+sprintf(enabledstr, ""%d enabled, %d"",
 shm->nr_active_32bit_syscalls,
 max_nr_32bit_syscalls - shm->nr_active_32bit_syscalls);
 else
-sprintf(enablednr, ""all"");
+sprintf(enabledstr, ""all"");
 
 output(0, ""32-bit syscalls: %s disabled. ""
 ""64-bit syscalls: %d enabled, %d disabled.\n"",
-enablednr,
+enabledstr,
 shm->nr_active_64bit_syscalls, max_nr_64bit_syscalls - shm->nr_active_64bit_syscalls);
 } else {
 output(0, ""Enabled %d syscalls. Disabled %d syscalls.\n"",
",386,97
"don't output ""64bit: 0 disabled"" when using -a64"," void count_syscalls_enabled(void)
 {
 if (biarch == TRUE) {
 char enabledstr[20];
+char disabledstr[20];
 
 memset(enabledstr, 0, sizeof(enabledstr));
+memset(disabledstr, 0, sizeof(disabledstr));
 
 if (shm->nr_active_32bit_syscalls != 0)
 sprintf(enabledstr, ""%d enabled, %d"",
 void count_syscalls_enabled(void)
 else
 sprintf(enabledstr, ""all"");
 
+if ((max_nr_64bit_syscalls - shm->nr_active_64bit_syscalls) != 0)
+sprintf(disabledstr, "", %d disabled"",
+max_nr_64bit_syscalls - shm->nr_active_64bit_syscalls);
+
 output(0, ""32-bit syscalls: %s disabled. ""
-""64-bit syscalls: %d enabled, %d disabled.\n"",
+""64-bit syscalls: %d enabled%s.\n"",
 enabledstr,
-shm->nr_active_64bit_syscalls, max_nr_64bit_syscalls - shm->nr_active_64bit_syscalls);
+shm->nr_active_64bit_syscalls,
+disabledstr);
 } else {
 output(0, ""Enabled %d syscalls. Disabled %d syscalls.\n"",
 shm->nr_active_syscalls, max_nr_syscalls - shm->nr_active_syscalls);
",392,98
Fix up a bunch of incorrect RAND_ARRAY uses," static const unsigned int atm_opts[] = {
 
 void atm_setsockopt(struct sockopt *so)
 {
-unsigned char val;
-
-val = RAND_ARRAY(atm_opts);
-so->optname = atm_opts[val];
+so->optname = RAND_ARRAY(atm_opts);
 }
",44,5
clear optval after freeing it," static void sso_socket(struct socket_triplet *triplet, struct sockopt *so, int f
 so->optval = 0;
 
 retry:
-if (so->optval != 0)
+if (so->optval != 0) {
 free((void *) so->optval);
+so->optval = 0;
+}
 
 do_setsockopt(so, triplet);
 
",332,79
clear optname on each do_setsockopt invocation," static void call_inet_sso_ptr(struct sockopt *so, struct socket_triplet *triplet
 */
 void do_setsockopt(struct sockopt *so, struct socket_triplet *triplet)
 {
+so->optname = 0;
+
 /* get a page for the optval to live in.
  * TODO: push this down into the per-proto .func calls
  */
",239,27
"Add POLLFREE symbol for older distros.

Signed-off-by: Vinson Lee <vlee@twitter.com>","
 #include ""random.h""
 #include ""sanitise.h""
 #include ""utils.h""
+#include ""compat.h""
 
 static const unsigned long poll_events[] = {
 POLLIN, POLLPRI, POLLOUT, POLLERR,
",75,6
re-sort the getopt param string.," static void usage(void)
 exit(EXIT_SUCCESS);
 }
 
-static const char paramstr[] = ""a:b:c:C:dDg:hIl:LN:mP:E:pqr:s:T:SV:vx:X"";
+static const char paramstr[] = ""a:b:c:C:dDE:g:hIl:LmN:P:pqr:s:ST:V:vx:X"";
 
 static const struct option longopts[] = {
 { ""arch"", required_argument, NULL, 'a' },
",268,45
fix gcc5 warning about trashed var," static bool handle_sigreturn(void)
 */
 void child_process(void)
 {
-const char *lastop = NULL;
 int ret;
 
 ret = sigsetjmp(ret_jump, 1);
 void child_process(void)
 shm_rw();
 
 while (shm->exit_reason == STILL_RUNNING) {
+const char *lastop = NULL;
 unsigned int i;
 
 periodic_work();
",260,53
only use fallback argument if argtype isn't defined," void generate_syscall_args(struct syscallrecord *rec)
 
 lock(&rec->lock);
 
+//TODO: instead of rand64() do a rand arg type
 entry = syscalls[rec->nr].entry;
 rec->state = PREP;
-rec->a1 = (unsigned long) rand64();
-rec->a2 = (unsigned long) rand64();
-rec->a3 = (unsigned long) rand64();
-rec->a4 = (unsigned long) rand64();
-rec->a5 = (unsigned long) rand64();
-rec->a6 = (unsigned long) rand64();
+if (entry->arg1type == ARG_UNDEFINED)
+rec->a1 = (unsigned long) rand64();
+if (entry->arg2type == ARG_UNDEFINED)
+rec->a2 = (unsigned long) rand64();
+if (entry->arg3type == ARG_UNDEFINED)
+rec->a3 = (unsigned long) rand64();
+if (entry->arg4type == ARG_UNDEFINED)
+rec->a4 = (unsigned long) rand64();
+if (entry->arg5type == ARG_UNDEFINED)
+rec->a5 = (unsigned long) rand64();
+if (entry->arg6type == ARG_UNDEFINED)
+rec->a6 = (unsigned long) rand64();
 
 generic_sanitise(rec);
 if (entry->sanitise)
",353,124
flesh out AF_ALG some more," void alg_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 strncpy((char *)alg->salg_name, hashes[i], len);
 break;
 case 2:
+snprintf((char *)alg->salg_type, 8, ""skcipher"");
+snprintf((char *)alg->salg_name, 8, ""cbc(aes)"");
 break;
 case 3:
 break;
",43,5
"fix get_interesting_32bit_value shifting

This is supposed to shift 0xff through 7 positions, not 31."," static unsigned int get_interesting_32bit_value(void)
 switch (rand() % 10) {
 case 0: return 0x80000000 >> (rand() & 0x1f);// 2^n (1 -> 0x10000)
 case 1: return rand();// 0 -> RAND_MAX (likely 0x7fffffff)
-case 2: return 0xff << (rand() % 25);
+case 2: return (unsigned int) 0xff << (4 * (rand() % 7));
 case 3: return 0xffff0000;
 case 4: return 0xffffe000;
 case 5: return 0xffffff00 | RAND_BYTE();
",94,48
check for memalign failure," void init_shm(void)
 childptrslen &= PAGE_MASK;
 
 shm->children = memalign(page_size, childptrslen);
+if (shm->children == NULL) {
+printf(""Failed to allocate child structures.\n"");
+exit(EXIT_FAILURE);
+}
+
 memset(shm->children, 0, childptrslen);
 
 /* We allocate the childdata structs as shared mappings, because
",67,9
"if main crashes before watchdog has begun, we need to check for it"," static void watchdog(void)
 while (shm->ready == FALSE) {
 unsigned int counter = 0;
 
+if (shm->mainpid != 0) {
+if (check_main_alive() == FALSE)
+return;
+}
+
 while (shm->mainpid == 0) {
 
 if (check_main_alive() == FALSE)
",360,78
add some more cases to the 'create a struct look-alike page' function," static void fabricate_onepage_struct(char *page)
 
 /* 4 byte (32bit) 8 byte (64bit) alignment */
 if (i & ~((__WORDSIZE / 8) - 1)) {
-unsigned long val;
+unsigned long val = 0;
 
 i += sizeof(unsigned long);
 if (i > page_size)
 return;
 
-if (RAND_BOOL())
-val = rand64();
-else
-val = (unsigned long) get_address();
+switch (rand() % 4) {
+case 0:val = rand64();
+break;
+case 1:val = (unsigned long) get_address();
+break;
+case 2:val = (unsigned long) ptr;
+break;
+case 3:val = get_len();
+break;
+}
 
 *(unsigned long *)ptr = val;
 
",200,56
make page_rand be a length we can return," unsigned long get_len(void)
 int i = 0;
 
 if (RAND_BOOL()) {
-switch (rand() % 3) {
+switch (rand() % 4) {
 case 0:return sizeof(char);
 case 1:return sizeof(int);
 case 2:return sizeof(long);
+case 3: return page_size;
 }
 }
 
",40,15
SIGABRT/SIGSEGV in main should be set to default," void setup_main_signals(void)
 /* we want default behaviour for child process signals */
 (void)signal(SIGFPE, SIG_DFL);
 (void)signal(SIGCHLD, SIG_DFL);
+(void)signal(SIGABRT, SIG_DFL);
+(void)signal(SIGSEGV, SIG_DFL);
 
 (void)signal(SIGINT, ctrlc_handler);
 }
",65,9
"fix the ""check for <8gb"" test"," static int init_mmap(void)
 }
 
 while (getline(&buffer, &n, fp) >= 0) {
-unsigned int free;
+unsigned long long free;
 
-if (sscanf(buffer, ""MemFree: %u"", &free) == 1) {
-unsigned long long freegb;
-
-freegb = free / 1024;
-
-if (freegb < GB(8ULL)) {
-printf(""Free memory: %.2fGB\n"", (double) freegb / 1024);
+if (sscanf(buffer, ""MemFree: %llu"", &free) == 1) {
+if ((free * 1024) < GB(8ULL)) {
+printf(""Free memory: %.2fGB\n"", (double) free / 1024 / 1024);
 printf(""Low on memory, disabling mmaping of 1GB pages\n"");
 sizes[5] = page_size;
 return 0;
",180,22
"open urandom just once on startup

We can fail to open it from the child later otherwise, and end up
falling back, and in some cases, seeding with '0' repeatedly. Oops."," int main(int argc, char* argv[])
 num_online_cpus = sysconf(_SC_NPROCESSORS_ONLN);
 max_children = num_online_cpus;/* possibly overridden in params. */
 
+if (init_random() == FALSE)
+exit(EXIT_FAILURE);
+
 set_seed(0);
 
 select_syscall_tables();
",152,35
"mask out a random number of bits from the new seed.

The new seeds are overwhelmingly large 32 bit numbers.
This at least gives some coverage to the lower end."," unsigned int new_seed(void)
 if (read(urandomfd, &bits, sizeof(bits)) != sizeof(bits))
 return fallbackseed();
 
-//printf(""new seed:%u\n"", r);
+bits %= 31;
+bits = max(bits, 8U);
+r &= ((1 << bits) -1);
 
+//printf(""new seed:%u\n"", r);
 return r;
 }
 
",87,17
"if we've filled the socket array, don't try to bind another fd."," static int open_socket(unsigned int domain, unsigned int type, unsigned int prot
 
 nr_sockets++;
 
+if (nr_sockets == NR_SOCKET_FDS)
+goto skip_bind;
+
 /* Sometimes, listen on created sockets. */
 if (RAND_BOOL()) {
 int ret, one = 1;
",329,78
select: fix shifting out of range of datatype in FD_SET," static void sanitise_select(struct syscallrecord *rec)
 
 /* set some random fd's. */
 for (i = 0; i < rand32() % 10; i++) {
-FD_SET(rand32() % 1024, rfds);
-FD_SET(rand32() % 1024, wfds);
-FD_SET(rand32() % 1024, exfds);
+FD_SET(rand32() % (__NFDBITS - 1), rfds);
+FD_SET(rand32() % (__NFDBITS - 1), wfds);
+FD_SET(rand32() % (__NFDBITS - 1), exfds);
 }
 
 rec->a2 = (unsigned long) rfds;
",51,3
re-add accidentally dropped netlink setsockopt's," void netlink_rand_socket(struct socket_triplet *st)
 
 static const unsigned int netlink_opts[] = {
 NETLINK_ADD_MEMBERSHIP, NETLINK_DROP_MEMBERSHIP, NETLINK_PKTINFO, NETLINK_BROADCAST_ERROR,
-NETLINK_NO_ENOBUFS, NETLINK_RX_RING, NETLINK_TX_RING,
+NETLINK_NO_ENOBUFS, NETLINK_RX_RING, NETLINK_TX_RING, NETLINK_LISTEN_ALL_NSID,
+NETLINK_LIST_MEMBERSHIPS,
 };
 
 void netlink_setsockopt(struct sockopt *so)
",39,4
decide at random at startup whether or we bind processes to CPUs," static void bind_child_to_cpu(struct childdata *child)
 cpu_set_t set;
 unsigned int cpudest;
 
+if (no_bind_to_cpu == TRUE)
+return;
+
 if (sched_getaffinity(child->pid, sizeof(set), &set) != 0)
 return;
 
",262,54
TODO: check loadavg before sanity checks," retry:
 }
 
 if (old != 0) {
+// FIXME: Should factor in loadavg here, as with enough pids, a child can exceed 60s
+// without getting scheduled.
 if (rec->tv.tv_sec - old > 60) {
 output(0, ""Sanity check failed. Something stomped on rec->tv after syscall:%s(%lx, %lx, %lx) was:%lx now:%lx.\n"",
 print_syscall_name(syscallnr, do32),
",124,20
"if an fd provider fails, just skip over it."," unsigned int open_fds(void)
 
 list_for_each(node, &fd_providers->list) {
 struct fd_provider *provider;
-int ret;
 
 provider = (struct fd_provider *) node;
 
 if (provider->enabled == FALSE)
 continue;
 
-ret = provider->open();
-if (ret == FALSE)
-return FALSE;
-
-num_fd_providers_enabled++;
+provider->enabled = provider->open();
+if (provider->enabled == TRUE)
+num_fd_providers_enabled++;
 }
 
 output(0, ""Enabled %d fd providers.\n"", num_fd_providers_enabled);
",173,25
decnet: use RAND_BOOL()," void decnet_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 dn->sdn_objnamel = rand() % 16;
 for (i = 0; i < dn->sdn_objnamel; i++)
 dn->sdn_objname[i] = rand();
-dn->sdn_add.a_len = rand() % 2;
+dn->sdn_add.a_len = RAND_BOOL();
 dn->sdn_add.a_addr[0] = rand();
 dn->sdn_add.a_addr[1] = rand();
 *addr = (struct sockaddr *) dn;
",48,5
move_pages: use RAND_BOOL()," static void sanitise_move_pages(struct syscallrecord *rec)
 /* nodes = array of ints specifying desired location for each page */
 nodes = calloc(count, sizeof(int));
 for (i = 0; i < count; i++)
-nodes[i] = (int) rand() % 2;
+nodes[i] = (int) RAND_BOOL();
 rec->a4 = (unsigned long) nodes;
 
 /* status = array of ints returning status of each page.*/
",62,5
munmap: use ONE_IN() and RAND_BOOL to make clearer what's intended," static void sanitise_munmap(struct syscallrecord *rec)
 
 action = 0;
 
-switch (rand() % 20) {
-case 0:
+if (ONE_IN(20) == TRUE) {
 /* delete the whole mapping. */
 action = WHOLE;
 return;
+}
 
-case 1 ... 10:
+if (RAND_BOOL()) {
 /* unmap a range of the mapping. */
 nr_pages = map->size / page_size;
 offsetpagenr = (rand() % nr_pages);
 static void sanitise_munmap(struct syscallrecord *rec)
 len = (rand() % (nr_pages - offsetpagenr)) + 1;
 len *= page_size;
 rec->a2 = len;
-return;
-
-case 11 ... 19:
+} else {
 /* just unmap 1 page of the mapping. */
 rec->a1 = (unsigned long) map->ptr;
 rec->a1 += (rand() % map->size) & PAGE_MASK;
 rec->a2 = page_size;
-return;
-
-default:
-break;
 }
 }
 
",54,6
perf_event_open: use RAND_BOOL()," static long long random_branch_sample_type(void)
 
 long long branch_sample = 0;
 
-if (rand() % 2)
+if (RAND_BOOL())
 return rand64();
 
 if (RAND_BOOL())
 void sanitise_perf_event_open(struct syscallrecord *rec)
 /* requires ROOT to select specific CPU if pid==-1 (all processes) */
 /* -1 means all CPUs */
 
-switch(rand() % 2) {
-case 0:
+if (RAND_BOOL()) {
 /* Any CPU */
 rec->a3 = -1;
-break;
-case 1:
+} else {
 /* Default to the get_cpu() value */
 /* set by ARG_CPU */
-default:
-break;
 }
 
 /* group_fd */
",1072,264
"watchdog: wait longer at startup

if we're starting a *lot* of processes, it can take longer than the
1000 retries in this loop when we only wait a microsecond each time."," static void watchdog(void)
 if (shm->exit_reason != STILL_RUNNING)
 return;
 
-usleep(1);
+sleep(1);
 }
 }
 
",360,78
random: remove unnecessary local var,"
 void generate_rand_bytes(unsigned char *ptr, unsigned int len)
 {
 unsigned int i;
-unsigned char choice = rand() % 3;
 unsigned int startoffset = 0, remain;
 unsigned char separators[3] = { ' ', '-', '\0' };
 unsigned char separator;
 
-switch (choice) {
+switch (rand() % 3) {
 case 0:
 /* Complete garbage. */
 for (i = 0; i < len; i++)
",163,48
compile-time calculate the separator array size," void generate_rand_bytes(unsigned char *ptr, unsigned int len)
 {
 unsigned int i;
 unsigned int startoffset = 0, remain;
-unsigned char separators[3] = { ' ', '-', '\0' };
+unsigned char separators[] = { ' ', '-', '\0', };
 unsigned char separator;
 
 switch (rand() % 3) {
 void generate_rand_bytes(unsigned char *ptr, unsigned int len)
 case 2:
 /* numbers (for now, decimal only) */
 
-separator = separators[rand() % 3];
+separator = separators[rand() % sizeof(separators)];
 
 remain = len;
 
",163,48
"rand: add ':', ',' and '.' as possible separators"," void generate_rand_bytes(unsigned char *ptr, unsigned int len)
 {
 unsigned int i;
 unsigned int startoffset = 0, remain;
-unsigned char separators[] = { ' ', '-', '\0', };
+unsigned char separators[] = { ':', ',', '.', ' ', '-', '\0', };
 unsigned char separator;
 
 switch (rand() % 3) {
",163,48
"socket: Fix missing-field-initializers build error.

This patch fixes this build error.

 CC	syscalls/socket.o
syscalls/socket.c:48:2: error: missing initializer for field func of const struct socket_ptr [-Werror=missing-field-initializers]
 [AF_ECONET] = { }, // DEAD
 ^
syscalls/socket.c:22:9: note: func declared here
 void (*func)(struct socket_triplet *st);
 ^

Signed-off-by: Vinson Lee <vlee@twitter.com>"," static const struct socket_ptr socketptrs[] = {
 [AF_NETLINK] = { .func = &netlink_rand_socket },
 [AF_PACKET] = { .func = &packet_rand_socket },
 [AF_ASH] = { .func = NULL },
-[AF_ECONET] = { },// DEAD
+[AF_ECONET] = { .func = NULL },// DEAD
 [AF_ATMSVC] = { .func = NULL },
 [AF_RDS] = { .func = &rds_rand_socket },
 [AF_SNA] = { .func = NULL },
",132,20
"Add /dev/kmem to the list of dangerous devices that Trinity should not access.

Writing to it may cause kernel memory corruption."," static int ignore_files(const char *path)
 ""/proc/sysrq-trigger"", ""/proc/kmem"", ""/proc/kcore"",
 
 /* dangerous/noisy/annoying stuff in /dev */
-""/dev/log"", ""/dev/mem"", ""/dev/kmsg"",
+""/dev/log"", ""/dev/mem"", ""/dev/kmsg"", ""/dev/kmem"",
 NULL
 };
 
",306,67
"remove pause param as it doesn't add any value any more

Signed-off-by: Praveen K. Pandey <praveen@linux.vnet.ibm.com>","
 #include ""debug.h""
 #include ""locks.h""
 #include ""log.h""
-#include ""params.h""// dopause
 #include ""pids.h""
 #include ""random.h""
 #include ""shm.h""
 retry:
  */
 len = strlen(rec->prebuffer);
 
-/* If we're going to pause, might as well sync pre-syscall */
-if (dopause == TRUE)
-synclogs();
-
 old = rec->tv.tv_sec;
 do_syscall(rec);
 
 retry:
 /* Output the syscall result, and clean up */
 output_syscall_postfix(rec);
 
-if (dopause == TRUE)
-sleep(1);
-
 handle_syscall_ret(rec);
 
 return TRUE;
",119,18
add a --dry-run argument to disable the 'do the syscall' path.," unsigned int user_specified_children = 0;
 bool do_specific_domain = FALSE;
 bool no_domains[TRINITY_PF_MAX];
 
+bool dry_run = FALSE;
 bool show_syscall_list = FALSE;
 bool show_ioctl_list = FALSE;
 unsigned char quiet_level = 0;
 static const struct option longopts[] = {
 { ""dropprivs"", no_argument, NULL, 'X'},
 { ""debug"", no_argument, NULL, 'D' },
 { ""disable-fds"", required_argument, NULL, 0 },
+{ ""dry-run"", no_argument, NULL, 0 },
 { ""enable-fds"", required_argument, NULL, 0 },
 { ""exclude"", required_argument, NULL, 'x' },
 { ""group"", required_argument, NULL, 'g' },
 void parse_args(int argc, char *argv[])
 if (strcmp(""enable-fds"", longopts[opt_index].name) == 0)
 process_fds_param(optarg, TRUE);
 
+if (strcmp(""dry-run"", longopts[opt_index].name) == 0)
+dry_run = TRUE;
+
 break;
 }
 }
",267,45
"sketch out the basics for a generic object cache

right now this does nothing.","
+#include ""list.h""
+#include ""objects.h""
+#include ""shm.h""
+#include ""trinity.h""
+#include ""utils.h""
+
+struct object * alloc_object(void *ptr, enum objecttype type)
+{
+struct object *obj;
+
+obj = zmalloc(sizeof(struct object));
+
+obj->type = type;
+obj->ptr = ptr;
+
+return obj;
+}
+
+void add_to_global_objects(struct object *obj)
+{
+list_add(obj->list, shm->global_objects[obj->type].list);
+}
+
+void add_to_child_objects(struct object *obj)
+{
+list_add(obj->list, this_child->objects[obj->type].list);
+}
+
+void destroy_object(struct object *obj)
+{
+// Remove it from the list first so nothing else uses it.
+list_del(obj->list);
+
+// Call the destructor
+obj->destroy(obj->ptr);
+
+// free obj
+free(obj);
+}
",27,4
maintain a count of objects in each object list," struct object * alloc_object(void *ptr, enum objecttype type)
 void add_to_global_objects(struct object *obj)
 {
 list_add(obj->list, shm->global_objects[obj->type].list);
+shm->global_objects[obj->type].num_entries++;
 }
 
 void add_to_child_objects(struct object *obj)
 {
 list_add(obj->list, this_child->objects[obj->type].list);
+this_child->objects[obj->type].num_entries++;
 }
 
-void destroy_object(struct object *obj)
+void destroy_object(struct object *obj, bool global)
 {
-// Remove it from the list first so nothing else uses it.
+struct objhead *head;
+
+if (global == TRUE)
+head = &shm->global_objects[obj->type];
+else
+head = &this_child->objects[obj->type];
+
 list_del(obj->list);
 
-// Call the destructor
+head->num_entries--;
+
 obj->destroy(obj->ptr);
 
-// free obj
 free(obj);
 }
",35,5
switch to just a single add_object function," struct object * alloc_object(void *ptr, enum objecttype type)
 return obj;
 }
 
-void add_to_global_objects(struct object *obj)
+void add_object(struct object *obj, bool global)
 {
-list_add(obj->list, shm->global_objects[obj->type].list);
-shm->global_objects[obj->type].num_entries++;
-}
+struct objhead *head;
 
-void add_to_child_objects(struct object *obj)
-{
-list_add(obj->list, this_child->objects[obj->type].list);
-this_child->objects[obj->type].num_entries++;
+if (global == OBJ_GLOBAL)
+head = &shm->global_objects[obj->type];
+else
+head = &this_child->objects[obj->type];
+
+list_add(obj->list, head->list);
+head->num_entries++;
 }
 
 void destroy_object(struct object *obj, bool global)
 {
 struct objhead *head;
 
-if (global == TRUE)
+if (global == OBJ_GLOBAL)
 head = &shm->global_objects[obj->type];
 else
 head = &this_child->objects[obj->type];
",35,5
object list initialization," void destroy_object(struct object *obj, bool global, enum objecttype type)
 
 free(obj);
 }
+
+void init_object_lists(bool global)
+{
+struct objhead *head;
+unsigned int i;
+
+for (i = 0; i < MAX_OBJECT_TYPES; i++) {
+if (global == OBJ_GLOBAL)
+head = &shm->global_objects[i];
+else
+head = &this_child->objects[i];
+
+INIT_LIST_HEAD(head->list);
+}
+}
",46,8
introduce a function to pick a random object," void init_object_lists(bool global)
 INIT_LIST_HEAD(head->list);
 }
 }
+
+struct object * get_random_object(enum objecttype type, bool global)
+{
+struct objhead *head;
+struct list_head *node, *list;
+unsigned int i, j = 0;
+
+if (global == OBJ_GLOBAL)
+head = &shm->global_objects[type];
+else
+head = &this_child->objects[type];
+
+list = head->list;
+
+i = rand() % head->num_entries;
+
+list_for_each(node, list) {
+struct object *m;
+
+m = (struct object *) node;
+
+if (i == j)
+return m;
+j++;
+}
+return NULL;
+}
",66,11
add new objects to the tail of lists.," void add_object(struct object *obj, bool global, enum objecttype type)
 else
 head = &this_child->objects[type];
 
-list_add(obj->list, head->list);
+list_add_tail(obj->list, head->list);
 head->num_entries++;
 }
 
",66,11
convert the per-child mmaps list to the object cache," static void reinit_child(struct childdata *child)
 memset(&child->syscall, 0, sizeof(struct syscallrecord));
 memset(&child->previous, 0, sizeof(struct syscallrecord));
 
-child->num_mappings = 0;
 child->seed = 0;
 child->kill_count = 0;
 child->dontkillme = FALSE;
 void init_child(struct childdata *child, int childno)
 
 set_seed(this_child);
 
-init_child_mappings(child);
+init_child_mappings();
 
 dirty_random_mapping();
 
",261,54
"move the object destructor to the objhead

rather that duplicate it once for every object."," void destroy_object(struct object *obj, bool global, enum objecttype type)
 
 head->num_entries--;
 
-obj->destroy(obj->ptr);
+head->destroy(obj);
 
 free(obj);
 }
",66,11
move mapping struct into a union in the object structs," void init_child_mappings(void)
  * will be faulted into the child when they get accessed.
  */
 list_for_each(node, &initial_mappings->list) {
-struct map *m, *newmap;
+struct map *m;
 struct object *newobj;
 
 m = (struct map *) node;
 
-newobj = alloc_object(m->ptr);
-newmap = (struct map *) newobj;
-newmap->name = strdup(m->name);
-newmap->size = m->size;
-newmap->prot = m->prot;
+newobj = zmalloc(sizeof(struct object));
+newobj->map.ptr = m->ptr;
+newobj->map.name = strdup(m->name);
+newobj->map.size = m->size;
+newobj->map.prot = m->prot;
 /* We leave type as 'INITIAL' until we change the mapping
  * by mprotect/mremap/munmap etc..
  */
-newmap->type = TRINITY_MAP_INITIAL;
+newobj->map.type = TRINITY_MAP_INITIAL;
 add_object(newobj, OBJ_LOCAL, OBJ_MMAP);
 }
 }
",76,10
convert global mmaps list to use the global object cache," struct map * get_map(void)
 */
 void init_child_mappings(void)
 {
-struct list_head *node;
+struct list_head *globallist, *node;
 
 init_object_lists(OBJ_LOCAL);
 
+globallist = shm->global_objects[OBJ_MMAP].list;
+
 /* Copy the initial mapping list to the child.
  * Note we're only copying pointers here, the actual mmaps
  * will be faulted into the child when they get accessed.
  */
-list_for_each(node, &initial_mappings->list) {
+list_for_each(node, globallist) {
 struct map *m;
 struct object *newobj;
 
",77,10
use the map struct in the object when dumping the list.," static void dump_initial_mappings(void)
 output(2, ""There are %d entries in the map table\n"", head->num_entries);
 
 list_for_each(node, list) {
+struct object *obj;
 struct map *m;
 
-m = (struct map *) node;
-output(2, "" start: %p name: %s\n"", m->ptr, m->name);
+obj = (struct object *) node;
+m = &obj->map;
+output(2, "" start: %p size:%d name: %s\n"", m->ptr, m->size, m->name);
 }
 }
 
",88,7
put the listhead directly in the object," void add_object(struct object *obj, bool global, enum objecttype type)
 else
 head = &this_child->objects[type];
 
-list_add_tail(obj->list, head->list);
+list_add_tail(&obj->list, head->list);
 head->num_entries++;
 }
 
 void destroy_object(struct object *obj, bool global, enum objecttype type)
 else
 head = &this_child->objects[type];
 
-list_del(obj->list);
+list_del(&obj->list);
 
 head->num_entries--;
 
 void init_object_lists(bool global)
 else
 head = &this_child->objects[i];
 
+head->list = zmalloc(sizeof(struct object));
 INIT_LIST_HEAD(head->list);
 }
 }
",60,10
get map struct from the object," static void alloc_zero_map(unsigned long size, int prot, const char *name)
 }
 
 new = zmalloc(sizeof(struct object));
-new->map.name = strdup(name);
 new->map.size = size;
 new->map.prot = prot;
 new->map.type = TRINITY_MAP_INITIAL;
 void destroy_initial_mappings(void)
 list = head->list;
 
 list_for_each_safe(node, tmp, list) {
-m = (struct map *) node;
+struct object *obj;
+
+obj = (struct object *) node;
+m = &obj->map;
 
 munmap(m->ptr, m->size);
 free(m->name);
",89,7
"destroy the obj, not the map"," void destroy_initial_mappings(void)
 {
 struct list_head *node, *list, *tmp;
 struct objhead *head;
-struct map *m;
 
 head = &shm->global_objects[OBJ_MMAP];
 list = head->list;
 
 list_for_each_safe(node, tmp, list) {
 struct object *obj;
+struct map *m;
 
 obj = (struct object *) node;
 m = &obj->map;
 void destroy_initial_mappings(void)
 munmap(m->ptr, m->size);
 free(m->name);
 
-destroy_object((struct object *) m, OBJ_GLOBAL, OBJ_MMAP);
+destroy_object(obj, OBJ_GLOBAL, OBJ_MMAP);
 }
 
 head->num_entries = 0;
",89,7
make getmap get the map from the obj,"
 */
 struct map * get_map(void)
 {
+struct object *obj;
 struct map *map;
 bool global;
 
 struct map * get_map(void)
 else
 global = OBJ_LOCAL;
 
-map = (struct map *) get_random_object(OBJ_MMAP, global);
+obj = get_random_object(OBJ_MMAP, global);
+map = &obj->map;
 
 return map;
 }
",80,10
do first alloc at first add_object instead of in init," void add_object(struct object *obj, bool global, enum objecttype type)
 else
 head = &this_child->objects[type];
 
+if (head->list == NULL) {
+head->list = zmalloc(sizeof(struct object));
+INIT_LIST_HEAD(head->list);
+}
+
 list_add_tail(&obj->list, head->list);
 head->num_entries++;
 }
 void destroy_object(struct object *obj, bool global, enum objecttype type)
 
 head->num_entries--;
 
-head->destroy(obj);
+if (head->destroy != NULL)
+head->destroy(obj);
 
 free(obj);
 }
 void init_object_lists(bool global)
 else
 head = &this_child->objects[i];
 
-head->list = zmalloc(sizeof(struct object));
-INIT_LIST_HEAD(head->list);
+head->list = NULL;
+head->num_entries = 0;
 }
 }
 
",65,12
add destructor for maps," struct map * get_map(void)
 return map;
 }
 
+static void map_destructor(struct object *obj)
+{
+struct map *map;
+
+map = &obj->map;
+printf(""Freeing %s\n"", map->name);
+free(map->name);
+}
+
 /*
 * Set up a childs local mapping list.
 * A child inherits the initial mappings, and will add to them
 struct map * get_map(void)
 void init_child_mappings(void)
 {
 struct list_head *globallist, *node;
+struct objhead *head;
 
 init_object_lists(OBJ_LOCAL);
 
+head = &this_child->objects[OBJ_MMAP];
+head->destroy = &map_destructor;
+
 globallist = shm->global_objects[OBJ_MMAP].list;
 
 /* Copy the initial mapping list to the child.
",90,11
use container_of to map from map back to object," void * __zmalloc(size_t size, const char *func);
 # define offsetof(type, member)((size_t) &((type *) 0)->member)
 #endif
 
+#define container_of(ptr, type, member) ({ \
+const typeof( ((type *)0)->member ) *__mptr = (ptr); \
+(type *)( (char *)__mptr - offsetof(type,member) );})
+
 /*
 * swap - swap value of @a and @b
 */
",13,1
Wire up phonet_rand_socket," static const struct socket_ptr socketptrs[] = {
 [AF_IUCV] = { .func = NULL },
 [AF_RXRPC] = { .func = NULL },
 [AF_ISDN] = { .func = NULL },
-[AF_PHONET] = { .func = NULL },
+[AF_PHONET] = { .func = &phonet_rand_socket },
 [AF_IEEE802154] = { .func = NULL },
 #ifdef USE_CAIF
 [AF_CAIF] = { .func = &caif_rand_socket },
",132,20
"for syscalls with >1 ARG_FD, don't always reuse the 1st ARG_FD"," unsigned int open_fds(void)
 return TRUE;
 }
 
-static int get_new_random_fd(void)
+int get_new_random_fd(void)
 {
 struct list_head *node;
 int fd = -1;
",173,25
silence another annoying gcc false positive," static int open_file(void)
 int ret;
 int tries = 0;
 int fcntl_flags;
-int flags, randflags;
+int flags, randflags = 0;
 bool opened_with_fopen = FALSE;
 
 retry:
",306,67
and another gcc false positive," static int open_file(void)
 int fd;
 int ret;
 int tries = 0;
-int fcntl_flags;
+int fcntl_flags = 0;
 int flags, randflags = 0;
 bool opened_with_fopen = FALSE;
 
",306,67
move get_random_fd proto to fd.h,"
 * When an error occurs, epoll_ctl() returns -1 and errno is set appropriately.
 */
 #include <sys/epoll.h>
+#include ""fd.h""
 #include ""sanitise.h""
 #include ""random.h""
 #include ""utils.h""
",42,2
NETLINK_SOCK_DIAG uses the type field for its own purposes.," void netlink_rand_socket(struct socket_triplet *st)
 st->type = SOCK_DGRAM;
 
 st->protocol = rand() % (_NETLINK_MAX + 1);
+
+if (st->protocol == NETLINK_SOCK_DIAG)
+st->type = rand() % 136;
 }
 
 static const unsigned int netlink_opts[] = {
",41,5
"Fix ""O_CREAT/O_TMPFILE without mode"" error in open_file()

 > *** invalid open call: O_CREAT or O_TMPFILE without mode ***:
 > ./trinity terminated

There's one more source of such crashes: open_file() in fds/files.c"," retry_flags:
 
 if (RAND_BOOL()) {
 randflags = get_o_flags();
-fd = open(filename, flags | randflags | O_NONBLOCK);
+fd = open(filename, flags | randflags | O_NONBLOCK, 0666);
 } else {
 fd = open_with_fopen(filename, flags);
 fcntl_flags = random_fcntl_setfl_flags();
",306,67
"Free correct argument in post_ppoll()

sanitise_ppoll() allocates first and third arguments and we need to free
them in post_ppoll(), not first and fourth.

Signed-off-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>"," static void sanitise_ppoll(struct syscallrecord *rec)
 static void post_ppoll(struct syscallrecord *rec)
 {
 freeptr(&rec->a1);
-freeptr(&rec->a4);
+freeptr(&rec->a3);
 }
 
 struct syscallentry syscall_ppoll = {
",76,6
"change syscall ->arglist.values to a pointer

Thus allowing for some deduping where some syscalls share common flags
(open, recv, send, etc..)"," struct syscallentry syscall_accept = {
 *
 */
 
+static unsigned long accept4_flags[] = {
+SOCK_NONBLOCK, SOCK_CLOEXEC,
+};
+
 struct syscallentry syscall_accept4 = {
 .name = ""accept4"",
 .num_args = 4,
 struct syscallentry syscall_accept4 = {
 .arg4type = ARG_LIST,
 .arg4list = {
 .num = 2,
-.values = { SOCK_NONBLOCK, SOCK_CLOEXEC },
+.values = accept4_flags,
 },
 .rettype = RET_FD,
 .flags = NEED_ALARM,
",41,1
"use a macro to count arglist members

bonus bug fix: the count for fcntl flags was wrong."," struct syscallentry syscall_accept4 = {
 .arg3type = ARG_SOCKADDRLEN,
 .arg4name = ""flags"",
 .arg4type = ARG_LIST,
-.arg4list = {
-.num = 2,
-.values = accept4_flags,
-},
+.arg4list = ARGLIST(accept4_flags),
 .rettype = RET_FD,
 .flags = NEED_ALARM,
 .sanitise = sanitise_accept,// use same as accept.
",38,1
"change syscall ->errnos.values to a pointer

allowing deduping, as we did for ->arglist.values"," static unsigned long getrandom_flags[] = {
 GRND_NONBLOCK, GRND_RANDOM,
 };
 
+static int getrandom_errnos[] = {
+EINVAL, EFAULT, EAGAIN, EINTR,
+};
+
 struct syscallentry syscall_getrandom = {
 .name = ""getrandom"",
 .num_args = 3,
 struct syscallentry syscall_getrandom = {
 .arg3list = ARGLIST(getrandom_flags),
 .errnos = {
 .num = 4,
-.values = {
-EINVAL, EFAULT, EAGAIN, EINTR,
-},
+.values = getrandom_errnos,
 },
 .sanitise = sanitise_getrandom,
 };
",29,1
use a macro to count errno list members," struct syscallentry syscall_execve = {
 .post = post_execve,
 .group = GROUP_VFS,
 .flags = EXTRA_FORK,
-.errnos = {
-.num = 17,
-.values = execve_errnos,
-},
+.errnos = ERRNOS(execve_errnos),
 };
 
 static unsigned long execveat_flags[] = {
 struct syscallentry syscall_execveat = {
 .post = post_execveat,
 .group = GROUP_VFS,
 .flags = EXTRA_FORK,
-.errnos = {
-.num = 17,
-.values = execve_errnos,
-},
+.errnos = ERRNOS(execve_errnos),
 };
",102,9
"move the object initialization up a level, out of the mm code."," void setup_initial_mappings(void)
 //GB(1),// disabled for now, due to OOM.
 };
 
-init_object_lists(OBJ_GLOBAL);
-
 alloc_zero_map(page_size, PROT_READ | PROT_WRITE, ""PROT_READ | PROT_WRITE"");
 alloc_zero_map(page_size, PROT_READ, ""PROT_READ"");
 alloc_zero_map(page_size, PROT_WRITE, ""PROT_WRITE"");
",88,7
convert the pipe fd code over to use the object cache,"
 */
 #include <fcntl.h>
 #include <stdlib.h>
+#include ""pipes.h""
 #include ""sanitise.h""
 #include ""shm.h""
 #include ""syscall.h""

 static void sanitise_tee(struct syscallrecord *rec)
 {
 if ((rand() % 10) > 0) {
-rec->a1 = shm->pipe_fds[rand() % MAX_PIPE_FDS];
-rec->a2 = shm->pipe_fds[rand() % MAX_PIPE_FDS];
+rec->a1 = get_rand_pipe_fd();
+rec->a2 = get_rand_pipe_fd();
 }
 }
 
",33,2
convert the file fd code over to use the object cache,"
 
 unsigned int files_in_index = 0;
 const char **fileindex;
-unsigned int nr_file_fds = 0;
 
 struct namelist {
 struct list_head list;
 static int open_files(void)
 return FALSE;
 
 for (i = 0; i < nr_to_open; i++) {
+struct object *obj;
 int fd;
 
 fd = open_file();
 
-shm->file_fds[i] = fd;
-nr_file_fds++;
+obj = zmalloc(sizeof(struct object));
+obj->filefd = fd;
+add_object(obj, OBJ_GLOBAL, OBJ_FD_FILE);
 }
 return TRUE;
 }
 const char * get_filename(void)
 
 static int get_rand_file_fd(void)
 {
-unsigned int fd_index;
+struct object *obj;
 
-if (nr_file_fds == 0)
+if (shm->global_objects[OBJ_FD_FILE].num_entries == 0)
 return -1;
 
-fd_index = rand() % nr_file_fds;
-return shm->file_fds[fd_index];
+obj = get_random_object(OBJ_FD_FILE, OBJ_GLOBAL);
+return obj->filefd;
 }
 
 const struct fd_provider file_fd_provider = {
",307,67
add an alloc_object helper," static int open_files(void)
 
 fd = open_file();
 
-obj = zmalloc(sizeof(struct object));
+obj = alloc_object();
 obj->filefd = fd;
 add_object(obj, OBJ_GLOBAL, OBJ_FD_FILE);
 }
",307,67
convert the perf fd code over to use the object cache," static int open_perf_fds(void)
 
 fd = syscall(__NR_perf_event_open, rec->a1, rec->a2, rec->a3, rec->a4, rec->a5);
 if (fd != -1) {
-shm->perf_fds[i] = fd;
-output(2, ""fd[%d] = perf\n"", shm->perf_fds[i]);
+struct object *obj;
+
+obj = alloc_object();
+obj->perffd = fd;
+add_object(obj, OBJ_GLOBAL, OBJ_FD_PERF);
+
+output(2, ""fd[%d] = perf\n"", fd);
 i++;
 } else {
 /* If ENOSYS, bail early rather than do MAX_PERF_FDS retries */
 static int open_perf_fds(void)
 
 static int get_rand_perf_fd(void)
 {
-if (shm->perf_fds[0] == 0)/* perf unavailable/disabled. */
+struct object *obj;
+
+/* check if perf unavailable/disabled. */
+if (shm->global_objects[OBJ_FD_PERF].num_entries == 0)
 return -1;
 
-return shm->perf_fds[rand() % MAX_PERF_FDS];
+obj = get_random_object(OBJ_FD_PERF, OBJ_GLOBAL);
+return obj->perffd;
 }
 
 const struct fd_provider perf_fd_provider = {
",48,6
convert epoll fd code over to use the object cache," static int open_epoll_fds(void)
 fd = epoll_create1(EPOLL_CLOEXEC);
 
 if (fd != -1) {
-shm->epoll_fds[i] = fd;
-output(2, ""fd[%d] = epoll\n"", shm->epoll_fds[i]);
+struct object *obj;
+
+obj = alloc_object();
+obj->perffd = fd;
+add_object(obj, OBJ_GLOBAL, OBJ_FD_EPOLL);
+
+output(2, ""fd[%d] = epoll\n"", fd);
 i++;
 } else {
 /* not sure what happened. */
 static int open_epoll_fds(void)
 
 static int get_rand_epoll_fd(void)
 {
-return shm->epoll_fds[rand() % MAX_EPOLL_FDS];
+struct object *obj;
+
+obj = get_random_object(OBJ_FD_EPOLL, OBJ_GLOBAL);
+return obj->epollfd;
 }
 
 const struct fd_provider epoll_fd_provider = {
",47,5
int is big enough for eventfd flags,"
 static int open_eventfd_fds(void)
 {
 unsigned int i;
-unsigned long flags[] = {
+unsigned int flags[] = {
 0,
 EFD_NONBLOCK,
 EFD_NONBLOCK | EFD_SEMAPHORE,
",54,5
convert testfilefd over to use the object cache," static int open_testfile(char *filename)
 static int open_testfile_fds(void)
 {
 char *filename;
-unsigned int i = 1;
+unsigned int i = 0;
 unsigned int fails = 0;
 
 filename = zmalloc(64);
 
-while (i <= MAX_TESTFILE_FDS) {
+while (i < MAX_TESTFILE_FDS) {
+struct object *obj;
 int fd;
 
 sprintf(filename, ""trinity-testfile%u"", i);
 
 fd = open_testfile(filename);
 if (fd != -1) {
-shm->testfile_fds[i - 1] = fd;
+obj = alloc_object();
+obj->testfilefd = fd;
+add_object(obj, OBJ_GLOBAL, OBJ_FD_TESTFILE);
+
 i++;
 fails = 0;
 } else {
 static int open_testfile_fds(void)
 
 static int get_rand_testfile_fd(void)
 {
-return shm->testfile_fds[rand() % MAX_TESTFILE_FDS];
+struct object *obj;
+
+/* check if testfilefd's unavailable/disabled. */
+if (shm->global_objects[OBJ_FD_TESTFILE].num_entries == 0)
+return -1;
+
+obj = get_random_object(OBJ_FD_TESTFILE, OBJ_GLOBAL);
+return obj->testfilefd;
 }
 
 const struct fd_provider testfile_fd_provider = {
",78,10
convert socketfd code to object cache,"
 
 static int socket_fd_test(int fd, const struct stat *st __attribute__((unused)))
 {
-unsigned i;
+struct list_head *globallist, *node;
 
-for (i=0; i < nr_sockets; ++i)
-if (shm->sockets[i].fd == fd)
+globallist = shm->global_objects[OBJ_FD_SOCKET].list;
+
+list_for_each(node, globallist) {
+struct object *obj;
+struct socketinfo *si;
+
+obj = (struct object *) node;
+si = &obj->sockinfo;
+
+if (si->fd == fd)
 return 0;
+}
 
 return -1;
 }
",160,2
initialize the listhead on new objects,"
 
 struct object * alloc_object(void)
 {
-return zmalloc(sizeof(struct object));
+struct object *obj;
+obj = zmalloc(sizeof(struct object));
+INIT_LIST_HEAD(&obj->list);
+return obj;
 }
 
 void add_object(struct object *obj, bool global, enum objecttype type)
",72,13
check for epoll init failure," static int get_rand_epoll_fd(void)
 {
 struct object *obj;
 
+if (shm->global_objects[OBJ_FD_EPOLL].num_entries == 0)
+return -1;
+
 obj = get_random_object(OBJ_FD_EPOLL, OBJ_GLOBAL);
 return obj->epollfd;
 }
",49,6
destroy the network sockets in the same process that created them.," int main(int argc, char* argv[])
 
 /* check if we ctrl'c or something went wrong during init. */
 if (shm->exit_reason != STILL_RUNNING)
-goto cleanup_fds;
+goto abort_early;
 
 init_watchdog();
 
 int main(int argc, char* argv[])
 
 main_loop();
 
+close_sockets();
+
 shm->mainpid = 0;
 _exit(EXIT_SUCCESS);
 }
 int main(int argc, char* argv[])
 output(0, ""Ran %ld syscalls. Successes: %ld Failures: %ld\n"",
 shm->stats.total_syscalls_done - 1, shm->stats.successes, shm->stats.failures);
 
-cleanup_fds:
-
-close_sockets();
+abort_early:
 
 destroy_initial_mappings();
 
",155,35
introduce shorthand 'no objects' helper," static int open_drm_fds(void)
 closedir(dir);
 
 done:
-if (shm->global_objects[OBJ_FD_DRM].num_entries == 0)
+if (no_objects(OBJ_FD_DRM) == TRUE)
 drm_fd_provider.enabled = FALSE;
 
 return TRUE;
 static int get_rand_drm_fd(void)
 struct object *obj;
 
 /* check if drm unavailable/disabled. */
-if (shm->global_objects[OBJ_FD_DRM].num_entries == 0)
+if (no_objects(OBJ_FD_DRM) == TRUE)
 return -1;
 
 obj = get_random_object(OBJ_FD_DRM, OBJ_GLOBAL);
",99,19
rename generic_fd_from_socketinfo -> fd_from_socketinfo," static int get_rand_socket_fd(void)
 return sockinfo->fd;
 }
 
-int generic_fd_from_socketinfo(struct socketinfo *si)
+int fd_from_socketinfo(struct socketinfo *si)
 {
 if (si != NULL) {
 if (!(ONE_IN(1000)))
",341,77
watchdog needs to check SOCKETINFO fd's too.," unsigned int check_if_fd(struct childdata *child, struct syscallrecord *rec)
 struct syscallentry *entry;
 unsigned int fd;
 
-fd = rec->a1;
-
 entry = get_syscall_entry(rec->nr, rec->do32bit);
-if (entry->arg1type != ARG_FD)
-return FALSE;
 
+if (entry->arg1type == ARG_FD) {
+fd = rec->a1;
+goto got_fd;
+}
+
+if (entry->arg1type == ARG_SOCKETINFO) {
+fd = fd_from_socketinfo((struct socketinfo *) rec->a1);
+goto got_fd;
+}
+return FALSE;
+
+got_fd:
 /* if it's out of range, it's not going to be valid. */
 if (fd > 1024)
 return FALSE;
",367,79
"post-syscall, ARG_SOCKETINFO becomes an fd, don't dereference it."," unsigned int check_if_fd(struct childdata *child, struct syscallrecord *rec)
 }
 
 if (entry->arg1type == ARG_SOCKETINFO) {
-fd = fd_from_socketinfo((struct socketinfo *) rec->a1);
+/* post syscall, a1 is actually the fd, not the socketinfo */
+fd = rec->a1;
 goto got_fd;
 }
 return FALSE;
",367,79
"Remove unused variable in fds/drm.c.

Fix build error with GCC 5.2.1.

 CC	fds/drm.o
fds/drm.c: In function open_drm_fds:
fds/drm.c:70:15: error: unused variable i [-Werror=unused-variable]
 unsigned int i;
 ^

Signed-off-by: Vinson Lee <vlee@freedesktop.org>"," static void add_drm_obj(int fd)
 
 static int open_drm_fds(void)
 {
-unsigned int i;
 int fd, dfd;
 DIR *dir;
 struct dirent *entry;
",98,19
handle_sigreturn needs to write to the shm.," void child_process(void)
 
 ret = sigsetjmp(ret_jump, 1);
 if (ret != 0) {
+shm_rw();
+
 if (handle_sigreturn() == FALSE)
 return;// Exit the child, things are getting too weird.
 }
 
-shm_rw();
-
 while (shm->exit_reason == STILL_RUNNING) {
 unsigned int i;
 
",261,54
check_if_fd needs a return true if we have logging disabled too," got_fd:
 
 if (fd <= (unsigned int) fileno(child->logfile))
 return FALSE;
-return TRUE;
 }
-
-return FALSE;
+return TRUE;
 }
 
 static void stuck_syscall_info(struct childdata *child)
",366,79
remove all the child related stuff from sigalarm handler," static void ctrlc_handler(__unused__ int sig)
 
 static void sighandler(int sig)
 {
-int childno;
-
 sigwas = sig;
 
 switch (sig) {
 case SIGALRM:
-childno = find_childno(getpid());
-if (childno == CHILD_NOT_FOUND)
-_exit(EXIT_SUCCESS);/* Hell knows what happened, just bail. */
-
 /* Re-arm the alarm. */
 alarm(1);
+(void)signal(sig, sighandler);
 
 /* Jump back, maybe we'll make progress. */
-(void)signal(sig, sighandler);
 siglongjmp(ret_jump, 1);
 break;
 
",61,8
reduce duplication in the check_if_fd function," unsigned int check_if_fd(struct childdata *child, struct syscallrecord *rec)
 
 entry = get_syscall_entry(rec->nr, rec->do32bit);
 
-if (entry->arg1type == ARG_FD) {
-fd = rec->a1;
-goto got_fd;
-}
+if ((entry->arg1type != ARG_FD) &&
+ (entry->arg1type != ARG_SOCKETINFO))
+ return FALSE;
 
-if (entry->arg1type == ARG_SOCKETINFO) {
-/* post syscall, a1 is actually the fd, not the socketinfo */
-fd = rec->a1;
-goto got_fd;
-}
-return FALSE;
+/* in the SOCKETINFO case, post syscall, a1 is actually the fd,
+ * not the socketinfo. In ARG_FD a1=fd.
+ */
+fd = rec->a1;
 
-got_fd:
 /* if it's out of range, it's not going to be valid. */
 if (fd > 1024)
 return FALSE;
",360,79
"more alg_gen_sockaddr improving.

duplication, but when the big struct gets split up, this will
make more sense"," static const char *algos[] = {
 void alg_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 {
 struct sockaddr_alg *alg;
-unsigned int i, type, len;
+unsigned int type;
 const char *types[] = { ""aead"", ""hash"", ""rng"", ""skcipher"", };
 unsigned int algo;
 
 void alg_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 strcpy((char *)alg->salg_type, types[type]);
 
 switch (type) {
-case 0:
+// aead
+case 0:algo = rand() % ARRAY_SIZE(algos);
 break;
-case 1:
-i = rand() % ARRAY_SIZE(hashes);
-len = min(strlen(hashes[i]), sizeof(alg->salg_type));
-strncpy((char *)alg->salg_name, hashes[i], len);
+// hash
+case 1:algo = rand() % ARRAY_SIZE(hashes);
 break;
-case 2:
-algo = rand() % ARRAY_SIZE(algos);
-strcpy((char *)alg->salg_name, algos[algo]);
+// rng
+case 2:algo = rand() % ARRAY_SIZE(algos);
 break;
-case 3:
+// skcipher
+case 3:algo = rand() % ARRAY_SIZE(algos);
 break;
 }
+strcpy((char *)alg->salg_name, algos[algo]);
 
 alg->salg_feat = rand();
 alg->salg_mask = rand();
",228,5
use rand32 instead of rand() for alg feat/mask,"
 #include <netinet/in.h>
 #include <stdlib.h>
 #include ""config.h""
+#include ""random.h""
 #include ""net.h""
 #include ""utils.h""
 #include ""compat.h""
 void alg_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 }
 strcpy((char *)alg->salg_name, algos[algo]);
 
-alg->salg_feat = rand();
-alg->salg_mask = rand();
+alg->salg_feat = rand32();
+alg->salg_mask = rand32();
 
 *addr = (struct sockaddr *) alg;
 *addrlen = sizeof(struct sockaddr_alg);
",229,5
factor out the code that determines which syscall to run," static void check_sanity(struct syscallrecord *rec, struct syscallrecord *stash)
 }
 }
 
-bool child_random_syscalls(void)
+static bool set_syscall_nr(struct syscallrecord *rec)
 {
-struct syscallrecord *rec, *stash;
 unsigned int syscallnr;
 bool do32;
 
 retry:
 goto retry;
 }
 
-rec = &this_child->syscall;
 /* critical section for shm updates. */
 lock(&rec->lock);
 rec->do32bit = do32;
 retry:
 if (syscalls_todo) {
 if (shm->stats.total_syscalls_done >= syscalls_todo)
 shm->exit_reason = EXIT_REACHED_COUNT;
+return FAIL;
 }
 
+return TRUE;
+}
+
+bool child_random_syscalls(void)
+{
+struct syscallrecord *rec, *stash;
+
+rec = &this_child->syscall;
+
+if (set_syscall_nr(rec) == FAIL)
+return FAIL;
+
 /* Generate arguments, print them out */
 
 generate_syscall_args(rec);
",119,21
wrong indentation hid a bug that would cause early exit.," retry:
 unlock(&rec->lock);
 
 if (syscalls_todo) {
-if (shm->stats.total_syscalls_done >= syscalls_todo)
+if (shm->stats.total_syscalls_done >= syscalls_todo) {
 shm->exit_reason = EXIT_REACHED_COUNT;
-return FAIL;
+return FAIL;
+}
 }
 
 return TRUE;
",120,21
"mips: fix prctl's

It looks like a typo in the syscalls/prctl.c file. It's lacking the PR_
preffix, and due to that is causing build failures like this one:

 CC	syscalls/prctl.o
syscalls/prctl.c:37:2: error: 'GET_FP_MODE' undeclared here (not in a
function)
 GET_FP_MODE, SET_FP_MODE,
 ^
syscalls/prctl.c:37:15: error: 'SET_FP_MODE' undeclared here (not
in a function)
 GET_FP_MODE, SET_FP_MODE,
 ^

Signed-off-by: Vicente Olivert Riera <Vincent.Riera@imgtec.com>"," static int prctl_opts[] = {
 PR_GET_NO_NEW_PRIVS, PR_GET_TID_ADDRESS, PR_SET_THP_DISABLE, PR_GET_THP_DISABLE,
 PR_MPX_ENABLE_MANAGEMENT, PR_MPX_DISABLE_MANAGEMENT,
 #ifdef __mips__
-GET_FP_MODE, SET_FP_MODE,
+PR_GET_FP_MODE, PR_SET_FP_MODE,
 #endif
 PR_CAP_AMBIENT,
 };
",62,4
init the list head before adding it to the list.," static void add_to_namelist(const char *name)
 
 newnode = zmalloc(sizeof(struct namelist));
 newnode->name = strdup(name);
+INIT_LIST_HEAD(&newnode->list);
 list_add_tail(&newnode->list, &names->list);
 }
 
",308,67
separate the 'generate filelist' from 'open fds' code.,"
 #include ""child.h""
 #include ""files.h""
 #include ""log.h""
+#include ""pathnames.h""
 #include ""random.h""
 
 int child_read_all_files(void)
",46,7
"when generating ipv[46] addresses, use localhost half the time."," in_addr_t random_ipv4_address(void)
 {
 int addr;
 
+/* 50% of the time, just do localhost. */
+if (RAND_BOOL())
+return 0x7f000001;
+
 if (ip_lifetime != 0) {
 ip_lifetime--;
 return previous_ip;
",225,23
convert this_child to be a function instead of a global var.," static char * render_arg(struct syscallrecord *rec, char *sptr, unsigned int arg
 static unsigned int render_syscall_prefix(struct syscallrecord *rec, char *bufferstart)
 {
 struct syscallentry *entry;
+struct childdata *child = this_child();
 char *sptr = bufferstart;
 unsigned int i;
 unsigned int syscallnr;
 static unsigned int render_syscall_prefix(struct syscallrecord *rec, char *buffe
 syscallnr = rec->nr;
 entry = get_syscall_entry(syscallnr, rec->do32bit);
 
-sptr += sprintf(sptr, ""[child%u:%u] [%lu] %s"", this_child->num, this_child->pid,
+sptr += sprintf(sptr, ""[child%u:%u] [%lu] %s"", child->num, child->pid,
 rec->op_nr,
 rec->do32bit == TRUE ? ""[32BIT] "" : """");
 
",154,40
add a function to speed up bluetooth socket generation.," void bluetooth_setsockopt(struct sockopt *so)
 default: break;
 }
 }
+
+#define BTPROTO_L2CAP 0
+#define BTPROTO_HCI 1
+#define BTPROTO_SCO 2
+#define BTPROTO_RFCOMM 3
+#define BTPROTO_BNEP 4
+#define BTPROTO_CMTP 5
+#define BTPROTO_HIDP 6
+#define BTPROTO_AVDTP 7
+
+void bluetooth_rand_socket(struct socket_triplet *st)
+{
+int bt_protos[] = {
+BTPROTO_L2CAP, BTPROTO_HCI, BTPROTO_SCO, BTPROTO_RFCOMM,
+BTPROTO_BNEP, BTPROTO_CMTP, BTPROTO_HIDP, BTPROTO_AVDTP,
+};
+int types[] = { SOCK_STREAM, SOCK_DGRAM, SOCK_RAW, SOCK_SEQPACKET };
+
+st->protocol = RAND_ARRAY(bt_protos);
+st->type = RAND_ARRAY(types);
+}
",55,12
cache the child struct ptr in the child main loop," static bool handle_sigreturn(void)
 */
 void child_process(void)
 {
+struct childdata *child;
 int ret;
 
 ret = sigsetjmp(ret_jump, 1);
 void child_process(void)
 return;// Exit the child, things are getting too weird.
 }
 
+child = this_child();
+
 while (shm->exit_reason == STILL_RUNNING) {
-struct childdata *child = this_child();
 unsigned int i;
 
 periodic_work();
",262,54
simplify get_address to the more useful cases," retry:
 return addr;
 }
 
-static void * _get_address(unsigned char null_allowed)
+static void * _get_address(bool null_allowed)
 {
-void *addr = NULL;
-int i;
-
-if (null_allowed == TRUE)
-i = rand() % 4;
-else
-i = RAND_RANGE(1, 3);
-
-switch (i) {
-case 0: addr = NULL;
-break;
-case 1:addr = (void *) KERNEL_ADDR;
-break;
-case 2:addr = (void *)(unsigned long)rand64();
-break;
-
-case 3:addr = get_writable_address(page_size);
-break;
+if (null_allowed == TRUE) {
+if (ONE_IN(100))
+return NULL;
 }
-return addr;
+
+return get_writable_address(page_size);
 }
 
 void * get_address(void)
",88,23
further simplification.," retry:
 return addr;
 }
 
-static void * _get_address(bool null_allowed)
+void * get_non_null_address(void)
 {
-if (null_allowed == TRUE) {
-if (ONE_IN(100))
-return NULL;
-}
-
+//TODO: use different sizes.
 return get_writable_address(page_size);
 }
 
 void * get_address(void)
 {
-return _get_address(TRUE);
-}
+if (ONE_IN(100))
+return NULL;
 
-void * get_non_null_address(void)
-{
-return _get_address(FALSE);
+return get_non_null_address();
 }
 
 static bool is_arg_address(enum argtype argtype)
",82,21
now get_address can pick random mapping sizes," retry:
 
 void * get_non_null_address(void)
 {
-//TODO: use different sizes.
-return get_writable_address(page_size);
+unsigned long size = RAND_ARRAY(mapping_sizes);
+
+return get_writable_address(size);
 }
 
 void * get_address(void)
",83,21
"convert all rand() calls to rnd() wrapper

This does nothing right now. It'll make life easier later when
switching to thread-safe variants of rand()

bonus side-effect: it shuts coverity up forever about rand() calls."," void child_process(void)
 set_seed(child);
 
 /* Choose operations for this iteration. */
-i = rand() % ARRAY_SIZE(child_ops);
+i = rnd() % ARRAY_SIZE(child_ops);
 
-if (rand() % 100 <= child_ops[i].likelyhood) {
+if (rnd() % 100 <= child_ops[i].likelyhood) {
 const char *lastop = NULL;
 
 if (lastop != child_ops[i].name) {
",262,54
"Disable use of 1GB pages again

Need to rethink this, as this causes a number of problems."," static void setup_mapping_sizes(void)
 }
 }
 
+//FIXME
+mapping_sizes[5] = page_size;
+
 out_free:
 free(buffer);
 out_close:
",117,13
simplify futex random array usage," static inline int random_futex_wake_op(void)
 FUTEX_OP_CMP_LE, FUTEX_OP_CMP_GT, FUTEX_OP_CMP_GE,
 };
 
-return op_flags[RAND_RANGE(0, ARRAY_SIZE(op_flags)) - 1] |
-cmp_flags[RAND_RANGE(0, ARRAY_SIZE(cmp_flags)) - 1];
+return RAND_ARRAY(op_flags) | RAND_ARRAY(cmp_flags);
 }
 
 /*
",179,43
"add missing includes of random.h

These all use RAND_ARRAY, so are pulling this in indirectly.","
 #include ""net.h""
 #include ""compat.h""
 #include ""config.h""
+#include ""random.h""
 #include ""utils.h""// RAND_ARRAY
 
 static const unsigned int dccp_opts[] = {
",17,1
I missed include/ in the rand -> rnd conversion," void freeptr(unsigned long *p);
 #define unreachable() do { } while (1)
 
 #define RAND_ELEMENT(_array, _element) \
-_array[rand() % ARRAY_SIZE(_array)]._element
+_array[rnd() % ARRAY_SIZE(_array)]._element
 
-#define RAND_ARRAY(_array) _array[rand() % ARRAY_SIZE(_array)]
+#define RAND_ARRAY(_array) _array[rnd() % ARRAY_SIZE(_array)]
",13,1
get rid of the RAND_32 / RAND_64 macros," unsigned int rand32(void)
 break;
 case 1:r = randbits(32);
 break;
-case 2: r = RAND_32();
+case 2: r = rnd();
 break;
 case 3:r = rept_byte();
 break;
 u64 rand64(void)
 break;
 case 1:r = randbits(64);
 break;
-case 2:r = RAND_64();
+case 2:r = (0ULL | rnd()) << 32 | rnd();
 break;
 case 3:r = rept_byte();
 break;
",167,49
fix up straggler rand() -> rnd() conversions," retry:
 
 /* Ok, we're doing another syscall, let's pick one. */
 do32 = choose_syscall_table();
-syscallnr = rand() % max_nr_syscalls;
+syscallnr = rnd() % max_nr_syscalls;
 
 /* If we got a syscallnr which is not active repeat the attempt,
  * since another child has switched that syscall off already.*/
",122,21
remove noisy output from sigreturn," static bool handle_sigreturn(void)
 }
 unlock(&rec->lock);
 
-output(2, ""<timed out>\n""); /* Flush out the previous syscall output. */
-
 /* Check if we're making any progress at all. */
 if (rec->op_nr == last) {
 count++;
",261,54
"improve msgrcv sanitise

mark as NEED_ALARM, give it a non-null address, and set a smaller len.","
 #include <sys/types.h>
 #include <linux/msg.h>
 #include ""compat.h""
+#include ""random.h""
 #include ""sanitise.h""
 
+static void sanitise_msgrcv(struct syscallrecord *rec)
+{
+rec->a3 = rand() % MSGMAX;
+}
+
 static unsigned long msgrcv_flags[] = {
 MSG_NOERROR, MSG_EXCEPT, MSG_COPY, IPC_NOWAIT,
 };
 struct syscallentry syscall_msgrcv = {
 .num_args = 5,
 .arg1name = ""msqid"",
 .arg2name = ""msgp"",
-.arg2type = ARG_ADDRESS,
+.arg2type = ARG_NON_NULL_ADDRESS,
 .arg3name = ""msgsz"",
-.arg3type = ARG_LEN,
 .arg4name = ""msgtyp"",
 .arg5name = ""msgflg"",
 .arg5type = ARG_LIST,
 .arg5list = ARGLIST(msgrcv_flags),
-.flags = IGNORE_ENOSYS,
+.flags = IGNORE_ENOSYS | NEED_ALARM,
+.sanitise = sanitise_msgrcv,
 };
",26,1
"creation of the child logfiles must happen in main pid.

otherwise the watchdog can't fileno() them."," void init_child(struct childdata *child, int childno)
 
 reinit_child(child);
 
-init_child_logging(child);
-
 set_seed(this_child());
 
 init_child_mappings();
",260,54
"remove the 'previous' syscall logging

It's never been particularly helpful, and it's use will be obviated
by the upcoming logging rewrite."," static void oom_score_adj(int adj)
 static void reinit_child(struct childdata *child)
 {
 memset(&child->syscall, 0, sizeof(struct syscallrecord));
-memset(&child->previous, 0, sizeof(struct syscallrecord));
 
 child->seed = 0;
 child->kill_count = 0;
",259,54
set the child number earlier.," void init_child(struct childdata *child, int childno)
 }
 }
 
-child->num = childno;
-
 reinit_child(child);
 
 set_seed(this_child());
",258,54
assume untainted if we fail to open the tainted sysctl," int kernel_taint_initial = 0;
 int check_tainted(void)
 {
 int fd;
-unsigned int ret;
+unsigned int ret = 0;
 char buffer[11];
 
 buffer[10] = 0; //make sure that we can fit the whole int.
 
 fd = open(""/proc/sys/kernel/tainted"", O_RDONLY);
 if (fd < 0)
-return -1;
+goto out;
+
 ret = read(fd, buffer, 10);
 close(fd);
 
 int check_tainted(void)
 /* We should never fail, but if we do, assume untainted. */
 ret = 0;
 }
-
+out:
 return ret;
 }
 
",96,23
store fd from epoll creation in the right object cache," static int open_epoll_fds(void)
 struct object *obj;
 
 obj = alloc_object();
-obj->perffd = fd;
+obj->epollfd = fd;
 add_object(obj, OBJ_GLOBAL, OBJ_FD_EPOLL);
 
 output(2, ""fd[%d] = epoll\n"", fd);
",49,6
store epollfd's created by children in child local list,"
 * On success, returns a nonnegative file descriptor.
 * On error, -1 is returned, and errno is set to indicate the error.
 */
+#include ""objects.h""
 #include ""sanitise.h""
+#include ""utils.h""
+
+static void post_epoll_create(struct syscallrecord *rec)
+{
+struct object *new;
+int fd = rec->retval;
+
+if (fd == -1)
+return;
+
+new = zmalloc(sizeof(struct object));
+new->epollfd = fd;
+add_object(new, OBJ_LOCAL, OBJ_FD_EPOLL);
+}
 
 struct syscallentry syscall_epoll_create = {
 .name = ""epoll_create"",
 struct syscallentry syscall_epoll_create = {
 .arg1name = ""size"",
 .arg1type = ARG_LEN,
 .rettype = RET_FD,
+.post = post_epoll_create,
 };
 
 /*
 struct syscallentry syscall_epoll_create1 = {
 .arg1type = ARG_LIST,
 .arg1list = ARGLIST(epoll_create_flags),
 .rettype = RET_FD,
+.post = post_epoll_create,
 };
",33,2
store eventfd's created by children in child local list,"
 *
 * eventfd() calls eventfd2() with a zero'd flags arg.
 */
+#include ""objects.h""
 #include ""sanitise.h""
+#include ""utils.h""
+
+static void post_eventfd_create(struct syscallrecord *rec)
+{
+struct object *new;
+int fd = rec->retval;
+
+if (fd == -1)
+return;
+
+new = zmalloc(sizeof(struct object));
+new->eventfd = fd;
+add_object(new, OBJ_LOCAL, OBJ_FD_EVENTFD);
+}
 
 struct syscallentry syscall_eventfd = {
 .name = ""eventfd"",
 struct syscallentry syscall_eventfd = {
 .arg1name = ""count"",
 .arg1type = ARG_LEN,
 .rettype = RET_FD,
+.post = post_eventfd_create,
 };
 
 /*
 struct syscallentry syscall_eventfd2 = {
 .arg2type = ARG_LIST,
 .arg2list = ARGLIST(eventfd2_flags),
 .rettype = RET_FD,
+.post = post_eventfd_create,
 };
",37,2
store inotify fd's created by children in child local list,"
 /*
 * SYSCALL_DEFINE0(inotify_init)
 */
+#include ""objects.h""
 #include ""sanitise.h""
+#include ""utils.h""
+
+static void post_inotify_init(struct syscallrecord *rec)
+{
+struct object *new;
+int fd = rec->retval;
+
+if (fd == -1)
+return;
+
+new = zmalloc(sizeof(struct object));
+new->eventfd = fd;
+add_object(new, OBJ_LOCAL, OBJ_FD_INOTIFY);
+}
 
 struct syscallentry syscall_inotify_init = {
 .name = ""inotify_init"",
 .num_args = 0,
 .group = GROUP_VFS,
 .rettype = RET_FD,
+.post = post_inotify_init,
 };
 
 /*
 struct syscallentry syscall_inotify_init = {
 #define IN_CLOEXEC 02000000
 #define IN_NONBLOCK 04000
 
-#include ""sanitise.h""
-
 static unsigned long inotify_init1_flags[] = {
 IN_CLOEXEC , IN_NONBLOCK,
 };
 struct syscallentry syscall_inotify_init1 = {
 .arg1list = ARGLIST(inotify_init1_flags),
 .group = GROUP_VFS,
 .rettype = RET_FD,
+.post = post_inotify_init,
 };
",33,2
the busy-wait on watchdog startup is actually waiting for the shm," corrupt:
 kill_all_kids();
 }
 
-static bool wait_for_watchdog(void)
+static bool wait_for_shmready(void)
 {
 while (shm->ready == FALSE) {
 unsigned int counter = 0;
 void init_watchdog(void)
 
 watchdog_pid = getpid();
 
-if (wait_for_watchdog() == FALSE)
+if (wait_for_shmready() == FALSE)
 return;
 
 output(0, ""Watchdog is alive. (pid:%d)\n"", watchdog_pid);
",366,81
add a destructor for epoll objects,"
 #include ""epoll.h""
 #include ""fd.h""
 #include ""log.h""
+#include ""objects.h""
 #include ""random.h""
 #include ""sanitise.h""
 #include ""shm.h""
 
+static void epoll_destructor(struct object *obj)
+{
+close(obj->epollfd);
+}
+
 static int open_epoll_fds(void)
 {
+struct objhead *head;
 unsigned int i = 0;
 int fd = -1;
 
+head = get_objhead(OBJ_GLOBAL, OBJ_FD_EPOLL);
+head->destroy = &epoll_destructor;
+
 while (i < MAX_EPOLL_FDS) {
 
 if (RAND_BOOL())
",57,7
add a destructor for eventfd's,"
 #include ""fd.h""
 #include ""files.h""
 #include ""log.h""
+#include ""objects.h""
 #include ""random.h""
 #include ""sanitise.h""
 #include ""shm.h""
 #include ""compat.h""
 
+static void eventfd_destructor(struct object *obj)
+{
+close(obj->eventfd);
+}
+
 static int open_eventfd_fds(void)
 {
+struct objhead *head;
 unsigned int i;
 unsigned int flags[] = {
 0,
 static int open_eventfd_fds(void)
 EFD_SEMAPHORE,
 };
 
+head = get_objhead(OBJ_GLOBAL, OBJ_FD_EVENTFD);
+head->destroy = &eventfd_destructor;
+
 for (i = 0; i < ARRAY_SIZE(flags); i++) {
 struct object *obj;
 int fd;
",62,6
add a destructor for drmfd's,"
 #include ""fd.h""
 #include ""log.h""
 #include ""memfd.h""
+#include ""objects.h""
 #include ""random.h""
 #include ""sanitise.h""
 #include ""shm.h""

 #include <fcntl.h>
 #include <drm/drm.h>
 
+static void drmfd_destructor(struct object *obj)
+{
+close(obj->drmfd);
+}
+
 static int create_dumb(__unused__ int fd)
 {
 #if defined(DRM_IOCTL_MODE_CREATE_DUMB) && defined(DRM_IOCTL_PRIME_HANDLE_TO_FD)
 static void add_drm_obj(int fd)
 
 static int open_drm_fds(void)
 {
+struct objhead *head;
 int fd, dfd;
 DIR *dir;
 struct dirent *entry;
 char buf[128];
 
+head = get_objhead(OBJ_GLOBAL, OBJ_FD_DRM);
+head->destroy = &drmfd_destructor;
+
 dir = opendir(""/dev/dri/"");
 if (!dir)
 goto done;
",106,20
add destructor for filefd's,"
 #include ""fd.h""
 #include ""files.h""
 #include ""log.h""
+#include ""objects.h""
 #include ""pathnames.h""
 #include ""random.h""
 #include ""syscalls/syscalls.h""
 retry_flags:
 return fd;
 }
 
+static void filefd_destructor(struct object *obj)
+{
+close(obj->filefd);
+}
+
 static int open_files(void)
 {
+struct objhead *head;
 unsigned int i, nr_to_open;
 
+head = get_objhead(OBJ_GLOBAL, OBJ_FD_FILE);
+head->destroy = &filefd_destructor;
+
 generate_filelist();
 
 if (files_in_index == 0) {
",130,22
add destructor for inotify fd's,"
 #include ""inotify.h""
 #include ""fd.h""
 #include ""log.h""
+#include ""objects.h""
 #include ""random.h""
 #include ""sanitise.h""
 #include ""shm.h""
 
+static void inotify_destructor(struct object *obj)
+{
+close(obj->inotifyfd);
+}
+
 static int open_inotify_fds(void)
 {
+struct objhead *head;
 struct object *obj;
 unsigned int i;
 int fd;
 static int open_inotify_fds(void)
 IN_NONBLOCK | IN_CLOEXEC,
 };
 
+head = get_objhead(OBJ_GLOBAL, OBJ_FD_INOTIFY);
+head->destroy = &inotify_destructor;
+
 fd = inotify_init();
 if (fd < 0)
 return FALSE;
",61,7
add destructor for memfd's,"
 #include ""fd.h""
 #include ""log.h""
 #include ""memfd.h""
+#include ""objects.h""
 #include ""random.h""
 #include ""sanitise.h""
 #include ""shm.h""
 static int memfd_create(__unused__ const char *uname, __unused__ unsigned int fl
 #endif
 }
 
+static void memfd_destructor(struct object *obj)
+{
+close(obj->memfd);
+}
+
 static int open_memfd_fds(void)
 {
+struct objhead *head;
 unsigned int i;
 unsigned int flags[] = {
 0,
 static int open_memfd_fds(void)
 MFD_ALLOW_SEALING,
 };
 
+head = get_objhead(OBJ_GLOBAL, OBJ_FD_MEMFD);
+head->destroy = &memfd_destructor;
+
 for (i = 0; i < ARRAY_SIZE(flags); i++) {
 struct object *obj;
 char namestr[] = ""memfdN"";
",64,8
add destructor for perf fd's,"
 #include <asm/unistd.h>
 
 #include ""fd.h""
+#include ""objects.h""
 #include ""perf.h""
 #include ""shm.h""
 #include ""log.h""
 #include ""sanitise.h""
 
+static void perffd_destructor(struct object *obj)
+{
+close(obj->perffd);
+}
+
 static int open_perf_fds(void)
 {
+struct objhead *head;
 unsigned int i = 0;
 
+head = get_objhead(OBJ_GLOBAL, OBJ_FD_PERF);
+head->destroy = &perffd_destructor;
+
 while (i < MAX_PERF_FDS) {
 struct syscallrecord *rec;
 int fd;
",56,7
add destructor for pipe fd's,"
 #include ""fd.h""
 #include ""files.h""
 #include ""log.h""
+#include ""objects.h""
 #include ""pipes.h""
 #include ""random.h""
 #include ""sanitise.h""
 #include ""shm.h""
 #include ""trinity.h""
 
+static void pipefd_destructor(struct object *obj)
+{
+close(obj->pipefd);
+}
+
 static void open_pipe_pair(unsigned int flags)
 {
+struct objhead *head;
 struct object *obj;
 int pipes[2];
 
+head = get_objhead(OBJ_GLOBAL, OBJ_FD_PIPE);
+head->destroy = &pipefd_destructor;
+
 if (pipe2(pipes, flags) < 0) {
 perror(""pipe fail.\n"");
 return;
",59,5
add destructor for sockets,"
 #include <sys/stat.h>
 
 #include ""debug.h""
+#include ""domains.h""
 #include ""log.h""
 #include ""net.h""
+#include ""objects.h""
 #include ""params.h""// verbose, do_specific_domain
-#include ""domains.h""
 #include ""random.h""
 #include ""sanitise.h""
 #include ""shm.h""
 void close_sockets(void)
 nr_sockets = 0;
 }
 
+static void socket_destructor(struct object *obj)
+{
+struct socketinfo *si = &obj->sockinfo;
+
+close(si->fd);
+}
+
 static int open_sockets(void)
 {
+struct objhead *head;
 int cachefile;
 unsigned int domain, type, protocol;
 unsigned int buffer[3];
 static int open_sockets(void)
 if (victim_path != NULL)
 return TRUE;
 
+head = get_objhead(OBJ_GLOBAL, OBJ_FD_SOCKET);
+head->destroy = &socket_destructor;
+
 cachefile = open(cachefilename, O_RDONLY);
 if (cachefile < 0) {
 output(1, ""Couldn't find socket cachefile. Regenerating.\n"");
",350,78
add destructor for testfiles,"
 #include ""fd.h""
 #include ""files.h""
 #include ""log.h""
+#include ""objects.h""
 #include ""random.h""
 #include ""sanitise.h""
 #include ""shm.h""

 #include ""testfile.h""
 #include ""utils.h""
 
+static void testfile_destructor(struct object *obj)
+{
+close(obj->testfilefd);
+}
+
 static int open_testfile(char *filename)
 {
+struct objhead *head;
 int fd;
 
+head = get_objhead(OBJ_GLOBAL, OBJ_FD_TESTFILE);
+head->destroy = &testfile_destructor;
+
 /* file might be around from an earlier run, nuke it. */
 (void) unlink(filename);
 
",86,11
add destructor for timerfd's,"
 #include ""fd.h""
 #include ""files.h""
 #include ""log.h""
+#include ""objects.h""
 #include ""random.h""
 #include ""sanitise.h""
 #include ""shm.h""
 #include ""compat.h""
 
+static void timerfd_destructor(struct object *obj)
+{
+close(obj->timerfd);
+}
+
 static int __open_timerfd_fds(int clockid)
 {
+struct objhead *head;
 unsigned int i;
 unsigned int flags[] = {
 0,
 static int __open_timerfd_fds(int clockid)
 TFD_NONBLOCK | TFD_CLOEXEC,
 };
 
+head = get_objhead(OBJ_GLOBAL, OBJ_FD_TIMERFD);
+head->destroy = &timerfd_destructor;
+
 for (i = 0; i < ARRAY_SIZE(flags); i++) {
 struct object *obj;
 int fd;
",67,9
use alloc_object for all allocation of objects.," static void alloc_zero_map(unsigned long size, int prot, const char *name)
 exit(EXIT_FAILURE);
 }
 
-new = zmalloc(sizeof(struct object));
+new = alloc_object();
 new->map.size = size;
 new->map.prot = prot;
 new->map.type = TRINITY_MAP_INITIAL;
",117,13
remove print spew from alloc_zero_mapping," static void dump_initial_mappings(void)
 list_for_each(node, list) {
 struct object *obj;
 struct map *m;
+char buf[11];
 
 obj = (struct object *) node;
 m = &obj->map;
-output(2, "" start: %p size:%d name: %s\n"", m->ptr, m->size, m->name);
+sizeunit(m->size, buf);
+output(2, "" start: %p size:%s name: %s\n"", m->ptr, buf, m->name);
 }
 }
 
 static void alloc_zero_map(unsigned long size, int prot, const char *name)
 {
-struct objhead *head;
 struct object *new;
 int fd;
-char buf[11];
 
 fd = open(""/dev/zero"", O_RDWR);
 if (fd == -1) {
 static void alloc_zero_map(unsigned long size, int prot, const char *name)
 
 sprintf(new->map.name, ""anon(%s)"", name);
 
-head = &shm->global_objects[OBJ_MMAP];
-
 add_object(new, OBJ_GLOBAL, OBJ_MMAP);
 
-sizeunit(size, buf);
-output(2, ""mapping[%d]: (zeropage %s) %p (%s)\n"",
-head->num_entries - 1, name, new->map.ptr, buf);
-
 close(fd);
 }
 
",113,13
use the mmap object destructor instead of open-coding it," void destroy_initial_mappings(void)
 
 list_for_each_safe(node, tmp, list) {
 struct object *obj;
-struct map *m;
 
 obj = (struct object *) node;
-m = &obj->map;
-
-munmap(m->ptr, m->size);
-free(m->name);
 
 destroy_object(obj, OBJ_GLOBAL, OBJ_MMAP);
 }
",109,13
mmap destructor needs to munmap the mmap," static void map_destructor(struct object *obj)
 struct map *map;
 
 map = &obj->map;
+munmap(map->ptr, map->size);
 free(map->name);
 }
 
",93,11
share the mmap destructor across local and global mappings," out_close:
 
 void setup_initial_mappings(void)
 {
+struct objhead *head;
 unsigned int i;
 
+head = get_objhead(OBJ_GLOBAL, OBJ_MMAP);
+head->destroy = &map_destructor;
+
 setup_mapping_sizes();
 
 for (i = 0; i < ARRAY_SIZE(mapping_sizes); i++) {
",112,13
make destroy_initial_mappings more generic," void setup_initial_mappings(void)
 
 dump_initial_mappings();
 }
-
-void destroy_initial_mappings(void)
-{
-struct list_head *node, *list, *tmp;
-struct objhead *head;
-
-head = &shm->global_objects[OBJ_MMAP];
-list = head->list;
-
-list_for_each_safe(node, tmp, list) {
-struct object *obj;
-
-obj = (struct object *) node;
-
-destroy_object(obj, OBJ_GLOBAL, OBJ_MMAP);
-}
-
-head->num_entries = 0;
-}
",99,12
add a simple garbage collector for old fd's etc.," void destroy_objects(enum objecttype type, bool global)
 
 head->num_entries = 0;
 }
+
+/*
+ * Think of this as a poor mans garbage collector, to prevent
+ * us from exhausting all the available fd's in the system etc.
+ */
+void prune_objects(enum objecttype type, bool global)
+{
+struct objhead *head;
+unsigned int num_to_prune;
+
+/* We don't want to over-prune things and growing a little
+ * bit past the ->max is fine, we'll clean it up next time.
+ */
+if (!(ONE_IN(10)))
+return;
+
+head = get_objhead(global, type);
+num_to_prune = rand() % head->max_entries;
+
+while (num_to_prune > 0) {
+struct list_head *node, *list, *tmp;
+
+list = head->list;
+
+list_for_each_safe(node, tmp, list) {
+struct object *obj;
+
+if (ONE_IN(10)) {
+obj = (struct object *) node;
+destroy_object(obj, global, type);
+num_to_prune--;
+//TODO: log something
+}
+}
+}
+}
",113,18
"max_entries = 0 means ""don't prune"""," void prune_objects(enum objecttype type, bool global)
 return;
 
 head = get_objhead(global, type);
+
+/* 0 = don't ever prune. */
+if (head->max_entries == 0)
+return;
+
 num_to_prune = rand() % head->max_entries;
 
 while (num_to_prune > 0) {
",115,19
genericise the destruction of global objects," int main(int argc, char* argv[])
 
 abort_early:
 
-destroy_objects(OBJ_GLOBAL, OBJ_MMAP);
+destroy_global_objects();
 
 shutdown_logging();
 
",155,35
only prune lists that have reached their max length," static void __prune_objects(enum objecttype type, bool global)
 if (head->max_entries == 0)
 return;
 
-num_to_prune = rand() % head->max_entries;
+/* only prune full lists. */
+if (head->num_entries < head->max_entries)
+return;
+
+num_to_prune = rand() % head->num_entries;
 
 while (num_to_prune > 0) {
 struct list_head *node, *list, *tmp;
",132,25
move initialization of child lists into init_child," void init_child(struct childdata *child, int childno)
 
 set_seed(this_child());
 
+init_object_lists(OBJ_LOCAL);
+
 init_child_mappings();
 
 dirty_random_mapping();
",259,54
child list creation can inherit destroy/max from global list," void init_object_lists(bool global)
 struct objhead *head;
 
 head = get_objhead(global, i);
+
 head->list = NULL;
 head->num_entries = 0;
+
+/*
+ * child lists can inherit properties from global lists.
+ */
+if (global == OBJ_LOCAL) {
+struct objhead *globalhead;
+globalhead = get_objhead(OBJ_GLOBAL, i);
+head->max_entries = globalhead->max_entries;
+head->destroy = globalhead->destroy;
+}
 }
 }
 
",138,26
use get_objhead instead of open-coding," static void dump_initial_mappings(void)
 struct list_head *node, *list;
 struct objhead *head;
 
-head = &shm->global_objects[OBJ_MMAP];
+head = get_objhead(OBJ_GLOBAL, OBJ_MMAP);
 list = head->list;
 
 output(2, ""There are %d entries in the map table\n"", head->num_entries);
",99,12
wire up the pruner to potentially trigger when we add an object.," void add_object(struct object *obj, bool global, enum objecttype type)
 
 list_add_tail(&obj->list, head->list);
 head->num_entries++;
+
+/* if we just added something to a child list, check
+ * to see if we need to do some pruning.
+ */
+if (global == OBJ_LOCAL)
+prune_objects();
 }
 
 void init_object_lists(bool global)
",140,27
"make the mmap dumper generic, and move to objects.c

This is useful for debugging. I'll clean up the TODO's later.","
 #include ""maps.h""
 #include ""utils.h""
 
-static void dump_initial_mappings(void)
-{
-struct list_head *node, *list;
-struct objhead *head;
-
-head = get_objhead(OBJ_GLOBAL, OBJ_MMAP);
-list = head->list;
-
-output(2, ""There are %d entries in the map table\n"", head->num_entries);
-
-list_for_each(node, list) {
-struct object *obj;
-struct map *m;
-char buf[11];
-
-obj = (struct object *) node;
-m = &obj->map;
-sizeunit(m->size, buf);
-output(2, "" start: %p size:%s name: %s\n"", m->ptr, buf, m->name);
-}
-}
-
 static void alloc_zero_map(unsigned long size, int prot, const char *name)
 {
 struct object *new;
 void setup_initial_mappings(void)
 alloc_zero_map(mapping_sizes[i], PROT_WRITE, ""PROT_WRITE"");
 }
 
-dump_initial_mappings();
+dump_objects(OBJ_GLOBAL, OBJ_MMAP);
 }
",82,11
move the socket shutdown code into destructors," int main(int argc, char* argv[])
 
 main_loop();
 
-close_sockets();
-
 shm->mainpid = 0;
 _exit(EXIT_SUCCESS);
 }
",154,35
"objects: rename no_objects

... and trivially simplify it while at it. no_objects()
is slightly confusing regarding the name and I believe
changing it to objects_empty() serves better.

Signed-off-by: Davidlohr Bueso <dbueso@suse.de>"," static int open_drm_fds(void)
 closedir(dir);
 
 done:
-if (no_objects(OBJ_FD_DRM) == TRUE)
+if (objects_empty(OBJ_FD_DRM) == TRUE)
 drm_fd_provider.enabled = FALSE;
 
 return TRUE;
 static int get_rand_drm_fd(void)
 struct object *obj;
 
 /* check if drm unavailable/disabled. */
-if (no_objects(OBJ_FD_DRM) == TRUE)
+if (objects_empty(OBJ_FD_DRM) == TRUE)
 return -1;
 
 obj = get_random_object(OBJ_FD_DRM, OBJ_GLOBAL);
",106,20
"futex: FUTEX_WAIT can also use FUTEX_CLOCK_REALTIME

FUTEX_WAIT is treated as a simple version for
FUTEX_WAIT_BITSET internally (with a bitmask of
FUTEX_BITSET_MATCH_ANY). As such there is no reason
for regular wait calls not to make use of it. Update
trinity to reflect the new kernel logic.

Signed-off-by: Davidlohr Bueso <dbueso@suse.de>"," static void sanitise_futex(struct syscallrecord *rec)
 
 out_setclock:
 switch (rec->a2) {
+case FUTEX_WAIT:
+case FUTEX_WAIT_PRIVATE:
 case FUTEX_WAIT_BITSET:
 case FUTEX_WAIT_BITSET_PRIVATE:
 case FUTEX_WAIT_REQUEUE_PI:
",181,45
"futex: convert to object cache

This allows better handling of the uaddr parameters we pass
to futex(2). As such, teach the object structure about the
internal lock primitive. We have two alternatives now, which
replaces the current use lock or whatever trinity gives us
as addresses. Now we continue using the lock half the time,
but make use of the mmap playground already available otherwise.

Signed-off-by: Davidlohr Bueso <dbueso@suse.de>"," void dump_objects(bool global, enum objecttype type)
 obj->sockinfo.triplet.protocol,
 obj->sockinfo.fd);
 break;
+case OBJ_FUTEX:
+output(0, ""futex: %lx owner:%d\n"",
+obj->lock.futex, obj->lock.owner_pid);
+break;
 case MAX_OBJECT_TYPES:
 default:
 break;
",205,41
"futex: fix post call make-it-fail

... the purpose is to clear the option.

Signed-off-by: Davidlohr Bueso <dbueso@suse.de>"," static void post_futex(struct syscallrecord *rec)
 if (futex_pi_cmd(rec->a2))
 setpriority(PRIO_PROCESS, 0, 0);
 
-(void)toggle_futex_fail_inj(TRUE);
+(void)toggle_futex_fail_inj(FALSE);
 }
 
 struct syscallentry syscall_futex = {
",229,53
fix divide by zero in get_random_object," struct object * get_random_object(enum objecttype type, bool global)
 {
 struct objhead *head;
 struct list_head *node, *list;
-unsigned int i, j = 0;
+unsigned int i, j = 0, n;
 
 head = get_objhead(global, type);
 
 list = head->list;
 
-i = rnd() % head->num_entries;
+n = head->num_entries;
+if (n == 0)
+return NULL;
+i = rnd() % n;
 
 list_for_each(node, list) {
 struct object *m;
",208,42
don't try to destroy empty lists," static void destroy_objects(enum objecttype type, bool global)
 struct list_head *node, *list, *tmp;
 struct objhead *head;
 
+if (objects_empty(type) == TRUE)
+return;
+
 head = get_objhead(global, type);
 list = head->list;
 
",210,43
"check for empty pidslots in stall_genocide

This was a pain in the ass to track down. We were sigkill'ing
a pid of -1, which took down everything.
Amazingly, this has been there for six months, and only recently
became a problem. This is because children previously weren't
running long enough, or getting stuck enough for this situation
to arise that often. With the recent segfault fixes, this
function gets hit a lot more."," static void stall_genocide(void)
 for_each_child(i) {
 struct childdata *child = shm->children[i];
 
+if (child->pid == EMPTY_PIDSLOT)
+continue;
+
 if (RAND_BOOL()) {
 int ret;
 
",368,82
"futex: fix private object segfault

When doing a get_random_object() lookup, we can
dereference a nil pointer in the local list. As
such, always use the global variant to avoid
crashing the child.

Signed-off-by: Davidlohr Bueso <dbueso@suse.de>"," struct __lock * get_random_lock(void)
 global = OBJ_LOCAL;
 
 obj = get_random_object(OBJ_FUTEX, global);
+if (!obj)
+obj = get_random_object(OBJ_MMAP, OBJ_GLOBAL);
 return &obj->lock;
 }
 
 static uint32_t * get_futex_mmap(void)
 global = OBJ_LOCAL;
 
 obj = get_random_object(OBJ_MMAP, global);
-map = &obj->map;
+if (!obj)
+obj = get_random_object(OBJ_MMAP, OBJ_GLOBAL);
 
+map = &obj->map;
 return (uint32_t *)map->ptr;
 
 }
",233,55
"futex: fix uaddr passing when dealing with lock

We are working on the address of the futex word in our
local lock structure. As such, we are currently passing
it a completely bogus params for uaddr and uaddr2, which
can be seen with the amount of unsuccessful futex calls.

Also get rid of printing the addresses in the mmap'ed
playground when creating our futexes, just show how many
are created, no one really cares about these specifics,
which can be seen/studied in the logs anyway.

Signed-off-by: Davidlohr Bueso <dbueso@suse.de>"," struct __lock * get_random_lock(void)
 obj = get_random_object(OBJ_FUTEX, global);
 if (!obj)
 obj = get_random_object(OBJ_MMAP, OBJ_GLOBAL);
+
 return &obj->lock;
 }
 
 void create_futexes(void)
 
 futex_init_lock(lock);
 add_object(obj, OBJ_GLOBAL, OBJ_FUTEX);
-output(0, ""futex[%u] uaddr: %p\n"", i, &lock->futex);
 }
 
 output(0, ""Reserved/initialized %d futexes.\n"", NFUTEXES);
 static void sanitise_futex(struct syscallrecord *rec)
 lock1 = get_random_lock();
 lock2 = get_random_lock();
 
-rec->a1 = (unsigned long) lock1->futex; /* uaddr */
+rec->a1 = (unsigned long) &lock1->futex; /* uaddr */
 /* ^^ no, we do not have 64-bit futexes :P */
-rec->a5 = (unsigned long) lock2->futex; /* uaddr2 */
+rec->a5 = (unsigned long) &lock2->futex; /* uaddr2 */
 } else {
 rec->a1 = (unsigned long) get_futex_mmap();
 rec->a5 = (unsigned long) get_futex_mmap();
",232,55
"convert syscall time tracking to CLOCK_MONOTONIC

Commit e8646038d918 (""add some extra sanity checks inside the child
process"") made trinity near unusable for me: the rec->tv sanity check
fails rather quickly after first syscall capable of changing wall time.

The patch reworks trinity to use clock_gettime(CLOCK_MONOTONIC) instead
of gettimeofday(). It makes trinity usable again.

Signed-off-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>"," static void check_sanity(struct syscallrecord *rec, struct syscallrecord *stash)
 {
 unsigned int len;
 
-if (stash->tv.tv_sec != 0) {
+if (stash->tp.tv_sec != 0) {
 // FIXME: Should factor in loadavg here, as with enough pids, a child can exceed 60s
 // without getting scheduled.
-if (rec->tv.tv_sec - stash->tv.tv_sec > 60) {
-output(0, ""Sanity check failed. Something stomped on rec->tv after syscall:%s(%lx, %lx, %lx) was:%lx now:%lx.\n"",
+if (rec->tp.tv_sec - stash->tp.tv_sec > 60) {
+output(0, ""Sanity check failed. Something stomped on rec->tp after syscall:%s(%lx, %lx, %lx) was:%lx now:%lx.\n"",
 print_syscall_name(stash->nr, stash->do32bit),
-stash->a1, stash->a2, stash->a3, stash->tv.tv_sec, rec->tv.tv_sec);
+stash->a1, stash->a2, stash->a3, stash->tp.tv_sec, rec->tp.tv_sec);
 fail_sanity();
 }
 }
",122,21
change the lock-checking to return a bool," static void kill_all_kids(void)
 shm->running_childs = 0;
 
 /* Check that no dead children hold locks. */
-check_all_locks();
+while (check_all_locks() == TRUE)
+reap_dead_kids();
 
 /* wait a second to give kids a chance to exit. */
 sleep(1);
 static void watchdog(void)
 if (check_main_alive() == FALSE)
 goto main_dead;
 
-reap_dead_kids();
-
-check_all_locks();
+while (check_all_locks() == TRUE)
+reap_dead_kids();
 
 if (syscalls_todo && (shm->stats.total_syscalls_done >= syscalls_todo)) {
 output(0, ""Reached limit %d. Telling children to exit.\n"", syscalls_todo);
",369,84
"two-step locking.

There was a tiny race where a lock would show as LOCKED, but hadn't
had its owner set yet. This would manifest by the watchdog finding
locks owned by pid 0."," static bool check_lock(lock_t *_lock)
 {
 pid_t pid;
 
+/* We don't care about unlocked or locking-in-progress */
 if (_lock->lock != LOCKED)
 return FALSE;
 
 void lock(lock_t *_lock)
 {
 pid_t pid = getpid();
 
-while (_lock->lock == LOCKED) {
+while (_lock->lock != UNLOCKED) {
 if (_lock->owner == pid) {
 debugf(""lol, already have lock!\n"");
 show_backtrace();
 void lock(lock_t *_lock)
 usleep(1);
 }
 
-_lock->lock = LOCKED;
+_lock->lock = LOCKING;
 _lock->contention = 0;
 _lock->owner = pid;
+_lock->lock = LOCKED;
 }
 
 void unlock(lock_t *_lock)
 void unlock(lock_t *_lock)
 */
 void bust_lock(lock_t *_lock)
 {
-if (_lock->lock != LOCKED)
+if (_lock->lock == UNLOCKED)
 return;
 if (getpid() != _lock->owner)
 return;
",89,17
"start numbering testfiles from 1, not 0"," static int open_testfile(char *filename)
 static int open_testfile_fds(void)
 {
 char *filename;
-unsigned int i = 0;
+unsigned int i = 1;
 unsigned int fails = 0;
 
 filename = zmalloc(64);
 
-while (i < MAX_TESTFILE_FDS) {
+while (i <= MAX_TESTFILE_FDS) {
 int fd;
 
 sprintf(filename, ""trinity-testfile%u"", i);
",86,11
move the resetting of a pid to EMPTY_PIDSLOT later.," void reap_child(pid_t childpid)
 goto out;
 
 child = shm->children[i];
-child->pid = EMPTY_PIDSLOT;
 child->syscall.tp = (struct timespec){};
 shm->running_childs--;
 shm->last_reaped = childpid;
+// FIXME: we do this last because things go walking children
+// looking for EMPTY_PIDSLOT, and it's not really EMPTY until
+// we've cleaned it out.
+//
+// we could really use some locking here.
+// this was easier when we had a global pidslot array.
+// now we'd need a lock that spans all child structs. ew.
+// Later: experiment with moving the pids back out of the child struct.
+child->pid = EMPTY_PIDSLOT;
 
 out:
 unlock(&shm->reaper_lock);
",250,54
add a dumb syslog() wrapper,"
 #endif
 #include <stdio.h>
 #include <stdarg.h>
+#include <syslog.h>
 #include ""child.h""
 #include ""debug.h""
 #include ""log.h""
 void debugf(const char *fmt, ...)
 va_end(args);
 output(0, debugbuf);
 }
+
+/* This is a bit crappy, wrapping a varargs fn with another,
+ * but this saves us having to do the openlog/closelog for every
+ * case where we want to write a message.
+ */
+void syslogf(const char *fmt, ...)
+{
+char debugbuf[BUFSIZE];
+va_list args;
+
+va_start(args, fmt);
+vsprintf(debugbuf, fmt, args);
+va_end(args);
+
+openlog(""trinity"", LOG_CONS|LOG_PERROR, LOG_USER);
+syslog(LOG_CRIT, ""%s"", debugbuf);
+closelog();
+}
",94,12
remove leftover debugging code.," bool check_all_locks(void)
 check_lock(&shm->reaper_lock);
 check_lock(&shm->syscalltable_lock);
 
-for_each_child(i) {
-bool x;
+for_each_child(i)
+ret = check_lock(&shm->children[i]->syscall.lock);
 
-x = check_lock(&shm->children[i]->syscall.lock);
-ret |= x;
-if (x == TRUE) {
-dump_childdata(shm->children[i]);
-}
-}
 return ret;
 }
 
",83,16
"accumulate the check_lock results instead of over-writing each time.

Typo introduced in previous commit."," bool check_all_locks(void)
 check_lock(&shm->syscalltable_lock);
 
 for_each_child(i)
-ret = check_lock(&shm->children[i]->syscall.lock);
+ret |= check_lock(&shm->children[i]->syscall.lock);
 
 return ret;
 }
",83,16
dump pipe object info on startup," static int open_pipes(void)
 open_pipe_pair(O_CLOEXEC);
 open_pipe_pair(O_NONBLOCK | O_CLOEXEC);
 
+dump_objects(OBJ_GLOBAL, OBJ_FD_PIPE);
+
 return TRUE;
 }
 
",60,5
"Remove the watchdog process.

Have the work it used to do done by the main process instead.
There's still room for improvement here, but this is a big step
forward in terms of simplification, and allows a whole bunch of
code & locking to just go away.

There's also no longer a good reason to fork main_loop() as a separate
process, so now we're back to a single process (for now).

A big change here also is the 'reaping' of processes. This is now
only ever done by the main process. The child no longer cleans up
after itself (ugh, kids eh?) before it exits. There's no watchdog
process, so we can probably remove the reaper_lock now as a follow-up."," static void lock_cachefile(int cachefile, int type)
 
 if (fcntl(cachefile, F_SETLKW, &fl) == -1) {
 perror(""fcntl F_SETLKW"");
-exit_main_fail();
+exit(EXIT_FAILURE);
 }
 
 if (verbose)
 static void unlock_cachefile(int cachefile)
 
 if (fcntl(cachefile, F_SETLK, &fl) == -1) {
 perror(""fcntl F_UNLCK F_SETLK "");
-exit_main_fail();
+exit(EXIT_FAILURE);
 }
 
 if (verbose)
",336,77
"Drop the futex debugfs frobbing for now.

It causes a ton of spew to stdout, and can't actually work
unless you're running as root, without --dropprivs (which is a
terrible idea).

I'll add a root process later, and a means for children to communicate
requests to it to do things like this on its behalf."," static inline int random_futex_wake_op(void)
 return RAND_ARRAY(op_flags) | RAND_ARRAY(cmp_flags);
 }
 
-static int toggle_futex_fail_inj(bool on)
+static int toggle_futex_fail_inj(__unused__ bool on)
 {
 int err = 0;
+#if 0
 
 if (access(""/proc/self/make-it-fail"", W_OK) == -1)
 goto done;
 static int toggle_futex_fail_inj(bool on)
 err = system(""echo Y > /sys/kernel/debug/fail_futex/task-filter"");
 err = system(""echo 1 > /sys/kernel/debug/fail_futex/times"");
 done:
+#endif
 return err;
 }
 
",232,56
"remove unnecessary break's

With these in place, the *p=0 line is never reached."," static void generate_random_page(char *page)
 case 2:p += sprintf(p, ""0x%x"", (int) rand32());
 break;
 }
-break;
 } else {
 /* decimal */
 
 static void generate_random_page(char *page)
 case 2:p += sprintf(p, ""%u"", (unsigned char) rnd());
 break;
 }
-break;
 }
 
 *p = 0;
",178,46
"syscall32 needs the shm writable.

also, narrow the period that the shm is RO around 64-bit syscalls."," already_done:
 shm->syscalls32_attempted++;
 }
 
+shm_ro();
 DO_32_SYSCALL
+shm_rw();
 
 if ((unsigned long)(__res) >= (unsigned long)(-133)) {
 errno = -(__res);
 static void __do_syscall(struct syscallrecord *rec)
 int nr, call;
 bool needalarm;
 
-shm_ro();
-
 nr = rec->nr;
 /* Some architectures (IA64/MIPS) start their Linux syscalls
  * At non-zero, and have other ABIs below.
 static void __do_syscall(struct syscallrecord *rec)
 if (needalarm)
 (void)alarm(1);
 
-if (rec->do32bit == FALSE)
+if (rec->do32bit == FALSE) {
+shm_ro();
 ret = syscall(call, rec->a1, rec->a2, rec->a3, rec->a4, rec->a5, rec->a6);
-else
+shm_rw();
+} else {
 ret = syscall32(call, rec->a1, rec->a2, rec->a3, rec->a4, rec->a5, rec->a6);
-
+}
 if (needalarm)
 (void)alarm(0);
-
-shm_rw();
 }
 
 /* We returned! */
",179,36
introduce a trylock function," bool check_all_locks(void)
 return ret;
 }
 
+static void __lock(lock_t *_lock)
+{
+_lock->lock = LOCKING;
+_lock->contention = 0;
+_lock->owner = getpid();
+_lock->lock = LOCKED;
+}
+
+bool trylock(lock_t *_lock)
+{
+if (_lock->lock == UNLOCKED) {
+__lock(_lock);
+return TRUE;
+}
+return FALSE;
+}
+
 void lock(lock_t *_lock)
 {
 pid_t pid = getpid();
 void lock(lock_t *_lock)
 _lock->contention++;
 usleep(1);
 }
-
-_lock->lock = LOCKING;
-_lock->contention = 0;
-_lock->owner = pid;
-_lock->lock = LOCKED;
+__lock(_lock);
 }
 
 void unlock(lock_t *_lock)
",95,19
"make stuck_syscall_info non-blocking.

A side-effect of removing the watchdog process is that now main_loop
and all the functions it calls can't ever busy wait, or we get child
processes stuck in zombies. This is catastrophic if they were holding
a lock and segfaulted."," static void stuck_syscall_info(struct childdata *child)
 
 rec = &child->syscall;
 
-lock(&rec->lock);
+if (trylock(&rec->lock) == FALSE)
+return;
 
 do32 = rec->do32bit;
 callno = rec->nr;
",487,112
"When reaping a child, release its syscall record lock.

Not strictly necessary, as it would get cleaned up by check_all_locks()
from the the main loop, but this cuts down 2-3 lines of log spew
every time a child segv's while holding a lock."," void reap_child(pid_t childpid)
 
 child = shm->children[i];
 child->syscall.tp = (struct timespec){};
+unlock(&child->syscall.lock);
 shm->running_childs--;
 shm->last_reaped = childpid;
 // FIXME: we do this last because things go walking children
",488,112
move fdstr clearing to later," static void stuck_syscall_info(struct childdata *child)
 if (shm->debug == FALSE)
 return;
 
-memset(fdstr, 0, sizeof(fdstr));
-
 rec = &child->syscall;
 
 if (trylock(&rec->lock) == FALSE)
 static void stuck_syscall_info(struct childdata *child)
 do32 = rec->do32bit;
 callno = rec->nr;
 
+memset(fdstr, 0, sizeof(fdstr));
+
 /* we can only be 'stuck' if we're still doing the syscall. */
 if (rec->state == BEFORE) {
 if (check_if_fd(child, rec) == TRUE)
",513,116
"kill off the reaper lock

This used to provide mutual exclusion between the watchdog process
and the main process. Now that there is no separate watchdog process,
this lock is redundant."," bool check_all_locks(void)
 unsigned int i;
 bool ret = FALSE;
 
-check_lock(&shm->reaper_lock);
 check_lock(&shm->syscalltable_lock);
 
 for_each_child(i)
",94,19
"Remove last_reaped

There shouldn't be any way we can concurrently reap the same pid now."," void reap_child(pid_t childpid)
 struct childdata *child;
 int i;
 
-if (childpid == shm->last_reaped) {// FIXME: Probably not needed now.
-debugf(""already reaped %d!\n"", childpid);
-return;
-}
-
 i = find_childno(childpid);
 if (i == CHILD_NOT_FOUND)
 return;
 void reap_child(pid_t childpid)
 child->syscall.tp = (struct timespec){};
 unlock(&child->syscall.lock);
 shm->running_childs--;
-shm->last_reaped = childpid;
 child->pid = EMPTY_PIDSLOT;
 }
 
",511,117
"mainpid doesn't need to live in the shm any more

Everything is now a descendant of the main process."," void lock(lock_t *_lock)
  * ever get back, and subsequently check_lock().
  * So we add an extra explicit check here.
  */
-if (pid == shm->mainpid) {
+if (pid == mainpid) {
 check_lock(_lock);
 } else {
 /* Ok, we're a child pid.
",94,19
"kill off initpid

This is unnecessary now that init and main are the same process."," FILE *find_logfile_handle(void)
 return NULL;
 
 pid = getpid();
-if (pid == initpid)
-return mainlogfile;
-
 if (pid == mainpid)
 return mainlogfile;
 
",87,20
remove unnecessary clearing of mainpid," int main(int argc, char* argv[])
 
 destroy_global_objects();
 
-mainpid = 0;
-
 output(0, ""Ran %ld syscalls. Successes: %ld Failures: %ld\n"",
 shm->stats.total_syscalls_done - 1, shm->stats.successes, shm->stats.failures);
 
",141,33
move statistics printing out of check_child_progressing," const char * decode_exit(void)
 return reasons[shm->exit_reason];
 }
 
+static unsigned int stall_count = 0;
+
 static void check_child_progressing(void)
 {
-unsigned int stall_count = 0;
 unsigned int i;
 
 for_each_child(i) {
 static void check_child_progressing(void)
 
 if (stall_count == shm->running_childs)
 stall_genocide();
+}
 
+static void print_stats(void)
+{
 if (shm->stats.total_syscalls_done > 1) {
 static unsigned long lastcount = 0;
 
 void main_loop(void)
 tainted_postmortem(ret);
 }
 
+print_stats();
+
 /* We used to waitpid() here without WNOHANG, but now that main_loop()
  * is doing the work the watchdog used to, we need to periodically wake up
  * so instead, we just sleep for a short while.
",515,118
"check_child_progressing actually checks all children

rename it."," const char * decode_exit(void)
 
 static unsigned int stall_count = 0;
 
-static void check_child_progressing(void)
+static void check_children_progressing(void)
 {
 unsigned int i;
 
 void main_loop(void)
 panic(EXIT_REACHED_COUNT);
 }
 
-check_child_progressing();
+check_children_progressing();
 
 /* Only check taint if the mask allows it */
 if (kernel_taint_mask != 0) {
",515,118
free pathnames post syscall," const char * generate_pathname(void)
 
 /* 90% chance of returning an unmangled filename */
 if (!ONE_IN(10))
-return pathname;
+return strdup(pathname);
 
 /* Create a bogus filename. */
-newpath = zmalloc(MAX_PATH_LEN);// FIXME: We leak this.
+newpath = zmalloc(MAX_PATH_LEN);
 
 len = strlen(pathname);
 
",225,53
"if we detect a stuck syscall blocking on an fd, don't reuse it."," static void stuck_syscall_info(struct childdata *child)
 
 /* we can only be 'stuck' if we're still doing the syscall. */
 if (rec->state == BEFORE) {
-if (check_if_fd(child, rec) == TRUE)
+if (check_if_fd(child, rec) == TRUE) {
 sprintf(fdstr, ""(fd = %u)"", (unsigned int) rec->a1);
+shm->fd_lifetime = 0;
+//close(rec->a1);
+//TODO: Remove the fd from the object list.
+}
 }
 
 unlock(&rec->lock);
",517,118
"remove duplicate set_seed(0) call

left-overs from separate init/main process"," int main(int argc, char* argv[])
 
 output(0, ""Main thread is alive.\n"");
 prctl(PR_SET_NAME, (unsigned long) &taskname);
-set_seed(0);
 
 if (open_fds() == FALSE) {
 if (shm->exit_reason != STILL_RUNNING)
",140,33
remove unnecessary print now that we only use one process," int main(int argc, char* argv[])
 
 no_bind_to_cpu = RAND_BOOL();
 
-output(0, ""Main thread is alive.\n"");
 prctl(PR_SET_NAME, (unsigned long) &taskname);
 
 if (open_fds() == FALSE) {
",139,33
allow socket usage when using victim files," static int open_sockets(void)
 int bytesread = -1;
 int ret;
 
-/* If we're doing victim files we probably don't care about sockets. */
-//FIXME: Is this really true ? We might want to sendfile for eg
-if (victim_path != NULL)
-return TRUE;
-
 head = get_objhead(OBJ_GLOBAL, OBJ_FD_SOCKET);
 head->destroy = &socket_destructor;
 
",334,76
free the line after we parse it from /proc/pid/stat," static char get_pid_state(struct childdata *child)
 if (getline(&line, &n, child->pidstatfile) != -1)
 sscanf(line, ""%d %s %c"", &pid, procname, &state);
 
+free(line);
 free(procname);
 return state;
 }
",528,119
"initial seeding cleanup

- remove workaround for no-longer-around init process
- main seeding now happens in init_shm"," unsigned int init_seed(unsigned int seedparam)
 */
 void set_seed(struct childdata *child)
 {
-/* if no shm yet, we must be the init process. */
-if (shm == NULL) {
-srand(new_seed());
-return;
-}
-
 /* if not in child context, we must be main. */
 if (child == NULL) {
-//printf(""Setting shm seed:%u\n"", shm->seed);
+//printf(""Setting main pid seed:%u\n"", shm->seed);
 srand(shm->seed);
 return;
 }
",84,16
rewind the getline file pointer each time we read it.," static char get_pid_state(struct childdata *child)
 if (getpid() != mainpid)
 BUG(""get_pid_state can only be called from main!\n"");
 
+rewind(child->pidstatfile);
 if (getline(&line, &n, child->pidstatfile) != -1)
 sscanf(line, ""%d %s %c"", &pid, procname, &state);
 
",529,119
move responsibility of the clean out of the childdata from the child to main," static void oom_score_adj(int adj)
 /*
 * Wipe out any state left from a previous child running in this slot.
 */
-static void reinit_child(struct childdata *child)
+void clean_childdata(struct childdata *child)
 {
 memset(&child->syscall, 0, sizeof(struct syscallrecord));
-
+child->logdirty = FALSE;
 child->seed = 0;
+child->pid = EMPTY_PIDSLOT;
 child->kill_count = 0;
 child->dontkillme = FALSE;
 }
 void init_child(struct childdata *child, int childno)
 }
 }
 
-reinit_child(child);
-
 set_seed(this_child());
 
 init_object_lists(OBJ_LOCAL);
",258,53
count SIGXCPUs and exit after we see 100 of them.," void clean_childdata(struct childdata *child)
 child->pid = EMPTY_PIDSLOT;
 child->kill_count = 0;
 child->dontkillme = FALSE;
+child->xcpu_count = 0;
 }
 
 static void bind_child_to_cpu(struct childdata *child)
 static bool handle_sigreturn(void)
 */
 void child_process(void)
 {
-struct childdata *child;
+struct childdata *child = this_child();
 int ret;
 
 ret = sigsetjmp(ret_jump, 1);
 if (ret != 0) {
 shm_rw();
 
+if (child->xcpu_count == 100) {
+debugf(""Child %d [%d] got 100 XCPUs. Exiting child.\n"", child->num, child->pid);
+return;
+}
+
 if (handle_sigreturn() == FALSE)
 return;// Exit the child, things are getting too weird.
 }
 
-child = this_child();
-
 while (shm->exit_reason == STILL_RUNNING) {
 unsigned int i;
 
",262,54
"remove the child sanity check for the tvsec progression

Let's just do this in the main process.
(It also fires too many false positives in the child)"," static void check_sanity(struct syscallrecord *rec, struct syscallrecord *stash)
 {
 unsigned int len;
 
-if (stash->tp.tv_sec != 0) {
-// FIXME: Should factor in loadavg here, as with enough pids, a child can exceed 60s
-// without getting scheduled.
-if (rec->tp.tv_sec - stash->tp.tv_sec > 60) {
-output(0, ""Sanity check failed. Something stomped on rec->tp after syscall:%s(%lx, %lx, %lx) was:%lx now:%lx.\n"",
-print_syscall_name(stash->nr, stash->do32bit),
-stash->a1, stash->a2, stash->a3, stash->tp.tv_sec, rec->tp.tv_sec);
-fail_sanity();
-}
-}
-
 len = strlen(stash->prebuffer);
 if (len != strlen(rec->prebuffer)) {
 output(0, ""Sanity check failed: prebuffer length changed from %d to %d after syscall:%s(%lx, %lx, %lx).\n"",
",114,19
"remove the lock-stealing mechanism

This was a bad idea, and it's now unnecessary (hopefully)"," void dump_syscallrec(struct syscallrecord *rec)
 output(0, "" nr:%d a1:%lx a2:%lx a3:%lx a4:%lx a5:%lx a6:%lx retval:%ld errno_post:%d\n"",
 rec->nr, rec->a1, rec->a2, rec->a3, rec->a4, rec->a5, rec->a6, rec->retval, rec->errno_post);
 output(0, "" op_nr:%lx do32bit:%d\n"", rec->op_nr, rec->do32bit);
-output(0, "" lock:%d {owner:%d contention:%ld)\n"", rec->lock.lock, rec->lock.owner, rec->lock.contention);
+output(0, "" lock:%d {owner:%d)\n"", rec->lock.lock, rec->lock.owner);
 output(0, "" state:%d\n"", rec->state);
 output(0, "" prebuffer : %p (len:%d)\n"", rec->prebuffer, strlen(rec->prebuffer));
 output(0, "" -> %s\n"", rec->prebuffer);
",94,12
use a better exit code when we fail sanity," static void fail_sanity(void)
 
 dump_childnos();
 dump_childdata(child);
-panic(EXIT_PID_OUT_OF_RANGE);
+panic(EXIT_SHM_CORRUPTION);
 }
 
 static void check_sanity(struct syscallrecord *rec, struct syscallrecord *stash)
",114,19
"reset stall count before each recount.

When this became a global I forgot to add something to clear it each time
we do a recount."," const char * decode_exit(void)
 return reasons[shm->exit_reason];
 }
 
-static unsigned int stall_count = 0;
+static unsigned int stall_count;
 
 static void check_children_progressing(void)
 {
 unsigned int i;
 
+stall_count = 0;
+
 for_each_child(i) {
 struct childdata *child = shm->children[i];
 struct syscallrecord *rec = &child->syscall;
",531,119
"move the pid back out of the child structure

By reintroducing a global pidslot array we can do better locking
when searching for EMPTY_PIDSLOT. This isn't so much of an issue
right now, but will be soon with some upcoming changes."," static unsigned int render_syscall_prefix(struct syscallrecord *rec, char *buffe
 syscallnr = rec->nr;
 entry = get_syscall_entry(syscallnr, rec->do32bit);
 
-sptr += sprintf(sptr, ""[child%u:%u] [%lu] %s"", child->num, child->pid,
+sptr += sprintf(sptr, ""[child%u:%u] [%lu] %s"", child->num, pids[child->num],
 rec->op_nr,
 rec->do32bit == TRUE ? ""[32BIT] "" : """");
 
",154,40
"remove clearing of pid entry from clear_childdata

This doesn't actually need moving, it's done by reap_child now"," void clean_childdata(struct childdata *child)
 child->kill_count = 0;
 child->dontkillme = FALSE;
 child->xcpu_count = 0;
-//TODO: move out of this function
-pids[child->num] = EMPTY_PIDSLOT;
 }
 
 static void bind_child_to_cpu(struct childdata *child)
",261,54
cache pid locally in various places instead of re-reading from pid array," static int shm_is_corrupt(void)
 
 child = shm->children[i];
 pid = pids[i];
-if (pids[i] == EMPTY_PIDSLOT)
+if (pid == EMPTY_PIDSLOT)
 continue;
 
 if (pid_is_valid(pid) == FALSE) {
 static void stall_genocide(void)
 unsigned int i;
 
 for_each_child(i) {
-if (pids[i] == EMPTY_PIDSLOT)
+pid_t pid = pids[i];
+if (pid == EMPTY_PIDSLOT)
 continue;
 
 if (RAND_BOOL()) {
 int ret;
 
-ret = kill(pids[i], SIGKILL);
+ret = kill(pid, SIGKILL);
 if (ret == 0)
 killed++;
 }
 static void handle_child(pid_t childpid, int childstatus)
 debugf(""All children exited!\n"");
 
 for_each_child(i) {
-if (pids[i] != EMPTY_PIDSLOT) {
-if (pid_alive(pids[i]) == -1) {
-pids[i] = EMPTY_PIDSLOT;
+pid_t pid = pids[i];
+if (pid != EMPTY_PIDSLOT) {
+if (pid_alive(pid) == -1) {
+pid = EMPTY_PIDSLOT;
 shm->running_childs--;
 } else {
-debugf(""%d looks still alive! ignoring.\n"", pids[i]);
+debugf(""%d looks still alive! ignoring.\n"", pid);
 }
 seen = TRUE;
 }
",528,119
pid caching for the child code too," static void bind_child_to_cpu(struct childdata *child)
 {
 cpu_set_t set;
 unsigned int cpudest;
+pid_t pid = pids[child->num];
 
 if (no_bind_to_cpu == TRUE)
 return;
 
-if (sched_getaffinity(pids[child->num], sizeof(set), &set) != 0)
+if (sched_getaffinity(pid, sizeof(set), &set) != 0)
 return;
 
 if (child->num > num_online_cpus)
 static void bind_child_to_cpu(struct childdata *child)
 
 CPU_ZERO(&set);
 CPU_SET(cpudest, &set);
-sched_setaffinity(pids[child->num], sizeof(set), &set);
+sched_setaffinity(pid, sizeof(set), &set);
 }
 
 /*
",262,54
"update the pids array, not the local copy."," static void handle_child(pid_t childpid, int childstatus)
 pid_t pid = pids[i];
 if (pid != EMPTY_PIDSLOT) {
 if (pid_alive(pid) == -1) {
-pid = EMPTY_PIDSLOT;
+pids[i] = EMPTY_PIDSLOT;
 shm->running_childs--;
 } else {
 debugf(""%d looks still alive! ignoring.\n"", pid);
",543,122
"spawn_child return a bool, not -1"," static void fork_children(void)
 exit(EXIT_FAILURE);
 }
 
-if (spawn_child(childno) < 0) {
+if (spawn_child(childno) == FALSE) {
 /* We failed, wait for a child to exit before retrying. */
 if (shm->running_childs > 0)
 return;
",543,122
check buffer length before trying to do some of the longer generators," void generate_rand_bytes(unsigned char *ptr, unsigned int len)
 unsigned int startoffset = 0, remain;
 unsigned char separators[] = { ':', ',', '.', ' ', '-', '\0', };
 unsigned char separator;
+unsigned int randrange = 10;
 
-switch (rnd() % 10) {
+/* If we only have a small buffer, don't do
+ * the longer generators. */
+if (len < 16)
+randrange = 6;
+
+switch (rnd() % randrange) {
 case 0:
 /* Complete garbage. */
 for (i = 0; i < len; i++)
",136,42
make struct fabricator work with less than a page,"
 #include ""random.h""
 #include ""sanitise.h""
 
-static void fabricate_onepage_struct(char *page)
+static void fabricate_struct(char *p, unsigned int len)
 {
 unsigned int i;
 
-for (i = 0; i < page_size; ) {
+for (i = 0; i < len; ) {
 void **ptr;
 
-ptr = (void*) &page[i];
+ptr = (void*) &p[i];
 
 /* 4 byte (32bit) 8 byte (64bit) alignment */
 if (i & ~((__WORDSIZE / 8) - 1)) {
 unsigned long val = 0;
 
 i += sizeof(unsigned long);
-if (i > page_size)
+if (i > len)
 return;
 
 switch (rnd() % 4) {
 static void fabricate_onepage_struct(char *page)
 /* int alignment */
 
 i += sizeof(unsigned int);
-if (i > page_size)
+if (i > len)
 return;
 
 *(unsigned int *)ptr = rand32();
 void generate_rand_bytes(unsigned char *ptr, unsigned int len)
 
 /* return something that looks kinda like a struct */
 case 8:
-if (len >= page_size)
-fabricate_onepage_struct((char *)ptr);
-//FIXME: Do something better here if 'else'
+fabricate_struct((char *)ptr, len);
 return;
 
 /* format strings. */
",135,41
more random 'random struct' generation.," void freeptr(unsigned long *p);
 _array[rnd() % ARRAY_SIZE(_array)]._element
 
 #define RAND_ARRAY(_array) _array[rnd() % ARRAY_SIZE(_array)]
+
+#define IS_ALIGNED(x, a)(((x) & ((typeof(x))(a) - 1)) == 0)
",13,1
The higher page-scribblers only work with an even number of bytes," void generate_rand_bytes(unsigned char *ptr, unsigned int len)
  * the longer generators. */
 if (len < 16)
 randrange = 6;
+else {
+/* Make sure we're always dealing with an even number */
+if (len & 1)
+len--;
+}
 
 switch (rnd() % randrange) {
 case 0:
",158,51
use same null-terminator as elsewhere," void generate_rand_bytes(unsigned char *ptr, unsigned int len)
 break;
 }
 }
-*p = 0;
+ptr[len] = 0;
 break;
 
 /* return something that looks kinda like a struct */
",158,51
case 7 can be up to 20 chars," void generate_rand_bytes(unsigned char *ptr, unsigned int len)
 
 /* If we only have a small buffer, don't do
  * the longer generators. */
-if (len < 16)
+if (len < 20)
 randrange = 6;
 else {
 /* Make sure we're always dealing with an even number */
",158,51
fix stupid off-by-one," void generate_rand_bytes(unsigned char *ptr, unsigned int len)
 break;
 }
 }
-ptr[len] = 0;
+ptr[len-1] = 0;
 break;
 
 /* return something that looks kinda like a struct */
",158,51
"fix rand16 to not shift out of range.

It also didn't match the original intent of this case"," static unsigned long rept_byte(void)
 */
 unsigned short rand16(void)
 {
-unsigned short r = 0;
+unsigned short r = 0, r2;
 
 switch (rnd() % 4) {
 case 0: r = rand_single_bit(16);
 unsigned short rand16(void)
 break;
 case 2: r = rnd();
 break;
-case 3:r = rnd() | (rnd() << 8);
+case 3:r2 = rnd() & 0xff;
+r = r2 | r2 << 8;
 break;
 }
 
",159,49
"masking rand16 with 0xffff is the same as doing nothing

change it to mask with 0xfff instead"," unsigned short rand16(void)
 switch (rnd() % 4) {
 case 0: r &= 0xff;
 break;
-case 1: r &= 0xffff;
+case 1: r &= 0xfff;
 break;
 case 2: r &= PAGE_MASK;
 break;
",159,49
make rand32 sometimes return rand16 ranges," unsigned int rand32(void)
 {
 unsigned long r = 0;
 
-switch (rnd() % 5) {
+switch (rnd() % 6) {
 case 0: r = rand_single_bit(32);
 break;
 case 1:r = randbits(32);
 unsigned int rand32(void)
 case 3:r = rept_byte();
 break;
 case 4:return get_interesting_value();
+case 5:return rand16();
 }
 
 /* Sometimes deduct it from INT_MAX */
",160,50
"bias all three sizes in struct size generation equally

Before, we favored putting them in the evaluation order."," static void fabricate_struct(char *p, unsigned int len)
 
 while (i < len) {
 void **ptr = (void*) &p[i];
+unsigned long val = 0;
 
-if (RAND_BOOL() && IS_ALIGNED(i, 8)) {
-unsigned long val = 0;
+switch (rnd() % 3) {
+case 0:
+if (!IS_ALIGNED(i, 8))
+break;
 
 i += sizeof(unsigned long);
 if (i > len)
 static void fabricate_struct(char *p, unsigned int len)
 }
 
 *(unsigned long *)ptr = val;
-continue;
-}
+break;
+
+case 1:
+if (!IS_ALIGNED(i, 4))
+break;
 
-if (RAND_BOOL() && IS_ALIGNED(i, 4)) {
 i += sizeof(unsigned int);
 if (i > len)
 return;
 
 *(unsigned int *)ptr = rand32();
-continue;
-}
+break;
+
+case 2:
+if (!IS_ALIGNED(i, 2))
+break;
 
-if (RAND_BOOL() && IS_ALIGNED(i, 2)) {
 if (RAND_BOOL()) {
 /* one u16 */
 i += sizeof(unsigned short);
 static void fabricate_struct(char *p, unsigned int len)
 }
 *(unsigned char *)ptr = RAND_BYTE();
 }
-continue;
+break;
 }
 }
 }
",163,51
"Add MCL_ONFAULT to mlockall calls

The new mlock2 system call was added, but it looks like the MCL_ONFAULT
flag was missed. This is now a valid flag to pass to mlockall(), but it
must be used in conjunction with either MCL_CURRENT or MCL_FUTURE (or
both). Also rework the way that the flags value for mlockall() is
caclulated. It is valid to pass any combination of the MCL_* flags
except for MCL_ONFAULT alone.

Signed-off-by: Eric B Munson <emunson@akamai.com>
Cc: Dave Jones <davej@codemonkey.org.uk>","
 
 #define MCL_CURRENT 1
 #define MCL_FUTURE 2
+#define MCL_ONFAULT4
 
 static void sanitise_mlockall(struct syscallrecord *rec)
 {
 if (rec->a1 != 0)
 return;
 
-if (RAND_BOOL())
-rec->a1 = MCL_CURRENT;
-else
-rec->a1 = MCL_FUTURE;
+/*
+ * There are two invalid bit patterns for MCL flags, 0, and MCL_ONFAULT
+ * alone. All other combinations should be valid.
+ */
+while (rec->a1 == 0 || rec->a1 == MCL_ONFAULT)
+rec->a1 = (RAND_BYTE() & 0x07);
 }
 
 static unsigned long mlockall_flags[] = {
-MCL_CURRENT, MCL_FUTURE,
+MCL_CURRENT, MCL_FUTURE, MCL_ONFAULT,
 };
 
 struct syscallentry syscall_mlockall = {
",25,4
the 'stop' argument to handle_childsig is a boolean," static void fork_children(void)
 shm->ready = TRUE;
 }
 
-static void handle_childsig(int childno, int childstatus, int stop)
+static void handle_childsig(int childno, int childstatus, bool stop)
 {
 struct childdata *child;
 int __sig;
",547,122
add recent socket setsockopts," static const unsigned int socket_opts[] = {
 SO_PROTOCOL, SO_DOMAIN, SO_RXQ_OVFL, SO_WIFI_STATUS,
 SO_PEEK_OFF, SO_NOFCS, SO_LOCK_FILTER, SO_SELECT_ERR_QUEUE,
 SO_BUSY_POLL, SO_MAX_PACING_RATE, SO_BPF_EXTENSIONS, SO_INCOMING_CPU,
+SO_ATTACH_BPF, SO_ATTACH_REUSEPORT_CBPF, SO_ATTACH_REUSEPORT_EBPF,
 };
 
 void socket_setsockopt(struct sockopt *so)
",44,5
remove bogus comment. this is actually still true.," void init_shm(void)
 memset(shm->children, 0, childptrslen);
 
 /* We allocate the childdata structs as shared mappings, because
- * the watchdog process needs to peek into each childs syscall records
+ * the forking process needs to peek into each childs syscall records
  * to make sure they are making progress.
- //FIXME: No longer true.
  */
 for_each_child(i) {
 struct childdata *child;
",66,9
add a userfaultfd provider,"
 #include ""shm.h""
 #include ""trinity.h""
 #include ""testfile.h""
+#include ""userfaultfd.h""
 #include ""utils.h""
 
 static unsigned int num_fd_providers;
 void setup_fd_providers(void)
 add_to_prov_list(&memfd_fd_provider);
 add_to_prov_list(&drm_fd_provider);
 add_to_prov_list(&inotify_fd_provider);
+add_to_prov_list(&userfaultfd_provider);
 
 output(0, ""Registered %d fd providers.\n"", num_fd_providers);
 }
",175,25
fd provider for fanotify,"
 
 #include ""epoll.h""
 #include ""eventfd.h""
+#include ""fanotify.h""
 #include ""fd.h""
 #include ""files.h""
 #include ""log.h""
 void setup_fd_providers(void)
 add_to_prov_list(&drm_fd_provider);
 add_to_prov_list(&inotify_fd_provider);
 add_to_prov_list(&userfaultfd_provider);
+add_to_prov_list(&fanotify_fd_provider);
 
 output(0, ""Registered %d fd providers.\n"", num_fd_providers);
 }
",177,25
fix broken cut-n-paste and add in missing bits for fanotify to work," static int open_fanotify_fds(void)
 struct objhead *head;
 unsigned int i;
 
-head = get_objhead(OBJ_GLOBAL, OBJ_FD_USERFAULTFD);
+head = get_objhead(OBJ_GLOBAL, OBJ_FD_FANOTIFY);
 head->destroy = &fanotifyfd_destructor;
 
 for (i = 0; i < NR_INOTIFYFDS; i++) {
 static int open_fanotify_fds(void)
 
 obj = alloc_object();
 obj->fanotifyfd = fd;
-add_object(obj, OBJ_GLOBAL, OBJ_FD_USERFAULTFD);
+add_object(obj, OBJ_GLOBAL, OBJ_FD_FANOTIFY);
 
 output(2, ""fd[%d] = fanotify_init\n"", fd);
 }
 static int get_rand_fanotifyfd(void)
 struct object *obj;
 
 /* check if eventfd unavailable/disabled. */
-if (objects_empty(OBJ_FD_USERFAULTFD) == TRUE)
+if (objects_empty(OBJ_FD_FANOTIFY) == TRUE)
 return -1;
 
-obj = get_random_object(OBJ_FD_USERFAULTFD, OBJ_GLOBAL);
+obj = get_random_object(OBJ_FD_FANOTIFY, OBJ_GLOBAL);
 return obj->fanotifyfd;
 }
 
",61,8
dump the fanotify flags too," static int open_fanotify_fds(void)
 obj->fanotifyfd = fd;
 add_object(obj, OBJ_GLOBAL, OBJ_FD_FANOTIFY);
 
-output(2, ""fd[%d] = fanotify_init\n"", fd);
+output(2, ""fd[%d] = fanotify_init(%lx, %lx)\n"", fd, flags, eventflags);
 }
 
 //FIXME: right now, returning FALSE means ""abort everything"", not
",61,8
"start abstracting away per-protocol stuff

socket.c shouldn't need to know directly about the individual protocols.
Start by moving socket creation. Initially, just netlink.
Eventually, things like setsockopt, and more will also move to the
netproto struct."," void netlink_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 *addrlen = sizeof(struct sockaddr_nl);
 }
 
-void netlink_rand_socket(struct socket_triplet *st)
+static void netlink_rand_socket(struct socket_triplet *st)
 {
 if (RAND_BOOL())
 st->type = SOCK_RAW;
 void netlink_setsockopt(struct sockopt *so)
 {
 so->optname = RAND_ARRAY(netlink_opts);
 }
+
+struct netproto proto_netlink = {
+.name = ""netlink"",
+.socket = netlink_rand_socket,
+};
",56,5
convert AF_UNIX to use netproto struct," void unix_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 *addrlen = sizeof(struct sockaddr_un);
 }
 
-void unix_rand_socket(struct socket_triplet *st)
+static void unix_rand_socket(struct socket_triplet *st)
 {
 st->protocol = PF_UNIX;
 
 void unix_rand_socket(struct socket_triplet *st)
 default:break;
 }
 }
+
+struct netproto proto_unix = {
+.name = ""unix"",
+.socket = unix_rand_socket,
+};
",37,5
convert AF_INET to use netproto struct," struct ipproto {
 unsigned int type;
 };
 
-void inet_rand_socket(struct socket_triplet *st)
+static void inet_rand_socket(struct socket_triplet *st)
 {
 struct ipproto ipprotos[] = {
 { .proto = IPPROTO_IP, },
 void ip_setsockopt(struct sockopt *so)
 break;
 }
 }
+
+struct netproto proto_ipv4 = {
+.name = ""ipv4"",
+.socket = inet_rand_socket,
+};
",229,23
convert AF_AX25 to use netproto struct," static int ax25_protocols[NR_AX25_PROTOS] = {
 0xF0 /* No layer 3 protocol impl. */
 };
 
-void ax25_rand_socket(struct socket_triplet *st)
+static void ax25_rand_socket(struct socket_triplet *st)
 {
 switch (rnd() % 3) {
 case 0: st->type = SOCK_DGRAM;
 void ax25_setsockopt(struct sockopt *so)
 {
 so->optname = RAND_ARRAY(ax25_opts);
 }
+
+struct netproto proto_ax25 = {
+.name = ""ax25"",
+.socket = ax25_rand_socket,
+};
",63,6
convert PF_IPX to use netproto struct," void ipx_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 *addrlen = sizeof(struct sockaddr_ipx);
 }
 
-void ipx_rand_socket(struct socket_triplet *st)
+static void ipx_rand_socket(struct socket_triplet *st)
 {
 st->protocol = rnd() % PROTO_MAX;
 st->type = SOCK_DGRAM;
 void ipx_setsockopt(struct sockopt *so)
 {
 so->optname = IPX_TYPE;
 }
+
+struct netproto proto_ipx = {
+.name = ""ipx"",
+.socket = ipx_rand_socket,
+};
",37,4
convert PF_APPLETALK to use struct netproto," void atalk_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 *addrlen = sizeof(struct sockaddr_at);
 }
 
-void atalk_rand_socket(struct socket_triplet *st)
+static void atalk_rand_socket(struct socket_triplet *st)
 {
 if (RAND_BOOL()) {
 st->type = SOCK_DGRAM;
 void atalk_rand_socket(struct socket_triplet *st)
 st->protocol = rnd() % PROTO_MAX;
 st->type = SOCK_RAW;
 }
+
+struct netproto proto_appletalk = {
+.name = ""appletalk"",
+.socket = atalk_rand_socket,
+};
 #endif
",36,3
convert PF_X25 to struct netproto," void x25_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 *addrlen = sizeof(struct sockaddr_x25);
 }
 
-void x25_rand_socket(struct socket_triplet *st)
+static void x25_rand_socket(struct socket_triplet *st)
 {
 st->type = SOCK_SEQPACKET;
 st->protocol = 0;
 void x25_setsockopt(struct sockopt *so)
 
 so->optlen = sizeof(int);
 }
+
+struct netproto proto_x25 = {
+.name = ""x25"",
+.socket = x25_rand_socket,
+};
",36,3
convert PF_INET6 to struct netproto," void ipv6_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 *addrlen = sizeof(struct sockaddr_in6);
 }
 
-void inet6_rand_socket(struct socket_triplet *st)
+static void inet6_rand_socket(struct socket_triplet *st)
 {
 // Use the same socket generator as ipv4
 proto_ipv4.socket(st);
 void inet6_setsockopt(struct sockopt *so)
 
 }
 }
+
+struct netproto proto_inet6 = {
+.name = ""inet6"",
+.socket = inet6_rand_socket,
+};
+
 #endif
",166,17
convert PF_DECnet to struct netproto," void decnet_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 *addrlen = sizeof(struct sockaddr_dn);
 }
 
-void decnet_rand_socket(struct socket_triplet *st)
+static void decnet_rand_socket(struct socket_triplet *st)
 {
 if (RAND_BOOL()) {
 st->type = SOCK_SEQPACKET;
 void decnet_setsockopt(struct sockopt *so)
 
 // TODO: set optlen correctly
 }
+
+struct netproto proto_decnet = {
+.name = ""decnet"",
+.socket = decnet_rand_socket,
+};
",52,5
convert PF_PACKET to use struct netproto," void packet_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 *addrlen = sizeof(struct sockaddr_pkt);
 }
 
-void packet_rand_socket(struct socket_triplet *st)
+static void packet_rand_socket(struct socket_triplet *st)
 {
 st->protocol = htons(ETH_P_ALL);
 
 void packet_setsockopt(struct sockopt *so)
 break;
 }
 }
+
+struct netproto proto_packet = {
+.name = ""packet"",
+.socket = packet_rand_socket,
+};
",68,13
convert PF_RDS to use struct netproto,"
 #include ""random.h""
 #include ""utils.h""// RAND_ARRAY
 
-void rds_rand_socket(struct socket_triplet *st)
+static void rds_rand_socket(struct socket_triplet *st)
 {
 st->protocol = 0;
 st->type = SOCK_SEQPACKET;
 void rds_setsockopt(struct sockopt *so)
 so->optname = RAND_ARRAY(rds_opts);
 }
 
+struct netproto proto_rds = {
+.name = ""rds"",
+.socket = rds_rand_socket,
+};
 #else
 /* stub if we are built on something without RDS headers */
 void rds_setsockopt(struct sockopt *so)
",38,4
convert PF_IRDA to use struct netproto," void irda_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 *addrlen = sizeof(struct sockaddr_irda);
 }
 
-void irda_rand_socket(struct socket_triplet *st)
+static void irda_rand_socket(struct socket_triplet *st)
 {
 switch (rnd() % 3) {
 
 void irda_setsockopt(struct sockopt *so)
 {
 so->optname = RAND_ARRAY(irda_opts);
 }
+
+struct netproto proto_irda = {
+.name = ""irda"",
+.socket = irda_rand_socket,
+};
",55,8
convert PF_LLC to use struct netproto," void llc_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 *addrlen = sizeof(struct sockaddr_llc);
 }
 
-void llc_rand_socket(struct socket_triplet *st)
+static void llc_rand_socket(struct socket_triplet *st)
 {
 st->protocol = rnd() % PROTO_MAX;
 if (RAND_BOOL())
 void llc_setsockopt(struct sockopt *so)
 {
 so->optname = RAND_ARRAY(llc_opts);
 }
+
+struct netproto proto_llc = {
+.name = ""llc"",
+.socket = llc_rand_socket,
+};
",50,5
convert PF_CAN to use struct netproto," void can_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 *addrlen = sizeof(struct sockaddr_can);
 }
 
-void can_rand_socket(struct socket_triplet *st)
+static void can_rand_socket(struct socket_triplet *st)
 {
 st->protocol = rnd() % 7; // CAN_NPROTO
 st->type = rnd() % TYPE_MAX;
 }
+
+struct netproto proto_can = {
+.name = ""can"",
+.socket = can_rand_socket,
+};
",30,2
convert PF_TIPC to use struct netproto," void tipc_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 *addrlen = sizeof(struct sockaddr_tipc);
 }
 
-void tipc_rand_socket(struct socket_triplet *st)
+static void tipc_rand_socket(struct socket_triplet *st)
 {
 st->protocol = 0;
 
 void tipc_setsockopt(struct sockopt *so)
 
 so->optlen = sizeof(__u32);
 }
+
+struct netproto proto_tipc = {
+.name = ""tipc"",
+.socket = tipc_rand_socket,
+};
",54,6
convert PF_BLUETOOTH to use struct netproto," void bluetooth_setsockopt(struct sockopt *so)
 #define BTPROTO_HIDP 6
 #define BTPROTO_AVDTP 7
 
-void bluetooth_rand_socket(struct socket_triplet *st)
+static void bluetooth_rand_socket(struct socket_triplet *st)
 {
 int bt_protos[] = {
 BTPROTO_L2CAP, BTPROTO_HCI, BTPROTO_SCO, BTPROTO_RFCOMM,
 void bluetooth_rand_socket(struct socket_triplet *st)
 st->protocol = RAND_ARRAY(bt_protos);
 st->type = RAND_ARRAY(types);
 }
+
+struct netproto proto_bluetooth = {
+.name = ""bluetooth"",
+.socket = bluetooth_rand_socket,
+};
",60,12
convert PF_PHONET to use struct netproto," void phonet_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 *addrlen = sizeof(struct sockaddr_pn);
 }
 
-void phonet_rand_socket(struct socket_triplet *st)
+static void phonet_rand_socket(struct socket_triplet *st)
 {
 st->protocol = 0;
 if (RAND_BOOL())
 void phonet_rand_socket(struct socket_triplet *st)
 else
 st->type = SOCK_SEQPACKET;
 }
+
+struct netproto proto_phonet = {
+.name = ""phonet"",
+.socket = phonet_rand_socket,
+};
",33,3
convert PF_CAIF to use struct netproto," void caif_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 *addrlen = sizeof(struct sockaddr_caif);
 }
 
-void caif_rand_socket(struct socket_triplet *st)
+static void caif_rand_socket(struct socket_triplet *st)
 {
 st->protocol = rnd() % _CAIFPROTO_MAX;
 if (RAND_BOOL())
 void caif_setsockopt(struct sockopt *so)
 {
 so->optname = RAND_ARRAY(caif_opts);
 }
+struct netproto proto_caif = {
+.name = ""caif"",
+.socket = caif_rand_socket,
+};
 #else
 /* stub if we are built on something without CAIF headers */
 void caif_setsockopt(struct sockopt *so)
",52,7
convert PF_NFC to use struct netproto," void nfc_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 *addrlen = sizeof(struct sockaddr_nfc);
 }
 
-void nfc_rand_socket(struct socket_triplet *st)
+static void nfc_rand_socket(struct socket_triplet *st)
 {
 if (RAND_BOOL()) {
 st->protocol = NFC_SOCKPROTO_LLCP;
 void nfc_rand_socket(struct socket_triplet *st)
 st->protocol = NFC_SOCKPROTO_RAW;
 st->type = SOCK_SEQPACKET;
 }
+
+struct netproto proto_nfc = {
+.name = ""nfc"",
+.socket = nfc_rand_socket,
+};
",38,4
"as we did with ->socket, start converting setsockopt"," static const unsigned int ax25_opts[] = {
 SO_BINDTODEVICE
 };
 
-void ax25_setsockopt(struct sockopt *so)
+static void ax25_setsockopt(struct sockopt *so)
 {
+so->level = SOL_AX25;
 so->optname = RAND_ARRAY(ax25_opts);
 }
 
 struct netproto proto_ax25 = {
 .name = ""ax25"",
 .socket = ax25_rand_socket,
+.setsockopt = ax25_setsockopt,
 };
",65,6
convert IPX setsockopt to use netproto," static void ipx_rand_socket(struct socket_triplet *st)
 st->type = SOCK_DGRAM;
 }
 
-void ipx_setsockopt(struct sockopt *so)
+static void ipx_setsockopt(struct sockopt *so)
 {
+so->level = SOL_IPX;
 so->optname = IPX_TYPE;
 }
 
 struct netproto proto_ipx = {
 .name = ""ipx"",
 .socket = ipx_rand_socket,
+.setsockopt = ipx_setsockopt,
 };
",39,4
convert ATALK to use netproto setsockopt," static void atalk_rand_socket(struct socket_triplet *st)
 st->type = SOCK_RAW;
 }
 
+static void atalk_setsockopt(struct sockopt *so)
+{
+so->level = SOL_ATALK;
+}
+
 struct netproto proto_appletalk = {
 .name = ""appletalk"",
 .socket = atalk_rand_socket,
+.setsockopt = atalk_setsockopt,
 };
 #endif
",41,4
convert netrom to use struct netproto,"
 #include ""random.h""
 #include ""utils.h""// RAND_ARRAY
 
-static const unsigned int netrom_opts[] = {
-NETROM_T1, NETROM_T2, NETROM_N2, NETROM_T4, NETROM_IDLE
-};
-
-void netrom_setsockopt(struct sockopt *so)
+static void netrom_setsockopt(struct sockopt *so)
 {
+const unsigned int netrom_opts[] = {
+NETROM_T1, NETROM_T2, NETROM_N2, NETROM_T4, NETROM_IDLE
+};
+
+so->level = SOL_NETROM;
 so->optname = RAND_ARRAY(netrom_opts);
 }
+
+struct netproto proto_netrom = {
+.name = ""netrom"",
+//.socket = netrom_rand_socket,
+.setsockopt = netrom_setsockopt,
+};
 #endif
",19,1
convert ATM to use struct netproto," static const unsigned int atm_opts[] = {
 SO_SETCLP, SO_CIRANGE, SO_ATMQOS, SO_ATMSAP, SO_ATMPVC, SO_MULTIPOINT,
 };
 
-void atm_setsockopt(struct sockopt *so)
+static void atm_setsockopt(struct sockopt *so)
 {
+so->level = SOL_ATM;
 so->optname = RAND_ARRAY(atm_opts);
 }
+
+struct netproto proto_atm = {
+.name = ""atm"",
+//.socket = atm_rand_socket,
+.setsockopt = atm_setsockopt,
+};
",50,5
convert x25 to use struct netproto for setsockopt," static void x25_rand_socket(struct socket_triplet *st)
 st->protocol = 0;
 }
 
-void x25_setsockopt(struct sockopt *so)
+static void x25_setsockopt(struct sockopt *so)
 {
 unsigned int *optval;
 
+so->level = SOL_X25;
+
 optval = (unsigned int *) so->optval;
 *optval = RAND_BOOL();
 
 void x25_setsockopt(struct sockopt *so)
 struct netproto proto_x25 = {
 .name = ""x25"",
 .socket = x25_rand_socket,
+.setsockopt = x25_setsockopt,
 };
",38,3
convert INET6 setsockopt to use struct netproto," static const struct sock_option inet6_opts[] = {
 { .name = IPV6_UNICAST_IF, },
 };
 
-void inet6_setsockopt(struct sockopt *so)
+static void inet6_setsockopt(struct sockopt *so)
 {
 unsigned char val;
 
+so->level = SOL_IPV6;
+
 val = rnd() % ARRAY_SIZE(inet6_opts);
 so->optname = inet6_opts[val].name;
 so->optlen = sockoptlen(inet6_opts[val].len);
 void inet6_setsockopt(struct sockopt *so)
 struct netproto proto_inet6 = {
 .name = ""inet6"",
 .socket = inet6_rand_socket,
+.setsockopt = inet6_setsockopt,
 };
 
 #endif
",168,17
convert ROSE to use netproto for setsockopt," static const unsigned int rose_opts[] = {
 ROSE_IDLE, ROSE_QBITINCL, ROSE_HOLDBACK,
 };
 
-void rose_setsockopt(struct sockopt *so)
+static void rose_setsockopt(struct sockopt *so)
 {
+so->level = SOL_ROSE;
 so->optname = RAND_ARRAY(rose_opts);
 }
+struct netproto proto_rose = {
+.name = ""rose"",
+// .socket = rose_rand_socket,
+.setsockopt = rose_setsockopt,
+};
 #endif
",41,2
convert DECNET to use struct netproto for setsockopt," static const unsigned int decnet_opts[] = {
 DSO_SERVICES, DSO_INFO
 };
 
-void decnet_setsockopt(struct sockopt *so)
+static void decnet_setsockopt(struct sockopt *so)
 {
+so->level = SOL_DECNET;
 so->optname = RAND_ARRAY(decnet_opts);
 
 // TODO: set optlen correctly
 void decnet_setsockopt(struct sockopt *so)
 struct netproto proto_decnet = {
 .name = ""decnet"",
 .socket = decnet_rand_socket,
+.setsockopt = decnet_setsockopt,
 };
",54,5
convert PF_NETBEUI to use netproto struct,"
+#include ""net.h""
+
+static void netbeui_setsockopt(struct sockopt *so)
+{
+so->level = SOL_NETBEUI;
+}
+
+struct netproto proto_netbeui = {
+.name = ""netbeui"",
+//.socket = netbeui_rand_socket,
+.setsockopt = netbeui_setsockopt,
+};
",9,1
convert netlink setsockopt to use struct netproto," static const unsigned int netlink_opts[] = {
 NETLINK_LIST_MEMBERSHIPS, NETLINK_CAP_ACK,
 };
 
-void netlink_setsockopt(struct sockopt *so)
+static void netlink_setsockopt(struct sockopt *so)
 {
+so->level = SOL_NETLINK;
 so->optname = RAND_ARRAY(netlink_opts);
 }
 
 struct netproto proto_netlink = {
 .name = ""netlink"",
 .socket = netlink_rand_socket,
+.setsockopt = netlink_setsockopt,
 };
",58,5
convert PF_PACKET to use struct netproto for setsockopt," static const unsigned int packet_opts[] = {
 PACKET_TIMESTAMP, PACKET_FANOUT,
 };
 
-void packet_setsockopt(struct sockopt *so)
+static void packet_setsockopt(struct sockopt *so)
 {
 char *optval;
 
+so->level = SOL_PACKET;
+
 optval = (char *) so->optval;
 
 so->optname = RAND_ARRAY(packet_opts);
 void packet_setsockopt(struct sockopt *so)
 struct netproto proto_packet = {
 .name = ""packet"",
 .socket = packet_rand_socket,
+.setsockopt = packet_setsockopt,
 };
",70,13
convert PF_RDS to use struct netproto for setsockopt," static const unsigned int rds_opts[] = {
 RDS_RECVERR, RDS_CONG_MONITOR, RDS_GET_MR_FOR_DEST,
 };
 
-void rds_setsockopt(struct sockopt *so)
+static void rds_setsockopt(struct sockopt *so)
 {
+so->level = SOL_RDS;
 so->optname = RAND_ARRAY(rds_opts);
 }
 
 struct netproto proto_rds = {
 .name = ""rds"",
 .socket = rds_rand_socket,
+.setsockopt = rds_setsockopt,
 };
 #else
 /* stub if we are built on something without RDS headers */
",40,4
convert PF_IRDA to use struct netproto for setsockopt," static const unsigned int irda_opts[] = {
 IRLMP_IAS_DEL, IRLMP_HINT_MASK_SET, IRLMP_WAITDEVICE
 };
 
-void irda_setsockopt(struct sockopt *so)
+static void irda_setsockopt(struct sockopt *so)
 {
+so->level = SOL_IRDA;
 so->optname = RAND_ARRAY(irda_opts);
 }
 
 struct netproto proto_irda = {
 .name = ""irda"",
 .socket = irda_rand_socket,
+.setsockopt = irda_setsockopt,
 };
",57,8
convert PPPOX to use struct netproto," static const unsigned int pppol2tp_opts[] = {
 PPPOL2TP_SO_DEBUG, PPPOL2TP_SO_RECVSEQ, PPPOL2TP_SO_SENDSEQ, PPPOL2TP_SO_LNSMODE,
 PPPOL2TP_SO_REORDERTO };
 
-void pppol2tp_setsockopt(struct sockopt *so)
+static void pppol2tp_setsockopt(struct sockopt *so)
 {
+so->level = SOL_PPPOL2TP;
 so->optname = RAND_ARRAY(pppol2tp_opts);
 
 so->optlen = sizeof(int);
 }
+
+struct netproto proto_pppol2tp = {
+.name = ""pppol2tp"",
+//.socket = pppol2tp_rand_socket,
+.setsockopt = pppol2tp_setsockopt,
+};
",144,15
convert PF_LLC to use struct netproto for setsockopt," static const unsigned int llc_opts[] = {
 LLC_OPT_PKTINFO,
 };
 
-void llc_setsockopt(struct sockopt *so)
+static void llc_setsockopt(struct sockopt *so)
 {
+so->level = SOL_LLC;
 so->optname = RAND_ARRAY(llc_opts);
 }
 
 struct netproto proto_llc = {
 .name = ""llc"",
 .socket = llc_rand_socket,
+.setsockopt = llc_setsockopt,
 };
",52,5
convert PF_TIPC to use struct netproto for setsockopt," static const unsigned int tipc_opts[] = {
 TIPC_NODE_RECVQ_DEPTH, TIPC_SOCK_RECVQ_DEPTH,
 };
 
-void tipc_setsockopt(struct sockopt *so)
+static void tipc_setsockopt(struct sockopt *so)
 {
+so->level = SOL_TIPC;
+
 so->optname = RAND_ARRAY(tipc_opts);
 
 so->optlen = sizeof(__u32);
 void tipc_setsockopt(struct sockopt *so)
 struct netproto proto_tipc = {
 .name = ""tipc"",
 .socket = tipc_rand_socket,
+.setsockopt = tipc_setsockopt,
 };
",56,6
convert PF_BLUETOOTH to use struct netproto for setsockopt," static const unsigned int bluetooth_l2cap_opts[] = {
 static const unsigned int bluetooth_rfcomm_opts[] = { RFCOMM_LM };
 
 
-void bluetooth_setsockopt(struct sockopt *so)
+static void bluetooth_setsockopt(struct sockopt *so)
 {
+so->level = SOL_BLUETOOTH;
+
 switch(rnd() % 5) {
 case 0: so->level = SOL_HCI; break;
 case 1: so->level = SOL_L2CAP; break;
 static void bluetooth_rand_socket(struct socket_triplet *st)
 struct netproto proto_bluetooth = {
 .name = ""bluetooth"",
 .socket = bluetooth_rand_socket,
+.setsockopt = bluetooth_setsockopt,
 };
",62,12
convert PF_IUCV to use struct netproto for setsockopt," static const unsigned int iucv_opts[] = {
 SO_IPRMDATA_MSG, SO_MSGLIMIT, SO_MSGSIZE
 };
 
-void iucv_setsockopt(struct sockopt *so)
+static void iucv_setsockopt(struct sockopt *so)
 {
+so->level = SOL_IUCV;
+
 so->optname = RAND_ARRAY(iucv_opts);
 
 so->optlen = sizeof(int);
 }
+
+struct netproto proto_iucv = {
+.name = ""iucv"",
+//.socket = iucv_rand_socket,
+.setsockopt = iucv_setsockopt,
+};
",18,1
convert PF_RXRPC to use struct netproto for setsockopt," static const unsigned int rxrpc_opts[] = {
 RXRPC_BUSY, RXRPC_LOCAL_ERROR, RXRPC_NEW_CALL, RXRPC_ACCEPT,
 };
 
-void rxrpc_setsockopt(struct sockopt *so)
+static void rxrpc_setsockopt(struct sockopt *so)
 {
+so->level = SOL_RXRPC;
+
 so->optname = RAND_ARRAY(rxrpc_opts);
 }
+
+struct netproto proto_rxrpc = {
+.name = ""rxrpc"",
+//.socket = rxrpc_rand_socket,
+.setsockopt = rxrpc_setsockopt,
+};
",18,1
convert PF_PHONET to use struct netproto for setsockopt," static void phonet_rand_socket(struct socket_triplet *st)
 st->type = SOCK_SEQPACKET;
 }
 
+static void phonet_setsockopt(struct sockopt *so)
+{
+so->level = SOL_PNPIPE;
+}
+
 struct netproto proto_phonet = {
 .name = ""phonet"",
 .socket = phonet_rand_socket,
+.setsockopt = phonet_setsockopt,
 };
",38,4
convert PF_CAIF to use struct netproto for setsockopt," static const unsigned int caif_opts[] = {
 CAIFSO_LINK_SELECT, CAIFSO_REQ_PARAM
 };
 
-void caif_setsockopt(struct sockopt *so)
+static void caif_setsockopt(struct sockopt *so)
 {
+so->level = SOL_CAIF;
+
 so->optname = RAND_ARRAY(caif_opts);
 }
 struct netproto proto_caif = {
 .name = ""caif"",
 .socket = caif_rand_socket,
+.setsockopt = caif_setsockopt,
 };
-#else
-/* stub if we are built on something without CAIF headers */
-void caif_setsockopt(struct sockopt *so)
-{
-}
 #endif
",51,6
convert PF_ALG to use struct netproto for setsockopt," void alg_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 *addr = (struct sockaddr *) alg;
 *addrlen = sizeof(struct sockaddr_alg);
 }
+
+static void alg_setsockopt(struct sockopt *so)
+{
+so->level = SOL_ALG;
+}
+
+struct netproto proto_alg = {
+.name = ""alg"",
+//.socket = alg_rand_socket,
+.setsockopt = alg_setsockopt,
+};
 #endif
",237,6
convert PF_NFC to use struct netproto for setsockopt," static void nfc_rand_socket(struct socket_triplet *st)
 st->type = SOCK_SEQPACKET;
 }
 
+static void nfc_setsockopt(struct sockopt *so)
+{
+so->level = SOL_NFC;
+}
+
 struct netproto proto_nfc = {
 .name = ""nfc"",
 .socket = nfc_rand_socket,
+.setsockopt = nfc_setsockopt,
 };
",43,5
check that we have a valid socket pointer before jumping to it.," int sanitise_socket_triplet(struct socket_triplet *st)
 const struct netproto *proto;
 
 proto = net_protocols[st->family].proto;
-if (proto != NULL)
-proto->socket(st);
+if (proto != NULL) {
+if (proto->socket != NULL)
+proto->socket(st);
+}
 
 /* Couldn't find func, fall back to random. */
 return -1;
",87,21
"Move IP related stuff out of setsockopt.c into proto-ipv4.c

This requires us to pass the triplet down, so that we can figure
out which IP protocol we're talking, so this cset impacts all protocols."," void alg_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 *addrlen = sizeof(struct sockaddr_alg);
 }
 
-static void alg_setsockopt(struct sockopt *so)
+static void alg_setsockopt(struct sockopt *so, __unused__ struct socket_triplet *triplet)
 {
 so->level = SOL_ALG;
 }
",237,6
make perf fd generation ctrl-c'able," static int open_perf_fds(void)
  * perf_event_open threw it out. Go around the loop again.
  */
 }
+
+if (shm->exit_reason != STILL_RUNNING)
+return FALSE;
 }
 
 return TRUE;
",58,8
introduce a gen_sockaddr funcptr to netproto struct," static const struct sa_func_entry sa_funcs[] = {
 
 void generate_sockaddr(struct sockaddr **addr, socklen_t *addrlen, int pf)
 {
+const struct netproto *proto;
 unsigned int i;
 
 /* If we want sockets of a specific type, we'll want sockaddrs that match. */
 void generate_sockaddr(struct sockaddr **addr, socklen_t *addrlen, int pf)
 if (pf == -1)
 pf = rnd() % TRINITY_PF_MAX;
 
+proto = net_protocols[pf].proto;
+if (proto != NULL) {
+if (proto->gen_sockaddr != NULL) {
+// eventually the common case.
+proto->gen_sockaddr(addr, addrlen);
+return;
+}
+}
+
+/* fallback case for the array above. will go away soon.*/
 for (i = 0; i < ARRAY_SIZE(sa_funcs); i++) {
 if (sa_funcs[i].pf == (unsigned int) pf) {
 sa_funcs[i].func(addr, addrlen);
",69,7
convert PF_UNIX to use gen_sockaddr,"
 #include ""random.h""
 #include ""utils.h""
 
-void unix_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
+static void unix_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 {
 struct sockaddr_un *unixsock;
 unsigned int len;
 static void unix_rand_socket(struct socket_triplet *st)
 struct netproto proto_unix = {
 .name = ""unix"",
 .socket = unix_rand_socket,
+.gen_sockaddr = unix_gen_sockaddr,
 };
",38,5
convert PF_INET to use gen_sockaddr," in_addr_t random_ipv4_address(void)
 return addr;
 }
 
-void ipv4_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
+static void ipv4_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 {
 struct sockaddr_in *ipv4;
 struct in_addr serv_addr;
 struct netproto proto_ipv4 = {
 .name = ""ipv4"",
 .socket = inet_rand_socket,
 .setsockopt = inet_setsockopt,
+.gen_sockaddr = ipv4_gen_sockaddr,
 };
",282,28
convert PF_AX25 to use gen_sockaddr,"
 #include ""utils.h""// RAND_ARRAY
 #include ""compat.h""
 
-void ax25_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
+static void ax25_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 {
 struct sockaddr_ax25 *ax25;
 
 struct netproto proto_ax25 = {
 .name = ""ax25"",
 .socket = ax25_rand_socket,
 .setsockopt = ax25_setsockopt,
+.gen_sockaddr = ax25_gen_sockaddr,
 };
",66,6
convert PF_IPX to use gen_sockaddr,"
 #include ""random.h""
 #include ""utils.h""
 
-void ipx_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
+static void ipx_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 {
 struct sockaddr_ipx *ipx;
 unsigned int i;
 struct netproto proto_ipx = {
 .name = ""ipx"",
 .socket = ipx_rand_socket,
 .setsockopt = ipx_setsockopt,
+.gen_sockaddr = ipx_gen_sockaddr,
 };
",40,4
convert PF_ATALK to use gen_sockaddr,"
 #include ""net.h""
 #include ""utils.h""
 
-void atalk_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
+static void atalk_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 {
 struct sockaddr_at *atalk;
 
 struct netproto proto_appletalk = {
 .name = ""appletalk"",
 .socket = atalk_rand_socket,
 .setsockopt = atalk_setsockopt,
+.gen_sockaddr = atalk_gen_sockaddr,
 };
 #endif
",42,4
convert PF_ATM[SVC|PVC] to use gen_sockaddr," static const struct sa_func_entry sa_funcs[] = {
 //TODO{ .pf = PF_UNSPEC, .func = &unspec_gen_sockaddr },
 //TODO{ .pf = PF_NETROM, .func = &netrom_gen_sockaddr },
 //TODO{ .pf = PF_BRIDGE, .func = &bridge_gen_sockaddr },
-{ .pf = PF_ATMPVC, .func = &atmpvc_gen_sockaddr },
 { .pf = PF_X25, .func = &x25_gen_sockaddr },
 #ifdef USE_IPV6
 { .pf = PF_INET6, .func = &ipv6_gen_sockaddr },
 static const struct sa_func_entry sa_funcs[] = {
 { .pf = PF_PACKET, .func = &packet_gen_sockaddr },
 //TODO{ .pf = PF_ASH, .func = &ash_gen_sockaddr },
 { .pf = PF_ECONET, .func = &econet_gen_sockaddr },
-{ .pf = PF_ATMSVC, .func = &atmsvc_gen_sockaddr },
 { .pf = PF_RDS, .func = &rds_gen_sockaddr },
 //TODO{ .pf = PF_SNA, .func = &sna_gen_sockaddr },
 { .pf = PF_IRDA, .func = &irda_gen_sockaddr },
",62,7
convert PF_X25 to use gen_sockaddr,"
 #include ""random.h""
 #include ""utils.h""
 
-void x25_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
+static void x25_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 {
 struct sockaddr_x25 *x25;
 unsigned int len;
 struct netproto proto_x25 = {
 .name = ""x25"",
 .socket = x25_rand_socket,
 .setsockopt = x25_setsockopt,
+.gen_sockaddr = x25_gen_sockaddr,
 };
",39,3
convert PF_INET6 to use gen_sockaddr," static void gen_random_ipv6_address(struct in6_addr *v6)
 }
 }
 
-void ipv6_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
+static void ipv6_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 {
 struct sockaddr_in6 *ipv6;
 struct in6_addr serv_addr;
 struct netproto proto_inet6 = {
 .name = ""inet6"",
 .socket = inet6_rand_socket,
 .setsockopt = inet6_setsockopt,
+.gen_sockaddr = ipv6_gen_sockaddr,
 };
-
 #endif
",169,17
convert PF_ROSE to use gen_sockaddr,"
 #include ""utils.h""// RAND_ARRAY
 #include ""compat.h""
 
-void rose_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
+static void rose_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 {
 struct sockaddr_rose *rose;
 
 struct netproto proto_rose = {
 .name = ""rose"",
 // .socket = rose_rand_socket,
 .setsockopt = rose_setsockopt,
+.gen_sockaddr = rose_gen_sockaddr,
 };
 #endif
",42,2
convert PF_DECNET to use gen_sockaddr,"
 #include ""utils.h""// RAND_ARRAY
 #include ""compat.h""
 
-void decnet_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
+static void decnet_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 {
 struct sockaddr_dn *dn;
 unsigned int i;
 struct netproto proto_decnet = {
 .name = ""decnet"",
 .socket = decnet_rand_socket,
 .setsockopt = decnet_setsockopt,
+.gen_sockaddr = decnet_gen_sockaddr,
 };
",55,5
"convert PF_NETBEUI and PF_LLC to use gen_sockaddr

given they both share the llc routine, just fold proto_netbeui.c
into proto-llc.c","
 #include ""utils.h""// RAND_ARRAY
 #include ""compat.h""
 
-void llc_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
+static void llc_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 {
 struct sockaddr_llc *llc;
 unsigned int i;
 static void llc_setsockopt(struct sockopt *so, __unused__ struct socket_triplet
 so->optname = RAND_ARRAY(llc_opts);
 }
 
+static void netbeui_setsockopt(struct sockopt *so, __unused__ struct socket_triplet *triplet)
+{
+so->level = SOL_NETBEUI;
+}
+
 struct netproto proto_llc = {
 .name = ""llc"",
 .socket = llc_rand_socket,
 .setsockopt = llc_setsockopt,
+.gen_sockaddr = llc_gen_sockaddr,
+};
+
+struct netproto proto_netbeui = {
+.name = ""netbeui"",
+.setsockopt = netbeui_setsockopt,
+.gen_sockaddr = llc_gen_sockaddr,
 };
",62,6
convert PF_NETLINK to use gen_sockaddr,"
 #endif /* NETLINK_RDMA */
 #endif /* NETLINK_CRYPTO */
 
-void netlink_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
+static void netlink_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 {
 struct sockaddr_nl *nl;
 const unsigned long nl_groups[] = {
 struct netproto proto_netlink = {
 .name = ""netlink"",
 .socket = netlink_rand_socket,
 .setsockopt = netlink_setsockopt,
+.gen_sockaddr = netlink_gen_sockaddr,
 };
",59,5
convert PF_PACKET to use gen_sockaddr,"
 #include ""utils.h""// RAND_ARRAY
 #include ""compat.h""
 
-void packet_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
+static void packet_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 {
 struct sockaddr_pkt *pkt;
 unsigned int i;
 struct netproto proto_packet = {
 .name = ""packet"",
 .socket = packet_rand_socket,
 .setsockopt = packet_setsockopt,
+.gen_sockaddr = packet_gen_sockaddr,
 };
",71,13
convert PF_ECONET to use struct netproto,"
 #include ""random.h""
 #include ""utils.h""
 
-void econet_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
+static void econet_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 {
 struct sockaddr_ec *ec;
 
 void econet_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 *addr = (struct sockaddr *) ec;
 *addrlen = sizeof(struct sockaddr_ec);
 }
+
+struct netproto proto_econet = {
+.name = ""econet"",
+.gen_sockaddr = econet_gen_sockaddr,
+};
",27,1
convert PF_RDS to use gen_sockaddr," static void rds_rand_socket(struct socket_triplet *st)
 st->type = SOCK_SEQPACKET;
 }
 
-void rds_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
+static void rds_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 {
 struct sockaddr_in *rds;
 
 struct netproto proto_rds = {
 .name = ""rds"",
 .socket = rds_rand_socket,
 .setsockopt = rds_setsockopt,
+.gen_sockaddr = rds_gen_sockaddr,
 };
 #else
 /* stub if we are built on something without RDS headers */
",41,4
convert PF_IRDA to use gen_sockaddr,"
 #include ""utils.h""// RAND_ARRAY
 #include ""compat.h""
 
-void irda_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
+static void irda_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 {
 struct sockaddr_irda *irda;
 unsigned int i;
 struct netproto proto_irda = {
 .name = ""irda"",
 .socket = irda_rand_socket,
 .setsockopt = irda_setsockopt,
+.gen_sockaddr = irda_gen_sockaddr,
 };
",58,8
convert PF_PPPOX to use gen_sockaddr," static void pppox_PX_PROTO_OL2TP(struct sockaddr **addr, socklen_t *addrlen)
 pppox_px_protos[rnd() % ARRAY_SIZE(pppox_px_protos)].func(addr, addrlen);
 }
 
-void pppox_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
+static void pppox_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 {
 const struct ppp_funcptr pppox_protos[] = {
 { .func = pppox_PX_PROTO_OE },
 struct netproto proto_pppol2tp = {
 .name = ""pppol2tp"",
 //.socket = pppol2tp_rand_socket,
 .setsockopt = pppol2tp_setsockopt,
+.gen_sockaddr = pppox_gen_sockaddr,
 };
",145,15
convert PF_CAN to use gen_sockaddr,"
 #include ""utils.h""
 #include ""compat.h""
 
-void can_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
+static void can_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 {
 struct sockaddr_can *can;
 
 static void can_rand_socket(struct socket_triplet *st)
 struct netproto proto_can = {
 .name = ""can"",
 .socket = can_rand_socket,
+.gen_sockaddr = can_gen_sockaddr,
 };
",31,2
convert PF_TIPC to use gen_sockaddr,"
 #include ""utils.h""// RAND_ARRAY
 #include ""compat.h""
 
-void tipc_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
+static void tipc_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 {
 struct sockaddr_tipc *tipc;
 
 struct netproto proto_tipc = {
 .name = ""tipc"",
 .socket = tipc_rand_socket,
 .setsockopt = tipc_setsockopt,
+.gen_sockaddr = tipc_gen_sockaddr,
 };
",57,6
convert PF_PHONET to use gen_sockaddr,"
 #include ""utils.h""
 #include ""compat.h""
 
-void phonet_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
+static void phonet_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 {
 struct sockaddr_pn *pn;
 
 struct netproto proto_phonet = {
 .name = ""phonet"",
 .socket = phonet_rand_socket,
 .setsockopt = phonet_setsockopt,
+.gen_sockaddr = phonet_gen_sockaddr,
 };
",39,4
convert PF_CAIF to use gen_sockaddr,"
 #ifdef USE_CAIF
 #include <linux/caif/caif_socket.h>
 
-void caif_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
+static void caif_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 {
 struct sockaddr_caif *caif;
 unsigned int i;
 struct netproto proto_caif = {
 .name = ""caif"",
 .socket = caif_rand_socket,
 .setsockopt = caif_setsockopt,
+.gen_sockaddr = caif_gen_sockaddr,
 };
 #endif
",52,6
convert PF_ALG to use gen_sockaddr," static const char *algos[] = {
 ""zlib"",
 };
 
-void alg_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
+static void alg_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 {
 struct sockaddr_alg *alg;
 unsigned int type;
 struct netproto proto_alg = {
 .name = ""alg"",
 //.socket = alg_rand_socket,
 .setsockopt = alg_setsockopt,
+.gen_sockaddr = alg_gen_sockaddr,
 };
 #endif
",238,6
convert PF_NFC to use gen_sockaddr and remove now unneeded code.,"
 #include ""random.h""
 #include ""utils.h""
 
-void nfc_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
+static void nfc_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 {
 struct sockaddr_nfc *nfc;
 
 struct netproto proto_nfc = {
 .name = ""nfc"",
 .socket = nfc_rand_socket,
 .setsockopt = nfc_setsockopt,
+.gen_sockaddr = nfc_gen_sockaddr,
 };
",44,5
remove no longer necessary includes,"
 * SYSCALL_DEFINE5(setsockopt, int, fd, int, level, int, optname, char __user *, optval, int, optlen)
 */
 
-#include <errno.h>
-#include <string.h>
-#include <stdlib.h>
-#include <sys/types.h>
-#include <sys/socket.h>
-#include <linux/types.h>
-#include <linux/tipc.h>
-#include <netinet/udp.h>
-#include <netipx/ipx.h>
-#include <netax25/ax25.h>
-#include ""config.h""
-#ifdef USE_APPLETALK
-#include <netatalk/at.h>
-#endif
-#ifdef USE_NETROM
-#include <netrom/netrom.h>
-#endif
-#ifdef USE_ROSE
-#include <netrose/rose.h>
-#endif
 #include ""arch.h""
-#include ""log.h""
-#include ""maps.h""
 #include ""net.h""
 #include ""random.h""
-#include ""sanitise.h""
-#include ""shm.h""
-#include ""syscall.h""
-#include ""trinity.h""
 #include ""utils.h""
-#include ""compat.h""
 
 /*
 * If we have a .len set, use it.
",112,21
constify struct netproto," static void alg_setsockopt(struct sockopt *so, __unused__ struct socket_triplet
 so->level = SOL_ALG;
 }
 
-struct netproto proto_alg = {
+const struct netproto proto_alg = {
 .name = ""alg"",
 //.socket = alg_rand_socket,
 .setsockopt = alg_setsockopt,
",238,6
keep the LLC/NETBEUI defines local to where they're used," static const unsigned int llc_opts[] = {
 LLC_OPT_PKTINFO,
 };
 
+#define SOL_NETBEUI 267
+#define SOL_LLC 268
+
 static void llc_setsockopt(struct sockopt *so, __unused__ struct socket_triplet *triplet)
 {
 so->level = SOL_LLC;
",62,6
move SOL_NETLINK define to where it's used," static const unsigned int netlink_opts[] = {
 NETLINK_LIST_MEMBERSHIPS, NETLINK_CAP_ACK,
 };
 
+#define SOL_NETLINK 270
+
 static void netlink_setsockopt(struct sockopt *so, __unused__ struct socket_triplet *triplet)
 {
 so->level = SOL_NETLINK;
",59,5
move SOL_RXRPC local to where it's used," static const unsigned int rxrpc_opts[] = {
 RXRPC_BUSY, RXRPC_LOCAL_ERROR, RXRPC_NEW_CALL, RXRPC_ACCEPT,
 };
 
+#define SOL_RXRPC 272
+
 static void rxrpc_setsockopt(struct sockopt *so, __unused__ struct socket_triplet *triplet)
 {
 so->level = SOL_RXRPC;
",18,1
move SOL_PPPOL2TP local to where it's used," static const unsigned int pppol2tp_opts[] = {
 PPPOL2TP_SO_DEBUG, PPPOL2TP_SO_RECVSEQ, PPPOL2TP_SO_SENDSEQ, PPPOL2TP_SO_LNSMODE,
 PPPOL2TP_SO_REORDERTO };
 
+#define SOL_PPPOL2TP 273
+
 static void pppol2tp_setsockopt(struct sockopt *so, __unused__ struct socket_triplet *triplet)
 {
 so->level = SOL_PPPOL2TP;
",145,15
move SOL_BLUETOOTH local to where it's used," static const unsigned int bluetooth_l2cap_opts[] = {
 
 static const unsigned int bluetooth_rfcomm_opts[] = { RFCOMM_LM };
 
+#define SOL_BLUETOOTH 274
 
 static void bluetooth_setsockopt(struct sockopt *so, __unused__ struct socket_triplet *triplet)
 {
",62,12
move SOL_PNPIPE local to where it's used," static void phonet_rand_socket(struct socket_triplet *st)
 st->type = SOCK_SEQPACKET;
 }
 
+#define SOL_PNPIPE 275
+
 static void phonet_setsockopt(struct sockopt *so, __unused__ struct socket_triplet *triplet)
 {
 so->level = SOL_PNPIPE;
",39,4
move SOL_RDS local to where it's used," static const unsigned int rds_opts[] = {
 RDS_RECVERR, RDS_CONG_MONITOR, RDS_GET_MR_FOR_DEST,
 };
 
+#define SOL_RDS 276
+
 static void rds_setsockopt(struct sockopt *so, __unused__ struct socket_triplet *triplet)
 {
 so->level = SOL_RDS;
",41,4
move SOL_IUCV local to where it's used," static const unsigned int iucv_opts[] = {
 SO_IPRMDATA_MSG, SO_MSGLIMIT, SO_MSGSIZE
 };
 
+#define SOL_IUCV 277
+
 static void iucv_setsockopt(struct sockopt *so, __unused__ struct socket_triplet *triplet)
 {
 so->level = SOL_IUCV;
",18,1
move SOL_CAIF local to where it's used," static const unsigned int caif_opts[] = {
 CAIFSO_LINK_SELECT, CAIFSO_REQ_PARAM
 };
 
+#define SOL_CAIF 278
+
 static void caif_setsockopt(struct sockopt *so, __unused__ struct socket_triplet *triplet)
 {
 so->level = SOL_CAIF;
",52,6
move SOL_ALG local to where it's used," static void alg_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 *addrlen = sizeof(struct sockaddr_alg);
 }
 
+#define SOL_ALG 279
+
 static void alg_setsockopt(struct sockopt *so, __unused__ struct socket_triplet *triplet)
 {
 so->level = SOL_ALG;
",238,6
move SOL_NFC local to where it's used," static void nfc_rand_socket(struct socket_triplet *st)
 st->type = SOCK_SEQPACKET;
 }
 
+#define SOL_NFC 280
+
 static void nfc_setsockopt(struct sockopt *so, __unused__ struct socket_triplet *triplet)
 {
 so->level = SOL_NFC;
",44,5
move the INET related SOL_ options to proto-ipv4," struct ip_sso_funcptr {
 void (*func)(struct sockopt *so, struct socket_triplet *triplet);
 };
 
+#define SOL_TCP 6
+#define SOL_SCTP 132
+#define SOL_UDPLITE 136
+#define SOL_DCCP 269
+
 static const struct ip_sso_funcptr ip_ssoptrs[] = {
 [IPPROTO_IP] = { .func = &ip_setsockopt },
 [IPPROTO_ICMP] = { .func = NULL },
",282,28
add new EPOLLEXCLUSIVE flag to epoll_ctl,"
 #include ""utils.h""
 #include ""compat.h""
 
+#ifndef EPOLLEXCLUSIVE
+#define EPOLLEXCLUSIVE (1 << 28)
+#endif
+
 static const unsigned long epoll_flags[] = {
 EPOLLIN, EPOLLOUT, EPOLLRDHUP, EPOLLPRI,
 EPOLLERR, EPOLLHUP, EPOLLET, EPOLLONESHOT,
-EPOLLWAKEUP,
+EPOLLWAKEUP, EPOLLEXCLUSIVE,
 };
 
 static void sanitise_epoll_ctl(struct syscallrecord *rec)
",42,2
remove debugging code," static int open_files(void)
 mmap_fd(fd, filename, sb.st_size, flags);
 }
 
-dump_objects(OBJ_GLOBAL, OBJ_MMAP);
+//dump_objects(OBJ_GLOBAL, OBJ_MMAP);
 return TRUE;
 }
 
",175,30
rename the TRINITY_MAP_ definitions," static void alloc_zero_map(unsigned long size, int prot, const char *name)
 new = alloc_object();
 new->map.size = size;
 new->map.prot = prot;
-new->map.type = TRINITY_MAP_INITIAL;
+new->map.type = INITIAL_ANON;
 new->map.ptr = mmap(NULL, size, prot, MAP_ANONYMOUS | MAP_SHARED, fd, 0);
 if (new->map.ptr == MAP_FAILED) {
 outputerr(""mmap failure\n"");
",82,11
move mmap_fd to maps.c," static void filefd_destructor(struct object *obj)
 close(obj->filefd);
 }
 
-static void mmap_fd(int fd, const char *name, size_t len, int prot)
-{
-struct object *obj;
-off_t offset;
-int retries = 0;
-
-/* Create an MMAP of the same fd. */
-obj = alloc_object();
-obj->map.name = strdup(name);
-obj->map.size = len;
-
-retry_mmap:
-if (len == 0) {
-offset = 0;
-obj->map.size = page_size;
-} else
-offset = (rnd() % obj->map.size) & PAGE_MASK;
-
-obj->map.prot = prot;
-obj->map.type = MMAPED_FILE;
-obj->map.ptr = mmap(NULL, len, prot, get_rand_mmap_flags(), fd, offset);
-if (obj->map.ptr == MAP_FAILED) {
-retries++;
-if (retries == 100) {
-free(obj->map.name);
-free(obj);
-return;
-} else
-goto retry_mmap;
-}
-
-/* TODO: maybe later make a separate cache ?
- * Otherwise, these are going to dominate get_map()
- */
-add_object(obj, OBJ_GLOBAL, OBJ_MMAP);
-return;
-}
-
 static int open_files(void)
 {
 struct objhead *head;
",146,26
change mmap_fd to take a global/child flag," static int open_files(void)
 break;
 }
 
-mmap_fd(fd, filename, sb.st_size, flags);
+mmap_fd(fd, filename, sb.st_size, flags, OBJ_GLOBAL);
 }
 
 //dump_objects(OBJ_GLOBAL, OBJ_MMAP);
",146,26
"allow get_map to return NULL

if get_random_object fails, we shouldn't return 0x10","
 struct map * get_map(void)
 {
 struct object *obj;
-struct map *map;
 struct childdata *child = this_child();
 bool global;
 
 struct map * get_map(void)
 global = OBJ_LOCAL;
 
 obj = get_random_object(OBJ_MMAP, global);
-map = &obj->map;
+if (obj == NULL)
+return NULL;
 
-return map;
+return &obj->map;
 }
 
 void map_destructor(struct object *obj)
",120,16
rename OBJ_MMAP -> OBJ_MMAP_ANON," static int open_files(void)
 mmap_fd(fd, filename, sb.st_size, flags, OBJ_GLOBAL);
 }
 
-//dump_objects(OBJ_GLOBAL, OBJ_MMAP);
+//dump_objects(OBJ_GLOBAL, OBJ_MMAP_ANON);
 return TRUE;
 }
 
",146,26
"Move the file fd provider up so it runs first.

This is kind of a hack, but makes sure we have some mmap's
on the lists before the perf fd provider tries to grab some."," void setup_fd_providers(void)
 fd_providers = zmalloc(sizeof(struct fd_provider));
 INIT_LIST_HEAD(&fd_providers->list);
 
+add_to_prov_list(&file_fd_provider);
 add_to_prov_list(&socket_fd_provider);
 add_to_prov_list(&pipes_fd_provider);
 add_to_prov_list(&perf_fd_provider);
 add_to_prov_list(&epoll_fd_provider);
 add_to_prov_list(&eventfd_fd_provider);
-add_to_prov_list(&file_fd_provider);
 add_to_prov_list(&timerfd_fd_provider);
 add_to_prov_list(&testfile_fd_provider);
 add_to_prov_list(&memfd_fd_provider);
",177,25
"make get_writable_address retry on failure.

Again, an ugly hack. We could theoretically get stuck here
if we've run out of writable mappings."," void * get_writable_address(unsigned long size)
 
 retry:
 map = get_map();
+if (map == NULL)
+goto retry;
 
 if (map->size < size)
 goto retry;
",85,22
make mmap'd files use their own object cache," static int open_files(void)
 break;
 }
 
-mmap_fd(fd, filename, sb.st_size, flags, OBJ_GLOBAL);
+mmap_fd(fd, filename, sb.st_size, flags, OBJ_GLOBAL, OBJ_MMAP_FILE);
 }
 
 //dump_objects(OBJ_GLOBAL, OBJ_MMAP_ANON);
",146,26
dirty_random_mapping needs to handle NULL get_map() results," void dirty_random_mapping(void)
 struct map *map;
 
 map = get_map();
+if (map == NULL)
+return;
+
 dirty_mapping(map);
 }
 
",127,18
"mincore fails giant malloc's all the time, cap the max size at 1GB"," static void sanitise_mincore(struct syscallrecord *rec)
 
 map = common_set_mmap_ptr_len();
 
-len = map->size + (page_size - 1) / page_size;
+len = min(GB(1), map->size);
+len = len + (page_size - 1) / page_size;
 
 rec->a3 = (unsigned long) zmalloc(len);// FIXME: LEAK
 }
",32,2
fix potential infinite loop in get_writable_address," void * get_writable_address(unsigned long size)
 {
 struct map *map;
 void *addr = NULL;
+int tries = 0;
+
+retry:tries++;
+if (tries == 100)
+return NULL;
 
-retry:
 map = get_map();
 if (map == NULL)
 goto retry;
",88,23
"go back to a state where get_map can't ever fail.

This is too much of a pain in the ass to run around everywhere
and handle fallbacks","
 */
 struct map * get_map(void)
 {
-struct object *obj;
+struct object *obj = NULL;
 struct childdata *child = this_child();
 bool global;
 enum objecttype type;
 struct map * get_map(void)
 else
 global = OBJ_LOCAL;
 
-if (RAND_BOOL())
-type = OBJ_MMAP_ANON;
-else
-type = OBJ_MMAP_FILE;
+while (obj == NULL) {
+if (RAND_BOOL())
+type = OBJ_MMAP_ANON;
+else
+type = OBJ_MMAP_FILE;
 
-obj = get_random_object(type, global);
-if (obj == NULL)
-return NULL;
+obj = get_random_object(type, global);
+}
 
 return &obj->map;
 }
 void dirty_random_mapping(void)
 struct map *map;
 
 map = get_map();
-if (map == NULL)
-return;
 
 dirty_mapping(map);
 }
",125,17
check the limit on the domain in the socket cache," static int open_sockets(void)
 type = buffer[1];
 protocol = buffer[2];
 
+if (domain > TRINITY_PF_MAX) {
+output(1, ""cachefile contained invalid domain %u\n"", domain);
+goto regenerate;
+}
+
 if ((do_specific_domain == TRUE && domain != specific_domain) ||
- (domain < ARRAY_SIZE(no_domains) && no_domains[domain] == TRUE)) {
+ (no_domains[domain] == TRUE)) {
 output(1, ""ignoring socket cachefile due to specific ""
  ""protocol request (or protocol disabled), ""
  ""and stale data in cachefile.\n"");
",338,76
create mmap's of the testfile fd's too," static int open_testfile_fds(void)
 
 i++;
 fails = 0;
+
+mmap_fd(fd, filename, page_size, PROT_READ|PROT_WRITE, OBJ_GLOBAL, OBJ_MMAP_TESTFILE);
+
 } else {
 fails++;
 if (fails == 100) {
 static int open_testfile_fds(void)
 }
 }
 
+dump_objects(OBJ_GLOBAL, OBJ_MMAP_TESTFILE);
+
 free(filename);
 return TRUE;
 }
",88,11
fix off-by-one in socket validation," static int open_sockets(void)
 type = buffer[1];
 protocol = buffer[2];
 
-if (domain > TRINITY_PF_MAX) {
+if (domain >= TRINITY_PF_MAX) {
 output(1, ""cachefile contained invalid domain %u\n"", domain);
 goto regenerate;
 }
",338,76
"Add some SYSV shm objects.

These aren't used anywhere yet"," void dump_objects(bool global, enum objecttype type)
 output(0, ""futex: %lx owner:%d\n"",
 obj->lock.futex, obj->lock.owner_pid);
 break;
+case OBJ_SYSV_SHM:
+output(0, ""sysv_shm: id:%u size:%d flags:%x ptr:%p\n"",
+obj->sysv_shm.id, obj->sysv_shm.size,
+obj->sysv_shm.flags, obj->sysv_shm.ptr);
+break;
 case MAX_OBJECT_TYPES:
 default:
 break;
",223,48
double check that we always have enough children running," void main_loop(void)
 }
 
 print_stats();
+
+/* This should never happen, but just to catch corner cases, like if
+ * fork() failed when we tried to replace a child.
+ */
+if (shm->running_childs < max_children)
+fork_children();
 }
 
 /* if the pid map is corrupt, we can't trust that we'll
",549,123
fix up more out of bounds writes in the page-dirtying routines," void generate_rand_bytes(unsigned char *ptr, unsigned int len)
 
 /* If we only have a small buffer, don't do
  * the longer generators. */
-if (len < 20)
+if (len < 24)
 randrange = 6;
 else {
 /* Make sure we're always dealing with an even number */
 void generate_rand_bytes(unsigned char *ptr, unsigned int len)
 
 p = (char *) ptr;
 
-while (p < (char *)(ptr + (len-22))) {// 22 is the longest case below + separator.
+while (p < (char *)(ptr + (len-23))) {// 23 is the longest case below + separator.
 if (RAND_BOOL()) {
 /* hex */
 switch (rnd() % 3) {
",144,46
"fix a rand64 case

undefined behaviour shifting > width of type"," unsigned int rand32(void)
 */
 u64 rand64(void)
 {
-unsigned long r = 0;
+u64 r = 0;
 
 switch (rnd() % 8) {
 
 u64 rand64(void)
 break;
 case 4:r = randbits(64);
 break;
-case 5:r = (0ULL | rnd()) << 32 | rnd();
+case 5:r = (u64) rnd() << 32 | rnd();
 break;
 case 6:r = rept_byte();
 break;
",167,54
remove void * arithmetic in dirty_last_page," static void dirty_first_page(struct map *map)
 * a strlen and go off the end. */
 static void dirty_last_page(struct map *map)
 {
-char *p = map->ptr;
+char *p = map->ptr + map->size - page_size;
 
-memset((void *) p + (map->size - page_size), 'A', page_size);
+memset((void *) p, 'A', page_size);
 }
 
 static const struct faultfn write_faultfns_single[] = {
",84,15
"Fix logging logic in output().

Commit ""preparation for different forms of logging."" contained a typo that
broke logging to mainlogfile.

Signed-off-by: Artem Savkov <asavkov@redhat.com>"," void output(unsigned char level, const char *fmt, ...)
 }
 
 /* go on with file logs only if enabled */
-if (logging == LOGGING_FILES)
+if (logging == LOGGING_DISABLED)
 return;
 
 handle = find_logfile_handle();
",149,32
remove lock stealing leftovers,"
 
 /*
 * Check that the processes holding locks are still alive.
- * And if they are, ensure they haven't held them for an
- * excessive length of time.
 */
-#define STEAL_THRESHOLD 1000000
-
 static bool check_lock(lock_t *_lock)
 {
 pid_t pid;
",84,18
"don't let get_random_fd run on uninitialized fd providers

This triggered a segv on init when pppox needed an fd, and
tried to get a pipe (which gets initialized _after_ socket init)"," int get_rand_pipe_fd(void)
 
 obj = get_random_object(OBJ_FD_PIPE, OBJ_GLOBAL);
 
+if (obj == NULL)
+return 0;
+
 return obj->pipefd;
 }
 
",62,6
give up trying to open perf events if they keep failing with EPERM," static int open_perf_fds(void)
 {
 struct objhead *head;
 unsigned int i = 0;
+unsigned int perm_count = 0;
 
 head = get_objhead(OBJ_GLOBAL, OBJ_FD_PERF);
 head->destroy = &perffd_destructor;
 static int open_perf_fds(void)
 output(2, ""fd[%d] = perf\n"", fd);
 i++;
 } else {
-/* If ENOSYS, bail early rather than do MAX_PERF_FDS retries */
-if (errno == ENOSYS)
-return TRUE;
+switch (errno) {
+case ENOSYS:
+/* If ENOSYS, bail early rather than do MAX_PERF_FDS retries */
+return FALSE;
+
+case EINVAL:
+/* If we get here we probably generated something invalid and
+ * perf_event_open threw it out. Go around the loop again.
+ */
+continue;
+
+case EACCES:
+perm_count++;
+}
+}
 
-/* If we get here we probably generated something invalid and
- * perf_event_open threw it out. Go around the loop again.
- */
+if (perm_count > 1000) {
+output(2, ""Couldn't open enough perf events, got EPERM too much. Giving up.\n"");
+return FALSE;
 }
 
 if (shm->exit_reason != STILL_RUNNING)
",69,11
"syscalls/mlockall.c only define MCL_* if not already done

required to avoid build errors on PowerPC.","
 #include ""syscall.h""
 #include ""trinity.h""
 
+#ifndef MCL_CURRENT
 #define MCL_CURRENT 1
+#endif
+#ifndef MCL_FUTURE
 #define MCL_FUTURE 2
+#endif
+#ifndef MCL_ONFAULT
 #define MCL_ONFAULT4
+#endif
 
 static void sanitise_mlockall(struct syscallrecord *rec)
 {
",25,4
add some crappy code to find unannotated syscall args," bool do_specific_domain = FALSE;
 bool no_domains[TRINITY_PF_MAX];
 
 bool dry_run = FALSE;
+bool show_unannotated = FALSE;
 bool show_syscall_list = FALSE;
 bool show_ioctl_list = FALSE;
 unsigned char quiet_level = 0;
 static const struct option longopts[] = {
 { ""random"", required_argument, NULL, 'r' },
 { ""server_addr"", required_argument, NULL, 0 },
 { ""server_port"", required_argument, NULL, 0 },
+{ ""show-unannotated"", no_argument, NULL, 0 },
 { ""syslog"", no_argument, NULL, 'S' },
 { ""verbose"", no_argument, NULL, 'v' },
 { ""victims"", required_argument, NULL, 'V' },
 void parse_args(int argc, char *argv[])
 if (strcmp(""dry-run"", longopts[opt_index].name) == 0)
 dry_run = TRUE;
 
+if (strcmp(""show-unannotated"", longopts[opt_index].name) == 0)
+show_unannotated = TRUE;
+
 break;
 }
 }
",271,46
fix type-spew from cppcheck," static void show_unannotated_biarch(void)
 }
 }
 if (count != 0)
-printf(""%s has %d unannotated arguments\n"", entry->name, count);
+printf(""%s has %u unannotated arguments\n"", entry->name, count);
 }
 */
 for_each_64bit_syscall(i) {
 static void show_unannotated_biarch(void)
 }
 }
 if (count != 0)
-printf(""%s has %d unannotated arguments\n"", entry->name, count);
+printf(""%s has %u unannotated arguments\n"", entry->name, count);
 }
 }
 
",448,118
add the iptables setsockopts,"
 #include <linux/types.h>
 #include <arpa/inet.h>
 #include <linux/mroute.h>
+#include <net/if.h>
+#include <linux/netfilter_ipv4/ip_tables.h>
 #include ""sanitise.h""
 #include ""compat.h""
 #include ""maps.h""
 static const struct sock_option ip_opts[] = {
 { .name = MRT_TABLE, .len = sizeof(__u32) },
 { .name = MRT_ADD_MFC_PROXY, .len = sizeof(struct mfcctl) },
 { .name = MRT_DEL_MFC_PROXY, .len = sizeof(struct mfcctl) },
+{ .name = IPT_SO_SET_REPLACE, },
+{ .name = IPT_SO_SET_ADD_COUNTERS, },
 };
 
 static void ip_setsockopt(struct sockopt *so, __unused__ struct socket_triplet *triplet)
",286,28
add the ebtables setsockopts,"
 #include <linux/mroute.h>
 #include <net/if.h>
 #include <linux/netfilter_ipv4/ip_tables.h>
+#include <linux/netfilter_bridge/ebtables.h>
 #include ""sanitise.h""
 #include ""compat.h""
 #include ""maps.h""
 static const struct sock_option ip_opts[] = {
 { .name = MRT_DEL_MFC_PROXY, .len = sizeof(struct mfcctl) },
 { .name = IPT_SO_SET_REPLACE, },
 { .name = IPT_SO_SET_ADD_COUNTERS, },
+{ .name = EBT_SO_SET_ENTRIES, },
+{ .name = EBT_SO_SET_COUNTERS, },
 };
 
 static void ip_setsockopt(struct sockopt *so, __unused__ struct socket_triplet *triplet)
",289,28
add the arptables setsockopts,"
 #include <net/if.h>
 #include <linux/netfilter_ipv4/ip_tables.h>
 #include <linux/netfilter_bridge/ebtables.h>
+#include <linux/netfilter_arp/arp_tables.h>
 #include ""sanitise.h""
 #include ""compat.h""
 #include ""maps.h""
 static const struct sock_option ip_opts[] = {
 { .name = IPT_SO_SET_ADD_COUNTERS, },
 { .name = EBT_SO_SET_ENTRIES, },
 { .name = EBT_SO_SET_COUNTERS, },
+{ .name = ARPT_SO_SET_REPLACE, },
+{ .name = ARPT_SO_SET_ADD_COUNTERS, },
 };
 
 static void ip_setsockopt(struct sockopt *so, __unused__ struct socket_triplet *triplet)
",292,28
add ip6tables setsockopts,"
 #include <linux/ipv6.h>// needed for ipv6_opt_hdr
 #include <linux/if_arp.h>
 #include <linux/if_packet.h>
+#include <linux/netfilter_ipv6/ip6_tables.h>
 #include <arpa/inet.h>
 #include <stdlib.h>
 #include ""arch.h""
 static const struct sock_option inet6_opts[] = {
 { .name = IPV6_ORIGDSTADDR, },
 { .name = IPV6_TRANSPARENT, },
 { .name = IPV6_UNICAST_IF, },
+{ .name = IP6T_SO_SET_REPLACE, },
+{ .name = IP6T_SO_SET_ADD_COUNTERS, },
 };
 
 static void inet6_setsockopt(struct sockopt *so, __unused__ struct socket_triplet *triplet)
",172,17
"add SO_IP_SET setsockopt

ugh, this demuxes the command from the data passed in instead of it
being multiple socket options. Something for later maybe","
 #include <linux/netfilter_ipv4/ip_tables.h>
 #include <linux/netfilter_bridge/ebtables.h>
 #include <linux/netfilter_arp/arp_tables.h>
+#include <linux/netfilter/ipset/ip_set.h>
 #include ""sanitise.h""
 #include ""compat.h""
 #include ""maps.h""
 static const struct sock_option ip_opts[] = {
 { .name = EBT_SO_SET_COUNTERS, },
 { .name = ARPT_SO_SET_REPLACE, },
 { .name = ARPT_SO_SET_ADD_COUNTERS, },
+{ .name = SO_IP_SET, },/* ugh, demux's based upon data */
 };
 
 static void ip_setsockopt(struct sockopt *so, __unused__ struct socket_triplet *triplet)
",294,28
keep init_child local to child.c," static void bind_child_to_cpu(struct childdata *child)
 /*
 * Called from the fork_children loop in the main process.
 */
-void init_child(struct childdata *child, int childno)
+static void init_child(struct childdata *child, int childno)
 {
 pid_t pid = getpid();
 char childname[17];
 static bool handle_sigreturn(void)
 * from the fork_children() loop.
 * We also re-enter it from the signal handler code if something happened.
 */
-void child_process(void)
+void child_process(struct childdata *child, int childno)
 {
-struct childdata *child = this_child();
 int ret;
 
+init_child(child, childno);
+
 ret = sigsetjmp(ret_jump, 1);
 if (ret != 0) {
 shm_rw();
",262,54
make init_child use the child struct passed in instead of searching for it," static void init_child(struct childdata *child, int childno)
 }
 }
 
-set_seed(this_child());
+set_seed(child);
 
 init_object_lists(OBJ_LOCAL);
 
",262,54
move child cleanup to child.c too," void child_process(struct childdata *child, int childno)
 
 if (child->xcpu_count == 100) {
 debugf(""Child %d [%d] got 100 XCPUs. Exiting child.\n"", child->num, pids[child->num]);
-return;
+goto out;
 }
 
 if (handle_sigreturn() == FALSE)
-return;// Exit the child, things are getting too weird.
+goto out;// Exit the child, things are getting too weird.
 }
 
 while (shm->exit_reason == STILL_RUNNING) {
 void child_process(struct childdata *child, int childno)
 
 ret = child_ops[i].func();
 if (ret == FAIL)
-return;
+goto out;
 }
 }
 
 void child_process(struct childdata *child, int childno)
 while (shm->postmortem_in_progress == TRUE) {
 /* Make sure the main process is still around. */
 if (pid_alive(mainpid) == -1)
-return;
+goto out;
 
 usleep(1);
 }
+
+out:
+shutdown_child_logging(child);
 }
",264,54
move child debugf into child code," void child_process(struct childdata *child, int childno)
 
 out:
 shutdown_child_logging(child);
+
+debugf(""child %d %d exiting.\n"", childno, getpid());
 }
",265,54
"move x86 specific syscalls to x86 dir

Signed-off-by: Adrien Schildknecht <adrien+dev@schischi.me>"," static void sanitise_modify_ldt(struct syscallrecord *rec)
  * bytecount must equal the size of this structure. */
 
 /*
- unsigned int entry_number;
- unsigned long base_addr;
- unsigned int limit;
- unsigned int seg_32bit:1;
- unsigned int contents:2;
- unsigned int read_exec_only:1;
- unsigned int limit_in_pages:1;
- unsigned int seg_not_present:1;
- unsigned int useable:1;
+ unsigned int entry_number;
+ unsigned long base_addr;
+ unsigned int limit;
+ unsigned int seg_32bit:1;
+ unsigned int contents:2;
+ unsigned int read_exec_only:1;
+ unsigned int limit_in_pages:1;
+ unsigned int seg_not_present:1;
+ unsigned int useable:1;
 */
 break;
 default:
",44,4
"net: include <linux/if.h> instead of <net/if.h>

Commit 4ada80dd202675 includes net/if.h and linux/netfilter_ipv4/ip_tables.h
net/* and linux/* should not be mixed.
Debian Jessie x86_64:
 CC net/proto-ipv4.o
 In file included from net/proto-ipv4.c:11:0:
 /usr/include/linux/if.h:71:2: error: redeclaration of enumerator 'IFF_UP'
 IFF_UP = 1<<0, /* sysfs */
 /usr/include/net/if.h:44:5: note: previous definition of 'IFF_UP' was here
 IFF_UP = 0x1, /* Interface is up. */
 [...]

Signed-off-by: Adrien Schildknecht <adrien+dev@schischi.me>","
 #include <linux/types.h>
 #include <arpa/inet.h>
 #include <linux/mroute.h>
-#include <net/if.h>
+#include <linux/if.h>
 #include <linux/netfilter_ipv4/ip_tables.h>
 #include <linux/netfilter_bridge/ebtables.h>
 #include <linux/netfilter_arp/arp_tables.h>
",311,28
"don't modify argv directly.

operate on a copy instead when we munge it."," static void disable_fds_param(char *str)
 exit(EXIT_FAILURE);
 }
 
+//TODO: prevent --enable and --disable being passed at the same time.
 void process_fds_param(char *param, bool enable)
 {
 unsigned int len, i;
-char *str = param;
+char *str_orig = strdup(param);
+char *str = str_orig;
 
 len = strlen(param);
 
 void process_fds_param(char *param, bool enable)
  * validating them as we go.
  */
 for (i = 0; i < len; i++) {
-if (param[i] == ',') {
-param[i] = 0;
+if (str[i] == ',') {
+str[i] = 0;
 if (enable == TRUE)
 enable_fds_param(str);
 else
 disable_fds_param(str);
-str = param + i + 1;
+str = str_orig + i + 1;
 }
 }
-if (str < param + len) {
+if (str < str_orig + len) {
 if (enable == TRUE)
 enable_fds_param(str);
 else
 disable_fds_param(str);
 }
+free(str_orig);
 }
",198,31
teach perf_event_open how to pull from the perf fd cache," static int open_perf_fds(void)
 return TRUE;
 }
 
-static int get_rand_perf_fd(void)
+int get_rand_perf_fd(void)
 {
 struct object *obj;
 
",69,11
"when reaping dead children clean up zombies immediately.

Without this, we don't get the shm->running_childs check
working if all processes are in Z state","
 #include ""taint.h""
 #include ""trinity.h""
 
+static void handle_child(int childno, pid_t childpid, int childstatus);
 
 static unsigned long hiscore = 0;
 
 static void reap_dead_kids(void)
 for_each_child(i) {
 pid_t pid;
 int ret;
+int childstatus;
 
 pid = pids[i];
 if (pid == EMPTY_PIDSLOT)
 static void reap_dead_kids(void)
 }
 }
 
+pid = waitpid(pid, &childstatus, WUNTRACED | WCONTINUED | WNOHANG);
+handle_child(i, pid, childstatus);
+
 if (shm->running_childs == 0)
 return;
 }
 static void handle_childsig(int childno, int childstatus, bool stop)
 }
 }
 
-
 static void handle_child(int childno, pid_t childpid, int childstatus)
 {
 switch (childpid) {
",550,123
make mmap use a random fd for non-anon mmaps," static void sanitise_mmap(struct syscallrecord *rec)
 rec->a2 = RAND_ARRAY(mapping_sizes);
 do_anon(rec);
 } else {
+rec->a5 = get_random_fd();
+if (rec->a5 == (unsigned long) -1)
+rec->a5 = 0;
+
 if (this_syscallname(""mmap2"") == TRUE) {
 /* mmap2 counts in 4K units */
 rec->a6 /= 4096;
",144,17
let get_writable_address return some sysv shm objects,"
 void * get_writable_address(unsigned long size)
 {
 struct map *map;
+struct object *obj;
 void *addr = NULL;
 int tries = 0;
 
 retry:tries++;
 if (tries == 100)
 return NULL;
 
-map = get_map();
-if (map->size < size)
-goto retry;
+if (RAND_BOOL()) {
+map = get_map();
+if (map->size < size)
+goto retry;
+
+addr = map->ptr;
+map->prot = PROT_READ | PROT_WRITE;
+} else {
+obj = get_random_object(OBJ_SYSV_SHM, OBJ_GLOBAL);
+if (obj->sysv_shm.size < size)
+goto retry;
+addr = obj->sysv_shm.ptr;
+}
 
-addr = map->ptr;
-mprotect(addr, map->size, PROT_READ | PROT_WRITE);
-map->prot = PROT_READ | PROT_WRITE;
+mprotect(addr, size, PROT_READ | PROT_WRITE);
 
 return addr;
 }
",93,24
sometimes unshare the userns on child startup," static void init_child(struct childdata *child, int childno)
 mask_signals_child();
 
 disable_coredumps();
+
+if (RAND_BOOL()) {
+int ret = unshare(CLONE_NEWUSER);
+if (ret != 0)
+output(0, ""couldn't unshare: %s\n"", strerror(errno));
+}
 }
 
 /*
",270,56
ioctl: allow 'pick random group' as a fallback.," static void sanitise_ioctl(struct syscallrecord *rec)
 /* if we don't know about this ioctl, the argument could mean anything,
  * because ioctl sucks like that. Make some shit up.
  */
-if (RAND_BOOL())
-rec->a3 = rand32();
-else
-rec->a3 = (unsigned long) get_non_null_address();
+switch (rnd() % 3) {
+case 0:rec->a3 = rand32();
+break;
+case 1:rec->a3 = (unsigned long) get_non_null_address();
+break;
+case 2:grp = get_random_ioctl_group();
+grp->sanitise(grp, rec);
+break;
+}
 }
 }
 
",41,6
"ioctl: move the rdev test later

sockets weren't getting matched to the socket ioctls because they
don't have a backing rdev"," const struct ioctl_group *find_ioctl_group(int fd)
 if (fstat(fd, &stbuf) < 0)
 return NULL;
 
-if (stbuf.st_rdev == 0)
-return NULL;
-
-devname = map_dev(stbuf.st_rdev, stbuf.st_mode);
-if (!devname)
-return NULL;
-
 for (i=0; i < grps_cnt; ++i) {
 if (grps[i]->fd_test) {
 if (grps[i]->fd_test(fd, &stbuf) == 0)
 const struct ioctl_group *find_ioctl_group(int fd)
 default: break;
 }
 
+if (stbuf.st_rdev == 0)
+return NULL;
+
+devname = map_dev(stbuf.st_rdev, stbuf.st_mode);
+if (!devname)
+return NULL;
+
 for (j=0; j < grps[i]->devs_cnt; ++j)
 if (strcmp(devname, grps[i]->devs[j]) == 0)
 return grps[i];
",99,31
ioctl: make random arguments a bit more.. random.,"
 #include ""ioctls.h""
 #include ""log.h""
 #include ""random.h""
+#include ""sanitise.h""
 #include ""shm.h""
 #include ""utils.h""// ARRAY_SIZE
 
 const struct ioctl_group *get_random_ioctl_group(void)
 return grps[rnd() % grps_cnt];
 }
 
+static unsigned long random_ioctl_arg(void)
+{
+if (RAND_BOOL())
+return (unsigned long) rand64();
+return (unsigned long) get_writable_address(page_size);
+}
+
 void pick_random_ioctl(const struct ioctl_group *grp, struct syscallrecord *rec)
 {
 int ioctlnr;
 void pick_random_ioctl(const struct ioctl_group *grp, struct syscallrecord *rec)
 ioctlnr = rnd() % grp->ioctls_cnt;
 
 rec->a2 = grp->ioctls[ioctlnr].request;
+rec->a3 = random_ioctl_arg();
+rec->a4 = random_ioctl_arg();
+rec->a5 = random_ioctl_arg();
+rec->a6 = random_ioctl_arg();
 }
 
 void dump_ioctls(void)
",110,33
mangle the random page we pass as an ioctl arg," const struct ioctl_group *get_random_ioctl_group(void)
 
 static unsigned long random_ioctl_arg(void)
 {
-if (RAND_BOOL())
+if (RAND_BOOL()) {
 return (unsigned long) rand64();
-return (unsigned long) get_writable_address(page_size);
+} else {
+void *page;
+
+page = get_writable_address(page_size);
+generate_random_page(page);
+
+return (unsigned long) page;
+}
 }
 
 void pick_random_ioctl(const struct ioctl_group *grp, struct syscallrecord *rec)
",115,33
check for existence of btrfs ioctl headers,"
+#include ""config.h""
+#ifdef USE_BTRFS_IOCTL
 #include <stdio.h>
 #include <linux/fs.h>
 
 static const struct ioctl_group btrfs_grp = {
 };
 
 REG_IOCTL_GROUP(btrfs_grp)
+#endif /* USE_BTRFS_IOCTL */
",97,2
use SOCK_RAW for IP sockets half the time.," static void inet_rand_socket(struct socket_triplet *st)
 };
 unsigned char val;
 
+/* half the time, use raw sockets */
+st->type = SOCK_RAW;
+if (RAND_BOOL())
+return;
+
+/* The rest of the time, use the correct type if present. */
 val = rnd() % ARRAY_SIZE(ipprotos);
 st->protocol = ipprotos[val].proto;
 if (ipprotos[val].type != 0)
 st->type = ipprotos[val].type;
-else
-st->type = SOCK_RAW;
 }
 
 static const struct sock_option ip_opts[] = {
",313,29
"make get_new_random_fd bail early if no fd provider has finished yet.

another rare deadlock."," int get_new_random_fd(void)
 if (num_fd_providers_enabled == 0)
 return -1;
 
+/* if nothing has initialized yet, bail */
+if (num_fd_providers_initialized == 0)
+return -1;
+
 while (fd < 0) {
 unsigned int i, j;
 retry:
",204,32
"by default, start nr_cpus * 4 child processes."," int main(int argc, char* argv[])
 
 page_size = getpagesize();
 num_online_cpus = sysconf(_SC_NPROCESSORS_ONLN);
-max_children = num_online_cpus;/* possibly overridden in params. */
+max_children = num_online_cpus * 4;/* possibly overridden in params. */
 
 if (init_random() == FALSE)
 exit(EXIT_FAILURE);
",144,34
EBADF is a possible return from execve," static int execve_errnos[] = {
 E2BIG, EACCES, EFAULT, EINVAL, EIO, EISDIR, ELIBBAD, ELOOP,
 EMFILE, ENOENT, ENOEXEC, ENOMEM, ENOTDIR, EPERM, ETXTBSY,
 /* currently undocumented in man page. */
-ENAMETOOLONG, ENXIO,
+ENAMETOOLONG, ENXIO, EBADF,
 };
 
 struct syscallentry syscall_execve = {
",102,9
remove some noise from potential failures from unshare()," static void init_child(struct childdata *child, int childno)
 
 disable_coredumps();
 
-if (RAND_BOOL()) {
-int ret = unshare(CLONE_NEWUSER);
-if (ret != 0)
-output(0, ""couldn't unshare: %s\n"", strerror(errno));
+if (shm->unshare_perm_err == FALSE) {
+if (RAND_BOOL()) {
+int ret = unshare(CLONE_NEWUSER);
+if (ret != 0)
+output(0, ""couldn't unshare: %s\n"", strerror(errno));
+if (ret == -EPERM)
+shm->unshare_perm_err = TRUE;
+}
 }
 }
 
",274,58
add l2tp to analyze-sockets,"
 #include <unistd.h>
 #include <fcntl.h>
 #include <errno.h>
-#include <linux/in.h>
+#include <linux/l2tp.h>
 #include <net/if_packet.h>
+#include <netinet/in.h>
 #include <sys/types.h>
 #include <sys/socket.h>
 #include <sys/stat.h>
 static const char * get_proto_name(unsigned int family, unsigned int proto)
 { ""IPPROTO_SCTP"", IPPROTO_SCTP },
 { ""IPPROTO_UDPLITE"", IPPROTO_UDPLITE },
 { ""IPPROTO_RAW"", IPPROTO_RAW },
+{ ""IPPROTO_L2TP"", IPPROTO_L2TP },
 };
 
 switch (family) {
",167,21
add a ->send method to struct netproto,"
 
 static void sanitise_send(struct syscallrecord *rec)
 {
+struct socketinfo *si = (struct socketinfo *) rec->a1;
+const struct netproto *proto;
 void *ptr;
 unsigned int size;
 
-rec->a1 = fd_from_socketinfo((struct socketinfo *) rec->a1);
+rec->a1 = fd_from_socketinfo(si);
+
+//printf(""Sending to family:%d type:%d proto:%d\n"",
+//si->triplet.family, si->triplet.type, si->triplet.protocol);
+
+proto = net_protocols[si->triplet.family].proto;
+if (proto != NULL) {
+if (proto->send != NULL)
+proto->send(&si->triplet, rec);
+return;
+}
 
+/* The rest of this function is only used as a fallback, if the per-proto
+ * send()'s aren't implemented.
+ */
 if (RAND_BOOL())
 size = 1;
 else
 static void sanitise_send(struct syscallrecord *rec)
 
 rec->a3 = size;
 
-// TODO: only use this as a fallback, and actually have
-// some per-proto generators here.
 generate_rand_bytes(ptr, size);
 }
 
",136,10
add SO_CNX_ADVICE setsockopt," static const unsigned int socket_opts[] = {
 SO_PEEK_OFF, SO_NOFCS, SO_LOCK_FILTER, SO_SELECT_ERR_QUEUE,
 SO_BUSY_POLL, SO_MAX_PACING_RATE, SO_BPF_EXTENSIONS, SO_INCOMING_CPU,
 SO_ATTACH_BPF, SO_ATTACH_REUSEPORT_CBPF, SO_ATTACH_REUSEPORT_EBPF,
+SO_CNX_ADVICE,
 };
 
 void socket_setsockopt(struct sockopt *so, __unused__ struct socket_triplet *triplet)
",45,5
"if a proto's ->send is missing, fallback to random

we returned too early, and ended up free'ing bad pointers."," static void sanitise_send(struct syscallrecord *rec)
 
 rec->a1 = fd_from_socketinfo(si);
 
-//printf(""Sending to family:%d type:%d proto:%d\n"",
-//si->triplet.family, si->triplet.type, si->triplet.protocol);
-
 proto = net_protocols[si->triplet.family].proto;
 if (proto != NULL) {
-if (proto->send != NULL)
+if (proto->send != NULL) {
 proto->send(&si->triplet, rec);
-return;
+//printf(""Sending to family:%d type:%d proto:%d\n"",
+//si->triplet.family, si->triplet.type, si->triplet.protocol);
+return;
+}
 }
 
 /* The rest of this function is only used as a fallback, if the per-proto
",138,10
add missing NETLINK_ROUTE decoding," static const char * get_proto_name(unsigned int family, unsigned int proto)
 };
 
 const struct protocol netlink_proto[] = {
+{ ""NETLINK_ROUTE"", NETLINK_ROUTE },
 { ""NETLINK_UNUSED"", NETLINK_UNUSED },
 { ""NETLINK_USERSOCK"", NETLINK_USERSOCK },
 { ""NETLINK_FIREWALL"", NETLINK_FIREWALL },
",197,24
"when per proto ->socket succeeds, indicate success so we don't fall back"," int sanitise_socket_triplet(struct socket_triplet *st)
 
 proto = net_protocols[st->family].proto;
 if (proto != NULL) {
-if (proto->socket != NULL)
+if (proto->socket != NULL) {
 proto->socket(st);
+return 0;
+}
 }
 
 /* Couldn't find func, fall back to random. */
",89,21
"Only pick a single netlink group

From the man page:
""Since Linux 2.6.13, messages can't be broadcast to multiple groups."""," static void netlink_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 
 nl->nl_family = PF_NETLINK;
 nl->nl_pid = 0; // destination is always kernel
-nl->nl_groups = set_rand_bitmask(ARRAY_SIZE(nl_groups), nl_groups);
+nl->nl_groups = RAND_ARRAY(nl_groups);
 *addr = (struct sockaddr *) nl;
 *addrlen = sizeof(struct sockaddr_nl);
 }
",59,5
"rename ->send to ->gen_packet, and redefine args.

This function will be used by sendmsg etc too, and we need to get
back a ptr to a generated buffer, along with its size."," static void sanitise_send(struct syscallrecord *rec)
 struct socketinfo *si = (struct socketinfo *) rec->a1;
 const struct netproto *proto;
 void *ptr;
-unsigned int size;
+size_t size;
 
 rec->a1 = fd_from_socketinfo(si);
 
 proto = net_protocols[si->triplet.family].proto;
 if (proto != NULL) {
-if (proto->send != NULL) {
-proto->send(&si->triplet, rec);
+if (proto->gen_packet != NULL) {
+ptr = &rec->a2;
+proto->gen_packet(&si->triplet, ptr, &rec->a3);
 //printf(""Sending to family:%d type:%d proto:%d\n"",
 //si->triplet.family, si->triplet.type, si->triplet.protocol);
 return;
",139,10
"Update perf.c

win10 LXcore always seems to return EINVAL for this, throwing trinity in an endless loop."," static int open_perf_fds(void)
 struct objhead *head;
 unsigned int i = 0;
 unsigned int perm_count = 0;
+unsigned int inval_count = 0;
 
 head = get_objhead(OBJ_GLOBAL, OBJ_FD_PERF);
 head->destroy = &perffd_destructor;
 static int open_perf_fds(void)
 case EINVAL:
 /* If we get here we probably generated something invalid and
  * perf_event_open threw it out. Go around the loop again.
+ * OR its LXCore throwing us in an endless loop.
  */
-continue;
+inval_count++;
 
 case EACCES:
 perm_count++;
 static int open_perf_fds(void)
 return FALSE;
 }
 
+if (inval_count > 10000) {
+output(2, ""couldn't open enough perf events, got EINVAL too much. Giving up.\n"");
+return FALSE;
+}
+
 if (shm->exit_reason != STILL_RUNNING)
 return FALSE;
 }
",74,12
perf: reset the failure counts if we succeed at all.," static int open_perf_fds(void)
 
 output(2, ""fd[%d] = perf\n"", fd);
 i++;
+
+/* any time we succeed, reset the failure counts.
+ * They're only there for the cases where we hit them repeatedly.
+ */
+inval_count = 0;
+perm_count = 0;
 } else {
 switch (errno) {
 case ENOSYS:
",76,12
decrement enabled fd provider count if one fails," static void __open_fds(bool do_rand)
 if (provider->enabled == TRUE) {
 provider->initialized = TRUE;
 num_fd_providers_initialized++;
+} else {
+num_fd_providers_enabled--;
 }
 }
 }
",206,32
"move the ""child progressing"" timestamp from the syscall rec to the child.

This will be more useful when multiple child types are implemented."," void child_process(struct childdata *child, int childno)
 lastop = child_ops[i].name;
 }
 
+clock_gettime(CLOCK_MONOTONIC, &child->tp);
+
 ret = child_ops[i].func();
 if (ret == FAIL)
 goto out;
",275,58
pass the child ptr down to the child op.,"
 
 struct child_funcs {
 const char *name;
-bool (*func)(void);
+bool (*func)(struct childdata *child);
 unsigned char likelyhood;
 };
 
 void child_process(struct childdata *child, int childno)
 
 clock_gettime(CLOCK_MONOTONIC, &child->tp);
 
-ret = child_ops[i].func();
+ret = child_ops[i].func(child);
 if (ret == FAIL)
 goto out;
 }
",275,58
"fix badly named child_random_syscalls()

It only does a single syscall, and is a childop, not a child"," struct child_funcs {
 };
 
 static const struct child_funcs child_ops[] = {
-{ .name = ""rand_syscalls"", .func = child_random_syscalls, .likelyhood = 100 },
+{ .name = ""rand_syscall"", .func = random_syscall, .likelyhood = 100 },
 };
 
 /*
",275,58
update the prototypes for the read-all-files childop," struct child_funcs {
 
 static const struct child_funcs child_ops[] = {
 { .name = ""rand_syscall"", .func = random_syscall, .likelyhood = 100 },
+//{ .name = ""read_all_files"", .func = read_all_files, .likelyhood = 10 },
 };
 
 /*
",280,60
"move op_nr from syscall record to childdata

This is a progress indicator, and is child-type agnostic, so it
doesn't belong in the syscall struct"," static unsigned int render_syscall_prefix(struct syscallrecord *rec, char *buffe
 syscallnr = rec->nr;
 entry = get_syscall_entry(syscallnr, rec->do32bit);
 
-sptr += sprintf(sptr, ""[child%u:%u] [%lu] %s"", child->num, pids[child->num],
-rec->op_nr,
+sptr += sprintf(sptr, ""[child%u:%u] [%lu] %s"",
+child->num, pids[child->num], child->op_nr,
 rec->do32bit == TRUE ? ""[32BIT] "" : """");
 
 sptr += sprintf(sptr, ""%s%s("", entry->name, ANSI_RESET);
",154,40
fix open() return code check," bool read_all_files(__unused__ struct childdata *child)
 memset(buffer, 0, sb.st_size);
 
 fd = open(filename, O_RDONLY | O_NONBLOCK);
-if (!fd) {
+if (fd == -1) {
 free(buffer);
 continue;
 }
",46,7
open/stat instead of stat/open," bool read_all_files(__unused__ struct childdata *child)
 
 filename = fileindex[i];
 
+fd = open(filename, O_RDONLY | O_NONBLOCK);
+if (fd == -1)
+continue;
+
 ret = (lstat(filename, &sb));
 if (ret == -1)
-continue;
+goto closeout;
 
 if (sb.st_size == 0)
 sb.st_size = page_size;
 
 buffer = malloc(sb.st_size);
 if (!buffer)
-continue;
+goto closeout;
 
 memset(buffer, 0, sb.st_size);
 
-fd = open(filename, O_RDONLY | O_NONBLOCK);
-if (fd == -1) {
-free(buffer);
-continue;
-}
-
 ret = read(fd, buffer, sb.st_size);
 //if (ret != -1)
 //output(0, ""%s:%s\n"", filename, buffer);
 bool read_all_files(__unused__ struct childdata *child)
 sleep(1);
 
 free(buffer);
-
+closeout:
 close(fd);
 }
 return TRUE;
",45,7
use fstat instead of lstat," bool read_all_files(__unused__ struct childdata *child)
 if (fd == -1)
 continue;
 
-ret = (lstat(filename, &sb));
+ret = (fstat(fd, &sb));
 if (ret == -1)
 goto closeout;
 
",45,7
reset the op ptr when we reach the loop counter.," void child_process(struct childdata *child, int childno)
 
 /* Every NEW_OP_COUNT potentially pick a new childop. */
 if (loops == NEW_OP_COUNT) {
+op = NULL;
+
 while (op == NULL) {
 unsigned int i;
 
",283,60
reset the child timestamp when we clean it out," void clean_childdata(struct childdata *child)
 child->dontkillme = FALSE;
 child->xcpu_count = 0;
 child->op_nr = 0;
+clock_gettime(CLOCK_MONOTONIC, &child->tp);
 }
 
 static void bind_child_to_cpu(struct childdata *child)
",284,60
"change stats to count operations, not just syscalls"," retry:
 unlock(&rec->lock);
 
 if (syscalls_todo) {
-if (shm->stats.total_syscalls_done >= syscalls_todo) {
+if (shm->stats.op_count >= syscalls_todo) {
 shm->exit_reason = EXIT_REACHED_COUNT;
 return FAIL;
 }
",113,19
"remove the shm_rw debug code.

It was racy, and has served its purpose."," void child_process(struct childdata *child, int childno)
 
 ret = sigsetjmp(ret_jump, 1);
 if (ret != 0) {
-shm_rw();
-
 if (child->xcpu_count == 100) {
 debugf(""Child %d [%d] got 100 XCPUs. Exiting child.\n"", child->num, pids[child->num]);
 goto out;
",287,60
store the type of childop we're doing in the child struct," struct child_funcs {
 const char *name;
 bool (*func)(struct childdata *child);
 unsigned char likelyhood;
+enum childtype type;
 };
 
 static const struct child_funcs child_ops[] = {
-{ .name = ""rand_syscall"", .func = random_syscall, .likelyhood = 100 },
-//{ .name = ""read_all_files"", .func = read_all_files, .likelyhood = 10 },
+{ .name = ""rand_syscall"", .func = random_syscall, .likelyhood = 100, .type = CHILD_RAND_SYSCALL },
+//{ .name = ""read_all_files"", .func = read_all_files, .likelyhood = 10, .type = CHILD_READ_ALL_FILES },
 };
 
 /*
 void child_process(struct childdata *child, int childno)
 if (op != child_ops[i].func) {
 //output(0, ""Chose %s.\n"", child_ops[i].name);
 op = child_ops[i].func;
+child->type = child_ops[i].type;
 loops = NEW_OP_COUNT;
 }
 }
",289,60
"remove the 10MB initial mapping.

It doesn't really serve any purpose the other mappings don't already cover"," static void alloc_zero_map(unsigned long size, int prot, const char *name)
 
 unsigned long mapping_sizes[NR_MAPPING_SIZES] = {
 -1,/* over-written with page_size below */
-MB(1), MB(2), MB(4), MB(10),
+MB(1), MB(2), MB(4),
 GB(1),
 };
 
",82,11
"be careful not to read past the end of the ip_ssoptrs array

If we create a socket with a protocol higher than that of
IPPROTO_MAX, then we can screw up here, because we sometimes
can call the ip setsockopt() on a non-ip socket.
(see syscalls/setsockopt.c:do_random_sso)"," static void call_inet_sso_ptr(struct sockopt *so, struct socket_triplet *triplet
 {
 int proto = triplet->protocol;
 
+/* we might have gotten here from a non-IP socket, (see setsockopt.c
+ * Make sure we don't run past the end of the array above
+ * Don't adjust the actual triplet though, because it's what the real socket is.
+ */
+if (proto > IPPROTO_MAX)
+proto = rnd() % IPPROTO_MAX;
+
 if (ip_ssoptrs[proto].func != NULL) {
 if (ip_ssoptrs[proto].sol != 0)
 so->level = ip_ssoptrs[proto].sol;
",315,30
define maximum size of ip_ssoptrs array," struct ip_sso_funcptr {
 #define SOL_UDPLITE 136
 #define SOL_DCCP 269
 
-static const struct ip_sso_funcptr ip_ssoptrs[] = {
+static const struct ip_sso_funcptr ip_ssoptrs[IPPROTO_MAX] = {
 [IPPROTO_IP] = { .func = &ip_setsockopt },
 [IPPROTO_ICMP] = { .func = NULL },
 [IPPROTO_IGMP] = { .func = NULL },
",315,30
"push the dropprivs code down into the child processes.

* main process always retains root privs.
* child processes will later get the option to retain root privs
 and run root-only ops.","
 #include ""list.h""
 #include ""log.h""
 #include ""maps.h""
+#include ""params.h""
 #include ""pids.h""
 #include ""random.h""
 #include ""shm.h""

 #include ""syscall.h""
 #include ""tables.h""
 #include ""trinity.h""// ARRAY_SIZE
+#include ""uid.h""
 #include ""utils.h""// zmalloc
 
 struct child_funcs {
 static void init_child(struct childdata *child, int childno)
 mask_signals_child();
 
 disable_coredumps();
-
+/*
 if (shm->unshare_perm_err == FALSE) {
 if (RAND_BOOL()) {
 int ret = unshare(CLONE_NEWUSER);
 static void init_child(struct childdata *child, int childno)
 shm->unshare_perm_err = TRUE;
 }
 }
+*/
+if (dropprivs == TRUE)
+drop_privs();
 }
 
 /*
",284,57
bump the 'pick new op' counter even higher.," static bool handle_sigreturn(void)
 * from the fork_children() loop.
 * We also re-enter it from the signal handler code if something happened.
 */
-#define NEW_OP_COUNT 10000
+#define NEW_OP_COUNT 100000
 
 void child_process(struct childdata *child, int childno)
 {
",284,57
"add a 'read /proc/<pid>/status' childop

simple beginnings. Eventually, I'll add support for hammering on all
the /proc/<pid>/ files."," struct child_funcs {
 static const struct child_funcs child_ops[] = {
 { .name = ""rand_syscall"", .func = random_syscall, .likelyhood = 100, .type = CHILD_RAND_SYSCALL },
 //{ .name = ""read_all_files"", .func = read_all_files, .likelyhood = 10, .type = CHILD_READ_ALL_FILES },
+{ .name = ""thrash_pid_files"", .func = thrash_pidfiles, .likelyhood = 50, .type = CHILD_THRASH_PID },
 };
 
 /*
",285,57
fix leaks in thrash-pid-files," static void read_pid_files(pid_t pid, char *buffer)
 return;
 
 ret = read(fd, buffer, page_size);
-if (ret < 0)
+if (ret < 0) {
+close(fd);
 return;
+}
 
 close(fd);
 }
 bool thrash_pidfiles(__unused__ struct childdata *child)
 if (pid != EMPTY_PIDSLOT)
 read_pid_files(pid, buffer);
 
-if (shm->exit_reason != STILL_RUNNING)
+if (shm->exit_reason != STILL_RUNNING) {
+free(buffer);
 return FALSE;
+}
 
 clock_gettime(CLOCK_MONOTONIC, &child->tp);
 }
+
+free(buffer);
 return TRUE;
 }
",51,6
reformat childop structs," struct child_funcs {
 };
 
 static const struct child_funcs child_ops[] = {
-{ .name = ""rand_syscall"", .func = random_syscall, .likelyhood = 100, .type = CHILD_RAND_SYSCALL },
-//{ .name = ""read_all_files"", .func = read_all_files, .likelyhood = 10, .type = CHILD_READ_ALL_FILES },
-{ .name = ""thrash_pid_files"", .func = thrash_pidfiles, .likelyhood = 50, .type = CHILD_THRASH_PID },
+{
+.name = ""rand_syscall"",
+.func = random_syscall,
+.likelyhood = 100,
+.type = CHILD_RAND_SYSCALL
+},
+/*{
+.name = ""read_all_files"",
+.func = read_all_files,
+.likelyhood = 10,
+.type = CHILD_READ_ALL_FILES
+},
+*/{
+.name = ""thrash_pid_files"",
+.func = thrash_pidfiles,
+.likelyhood = 50,
+.type = CHILD_THRASH_PID
+},
 };
 
 /*
",295,57
convert uid.c to use output() instead of outputerr()," void dump_uids(void)
 void drop_privs(void)
 {
 if (setresgid(nobody_gid, nobody_gid, nobody_gid) < 0) {
-outputerr(""Error setting nobody gid (%s)\n"", strerror(errno));
+output(0, ""Error setting nobody gid (%s)\n"", strerror(errno));
 exit(EXIT_FAILURE);
 }
 
 if (setgroups(0, NULL) == -1) {
-outputerr(""Error dropping supplemental groups (%s)\n"", strerror(errno));
+output(0, ""Error dropping supplemental groups (%s)\n"", strerror(errno));
 exit(EXIT_FAILURE);
 }
 
 if (setresuid(nobody_uid, nobody_uid, nobody_uid) < 0) {
-outputerr(""Error setting nobody uid (%s)\n"", strerror(errno));
+output(0, ""Error setting nobody uid (%s)\n"", strerror(errno));
 exit(EXIT_FAILURE);
 }
 
-outputstd(""set uid to %u and gid to %d (nobody)\n"", nobody_uid, nobody_gid);
+output(0, ""set uid to %u and gid to %d (nobody)\n"", nobody_uid, nobody_gid);
 }
 
 void init_uids(void)
",103,19
set a flag in the child struct when we've dropped privs," void clean_childdata(struct childdata *child)
 child->dontkillme = FALSE;
 child->xcpu_count = 0;
 child->op_nr = 0;
+child->dropped_privs = FALSE;
 clock_gettime(CLOCK_MONOTONIC, &child->tp);
 }
 
 static void init_child(struct childdata *child, int childno)
 }
 */
 if (dropprivs == TRUE)
-drop_privs();
+drop_privs(child);
 }
 
 /*
",296,57
rewrite set_new_op to take ptrs to alternative childops.," static bool handle_sigreturn(void)
 static void * set_new_op(struct childdata *child)
 {
 bool (*op)(struct childdata *child) = NULL;
+const struct child_funcs *ops;
+size_t len;
+
+ops = child_ops;
+len = ARRAY_SIZE(child_ops);
 
 while (op == NULL) {
 unsigned int i;
 
-i = rnd() % ARRAY_SIZE(child_ops);
+i = rnd() % len;
 
-if (rnd() % 100 <= child_ops[i].likelyhood) {
-if (op != child_ops[i].func) {
-//output(0, ""Chose %s.\n"", child_ops[i].name);
-op = child_ops[i].func;
-child->type = child_ops[i].type;
+if (rnd() % 100 <= ops[i].likelyhood) {
+if (op != ops[i].func) {
+//output(0, ""Chose %s.\n"", ops[i].name);
+op = ops[i].func;
+child->type = ops[i].type;
 }
 }
 }
",305,58
"Introduce 'root child ops'.

Make 'drop privs' be the first possible operation a root process can do.
After calling this, a child will then fall back to calling only
!root operations.","
 #include <pwd.h>
 #include <grp.h>
 #include ""child.h""
+#include ""debug.h""
 #include ""log.h""
 #include ""params.h""
 #include ""trinity.h""
 void dump_uids(void)
 uid, gid, euid, egid, suid, sgid);
 }
 
-void drop_privs(struct childdata *child)
+bool drop_privs(struct childdata *child)
 {
 if (setresgid(nobody_gid, nobody_gid, nobody_gid) < 0) {
 output(0, ""Error setting nobody gid (%s)\n"", strerror(errno));
 void drop_privs(struct childdata *child)
 }
 
 if (setgroups(0, NULL) == -1) {
-output(0, ""Error dropping supplemental groups (%s)\n"", strerror(errno));
-exit(EXIT_FAILURE);
+;
 }
 
 if (setresuid(nobody_uid, nobody_uid, nobody_uid) < 0) {
 void drop_privs(struct childdata *child)
 exit(EXIT_FAILURE);
 }
 
-output(0, ""set uid to %u and gid to %d (nobody)\n"", nobody_uid, nobody_gid);
+//debugf(""set uid to %u and gid to %d (nobody)\n"", nobody_uid, nobody_gid);
 child->dropped_privs = TRUE;
+return TRUE;
 }
 
 void init_uids(void)
",105,19
don't call fcntl on -1 fd's," static int open_testfile(char *filename)
 
 if (RAND_BOOL()) {
 fd = open_with_fopen(filename, O_RDWR);
-if (fd != -1)
+if (fd != -1) {
 output(2, ""fd[%d] = fopen(\""%s\"", O_RDWR)\n"", fd, filename);
-(void) fcntl(fd, F_SETFL, random_fcntl_setfl_flags());
+(void) fcntl(fd, F_SETFL, random_fcntl_setfl_flags());
+}
 } else {
 const unsigned long open_flags[] = { O_DIRECT, O_DSYNC, O_SYNC, };
 int flags = 0;
",89,11
only do the 'stuck syscall' info on children running random syscalls," static void stuck_syscall_info(struct childdata *child)
 if (shm->debug == FALSE)
 return;
 
+if (child->type != CHILD_RAND_SYSCALL)
+return;
+
 rec = &child->syscall;
 
 if (trylock(&rec->lock) == FALSE)
",543,123
print the error if the initial mmaps fail,"
 * Children will copy the whole initial_mappings list to their own
 * private copies, and then perform operations upon them.
 */
+#include <errno.h>
 #include <fcntl.h>
 #include <stdio.h>
 #include <stdlib.h>
 static void alloc_zero_map(unsigned long size, int prot, const char *name)
 new->map.type = INITIAL_ANON;
 new->map.ptr = mmap(NULL, size, prot, MAP_ANONYMOUS | MAP_SHARED, fd, 0);
 if (new->map.ptr == MAP_FAILED) {
-outputerr(""mmap failure\n"");
+outputerr(""mmap failure:%s\n"", strerror(errno));
 exit(EXIT_FAILURE);
 }
 
",83,11
"fix offset for 1GB pages.

When I removed the 10MB mapping, I forgot to update this, despite
the big fat comment."," static void setup_mapping_sizes(void)
 }
 
 //FIXME
-mapping_sizes[5] = page_size;
+mapping_sizes[4] = page_size;
 
 out_free:
 free(buffer);
",83,11
"when disabling 1GB pages, just do nothing

don't bother adding a second page_size mapping."," static void alloc_zero_map(unsigned long size, int prot, const char *name)
 struct object *new;
 int fd;
 
+if (size == 0)
+return;
+
 fd = open(""/dev/zero"", O_RDWR);
 if (fd == -1) {
 outputerr(""couldn't open /dev/zero\n"");
 static void setup_mapping_sizes(void)
 }
 
 //FIXME
-mapping_sizes[4] = page_size;
+mapping_sizes[4] = 0;
 
 out_free:
 free(buffer);
",85,12
"make setup_fd_providers silent, so it doesn't spew during -h"," void setup_fd_providers(void)
 add_to_prov_list(&inotify_fd_provider);
 add_to_prov_list(&userfaultfd_provider);
 add_to_prov_list(&fanotify_fd_provider);
-
-output(0, ""Registered %d fd providers.\n"", num_fd_providers);
 }
 
 static void __open_fds(bool do_rand)
 unsigned int open_fds(void)
 /* Now open any leftovers */
 __open_fds(FALSE);
 
-output(0, ""Enabled %d fd providers: initialized:%d.\n"",
-num_fd_providers_enabled, num_fd_providers_initialized);
+output(0, ""Enabled %d/%d fd providers. initialized:%d.\n"",
+num_fd_providers_enabled, num_fd_providers, num_fd_providers_initialized);
 
 return TRUE;
 }
",201,32
add flags from 4.7 for preadv2/pwritev2,"
 #include ""shm.h""
 #include ""syscall.h""
 #include ""trinity.h""
+#include ""compat.h""
 
 static void sanitise_read(struct syscallrecord *rec)
 {
 struct syscallentry syscall_preadv = {
  int, flags)
 */
 static unsigned long preadv2_flags[] = {
-0,// No values defined as of v4.6
+RWF_HIPRI, RWF_DSYNC, RWF_SYNC,
 };
 
 struct syscallentry syscall_preadv2 = {
",92,3
"if random_ipv4_address picked localhost last time, let it happen again.

The ip_lifetime check happened too late, so we only had a 50/50 chance
of getting localhost more than once."," in_addr_t random_ipv4_address(void)
 {
 int addr;
 
-/* 50% of the time, just do localhost. */
-if (RAND_BOOL())
-return 0x7f000001;
-
 if (ip_lifetime != 0) {
 ip_lifetime--;
 return previous_ip;
 }
 
-addr = new_ipv4_addr();
+/* 50% of the time, just do localhost. */
+if (RAND_BOOL())
+addr = 0x7f000001;
+else
+addr = new_ipv4_addr();
 
 previous_ip = addr;
 ip_lifetime = 5;
",316,30
Convert fd provider initialization to use constructors," static int get_rand_drm_fd(void)
 return obj->drmfd;
 }
 
-struct fd_provider drm_fd_provider = {
+static struct fd_provider drm_fd_provider = {
 .name = ""drm"",
 .enabled = TRUE,
 .open = &open_drm_fds,
 .get = &get_rand_drm_fd,
 };
+
+REG_FD_PROV(drm_fd_provider);
",107,20
"include file cleanup

after switching the fd providers to use constructors, clean up the
leftover mess.","
 #include <unistd.h>
 #include <sys/epoll.h>
 
-#include ""epoll.h""
 #include ""fd.h""
 #include ""log.h""
 #include ""objects.h""

 #include ""sanitise.h""
 #include ""shm.h""
 
+#define MAX_EPOLL_FDS 10
+
 static void epoll_destructor(struct object *obj)
 {
 close(obj->epollfd);
",57,7
document how register_fd_provider gets run," static unsigned int num_fd_providers_initialized = 0;// num we called ->init on
 
 static struct fd_provider *fd_providers = NULL;
 
+/*
+ * This is called by the REG_FD_PROV constructors on startup.
+ * Because of this, this function shouldn't rely on anything
+ * already existing/being initialized.
+ */
 void register_fd_provider(const struct fd_provider *prov)
 {
 struct fd_provider *newnode;
",178,32
fix up more clang detritus," static void alg_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 // skcipher
 case 3:algo = rnd() % ARRAY_SIZE(algos);
 break;
+default: unreachable();
 }
 strcpy((char *)alg->salg_name, algos[algo]);
 
",243,6
change set_dontkillme to take a child struct instead of a pid," static const struct child_funcs root_child_ops[] = {
 * longer than the time the reaper is prepared to wait, especially if
 * we're doing something critical, like handling a lock, or dumping a log.
 */
-void set_dontkillme(pid_t pid, bool state)
+void set_dontkillme(struct childdata *child, bool state)
 {
-int childno;
-
-childno = find_childno(pid);
-if (childno == CHILD_NOT_FOUND)/* possible, we might be the mainpid */
+if (child == NULL)/* possible, we might be the mainpid */
 return;
-shm->children[childno]->dontkillme = state;
+child->dontkillme = state;
 }
 
 /*
",321,60
"bump the child progress indicator in set_dontkillme

This is mostly for when we are unsetting it, as we could have spent
some time dumping stack traces etc."," void set_dontkillme(struct childdata *child, bool state)
 if (child == NULL)/* possible, we might be the mainpid */
 return;
 child->dontkillme = state;
+
+/* bump the progress indicator */
+clock_gettime(CLOCK_MONOTONIC, &child->tp);
 }
 
 /*
",322,60
"check the actual num/values, not the pointers"," static void get_num_and_values(struct syscallentry *entry, unsigned int argnum,
 unreachable();
 }
 
-if (num == 0)
+if (*num == 0)
 BUG(""ARG_OP/LIST with 0 args. What?\n"");
 
-if (values == NULL)
+if (*values == NULL)
 BUG(""ARG_OP/LIST with no values.\n"");
 }
 
",365,127
"Reactivate the use of 1GB mmaps if enough memory available.

With the recent fixes in this area, this should be safe again

also, fix another instance of 'wrong offset for 1gb mapping'"," static void setup_mapping_sizes(void)
 if ((free * 1024) < GB(8ULL)) {
 printf(""Free memory: %.2fGB\n"", (double) free / 1024 / 1024);
 printf(""Low on memory, disabling mmaping of 1GB pages\n"");
-mapping_sizes[5] = page_size;
+mapping_sizes[4] = page_size;
 goto out_free;
 }
 }
 }
 
-//FIXME
-mapping_sizes[4] = 0;
-
 out_free:
 free(buffer);
 out_close:
",84,12
Add a child-op to truncate one of the testfiles to a random size," static const struct child_funcs child_ops[] = {
 .likelyhood = 10,
 .type = CHILD_READ_ALL_FILES
 },
-*/{
+{
 .name = ""thrash_pid_files"",
 .func = thrash_pidfiles,
 .likelyhood = 50,
 .type = CHILD_THRASH_PID
 },
+{
+.name = ""truncate_testfile"",
+.func = truncate_testfile,
+.likelyhood = 10,
+.type = CHILD_TRUNCATE_TESTFILE
+},
+*/
 };
 
 static const struct child_funcs root_child_ops[] = {
",316,60
"for each random syscall, do one in an extra child too.

idea here is two racing syscalls with the same inputs","
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
+#include <sys/types.h>
+#include <sys/wait.h>
 
 #include ""arch.h""// biarch
 #include ""child.h""
 retry:
 bool random_syscall(struct childdata *child)
 {
 struct syscallrecord *rec, *stash;
+pid_t pid;
 
 rec = &child->syscall;
 
 bool random_syscall(struct childdata *child)
 stash = zmalloc(sizeof(struct syscallrecord));
 memcpy(stash, rec, sizeof(struct syscallrecord));
 
-do_syscall(rec);
+pid = fork();
+if (pid == 0) {
+// child
+do_syscall(rec);
+_exit(EXIT_SUCCESS);
+} else if (pid > 0) {
+// parent
+int ret = 0;
+int childstatus;
+while (ret == 0) {
+clock_gettime(CLOCK_MONOTONIC, &child->tp);
+kill(pid, SIGKILL);
+ret = waitpid(pid, &childstatus, WUNTRACED | WCONTINUED | WNOHANG);
+if (ret == 0)
+usleep(100);
+}
+do_syscall(rec);
+} else {
+// fork failed
+return FALSE;
+}
 
 check_sanity(rec, stash);
 
",133,23
fix memory leak on child fork failure.," bool random_syscall(struct childdata *child)
 {
 struct syscallrecord *rec, *stash;
 pid_t pid;
+int ret = FALSE;
 
 rec = &child->syscall;
 
 bool random_syscall(struct childdata *child)
 _exit(EXIT_SUCCESS);
 } else if (pid > 0) {
 // parent
-int ret = 0;
+int childret = 0;
 int childstatus;
 while (ret == 0) {
 clock_gettime(CLOCK_MONOTONIC, &child->tp);
 kill(pid, SIGKILL);
-ret = waitpid(pid, &childstatus, WUNTRACED | WCONTINUED | WNOHANG);
-if (ret == 0)
+childret = waitpid(pid, &childstatus, WUNTRACED | WCONTINUED | WNOHANG);
+if (childret == 0)
 usleep(100);
 }
 do_syscall(rec);
 } else {
 // fork failed
-return FALSE;
+goto fail;
 }
 
 check_sanity(rec, stash);
 bool random_syscall(struct childdata *child)
 
 handle_syscall_ret(rec);
 
+ret = TRUE;
+fail:
 free(stash);
 
-return TRUE;
+return ret;
 }
",136,23
"check for potential failure to acquire testfile fd.

also, offsets are off_t's"," bool truncate_testfile(struct childdata *child)
 {
 int fd;
 int ret;
-int sizes[] = { 0, 4096, MB(1), GB(1) };
+off_t sizes[] = { 0, 4096, MB(1), GB(1) };
 
 fd = get_rand_testfile_fd();
+if (fd < 0)
+return FALSE;
 
 ret = ftruncate(fd, RAND_ARRAY(sizes));
 
",20,3
"fds/drm.c: Add forward declaration of struct.

Fix build error.

 CC	fds/drm.o
fds/drm.c: In function open_drm_fds:
fds/drm.c:120:3: error: drm_fd_provider undeclared (first use in this function)
 drm_fd_provider.enabled = FALSE;
 ^

Signed-off-by: Vinson Lee <vlee@freedesktop.org>"," static void add_drm_obj(int fd)
 output(2, ""fd[%d] = drm\n"", fd);
 }
 
+static struct fd_provider drm_fd_provider;
+
 static int open_drm_fds(void)
 {
 struct objhead *head;
",108,20
introduce object types for bpf maps & progs," void dump_objects(bool global, enum objecttype type)
 case OBJ_FD_FANOTIFY:
 output(0, ""fanotify:%d\n"", obj->fanotifyfd);\
 break;
+case OBJ_FD_BPF_MAP:
+output(0, ""bpf map fd:%d\n"", obj->bpf_map_fd);
+break;
+case OBJ_FD_BPF_PROG:
+output(0, ""bpf prog fd:%d\n"", obj->bpf_prog_fd);
+break;
 case OBJ_FUTEX:
 output(0, ""futex: %lx owner:%d\n"",
 obj->lock.futex, obj->lock.owner_pid);
",229,50
fix wrong variable name in childops wait," bool random_syscall(struct childdata *child)
 // parent
 int childret = 0;
 int childstatus;
-while (ret == 0) {
+while (childret == 0) {
 clock_gettime(CLOCK_MONOTONIC, &child->tp);
 kill(pid, SIGKILL);
 childret = waitpid(pid, &childstatus, WUNTRACED | WCONTINUED | WNOHANG);
",136,23
"if we use the fallback seed, don't use rand() yet."," static int fallbackseed(void)
 unsigned int r;
 
 //printf(""Fell back to gtod seed! errno:%s\n"", strerror(errno));
-r = rnd();
-if (!(RAND_BOOL())) {
-gettimeofday(&t, NULL);
-r |= t.tv_usec;
-}
+gettimeofday(&t, NULL);
+r = t.tv_sec * t.tv_usec;
 return r;
 }
 
",81,15
"Before falling back to gtod, try getrandom() if available."," static int fallbackseed(void)
 struct timeval t;
 unsigned int r;
 
-//printf(""Fell back to gtod seed! errno:%s\n"", strerror(errno));
+#ifdef SYS_getrandom
+int buf, ret;
+
+ret = syscall(SYS_getrandom, &buf, 4, 0);
+if (ret > 0)
+return buf;
+#endif
+
 gettimeofday(&t, NULL);
 r = t.tv_sec * t.tv_usec;
 return r;
",85,17
"net/proto-unix.c: set protocol to 0 in unix_rand_socket()

The protocol of an AF_UNIX socket should be 0.

Signed-off-by: Fabien Siron <fabien.siron@epita.fr>"," static void unix_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 
 static void unix_rand_socket(struct socket_triplet *st)
 {
-st->protocol = PF_UNIX;
+st->protocol = 0;
 
 switch (rnd() % 3) {
 case 0: st->type = SOCK_STREAM;
",38,5
"remove all the 'unknown errno' checking.

It's a huge task to get even a partial coverage here, and it's not
particularly useful, and slows things down unnecessarily."," static void post_execveat(struct syscallrecord *rec)
 free_execve_ptrs((void **) rec->a3, (void **) rec->a4);
 }
 
-static int execve_errnos[] = {
-E2BIG, EACCES, EFAULT, EINVAL, EIO, EISDIR, ELIBBAD, ELOOP,
-EMFILE, ENOENT, ENOEXEC, ENOMEM, ENOTDIR, EPERM, ETXTBSY,
-/* currently undocumented in man page. */
-ENAMETOOLONG, ENXIO, EBADF,
-};
-
 struct syscallentry syscall_execve = {
 .name = ""execve"",
 .num_args = 3,
 struct syscallentry syscall_execve = {
 .post = post_execve,
 .group = GROUP_VFS,
 .flags = EXTRA_FORK,
-.errnos = ERRNOS(execve_errnos),
 };
 
 static unsigned long execveat_flags[] = {
 struct syscallentry syscall_execveat = {
 .post = post_execveat,
 .group = GROUP_VFS,
 .flags = EXTRA_FORK,
-.errnos = ERRNOS(execve_errnos),
 };
",95,9
sanitise add_key type argument,"
 * On success add_key() returns the serial number of the key it created or updated.
 * On error, the value -1 will be returned and errno will have been set to an appropriate error.
 */
+#include ""random.h""
 #include ""sanitise.h""
 
+static const char *keytypes[] = {
+""user"", ""keyring"", ""big_key"",
+};
+
+static void sanitise_add_key(struct syscallrecord *rec)
+{
+rec->a1 = (unsigned long) RAND_ARRAY(keytypes);
+}
+
 struct syscallentry syscall_add_key = {
 .name = ""add_key"",
 .num_args = 5,
 struct syscallentry syscall_add_key = {
 .arg4type = ARG_LEN,
 .arg5name = ""ringid"",
 .rettype = RET_KEY_SERIAL_T,
+.sanitise = sanitise_add_key,
 };
",24,1
fix misplaced bracket in dump_childnos," void dump_childnos(void)
 if (pid_is_valid(pid) == FALSE)
 sptr += sprintf(sptr, ""%s"", ANSI_RED);
 
-if (pid_alive(pid == -1))
+if (pid_alive(pid) == -1)
 sptr += sprintf(sptr, ""%s"", ANSI_RED);
 
 sptr += sprintf(sptr, ""%u %s"", pid, ANSI_RESET);
",132,30
"check child is alive before we bomb it with SIGKILLs

also tweak delays"," bool random_syscall(struct childdata *child)
 // parent
 int childret = 0;
 int childstatus;
+
+// wait for child to exit, or kill it.
 while (childret == 0) {
+// slight pause to let child do something.
+usleep(1000);
+
 clock_gettime(CLOCK_MONOTONIC, &child->tp);
-kill(pid, SIGKILL);
-childret = waitpid(pid, &childstatus, WUNTRACED | WCONTINUED | WNOHANG);
-if (childret == 0)
-usleep(100);
+
+if (pid_alive(pid) == 0) {
+kill(pid, SIGKILL);
+childret = waitpid(pid, &childstatus, WUNTRACED | WCONTINUED | WNOHANG);
+if (childret == 0)
+usleep(10000);
+}
 }
+// and do the same work in the parent.
 do_syscall(rec);
 } else {
 // fork failed
",139,24
"pid_alive is a boolean thing, so make it return bool"," static void init_child(struct childdata *child, int childno)
 
 /* Wait for parent to set our childno */
 while (pids[childno] != pid) {
-int ret = 0;
-
 /* Make sure parent is actually alive to wait for us. */
-ret = pid_alive(mainpid);
-if (ret != 0) {
+if (pid_alive(mainpid) == FALSE) {
 panic(EXIT_SHM_CORRUPTION);
 outputerr(""BUG!: parent (%d) went away!\n"", mainpid);
 sleep(20000);
 static void check_parent_pid(void)
 ""main pid:%d. ppid=%d\n"",
 pid, mainpid, ppid);
 
-if (pid_alive(mainpid) == -1)
+if (pid_alive(mainpid) == FALSE)
 output(0, ""main pid %d is dead.\n"", mainpid);
 
 panic(EXIT_REPARENT_PROBLEM);
 void child_process(struct childdata *child, int childno)
 /* If we're exiting because we tainted, wait here for it to be done. */
 while (shm->postmortem_in_progress == TRUE) {
 /* Make sure the main process is still around. */
-if (pid_alive(mainpid) == -1)
+if (pid_alive(mainpid) == FALSE)
 goto out;
 
 usleep(1);
",314,60
replace open-coded pid_alive," static void reap_dead_kids(void)
 
 for_each_child(i) {
 pid_t pid;
-int ret;
 int childstatus;
 
 pid = pids[i];
 static void reap_dead_kids(void)
 if (pid_is_valid(pid) == FALSE)
 continue;
 
-ret = kill(pid, 0);
-/* If it disappeared, reap it. */
-if (ret == -1) {
+if (pid_alive(pid) == FALSE) {
+/* If it disappeared, reap it. */
 if (errno == ESRCH) {
 output(0, ""pid %u has disappeared. Reaping.\n"", pid);
 reap_child(shm->children[i]);
",541,123
replace kill() invocations with kill_pid," bool random_syscall(struct childdata *child)
 clock_gettime(CLOCK_MONOTONIC, &child->tp);
 
 if (pid_alive(pid) == TRUE) {
-kill(pid, SIGKILL);
+kill_pid(pid);
 childret = waitpid(pid, &childstatus, WUNTRACED | WCONTINUED | WNOHANG);
 if (childret == 0)
 usleep(10000);
",139,24
grand-child forking code needs to handle errors," static void do_extrafork(struct syscallrecord *rec)
 _exit(EXIT_SUCCESS);
 }
 
+/* misc failure. */
+if (extrapid == -1) {
+debugf(""Couldn't fork grandchild\n"");
+return;
+}
+
 /* child */
 while (pid == 0) {
 int childstatus;
",162,33
silence annoying cppcheck warning," int check_stat_file(const struct stat *sb)
 set_write = TRUE;
 
 
-if ((set_read | set_write) == 0)
+if (set_read == 0 && set_write == 0)
 return -1;
 
 if (set_read == TRUE)
",225,54
"The 1GB mappings cause oom's too much, disable them most the time","
 #include ""list.h""
 #include ""log.h""
 #include ""maps.h""
+#include ""random.h""
 #include ""utils.h""
 
 static void alloc_zero_map(unsigned long size, int prot, const char *name)
 static void setup_mapping_sizes(void)
 
 mapping_sizes[0] = page_size;
 
+/* Using 1GB mappings ends up oom'ing a lot, so we don't
+ * want to do it every single run. It's worth doing it
+ * occasionally though, to stress the oom paths.
+ */
+if (!(ONE_IN(100))) {
+mapping_sizes[4] = page_size;
+return;
+}
+
 fp = fopen(""/proc/meminfo"", ""r"");
 if (!fp)
 return;
",89,13
pass the signal from the sighandler using siglongjmp instead of global var," static void periodic_work(void)
 *
 * FIXME: when we have different child ops, we're going to need to redo the progress detector.
 */
-static bool handle_sigreturn(void)
+static bool handle_sigreturn(int sigwas)
 {
 struct childdata *child = this_child();
 struct syscallrecord *rec;
 void child_process(struct childdata *child, int childno)
 goto out;
 }
 
-if (handle_sigreturn() == FALSE)
+if (handle_sigreturn(ret) == FALSE)
 goto out;// Exit the child, things are getting too weird.
 }
 
",314,60
"Check for 0 pid when encountering locked lock

Because the pid zeroing happens before we set the lock back to UNLOCKED,
there's a tiny window where we end up with a locked lock with no owner.
Just recheck, and we'll get it right next time around."," static bool check_lock(lock_t *_lock)
 {
 pid_t pid;
 
+retry:
 /* We don't care about unlocked or locking-in-progress */
 if (_lock->lock != LOCKED)
 return FALSE;
 
 /* First the easy case. If it's held by a dead pid, release it. */
 pid = _lock->owner;
+
+/* if we're in the process of unlocking, it can show up as LOCKED
+ * but with no owner. Just retry.
+ */
+if (pid == 0)
+goto retry;
+
 if (pid_alive(pid) == FALSE) {
 if (errno != ESRCH)
 return TRUE;
",87,19
add support for TCP_REPAIR_WINDOW," static const unsigned int tcp_opts[] = {
 TCP_THIN_DUPACK, TCP_USER_TIMEOUT, TCP_REPAIR, TCP_REPAIR_QUEUE,
 TCP_QUEUE_SEQ, TCP_REPAIR_OPTIONS, TCP_FASTOPEN, TCP_TIMESTAMP,
 TCP_NOTSENT_LOWAT, TCP_CC_INFO, TCP_SAVE_SYN, TCP_SAVED_SYN,
+TCP_REPAIR_WINDOW,
 };
 
 void tcp_setsockopt(struct sockopt *so, __unused__ struct socket_triplet *triplet)
",20,1
"force unlock 'stuck' locks.

don't wait for it to unlock, because the unlocker may be dead."," static bool check_lock(lock_t *_lock)
 {
 pid_t pid;
 
-retry:
 /* We don't care about unlocked or locking-in-progress */
 if (_lock->lock != LOCKED)
 return FALSE;
 retry:
 pid = _lock->owner;
 
 /* if we're in the process of unlocking, it can show up as LOCKED
- * but with no owner. Just retry.
+ * but with no owner. Just unlock it.
  */
 if (pid == 0)
-goto retry;
+unlock(_lock);
 
 if (pid_alive(pid) == FALSE) {
 if (errno != ESRCH)
",86,19
"Check for existence of linux/bpf.h

This is a little more involved, due to us now needing to handle
holes in the syscall table when something isn't defined.

Based on an initial patch from Vinson Lee <vlee@freedesktop.org>","
 /*
 * SYSCALL_DEFINE3(bpf, int, cmd, union bpf_attr __user *, uattr, unsigned int, size)
 */
+#ifdef USE_BPF
 #include <linux/bpf.h>
 #include <linux/filter.h>
 #include ""arch.h""
 struct syscallentry syscall_bpf = {
 .sanitise = sanitise_bpf,
 .post = post_bpf,
 };
+#endif
",81,8
"forcing an unlock is a bad idea, just wait a little longer."," static bool check_lock(lock_t *_lock)
 pid = _lock->owner;
 
 /* if we're in the process of unlocking, it can show up as LOCKED
- * but with no owner. Just unlock it.
+ * but with no owner. Just bail, we'll try again next time around.
  */
 if (pid == 0)
-unlock(_lock);
+return FALSE;
 
 if (pid_alive(pid) == FALSE) {
 if (errno != ESRCH)
",86,19
dump errno if we fail to fork a child," static void do_extrafork(struct syscallrecord *rec)
 
 /* misc failure. */
 if (extrapid == -1) {
-debugf(""Couldn't fork grandchild\n"");
+debugf(""Couldn't fork grandchild: %s\n"", strerror(errno));
 return;
 }
 
",162,33
"remove the pause in the parent before we wait for the child.

It isn't necessary due to the other syscalls"," static bool do_syscall_in_child(struct syscallrecord *rec, struct childdata *chi
 
 // wait for child to exit, or kill it.
 while (childret == 0) {
-// slight pause to let child do something.
-usleep(1000);
 
 clock_gettime(CLOCK_MONOTONIC, &child->tp);
 
",147,27
secret option to skip the delay when run as root," bool do_syslog = FALSE;
 bool random_selection = FALSE;
 unsigned int random_selection_num;
 
+bool clowntown = FALSE;
+
 bool user_set_seed = FALSE;
 
 unsigned char desired_group = GROUP_NONE;
 static const struct option longopts[] = {
 { ""arch"", required_argument, NULL, 'a' },
 { ""bdev"", required_argument, NULL, 'b' },
 { ""children"", required_argument, NULL, 'C' },
+{ ""clowntown"", no_argument, NULL, 0 },
 { ""dangerous"", no_argument, NULL, 'd' },
 { ""dropprivs"", no_argument, NULL, 'X'},
 { ""debug"", no_argument, NULL, 'D' },
 void parse_args(int argc, char *argv[])
 if (strcmp(""server_port"", longopts[opt_index].name) == 0)
 server_port = atoi(optarg);
 
+if (strcmp(""clowntown"", longopts[opt_index].name) == 0)
+clowntown = TRUE;
+
 if (strcmp(""disable-fds"", longopts[opt_index].name) == 0)
 process_fds_param(optarg, FALSE);
 
",275,47
"remove the 4MB mapping

This is pretty pointless, because no-one cares about !PAE 32bit x86"," static void alloc_zero_map(unsigned long size, int prot, const char *name)
 
 unsigned long mapping_sizes[NR_MAPPING_SIZES] = {
 -1,/* over-written with page_size below */
-MB(1), MB(2), MB(4),
+MB(1), MB(2),
 GB(1),
 };
 
 static void setup_mapping_sizes(void)
  * occasionally though, to stress the oom paths.
  */
 if (!(ONE_IN(100))) {
-mapping_sizes[4] = page_size;
+mapping_sizes[3] = page_size;
 return;
 }
 
 static void setup_mapping_sizes(void)
 if ((free * 1024) < GB(8ULL)) {
 printf(""Free memory: %.2fGB\n"", (double) free / 1024 / 1024);
 printf(""Low on memory, disabling mmaping of 1GB pages\n"");
-mapping_sizes[4] = page_size;
+mapping_sizes[3] = page_size;
 goto out_free;
 }
 }
",89,13
make IPPROTO_IP sockets be type DGRAM," struct ipproto {
 static void inet_rand_socket(struct socket_triplet *st)
 {
 struct ipproto ipprotos[] = {
-{ .proto = IPPROTO_IP, },
+{ .proto = IPPROTO_IP, .type = SOCK_DGRAM },
 { .proto = IPPROTO_ICMP, .type = SOCK_DGRAM },
 { .proto = IPPROTO_IGMP, },
 { .proto = IPPROTO_IPIP, },
",316,30
mmap sanitize can use simplified 'size' setting," static void sanitise_mmap(struct syscallrecord *rec)
 /* Don't actually set a hint right now. */
 rec->a1 = 0;
 
+rec->a2 = RAND_ARRAY(mapping_sizes);
+
 /* this over-rides the ARG_OP in the syscall struct */
 rec->a4 = get_rand_mmap_flags();
 
 if (rec->a4 & MAP_ANONYMOUS) {
-rec->a2 = RAND_ARRAY(mapping_sizes);
 do_anon(rec);
 } else {
 rec->a5 = get_random_fd();
 static void sanitise_mmap(struct syscallrecord *rec)
 /* page align non-anonymous mappings. */
 rec->a6 &= PAGE_MASK;
 }
-
-rec->a2 = page_size;
 }
 }
 
",143,17
"fix segfault when specifying multiple -c's

We now need to care about NULL's in the syscall table."," int search_syscall_table(const struct syscalltable *table, unsigned int nr_sysca
 
 /* search by name */
 for (i = 0; i < nr_syscalls; i++) {
+if (table[i].entry == NULL)
+continue;
+
 if (strcmp(arg, table[i].entry->name) == 0) {
 //debugf(""Found %s at %u\n"", table[i].entry->name, i);
 return i;
",493,137
"Add a hook for protocols to call post socket()

Sometimes we might want to always call certain setsockopt's on
a created socket."," static int open_socket(unsigned int domain, unsigned int type, unsigned int prot
 {
 struct object *obj;
 struct sockaddr *sa = NULL;
+const struct netproto *proto;
 socklen_t salen;
 struct sockopt so = { 0, 0, 0, 0 };
 int fd;
 static int open_socket(unsigned int domain, unsigned int type, unsigned int prot
 
 obj = add_socket(fd, domain, type, protocol, FALSE);
 
+proto = net_protocols[domain].proto;
+if (proto->socket_setup != NULL)
+proto->socket_setup(fd);
+
 /* Set some random socket options. */
 sso_socket(&obj->sockinfo.triplet, &so, fd);
 
",343,77
give equal chance to mmap exclusive flags with/without extra flags," unsigned long get_rand_mmap_flags(void)
 };
 
 flags = RAND_ARRAY(mmap_excl_flags);
-flags |= set_rand_bitmask(ARRAY_SIZE(mmap_flags), mmap_flags);
+if (RAND_BOOL())
+flags |= set_rand_bitmask(ARRAY_SIZE(mmap_flags), mmap_flags);
 
 return flags;
 }
",144,18
check for NULL protocol ptrs," static int open_socket(unsigned int domain, unsigned int type, unsigned int prot
 obj = add_socket(fd, domain, type, protocol, FALSE);
 
 proto = net_protocols[domain].proto;
-if (proto->socket_setup != NULL)
-proto->socket_setup(fd);
+if (proto != NULL)
+if (proto->socket_setup != NULL)
+proto->socket_setup(fd);
 
 /* Set some random socket options. */
 sso_socket(&obj->sockinfo.triplet, &so, fd);
",344,78
"if we haven't done a syscall yet, treat child as ""making progress"".

Chances are that we haven't been scheduled because some other
children are hogging the cpu."," static void stuck_syscall_info(struct childdata *child)
 */
 static bool is_child_making_progress(struct childdata *child)
 {
+struct syscallrecord *rec;
 struct timespec tp;
 time_t diff, old, now;
 pid_t pid;
 static bool is_child_making_progress(struct childdata *child)
 
 if (pid == EMPTY_PIDSLOT)
 return TRUE;
+// bail if we've not done a syscall yet, we probably just haven't
+// been scheduled due to other pids hogging the cpu
+rec = &child->syscall;
+if (trylock(&rec->lock) == FALSE)
+return TRUE;
+
+if (rec->state <= BEFORE) {
+unlock(&rec->lock);
+return TRUE;
+}
+unlock(&rec->lock);
 
 old = child->tp.tv_sec;
 
",551,125
"Fix a missing reseed point.

We were only reseeding from fork_children(), so when we called
spawn_child directly, we got a child with a seed we'd already used."," static bool spawn_child(int childno)
 struct childdata *child = shm->children[childno];
 int pid = 0;
 
+reseed();
+
 /* Wipe out any state left from a previous child running in this slot. */
 clean_childdata(child);
 
",585,131
"remove out of date comment about -n

This arg doesn't exist any more. This condition may be unnecessary now,
but it's safe enough to leave it in case I change the path building code
later."," const char * generate_pathname(void)
 char *newpath;
 unsigned int len;
 
-if (pathname == NULL)/* handle -n correctly. */
+if (pathname == NULL)
 return NULL;
 
 /* 90% chance of returning an unmangled filename */
",225,54
"store results of which file descriptors a given syscall succeeded with.

This will later be used to avoid using fd's that block, or fail in some
other way."," static unsigned long handle_arg_mode_t(void)
 return mode;
 }
 
-static enum argtype get_argtype(struct syscallentry *entry, unsigned int argnum)
+enum argtype get_argtype(struct syscallentry *entry, unsigned int argnum)
 {
 enum argtype argtype = 0;
 
",365,127
remove implied local variable name," static unsigned int render_syscall_prefix(struct syscallrecord *rec, char *buffe
 
 sptr += sprintf(sptr, ""%s%s("", entry->name, ANSI_RESET);
 
-for_each_arg(i) {
+for_each_arg(entry, i) {
 sptr = render_arg(rec, sptr, i, entry);
 }
 
",154,40
store results for ARG_LEN," static void store_successful_fd(struct results *results, unsigned long value)
 results->fdmap[fd] = TRUE;
 }
 
+static void store_successful_len(struct results *results, unsigned long value)
+{
+if (value < results->min)
+results->min = value;
+if (value > results->max)
+results->max = value;
+}
+
 static void handle_success(struct syscallrecord *rec)
 {
 struct syscallentry *entry;
 static void handle_success(struct syscallrecord *rec)
 store_successful_fd(results, value);
 break;
 case ARG_LEN:
+store_successful_len(results, value);
+break;
 case ARG_UNDEFINED:
 case ARG_ADDRESS:
 case ARG_MODE_T:
",239,70
"remove all the server_addr stuff

It wasn't particularly useful in this form. Eventually I'll do something
better here, but for now we'll rely on localhost"," in_addr_t random_ipv4_address(void)
 static void ipv4_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 {
 struct sockaddr_in *ipv4;
-struct in_addr serv_addr;
 
 ipv4 = zmalloc(sizeof(struct sockaddr_in));
 
 static void ipv4_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 ipv4->sin_addr.s_addr = random_ipv4_address();
 ipv4->sin_port = htons(rnd() % 65535);
 
-/* Client side if we supplied server_addr */
-if (inet_pton(PF_INET, server_addr, &serv_addr) == 1)
-ipv4->sin_addr = serv_addr;
-/* Server side if we supplied port without addr, so listen on INADDR_ANY */
-else if (server_port != 0)
-ipv4->sin_addr.s_addr = htonl(INADDR_ANY);
-
-/* Fuzz from port to (port + 100) if supplied */
-if (server_port != 0)
-ipv4->sin_port = htons(server_port + rnd() % 100);
-
 *addr = (struct sockaddr *) ipv4;
 *addrlen = sizeof(struct sockaddr_in);
 }
",309,27
tweak localhost bias to be 90%," in_addr_t random_ipv4_address(void)
 return previous_ip;
 }
 
-/* 50% of the time, just do localhost. */
-if (RAND_BOOL())
+/* 90% of the time, just do localhost. */
+if (!(ONE_IN(10)))
 addr = 0x7f000001;
 else
 addr = new_ipv4_addr();
",309,27
"remove masking of random seeds.

Reducing entropy in the seed isn't a good idea, we end up re-using
a lot of the lower numbered seeds."," static int fallbackseed(void)
 
 unsigned int new_seed(void)
 {
-unsigned int r, bits;
+unsigned int r;
 
 if (urandomfd == -1)
 return fallbackseed();
 unsigned int new_seed(void)
 if (read(urandomfd, &r, sizeof(r)) != sizeof(r))
 return fallbackseed();
 
-if (read(urandomfd, &bits, sizeof(bits)) != sizeof(bits))
-return fallbackseed();
-
-bits %= 31;
-bits = max(bits, 8U);
-r &= ((1 << bits) -1);
-
 //printf(""new seed:%u\n"", r);
 return r;
 }
",80,16
"make PF matcher work on length of string passed in.

We were matching 'INET6' as 'INET' because it appears earlier
in the list."," static const struct domain domains[] = {
 
 static const struct domain *lookup_domain(const char *name)
 {
-unsigned int i;
+unsigned int i, len;
 
 if (!name)
 return NULL;
 
-if (strncmp(name, ""PF_"", 3) == 0)
+len = strlen(name);
+
+if (strncmp(name, ""PF_"", 3) == 0) {
 name += 3;
+len-=3;
+}
 
 for (i = 0; i < ARRAY_SIZE(domains); i++) {
-if (strncmp(name, domains[i].name, strlen(domains[i].name)) == 0)
+if (strncmp(name, domains[i].name, len) == 0)
 return &domains[i];
 }
 
",139,20
only do raw sockets if we're running as root,"
 #include ""net.h""
 #include ""config.h""
 #include ""random.h""
+#include ""uid.h""
 #include ""utils.h""// ARRAY_SIZE
 
 /* workaround for <linux/in.h> vs. <netinet/in.h> */
 static void inet_rand_socket(struct socket_triplet *st)
 };
 unsigned char val;
 
-/* half the time, use raw sockets */
-st->type = SOCK_RAW;
-if (RAND_BOOL())
-return;
+if (orig_uid == 0) {
+/* half the time, use raw sockets */
+st->type = SOCK_RAW;
+if (RAND_BOOL())
+return;
+}
 
 /* The rest of the time, use the correct type if present. */
 val = rnd() % ARRAY_SIZE(ipprotos);
",312,28
add possible SOCK types for IP sockets," struct ipproto {
 
 static void inet_rand_socket(struct socket_triplet *st)
 {
+int types[] = { SOCK_STREAM, SOCK_DGRAM, SOCK_SEQPACKET };
+
 struct ipproto ipprotos[] = {
 { .proto = IPPROTO_IP, .type = SOCK_DGRAM },
 { .proto = IPPROTO_ICMP, .type = SOCK_DGRAM },
 static void inet_rand_socket(struct socket_triplet *st)
 st->protocol = ipprotos[val].proto;
 if (ipprotos[val].type != 0)
 st->type = ipprotos[val].type;
+else
+st->type = RAND_ARRAY(types);
 }
 
 static const struct sock_option ip_opts[] = {
",315,28
"socket(INET[6], IPPROTO_IP) can be multiple types."," static void inet_rand_socket(struct socket_triplet *st)
 int types[] = { SOCK_STREAM, SOCK_DGRAM, SOCK_SEQPACKET };
 
 struct ipproto ipprotos[] = {
-{ .proto = IPPROTO_IP, .type = SOCK_DGRAM },
+{ .proto = IPPROTO_IP, },
 { .proto = IPPROTO_ICMP, .type = SOCK_DGRAM },
 { .proto = IPPROTO_IGMP, },
 { .proto = IPPROTO_IPIP, },
",315,28
move periodic_work() after the seeding interval," void child_process(struct childdata *child, int childno)
 loops = 0;
 
 while (shm->exit_reason == STILL_RUNNING) {
-periodic_work();
-
 /* If the parent reseeded, we should reflect the latest seed too. */
-if (shm->seed != child->seed)
+if (shm->seed != child->seed) {
+//output(0, ""child %d reseeded to %x\n"", child->num, child->seed);
 set_seed(child);
+}
+
+periodic_work();
 
 /* Every NEW_OP_COUNT potentially pick a new childop. */
 if (loops == 0) {
",317,61
"move initial reseed out of fork_children into spawn_child

Making spawn_child the only place we do reseeding."," static bool spawn_child(int childno)
 struct childdata *child = shm->children[childno];
 int pid = 0;
 
-reseed();
+/* a new child means a new seed, or the new child
+ * will do the same syscalls as the one in the child it's replacing.
+ * (special case startup, or we reseed unnecessarily)
+ */
+if (shm->ready == TRUE)
+reseed();
 
 /* Wipe out any state left from a previous child running in this slot. */
 clean_childdata(child);
 static void fork_children(void)
 if (shm->spawn_no_more == TRUE)
 return;
 
-/* a new child means a new seed, or the new child
- * will do the same syscalls as the one in the child it's replacing.
- * (special case startup, or we reseed unnecessarily)
- */
-if (shm->ready == TRUE)
-reseed();
-
 /* Find a space for it in the pid map */
 childno = find_childno(EMPTY_PIDSLOT);
 if (childno == CHILD_NOT_FOUND) {
",584,131
remove debug code that crept in," out_unlock:
 close(cachefile);
 }
 
-exit(10);
 return ret;
 }
 
",351,78
"if the child pidstat file didn't open, don't try to close it.

This can happen if we run out of file handles"," static void handle_child(int childno, pid_t childpid, int childstatus)
 debugf(""Child %d (pid:%u type:%u) exited after %ld operations.\n"",
 childno, childpid, child->type, child->op_nr);
 reap_child(shm->children[childno]);
-fclose(child->pidstatfile);
+if (child->pidstatfile != NULL)
+fclose(child->pidstatfile);
 child->pidstatfile = NULL;
 
 replace_child(childno);
",585,132
"If we get a zero byte socket cache, invalidate it."," static int open_sockets(void)
 int fd;
 
 bytesread = read(cachefile, buffer, sizeof(int) * 3);
-if (bytesread == 0)
+if (bytesread == 0) {
+if (nr_sockets == 0)
+goto regenerate;
 break;
+}
 
 domain = buffer[0];
 type = buffer[1];
",354,79
"simplify rand_proto_type() using RAND_ARRAY

The special casing for packet sockets isn't worth it.","
 
 void rand_proto_type(struct socket_triplet *st)
 {
-int n;
-
-/*
- * One special moment on packet sockets. They
- * can be created with SOCK_PACKET, so if
- * PF_PACKET is disabled, choose some other type.
- */
-
-st->protocol = rnd() % PROTO_MAX;
-
-if (st->family == PF_INET && no_domains[PF_PACKET])
-n = 5;
-else
-n = 6;
-
-switch (rnd() % n) {
-case 0:st->type = SOCK_DGRAM;break;
-case 1:st->type = SOCK_STREAM;break;
-case 2:st->type = SOCK_SEQPACKET;break;
-case 3:st->type = SOCK_RAW;break;
-case 4:st->type = SOCK_RDM;break;
-/*
- * Make sure it's last one.
- */
-case 5:st->type = SOCK_PACKET;break;
-default: break;
-}
+int types[] = { SOCK_STREAM, SOCK_DGRAM, SOCK_RAW, SOCK_RDM, SOCK_SEQPACKET, SOCK_DCCP, SOCK_PACKET };
+
+st->protocol = RAND_ARRAY(types);
 }
 
 /* note: also called from generate_sockets() */
",89,17
handle ipv6 sockets in analyzer," static const char * get_proto_name(unsigned int family, unsigned int proto)
 };
 
 switch (family) {
+case AF_INET6:
 case AF_INET:
 for (i = 0; i < ARRAY_SIZE(ip_protocols); i++)
 if (ip_protocols[i].proto == proto)
",198,25
generalise the 'generate socket' routines.," static unsigned int valid_proto(unsigned int family)
 return TRUE;
 }
 
+void generate_socket(unsigned int family, unsigned int protocol, unsigned int type)
+{
+struct socket_triplet st;
+int fd;
+
+st.family = family;
+st.type = type;
+st.protocol = protocol;
+
+fd = open_socket(st.family, st.type, st.protocol);
+if (fd > -1) {
+write_socket_to_cache(&st);
+return;
+}
+output(0, ""Couldn't open socket %d:%d:%d. %s\n"", family, type, protocol, strerror(errno));
+}
+
 bool write_socket_to_cache(struct socket_triplet *st)
 {
 unsigned int buffer[3];
",368,81
fill out flowinfo & scope id for ipv6 sockaddr," static void ipv6_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 
 gen_random_ipv6_address(&ipv6->sin6_addr);
 ipv6->sin6_port = htons(rnd() % 65535);
+ipv6->sin6_flowinfo = rnd();
+ipv6->sin6_scope_id = rnd();
 
 *addr = (struct sockaddr *) ipv6;
 *addrlen = sizeof(struct sockaddr_in6);
",185,17
remove duplicate get_argval function," static unsigned long handle_arg_iovec(struct syscallentry *entry, struct syscall
 return (unsigned long) alloc_iovec(num_entries);
 }
 
-static unsigned long get_argval(struct syscallrecord *rec, unsigned int argnum)
-{
-unsigned long val = 0;
-
-switch (argnum) {
-case 1:val = rec->a1;
-break;
-case 2:val = rec->a2;
-break;
-case 3:val = rec->a3;
-break;
-case 4:val = rec->a4;
-break;
-case 5:val = rec->a5;
-break;
-case 6:val = rec->a6;
-break;
-}
-return val;
-}
-
-
 static unsigned long handle_arg_sockaddr(struct syscallentry *entry, struct syscallrecord *rec, unsigned int argnum)
 {
 struct sockaddr *sockaddr = NULL;
",346,120
pass the protocol family down to generate_sockaddr from sendmsg()," struct syscallentry syscall_sendto = {
 */
 static void sanitise_sendmsg(struct syscallrecord *rec)
 {
+struct socketinfo *si = (struct socketinfo *) rec->a1;
 struct msghdr *msg;
 struct sockaddr *sa = NULL;
 socklen_t salen;
 static void sanitise_sendmsg(struct syscallrecord *rec)
 
 msg = zmalloc(sizeof(struct msghdr));
 
-generate_sockaddr((struct sockaddr **) &sa, (socklen_t *) &salen, rnd() % TRINITY_PF_MAX);
+generate_sockaddr((struct sockaddr **) &sa, (socklen_t *) &salen, si->triplet.family);
 
 msg->msg_name = sa;
 msg->msg_namelen = salen;
",140,10
"perf_event_open fix unexpected char warning

The perf_event_open code parses some files under /sys
There are some hex values there, traditionally these were all lowercase
but on RaspberryPi2 machines for whatever reason they use uppercase.

This led to warnings like this:

 Unexpected char A
 Unexpected char D
 Unexpected char D
 Unexpected char B

Signed-off-by: Vince Weaver <vincent.weaver@maine.edu>"," static int parse_generic(int pmu, const char *value,
 if (value[ptr]==0) break;
 if (value[ptr]==',') break;
 if (! ( ((value[ptr]>='0') && (value[ptr]<='9'))
- || ((value[ptr]>='a') && (value[ptr]<='f'))) ) {
+|| ((value[ptr]>='a') && (value[ptr]<='f'))
+|| ((value[ptr]>='A') && (value[ptr]<='F'))) ) {
 outputerr(""Unexpected char %c\n"", value[ptr]);
 }
 temp*=base;
 if ((value[ptr]>='0') && (value[ptr]<='9')) {
 temp+=value[ptr]-'0';
 }
-else {
+else if ((value[ptr]>='a') && (value[ptr]<='f')) {
 temp+=(value[ptr]-'a')+10;
 }
+else {
+temp+=(value[ptr]-'A')+10;
+}
 i++;
 ptr++;
 }
",1087,271
fix uninitialized use of .type in socketcall,"
 
 static void socketcall_socket(unsigned long *args)
 {
-struct socket_triplet st;
+struct socket_triplet st = { .family = 0, .protocol = 0, .type = 0 };
 
 gen_socket_args(&st);
 
",46,4
"make sendmsg pass in more sensible iovecs

also the msg_flags arg is apparently ignored, so leave it 0 most the time"," static void sanitise_sendmsg(struct syscallrecord *rec)
 struct msghdr *msg;
 struct sockaddr *sa = NULL;
 socklen_t salen;
+unsigned int num_entries;
 
 rec->a1 = fd_from_socketinfo((struct socketinfo *) rec->a1);
 
 static void sanitise_sendmsg(struct syscallrecord *rec)
 msg->msg_name = sa;
 msg->msg_namelen = salen;
 
-msg->msg_iov = get_address();
-msg->msg_iovlen = get_len();
+num_entries = RAND_RANGE(1, 256);
+msg->msg_iov = alloc_iovec(num_entries);
+msg->msg_iovlen = num_entries;
+
 msg->msg_control = get_address();
-msg->msg_controllen = get_len();
-msg->msg_flags = rand32();
+msg->msg_controllen = rand32() % 20480;// /proc/sys/net/core/optmem_max
+if (ONE_IN(100))
+msg->msg_flags = rand32();
+else
+msg->msg_flags = 0;
 
 rec->a2 = (unsigned long) msg;
 }
 static void post_sendmsg(__unused__ struct syscallrecord *rec)
 struct msghdr *msg = (struct msghdr *) rec->a2;
 
 if (msg != NULL) {
+free(msg->msg_iov);
 free(msg->msg_name);// free sockaddr
 freeptr(&rec->a2);
 }
",146,11
fix -E to work when no -P is passed," static bool generate_sockets(void)
 /*
  * check if all domains are disabled.
  */
-for (i = 0; i < (int)ARRAY_SIZE(no_domains); i++)
-domains_disabled |= no_domains[i];
+for (i = 0; i < (int)ARRAY_SIZE(no_domains); i++) {
+if (no_domains[i] == FALSE) {
+domains_disabled = FALSE;
+break;
+} else {
+domains_disabled = TRUE;
+}
+}
 
 if (domains_disabled == TRUE) {
 output(0, ""All domains disabled!\n"");
 static bool generate_sockets(void)
 for (i = 0; i < TRINITY_PF_MAX; i++) {
 const struct netproto *proto = net_protocols[i].proto;
 
+if (no_domains[i] == TRUE)
+continue;
+
 /* check for ctrl-c again. */
 if (shm->exit_reason != STILL_RUNNING)
 goto out_unlock;
",376,83
"when comparing PF names, take the length into account."," static const struct domain *lookup_domain(const char *name)
 }
 
 for (i = 0; i < ARRAY_SIZE(domains); i++) {
+if (len != strlen(domains[i].name))
+continue;
 if (strncmp(name, domains[i].name, len) == 0)
 return &domains[i];
 }
",141,21
->generate for unix sockets," static void unix_rand_socket(struct socket_triplet *st)
 }
 }
 
+static void gen_unix(void)
+{
+generate_socket(PF_LOCAL, 0, SOCK_DGRAM);
+generate_socket(PF_LOCAL, 0, SOCK_SEQPACKET);
+generate_socket(PF_LOCAL, 0, SOCK_STREAM);
+}
+
 const struct netproto proto_unix = {
 .name = ""unix"",
 .socket = unix_rand_socket,
 .gen_sockaddr = unix_gen_sockaddr,
+.generate = gen_unix,
 };
",45,6
misc coverity warnings," static const char * get_proto_name(unsigned int family, unsigned int proto)
 break;
 }
 
-str = malloc(80);
-memset(str, 0, 80);
-sprintf(str, ""Unknown(%d)"", proto);
+str = calloc(1, 80);
+sprintf(str, ""Unknown(%u)"", proto);
 return str;
 }
 
 static const char *decode_type(unsigned int type)
 case SOCK_PACKET:
 return ""SOCK_PACKET"";
 }
-str = malloc(80);
-memset(str, 0, 80);
-sprintf(str, ""Unknown(%d)"", type);
+str = calloc(1, 80);
+sprintf(str, ""Unknown(%u)"", type);
 return str;
 }
 
 static void open_sockets(char *cachefilename)
 type = buffer[1];
 protocol = buffer[2];
 
-printf(""family:%s type:%s protocol:%s\n"",
+printf(""family:%s type:%s protocol:%s(%d)\n"",
 get_family_name(family),
 decode_type(type),
-get_proto_name(family, protocol), protocol);
+get_proto_name(family, protocol));
 nr_sockets++;
 
 }
",204,25
remove extraneous format string," static void open_sockets(char *cachefilename)
 type = buffer[1];
 protocol = buffer[2];
 
-printf(""family:%s type:%s protocol:%s(%d)\n"",
+printf(""family:%s type:%s protocol:%s\n"",
 get_family_name(family),
 decode_type(type),
 get_proto_name(family, protocol));
",204,25
"when we play with 1GB mappings, don't create so many children"," static void setup_mapping_sizes(void)
 mapping_sizes[3] = page_size;
 goto out_free;
 }
+} else {
+// Because of increased mem usage, don't do nr_cpus * 4
+max_children /= 4;
 }
 }
 
",91,13
cap the number of ARG_LIST options to at most 3," static unsigned long handle_arg_list(struct syscallentry *entry, unsigned int ar
 
 get_num_and_values(entry, argnum, &num, &values);
 
+if (RAND_BOOL())
+num = min(num, 3U);
+
 mask = set_rand_bitmask(num, values);
 return mask;
 }
",348,121
point alg->salg_name to a hash name if we choose hashes.," static const char *algos[] = {
 static void alg_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 {
 struct sockaddr_alg *alg;
+const char **algs = algos;
 unsigned int type;
 const char *types[] = { ""aead"", ""hash"", ""rng"", ""skcipher"", };
 unsigned int algo;
 static void alg_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 break;
 // hash
 case 1:algo = rnd() % ARRAY_SIZE(hashes);
+algs = hashes;
 break;
 // rng
 case 2:algo = rnd() % ARRAY_SIZE(algos);
 static void alg_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 break;
 default: unreachable();
 }
-strcpy((char *)alg->salg_name, algos[algo]);
+strcpy((char *)alg->salg_name, algs[algo]);
 
 alg->salg_feat = rand32();
 alg->salg_mask = rand32();
",245,6
sometimes make generate_sockaddr create a PF_UNSPEC sockaddr,"
 void generate_sockaddr(struct sockaddr **addr, socklen_t *addrlen, int pf)
 {
 const struct netproto *proto;
+struct sockaddr_un *un;
+
+
+if (RAND_BOOL()) {
+un = (struct sockaddr_un *) addr;
+if (un == NULL)
+un = zmalloc(sizeof(struct sockaddr_un));
+un->sun_family = PF_UNSPEC;
+return;
+}
 
 /* If we want sockets of a specific type, we'll want sockaddrs that match. */
 if (do_specific_domain == TRUE)
",35,7
Sometimes just do generic socket options instead of the per-proto ones.," void do_setsockopt(struct sockopt *so, struct socket_triplet *triplet)
 {
 so->optname = 0;
 
+/* Sometimes just do generic options */
+if (ONE_IN(10)) {
+socket_setsockopt(so, triplet);
+return;
+}
+
 /* get a page for the optval to live in.
  * TODO: push this down into the per-proto .func calls
  */
",158,27
->generate for PF_ALG," static void alg_setsockopt(struct sockopt *so, __unused__ struct socket_triplet
 so->level = SOL_ALG;
 }
 
+static void gen_alg(void)
+{
+generate_socket(PF_ALG, 0, SOCK_SEQPACKET);
+}
+
 const struct netproto proto_alg = {
 .name = ""alg"",
 //.socket = alg_rand_socket,
 .setsockopt = alg_setsockopt,
 .gen_sockaddr = alg_gen_sockaddr,
+.generate = gen_alg,
 };
 #endif
",250,7
->generate for PF_PACKET," static void packet_setsockopt(struct sockopt *so, __unused__ struct socket_tripl
 }
 }
 
+static void generate_packet_socket(void)
+{
+generate_socket(PF_PACKET, 768, SOCK_PACKET);
+generate_socket(PF_PACKET, 768, SOCK_RAW);
+}
+
 const struct netproto proto_packet = {
 .name = ""packet"",
 .socket = packet_rand_socket,
 .socket_setup = packet_socket_setup,
 .setsockopt = packet_setsockopt,
 .gen_sockaddr = packet_gen_sockaddr,
+.generate = generate_packet_socket,
 };
",97,14
->generate for PF_RDS," static void rds_setsockopt(struct sockopt *so, __unused__ struct socket_triplet
 so->optname = RAND_ARRAY(rds_opts);
 }
 
+static void generate_rds(void)
+{
+generate_socket(PF_RDS, 0, SOCK_SEQPACKET);
+}
+
 const struct netproto proto_rds = {
 .name = ""rds"",
 .socket = rds_rand_socket,
 .setsockopt = rds_setsockopt,
 .gen_sockaddr = rds_gen_sockaddr,
+.generate = generate_rds,
 };
 #else
 /* stub if we are built on something without RDS headers */
",46,5
->generate for PF_LLC," const struct netproto proto_llc = {
 .gen_sockaddr = llc_gen_sockaddr,
 };
 
+static void generate_llc(void)
+{
+generate_socket(PF_LLC, 0, SOCK_DGRAM);
+generate_socket(PF_LLC, 0, SOCK_STREAM);
+}
+
 const struct netproto proto_netbeui = {
 .name = ""netbeui"",
 .setsockopt = netbeui_setsockopt,
 .gen_sockaddr = llc_gen_sockaddr,
+.generate = generate_llc,
 };
",68,7
->generate for PF_PHONET," static void phonet_setsockopt(struct sockopt *so, __unused__ struct socket_tripl
 so->level = SOL_PNPIPE;
 }
 
+static void generate_phonet(void)
+{
+generate_socket(PF_PHONET, 0, SOCK_DGRAM);
+generate_socket(PF_PHONET, 0, SOCK_SEQPACKET);
+generate_socket(PF_PHONET, 1, SOCK_DGRAM);
+generate_socket(PF_PHONET, 2, SOCK_SEQPACKET);
+}
+
 const struct netproto proto_phonet = {
 .name = ""phonet"",
 .socket = phonet_rand_socket,
 .setsockopt = phonet_setsockopt,
 .gen_sockaddr = phonet_gen_sockaddr,
+.generate = generate_phonet,
 };
",47,5
->generate for PF_TIPC," static void tipc_setsockopt(struct sockopt *so, __unused__ struct socket_triplet
 so->optlen = sizeof(__u32);
 }
 
+static void generate_tipc(void)
+{
+generate_socket(PF_TIPC, 0, SOCK_DGRAM);
+generate_socket(PF_TIPC, 0, SOCK_SEQPACKET);
+generate_socket(PF_TIPC, 0, SOCK_STREAM);
+}
+
 const struct netproto proto_tipc = {
 .name = ""tipc"",
 .socket = tipc_rand_socket,
 .setsockopt = tipc_setsockopt,
 .gen_sockaddr = tipc_gen_sockaddr,
+.generate = generate_tipc,
 };
",64,7
->generate for PF_NETROM," static void netrom_setsockopt(struct sockopt *so, __unused__ struct socket_tripl
 so->optname = RAND_ARRAY(netrom_opts);
 }
 
+static void generate_netrom(void)
+{
+generate_socket(PF_NETROM, 0, SOCK_SEQPACKET);
+}
+
 const struct netproto proto_netrom = {
 .name = ""netrom"",
 //.socket = netrom_rand_socket,
 .setsockopt = netrom_setsockopt,
+.generate = generate_netrom,
 };
 #endif
",24,2
pass the UNSPEC sockaddr back up instead of just leaking it," void generate_sockaddr(struct sockaddr **addr, socklen_t *addrlen, int pf)
 if (un == NULL)
 un = zmalloc(sizeof(struct sockaddr_un));
 un->sun_family = PF_UNSPEC;
+*addr = (struct sockaddr *) un;
+*addrlen = sizeof(struct sockaddr_un);
 return;
 }
 
",37,7
overwrite the correct pointer with the sockaddr," void generate_sockaddr(struct sockaddr **addr, socklen_t *addrlen, int pf)
 if (RAND_BOOL()) {
 struct sockaddr_un *un;
 
-un = (struct sockaddr_un *) addr;
+un = (struct sockaddr_un *) *addr;
 if (un == NULL)
 un = zmalloc(sizeof(struct sockaddr_un));
 un->sun_family = PF_UNSPEC;
",37,7
"Replace ->generate with lists of valid socket triplets

These can be shared between the 'generate fds' code as well as indirectly
from ->socket calls (tbd)

Currently lacks support for 'needs root' sockets."," static bool generate_sockets(void)
 
 for (i = 0; i < TRINITY_PF_MAX; i++) {
 const struct netproto *proto = net_protocols[i].proto;
+struct socket_triplet *triplets;
+unsigned int j;
 
 if (no_domains[i] == TRUE)
 continue;
 static bool generate_sockets(void)
 
 if (proto == NULL)
 continue;
-if (proto->generate == NULL)
+if (proto->nr_triplets == 0)
 continue;
 
-proto->generate();
+triplets = proto->valid_triplets;
+
+for (j = 0; j < proto->nr_triplets; j++) {
+generate_socket(triplets[j].family, triplets[j].protocol, triplets[j].type);
+}
 }
 
-/* This is here temporarily until we have sufficient ->generate's */
+/* This is here temporarily until we have sufficient ->valid_proto's */
 while (nr_sockets < NR_SOCKET_FDS) {
 r = rnd() % TRINITY_PF_MAX;
 for (i = 0; i < 10; i++)
",381,84
"add support for privileged sockets to the socket generator.

Not super happy with this yet, but this is better than nothing for now."," static bool generate_sockets(void)
 continue;
 
 triplets = proto->valid_triplets;
+for (j = 0; j < proto->nr_triplets; j++)
+generate_socket(triplets[j].family, triplets[j].protocol, triplets[j].type);
+
+if (proto->nr_privileged_triplets == 0)
+continue;
 
-for (j = 0; j < proto->nr_triplets; j++) {
+if (orig_uid != 0)
+continue;
+
+triplets = proto->valid_privileged_triplets;
+for (j = 0; j < proto->nr_triplets; j++)
 generate_socket(triplets[j].family, triplets[j].protocol, triplets[j].type);
-}
 }
 
 /* This is here temporarily until we have sufficient ->valid_proto's */
",387,87
use correct loop boundary for privileged sockets," static bool generate_sockets(void)
 continue;
 
 triplets = proto->valid_privileged_triplets;
-for (j = 0; j < proto->nr_triplets; j++)
+for (j = 0; j < proto->nr_privileged_triplets; j++)
 generate_socket(triplets[j].family, triplets[j].protocol, triplets[j].type);
 }
 
",387,87
add PF_DECnet socket triplets," static void decnet_setsockopt(struct sockopt *so, __unused__ struct socket_tripl
 // TODO: set optlen correctly
 }
 
+static struct socket_triplet decnet_triplets[] = {
+{ .family = PF_DECnet, .protocol = DNPROTO_NSP, .type = SOCK_SEQPACKET },
+{ .family = PF_DECnet, .protocol = DNPROTO_NSP, .type = SOCK_STREAM },
+};
+
 const struct netproto proto_decnet = {
 .name = ""decnet"",
 .socket = decnet_rand_socket,
 .setsockopt = decnet_setsockopt,
 .gen_sockaddr = decnet_gen_sockaddr,
+.valid_triplets = decnet_triplets,
+.nr_triplets = ARRAY_SIZE(decnet_triplets),
 };
",61,5
dummy entry for (dead) econet," static void econet_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 *addrlen = sizeof(struct sockaddr_ec);
 }
 
+static struct socket_triplet econet_triplet[] = {
+// total guess, doesn't matter, it's dead.
+{ .family = PF_ECONET, .protocol = 0, .type = SOCK_SEQPACKET },
+};
+
 const struct netproto proto_econet = {
 .name = ""econet"",
 .gen_sockaddr = econet_gen_sockaddr,
+.valid_triplets = econet_triplet,
+.nr_triplets = ARRAY_SIZE(econet_triplet),
 };
",32,1
add valid protos for PF_KCM,"
 #include ""net.h""
 #include ""random.h""
 #include ""utils.h""// RAND_ARRAY
+#include ""compat.h""
 
 #ifndef KCMPROTO_CONNECTED
 #define KCMPROTO_CONNECTED 0
 static void kcm_setsockopt(struct sockopt *so, __unused__ struct socket_triplet
 }
 }
 
+static struct socket_triplet kcm_triplets[] = {
+{ .family = PF_KCM, .protocol = KCMPROTO_CONNECTED, .type = SOCK_PACKET },
+{ .family = PF_KCM, .protocol = KCMPROTO_CONNECTED, .type = SOCK_DGRAM },
+};
+
 const struct netproto proto_kcm = {
 .name = ""kcm"",
 .socket = kcm_rand_socket,
 .setsockopt = kcm_setsockopt,
+.valid_triplets = kcm_triplets,
+.nr_triplets = ARRAY_SIZE(kcm_triplets),
 };
",47,4
add PF_X25 valid triplet," static void x25_setsockopt(struct sockopt *so, __unused__ struct socket_triplet
 so->optlen = sizeof(int);
 }
 
+static struct socket_triplet x25_triplet[] = {
+{ .family = PF_X25, .protocol = 0, .type = SOCK_SEQPACKET },
+};
+
 const struct netproto proto_x25 = {
 .name = ""x25"",
 .socket = x25_rand_socket,
 .setsockopt = x25_setsockopt,
 .gen_sockaddr = x25_gen_sockaddr,
+.valid_triplets = x25_triplet,
+.nr_triplets = ARRAY_SIZE(x25_triplet),
 };
",44,3
"remove ->socket

Use the triplets arrays instead.
Mucho code deletion."," static void atalk_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 *addrlen = sizeof(struct sockaddr_at);
 }
 
-static void atalk_rand_socket(struct socket_triplet *st)
-{
-if (RAND_BOOL()) {
-st->type = SOCK_DGRAM;
- st->protocol = 0;
- return;
-}
-
-st->protocol = rnd() % PROTO_MAX;
-st->type = SOCK_RAW;
-}
-
 static void atalk_setsockopt(struct sockopt *so, __unused__ struct socket_triplet *triplet)
 {
 so->level = SOL_ATALK;
 static struct socket_triplet atalk_triplets[] = {
 
 const struct netproto proto_appletalk = {
 .name = ""appletalk"",
-.socket = atalk_rand_socket,
 .setsockopt = atalk_setsockopt,
 .gen_sockaddr = atalk_gen_sockaddr,
 .valid_triplets = atalk_triplets,
",37,2
"Only do the max_children limiting once.

This was in a loop, which sent it to 0. Derp."," static void setup_mapping_sizes(void)
 mapping_sizes[3] = page_size;
 goto out_free;
 }
-} else {
-// Because of increased mem usage, don't do nr_cpus * 4
-max_children /= 4;
 }
 }
 
+// Because of increased mem usage, don't do nr_cpus * 4
+printf(""Limiting children from %u to %u\n"",
+max_children, max_children / 4);
+max_children /= 4;
+
 out_free:
 free(buffer);
 out_close:
",92,13
"fix generation of localhost addresses.

The main thing wrong here was that it was in host order, not network
order, so we were trying to send to 1.0.0.127. Oops.

Make things more readable by just referring to it in ascii."," static in_addr_t new_ipv4_addr(void)
 { ""224.0.0.0"", SLASH24 },/* multi-cast */
 { ""255.255.255.255"", SLASH32 },
 };
+const char localhost[] = ""127.0.0.1"";
 
-int entry = rnd() % ARRAY_SIZE(addresses);
-const char *p = addresses[entry].name;
+int entry;
+const char *p;
 
+/* 99% of the time, just do localhost. */
+if (!ONE_IN(100)) {
+inet_pton(AF_INET, localhost, &v4);
+return v4;
+}
+
+entry = rnd() % ARRAY_SIZE(addresses);
+p = addresses[entry].name;
 inet_pton(AF_INET, p, &v4);
 
 if (addresses[entry].classmask != SLASH32)
 in_addr_t random_ipv4_address(void)
 return previous_ip;
 }
 
-/* 90% of the time, just do localhost. */
-if (!(ONE_IN(10)))
-addr = 0x7f000001;
-else
-addr = new_ipv4_addr();
+addr = new_ipv4_addr();
 
 previous_ip = addr;
 ip_lifetime = 5;
",320,24
add option to dump errno distribution on exit,"
+#include <errno.h>
+#include ""log.h""
+#include ""stats.h""
+#include ""syscall.h""
+#include ""tables.h""
+
+static void dump_entry(const struct syscalltable *table, unsigned int i)
+{
+struct syscallentry *entry;
+unsigned int j;
+unsigned int total = 0;
+
+entry = table[i].entry;
+if (entry == NULL)
+return;
+
+for (j = 0; j < NR_ERRNOS; j++) {
+if (entry->errnos[j] != 0)
+total++;
+}
+
+if (total == 0)
+return;
+
+printf(""%s:\n"", entry->name);
+
+for (j = 0; j < NR_ERRNOS; j++) {
+if (entry->errnos[j] != 0) {
+printf("" %s: %d\n"", strerror(j), entry->errnos[j]);
+}
+}
+}
+
+void dump_stats(void)
+{
+unsigned int i;
+
+if (biarch == TRUE) {
+printf(""32bit:\n"");
+for_each_32bit_syscall(i) {
+dump_entry(syscalls_32bit, i);
+}
+printf(""64bit:\n"");
+for_each_64bit_syscall(i) {
+dump_entry(syscalls_64bit, i);
+}
+} else {
+for_each_syscall(i) {
+dump_entry(syscalls, i);
+}
+}
+}
",44,9
record/output the successes/failures per syscall," static void dump_entry(const struct syscalltable *table, unsigned int i)
 {
 struct syscallentry *entry;
 unsigned int j;
-unsigned int total = 0;
 
 entry = table[i].entry;
 if (entry == NULL)
 return;
 
-for (j = 0; j < NR_ERRNOS; j++) {
-if (entry->errnos[j] != 0)
-total++;
-}
-
-if (total == 0)
+if (entry->attempted == 0)
 return;
 
-printf(""%s:\n"", entry->name);
+printf(""%s: (attempted:%u. success:%u. failures:%u.\n"", entry->name, entry->attempted, entry->successes, entry->failures);
 
 for (j = 0; j < NR_ERRNOS; j++) {
 if (entry->errnos[j] != 0) {
",39,7
"change check for inactive children

Jan Stancek reported that he saw processes hanging without getting killed,
and this is the most probably reason. We were considering children
as inactive even if they were doing the syscall, so they were never getting
sent a SIGKILL.

Change the state comparison, and also widen the window that we spend
in 'BEFORE' up until right before the syscall."," static bool is_child_making_progress(struct childdata *child)
 if (trylock(&rec->lock) == FALSE)
 return TRUE;
 
-if (rec->state <= BEFORE) {
+if (rec->state < BEFORE) {
 unlock(&rec->lock);
 return TRUE;
 }
",585,132
"let the grandchild live for a second before we kill it.

When under load, we got into a situation where the fork/exec never
actually completed before we started sending kills."," static void __do_syscall(struct syscallrecord *rec)
 
 /* This is a special case for things like execve, which would replace our
 * child process with something unknown to us. We use a 'throwaway' process
- * to do the execve in, and let it run for a max of a seconds before we kill it
+ * to do the execve in, and let it run for a max of a second before we kill it
 */
 static void do_extrafork(struct syscallrecord *rec)
 {
 static void do_extrafork(struct syscallrecord *rec)
 }
 
 /* child */
+sleep(1);
 while (pid == 0) {
 int childstatus;
 
",175,34
small pause before repeated kills to grandchild," static void do_extrafork(struct syscallrecord *rec)
 pid = waitpid(extrapid, &childstatus, WUNTRACED | WCONTINUED | WNOHANG);
 if (pid_alive(extrapid) == TRUE)
 kill(extrapid, SIGKILL);
+usleep(1000);
 }
 shm->stats.successes++;
 }
",176,34
unify the stats update in handle_syscall_ret()," static void __do_syscall(struct syscallrecord *rec)
 rec->retval = ret;
 rec->state = AFTER;
 unlock(&rec->lock);
-
-if (IS_ERR(ret))
-shm->stats.failures++;
-else
-shm->stats.successes++;
 }
 
 /* This is a special case for things like execve, which would replace our
 static void do_extrafork(struct syscallrecord *rec)
 __do_syscall(rec);
 /* if this was for eg. an successful execve, we should never get here.
  * if it failed though... */
-shm->stats.failures++;
 _exit(EXIT_SUCCESS);
 }
 
 static void do_extrafork(struct syscallrecord *rec)
 kill(extrapid, SIGKILL);
 usleep(1000);
 }
-shm->stats.successes++;
 }
 
 
 void handle_syscall_ret(struct syscallrecord *rec)
 } else {
 printf(""errno out of range: %d:%s\n"", err, strerror(err));
 }
+shm->stats.failures++;
 }
 } else {
 handle_success(rec);// Believe me folks, you'll never get bored with winning
 entry->successes++;
+shm->stats.successes++;
 }
 entry->attempted++;
 
",172,33
"count syscall attempts before, not after the syscall."," static void __do_syscall(struct syscallrecord *rec, enum syscallstate state)
 
 errno = 0;
 
+shm->stats.op_count++;
+
 if (dry_run == FALSE) {
 int nr, call;
 bool needalarm;
 static void __do_syscall(struct syscallrecord *rec, enum syscallstate state)
 (void)alarm(0);
 }
 
-/* We returned! */
-shm->stats.op_count++;
-
 lock(&rec->lock);
 rec->errno_post = errno;
 rec->retval = ret;
",171,33
add missing locking around state modification," static void __do_syscall(struct syscallrecord *rec, enum syscallstate state)
 if (needalarm)
 (void)alarm(1);
 
+lock(&rec->lock);
 rec->state = state;
+unlock(&rec->lock);
 
 if (rec->do32bit == FALSE) {
 ret = syscall(call, rec->a1, rec->a2, rec->a3, rec->a4, rec->a5, rec->a6);
",173,33
skip the sleep if the grandchild has already exited.," static void do_extrafork(struct syscallrecord *rec)
 return;
 }
 
-/* child */
-sleep(1);
+/* small pause to let grandchild do some work. */
+if (pid_alive(extrapid) == TRUE)
+sleep(1);
+
 while (pid == 0) {
 int childstatus;
 
",174,34
reduce the amount of time we wait for the grandchild a little," static void do_extrafork(struct syscallrecord *rec)
 
 /* small pause to let grandchild do some work. */
 if (pid_alive(extrapid) == TRUE)
-sleep(1);
+usleep(100);
 
 while (pid == 0) {
 int childstatus;
",174,34
make enable_random_syscalls static," void display_enabled_syscalls(void)
 display_enabled_syscalls_uniarch();
 }
 
-void enable_random_syscalls(void)
+static void enable_random_syscalls(void)
 {
 unsigned int i;
 
",493,137
fix up some segfaults when --disable-fds=sockets is passed.," static void sanitise_send(struct syscallrecord *rec)
 
 rec->a1 = fd_from_socketinfo(si);
 
+if (si == NULL)// handle --disable-fds=sockets
+goto skip_si;
+
 proto = net_protocols[si->triplet.family].proto;
 if (proto != NULL) {
 if (proto->gen_packet != NULL) {
 static void sanitise_send(struct syscallrecord *rec)
 }
 }
 
+skip_si:
+
 /* The rest of this function is only used as a fallback, if the per-proto
  * send()'s aren't implemented.
  */
 static void sanitise_sendmsg(struct syscallrecord *rec)
 struct sockaddr *sa = NULL;
 socklen_t salen;
 
+if (si == NULL)// handle --disable-fds=sockets
+goto skip_si;
+
 rec->a1 = fd_from_socketinfo((struct socketinfo *) rec->a1);
 
 generate_sockaddr((struct sockaddr **) &sa, (socklen_t *) &salen, si->triplet.family);
 
+skip_si:
 msg = zmalloc(sizeof(struct msghdr));
 msg->msg_name = sa;
 msg->msg_namelen = salen;
",159,16
correct the params for BPF_MAP_TYPE_STACK_TRACE creation," fail_progarray:
 output(2, ""fd[%d] = bpf perf event array\n"", fd);
 fail_perf_event_array:
 
-fd = bpf_create_map(BPF_MAP_TYPE_PERCPU_HASH, sizeof(long), sizeof(long), 1024, 0);
+fd = bpf_create_map(BPF_MAP_TYPE_PERCPU_HASH, sizeof(u32), sizeof(u64) * PERF_MAX_STACK_DEPTH, 10000, 0);
 if (fd < 0)
 goto fail_percpu_hash;
 obj = alloc_object();
",122,13
fix uninitialized var when run with --disable-fds=sockets," static void sanitise_sendmsg(struct syscallrecord *rec)
 struct socketinfo *si = (struct socketinfo *) rec->a1;
 struct msghdr *msg;
 struct sockaddr *sa = NULL;
-socklen_t salen;
+socklen_t salen = 0;
 
 if (si == NULL)// handle --disable-fds=sockets
 goto skip_si;
",159,16
"fill out the .k with rand32, so we get fd's etc in there.

This needs to be smarter, but this is better than rand() for now"," void bpf_gen_filter(unsigned long **addr, unsigned long *addrlen)
 bpf->filter[i].jf |= (uint8_t) rnd();
 
 /* Not always fill out k */
-bpf->filter[i].k = ((ONE_IN(10)) ? 0 : (uint32_t) rnd());
+bpf->filter[i].k = ((ONE_IN(10)) ? 0 : (uint32_t) rand32());
 
 /* Also try to jump into BPF extensions by chance */
 if (BPF_CLASS(bpf->filter[i].code) == BPF_LD ||
",659,131
open the testfiles multiple times with multiple modes,"
 #include ""testfile.h""
 #include ""utils.h""
 
-#define MAX_TESTFILE_FDS 4
+#define MAX_TESTFILES 4
+#define MAX_TESTFILE_FDS 20
 
 static void testfile_destructor(struct object *obj)
 {
 static int open_testfile(char *filename)
 static int open_testfile_fds(void)
 {
 char *filename;
-unsigned int i = 1;
+unsigned int i = 1, nr = 0;
 unsigned int fails = 0;
 
 filename = zmalloc(64);
 
-while (i <= MAX_TESTFILE_FDS) {
+while (nr < MAX_TESTFILE_FDS) {
 int fd;
 
 sprintf(filename, ""trinity-testfile%u"", i);
 static int open_testfile_fds(void)
 add_object(obj, OBJ_GLOBAL, OBJ_FD_TESTFILE);
 
 i++;
+if (i > MAX_TESTFILES)
+i = 1;
+nr++;
+
 fails = 0;
 
 mmap_fd(fd, filename, page_size, PROT_READ|PROT_WRITE, OBJ_GLOBAL, OBJ_MMAP_TESTFILE);
",93,12
add pkey_mprotect stub," struct syscallentry syscall_mprotect = {
 .group = GROUP_VM,
 .post = post_mprotect,
 };
+
+struct syscallentry syscall_pkey_mprotect = {
+.name = ""pkey_mprotect"",
+.num_args = 4,
+.arg1name = ""start"",
+.arg1type = ARG_MMAP,
+.arg2name = ""len"",
+.arg3name = ""prot"",
+.arg3type = ARG_LIST,
+.arg3list = ARGLIST(mprotect_prots),
+.arg4name = ""key"",
+.sanitise = sanitise_mprotect,
+.group = GROUP_VM,
+.post = post_mprotect,
+};
",50,3
add pkey alloc/free syscall stubs,"
+/*
+ * SYSCALL_DEFINE2(pkey_alloc, unsigned long, flags, unsigned long, init_val)
+ */
+
+#include ""sanitise.h""
+#include ""syscall.h""
+#include ""trinity.h""
+#include ""utils.h""
+
+#define PKEY_DISABLE_ACCESS 0x1
+#define PKEY_DISABLE_WRITE 0x2
+
+static unsigned long pkey_alloc_initvals[] = {
+PKEY_DISABLE_ACCESS,
+PKEY_DISABLE_WRITE,
+};
+
+static void sanitise_pkey_alloc(struct syscallrecord *rec)
+{
+// no flags defined right now.
+rec->a1 = 0;
+}
+
+struct syscallentry syscall_pkey_alloc = {
+.name = ""pkey_alloc"",
+.num_args = 2,
+.arg1name = ""flags"",
+.arg2name = ""init_val"",
+.arg2type = ARG_LIST,
+.arg2list = ARGLIST(pkey_alloc_initvals),
+.sanitise = sanitise_pkey_alloc,
+.group = GROUP_VM,
+};
+
+struct syscallentry syscall_pkey_free = {
+.name = ""pkey_free"",
+.num_args = 1,
+.arg1name = ""key"",
+.group = GROUP_VM,
+};
",28,1
"don't use rewind() on /proc/pid/stat

This seems to not do the right thing always.
The fseek is more explicit."," static char get_pid_state(struct childdata *child)
 if (getpid() != mainpid)
 BUG(""get_pid_state can only be called from main!\n"");
 
-rewind(child->pidstatfile);
+fseek(child->pidstatfile, 0L, SEEK_SET);
 if (getline(&line, &n, child->pidstatfile) != -1)
 sscanf(line, ""%d %s %c"", &pid, procname, &state);
 
",585,132
"Fix up segfaults when encountering null entries in syscall tables.

Triggered occasionally with -r"," void validate_specific_syscall(const struct syscalltable *table, int call)
 return;
 
 entry = table[call].entry;
+if (entry == NULL)
+return;
 
 if (entry->flags & AVOID_SYSCALL)
 output(0, ""%s is marked as AVOID. Skipping\n"", entry->name);
 int validate_specific_syscall_silent(const struct syscalltable *table, int call)
 return FALSE;
 
 entry = table[call].entry;
+if (entry == NULL)
+return FALSE;
 
 if (entry->flags & AVOID_SYSCALL)
 return FALSE;
",497,139
fix segfault in setsockopt() when called with --disable-fds=sockets," static void sanitise_setsockopt(struct syscallrecord *rec)
 struct socket_triplet *triplet = NULL;
 int fd;
 
+si = (struct socketinfo *) rec->a1;
+if (si == NULL) {
+rec->a1 = get_random_fd();
+rec->a4 = (unsigned long) zmalloc(page_size);
+return;
+}
+
 if (ONE_IN(1000)) {
 fd = get_random_fd();
 } else {
-si = (struct socketinfo *) rec->a1;
 fd = si->fd;
 triplet = &si->triplet;
 }
",163,28
add the 'special' ring-id's for keyctl,"
 * On success add_key() returns the serial number of the key it created or updated.
 * On error, the value -1 will be returned and errno will have been set to an appropriate error.
 */
+#include <linux/keyctl.h>
 #include ""random.h""
 #include ""sanitise.h""
 
 static void sanitise_add_key(struct syscallrecord *rec)
 rec->a1 = (unsigned long) RAND_ARRAY(keytypes);
 }
 
+static unsigned long addkey_ringids[] = {
+KEY_SPEC_THREAD_KEYRING,
+KEY_SPEC_PROCESS_KEYRING,
+KEY_SPEC_SESSION_KEYRING,
+KEY_SPEC_USER_KEYRING,
+KEY_SPEC_USER_SESSION_KEYRING,
+KEY_SPEC_GROUP_KEYRING,
+KEY_SPEC_REQKEY_AUTH_KEY,
+KEY_SPEC_REQUESTOR_KEYRING,
+};
+
 struct syscallentry syscall_add_key = {
 .name = ""add_key"",
 .num_args = 5,
 struct syscallentry syscall_add_key = {
 .arg4name = ""plen"",
 .arg4type = ARG_LEN,
 .arg5name = ""ringid"",
+.arg5type = ARG_OP,
+.arg5list = ARGLIST(addkey_ringids),
 .rettype = RET_KEY_SERIAL_T,
 .sanitise = sanitise_add_key,
 };
",37,1
generate random numbers in the -1..-10 range," unsigned short rand16(void)
 {
 unsigned short r = 0, r2;
 
-switch (rnd() % 5) {
+switch (rnd() % 6) {
 case 0:r = RAND_BYTE();
 break;
 
 unsigned short rand16(void)
 case 4:r2 = rnd() & 0xff;
 r = r2 | r2 << 8;
 break;
+case 5: return 0 - ((rnd() % 10) + 1);
 }
 
 /* Sometimes flip sign */
 unsigned int rand32(void)
 {
 unsigned long r = 0;
 
-switch (rnd() % 7) {
+switch (rnd() % 8) {
 case 0:r = RAND_BYTE();
 break;
 
 unsigned int rand32(void)
 break;
 
 case 6:return get_interesting_value();
+
+case 7: return 0 - ((rnd() % 10) + 1);
 }
 
 /* Sometimes deduct it from INT_MAX */
 u64 rand64(void)
 {
 u64 r = 0;
 
-switch (rnd() % 8) {
+switch (rnd() % 9) {
 
 /* 8-bit ranges */
 case 0:r = RAND_BYTE();
 u64 rand64(void)
 
 /* Sometimes pick a not-so-random number. */
 case 7:return get_interesting_value();
+
+// small 64bit negative number.
+case 8: return 0 - ((rnd() % 10) + 1);
 }
 
 /* limit the size */
",170,57
"remove the 'do syscall in a subchild' code for now.

This isn't doing anything useful other than adding overhead right now.
To be revisited post 1.7"," retry:
 return TRUE;
 }
 
+/*
 static bool do_syscall_in_child(struct syscallrecord *rec, struct childdata *child)
 {
 pid_t pid;
 static bool do_syscall_in_child(struct syscallrecord *rec, struct childdata *chi
 return FALSE;
 }
 }
+*/
 
 bool random_syscall(struct childdata *child)
 {
 bool random_syscall(struct childdata *child)
 stash = zmalloc(sizeof(struct syscallrecord));
 memcpy(stash, rec, sizeof(struct syscallrecord));
 
-
-if (RAND_BOOL()) {
+/*
+if (ONE_IN(100)) {
 if (do_syscall_in_child(rec, child) == FALSE)
 goto fail;
 } else
-do_syscall(rec);
+*/
+do_syscall(rec);
 
 check_sanity(rec, stash);
 
 bool random_syscall(struct childdata *child)
 handle_syscall_ret(rec);
 
 ret = TRUE;
-fail:
+//fail:
 free(stash);
 
 return ret;
",117,19
allow '0' as a file mode," static unsigned long handle_arg_mode_t(void)
 for (i = 0; i < count; i++) {
 unsigned int j;
 
-j = rnd() % 15;
+j = rnd() % 16;
 switch (j) {
 case 0: op = S_IRWXU; break;
 case 1: op = S_IRUSR; break;
",348,121
"fix off-by-one bugs in single page fault routines.

page offsets are 0-4095, so we don't need the extra subtraction."," static unsigned int nr_pages(struct map *map)
 static void read_one_page(struct map *map)
 {
 char *p = map->ptr;
-unsigned long offset = (rnd() % (map->size - 1)) & PAGE_MASK;
+unsigned long offset = (rnd() % map->size) & PAGE_MASK;
 char buf[page_size];
 
 p += offset;
",93,14
bpf: Fill out .k with a bpf map fd occasionally.,"
 #include <linux/unistd.h>
 #include <linux/perf_event.h>
 
+#include ""bpf.h""
 #include ""fd.h""
 #include ""log.h""
 #include ""objects.h""
 static int open_bpf_fds(void)
 return TRUE;
 }
 
-static int get_rand_bpf_fd(void)
+int get_rand_bpf_fd(void)
 {
 struct object *obj;
 
",93,8
"if we passed in a seed, don't generate new seeds from urandom/gtod"," static int fallbackseed(void)
 
 unsigned int new_seed(void)
 {
-unsigned int r;
+unsigned int r = 0;
+
+/* If we passed in an initial seed, all subsequent seeds have to
+ * be based off of it. */
+if (user_set_seed == TRUE) {
+r = rnd();
+goto out;
+}
 
-if (urandomfd == -1)
-return fallbackseed();
+if (urandomfd == -1) {
+r = fallbackseed();
+goto out;
+}
 
 if (read(urandomfd, &r, sizeof(r)) != sizeof(r))
-return fallbackseed();
+r = fallbackseed();
 
+out:
 //printf(""new seed:%u\n"", r);
 return r;
 }
",99,20
let children reseed (from rand()) when we pass in -s," void set_seed(struct childdata *child)
 * Called when a new child starts, so we don't repeat runs across different pids.
 * We only reseed in the main pid, all the children are expected to periodically
 * check if the seed changed, and reseed accordingly.
- *
- * Caveat: Not used if we passed in our own seed with -s
 */
 void reseed(void)
 {
 void reseed(void)
 exit(EXIT_FAILURE);
 }
 
-/* don't change the seed if we passed -s */
-if (user_set_seed == TRUE)
-return;
-
 /* We are reseeding. */
 shm->seed = new_seed();
 }
",97,19
"disable the mremap page-dirtying for now

This segfaults, and I'm not sure why yet. Disable for 1.7"," static void post_mremap(struct syscallrecord *rec)
 map->ptr = ptr;
 
 /* Sometimes dirty the mapping first. */
-if (RAND_BOOL())
-dirty_mapping(map);
+//if (RAND_BOOL())
+//dirty_mapping(map);
 }
 
 static unsigned long mremap_flags[] = {
",56,4
pick read/write dirtying based on PROT settings of mapping,"
 #include <stdlib.h>
 #include <string.h>
 #include <sys/mman.h>
+#include <asm/mman.h>
 #include <sys/types.h>
 #include <sys/stat.h>
 #include ""arch.h""
 struct map * common_set_mmap_ptr_len(void)
 */
 void dirty_mapping(struct map *map)
 {
-bool rw = RAND_BOOL();
-
-if (rw == TRUE) {
-/* Check mapping is writable, or we'll segv.
- * TODO: Perhaps we should do that, and trap it, mark it writable,
- * then reprotect after we dirtied it ? */
-if (map->prot & ~PROT_WRITE)
-return;
-
+switch (map->prot) {
+case PROT_WRITE:
+case PROT_WRITE|PROT_READ:
 random_map_writefn(map);
-return;
-
-} else {
-if (map->prot & ~PROT_READ)
-return;
-
+break;
+case PROT_READ:
 random_map_readfn(map);
+break;
+case PROT_SEM:
+case PROT_NONE:
+default:
+break;
 }
 }
 
",132,21
"for now disable periodic dirtying of mappings.

Another case where after some syscalls (mremap for eg) we segv.
Need to investigate further post 1.7"," static void periodic_work(void)
 check_parent_pid();
 
 /* Every 100 iterations. */
-if (!(periodic_counter % 100))
-dirty_random_mapping();
+//if (!(periodic_counter % 100))
+//dirty_random_mapping();
 
 if (periodic_counter == 1000)
 periodic_counter = 0;
",315,60
"Sanity checks in pid_alive

debug code that I've been carrying forever.
These should never fire any more, but they might be useful to have
in case I screw something up in the future.","
 #include ""sanitise.h""
 #include ""shm.h""
 
+#include <debug.h>
+
 pid_t *pids;
 
 bool pid_alive(pid_t pid)
 {
+if (pid < -1) {
+syslogf(""kill_pid tried to kill %d!\n"", pid);
+show_backtrace();
+return TRUE;
+}
+if (pid == -1) {
+syslogf(""kill_pid tried to kill -1!\n"");
+show_backtrace();
+return TRUE;
+}
+if (pid == 0) {
+syslogf(""tried to kill_pid 0!\n"");
+show_backtrace();
+return TRUE;
+}
+
 if (kill(pid, 0) == 0)
 return TRUE;
 return FALSE;
",154,35
"kill_pid debugging

like the pid_alive debugging, this may be useful to prevent some
future stupidity.","
 #include <stdlib.h>
 #include <stdio.h>
 #include <string.h>
+#include ""debug.h""
 #include ""log.h""
 #include ""pids.h""
 #include ""random.h""
 void kill_pid(pid_t pid)
 int ret;
 int childno;
 
+if (pid == -1) {
+show_backtrace();
+syslogf(""kill_pid tried to kill -1!\n"");
+return;
+}
+if (pid == 0) {
+show_backtrace();
+syslogf(""tried to kill_pid 0!\n"");
+return;
+}
+
 childno = find_childno(pid);
 if (childno != CHILD_NOT_FOUND) {
 if (shm->children[childno]->dontkillme == TRUE)
",84,17
"consolidate the seed initialization into init_seed

Reducing the number of places we check user_set_seed.

Bonus side-effect of not printing about getrandom() when we set a seed."," bool init_random(void)
 
 // If we have sys_getrandom, use that instead of urandom
 if (do_getrandom(&r) == TRUE) {
-printf(""Using getrandom() for seeds\n"");
 urandomfd = -1;
 return TRUE;
 }
 bool init_random(void)
 unsigned int init_seed(unsigned int seedparam)
 {
 if (user_set_seed == TRUE)
-output(0, ""Using user passed random seed: %u\n"", seedparam);
+output(0, ""Using user passed random seed: %u.\n"", seedparam);
 else {
+if (urandomfd == -1)
+output(0, ""Using getrandom() for seeds.\n"");
+else
+output(0, ""Using /dev/urandom for seeds.\n"");
+
 seedparam = new_seed();
 
 output(0, ""Initial random seed: %u\n"", seedparam);
",100,20
"fix build when USE_BPF is not defined

net/bpf.o: In function `bpf_gen_filter': bpf.c:852: undefined reference to `get_rand_bpf_fd'

Signed-off-by: Jan Stancek <jstancek@redhat.com>","
 #include <string.h>
 
 #include ""bpf.h""
+#include ""config.h""
 #include ""debug.h""
 #include ""log.h""
 #include ""net.h""

 #include ""utils.h""
 #include ""compat.h""
 
+#ifdef USE_BPF
 /**
 * BPF filters are used in networking such as in pf_packet, but also
 * in seccomp for application sand-boxing. Additionally, with arch
 void bpf_gen_filter(unsigned long **addr, unsigned long *addrlen)
 if (dump_bpf)
 bpf_disasm_all(bpf->filter, bpf->len);
 }
+#endif
",667,133
Some older distros apparently need types.h included here.,"
 #include <stdio.h>
 #include <linux/fs.h>
+#include <linux/types.h>
 
 #include <asm/ioctl.h>
 #include ""ioctls.h""
",68,2
Fix missing initializer warnings for older gcc's.," static int shm_is_corrupt(void)
 */
 void reap_child(struct childdata *child)
 {
-child->tp = (struct timespec){};
+child->tp = (struct timespec){ .tv_sec = 0, .tv_nsec = 0 };
 unlock(&child->syscall.lock);
 shm->running_childs--;
 pids[child->num] = EMPTY_PIDSLOT;
",585,132
"rework taint checking

* Move the mask checking into taint.c
* introduce is_tainted()
* rename check_tainted to get_taint()"," static void print_stats(void)
 
 void main_loop(void)
 {
-int ret = 0;
-
 fork_children();
 
 while (shm->exit_reason == STILL_RUNNING) {
 void main_loop(void)
 
 check_children_progressing();
 
-/* Only check taint if the mask allows it */
-if (kernel_taint_mask != 0) {
-ret = check_tainted();
-if (((ret & kernel_taint_mask) & (~kernel_taint_initial)) != 0)
-tainted_postmortem(ret);
-}
+if (is_tainted() == TRUE)
+tainted_postmortem();
 
 print_stats();
 
",581,131
"Add beginnings of ftrace work

This assumes you've already setup some ftrace tracing before
you started a trinity run.
When it detects that the kernel has become tainted, it shuts down
the tracer.

Right now it relies on you to copy the trace buffer somewhere safe etc.","
+#include <errno.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <string.h>
+#include <stdlib.h>
+
+#include ""ftrace.h""
+#include ""log.h""
+#include ""taint.h""
+
+static int trace_fd = -1;
+
+void setup_ftrace(void)
+{
+//todo: check for root
+trace_fd = open(""/sys/kernel/debug/tracing/tracing_on"", O_WRONLY);
+if (trace_fd == -1) {
+if (errno != -EEXIST) {
+output(0, ""Error opening tracing_on : %s\n"", strerror(errno));
+}
+}
+output(0, ""Opened ftrace tracing_on as fd %d\n"", trace_fd);
+}
+
+void stop_ftrace_if_tainted(void)
+{
+if (is_tainted() == TRUE) {
+if (trace_fd != -1) {
+if (write(trace_fd, ""0"", 1) == -1)
+output(0, ""Stopping ftrace failed! %s\n"", strerror(errno));
+close(trace_fd);
+trace_fd = -1;
+}
+}
+}
",30,7
"Fix -Wunused error

I try to build trinity for aarch64. In my configuration USE_PPPOL2TPIN6
is not defined, and it makes some functions have unused variables. GCC
treats it as error. This patch fixes it.

Signed-off-by: Yury Norov <ynorov@caviumnetworks.com>"," static int urandomfd;
 * to store what gets passed in from the command line -s argument */
 unsigned int seed = 0;
 
-static int do_getrandom(unsigned int *buf)
+static int do_getrandom(__unused__ unsigned int *buf)
 {
 #ifdef SYS_getrandom
 int ret;
",100,20
"reset tainted filepos to 0 before each read

Now that we keep the fd open across the lifetime of the run, we need
to reset it after we've read it"," int get_taint(void)
 if (taint_fd < 0)
 goto out;
 
+lseek(taint_fd, 0, SEEK_SET);
+
 ret = read(taint_fd, buffer, 10);
 
 if (ret > 0)
",108,27
"get_cpu type fixes

-1 needs us to return a signed int.
return INT_MAX as a possibility too
fallthrough to allow 0 to be a possible case.","
 #include <stdlib.h>
 #include <unistd.h>
 #include <string.h>
+#include <values.h>
 
 #include ""arch.h""
 #include ""debug.h""

 #include ""tables.h""
 #include ""trinity.h""// num_online_cpus
 
-static unsigned int get_cpu(void)
+static int get_cpu(void)
 {
 int i;
 i = rnd() % 100;
 static unsigned int get_cpu(void)
 switch (i) {
 case 0: return -1;
 case 1: return rnd() % 4096;
-case 2 ... 99:
+case 2: return INT_MAX;
+case 3 ... 98:
 return rnd() % num_online_cpus;
 }
 return 0;
",350,122
split stop_ftrace_if_tainted in two,"
 
 #include ""ftrace.h""
 #include ""log.h""
-#include ""taint.h""
 
 static int trace_fd = -1;
 
 void setup_ftrace(void)
 output(0, ""Opened ftrace tracing_on as fd %d\n"", trace_fd);
 }
 
-void stop_ftrace_if_tainted(void)
+void stop_ftrace(void)
 {
-if (is_tainted() == TRUE) {
-if (trace_fd != -1) {
-if (write(trace_fd, ""0"", 1) == -1)
-output(0, ""Stopping ftrace failed! %s\n"", strerror(errno));
-close(trace_fd);
-trace_fd = -1;
-}
+if (trace_fd != -1) {
+if (write(trace_fd, ""0"", 1) == -1)
+output(0, ""Stopping ftrace failed! %s\n"", strerror(errno));
+} else {
+output(0, ""trace_fd was %d\n"", trace_fd);
 }
 }
",27,6
replace duplicate code with taint_check helper," static void print_stats(void)
 }
 }
 
+
+static void taint_check(void)
+{
+if (is_tainted() == TRUE) {
+stop_ftrace();
+tainted_postmortem();
+}
+}
+
 void main_loop(void)
 {
 fork_children();
 void main_loop(void)
 
 handle_children();
 
-if (is_tainted() == TRUE) {
-stop_ftrace();
-tainted_postmortem();
-}
+taint_check();
 
 if (shm_is_corrupt() == TRUE)
 goto corrupt;
 void main_loop(void)
 
 /* Wait for all the children to exit. */
 while (shm->running_childs > 0) {
-if (is_tainted() == TRUE) {
-stop_ftrace();
-tainted_postmortem();
-}
+taint_check();
 
 handle_children();
 kill_all_kids();
",589,132
We only want to do the ftrace stop/postmortem once," static void print_stats(void)
 }
 }
 
+static bool handled_taint = FALSE;
 
 static void taint_check(void)
 {
+if (handled_taint == TRUE)
+return;
+
 if (is_tainted() == TRUE) {
 stop_ftrace();
 tainted_postmortem();
+handled_taint = TRUE;
 }
 }
 
",593,133
don't fall through if opening ftrace tracing_on fails," void setup_ftrace(void)
 if (trace_fd == -1) {
 if (errno != -EEXIST) {
 output(0, ""Error opening tracing_on : %s\n"", strerror(errno));
+return;
 }
 }
 output(0, ""Opened ftrace tracing_on as fd %d\n"", trace_fd);
",28,6
"similarly, if stopped ftrace fails, bail out after warning"," void setup_ftrace(void)
 void stop_ftrace(void)
 {
 if (trace_fd != -1) {
-if (write(trace_fd, ""0"", 1) == -1)
+if (write(trace_fd, ""0"", 1) == -1) {
 output(0, ""Stopping ftrace failed! %s\n"", strerror(errno));
+return;
+}
 } else {
 output(0, ""trace_fd was %d\n"", trace_fd);
 }
",30,6
"use userspace headers for ax25 instead of kernel.

This should solve https://bugzilla.redhat.com/show_bug.cgi?id=1400720","
 #include <sys/un.h>
 #include <netinet/in.h>
 #include <bits/sockaddr.h>
-#include <linux/ax25.h> /* for ax25_address in rose.h */
+#include <netax25/ax25.h> /* for ax25_address in rose.h */
 #include <netrose/rose.h>
 #include <stdlib.h>
 #include ""net.h""
",42,2
"move taint checking init to its own function

also explicitly cache the taint fd on startup"," int get_taint(void)
 
 buffer[10] = 0; //make sure that we can fit the whole int.
 
-if (taint_fd == 0)
-taint_fd = open(""/proc/sys/kernel/tainted"", O_RDONLY);
-
-if (taint_fd < 0)
-goto out;
-
 lseek(taint_fd, 0, SEEK_SET);
 
 ret = read(taint_fd, buffer, 10);
 int get_taint(void)
 /* We should never fail, but if we do, assume untainted. */
 ret = 0;
 }
-out:
+
 return ret;
 }
 
 void process_taint_arg(char *taintarg)
 }
 toggle_taint_flag_by_name(beg,end);
 }
+
+void init_taint_checking(void)
+{
+taint_fd = open(""/proc/sys/kernel/tainted"", O_RDONLY);
+
+kernel_taint_initial = get_taint();
+if (kernel_taint_initial != 0)
+output(0, ""Kernel was tainted on startup. Will ignore flags that are already set.\n"");
+}
",110,27
"greatly simplify the seeding code.

- only use /dev/urandom
There's really no benefit to getrandom().
- remove gtod fallback. urandom or gtfo.
- Only read from a high entropy source (urandom) once, and use
rnd() in subsequent new seeds. We don't know what other consumers
of urandom are on a system, so replaying the reseeding was difficult
or impossible depending on how busy the system was."," void init_shm(void)
 
 shm->seed = init_seed(seed);
 
-/* Set seed in main process. */
-set_seed(NULL);
-
 childptrslen = max_children * sizeof(struct childdata *);
 /* round up to page size */
 childptrslen += page_size - 1;
",52,4
ECHILD with child==-1 is boring," static void handle_child(int childno, pid_t childpid, int childstatus)
 unsigned int i;
 bool seen = FALSE;
 
+if (childpid == -1)
+break;
+
 debugf(""All children exited (childpid:%u)!\n"", childpid);
 
 for_each_child(i) {
",595,134
"remove the ECHILD handling completely.

It shouldn't be necessary any more."," static void handle_child(int childno, pid_t childpid, int childstatus)
 break;
 
 case -1:
-if (shm->exit_reason != STILL_RUNNING)
-return;
-
-if (errno == ECHILD) {
-unsigned int i;
-bool seen = FALSE;
-
-if (childpid == -1)
-break;
-
-debugf(""All children exited (childpid:%u)!\n"", childpid);
-
-for_each_child(i) {
-pid_t pid = pids[i];
-if (pid != EMPTY_PIDSLOT) {
-if (pid_alive(pid) == FALSE) {
-pids[i] = EMPTY_PIDSLOT;
-shm->running_childs--;
-replace_child(i);
-} else {
-debugf(""%d looks still alive! ignoring.\n"", pid);
-}
-seen = TRUE;
-}
-}
-if (seen == FALSE)
-shm->running_childs = 0;
-break;
-}
-output(0, ""error! (%s)\n"", strerror(errno));
 break;
 
 default:
",569,128
remove some off-by-one's in the -N handling," void init_shm(void)
 if (set_debug == TRUE)
 shm->debug = TRUE;
 
-shm->stats.op_count = 1;
+shm->stats.op_count = 0;
 
 shm->seed = init_seed(seed);
 
",52,4
don't reduce max number of children if < 4 specified," static void setup_mapping_sizes(void)
 
 
 // Because of increased mem usage, don't do nr_cpus * 4
-printf(""Limiting children from %u to %u\n"",
-max_children, max_children / 4);
-max_children /= 4;
-return;
+if (max_children > 4) {
+printf(""Limiting children from %u to %u\n"",
+max_children, max_children / 4);
+max_children /= 4;
+return;
+}
 
 disable_1gb_mappings:
 mapping_sizes[3] = page_size;
",104,16
add IP_RECVFRAGSIZE setsockopt," static const struct sock_option ip_opts[] = {
 { .name = IP_NODEFRAG, },
 { .name = IP_CHECKSUM, },
 { .name = IP_BIND_ADDRESS_NO_PORT, },
+{ .name = IP_RECVFRAGSIZE, },
 { .name = IP_MULTICAST_IF, .len = sizeof(struct ip_mreqn) },
 { .name = IP_MULTICAST_TTL, },
 { .name = IP_MULTICAST_LOOP, },
",321,24
"fix segfault in get_writable_address

we can call this before we've setup any shm objects."," retry:tries++;
 map->prot = PROT_READ | PROT_WRITE;
 } else {
 obj = get_random_object(OBJ_SYSV_SHM, OBJ_GLOBAL);
+if (obj == NULL)
+goto retry;
 if (obj->sysv_shm.size < size)
 goto retry;
 addr = obj->sysv_shm.ptr;
",95,25
optimize the case where we're dirtying a whole mapping.,"
 #include ""sanitise.h""// get_address
 #include ""utils.h""
 
+static bool mark_map_rw(struct map *map)
+{
+int ret;
+ret = mprotect(map->ptr, map->size, PROT_READ|PROT_WRITE);
+if (ret < 0)
+return FALSE;
+
+map->prot = PROT_READ|PROT_WRITE;
+return TRUE;
+}
+
 static bool mark_page_rw(struct map *map, void *page)
 {
 int ret;
 static void dirty_whole_mapping(struct map *map)
 {
 unsigned int i, nr;
 
+if (mark_map_rw(map) == FALSE)
+return;
+
 nr = nr_pages(map);
 
 for (i = 0; i < nr; i++) {
 char *p = map->ptr + (i * page_size);
-if (mark_page_rw(map, p) == TRUE)
-*p = rnd();
+*p = rnd();
 }
 }
 
",113,26
protocol is always unsigned.," static const struct ip_sso_funcptr ip_ssoptrs[IPPROTO_MAX] = {
 
 static void call_inet_sso_ptr(struct sockopt *so, struct socket_triplet *triplet)
 {
-int proto = triplet->protocol;
+unsigned int proto = triplet->protocol;
 
 /* we might have gotten here from a non-IP socket, (see setsockopt.c
  * Make sure we don't run past the end of the array above
",321,24
clear out any old state left in the postbuffer before we do a syscall.," bool random_syscall(struct childdata *child)
 if (set_syscall_nr(rec) == FAIL)
 return FAIL;
 
-/* Generate arguments, print them out */
+memset(rec->postbuffer, 0, POSTBUFFER_LEN);
 
+/* Generate arguments, print them out */
 generate_syscall_args(rec);
 
 output_syscall_prefix(rec);
",118,19
Correctly handle an error during initialization of fd providers," static void __open_fds(bool do_rand)
 provider->initialized = TRUE;
 num_fd_providers_initialized++;
 num_fd_providers_enabled++;
+} else {
+outputstd(""Error during initialization of %s\n"", provider->name);
+num_fd_providers_to_enable--;
 }
 }
 }
",163,29
Correctly handle commas in fd provider mask," void process_fds_param(char *param, bool enable)
  * validating them as we go.
  */
 for (i = 0; i < len; i++) {
-if (str[i] == ',') {
-str[i] = 0;
+if (str_orig[i] == ',') {
+str_orig[i] = 0;
 toggle_fds_param(str, enable);
 str = str_orig + i + 1;
 }
",163,29
Correctly handle failure to open the kernel taint file," int get_taint(void)
 unsigned int ret = 0;
 char buffer[11];
 
+/* Opening taint file had previously failed. Continue assuming untainted */
+if (taint_fd == -1)
+return 0;
+
 buffer[10] = 0; //make sure that we can fit the whole int.
 
 lseek(taint_fd, 0, SEEK_SET);
",112,28
generate_socket can be static," static unsigned int valid_proto(unsigned int family)
 return TRUE;
 }
 
-void generate_socket(unsigned int family, unsigned int protocol, unsigned int type)
+static void generate_socket(unsigned int family, unsigned int protocol, unsigned int type)
 {
 struct socket_triplet st;
 int fd;
",387,87
Fix --enable-fds bash list expansion bug," static unsigned int num_fd_providers;// num in list.
 static unsigned int num_fd_providers_to_enable = 0;// num of --fd-enable= params
 static unsigned int num_fd_providers_enabled = 0;// final num we enabled.
 static unsigned int num_fd_providers_initialized = 0;// num we called ->init on
+static bool enable_fd_initialized = FALSE;// initialized (disabled all) fd providers
 
 static struct fd_provider *fd_providers = NULL;
 
 void process_fds_param(char *param, bool enable)
 
 len = strlen(param);
 
-if (enable == TRUE) {
+if (enable_fd_initialized == FALSE && enable == TRUE) {
 struct list_head *node;
 
 /* First, pass through and mark everything disabled. */
 void process_fds_param(char *param, bool enable)
 provider = (struct fd_provider *) node;
 provider->enabled = FALSE;
 }
+enable_fd_initialized = TRUE;
 }
 
 /* Check if there are any commas. If so, split them into multiple params,
",165,30
open_socket can be static," static struct object * add_socket(int fd, unsigned int domain, unsigned int type
 return obj;
 }
 
-int open_socket(unsigned int domain, unsigned int type, unsigned int protocol)
+static int open_socket(unsigned int domain, unsigned int type, unsigned int protocol)
 {
 struct object *obj;
 struct sockaddr *sa = NULL;
",388,87
remove all the ANSI colour code stuff," void __BUG(const char *bugtxt, const char *filename, const char *funcname, unsig
 {
 struct childdata *child = this_child();
 
-printf(""BUG!: %s%s%s\n"", ANSI_RED, bugtxt, ANSI_RESET);
+printf(""BUG!: %s\n"", bugtxt);
 printf(""BUG!: %s\n"", VERSION);
 printf(""BUG!: [%d] %s:%s:%u\n"", getpid(), filename, funcname, lineno);
 
",109,15
remove all the 'log to disk' code.," void child_process(struct childdata *child, int childno)
 }
 
 out:
-shutdown_child_logging(child);
 
 debugf(""child %d %d exiting.\n"", childno, getpid());
 }
",314,60
Fix a rare double reap bug," static int shm_is_corrupt(void)
 */
 void reap_child(struct childdata *child)
 {
+/* Don't reap a child again */
+if( pids[child->num] == EMPTY_PIDSLOT )
+return;
 child->tp = (struct timespec){ .tv_sec = 0, .tv_nsec = 0 };
 unlock(&child->syscall.lock);
 shm->running_childs--;
",571,129
"btrfs/ioctl.h is not really needed

<linux/btrfs.h> has the ioctl definitions we want, so I see no reason for
checking for <btrfs/ioctl.h>.","
 #include ""config.h""
-#ifdef USE_BTRFS_IOCTL
+#ifdef USE_BTRFS
 #include <stdio.h>
 #include <linux/fs.h>
-
-#include <btrfs/ioctl.h>
+#include <linux/btrfs.h>
 #include ""ioctls.h""
 #include ""shm.h""
 #include ""utils.h""
 static const struct ioctl_group btrfs_grp = {
 };
 
 REG_IOCTL_GROUP(btrfs_grp)
-#endif /* USE_BTRFS_IOCTL */
+#endif /* USE_BTRFS */
",96,2
"do a flush after rewinding the pid stat file.

we can read stale data aparently without this."," static char get_pid_state(struct childdata *child)
 BUG(""get_pid_state can only be called from main!\n"");
 
 fseek(child->pidstatfile, 0L, SEEK_SET);
+fflush(child->pidstatfile);
+
 if (getline(&line, &n, child->pidstatfile) != -1)
 sscanf(line, ""%d %s %c"", &pid, procname, &state);
 
",572,129
don't set dropprivs if we start up without any.," void parse_args(int argc, char *argv[])
 break;
 
 case 'X':
-dropprivs = TRUE;
+if (getuid() == 0)
+dropprivs = TRUE;
+else
+outputstd(""Already running unprivileged, can't drop privs\n"");
 break;
 
 case 0:
",264,47
"if creation of a specific socket fails, bail out instead of retrying

otherwise we could get stuck in an infinite loop of EPERM"," static bool generate_sockets(void)
 lock_cachefile(F_WRLCK);
 
 if (do_specific_domain == TRUE) {
-while (nr_sockets < NR_SOCKET_FDS)
-ret |= generate_specific_socket(specific_domain);
+while (nr_sockets < NR_SOCKET_FDS) {
+ret = generate_specific_socket(specific_domain);
+
+if (ret == FALSE)
+return FALSE;
+}
 goto out_unlock;
 }
 
",391,88
"Add PF_KCM to domains list, so -E KCM works."," static const struct domain domains[] = {
 { ""ALG"",PF_ALG },
 { ""NFC"",PF_NFC },
 { ""VSOCK"",PF_VSOCK },
+{ ""KCM"",PF_KCM },
 };
 
 static const struct domain *lookup_domain(const char *name)
",142,21
"missing include, compile fix","
 #include <linux/icmp.h>
 #include ""net.h""
+#include ""trinity.h""
 
 void raw_setsockopt(struct sockopt *so, __unused__ struct socket_triplet *triplet)
 {
",7,1
remove some more leftover log-to-file code," static void oom_score_adj(int adj)
 void clean_childdata(struct childdata *child)
 {
 memset(&child->syscall, 0, sizeof(struct syscallrecord));
-child->logdirty = FALSE;
 child->seed = 0;
 child->kill_count = 0;
 child->dontkillme = FALSE;
 static bool handle_sigreturn(int sigwas)
 
 /* Check if we're blocked because we were stuck on an fd. */
 lock(&rec->lock);
-if (check_if_fd(child, rec) == TRUE) {
+if (check_if_fd(rec) == TRUE) {
 /* avoid doing it again from other threads. */
 shm->fd_lifetime = 0;
 
",313,60
"introduce some basic 'connect to udp server' code.

early days, but something to build on","
+#include <errno.h>
 #include <stdio.h>
 #include <stdarg.h>
 #include ""log.h""
-#include ""params.h""// logging, quiet_level
 #include ""pids.h""
-#include ""shm.h""
-#include ""trinity.h""
+#include ""params.h""// quiet_level
 
 #define BUFSIZE 1024// decoded syscall args are fprintf'd directly, this is for everything else.
 
 void outputstd(const char *fmt, ...)
 }
 
 
-// TODO: combine the below with output()
 void output_rendered_buffer(char *buffer)
 {
 /* Output to stdout only if -q param is not specified */
 void output_rendered_buffer(char *buffer)
 fflush(stdout);
 }
 }
-
-void init_logging(void)
-{
-}
-
-void shutdown_logging(void)
-{
-}
",59,10
"move output() and friends to trinity.h

step 1 of killing off log.h

This is used pretty much everywhere, so it makes sense to put it in
the 'everything' header."," static unsigned int render_syscall_postfix(struct syscallrecord *rec, char *buff
 }
 
 /* These next two functions are always called from child_random_syscalls() by a fuzzing child.
- * They render the buffer, and output it (to both stdout and logs).
+ * They render the buffer, and output it to stdout.
 * Other contexts (like post-mortem) directly use the buffers.
 */
 void output_syscall_prefix(struct syscallrecord *rec)
",153,40
log.c->output.c log.h->arg-decoder.h,"
 */
 #include <stdio.h>
 #include ""arch.h""//PAGE_MASK
-#include ""log.h""
+#include ""arg-decoder.h""
 #include ""params.h""// logging, quiet_level
 #include ""pids.h""
 #include ""shm.h""
",153,40
implement logging shutdown," void sendudp(char *buffer)
 
 void shutdown_logging(void)
 {
+if (logging_enabled == FALSE)
+return;
+
+close(logsocket);
 }
",68,10
make sendudp less fatal on failure," void sendudp(char *buffer)
 ret = sendto(logsocket, buffer, strlen(buffer) + 1, 0, (struct sockaddr *) &udpserver, sizeof(udpserver));
 if (ret == -1) {
 fprintf(stderr, ""sendto: %s\n"", strerror(errno));
-close(logsocket);
-exit(EXIT_FAILURE);
 }
 }
 
",66,10
"add ->dump member to objhead

this way objects.c doesn't need to know about every new kind of object."," static void bpf_destructor(struct object *obj)
 close(obj->bpf_map_fd);
 }
 
+static void bpf_map_dump(struct object *obj)
+{
+output(0, ""bpf map fd:%d\n"", obj->bpf_map_fd);
+}
+
 struct bpf_fd_types {
 u32 map_type;
 u32 key_size;
 static int open_bpf_fds(void)
 
 head = get_objhead(OBJ_GLOBAL, OBJ_FD_BPF_MAP);
 head->destroy = &bpf_destructor;
+head->dump = &bpf_map_dump;
 
 for (i = 0; i < ARRAY_SIZE(bpf_fds); i++) {
 struct object *obj;
",97,9
Add TCP_FASTOPEN_CONNECT," static const unsigned int tcp_opts[] = {
 TCP_THIN_DUPACK, TCP_USER_TIMEOUT, TCP_REPAIR, TCP_REPAIR_QUEUE,
 TCP_QUEUE_SEQ, TCP_REPAIR_OPTIONS, TCP_FASTOPEN, TCP_TIMESTAMP,
 TCP_NOTSENT_LOWAT, TCP_CC_INFO, TCP_SAVE_SYN, TCP_SAVED_SYN,
-TCP_REPAIR_WINDOW,
+TCP_REPAIR_WINDOW, TCP_FASTOPEN_CONNECT,
 };
 
 void tcp_setsockopt(struct sockopt *so, __unused__ struct socket_triplet *triplet)
",20,1
skeletal support for AF_QIPCRTR," static const struct domain domains[] = {
 { ""NFC"",PF_NFC },
 { ""VSOCK"",PF_VSOCK },
 { ""KCM"",PF_KCM },
+{ ""QIPCRTR"",PF_QIPCRTR },
 };
 
 static const struct domain *lookup_domain(const char *name)
",142,21
skeletal support for PF_SMC," static const struct domain domains[] = {
 { ""VSOCK"",PF_VSOCK },
 { ""KCM"",PF_KCM },
 { ""QIPCRTR"",PF_QIPCRTR },
+{ ""SMC"",PF_SMC },
 };
 
 static const struct domain *lookup_domain(const char *name)
",143,21
add RTNLGRP_MPLS_NETCONF," static void netlink_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 RTNLGRP_DECnet_RULE, RTNLGRP_NOP4, RTNLGRP_IPV6_PREFIX, RTNLGRP_IPV6_RULE,
 RTNLGRP_ND_USEROPT, RTNLGRP_PHONET_IFADDR, RTNLGRP_PHONET_ROUTE, RTNLGRP_DCB,
 RTNLGRP_IPV4_NETCONF, RTNLGRP_IPV6_NETCONF, RTNLGRP_MDB, RTNLGRP_MPLS_ROUTE,
-RTNLGRP_NSID,
+RTNLGRP_NSID, RTNLGRP_MPLS_NETCONF,
 };
 
 nl = zmalloc(sizeof(struct sockaddr_nl));
",80,2
remove unnecessary macro hell,"
 #include ""utils.h""// RAND_ARRAY
 #include ""compat.h""
 
-
-/* Current highest netlink socket. Supports some older kernels. */
-#ifdef NETLINK_CRYPTO
-#define _NETLINK_MAX NETLINK_CRYPTO
-#else
-#ifdef NETLINK_RDMA
-#define _NETLINK_MAX NETLINK_RDMA
-#else
-#define _NETLINK_MAX NETLINK_ECRYPTFS
-#endif /* NETLINK_RDMA */
-#endif /* NETLINK_CRYPTO */
-
 static void netlink_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 {
 struct sockaddr_nl *nl;
",80,2
Sometimes unshare various namespaces in child processes," static void init_child(struct childdata *child, int childno)
 mask_signals_child();
 
 disable_coredumps();
+
+if (RAND_BOOL()) {
+unshare(CLONE_NEWNS);
+unshare(CLONE_NEWIPC);
+unshare(CLONE_IO);
+unshare(CLONE_NEWNET);
+}
+
 /*
 if (shm->unshare_perm_err == FALSE) {
 if (RAND_BOOL()) {
",318,61
make iovec's with a single element half the time," static unsigned long handle_arg_iovec(struct syscallentry *entry, struct syscall
 {
 unsigned long num_entries;
 
-num_entries = RAND_RANGE(1, 256);
+if (RAND_BOOL())
+num_entries = 1;
+else
+num_entries = RAND_RANGE(1, 256);
 
 switch (argnum) {
 case 1:if (entry->arg2type == ARG_IOVECLEN)
",352,123
"set iovec lens to '20' half the time.

This is a magic arbitrary number, do something better later.
The case it's trying to improve is when we have a huge mapping,
and picking a rnd() amount of that mapping is still huge."," struct iovec * alloc_iovec(unsigned int num)
 struct map *map = get_map();
 
 iov[i].iov_base = map->ptr;
-iov[i].iov_len = rnd() % map->size;
+if (RAND_BOOL())
+iov[i].iov_len = 20;
+else
+iov[i].iov_len = rnd() % map->size;
 }
 
 return iov;
",97,26
add BPF_OBJ_PIN/BPF_OBJ_GET," static void bpf_prog_load(struct syscallrecord *rec, union bpf_attr *attr)
 rec->a3 = sizeof(attr);
 }
 
+#ifndef BPF_OBJ_PIN
+#define BPF_OBJ_PIN 6
+#define BPF_OBJ_GET 7
+#endif
+
 static void sanitise_bpf(struct syscallrecord *rec)
 {
 union bpf_attr *attr;
 static void sanitise_bpf(struct syscallrecord *rec)
 case BPF_MAP_UPDATE_ELEM:
 case BPF_MAP_DELETE_ELEM:
 case BPF_MAP_GET_NEXT_KEY:
+case BPF_OBJ_PIN:
+case BPF_OBJ_GET:
 attr->fd = get_rand_bpf_fd();
 attr->key = rnd();
 attr->value = rnd();
 static void sanitise_bpf(struct syscallrecord *rec)
 case BPF_PROG_LOAD:
 bpf_prog_load(rec, attr);
 break;
+
 default:
 break;
 }
 static void post_bpf(struct syscallrecord *rec)
 
 static unsigned long bpf_flags[] = {
 BPF_MAP_CREATE, BPF_MAP_LOOKUP_ELEM, BPF_MAP_UPDATE_ELEM, BPF_MAP_DELETE_ELEM,
-BPF_MAP_GET_NEXT_KEY, BPF_PROG_LOAD,
+BPF_MAP_GET_NEXT_KEY, BPF_PROG_LOAD, BPF_OBJ_PIN, BPF_OBJ_GET,
 };
 
 struct syscallentry syscall_bpf = {
",98,15
"bpf arg 1 is cmds, not flags"," static void post_bpf(struct syscallrecord *rec)
 freeptr(&rec->a2);
 }
 
-static unsigned long bpf_flags[] = {
+static unsigned long bpf_cmds[] = {
 BPF_MAP_CREATE, BPF_MAP_LOOKUP_ELEM, BPF_MAP_UPDATE_ELEM, BPF_MAP_DELETE_ELEM,
 BPF_MAP_GET_NEXT_KEY, BPF_PROG_LOAD, BPF_OBJ_PIN, BPF_OBJ_GET,
 };
 struct syscallentry syscall_bpf = {
 
 .arg1name = ""cmd"",
 .arg1type = ARG_OP,
-.arg1list = ARGLIST(bpf_flags),
+.arg1list = ARGLIST(bpf_cmds),
 .arg2name = ""uattr"",
 .arg3name = ""size"",
 .sanitise = sanitise_bpf,
",98,15
"always include config.h

Missing this include has caught me out a number of times, as we'll
silently fail ifdefs. Make it implicitly included.","
 * Various routines useful for debugging.
 */
 
-#include ""config.h""
 
 #ifdef USE_BACKTRACE
 #include <execinfo.h>
",107,15
bpf: set r2/r3 in all cases," static unsigned long bpf_prog_types[] = {
 
 static const char license[] = ""GPLv2"";
 
-static void bpf_prog_load(struct syscallrecord *rec, union bpf_attr *attr)
+static void bpf_prog_load(union bpf_attr *attr)
 {
 unsigned long *insns = NULL, len = 0;
 attr->prog_type = RAND_ARRAY(bpf_prog_types);
 static void bpf_prog_load(struct syscallrecord *rec, union bpf_attr *attr)
 attr->log_size = rnd() % page_size;
 attr->log_buf = (u64) get_writable_address(page_size);
 //attr->kern_version = TODO: stick uname in here.
-
-rec->a2 = (unsigned long) attr;
-rec->a3 = sizeof(attr);
 }
 
 #ifndef BPF_OBJ_PIN
 static void sanitise_bpf(struct syscallrecord *rec)
 union bpf_attr *attr;
 
 attr = zmalloc(sizeof(union bpf_attr));
+rec->a2 = (unsigned long) attr;
+rec->a3 = sizeof(*attr);
 
 switch (rec->a1) {
 case BPF_MAP_CREATE:
 static void sanitise_bpf(struct syscallrecord *rec)
 break;
 
 case BPF_PROG_LOAD:
-bpf_prog_load(rec, attr);
+bpf_prog_load(attr);
 break;
 
 default:
",99,15
"unused fields are already zeroed, as this is zmalloc'd"," static void sanitise_bpf(struct syscallrecord *rec)
 attr->map_fd = get_rand_bpf_fd();
 attr->key = rnd() % 1024;
 attr->value = rnd();
-attr->next_key = 0;
-attr->flags = 0;
 break;
 
 case BPF_MAP_UPDATE_ELEM:
 static void sanitise_bpf(struct syscallrecord *rec)
 case BPF_MAP_DELETE_ELEM:
 attr->map_fd = get_rand_bpf_fd();
 attr->key = rnd() % 1024;
-attr->value = 0;
-attr->next_key = 0;
-attr->flags = 0;
 break;
 
 case BPF_MAP_GET_NEXT_KEY:
 attr->map_fd = get_rand_bpf_fd();
 attr->key = rnd() % 1024;
 attr->value = rnd();
-attr->next_key = 0;
-attr->flags = 0;
 break;
 
 case BPF_OBJ_PIN:
 case BPF_OBJ_GET:
 attr->map_fd = get_rand_bpf_fd();
-attr->key = 0;
-attr->value = 0;
-attr->next_key = 0;
-attr->flags = 0;
 break;
 
 case BPF_PROG_LOAD:
",117,15
improve BPF_MAP_CREATE by setting reasonable types/size," struct bpf_fd_types {
 char name[32];
 };
 
-#ifndef BPF_MAP_TYPE_LRU_HASH
-#define BPF_MAP_TYPE_LRU_HASH 9
-#define BPF_MAP_TYPE_LRU_PERCPU_HASH 10
-#define BPF_MAP_TYPE_LPM_TRIE 11
-#endif
-#ifndef BPF_F_NO_COMMON_LRU
-#define BPF_F_NO_COMMON_LRU(1U << 1)
-#endif
-
-
+// TODO: Move to syscalls/bpf.c
 static struct bpf_fd_types bpf_fds[] = {
 { BPF_MAP_TYPE_HASH, sizeof(long long), sizeof(long long), 1024, 0, ""hash"" },
 { BPF_MAP_TYPE_ARRAY, sizeof(int), sizeof(long long), 256, 0, ""array"" },
",101,9
keep bpf keys in small range for now," static void sanitise_bpf(struct syscallrecord *rec)
 
 case BPF_MAP_LOOKUP_ELEM:
 attr->map_fd = get_rand_bpf_fd();
-attr->key = rnd() % 1024;
+attr->key = RAND_RANGE(0, 10);
 attr->value = rnd();
 break;
 
 case BPF_MAP_UPDATE_ELEM:
 attr->map_fd = get_rand_bpf_fd();
-attr->key = rnd() % 1024;
+attr->key = RAND_RANGE(0, 10);
 attr->value = rnd();
 attr->next_key = rnd();
 attr->flags = RAND_RANGE(0, 4);
 static void sanitise_bpf(struct syscallrecord *rec)
 
 case BPF_MAP_DELETE_ELEM:
 attr->map_fd = get_rand_bpf_fd();
-attr->key = rnd() % 1024;
+attr->key = RAND_RANGE(0, 10);
 break;
 
 case BPF_MAP_GET_NEXT_KEY:
 attr->map_fd = get_rand_bpf_fd();
-attr->key = rnd() % 1024;
+attr->key = RAND_RANGE(0, 10);
 attr->value = rnd();
 break;
 
",122,15
send a udp message to indicate main started,"
 #include ""tables.h""
 #include ""taint.h""
 #include ""trinity.h""
+#include ""udp.h""
 
 static void handle_child(int childno, pid_t childpid, int childstatus);
 
 static void taint_check(void)
 }
 }
 
+static void log_main_started(void)
+{
+struct mainstarted {
+pid_t pid;
+enum logmsgtypes type;
+unsigned int num_children;
+} msg;
+
+msg.pid = getpid();
+msg.type = MAIN_STARTED;
+msg.num_children = max_children;
+
+sendudp((char *) &msg, sizeof(msg));
+}
+
 void main_loop(void)
 {
+log_main_started();
+
 fork_children();
 
 while (shm->exit_reason == STILL_RUNNING) {
",579,127
have the logmsg type be the first byte," static void taint_check(void)
 static void log_main_started(void)
 {
 struct mainstarted {
-pid_t pid;
 enum logmsgtypes type;
+pid_t pid;
 unsigned int num_children;
 } msg;
 
",579,127
move the message struct definition to udp.h," static void taint_check(void)
 
 static void log_main_started(void)
 {
-struct mainstarted {
-enum logmsgtypes type;
-pid_t pid;
-unsigned int num_children;
-} msg;
+struct msg_mainstarted mainmsg;
 
-msg.pid = getpid();
-msg.type = MAIN_STARTED;
-msg.num_children = max_children;
+mainmsg.pid = getpid();
+mainmsg.type = MAIN_STARTED;
+mainmsg.num_children = max_children;
 
-sendudp((char *) &msg, sizeof(msg));
+sendudp((char *) &msg, sizeof(mainmsg));
 }
 
 void main_loop(void)
",575,127
fix missed variable replacement," static void log_main_started(void)
 mainmsg.type = MAIN_STARTED;
 mainmsg.num_children = max_children;
 
-sendudp((char *) &msg, sizeof(mainmsg));
+sendudp((char *) &mainmsg, sizeof(mainmsg));
 }
 
 void main_loop(void)
",575,127
don't hardcode protocol version in server side.,"
 #include ""trinity.h""
 #include ""types.h""
 #include ""udp.h""
+#include ""utils.h""
 
 #define MAXBUF 1024
 
 static size_t readudp(void)
 }
 
 /* simple 2-way handshake just to agree on protocol. */
-static const char hello[] = ""Trinity proto v1"";
+static const char hello[] = ""Trinity proto v"" __stringify(TRINITY_UDP_VERSION);
 static bool __handshake(void)
 {
-char reply[] = ""Trinity server v1. Go ahead"";
+char reply[] = ""Trinity server v"" __stringify(TRINITY_UDP_VERSION) "". Go ahead"";
 
 if (strncmp(buf, hello, strlen(hello)) != 0) {
 printf(""Incorrect message: %s\n"", buf);
",104,19
"move exit reasons to header

This will allow sharing between client/server"," enum exit_reasons {
 NUM_EXIT_REASONS = 17
 };
 
-const char * decode_exit(void);
+static const char *reasons[NUM_EXIT_REASONS] = {
+ ""Still running."",
+ ""No more syscalls enabled."",
+ ""Completed maximum number of operations."",
+ ""No file descriptors open."",
+ ""Lost track of a child."",
+ ""shm corruption - Found a pid out of range."",
+ ""ctrl-c"",
+ ""kernel became tainted."",
+ ""SHM was corrupted!"",
+ ""Child reparenting problem"",
+ ""No files in file list."",
+ ""Main process disappeared."",
+ ""UID changed."",
+ ""Something happened during fd init."",
+ ""fork() failure"",
+ ""some kind of locking catastrophe"",
+ ""error while opening logfiles"",
+};
+
+static inline const char * decode_exit(enum exit_reasons reason)
+{
+return reasons[reason];
+}
",44,1
shut down socket if handshake fails," void init_logging(char *optarg)
  */
 logging_enabled = TRUE;
 
-if (handshake() == FALSE)
+if (handshake() == FALSE) {
 logging_enabled = FALSE;
+close(logsocket);
+logsocket = -1;
+}
 }
 
 void shutdown_logging(void)
",100,15
add logging of main exiting," static void log_main_started(void)
 sendudp((char *) &mainmsg, sizeof(mainmsg));
 }
 
+static void log_main_exiting(void)
+{
+struct msg_mainexiting mainmsg;
+
+mainmsg.pid = getpid();
+mainmsg.type = MAIN_EXITING;
+mainmsg.reason = shm->exit_reason;
+
+sendudp((char *) &mainmsg, sizeof(mainmsg));
+}
+
 void main_loop(void)
 {
 log_main_started();
 corrupt:
 
 dont_wait:
 output(0, ""Bailing main loop because %s.\n"", decode_exit(shm->exit_reason));
+log_main_exiting();
 }
 
 
",561,127
add server decoding of main exiting,"
 #include <stdio.h>
 #include <stdlib.h>
 #include <unistd.h>
+#include ""exit.h""
 #include ""trinity.h""
 #include ""types.h""
 #include ""udp.h""
 static void decode_main_started(void)
 printf(""Main started. pid:%d number of children: %d\n"", mainmsg->pid, mainmsg->num_children);
 }
 
+static void decode_main_exiting(void)
+{
+struct msg_mainexiting *mainmsg;
+
+mainmsg = (struct msg_mainexiting *) &buf;
+printf(""Main exiting. pid:%d Reason: %s\n"", mainmsg->pid, decode_exit(mainmsg->reason));
+}
+
 int main(__unused__ int argc, __unused__ char* argv[])
 {
 int ret;
 int main(__unused__ int argc, __unused__ char* argv[])
 decode_main_started();
 break;
 
+case MAIN_EXITING:
+decode_main_exiting();
+break;
+
 default:
 /* Unknown command (yet). Just dump as hex. */
 printf(""rx %d bytes: "", ret);
",114,21
decode child started messages," static void decode_main_exiting(void)
 printf(""Main exiting. pid:%d Reason: %s\n"", mainmsg->pid, decode_exit(mainmsg->reason));
 }
 
+static void decode_child_spawned(void)
+{
+struct msg_childspawned *childmsg;
+
+childmsg = (struct msg_childspawned *) &buf;
+printf(""Child spawned. id:%d pid:%d\n"", childmsg->pid, childmsg->childno);
+}
+
 int main(__unused__ int argc, __unused__ char* argv[])
 {
 int ret;
 int main(__unused__ int argc, __unused__ char* argv[])
 decode_main_exiting();
 break;
 
+case CHILD_SPAWNED:
+decode_child_spawned();
+break;
+
 default:
 /* Unknown command (yet). Just dump as hex. */
 printf(""rx %d bytes: "", ret);
",123,23
log child signal messages," static void fork_children(void)
 shm->ready = TRUE;
 }
 
+static void log_child_signalled(int childno, pid_t pid, int sig)
+{
+struct msg_childsignalled childmsg;
+
+childmsg.pid = pid;
+childmsg.type = CHILD_SIGNALLED;
+childmsg.childno = childno;
+childmsg.sig = sig;
+
+sendudp((char *) &childmsg, sizeof(childmsg));
+}
+
 static void handle_childsig(int childno, int childstatus, bool stop)
 {
 struct childdata *child;
 static void handle_childsig(int childno, int childstatus, bool stop)
 if (stop == TRUE)
 debugf(""Child %d (pid %d) was stopped by %s\n"",
 childno, pid, strsignal(WSTOPSIG(childstatus)));
-else
+else {
 debugf(""got a signal from child %d (pid %d) (%s)\n"",
 childno, pid, strsignal(WTERMSIG(childstatus)));
+log_child_signalled(childno, pid, WTERMSIG(childstatus));
+}
 reap_child(shm->children[childno]);
 
 fclose(child->pidstatfile);
",581,129
decode child signal messages," static bool __handshake(void)
 char reply[] = ""Trinity server v"" __stringify(TRINITY_UDP_VERSION) "". Go ahead"";
 
 if (strncmp(buf, hello, strlen(hello)) != 0) {
-printf(""Incorrect message: %s\n"", buf);
+//printf(""Incorrect message: %s\n"", buf);
 return FALSE;
 }
 
 static void decode_child_exited(void)
 printf(""Child exited. id:%d pid:%d\n"", childmsg->pid, childmsg->childno);
 }
 
+static void decode_child_signalled(void)
+{
+struct msg_childsignalled *childmsg;
+
+childmsg = (struct msg_childsignalled *) &buf;
+printf(""Child signal. id:%d pid:%d signal: %s\n"",
+childmsg->pid, childmsg->childno, strsignal(childmsg->sig));
+}
+
 int main(__unused__ int argc, __unused__ char* argv[])
 {
 int ret;
 int main(__unused__ int argc, __unused__ char* argv[])
 decode_child_exited();
 break;
 
+case CHILD_SIGNALLED:
+decode_child_signalled();
+break;
+
 default:
 /* Unknown command (yet). Just dump as hex. */
 printf(""rx %d bytes: "", ret);
",141,27
remove old debugging message that now triggers all the time," static bool __handshake(void)
 {
 char reply[] = ""Trinity server v"" __stringify(TRINITY_UDP_VERSION) "". Go ahead"";
 
-if (strncmp(buf, hello, strlen(hello)) != 0) {
-//printf(""Incorrect message: %s\n"", buf);
+/* if we got here, we know we got a correct size message, but the contents
+ * need to match also for it to be a handshake.
+ */
+if (strncmp(buf, hello, strlen(hello)) != 0)
 return FALSE;
-}
 
 printf(""Handshake request. sending reply (%ld bytes)\n"", strlen(reply));
 
",139,23
"fail hard if we get passed '-l off'

I'll remove this in a few releases, but for now document it so people
know what's happening."," void parse_args(int argc, char *argv[])
 break;
 
 case 'l':
-outputerr(""-l currently does nothing. TBD.\n"");
+if (!strcmp(optarg, ""off"")) {
+outputerr(""The -l parameter has changed, and now takes a hostname as an argument. (logging is off by default now)\n"");
+exit(EXIT_FAILURE);
+}
 init_logging(optarg);
 break;
 
",263,47
"micro-optimize the 'became tainted' case.

don't bother reading /proc if some other process already did it."," int get_taint(void)
 return ret;
 }
 
+static bool became_tainted = FALSE;
+
 bool is_tainted(void)
 {
+/*
+ * Microoptimise the case where we became tainted. We don't need
+ * multiple reads of /proc.
+ */
+if (became_tainted == TRUE)
+return TRUE;
+
 /* Only check taint if the mask allows it */
 if (kernel_taint_mask != 0) {
 int ret = 0;
 
 ret = get_taint();
 if (((ret & kernel_taint_mask) & (~kernel_taint_initial)) != 0) {
+became_tainted = TRUE;
 return TRUE;
 }
 }
",116,29
"don't make locking failure fatal

this will always fail when run on nfsroot for eg."," static void lock_cachefile(int type)
 
 if (fcntl(cachefile, F_SETLKW, &fl) == -1) {
 perror(""fcntl F_SETLKW"");
-exit(EXIT_FAILURE);
+return;
 }
 
 if (verbose)
 static void unlock_cachefile(void)
 
 if (fcntl(cachefile, F_SETLK, &fl) == -1) {
 perror(""fcntl F_UNLCK F_SETLK "");
-exit(EXIT_FAILURE);
+return;
 }
 
 if (verbose)
",399,89
"export logging_enabled and use it appropriately

no point building structures we aren't going to send."," static void log_child_spawned(pid_t pid, int childno)
 {
 struct msg_childspawned childmsg;
 
+if (logging_enabled == FALSE)
+return;
+
 childmsg.pid = pid;
 childmsg.type = CHILD_SPAWNED;
 childmsg.childno = childno;
",330,63
fix off-by-one in ip proto selection," static void call_inet_sso_ptr(struct sockopt *so, struct socket_triplet *triplet
  * Make sure we don't run past the end of the array above
  * Don't adjust the actual triplet though, because it's what the real socket is.
  */
-if (proto > IPPROTO_MAX)
+if (proto >= IPPROTO_MAX)
 proto = rnd() % IPPROTO_MAX;
 
 if (ip_ssoptrs[proto].func != NULL) {
",320,24
error handling cleanups for ftrace," static void dump_trace(void)
 int tracein, traceout;
 ssize_t in = -1, out = -1;
 char buffer[4096];
+const char tracefile[] = ""/sys/kernel/debug/tracing/trace"";
 
-tracein = open(""/sys/kernel/debug/tracing/trace"", O_RDONLY);
+tracein = open(tracefile, O_RDONLY);
 if (tracein == -1) {
-if (errno != -EEXIST) {
-output(0, ""Error opening /sys/kernel/debug/tracing/trace : %s\n"", strerror(errno));
-return;
-}
+if (errno != -EEXIST)
+output(0, ""Error opening %s : %s\n"", tracefile, strerror(errno));
+return;
 }
 
 traceout = open(ftracedumpname, O_CREAT | O_WRONLY, 0600);
 static void dump_trace(void)
 goto fail;
 }
 }
-}
-if (in == -1) {
-output(0, ""something went wrong reading from trace. %s\n"", strerror(errno));
+
+if (in == -1) {
+output(0, ""something went wrong reading from trace. %s\n"", strerror(errno));
+goto fail;
+}
 }
 
 output(0, ""Dumped trace to %s\n"", ftracedumpname);
",72,14
"fix some ftrace resource leaks

we're exiting anyway after this, so no big deal, but it shuts coverity up."," static void dump_trace(void)
 if (tracein == -1) {
 if (errno != -EEXIST)
 output(0, ""Error opening %s : %s\n"", tracefile, strerror(errno));
-return;
+goto fail_tracein;
 }
 
 traceout = open(ftracedumpname, O_CREAT | O_WRONLY, 0600);
 if (traceout == -1) {
 output(0, ""Error opening %s : %s\n"", ftracedumpname, strerror(errno));
-return;
+goto fail_traceout;
 }
 
 while (in != 0) {
 static void dump_trace(void)
 fail:
 fsync(traceout);
 close(tracein);
+
+fail_traceout:
 close(traceout);
+fail_tracein:
+free((void *)ftracedumpname);
+ftracedumpname = NULL;
 }
 
 void setup_ftrace(void)
",76,14
log where the shm starts/end," static void log_main_started(void)
 mainmsg.pid = getpid();
 mainmsg.type = MAIN_STARTED;
 mainmsg.num_children = max_children;
+mainmsg.shm_begin = shm;
+mainmsg.shm_end = shm + shm_size - 1;
 
 sendudp((char *) &mainmsg, sizeof(mainmsg));
 }
",587,131
"remove dump_objects, and make add_object do the dumping.

When we start logging objects we want to do them at creation time,
instead of having to walk a list."," static int open_files(void)
 
 mmap_fd(fd, filename, sb.st_size, flags, OBJ_GLOBAL, OBJ_MMAP_FILE);
 }
-
-//dump_objects(OBJ_GLOBAL, OBJ_MMAP_ANON);
 return TRUE;
 }
 
",151,27
remove duplicate logging from epollfd creation," static int open_epoll_fds(void)
 obj = alloc_object();
 obj->epollfd = fd;
 add_object(obj, OBJ_GLOBAL, OBJ_FD_EPOLL);
-
-output(2, ""fd[%d] = epoll\n"", fd);
 i++;
 } else {
 /* not sure what happened. */
",60,8
remove duplicate logging from eventfd creation," static int open_eventfd_fds(void)
 obj = alloc_object();
 obj->eventfd = fd;
 add_object(obj, OBJ_GLOBAL, OBJ_FD_EVENTFD);
-
-output(2, ""fd[%d] = eventfd\n"", fd);
 }
 
 return TRUE;
",65,7
remove duplicate logging from timerfd creation," static int __open_timerfd_fds(int clockid)
 obj = alloc_object();
 obj->timerfd = fd;
 add_object(obj, OBJ_GLOBAL, OBJ_FD_TIMERFD);
-output(2, ""fd[%d] = timerfd\n"", fd);
 }
 return TRUE;
 }
",70,10
improve dump output for file fds," static int vfs_fd_test(int fd, const struct stat *st __attribute__((unused)))
 globallist = shm->global_objects[OBJ_FD_FILE].list;
 list_for_each(node, globallist) {
 obj = (struct object *) node;
-if (obj->filefd == fd)
+if (obj->fileobj.fd == fd)
 return 0;
 }
 
",89,4
only set up the pipe objhead once," static void pipefd_dump(struct object *obj)
 
 static void open_pipe_pair(unsigned int flags)
 {
-struct objhead *head;
 struct object *obj;
 int pipes[2];
 
-head = get_objhead(OBJ_GLOBAL, OBJ_FD_PIPE);
-head->destroy = &pipefd_destructor;
-head->dump = &pipefd_dump;
-
 if (pipe2(pipes, flags) < 0) {
 perror(""pipe fail.\n"");
 return;
 static void open_pipe_pair(unsigned int flags)
 
 static int open_pipes(void)
 {
+struct objhead *head;
+
+head = get_objhead(OBJ_GLOBAL, OBJ_FD_PIPE);
+head->destroy = &pipefd_destructor;
+head->dump = &pipefd_dump;
+
 open_pipe_pair(0);
 open_pipe_pair(O_NONBLOCK);
 open_pipe_pair(O_CLOEXEC);
",66,7
extend pipe object with additional info about creation," static int vfs_fd_test(int fd, const struct stat *st __attribute__((unused)))
 globallist = shm->global_objects[OBJ_FD_PIPE].list;
 list_for_each(node, globallist) {
 obj = (struct object *) node;
-if (obj->pipefd == fd)
+if (obj->pipeobj.fd == fd)
 return 0;
 }
 
",89,4
"perf fd destructor/dump were backwards.

wow.","
 
 static void perffd_destructor(struct object *obj)
 {
-output(0, ""perffd:%d\n"", obj->perffd);
+close(obj->perffd);
 }
 
 static void perffd_dump(struct object *obj)
 {
-close(obj->perffd);
+output(0, ""perffd:%d\n"", obj->perffd);
 }
 
 static int open_perf_fds(void)
",83,13
remove duplicate output from perf fd init," static void perffd_destructor(struct object *obj)
 
 static void perffd_dump(struct object *obj)
 {
-output(0, ""perffd:%d\n"", obj->perffd);
+output(0, ""perf fd: %d\n"", obj->perffd);
 }
 
 static int open_perf_fds(void)
 static int open_perf_fds(void)
 obj = alloc_object();
 obj->perffd = fd;
 add_object(obj, OBJ_GLOBAL, OBJ_FD_PERF);
-
-output(2, ""fd[%d] = perf\n"", fd);
 i++;
 
 /* any time we succeed, reset the failure counts.
",82,13
enhance testfile ->dump to log more info," static int btrfs_fd_test(int fd, const struct stat *st __attribute__((unused)))
 struct object *obj;
 
 obj = (struct object *) node;
-if (obj->testfilefd == fd)
+if (obj->testfileobj.fd == fd)
 return 0;
 }
 
",95,2
extended logging for epoll fd creation,"
 */
 #include ""objects.h""
 #include ""sanitise.h""
+#include ""tables.h""
 #include ""utils.h""
 
 static void post_epoll_create(struct syscallrecord *rec)
 {
 struct object *new;
+struct epollobj *eo;
 int fd = rec->retval;
 
 if (fd == -1)
 return;
 
 new = alloc_object();
-new->epollfd = fd;
+eo = &new->epollobj;
+eo->fd = fd;
+if (this_syscallname(""epoll_create1"")) {
+eo->create1 = TRUE;
+eo->flags = rec->a1;
+} else {
+eo->create1 = FALSE;
+eo->flags = 0;
+}
 add_object(new, OBJ_LOCAL, OBJ_FD_EPOLL);
 }
 
",43,3
fix cut-n-paste error in inotify syscall ->post," static void post_inotify_init(struct syscallrecord *rec)
 return;
 
 new = alloc_object();
-new->eventfd = fd;
+new->inotifyfd = fd;
 add_object(new, OBJ_LOCAL, OBJ_FD_INOTIFY);
 }
 
",33,2
extended logging for eventfd," static void post_eventfd_create(struct syscallrecord *rec)
 return;
 
 new = alloc_object();
-new->eventfd = fd;
+new->eventfdobj.fd = fd;
+new->eventfdobj.count = rec->a1;
+new->eventfdobj.flags = rec->a2;
 add_object(new, OBJ_LOCAL, OBJ_FD_EVENTFD);
 }
 
",39,2
quieten down the mm dumper," void map_dump(struct object *obj)
 
 m = &obj->map;
 sizeunit(m->size, buf);
-output(0, "" start: %p size:%s name: %s\n"", m->ptr, buf, m->name);
+output(2, "" start: %p size:%s name: %s\n"", m->ptr, buf, m->name);
 }
 
 /*
",144,22
"fix 'always true' comparison by hoisting declaration

the = NULL assignment each time around the loop
caused us to leak objects if we failed to open a testfile"," static void testfile_dump(struct object *obj)
 static int open_testfile(struct object *obj, char *filename)
 {
 int fd;
-int fcntl_flags;
 
 obj->testfileobj.filename = filename;
 
 static int open_testfile(struct object *obj, char *filename)
 
 fd = open_with_fopen(filename, O_RDWR);
 if (fd != -1) {
+int fcntl_flags;
+
 fcntl_flags = random_fcntl_setfl_flags();
 (void) fcntl(fd, F_SETFL, fcntl_flags);
 obj->testfileobj.fcntl_flags = fcntl_flags;
 static int open_testfile(struct object *obj, char *filename)
 static int open_testfile_fds(void)
 {
 struct objhead *head;
+struct object *obj = NULL;
 char *filename;
 unsigned int i = 1, nr = 0;
 unsigned int fails = 0;
 static int open_testfile_fds(void)
 filename = zmalloc(64);
 
 while (nr < MAX_TESTFILE_FDS) {
-struct object *obj = NULL;
 int fd;
 
 sprintf(filename, ""trinity-testfile%u"", i);
",106,13
fix leak of epoll object in failure path," static int open_epoll_fds(void)
 } else {
 /* not sure what happened. */
 output(0, ""open_epoll_fds fail: %s\n"", strerror(errno));
+free(obj);
 return FALSE;
 }
 }
",69,9
extended logging for timerfd objects,"
 
 static void timerfd_destructor(struct object *obj)
 {
-close(obj->timerfd);
+close(obj->timerfdobj.fd);
 }
 
 static void timerfd_dump(struct object *obj)
 {
-output(0, ""timerfd:%d\n"", obj->timerfd);
+struct timerfdobj *to = &obj->timerfdobj;
+
+output(0, ""timerfd fd:%d clockid:%d flags:%x\n"", to->fd, to->clockid, to->flags);
 }
 
 static int __open_timerfd_fds(int clockid)
 static int __open_timerfd_fds(int clockid)
 return FALSE;
 
 obj = alloc_object();
-obj->timerfd = fd;
+obj->timerfdobj.fd = fd;
+obj->timerfdobj.clockid = clockid;
+obj->timerfdobj.flags = flags[i];
 add_object(obj, OBJ_GLOBAL, OBJ_FD_TIMERFD);
 }
 return TRUE;
 static int get_rand_timerfd_fd(void)
 return -1;
 
 obj = get_random_object(OBJ_FD_TIMERFD, OBJ_GLOBAL);
-return obj->timerfd;
+return obj->timerfdobj.fd;
 }
 
 static const struct fd_provider timerfd_fd_provider = {
",73,10
extended logging for memfd objects," static int memfd_create(__unused__ const char *uname, __unused__ unsigned int fl
 
 static void memfd_destructor(struct object *obj)
 {
-close(obj->memfd);
+free(obj->memfdobj.name);
+close(obj->memfdobj.fd);
 }
 
 static void memfd_dump(struct object *obj)
 {
-output(0, ""memfd:%d\n"", obj->memfd);
+struct memfdobj *mo = &obj->memfdobj;
+
+output(0, ""memfd fd:%d name:%s flags:%x\n"", mo->fd, mo->name, mo->flags);
 }
 
 static int open_memfd_fds(void)
 static int open_memfd_fds(void)
 continue;
 
 obj = alloc_object();
-obj->memfd = fd;
+obj->memfdobj.fd = fd;
+obj->memfdobj.name = strdup(namestr);
+obj->memfdobj.flags = flags[i];
 add_object(obj, OBJ_GLOBAL, OBJ_FD_MEMFD);
-
-output(2, ""fd[%d] = memfd\n"", fd);
 }
 
 //FIXME: right now, returning FALSE means ""abort everything"", not
 static int get_rand_memfd_fd(void)
 return -1;
 
 obj = get_random_object(OBJ_FD_MEMFD, OBJ_GLOBAL);
-return obj->memfd;
+return obj->memfdobj.fd;
 }
 
 static const struct fd_provider memfd_fd_provider = {
",72,9
extended logging for inotify objects,"
 */
 #include ""objects.h""
 #include ""sanitise.h""
+#include ""tables.h""
 #include ""utils.h""
 
 static void post_inotify_init(struct syscallrecord *rec)
 static void post_inotify_init(struct syscallrecord *rec)
 return;
 
 new = alloc_object();
-new->inotifyfd = fd;
+new->inotifyobj.fd = fd;
+if (this_syscallname(""inotify_init1""))
+new->inotifyobj.flags = rec->a1;
+else
+new->inotifyobj.flags = 0;
 add_object(new, OBJ_LOCAL, OBJ_FD_INOTIFY);
 }
 
",38,3
extended logging for userfaultfd," static int userfaultfd_create(__unused__ unsigned int flag)
 
 static void userfaultfd_destructor(struct object *obj)
 {
-close(obj->userfaultfd);
+close(obj->userfaultobj.fd);
 }
 
 static void userfaultfd_dump(struct object *obj)
 {
-output(0, ""userfaultfd:%d\n"", obj->userfaultfd);
+struct userfaultobj *uo = &obj->userfaultobj;
+
+output(0, ""userfault fd:%d flags:%x\n"", uo->fd, uo->flags);
 }
 
 static int open_userfaultfds(void)
 static int open_userfaultfds(void)
 continue;
 
 obj = alloc_object();
-obj->userfaultfd = fd;
+obj->userfaultobj.fd = fd;
+obj->userfaultobj.flags = flags[i];
 add_object(obj, OBJ_GLOBAL, OBJ_FD_USERFAULTFD);
-
-output(2, ""fd[%d] = userfaultfd\n"", fd);
 }
 
 //FIXME: right now, returning FALSE means ""abort everything"", not
 static int get_rand_userfaultfd(void)
 return -1;
 
 obj = get_random_object(OBJ_FD_USERFAULTFD, OBJ_GLOBAL);
-return obj->userfaultfd;
+return obj->userfaultobj.fd;
 }
 
 static const struct fd_provider userfaultfd_provider = {
",69,9
fanotify object extended logging,"
 #include ""sanitise.h""
 #include ""utils.h""
 
-unsigned long fanotify_init_flags[] = {
+static unsigned long fanotify_init_flags[] = {
 FAN_CLOEXEC , FAN_NONBLOCK, FAN_UNLIMITED_QUEUE , FAN_UNLIMITED_MARKS,
 FAN_CLASS_NOTIF, FAN_CLASS_CONTENT, FAN_CLASS_PRE_CONTENT,
 };
",42,3
pass the global bool down to ->dump," static struct bpf_fd_types bpf_fds[] = {
 { BPF_MAP_TYPE_LPM_TRIE, 8, sizeof(long), 10000, 0, ""LPM TRIE"" },
 };
 
-static void bpf_map_dump(struct object *obj)
+static void bpf_map_dump(struct object *obj, __unused__ bool global)
 {
 u32 type = obj->bpfobj.map_type;
 
",102,9
move MAX_PATH_LEN to header," const char * get_filename(void)
 return fileindex[rnd() % files_in_index];
 }
 
-#define MAX_PATH_LEN 4096
-
 const char * generate_pathname(void)
 {
 const char *pathname = get_filename();
",224,54
log files opened over udp,"
 #include ""pathnames.h""
 #include ""random.h""
 #include ""syscalls/syscalls.h""
+#include ""udp.h""
 
 int open_with_fopen(const char *filename, int flags)
 {
 static void filefd_destructor(struct object *obj)
 close(obj->fileobj.fd);
 }
 
-static void filefd_dump(struct object *obj, __unused__ bool global)
+static void filefd_dump(struct object *obj, bool global)
 {
 struct fileobj *fo = &obj->fileobj;
+struct msg_objcreatedfile objmsg;
+int len = strlen(fo->filename);
+
+objmsg.type = OBJ_CREATED_FILE;
+objmsg.pid = getpid();
+objmsg.global = global;
+objmsg.address = obj;
+strncpy(objmsg.filename, fo->filename, len);
+memset(objmsg.filename + len, 0, MAX_PATH_LEN - len);
+objmsg.flags = fo->flags;
+objmsg.fd = fo->fd;
+objmsg.fopened = fo->fopened;
+objmsg.fcntl_flags = fo->fcntl_flags;
+sendudp((char *) &objmsg, sizeof(objmsg));
 
 output(0, ""file fd:%d filename:%s flags:%x fopened:%d fcntl_flags:%x\n"",
 fo->fd, fo->filename, fo->flags, fo->fopened, fo->fcntl_flags);
",159,23
drmfd dump needs to take the bool arg too.," static void drmfd_destructor(struct object *obj)
 close(obj->drmfd);
 }
 
-static void drmfd_dump(struct object *obj)
+static void drmfd_dump(struct object *obj, __unused__ bool global)
 {
 output(0, ""drmfd:%d\n"", obj->drmfd);
 }
",111,21
log and decode map objects," static void log_child_spawned(pid_t pid, int childno)
 if (logging_enabled == FALSE)
 return;
 
-childmsg.pid = pid;
-childmsg.type = CHILD_SPAWNED;
+childmsg.hdr.pid = pid;
+childmsg.hdr.type = CHILD_SPAWNED;
 childmsg.childno = childno;
 
 sendudp((char *) &childmsg, sizeof(childmsg));
",330,63
log & decode pipe objects,"
 #include ""sanitise.h""
 #include ""shm.h""
 #include ""trinity.h""
+#include ""udp.h""
 
 static void pipefd_destructor(struct object *obj)
 {
 close(obj->pipeobj.fd);
 }
 
-static void pipefd_dump(struct object *obj, __unused__ bool global)
+static void pipefd_dump(struct object *obj, bool global)
 {
 struct pipeobj *po = &obj->pipeobj;
+struct msg_objcreatedpipe objmsg;
 
 output(0, ""pipe fd:%d flags:%x [%s]\n"",
 po->fd, po->flags,
 po->reader ? ""reader"" : ""writer"");
+
+objmsg.hdr.type = OBJ_CREATED_PIPE;
+objmsg.hdr.pid = getpid();
+objmsg.hdr.global = global;
+objmsg.hdr.address = obj;
+objmsg.fd = po->fd;
+objmsg.flags = po->flags;
+objmsg.reader = po->reader;
+sendudp((char *) &objmsg, sizeof(objmsg));
 }
 
 static void open_pipe_pair(unsigned int flags)
",81,8
helper functions for msghdr init," static void filefd_dump(struct object *obj, bool global)
 struct msg_objcreatedfile objmsg;
 int len = strlen(fo->filename);
 
-objmsg.hdr.type = OBJ_CREATED_FILE;
-objmsg.hdr.pid = getpid();
-objmsg.hdr.global = global;
-objmsg.hdr.address = obj;
+init_msgobjhdr(&objmsg.hdr, OBJ_CREATED_FILE, global, obj);
 strncpy(objmsg.filename, fo->filename, len);
 memset(objmsg.filename + len, 0, MAX_PATH_LEN - len);
 objmsg.flags = fo->flags;
",156,23
convert map dump to use init_msgobjhdr," void map_dump(struct object *obj, bool global)
 
 m = &obj->map;
 
-objmsg.hdr.type = OBJ_CREATED_MAP;
-objmsg.hdr.pid = getpid();
-objmsg.hdr.global = global;
-objmsg.hdr.address = obj;
+init_msgobjhdr(&objmsg.hdr, OBJ_CREATED_MAP, global, obj);
 objmsg.start = m->ptr;
 len = strlen(m->name);
 strncpy(objmsg.name, m->name, len);
",156,22
use init_msghdr for MAIN_ messages," static void log_main_started(void)
 if (logging_enabled == FALSE)
 return;
 
-mainmsg.hdr.pid = getpid();
-mainmsg.hdr.type = MAIN_STARTED;
+init_msghdr(&mainmsg.hdr, MAIN_STARTED);
 mainmsg.num_children = max_children;
 mainmsg.shm_begin = shm;
 mainmsg.shm_end = shm + shm_size - 1;
 static void log_main_exiting(void)
 if (logging_enabled == FALSE)
 return;
 
-mainmsg.hdr.pid = getpid();
-mainmsg.hdr.type = MAIN_EXITING;
+init_msghdr(&mainmsg.hdr, MAIN_EXITING);
 mainmsg.reason = shm->exit_reason;
 
 sendudp((char *) &mainmsg, sizeof(mainmsg));
",585,131
add init_childmsghdr helper," static void log_child_signalled(int childno, pid_t pid, int sig)
 {
 struct msg_childsignalled childmsg;
 
-childmsg.hdr.pid = pid;
-childmsg.hdr.type = CHILD_SIGNALLED;
+init_childmsghdr(&childmsg.hdr, CHILD_SIGNALLED, pid);
 childmsg.childno = childno;
 childmsg.sig = sig;
 
 static void log_child_exited(pid_t pid, int childno)
 {
 struct msg_childexited childmsg;
 
-childmsg.hdr.pid = pid;
-childmsg.hdr.type = CHILD_EXITED;
+init_childmsghdr(&childmsg.hdr, CHILD_EXITED, pid);
 childmsg.childno = childno;
 
 sendudp((char *) &childmsg, sizeof(childmsg));
",583,131
log & decode epoll objects,"
 #include ""random.h""
 #include ""sanitise.h""
 #include ""shm.h""
+#include ""udp.h""
 
 #define MAX_EPOLL_FDS 10
 
 static void epoll_destructor(struct object *obj)
 static void epoll_dump(struct object *obj, __unused__ bool global)
 {
 struct epollobj *eo = &obj->epollobj;
+struct msg_objcreatedepoll objmsg;
 
 output(0, ""epoll fd:%d used create1?:%d flags:%x\n"", eo->fd, eo->create1, eo->flags);
+
+init_msgobjhdr(&objmsg.hdr, OBJ_CREATED_EPOLL, global, obj);
+objmsg.fd = eo->fd;
+objmsg.create1 = eo->create1;
+objmsg.flags = eo->flags;
+sendudp((char *) &objmsg, sizeof(objmsg));
 }
 
 static int open_epoll_fds(void)
",76,9
log & decode eventfd objects,"
 #include ""random.h""
 #include ""sanitise.h""
 #include ""shm.h""
+#include ""udp.h""
 #include ""compat.h""
 
 static void eventfd_destructor(struct object *obj)
 static void eventfd_destructor(struct object *obj)
 static void eventfd_dump(struct object *obj, __unused__ bool global)
 {
 struct eventfdobj *eo = &obj->eventfdobj;
+struct msg_objcreatedeventfd objmsg;
 
 output(0, ""eventfd fd:%d count:%d flags:%x\n"", eo->fd, eo->count, eo->flags);
+
+init_msgobjhdr(&objmsg.hdr, OBJ_CREATED_EVENTFD, global, obj);
+objmsg.fd = eo->fd;
+objmsg.count = eo->count;
+objmsg.flags = eo->flags;
+sendudp((char *) &objmsg, sizeof(objmsg));
 }
 
 static int open_eventfd_fds(void)
",76,7
log & decode timerfd objects,"
 #include ""sanitise.h""
 #include ""shm.h""
 #include ""compat.h""
+#include ""udp.h""
 
 static void timerfd_destructor(struct object *obj)
 {
 static void timerfd_destructor(struct object *obj)
 static void timerfd_dump(struct object *obj, __unused__ bool global)
 {
 struct timerfdobj *to = &obj->timerfdobj;
+struct msg_objcreatedtimerfd objmsg;
 
 output(0, ""timerfd fd:%d clockid:%d flags:%x\n"", to->fd, to->clockid, to->flags);
+
+init_msgobjhdr(&objmsg.hdr, OBJ_CREATED_TIMERFD, global, obj);
+objmsg.fd = to->fd;
+objmsg.clockid = to->clockid;
+objmsg.flags = to->flags;
+sendudp((char *) &objmsg, sizeof(objmsg));
 }
 
 static int __open_timerfd_fds(int clockid)
",80,10
log & decode testfile objects,"
 #include ""syscalls/syscalls.h""
 #include ""testfile.h""
 #include ""utils.h""
+#include ""udp.h""
 
 #define MAX_TESTFILES 4
 #define MAX_TESTFILE_FDS 20
 static void testfile_destructor(struct object *obj)
 static void testfile_dump(struct object *obj, __unused__ bool global)
 {
 struct fileobj *fo = &obj->testfileobj;
+struct msg_objcreatedfile objmsg;
+int len = strlen(fo->filename);
 
 output(0, ""testfile fd:%d filename:%s flags:%x fopened:%d fcntl_flags:%x\n"",
 fo->fd, fo->filename, fo->flags, fo->fopened, fo->fcntl_flags);
+
+init_msgobjhdr(&objmsg.hdr, OBJ_CREATED_TESTFILE, global, obj);
+strncpy(objmsg.filename, fo->filename, len);
+memset(objmsg.filename + len, 0, MAX_PATH_LEN - len);
+objmsg.flags = fo->flags;
+objmsg.fd = fo->fd;
+objmsg.fopened = fo->fopened;
+objmsg.fcntl_flags = fo->fcntl_flags;
+sendudp((char *) &objmsg, sizeof(objmsg));
 }
 
 static int open_testfile(struct object *obj, char *filename)
",117,13
log & decode memfd objects,"
 #include ""shm.h""
 #include ""compat.h""
 #include ""trinity.h""
+#include ""udp.h""
 
 static int memfd_create(__unused__ const char *uname, __unused__ unsigned int flag)
 {
 static void memfd_destructor(struct object *obj)
 static void memfd_dump(struct object *obj, __unused__ bool global)
 {
 struct memfdobj *mo = &obj->memfdobj;
+struct msg_objcreatedmemfd objmsg;
+int len;
 
 output(0, ""memfd fd:%d name:%s flags:%x\n"", mo->fd, mo->name, mo->flags);
+
+init_msgobjhdr(&objmsg.hdr, OBJ_CREATED_MEMFD, global, obj);
+objmsg.fd = mo->fd;
+len = strlen(mo->name);
+strncpy(objmsg.name, mo->name, len);
+objmsg.flags = mo->flags;
+sendudp((char *) &objmsg, sizeof(objmsg));
 }
 
 static int open_memfd_fds(void)
",81,9
log & decode drm objects,"
 #include <fcntl.h>
 #include <drm/drm.h>
 
+#include ""udp.h""
+
 static void drmfd_destructor(struct object *obj)
 {
 close(obj->drmfd);
 static void drmfd_destructor(struct object *obj)
 
 static void drmfd_dump(struct object *obj, __unused__ bool global)
 {
+struct msg_objcreateddrm objmsg;
+
 output(0, ""drmfd:%d\n"", obj->drmfd);
+
+init_msgobjhdr(&objmsg.hdr, OBJ_CREATED_DRM, global, obj);
+objmsg.fd = obj->drmfd;
+sendudp((char *) &objmsg, sizeof(objmsg));
 }
 
 static int create_dumb(__unused__ int fd)
",116,21
log & decode inotify objects,"
 #include ""random.h""
 #include ""sanitise.h""
 #include ""shm.h""
+#include ""udp.h""
 
 #define MAX_INOTIFY_FDS 5
 
 static void inotify_destructor(struct object *obj)
 static void inotify_dump(struct object *obj, __unused__ bool global)
 {
 struct inotifyobj *io = &obj->inotifyobj;
+struct msg_objcreatedinotify objmsg;
 
 output(0, ""inotify fd:%d flags:%x\n"", io->fd, io->flags);
+
+init_msgobjhdr(&objmsg.hdr, OBJ_CREATED_INOTIFY, global, obj);
+objmsg.fd = io->fd;
+objmsg.flags = io->flags;
+sendudp((char *) &objmsg, sizeof(objmsg));
 }
 
 static int open_inotify_fds(void)
",74,8
log & decode userfault objects,"
 #include ""shm.h""
 #include ""compat.h""
 #include ""trinity.h""
+#include ""udp.h""
 
 static int userfaultfd_create(__unused__ unsigned int flag)
 {
 static void userfaultfd_destructor(struct object *obj)
 static void userfaultfd_dump(struct object *obj, __unused__ bool global)
 {
 struct userfaultobj *uo = &obj->userfaultobj;
+struct msg_objcreateduserfault objmsg;
 
 output(0, ""userfault fd:%d flags:%x\n"", uo->fd, uo->flags);
+
+init_msgobjhdr(&objmsg.hdr, OBJ_CREATED_USERFAULT, global, obj);
+objmsg.fd = uo->fd;
+objmsg.flags = uo->flags;
+sendudp((char *) &objmsg, sizeof(objmsg));
 }
 
 static int open_userfaultfds(void)
",75,9
log & decode fanotify objects,"
 #include ""compat.h""
 #include ""trinity.h""
 #include ""utils.h""
+#include ""udp.h""
 
 #define NR_FANOTIFYFDS 10
 
 static void fanotifyfd_destructor(struct object *obj)
 static void fanotifyfd_dump(struct object *obj, __unused__ bool global)
 {
 struct fanotifyobj *fo = &obj->fanotifyobj;
+struct msg_objcreatedfanotify objmsg;
 
 output(0, ""fanotify fd:%d flags:%x eventflags:%x\n"",
 fo->fd, fo->flags, fo->eventflags);
+
+init_msgobjhdr(&objmsg.hdr, OBJ_CREATED_FANOTIFY, global, obj);
+objmsg.fd = fo->fd;
+objmsg.flags = fo->flags;
+objmsg.eventflags = fo->eventflags;
+sendudp((char *) &objmsg, sizeof(objmsg));
 }
 
 static int open_fanotify_fds(void)
",76,9
log & decode bpf map objects,"
 #include ""shm.h""
 #include ""compat.h""
 #include ""trinity.h""
+#include ""udp.h""
 
 static int bpf(int cmd, union bpf_attr *attr, unsigned int size)
 {
 static struct bpf_fd_types bpf_fds[] = {
 
 static void bpf_map_dump(struct object *obj, __unused__ bool global)
 {
+struct msg_objcreatedbpfmap objmsg;
 u32 type = obj->bpfobj.map_type;
 
 output(0, ""bpf map fd:%d type:%s\n"", obj->bpfobj.map_fd, &bpf_fds[type].name);
+
+init_msgobjhdr(&objmsg.hdr, OBJ_CREATED_BPFMAP, global, obj);
+objmsg.map_fd = obj->bpfobj.map_fd;
+objmsg.map_type = obj->bpfobj.map_type;
+sendudp((char *) &objmsg, sizeof(objmsg));
 }
 
 static int open_bpf_fds(void)
",108,9
log & decode socket objects,"
 #include ""sanitise.h""
 #include ""shm.h""
 #include ""trinity.h""
+#include ""udp.h""
 #include ""uid.h""
 #include ""utils.h""
 
 static void socket_destructor(struct object *obj)
 static void socket_dump(struct object *obj, __unused__ bool global)
 {
 struct socketinfo *si = &obj->sockinfo;
+struct msg_objcreatedsocket objmsg;
 
 output(0, ""socket fd:%d domain:%u (%s) type:0x%u protocol:%u\n"",
 si->fd, si->triplet.family, get_domain_name(si->triplet.family),
 si->triplet.type, si->triplet.protocol);
+
+init_msgobjhdr(&objmsg.hdr, OBJ_CREATED_SOCKET, global, obj);
+objmsg.si.fd = si->fd;
+objmsg.si.triplet.family = si->triplet.family;
+objmsg.si.triplet.type = si->triplet.type;
+objmsg.si.triplet.protocol = si->triplet.protocol;
+sendudp((char *) &objmsg, sizeof(objmsg));
 }
 
 static int open_sockets(void)
",403,88
log & decode futex objects," static void decode_obj_created_socket(void)
 objmsg->si.triplet.protocol);
 }
 
+static void decode_obj_created_futex(void)
+{
+struct msg_objcreatedfutex *objmsg;
+objmsg = (struct msg_objcreatedfutex *) &buf;
+
+printf(""%s futex object created at %p by pid %d: futex:%d owner:%d\n"",
+objmsg->hdr.global ? ""local"" : ""global"",
+objmsg->hdr.address, objmsg->hdr.pid,
+objmsg->futex, objmsg->owner);
+}
 
 const struct msgfunc decodefuncs[MAX_LOGMSGTYPE] = {
 [MAIN_STARTED] = { decode_main_started },
 const struct msgfunc decodefuncs[MAX_LOGMSGTYPE] = {
 [OBJ_CREATED_FANOTIFY] = { decode_obj_created_fanotify },
 [OBJ_CREATED_BPFMAP] = { decode_obj_created_bpfmap },
 [OBJ_CREATED_SOCKET] = { decode_obj_created_socket },
+[OBJ_CREATED_FUTEX] = { decode_obj_created_futex },
 };
",250,44
log & decode sysvshm objects," static void decode_obj_created_futex(void)
 objmsg->futex, objmsg->owner);
 }
 
+static void decode_obj_created_shm(void)
+{
+struct msg_objcreatedshm *objmsg;
+objmsg = (struct msg_objcreatedshm *) &buf;
+
+printf(""%s shm object created at %p by pid %d: id:%u size:%zu flags:%x ptr:%p\n"",
+objmsg->hdr.global ? ""local"" : ""global"",
+objmsg->hdr.address, objmsg->hdr.pid,
+objmsg->id, objmsg->size, objmsg->flags, objmsg->ptr);
+}
+
 const struct msgfunc decodefuncs[MAX_LOGMSGTYPE] = {
 [MAIN_STARTED] = { decode_main_started },
 [MAIN_EXITING] = { decode_main_exiting },
 const struct msgfunc decodefuncs[MAX_LOGMSGTYPE] = {
 [OBJ_CREATED_BPFMAP] = { decode_obj_created_bpfmap },
 [OBJ_CREATED_SOCKET] = { decode_obj_created_socket },
 [OBJ_CREATED_FUTEX] = { decode_obj_created_futex },
+[OBJ_CREATED_SHM] = { decode_obj_created_shm },
 };
",260,46
log & decode object destruction,"
 #include ""random.h""
 #include ""shm.h""
 #include ""trinity.h""
+#include ""udp.h""
 #include ""utils.h""
 
 struct object * alloc_object(void)
 bool objects_empty(enum objecttype type)
 void destroy_object(struct object *obj, bool global, enum objecttype type)
 {
 struct objhead *head;
+struct msg_objdestroyed objmsg;
+
+init_msgobjhdr(&objmsg.hdr, OBJ_DESTROYED, global, obj);
+sendudp((char *) &objmsg, sizeof(objmsg));
 
 list_del(&obj->list);
 
",149,29
pass the buffer down to the decode routines instead of using a global," struct sockaddr_in udpclient;
 
 int socketfd;
 
-char buf[MAXBUF];
+#define MAXBUF 10240
+static char buf[MAXBUF];
 
 void sendudp(char *buffer, size_t len)
 {
 int main(__unused__ int argc, __unused__ char* argv[])
 continue;
 }
 
-decodefuncs[type].func();
+decodefuncs[type].func((char *)&buf);
 }
 
 closeout:
",99,18
log which syscalls got enabled.," static void decode_obj_destroyed(char *buf)
 objmsg->hdr.type);
 }
 
+static void decode_syscalls_enabled(char *buf)
+{
+struct msg_syscallsenabled *scmsg;
+int nr;
+int i;
+
+scmsg = (struct msg_syscallsenabled *) buf;
+nr = scmsg->nr_enabled;
+if (scmsg->arch_is_biarch == TRUE) {
+printf(""Enabled %d %s bit syscalls : { "", nr, scmsg->is_64 ? ""64"" : ""32"");
+for (i = 0 ; i < nr; i++)
+printf(""%d "", scmsg->entries[i]);
+printf(""}\n"");
+} else {
+printf(""Enabled %d syscalls : { "", nr);
+for (i = 0 ; i < nr; i++)
+printf(""%d "", scmsg->entries[i]);
+printf(""}\n"");
+}
+}
+
 const struct msgfunc decodefuncs[MAX_LOGMSGTYPE] = {
 [MAIN_STARTED] = { decode_main_started },
 [MAIN_EXITING] = { decode_main_exiting },
 const struct msgfunc decodefuncs[MAX_LOGMSGTYPE] = {
 [OBJ_CREATED_FUTEX] = { decode_obj_created_futex },
 [OBJ_CREATED_SHM] = { decode_obj_created_shm },
 [OBJ_DESTROYED] = { decode_obj_destroyed },
+[SYSCALLS_ENABLED] = { decode_syscalls_enabled },
 };
",290,53
"add missing 'transmit and free udp packet' lines to uniarch table code.

missing cut-n-paste."," void log_enabled_syscalls_uniarch(void)
 continue;
 
 if (entry->flags & ACTIVE)
-entries[index++]= i;
+entries[index++] = i;
 }
+sendudp((char *) udpmsg, size);
+free(udpmsg);
 }
",155,30
"fix off-by-one in dump_childnos()

Fixes a segfault:

 ## pids: (60 active)
 0-7: 0 0 0 0 0 0 0 0
 8-15: 0 0 0 0 0 0 0 0
 16-23: 0 0 0 0 0 0 0 0
 24-31: 0 0 0 0 0 0 0 0
 32-39: 0 11081 11082 11083 11084 11085 11086 11087
 40-47: 11088 11089 11090 11091 11093 11094 11095 11096
 48-55: 11097 11098 11099 11100 11101 11102 0 0
 Segmentation fault"," void dump_childnos(void)
 for (j = 0; j < 8; j++) {
 struct childdata *child;
 
-if (i + j > max_children)
+if (i + j >= max_children)
 break;
 
 child = shm->children[i + j];
",150,33
"fix memory corruption in tables-uniarch:log_enabled_syscalls_uniarch

size change to (sizeof(int) * shm->nr_active_syscalls

Signed-off-by: Praveen K Pandey <praveen@linux.vnet.ibm.com>"," void log_enabled_syscalls_uniarch(void)
 unsigned int i, index = 0;
 unsigned int size;
 
-size = sizeof(struct msg_syscallsenabled) + shm->nr_active_syscalls;
+size = sizeof(struct msg_syscallsenabled) + (sizeof(int) * shm->nr_active_syscalls);
 udpmsg = zmalloc(size);
 init_msghdr(&udpmsg->hdr, SYSCALLS_ENABLED);
 udpmsg->nr_enabled = shm->nr_active_syscalls;
",155,30
todo: iterate fd provider list in help text," bool kernel_taint_param_occured = FALSE;
 
 void enable_disable_fd_usage(void)
 {
+//TODO: Build this dynamically
 outputerr("" --enable-fds/--disable-fds= {sockets,pipes,perf,epoll,eventfd,pseudo,timerfd,testfile,memfd,drm}\n"");
 }
 
",263,47
copy the ->dump method into the child object header," void init_object_lists(bool global)
 globalhead = get_objhead(OBJ_GLOBAL, i);
 head->max_entries = globalhead->max_entries;
 head->destroy = globalhead->destroy;
+head->dump = globalhead->dump;
 }
 }
 }
",150,29
remove a bunch of bogus __unused__ attributes," static struct bpf_fd_types bpf_fds[] = {
 { BPF_MAP_TYPE_LPM_TRIE, 8, sizeof(long), 10000, 0, ""LPM TRIE"" },
 };
 
-static void bpf_map_dump(struct object *obj, __unused__ bool global)
+static void bpf_map_dump(struct object *obj, bool global)
 {
 struct msg_objcreatedbpfmap objmsg;
 u32 type = obj->bpfobj.map_type;
",108,9
"if handshake fails, force a re-read from udp"," static void handshake(void)
 retry:while (ret != strlen(hello))
 ret = readudp();
 
-if (__handshake() == FALSE)
+if (__handshake() == FALSE) {
+ret = -1;
 goto retry;
+}
 }
 
 int main(__unused__ int argc, __unused__ char* argv[])
",101,18
introduce a trinity_msgchildhdr struct," static void log_child_spawned(pid_t pid, int childno)
 
 childmsg.hdr.pid = pid;
 childmsg.hdr.type = CHILD_SPAWNED;
-childmsg.childno = childno;
+childmsg.hdr.childno = childno;
 
 sendudp((char *) &childmsg, sizeof(childmsg));
 }
",330,63
log seed/reseed events," static void log_main_started(void)
 mainmsg.num_children = max_children;
 mainmsg.shm_begin = shm;
 mainmsg.shm_end = shm + shm_size - 1;
+mainmsg.initial_seed = shm->seed;
 
 sendudp((char *) &mainmsg, sizeof(mainmsg));
 }
",582,131
"fix infinite loop in main

If we reach max count, and send SIGKILL to a child process which had
set a lock to LOCKING, but hadn't set the lock owner yet, other children
which stumble across that lock get stuck.

Help those stuck children along a little with a SIGKILL."," void main_loop(void)
 if (shm_is_corrupt() == TRUE)
 goto corrupt;
 
-while (check_all_locks() == TRUE)
+while (check_all_locks() == TRUE) {
 reap_dead_kids();
+if (shm->exit_reason == EXIT_REACHED_COUNT)
+kill_all_kids();
+}
 
 if (syscalls_todo && (shm->stats.op_count >= syscalls_todo)) {
 output(0, ""Reached limit %d. Telling children to exit.\n"", syscalls_todo);
",585,132
don't spin on locks if we've already finished.," void lock(lock_t *_lock)
 if (pid == mainpid) {
 check_lock(_lock);
 } else {
-/* Ok, we're a child pid.
- * if something bad happened, like main crashed,
+/* Ok, we're a child pid. If we reached the limit, just exit */
+if (shm->exit_reason == EXIT_REACHED_COUNT)
+_exit(EXIT_SUCCESS);
+
+/* if something bad happened, like main crashed,
  * we don't want to spin forever, so just get out.
  */
-if ((shm->exit_reason != STILL_RUNNING) &&
- (shm->exit_reason != EXIT_REACHED_COUNT)) {
+if (shm->exit_reason != STILL_RUNNING)
 _exit(EXIT_FAILURE);
-}
+
 }
 
 usleep(1);
",87,19
split up the decode file,"
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <errno.h>
+#include <netdb.h>
+#include <string.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include ""decode.h""
+#include ""exit.h""
+#include ""socketinfo.h""
+#include ""trinity.h""
+#include ""types.h""
+#include ""udp.h""
+#include ""utils.h""
+
+void decode_child_spawned(char *buf)
+{
+struct msg_childspawned *childmsg;
+
+childmsg = (struct msg_childspawned *) buf;
+printf(""Child spawned. id:%d pid:%d\n"", childmsg->hdr.childno, childmsg->hdr.pid);
+}
+
+void decode_child_exited(char *buf)
+{
+struct msg_childexited *childmsg;
+
+childmsg = (struct msg_childexited *) buf;
+printf(""Child exited. id:%d pid:%d\n"", childmsg->hdr.childno, childmsg->hdr.pid);
+}
+
+void decode_child_signalled(char *buf)
+{
+struct msg_childsignalled *childmsg;
+
+childmsg = (struct msg_childsignalled *) buf;
+printf(""Child signal. id:%d pid:%d signal: %s\n"",
+childmsg->hdr.childno, childmsg->hdr.pid, strsignal(childmsg->sig));
+}
",34,3
do more dead child reaping when waiting for exit," void main_loop(void)
 /* Give children a chance to exit before retrying. */
 sleep(1);
 }
+reap_dead_kids();
 }
 
 corrupt:
",586,132
"rewrite the handshake code to pass a struct

We'll need to match up session creation (ie, a handshake) with a main
thread and it's number of children, so pass the relevant info in the
handshake request."," static void log_main_started(void)
 return;
 
 init_msghdr(&mainmsg.hdr, MAIN_STARTED);
-mainmsg.num_children = max_children;
 mainmsg.shm_begin = shm;
 mainmsg.shm_end = shm + shm_size - 1;
 mainmsg.initial_seed = shm->seed;
",585,132
num_children moved to the handshake message," void decode_main_started(char *buf)
 struct msg_mainstarted *mainmsg;
 
 mainmsg = (struct msg_mainstarted *) buf;
-printf(""Main started. pid:%d number of children: %d. shm:%p-%p initial seed: %u\n"",
-mainmsg->hdr.pid, mainmsg->num_children, mainmsg->shm_begin, mainmsg->shm_end,
+printf(""Main started. pid:%d shm:%p-%p initial seed: %u\n"",
+mainmsg->hdr.pid, mainmsg->shm_begin, mainmsg->shm_end,
 mainmsg->initial_seed);
 }
 
",35,3
make ->dump silent when running with -q," static void bpf_map_dump(struct object *obj, bool global)
 struct msg_objcreatedbpfmap objmsg;
 u32 type = obj->bpfobj.map_type;
 
-output(0, ""bpf map fd:%d type:%s\n"", obj->bpfobj.map_fd, &bpf_fds[type].name);
+output(2, ""bpf map fd:%d type:%s\n"", obj->bpfobj.map_fd, &bpf_fds[type].name);
 
 init_msgobjhdr(&objmsg.hdr, OBJ_CREATED_BPFMAP, global, obj);
 objmsg.map_fd = obj->bpfobj.map_fd;
",108,9
"initialize logging later.

We need to do this at least after all params are parsed, because things
like max_children can change based on which args we passed, and the
value in the handshake will be incorrect."," void parse_args(int argc, char *argv[])
 outputerr(""The -l parameter has changed, and now takes a hostname as an argument. (logging is off by default now)\n"");
 exit(EXIT_FAILURE);
 }
-init_logging(optarg);
+logging_args = strdup(optarg);
 break;
 
 case 'L':
",263,47
shut up cppcheck: scope reduction," static void queue_object_msg(struct trinity_msgobjhdr *obj, int len)
 
 static void * queue_packets(__unused__ void *data)
 {
-int ret;
 int len;
 enum logmsgtypes type;
 
 while (1) {
-ret = readudp();
+int ret = readudp();
 if (ret <= 0)
 continue;
 
",231,47
change decoders to return strings," static struct fuzzsession session;
 static void decode(struct packet *pkt, pthread_mutex_t *packetmutex)
 {
 char *buffer = pkt->data;
+char *str;
 enum logmsgtypes type = buffer[0];
 
-decodefuncs[type].func((char *) pkt->data);
+str = decodefuncs[type].func((char *) pkt->data);
+printf(""%s"", str);
+free(str);
+
 pthread_mutex_lock(packetmutex);
 list_del(&pkt->list);
 pthread_mutex_unlock(packetmutex);
",252,49
add a server/ copy of zmalloc,"
+//TODO: eventually this file will go away, and we'll just share parts of
+// the top-level utils.c
+
+#include <errno.h>
+#include <sys/mman.h>
+#include <signal.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include ""utils.h""
+
+void * __zmalloc(size_t size, const char *func)
+{
+void *p;
+
+p = malloc(size);
+if (p == NULL) {
+/* Maybe we mlockall'd everything. Try and undo that, and retry. */
+munlockall();
+p = malloc(size);
+if (p != NULL)
+goto done;
+
+printf(""%s: malloc(%zu) failure.\n"", func, size);
+exit(EXIT_FAILURE);
+}
+
+done:
+memset(p, 0, size);
+return p;
+}
",23,3
fix potential use-before-init," void init_logging(char *optarg)
 struct hostent *he;
 struct sockaddr_in udpclient;
 struct in_addr **addr_list;
-char *ip;
+char *ip = NULL;
 int ret;
 unsigned int i;
 
 void init_logging(char *optarg)
 udpserver.sin_addr.s_addr = inet_addr(ip);
 udpserver.sin_port = htons(TRINITY_LOG_PORT);
 }
+
+if (ip == NULL)
+return;
+
 printf(""Logging to %s\n"", ip);
 
 logsocket = socket(AF_INET, SOCK_DGRAM, 0);
",157,26
output decoded packets to logfiles.,"
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+
+#include ""logfiles.h""
+#include ""utils.h""
+
+int open_logfile(const char *logfilename)
+{
+int fd;
+
+fd = open(logfilename, O_WRONLY | O_TRUNC | O_CREAT, 0666);
+if (!fd)
+printf(""## couldn't open logfile %s\n"", logfilename);
+
+return fd;
+}
+
+int open_child_logfile(int num)
+{
+char *logfilename;
+int fd;
+
+logfilename = zmalloc(64);
+sprintf(logfilename, ""trinity-child%u.log"", num);
+
+fd = open_logfile(logfilename);
+if (!fd)
+exit(EXIT_FAILURE);
+
+free(logfilename);
+return fd;
+}
",28,4
"print where handshakes came from

(will use the ip in the logdir name later)","
 #include <stdio.h>
 #include <stdlib.h>
 #include <unistd.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
 #include ""decode.h""
 #include ""exit.h""
 #include ""handshake.h""
 static bool __handshake(void)
 assert(!ret);
 }
 
+printf(""Received handshake from %s:%d\n"", inet_ntoa(udpclient.sin_addr), ntohs(udpclient.sin_port));
 sendudp(serverreply, strlen(serverreply));
 
 return TRUE;
",232,42
"tweak socket buffer sizes.

This isn't perfect, but it's a start"," size_t readudp(void)
 bool setup_socket(void)
 {
 struct sockaddr_in udpserver;
+int rcvbuf;
+int ret;
 
 socketfd = socket(AF_INET, SOCK_DGRAM, 0);
 if (socketfd == -1) {
 bool setup_socket(void)
 close(socketfd);
 return FALSE;
 }
+
+rcvbuf = 1000000 * 64;//TODO: adjust 64 to max_children
+ret = setsockopt(socketfd, SOL_SOCKET, SO_RCVBUF, &rcvbuf, sizeof(rcvbuf));
+printf(""Recieve socket buffer size set to %d\n"", rcvbuf);
+
 return TRUE;
 }
",57,7
timestamp syscall operations.," void do_syscall(struct syscallrecord *rec)
 struct childdata *child = this_child();
 unsigned int call;
 
+/* timestamp for 'before the syscall' */
+clock_gettime(CLOCK_MONOTONIC, &rec->tp);
+
 init_msgchildhdr(&scmsg.hdr, SYSCALL_PREP, pids[child->num], child->num);
 scmsg.sequence_nr = child->op_nr;
 scmsg.nr = rec->nr;
 void do_syscall(struct syscallrecord *rec)
 scmsg.a4 = rec->a4;
 scmsg.a5 = rec->a5;
 scmsg.a6 = rec->a6;
+scmsg.tp = rec->tp;
 sendudp((char *) &scmsg, sizeof(scmsg));
 
 call = rec->nr;
 void do_syscall(struct syscallrecord *rec)
 else
  /* common-case, do the syscall in this child process. */
 __do_syscall(rec, BEFORE);
+
+/* timestamp again for when we returned */
+clock_gettime(CLOCK_MONOTONIC, &rec->tp);
 }
 
 /*
 void handle_syscall_ret(struct syscallrecord *rec)
 scmsg.sequence_nr = child->op_nr;
 scmsg.retval = rec->retval;
 scmsg.errno_post = rec->errno_post;
+scmsg.tp = rec->tp;
 sendudp((char *) &scmsg, sizeof(scmsg));
 
 call = rec->nr;
",206,35
"timestamp all child messages

Move the timestamp out of the syscall record out to the childmsg header.
This way we can order all child messages more easily"," static void log_child_spawned(pid_t pid, int childno)
 if (logging_enabled == FALSE)
 return;
 
-childmsg.hdr.pid = pid;
-childmsg.hdr.type = CHILD_SPAWNED;
-childmsg.hdr.childno = childno;
-
+init_msgchildhdr(&childmsg.hdr, CHILD_SPAWNED, pid, childno);
 sendudp((char *) &childmsg, sizeof(childmsg));
 }
 
",328,63
only print setsockopt success if it actually succeeded," bool setup_socket(void)
 
 rcvbuf = 1000000 * 64;//TODO: adjust 64 to max_children
 ret = setsockopt(socketfd, SOL_SOCKET, SO_RCVBUF, &rcvbuf, sizeof(rcvbuf));
-printf(""Recieve socket buffer size set to %d\n"", rcvbuf);
+if (ret == 0)
+printf(""Recieve socket buffer size set to %d\n"", rcvbuf);
 
 return TRUE;
 }
",58,8
reset the expected sequence number when a child is respawned,"
 #include <unistd.h>
 #include ""decode.h""
 #include ""exit.h""
+#include ""session.h""
 #include ""socketinfo.h""
 #include ""trinity.h""
 #include ""types.h""
 char * decode_child_spawned(char *buf)
 {
 struct msg_childspawned *childmsg;
 struct timespec *ts;
+struct childdata *child;
 void *p = zmalloc(1024);
 
 childmsg = (struct msg_childspawned *) buf;
 char * decode_child_spawned(char *buf)
 sprintf(p, ""%d.%d Child spawned. id:%d pid:%d\n"",
 (int) ts->tv_sec, (int) ts->tv_nsec,
 childmsg->hdr.childno, childmsg->hdr.pid);
+
+child = &session.children[childmsg->hdr.childno];
+child->expected_seq = 0;
+child->expecting_result = FALSE;
 return p;
 }
 
",56,3
"after iterating the child list once, sleep.

This gives other threads a chance to execute, and lets the queue
build up again"," static void * decoder_child_func(void *data)
 done:
 pthread_mutex_unlock(&child->packetmutex);
 //TODO: if main session exits, we should exit this thread.
+
+sleep(1);
 }
 return NULL;
 }
",272,53
no implied ordering between packets on spawn/exit/signal," static void * decoder_child_func(void *data)
 currpkt = (struct packet *) node;
 type = get_packet_type(currpkt);
 
+// The non syscall related messages have no ordering on each other asides from timestamp
+switch (type) {
+case CHILD_SPAWNED:
+case CHILD_EXITED:
+case CHILD_SIGNALLED:
+decode_this_packet(child, currpkt);
+continue;
+default:
+break;
+}
+
 if (child->expecting_result == TRUE) {
 if (type != SYSCALL_RESULT) {
 continue;
",281,56
"detect pid changes in child messages

This has the effect of ordering exit/spawn messages among syscall messages."," char * decode_child_spawned(char *buf)
 childmsg->hdr.childno, childmsg->hdr.pid);
 
 child = &session.children[childmsg->hdr.childno];
+child->childpid = childmsg->hdr.pid;
 child->expected_seq = 0;
 child->expecting_result = FALSE;
 return p;
",57,3
more cppcheck cleanups," int open_logfile(const char *logfilename)
 return fd;
 }
 
-int open_child_logfile(int num)
+int open_child_logfile(unsigned int num)
 {
 char *logfilename;
 int fd;
",28,4
dump errno if write() to logfile fails," static char * decode(struct packet *pkt)
 static void decode_this_packet(struct childdata *child, struct packet *pkt)
 {
 char *str = decode(pkt);
-write(child->logfile, str, strlen(str));
+int ret;
+
+ret = write(child->logfile, str, strlen(str));
+if (ret == -1)
+printf(""error writing to child logfile: %s\n"", strerror(errno));
 free(str);
 }
 
 static void * decoder_main_func(void *data)
 list_for_each_safe(node, tmp, &fs->mainpackets.list) {
 if (node != NULL) {
 char *str;
+int ret;
 str = decode((struct packet *)node);
-write(fs->logfile, str, strlen(str));
+ret = write(fs->logfile, str, strlen(str));
+if (ret == -1)
+printf(""error writing to main logfile: %s\n"", strerror(errno));
 free(str);
 }
 }
",285,58
"maintain a packets pending count

for debugging purposes."," static void decode_this_packet(struct childdata *child, struct packet *pkt)
 if (ret == -1)
 printf(""error writing to child logfile: %s\n"", strerror(errno));
 free(str);
+
+child->packetcount--;
 }
 
 static void * decoder_child_func(void *data)
 static bool __handshake(void)
 child->expected_seq = 0;
 child->expecting_result = FALSE;
 INIT_LIST_HEAD(&child->packets.list);
+child->packetcount = 0;
 pthread_mutex_init(&child->packetmutex, NULL);
 ret = pthread_create(&session.childthreads[i], NULL, decoder_child_func, child);
 assert(!ret);
 tail_add:
 
 list_add_tail(&pkt->list, &child->packets.list);
 done:
+child->packetcount++;
 pthread_mutex_unlock(&child->packetmutex);
 }
 
",288,58
copy incoming packet timestamp into the packet header," static void add_to_child_queue(void *data, int len)
 childhdr = (struct trinity_msgchildhdr *) pkt->data;
 child = &fs->children[childhdr->childno];
 
+pkt->tp = childhdr->tp;
+
 pthread_mutex_lock(&child->packetmutex);
 
 if (list_empty(&child->packets.list))
",289,58
log the last operation number a child did when we get a signal," static void fork_children(void)
 shm->ready = TRUE;
 }
 
-static void log_child_signalled(int childno, pid_t pid, int sig)
+static void log_child_signalled(int childno, pid_t pid, int sig, unsigned long op_nr)
 {
 struct msg_childsignalled childmsg;
 
 init_msgchildhdr(&childmsg.hdr, CHILD_SIGNALLED, pid, childno);
 childmsg.sig = sig;
+childmsg.op_nr = op_nr;
 
 sendudp((char *) &childmsg, sizeof(childmsg));
 }
 static void handle_childsig(int childno, int childstatus, bool stop)
 else {
 debugf(""got a signal from child %d (pid %d) (%s)\n"",
 childno, pid, strsignal(WTERMSIG(childstatus)));
-log_child_signalled(childno, pid, WTERMSIG(childstatus));
+log_child_signalled(childno, pid, WTERMSIG(childstatus), child->op_nr);
 }
 reap_child(shm->children[childno]);
 
",586,132
use pthread_yield rather than sleep," static void * decoder_child_func(void *data)
 }
 done:
 pthread_mutex_unlock(&child->packetmutex);
-//TODO: if main session exits, we should exit this thread.
 
-sleep(1);
+pthread_yield();
 }
+//TODO: if main session exits, we should exit this thread.
 return NULL;
 }
 
",289,58
send the SIGALARM message from the child that just received it.," static bool handle_sigreturn(int sigwas)
 
 if (sigwas != SIGALRM)
 output(1, ""[%d] Back from signal handler! (sig was %s)\n"", getpid(), strsignal(sigwas));
-
+else {
+log_child_signalled(child->num, pids[child->num], SIGALRM, child->op_nr);
+child->op_nr++;
+}
 return TRUE;
 }
 
",332,63
bump the expected sequence nr if we got a SIGALARM," static void * decoder_child_func(void *data)
 switch (type) {
 case CHILD_SPAWNED:
 case CHILD_EXITED:
+// TODO: put lastop in the exit msg and wait until that op before processing this.
+// TODO: check signalled->op_nr == expected-1
+decode_this_packet(child, currpkt);
+child->expecting_result = FALSE;
+continue;
+
 case CHILD_SIGNALLED:
+// TODO: check signalled->op_nr == expected-1
 decode_this_packet(child, currpkt);
 child->expecting_result = FALSE;
+// TODO: only if SIGALRM
+child->expected_seq++;
 continue;
 default:
 break;
",293,58
"add incoming packets to the correct place in the list.

At this point, 'node' points to the node after where we want to insert."," static void add_to_child_queue(void *data, int len)
 if (childhdr->tp.tv_nsec > listpkt->tp.tv_nsec)
 continue;
 
-list_add(&pkt->list, node);
+list_add(&pkt->list, node->prev);
 goto done;
 }
 
",293,58
add the last op_nr to the childexited message," static void handle_childsig(int childno, int childstatus, bool stop)
 }
 }
 
-static void log_child_exited(pid_t pid, int childno)
+static void log_child_exited(struct childdata *child)
 {
 struct msg_childexited childmsg;
 
-init_msgchildhdr(&childmsg.hdr, CHILD_EXITED, pid, childno);
+init_msgchildhdr(&childmsg.hdr, CHILD_EXITED,
+ pids[child->num], child->num);
+childmsg.op_nr = child->op_nr;
 sendudp((char *) &childmsg, sizeof(childmsg));
 }
 
 static void handle_child(int childno, pid_t childpid, int childstatus)
 if (WIFEXITED(childstatus)) {
 struct childdata *child = shm->children[childno];
 
-log_child_exited(childpid, childno);
+log_child_exited(child);
 
 debugf(""Child %d (pid:%u type:%u) exited after %ld operations.\n"",
 childno, childpid, child->type, child->op_nr);
",588,132
childhdr is already set at this point.," static void * decoder_child_func(void *data)
 
 /* From here on, type can only be SYSCALL_PREP or SYSCALL_RESULT */
 
-/* if the pid changed, before we gto a CHILD_SPAWNED, skip */
-childhdr = (struct trinity_msgchildhdr *) currpkt->data;
+/* if the pid changed, before we got a CHILD_SPAWNED, skip */
 if (child->childpid != childhdr->pid)
 continue;
 
",329,65
drop duplicate packets instead of adding them to the list.," static void add_to_child_queue(void *data, int len)
 if (childhdr->tp.tv_sec == listpkt->tp.tv_sec) {
 if (childhdr->tp.tv_nsec > listpkt->tp.tv_nsec)
 goto tail_add;
+if (childhdr->tp.tv_nsec == listpkt->tp.tv_nsec)
+goto drop_dupe;
 }
 
 /* crap, we've got something out of order, scan the list for the right place
 static void add_to_child_queue(void *data, int len)
 continue;
 if (childhdr->tp.tv_nsec > listpkt->tp.tv_nsec)
 continue;
+if (childhdr->tp.tv_nsec == listpkt->tp.tv_nsec)
+goto drop_dupe;
 
 list_add(&pkt->list, node->prev);
 goto done;
 tail_add:
 done:
 child->packetcount++;
 pthread_mutex_unlock(&child->packetmutex);
+return;
+
+drop_dupe:
+free(pkt->data);
+free(pkt);
+pthread_mutex_unlock(&child->packetmutex);
 }
 
 static void queue_object_msg(struct trinity_msgobjhdr *obj, int len)
",349,71
fix up cppcheck signedness warnings," static void decode_this_packet(struct childdata *child, struct packet *pkt)
 static void decode_one_child(struct childdata *child)
 {
 struct list_head *node = NULL, *tmp;
-int childno;
+unsigned int childno;
 int n = 0;
 
 pthread_mutex_lock(&child->packetmutex);
 static void decode_one_child(struct childdata *child)
 }
 
 if (child->packetcount != 0)
-printf(""pkts in queue for child %u: %d\n"", childno, child->packetcount);
+printf(""pkts in queue for child %u: %u\n"", childno, child->packetcount);
 done:
 pthread_mutex_unlock(&child->packetmutex);
 
",349,71
"replace state machine with simpler drain logic

In its current form, this was too easy to confuse when packets went missing.
I may resurrect something similar later, but for now, just implement
a simple plug/drain mutex to dump child queues when a child exits.
(Other cases still need handling, like segv)"," char * decode_child_spawned(char *buf)
 
 child = &session.children[childmsg->hdr.childno];
 child->childpid = childmsg->hdr.pid;
-child->expected_seq = 0;
-child->expecting_result = FALSE;
 return p;
 }
 
",56,3
reduce the likelyhood that we call expensive syscalls.," static bool choose_syscall_table(void)
 
 static bool set_syscall_nr(struct syscallrecord *rec)
 {
+struct syscallentry *entry;
 unsigned int syscallnr;
 bool do32;
 
 retry:
 goto retry;
 }
 
+entry = get_syscall_entry(syscallnr, do32);
+if (entry->flags & EXPENSIVE) {
+if (!ONE_IN(1000))
+goto retry;
+}
+
 /* critical section for shm updates. */
 lock(&rec->lock);
 rec->do32bit = do32;
",101,18
remove old debug leftover," void log_enabled_syscalls_biarch(void)
 }
 
 sendudp((char *) udpmsg, size);
-printf(""freeing %p\n"", udpmsg);
 free(udpmsg);
 
 /* Now send the 32bit syscalls */
",345,79
"make the new seed be sequential (sort of)

Offset it by the number of children, as previous children will have
already used all the intermediate seeds."," void reseed(void)
 }
 
 /* We are reseeding. */
-shm->seed = rnd();
+shm->seed += max_children;
 
 init_msghdr(&reseedmsg.hdr, RESEED);
 reseedmsg.new_seed = shm->seed;
",58,8
move the 'are we done' check to the generic child code.," void child_process(struct childdata *child, int childno)
 
 if (ops->flags & ONESHOT)
 loops = 0;
+
+if (syscalls_todo) {
+if (shm->stats.op_count >= syscalls_todo) {
+shm->exit_reason = EXIT_REACHED_COUNT;
+goto out;
+}
+}
 }
 
 enable_coredumps();
",338,65
"Include sys/io.h for UIO_MAXIOV symbol.

This patch fixes this build error.

 CC	net/proto-ipv4.o
net/proto-ipv4.c: In function ip_setsockopt:
net/proto-ipv4.c:231:49: error: UIO_MAXIOV undeclared (first use in this function); did you mean _IO_MAGIC?
 so->optlen = rnd() % sizeof(unsigned long)*(2*UIO_MAXIOV+512);
 ^~~~~~~~~~
 _IO_MAGIC

Signed-off-by: Vinson Lee <vlee@freedesktop.org>","
 #include <sys/types.h>
 #include <sys/socket.h>
 #include <sys/un.h>
+#include <sys/uio.h>
 #include <netinet/in.h>
 #include <netinet/udp.h>
 #include <stdlib.h>
",321,24
ioctls/vfs.c: FS_IOC_GETFSMAP,"
 #include <linux/fiemap.h>
 #include <linux/fs.h>
 #include <linux/blktrace_api.h>
+#ifdef USE_FSMAP
+#include <linux/fsmap.h>
+#endif
 #include <linux/ioctl.h>
 #include <asm/ioctls.h>
 #include ""ioctls.h""
 static const struct ioctl vfs_ioctls[] = {
 #ifdef FS_IOC_GET_ENCRYPTION_POLICY
 { .name = ""FS_IOC_GET_ENCRYPTION_POLICY"", .request = FS_IOC_GET_ENCRYPTION_POLICY, },
 #endif
+#ifdef FS_IOC_GETFSMAP
+{ .name = ""FS_IOC_GETFSMAP"", .request = FS_IOC_GETFSMAP, },
+#endif
 };
 
 static const struct ioctl_group vfs_grp = {
",134,4
"get_syscall_entry: remove SYSCALL_OFFSET

0-based syscall numbers are used throughout the application and the
SYSCALL_OFFSET is only added when invoking the syscall. It is therefore
wrong to substract the offset in get_syscall_entry, as it leads to
dereferencing array entries at negative offsets and segfaults.

Tested on MIPS32/LE.
This change effectively reverts cc5108ff ('make get_syscall_entry take
SYSCALL_OFFSET into account')

Signed-off-by: Marcin Nowakowski <marcin.nowakowski@imgtec.com>"," int munge_tables(void)
 */
 struct syscallentry * get_syscall_entry(unsigned int callno, bool do32)
 {
-unsigned int offset = callno - SYSCALL_OFFSET;
 if (biarch == FALSE)
-return syscalls[offset].entry;
+return syscalls[callno].entry;
 
 /* biarch case */
 if (do32 == TRUE)
-return syscalls_32bit[offset].entry;
+return syscalls_32bit[callno].entry;
 else
-return syscalls_64bit[offset].entry;
+return syscalls_64bit[callno].entry;
 }
 
 /*
",503,141
add new TCP setsockopts," static const unsigned int tcp_opts[] = {
 TCP_THIN_DUPACK, TCP_USER_TIMEOUT, TCP_REPAIR, TCP_REPAIR_QUEUE,
 TCP_QUEUE_SEQ, TCP_REPAIR_OPTIONS, TCP_FASTOPEN, TCP_TIMESTAMP,
 TCP_NOTSENT_LOWAT, TCP_CC_INFO, TCP_SAVE_SYN, TCP_SAVED_SYN,
-TCP_REPAIR_WINDOW, TCP_FASTOPEN_CONNECT,
+TCP_REPAIR_WINDOW, TCP_FASTOPEN_CONNECT, TCP_ULP, TCP_MD5SIG_EXT,
 };
 
 void tcp_setsockopt(struct sockopt *so, __unused__ struct socket_triplet *triplet)
",20,1
update setsockopt options," static const unsigned int socket_opts[] = {
 SO_PEEK_OFF, SO_NOFCS, SO_LOCK_FILTER, SO_SELECT_ERR_QUEUE,
 SO_BUSY_POLL, SO_MAX_PACING_RATE, SO_BPF_EXTENSIONS, SO_INCOMING_CPU,
 SO_ATTACH_BPF, SO_ATTACH_REUSEPORT_CBPF, SO_ATTACH_REUSEPORT_EBPF,
-SO_CNX_ADVICE,
+SO_CNX_ADVICE, SCM_TIMESTAMPING_OPT_STATS, SO_MEMINFO, SO_INCOMING_NAPI_ID,
+SO_COOKIE, SCM_TIMESTAMPING_PKTINFO, SO_PEERGROUPS,
 };
 
 static void socket_setsockopt(struct sockopt *so, __unused__ struct socket_triplet *triplet)
",164,29
special case tls for TCP_ULP," static const unsigned int tcp_opts[] = {
 void tcp_setsockopt(struct sockopt *so, __unused__ struct socket_triplet *triplet)
 {
 so->optname = RAND_ARRAY(tcp_opts);
+
+if (so->optname == TCP_ULP) {
+char *ptr = (char *) so->optval;
+
+sprintf(ptr, ""tls"");
+so->optlen = sizeof(""tls"");
+}
 }
",25,2
update netlink protocols," static const char * get_proto_name(unsigned int family, unsigned int proto)
 { ""NETLINK_ECRYPTFS"", NETLINK_ECRYPTFS },
 { ""NETLINK_RDMA"", NETLINK_RDMA },
 { ""NETLINK_CRYPTO"", NETLINK_CRYPTO },
+{ ""NETLINK_SMC"", NETLINK_SMC },
 };
 
 switch (family) {
",205,25
"dump_pid_stack: fix uninitialised variable

On first call to getline() 'line' is uninitialised, so while getline
allocates memory for the line, it will attempt to free an invalid
pointer.

Signed-off-by: Marcin Nowakowski <marcin.nowakowski@imgtec.com>"," static void dump_pid_stack(int pid)
 
 while (!(feof(fp))) {
 size_t n = 0;
-char *line;
+char *line = NULL;
 if (getline(&line, &n, fp) != -1) {
 output(0, ""pid %d stack: %s"", pid, line);
 free(line);
",588,132
"econet: make optional

musl-libc doesn't define structures required for econet support, so make
the protocol support optional depending on whether the expected header
exists

Signed-off-by: Marcin Nowakowski <marcin.nowakowski@imgtec.com>","
+#ifdef USE_NETECONET
 #include <sys/types.h>
 #include <sys/socket.h>
 #include <sys/un.h>
 const struct netproto proto_econet = {
 .valid_triplets = econet_triplet,
 .nr_triplets = ARRAY_SIZE(econet_triplet),
 };
+
+#endif
",32,1
"ax25: make optional

musl-libc doesn't define structures required for ax25 support, so make
the protocol support optional depending on whether the expected header
exists

Signed-off-by: Marcin Nowakowski <marcin.nowakowski@imgtec.com>","
+#ifdef USE_NETAX25
 #include <stdlib.h>
 #include <sys/types.h>
 #include <sys/socket.h>
 const struct netproto proto_ax25 = {
 .valid_triplets = ax25_triplets,
 .nr_triplets = ARRAY_SIZE(ax25_triplets),
 };
+#endif
",45,2
"ipx: make optional

musl-libc doesn't define structures required for ipx support, so make
the protocol support optional depending on whether the expected header
exists

Signed-off-by: Marcin Nowakowski <marcin.nowakowski@imgtec.com>","
+#ifdef USE_IPX
 #include <sys/types.h>
 #include <sys/socket.h>
 #include <sys/un.h>
 const struct netproto proto_ipx = {
 .valid_triplets = ipx_triplet,
 .nr_triplets = ARRAY_SIZE(ipx_triplet),
 };
+
+#endif
",39,3
"replace __WORDSIZE with WORD_BIT

WORD_BIT is defined by the standard and is declared in limits.h
__WORDSIZE is a libc-internal symbol and should not be used by the
applications. Moreover, musl-libc doesn't declare it at all.

Signed-off-by: Marcin Nowakowski <marcin.nowakowski@imgtec.com>"," static unsigned int get_interesting_32bit_value(void)
 }
 }
 
-#if __WORDSIZE != 32
+#if WORD_BIT != 32
 static unsigned long per_arch_interesting_addr(unsigned long low)
 {
 int i = 0;
 static unsigned long per_arch_interesting_addr(unsigned long low)
 
 return i | low;
 }
-#endif/* __WORDSIZE */
+#endif/* WORD_BIT */
 
 unsigned long get_interesting_value(void)
 {
 unsigned long get_interesting_value(void)
 }
 
 low = (rnd() & 0xf) ? low : plus_minus_two(low);// 1 in 16 call plus_minus_two
-#if __WORDSIZE != 32
+#if WORD_BIT != 32
 
 if (RAND_BOOL()) {// FIXME: This should likely be less aggressive than 50/50
 switch (rnd() % 11) {
 unsigned long get_interesting_value(void)
 }
 }
 
-#endif/* __WORDSIZE */
+#endif/* WORD_BIT */
 return low;
 }
",94,48
"syscalls/select: ensure __NFDBITS is defined

musl-libc doesn't define __NFDBITS and provides a definition of NFDBITS
instead.

Signed-off-by: Marcin Nowakowski <marcin.nowakowski@imgtec.com>","
 #include ""sanitise.h""
 #include ""utils.h""
 
+#ifndef __NFDBITS
+#define __NFDBITS NFDBITS
+#endif
+
 static void sanitise_select(struct syscallrecord *rec)
 {
 unsigned int i;
",51,3
"fix includes

musl-libc is more strict about which headers provide which definitions,
so add/remove includes where required","
 #pragma once
 
+#include <sys/types.h>
 #include <sys/mman.h>
 #include <stdlib.h>
 #include <stdio.h>
",14,1
"pathnames: add missing nftw defines

nftw in glibc has a non-standard FTW_ACTIONRETVAL option that allows the
callback implementation to be more efficient. Add the missing #defines
to make the current implementation compatible with musl-libc which
doesn't have the FTW_ACTIONRETVAL extension.

Signed-off-by: Marcin Nowakowski <marcin.nowakowski@imgtec.com>","
 #include ""uid.h""
 #include ""utils.h""
 
+#ifndef FTW_ACTIONRETVAL
+#define FTW_ACTIONRETVAL 0
+#define FTW_CONTINUE 0
+#define FTW_SKIP_SUBTREE 0
+#define FTW_STOP 1
+#endif
+
 unsigned int files_in_index = 0;
 const char **fileindex;
 
 static int file_tree_callback(const char *fpath, const struct stat *sb, int type
 return FTW_CONTINUE;
 }
 
-
 static void open_fds_from_path(const char *dirpath)
 {
 int before = files_in_index;
",224,54
"Add SIGILL as a potential child exit signal

It is possible for the child process to terminate with a SIGILL signal.
As this is currently not handled, the parent process would not properly
clean up the child's state and will later assume the child is not making
a progress and attempt to kill it even though it's no longer there.

Signed-off-by: Marcin Nowakowski <marcin.nowakowski@imgtec.com>"," static void handle_childsig(int childno, int childstatus, bool stop)
 case SIGPIPE:
 case SIGABRT:
 case SIGBUS:
+case SIGILL:
 if (stop == TRUE)
 debugf(""Child %d (pid %d) was stopped by %s\n"",
 childno, pid, strsignal(WSTOPSIG(childstatus)));
",589,133
output a packet count for debugging," static void * queue_packets(__unused__ void *data)
 {
 int len;
 enum logmsgtypes type;
+unsigned long numpkts = 0;
 
 while (1) {
 struct childdata *child;
 static void * queue_packets(__unused__ void *data)
 
 len = ret;
 
+numpkts++;
+printf(""RX:%lu\r"", numpkts);
+
 /* We may see a new handshake appear at any time
  * if a client dies without sending a 'main has exited' message.
  * Just re-handshake for now. Later, we'll tear down any context etc.
",302,57
"net/proto-rds.c: rds_setsockopt() stub not needed

The stub function is not needed, and we can #ifdef the whole file.

Signed-off-by: Tommi Rantala <tommi.t.rantala@nokia.com>","
-#include <stdlib.h>
-#include ""net.h""
-
 #ifdef USE_RDS
 #include <linux/rds.h>
-#endif
-
+#include <stdlib.h>
+#include ""net.h""
 #include ""compat.h""
 #include ""random.h""
 #include ""utils.h""// RAND_ARRAY
 static void rds_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 *addrlen = sizeof(struct sockaddr_in);
 }
 
-#ifdef USE_RDS
 static const unsigned int rds_opts[] = {
 RDS_CANCEL_SENT_TO, RDS_GET_MR, RDS_FREE_MR,
 4, /* deprecated RDS_BARRIER 4 */
 const struct netproto proto_rds = {
 .valid_triplets = rds_triplet,
 .nr_triplets = ARRAY_SIZE(rds_triplet),
 };
-#else
-/* stub if we are built on something without RDS headers */
-void rds_setsockopt(struct sockopt *so)
-{
-}
 #endif/* USE_RDS */
",36,2
"proto-rds: fix missing includes

Signed-off-by: Marcin Nowakowski <marcin.nowakowski@imgtec.com>","
 #ifdef USE_RDS
+#include <sys/socket.h>
+#include <stdint.h>
 #include <linux/rds.h>
 #include <stdlib.h>
 #include ""net.h""
",38,2
"reinstate the log-to-file code for now.

The log-to-udp code isn't ready for primetime, and logging to file still
has its occasional uses, so bring it back for the upcoming release.","
 #include ""arch.h""
 #include ""child.h""
 #include ""list.h""
+#include ""log.h""
 #include ""maps.h""
 #include ""params.h""
 #include ""pids.h""
 static void oom_score_adj(int adj)
 void clean_childdata(struct childdata *child)
 {
 memset(&child->syscall, 0, sizeof(struct syscallrecord));
+child->logdirty = FALSE;
 child->seed = 0;
 child->kill_count = 0;
 child->dontkillme = FALSE;
 static bool handle_sigreturn(int sigwas)
 
 /* Check if we're blocked because we were stuck on an fd. */
 lock(&rec->lock);
-if (check_if_fd(rec) == TRUE) {
+if (check_if_fd(child, rec) == TRUE) {
 /* avoid doing it again from other threads. */
 shm->fd_lifetime = 0;
 
 void child_process(struct childdata *child, int childno)
 }
 
 out:
+shutdown_child_logging(child);
 
 debugf(""child %d %d exiting.\n"", childno, getpid());
 }
",341,65
"fix the case where -l is passed a directory.

Did this ever work ? It was supposed to, so now it does."," static bool logfiles_opened = FALSE;
 static FILE *open_logfile(const char *logfilename)
 {
 FILE *file;
+char *fullpath;
+int len = strlen(logging_args) + strlen(logfilename) + 2;
 
-unlink(logfilename);
+fullpath = zmalloc(len);
+snprintf(fullpath, len, ""%s/%s"", logging_args, logfilename);
 
-file = fopen(logfilename, ""w"");
+unlink(fullpath);
+
+file = fopen(fullpath, ""w"");
 if (!file)
-outputerr(""## couldn't open logfile %s\n"", logfilename);
+outputerr(""## couldn't open logfile %s\n"", fullpath);
 
+free(fullpath);
 return file;
 }
 
",93,20
"make output() aware that LOGGING_UDP is a thing

This section only matters for LOGGING_FILES, so wrap it in an if."," skip_pid:
 }
 
 /* go on with file logs only if enabled */
-if (logging == LOGGING_DISABLED)
-return;
-
-handle = find_logfile_handle();
-if (!handle)
-return;
+if (logging == LOGGING_FILES) {
+handle = find_logfile_handle();
+if (!handle)
+return;
 
-fprintf(handle, ""%s %s"", prefix, outputbuf);
+fprintf(handle, ""%s %s"", prefix, outputbuf);
 
-(void)fflush(handle);
+(void)fflush(handle);
+}
 }
 
 /*
",83,14
"remove logfiles_opened

This seems unnecessary now","
 
 FILE *mainlogfile;
 
-static bool logfiles_opened = FALSE;
-
 static FILE *open_logfile(const char *logfilename)
 {
 FILE *file;
 void open_main_logfile(void)
 mainlogfile = open_logfile(""trinity.log"");
 if (!mainlogfile)
 exit(EXIT_FAILURE);
-
-logfiles_opened = TRUE;//FIXME: This is a bit crap
 }
 
 void open_child_logfile(struct childdata *child)
 FILE *find_logfile_handle(void)
 struct childdata *child;
 pid_t pid;
 
-if (!logfiles_opened)
-return NULL;
-
 pid = getpid();
 if (pid == mainpid)
 return mainlogfile;
",79,14
update some documentation regarding logging," static void usage(void)
 outputerr("" --ioctls,-I: list all ioctls.\n"");
 outputerr("" --kernel_taint, -T: controls which kernel taint flags should be considered, for more details refer to README file. \n"");
 outputerr("" --list,-L: list all syscalls known on this architecture.\n"");
-outputerr("" --logging,-l [off, <hostname>] : disable logging to files, or log over udp to a remote trinity server.\n"");
+outputerr("" --logging,-l [off, <dir>, <hostname>] : disable logging to files, log to a directory, or log over udp to a remote trinity server.\n"");
 outputerr("" --domain,-P: specify specific network domain for sockets.\n"");//FIXME: P used to be 'proto' pick something better.
 outputerr("" --no_domain,-E: specify network domains to be excluded from testing.\n"");
 outputerr("" --quiet,-q: less output.\n"");
",280,50
Fix up null ptr deref when no -l arg.," FILE *mainlogfile;
 static FILE *open_logfile(const char *logfilename)
 {
 FILE *file;
-char *fullpath;
-int len = strlen(logging_args) + strlen(logfilename) + 2;
+char *fullpath, *p;
+int len = strlen(logfilename) + 2;
 
-fullpath = zmalloc(len);
-snprintf(fullpath, len, ""%s/%s"", logging_args, logfilename);
+if (logging_args)
+len += strlen(logging_args);
+
+p = fullpath = zmalloc(len);
+if (logging_args)
+p += snprintf(fullpath, strlen(logging_args) + 2, ""%s/"", logging_args);
+p += snprintf(p, strlen(logfilename) + 1, ""%s"", logfilename);
 
 unlink(fullpath);
 
",83,16
"ignore possible error codes like ERESTARTSYS

These are usually only seen by libc, and never passed on to apps,
but Trinity is doing raw syscalls, so we have to worry about these."," void handle_syscall_ret(struct syscallrecord *rec)
 if (err < NR_ERRNOS) {
 entry->errnos[err]++;
 } else {
-printf(""errno out of range: %d:%s\n"", err, strerror(err));
+// ""These should never be seen by user programs.""
+// But trinity isn't a 'normal' user program, we're doing
+// stuff that libc hides from apps.
+if (err < 512 || err > 530)
+printf(""errno out of range after doing %s: %d:%s\n"",
+entry->name,
+err, strerror(err));
 }
 shm->stats.failures++;
 }
",210,37
add new madvise flags," static unsigned long madvise_advices[] = {
 MADV_FREE, MADV_REMOVE, MADV_DONTFORK, MADV_DOFORK,
 MADV_MERGEABLE, MADV_UNMERGEABLE, MADV_HUGEPAGE, MADV_NOHUGEPAGE,
 MADV_DONTDUMP, MADV_DODUMP,
+MADV_WIPEONFORK, MADV_KEEPONFORK,
 };
 
 struct syscallentry syscall_madvise = {
",32,1
document why we take that rec->lock in the extrafork path," static void do_extrafork(struct syscallrecord *rec)
 if (pid_alive(extrapid) == TRUE)
 usleep(100);
 
+/* We take the rec lock here even though we don't obviously use it.
+ * The reason, is that the grandchild is using it. */
 lock(&rec->lock);
 while (pid == 0) {
 int childstatus;
",210,37
"trinity: Fix compile error on linux 4.15 kernel

Commit 1f28c5d055032e7e8ee5e48198dca7e125d0eec6
(""autofs: remove unused AUTOFS_IOC_EXPIRE_DIRECT/INDIRECT"")

in the linux kernel removed the 2 defines
AUTOFS_IOC_EXPIRE_INDIRECT
AUTOFS_IOC_EXPIRE_DIRECT

Since they are used unconditionally the build fails.
To fix this add #ifdef/#endif around it.

Signed-off-by: Thomas Richter <tmricht@linux.vnet.ibm.com>"," static const struct ioctl autofs_ioctls[] = {
 IOCTL(AUTOFS_IOC_SETTIMEOUT),
 IOCTL(AUTOFS_IOC_EXPIRE),
 IOCTL(AUTOFS_IOC_EXPIRE_MULTI),
+/* Both defines removed by kernel commit
+ * 1f28c5d055032e7e8ee5e48198dca7e125d0eec6
+ */
+#ifdef AUTOFS_IOC_EXPIRE_INDIRECT
 IOCTL(AUTOFS_IOC_EXPIRE_INDIRECT),
+#endif
+#ifdef AUTOFS_IOC_EXPIRE_DIRECT
 IOCTL(AUTOFS_IOC_EXPIRE_DIRECT),
+#endif
 IOCTL(AUTOFS_IOC_PROTOSUBVER),
 IOCTL(AUTOFS_IOC_ASKUMOUNT),
 
",181,18
"memfd: fix build with glibc 2.27

glibc 2.27 added a wrapper for memfd_create(). This causes build
failure:

fds/memfd.c:19:12: error: static declaration of 'memfd_create' follows non-static declaration
 static int memfd_create(__unused__ const char *uname, __unused__ unsigned int flag)
 ^~~~~~~~~~~~

Don't use the local definition when the libc provides one.

Signed-off-by: Baruch Siach <baruch@tkos.co.il>","
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
+#include <sys/mman.h>
 
 #include ""fd.h""
 #include ""memfd.h""

 #include ""trinity.h""
 #include ""udp.h""
 
+#ifndef USE_MEMFD_CREATE
 static int memfd_create(__unused__ const char *uname, __unused__ unsigned int flag)
 {
 #ifdef SYS_memfd_create
 static int memfd_create(__unused__ const char *uname, __unused__ unsigned int fl
 return -ENOSYS;
 #endif
 }
+#endif
 
 static void memfd_destructor(struct object *obj)
 {
",82,9
"mlock: move MLOCK_ONFAULT to compat.h

It got defined in our headers, so it causes build failures:
syscalls/mlock.c:30:0: error: ""MLOCK_ONFAULT"" redefined [-Werror]
 #define MLOCK_ONFAULT 0x01

In file included from /usr/include/bits/mman-linux.h:115:0,
 from /usr/include/bits/mman.h:45,
 from /usr/include/sys/mman.h:41,
 from include/utils.h:4,
 from include/syscall.h:7,
 from include/child.h:7,
 from include/shm.h:4,
 from syscalls/mlock.c:6:
/usr/include/bits/mman-shared.h:33:0: note: this is the location of the previous definition
 # define MLOCK_ONFAULT 1U

So move it out of our way.

Signed-off-by: Jiri Slaby <jslaby@suse.cz>","
 #include ""sanitise.h""
 #include ""syscall.h""
 #include ""trinity.h""
+#include ""compat.h""
 
 static void sanitise_mlock(__unused__ struct syscallrecord *rec)
 {
 struct syscallentry syscall_mlock = {
 * SYSCALL_DEFINE3(mlock2, unsigned long, start, size_t, len, int, flags)
 */
 
-#define MLOCK_ONFAULT 0x01
-
 struct syscallentry syscall_mlock2 = {
 .name = ""mlock2"",
 .num_args = 2,
",34,1
short-circuit log handle discovery if logging disabled," void output_rendered_buffer(char *buffer)
 fflush(stdout);
 }
 
+if (logging == LOGGING_DISABLED)
+return;
+
 log_handle = find_logfile_handle();
 if (log_handle != NULL) {
 fprintf(log_handle, ""%s"", buffer);
",85,15
"parisc-specific updates

A few parisc-specific updates for trinity:
- Update PTRACE_XXXREGS constants which are now available on parisc
- Add more syscalls
- MS_ASYNC, MS_SYNC and MS_INVALIDATE can have different values than
 x86_64 on alpha, parisc, xtensa and other platforms

Signed-off-by: Helge Deller <deller@gmx.de>","
 #include ""syscall.h""
 #include ""trinity.h""
 
+#if !defined(MS_ASYNC)
 #define MS_ASYNC 1 /* Sync memory asynchronously. */
+#endif
+#if !defined(MS_SYNC)
 #define MS_SYNC 4 /* Synchronous memory sync. */
+#endif
+#if !defined(MS_INVALIDATE)
 #define MS_INVALIDATE 2 /* Invalidate the caches. */
+#endif
 
 static void sanitise_msync(struct syscallrecord *rec)
 {
",27,2
"trinity: check pidstatfile before fclose

Below run got segment fault. This is caused by fclose to a null
pidstatfile. Fix by checking it before executing fclose on it.

	trinity -csplice,move_pages -q -N 20

Signed-off-by: Chunyu Hu <chuhu@redhat.com>"," static void handle_childsig(int childno, int childstatus, bool stop)
 log_child_signalled(childno, pid, WTERMSIG(childstatus), child->op_nr);
 }
 reap_child(shm->children[childno]);
-
-fclose(child->pidstatfile);
+if (child->pidstatfile)
+fclose(child->pidstatfile);
 child->pidstatfile = NULL;
 
 replace_child(childno);
",597,137
"configure: fix build with kernel headers v4.17+

Kernel v4.17 removed the linux/irda.h header. Skip the irda test when
this header is missing.

Signed-off-by: Baruch Siach <baruch@tkos.co.il>","
 #include <sys/un.h>
 /* old irda.h does not include something which defines sa_family_t */
 #include <netinet/in.h>
-#include <linux/irda.h>
 #include <stdlib.h>
 #include ""net.h""
 #include ""random.h""
 #include ""utils.h""// RAND_ARRAY
 #include ""compat.h""
 
+#ifdef USE_IRDA
+#include <linux/irda.h>
+
 static void irda_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 {
 struct sockaddr_irda *irda;
 const struct netproto proto_irda = {
 .valid_triplets = irda_triplets,
 .nr_triplets = ARRAY_SIZE(irda_triplets),
 };
+
+#endif
",47,3
"proto-rds: include libc network headers first

To avoid collisions between libc networking headers and header kernels
the libc headers must appear first in the list of headers. This fixes a
build issue with kernel headers v4.19:

In file included from include/net.h:5:0,
 from net/proto-rds.c:6:
.../sysroot/usr/include/netinet/in.h:23:8: error: redefinition of 'struct in6_addr'
 struct in6_addr {
 ^~~~~~~~
In file included from .../sysroot/usr/include/linux/rds.h:40:0,
 from net/proto-rds.c:4:
.../sysroot/usr/include/linux/in6.h:33:8: note: originally defined here
 struct in6_addr {
		^~~~~~~~

Signed-off-by: Baruch Siach <baruch@tkos.co.il>","
 #ifdef USE_RDS
 #include <sys/socket.h>
 #include <stdint.h>
-#include <linux/rds.h>
 #include <stdlib.h>
 #include ""net.h""
 #include ""compat.h""
 #include ""random.h""
 #include ""utils.h""// RAND_ARRAY
+#include <linux/rds.h>
 
 static void rds_gen_sockaddr(struct sockaddr **addr, socklen_t *addrlen)
 {
",38,2
"memfd build fixes for modern glibc

also add MFD_HUGETLB","
 #include ""udp.h""
 
 #ifndef USE_MEMFD_CREATE
+
+#ifndef MFD_ALLOW_SEALING
 static int memfd_create(__unused__ const char *uname, __unused__ unsigned int flag)
 {
 #ifdef SYS_memfd_create
 static int memfd_create(__unused__ const char *uname, __unused__ unsigned int fl
 #endif
 }
 #endif
+#endif
 
 static void memfd_destructor(struct object *obj)
 {
 static int open_memfd_fds(void)
 0,
 MFD_CLOEXEC,
 MFD_CLOEXEC | MFD_ALLOW_SEALING,
-MFD_ALLOW_SEALING,
+MFD_ALLOW_SEALING, MFD_HUGETLB,
 };
 
 head = get_objhead(OBJ_GLOBAL, OBJ_FD_MEMFD);
",82,9
Fix compile failure on centos7,"
 
 #ifndef USE_MEMFD_CREATE
 
-#ifndef MFD_ALLOW_SEALING
+#ifndef memfd_create
 static int memfd_create(__unused__ const char *uname, __unused__ unsigned int flag)
 {
 #ifdef SYS_memfd_create
",82,9
Don't do 10 iterations of sockets we can't generate," static bool generate_sockets(void)
 while (nr_sockets < NR_SOCKET_FDS) {
 r = rnd() % TRINITY_PF_MAX;
 for (i = 0; i < 10; i++)
-generate_specific_socket(r);
+if (generate_specific_socket(r) == FALSE)
+break;
 }
 
 out_unlock:
",404,89
socket args are unsigned," static bool generate_socket(unsigned int family, unsigned int protocol, unsigned
 write_socket_to_cache(&st);
 return TRUE;
 }
-output(2, ""Couldn't open socket %d:%d:%d. %s\n"", family, type, protocol, strerror(errno));
+output(2, ""Couldn't open socket %u:%u:%u. %s\n"", family, type, protocol, strerror(errno));
 return FALSE;
 }
 
",404,89
"silence the perf dumper

it's not particularly helpful in this form rn"," static void perffd_dump(struct object *obj, bool global)
 struct perf_event_attr *attr = obj->perfobj.eventattr;
 struct msg_objcreatedperf *objmsg;
 char *p = (char *)attr;
-unsigned int i;
+//unsigned int i;
 unsigned int perfsize = sizeof(struct perf_event_attr);
 
 output(2, ""perf fd: %d pid:%d cpu:%d group_fd:%d flags:%lx\n"",
 po->fd, po->pid, po->cpu, po->group_fd, po->flags);
-output(2, "" perf_event_attr:"");
+/*output(2, "" perf_event_attr:"");
 for (i = 0; i < perfsize ; i++) {
 output(CONT, ""%02x "", (unsigned char) p[i]);
 }
 output(CONT, ""\n"");
-
+*/
 objmsg = zmalloc(sizeof(struct msg_objcreatedperf) + perfsize);
 init_msgobjhdr(&objmsg->hdr, OBJ_CREATED_PERF, global, obj);
 objmsg->fd = po->fd;
",110,13
more signed->unsigned," static bool generate_specific_socket(int family)
 
 fd = open_socket(st.family, st.type, st.protocol);
 if (fd == -1) {
-output(0, ""Couldn't open socket (%d:%d:%d). %s\n"",
+output(0, ""Couldn't open socket (%u:%u:%u). %s\n"",
 st.family, st.type, st.protocol,
 strerror(errno));
 return FALSE;
",404,89
Fix reversed file closures in ftrace code.," static void dump_trace(void)
 output(0, ""Dumped trace to %s\n"", ftracedumpname);
 fail:
 fsync(traceout);
-close(tracein);
+close(traceout);
 
 fail_traceout:
-close(traceout);
+close(tracein);
 fail_tracein:
 free((void *)ftracedumpname);
 ftracedumpname = NULL;
",76,14
don't free the default dump filename ptr," static void dump_trace(void)
 fail:
 fsync(traceout);
 close(traceout);
-
 fail_traceout:
 close(tracein);
 fail_tracein:
-free((void *)ftracedumpname);
-ftracedumpname = NULL;
+if (ftracedumpname != defaultdumpfilename) {
+free((void *)ftracedumpname);
+ftracedumpname = NULL;
+}
 }
 
 void setup_ftrace(void)
 void stop_ftrace(void)
 }
 dump_trace();
 return;
-} else {
-output(0, ""trace_fd was %d\n"", trace_fd);
 }
 }
",76,15
Add SO_DETACH_REUSEPORT_BPF," static const unsigned int socket_opts[] = {
 SO_COOKIE, SCM_TIMESTAMPING_PKTINFO, SO_PEERGROUPS, SO_ZEROCOPY,
 SO_TXTIME, SO_BINDTOIFINDEX, SO_TIMESTAMP_NEW, SO_TIMESTAMPNS_NEW,
 SO_TIMESTAMPING_NEW, SO_RCVTIMEO_NEW, SO_SNDTIMEO_NEW,
+SO_DETACH_REUSEPORT_BPF,
 };
 
 static void socket_setsockopt(struct sockopt *so, __unused__ struct socket_triplet *triplet)
",167,29
update TCP setsockopts," static const unsigned int tcp_opts[] = {
 TCP_QUEUE_SEQ, TCP_REPAIR_OPTIONS, TCP_FASTOPEN, TCP_TIMESTAMP,
 TCP_NOTSENT_LOWAT, TCP_CC_INFO, TCP_SAVE_SYN, TCP_SAVED_SYN,
 TCP_REPAIR_WINDOW, TCP_FASTOPEN_CONNECT, TCP_ULP, TCP_MD5SIG_EXT,
+TCP_FASTOPEN_KEY, TCP_FASTOPEN_NO_COOKIE, TCP_ZEROCOPY_RECEIVE, TCP_INQ,
+TCP_TX_DELAY,
 };
 
 void tcp_setsockopt(struct sockopt *so, __unused__ struct socket_triplet *triplet)
",27,2
"modify_ldt: include linux/types.h before ASSEMBLY == 1

Otherwise we see a lot of:
In file included from /usr/include/bits/statx.h:30,
 from /usr/include/sys/stat.h:446,
 from include/files.h:3,
 from include/shm.h:6,
 from syscalls/x86/modify_ldt.c:12:
/usr/include/linux/stat.h:57:2: error: unknown type name '__s64'
 57 | __s64 tv_sec;
 | ^~~~~
/usr/include/linux/stat.h:58:2: error: unknown type name '__u32'
 58 | __u32 tv_nsec;
 | ^~~~~","
 */
 #include <stdlib.h>
 #include <sys/types.h>
+#include <linux/types.h> /* before __ASSEMBLY__ == 1 */
 #define __ASSEMBLY__ 1
 #include <asm/ldt.h>
 #include ""sanitise.h""
",45,4
"remove all the udp logging

unfinished, kinda broken, and not likely to get worked on in this lifetime","
 #include ""shm.h""
 #include ""compat.h""
 #include ""trinity.h""
-#include ""udp.h""
 
 static int bpf(int cmd, union bpf_attr *attr, unsigned int size)
 {
 static struct bpf_fd_types bpf_fds[] = {
 
 static void bpf_map_dump(struct object *obj, bool global)
 {
-struct msg_objcreatedbpfmap objmsg;
 u32 type = obj->bpfobj.map_type;
 
-output(2, ""bpf map fd:%d type:%s\n"", obj->bpfobj.map_fd, (char *)&bpf_fds[type].name);
-
-init_msgobjhdr(&objmsg.hdr, OBJ_CREATED_BPFMAP, global, obj);
-objmsg.map_fd = obj->bpfobj.map_fd;
-objmsg.map_type = obj->bpfobj.map_type;
-sendudp((char *) &objmsg, sizeof(objmsg));
+output(2, ""bpf map fd:%d type:%s global:%d\n"",
+obj->bpfobj.map_fd, (char *)&bpf_fds[type].name, global);
 }
 
 static int open_bpf_fds(void)
",103,9
"Remove leftover udp.h include.

Fix build error.

 CC	fds/drm.o
fds/drm.c:26:10: fatal error: udp.h: No such file or directory
 26 | #include ""udp.h""
 | ^~~~~~~

Fixes: c927ff98280b (""remove all the udp logging"")
Signed-off-by: Vinson Lee <vlee@freedesktop.org>","
 #include <fcntl.h>
 #include <drm/drm.h>
 
-#include ""udp.h""
-
 static void drmfd_destructor(struct object *obj)
 {
 close(obj->drmfd);
",111,21
Solved race condition that was giving segfault when adding large number of jobs while workers were reading from job queue," int thpool_add_work(thpool_t* tp_p, void *(*function_p)(void*), void* arg_p){
 newJob->arg=arg_p;
 
 /* add job to queue */
+pthread_mutex_lock(&mutex); /* LOCK */
 thpool_jobqueue_add(tp_p, newJob);
+pthread_mutex_unlock(&mutex); /* UNLOCK */
 
 return 0;
 }
",158,28
Queue operations are thread-safe," void thpool_thread_do(thpool_t* tp_p){
 void*(*func_buff)(void* arg);
 void* arg_buff;
 job_t* job_p;
-
-pthread_mutex_lock(&mutex); /* LOCK */
+
 puts(""pulling job"");
 job_p = jobqueue_pull(tp_p);
-pthread_mutex_unlock(&mutex); /* UNLOCK */
 
 if (job_p) {
 puts(""WILL RUN THE JOB NOW"");
",158,28
Single listed queue used from now on," static void jobqueue_clear(thpool_t* thpool){
 //printf(""rear: %p\n"", thpool->jobqueue->rear);
 //printf(""curjob prev: %p\n"", thpool->jobqueue->rear->prev);
 //thpool->jobqueue->tail = curjob->prev;
-while(thpool->jobqueue->len){
+//while(thpool->jobqueue->len){
 //thpool->jobqueue->tail = curjob->prev;
 //free(curjob);
 //curjob=thpool->jobqueue->tail;
",163,30
Resume/pause tests added,"
+#include <stdio.h>
+#include <unistd.h>
+#include <time.h>
+#include <stdlib.h>
+#include ""../../thpool.h""
+
+/* 
+ * THIS TEST NEEDS TO BE TIMED TO BE MEANINGFULL
+ * 
+ * main: sleep 3 secs sleep 2 secs
+ * 
+ * thpool: sleep 4 secs
+ * 
+ * Thus the program should take just a bit more than 7 seconds.
+ * 
+ * */
+
+void sleep_4_secs(){
+sleep(4);
+puts(""SLEPT"");
+}
+
+int main(int argc, char *argv[]){
+
+char* p;
+if (argc != 2){
+puts(""This testfile needs excactly one arguments"");
+exit(1);
+}
+int num_threads = strtol(argv[1], &p, 10);
+
+thpool threadpool = thpool_init(num_threads);
+
+thpool_pause(threadpool);
+
+thpool_add_work(threadpool, (void*)sleep_4_secs, NULL);
+thpool_add_work(threadpool, (void*)sleep_4_secs, NULL);
+
+sleep(3);
+
+thpool_resume(threadpool);
+// If it works, then the threadpool starts working NOW
+
+sleep(2); // Give some time to threads to get the work
+
+thpool_destroy(threadpool); // Wait for work to finish
+
+return 0;
+}
",26,3
Forgot to include pthread.h,"
 #include <stdio.h>
+#include <pthread.h>
 #include <unistd.h>
 #include <time.h>
 #include <stdlib.h>
",30,4
Smart polling implemented," int main(int argc, char *argv[]){
 int num_jobs = strtol(argv[1], &p, 10);
 int num_threads = strtol(argv[2], &p, 10);
 int wait_each_job = strtol(argv[3], &p, 10);
-
-printf(""%d\n"", wait_each_job);
 
 threadpool thpool = thpool_init(num_threads);
 
",28,6
Concise error messages," static void* thread_do(struct thread* thread_p){
 struct sigaction act;
 act.sa_handler = thread_hold;
 if (sigaction(SIGUSR1, &act, NULL) == -1) {
-perror(""Error: cannot handle SIGUSR1"");
+fprintf(stderr, ""thread_do(): cannot handle SIGUSR1"");
 }
 
 /* Mark thread as alive (initialized) */
 static void jobqueue_destroy(thpool_* thpool_p){
 /* Init semaphore to 1 or 0 */
 static void bsem_init(bsem *bsem_p, int value) {
 if (value < 0 || value > 1) {
-printf(""ERROR: bsem_init(): Binary semaphore can take only values 1 or 0"");
+fprintf(stderr, ""bsem_init(): Binary semaphore can take only values 1 or 0"");
 exit(1);
 }
 bsem_p->v = value;
",310,56
Works now even when compiled with optimization flags," typedef struct thread{
 /* Threadpool */
 typedef struct thpool_{
 thread** threads; /* pointer to threads */
-int num_threads_alive; /* threads currently alive */
-int num_threads_working; /* threads currently working */
+volatile int num_threads_alive; /* threads currently alive */
+volatile int num_threads_working; /* threads currently working */
 pthread_mutex_t thcount_lock; /* used for thread count etc */
 jobqueue* jobqueue_p; /* pointer to the job queue */ 
 } thpool_;
",310,56
Add unit test: run in nonzero heap/stack env.,"
+/*
+ * Try to run thpool with a non-zero heap and stack
+ */
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <pthread.h>
+#include ""../../thpool.h""
+
+
+void task(){
+printf(""Thread #%u working on task\n"", (int)pthread_self());
+}
+
+
+void nonzero_stack(){
+ char buf[40096];
+ memset(buf, 0x80, 40096);
+}
+
+
+void nonzero_heap(){
+
+ int i;
+ void *ptrs[200];
+
+ for (i=0; i<200; i++){
+ ptrs[i] = malloc((i+1) << 4);
+ if (ptrs[i])
+ memset(ptrs[i], 0x80, (i+1) << 4);
+ }
+ for (i=0; i<200; i++){
+ free(ptrs[i]);
+ }
+}
+
+
+int main(){
+
+nonzero_stack();
+nonzero_heap();
+
+puts(""Making threadpool with 4 threads"");
+threadpool thpool = thpool_init(4);
+
+puts(""Adding 20 tasks to threadpool"");
+int i;
+for (i=0; i<20; i++){
+thpool_add_work(thpool, (void*)task, NULL);
+};
+
+puts(""Killing threadpool"");
+thpool_destroy(thpool);
+
+return 0;
+}
",38,8
Fix nonempty heap/stack bug (unit test now passes),"
 #include <signal.h>
 #include <stdio.h>
 #include <stdlib.h>
+#include <string.h>
 #include <pthread.h>
 #include <errno.h>
 #include <time.h> 
 static int jobqueue_init(thpool_* thpool_p){
 if (thpool_p->jobqueue_p == NULL){
 return -1;
 }
+ memset(thpool_p->jobqueue_p, 0, sizeof(struct jobqueue));
 thpool_p->jobqueue_p->has_jobs = (struct bsem*)malloc(sizeof(struct bsem));
+if (thpool_p->jobqueue_p->has_jobs == NULL){
+return -1;
+}
+ memset(thpool_p->jobqueue_p->has_jobs, 0, sizeof(struct bsem));
 bsem_init(thpool_p->jobqueue_p->has_jobs, 0);
 jobqueue_clear(thpool_p);
 return 0;
",316,57
"Add THPOOL_DEBUG define (mandatory for debug msgs)

Added this because some messages are ont designed to be printed
while integrating thpool in an existing project."," struct thpool_* thpool_init(int num_threads){
 int n;
 for (n=0; n<num_threads; n++){
 thread_init(thpool_p, &thpool_p->threads[n], n);
-printf(""Created thread %d in pool \n"", n);
+#ifdef THPOOL_DEBUG
+printf(""THPOOL_DEBUG: Created thread %d in pool \n"", n);
+#endif
 }
 
 /* Wait for threads to initialize */
",317,58
THPOOL_DEBUG moved on top,"
 
 #include ""thpool.h""
 
+#ifdef THPOOL_DEBUG
+#define THPOOL_DEBUG 1
+#else
+#define THPOOL_DEBUG 0
+#endif
+
 #define MAX_NANOSEC 999999999
 #define CEIL(X) ((X-(int)(X)) > 0 ? (int)(X+1) : (int)(X))
 
 struct thpool_* thpool_init(int num_threads){
 int n;
 for (n=0; n<num_threads; n++){
 thread_init(thpool_p, &thpool_p->threads[n], n);
-#ifdef THPOOL_DEBUG
-printf(""THPOOL_DEBUG: Created thread %d in pool \n"", n);
-#endif
+if (THPOOL_DEBUG)
+printf(""THPOOL_DEBUG: Created thread %d in pool \n"", n);
 }
 
 /* Wait for threads to initialize */
",318,58
initilise jobqueue_p->len to 0," static int jobqueue_init(thpool_* thpool_p){
 return -1;
 }
 bsem_init(thpool_p->jobqueue_p->has_jobs, 0);
-
+thpool_p->jobqueue_p->len = 0;
 jobqueue_clear(thpool_p);
 return 0;
 }
",319,58
"Fixes valgrind errors

Syscall param rt_sigaction(act->sa_handler) points to uninitialised byte(s)
Syscall param rt_sigaction(act->sa_flags) points to uninitialised byte(s)"," static void* thread_do(struct thread* thread_p){
 
 /* Register signal handler */
 struct sigaction act;
+sigemptyset(&act.sa_mask);
+act.sa_flags = 0;
 act.sa_handler = thread_hold;
 if (sigaction(SIGUSR1, &act, NULL) == -1) {
 fprintf(stderr, ""thread_do(): cannot handle SIGUSR1"");
",321,58
added some (unlikely required) free()s," struct thpool_* thpool_init(int num_threads){
 thpool_p->threads = (struct thread**)malloc(num_threads * sizeof(struct thread));
 if (thpool_p->threads == NULL){
 fprintf(stderr, ""thpool_init(): Could not allocate memory for threads\n"");
+jobqueue_destroy(thpool_p);
+free(thpool_p->jobqueue_p);
+free(thpool_p);
 return NULL;
 }
 
",323,57
"add thread name, fix warning in the example

thread name is good for both profiling and debuging
also htop can turn on the option 'Show custom thread names' in 'Display
options'
the warning in example is pthread_self [-Wimplicit-function-declaration]","
 * */
 
 #include <stdio.h>
+#include <pthread.h>
 #include ""thpool.h""
 
 
",22,4
Replace prctl w/ pthread_setname_np. Use predefined macros to differ btwn linux and os x.,"
 #include <pthread.h>
 #include <errno.h>
 #include <time.h> 
-#include <sys/prctl.h>
-
 #include ""thpool.h""
 
 #ifdef THPOOL_DEBUG
 static void thread_hold () {
 * @return nothing
 */
 static void* thread_do(struct thread* thread_p){
+
 /* Set thread name for profiling and debuging */
 char thread_name[128] = {0};
 sprintf(thread_name, ""thread-pool-%d"", thread_p->id);
-prctl(PR_SET_NAME, thread_name);
+
+#if defined(__linux__)
+pthread_setname_np(thread_p->pthread, thread_name);
+#elif defined(__APPLE__) && defined(__MACH__)
+pthread_setname_np(thread_name);
+#else
+fprintf(stderr, ""thread_do(): pthread_setname_np is not supported on this system"");
+#endif
 
 /* Assure all threads have been created before starting serving */
 thpool_* thpool_p = thread_p->thpool_p;
",308,53
code style: remove space," struct thpool_* thpool_init(int num_threads){
 threads_on_hold = 0;
 threads_keepalive = 1;
 
-if ( num_threads < 0){
+if (num_threads < 0){
 num_threads = 0;
 }
 
",309,53
"add _GNU_SOURCE for pthread_setname_np, add NULL check for destroy
_GNU_SOURCE: http://man7.org/linux/man-pages/man3/pthread_setname_np.3.html
NULL check: Some programs might get errors while initialization and thus fall to destroy process. This could prevent errors in this situations. Also this check could prevent some rare situations where thpool is free twice.","
 * 
 ********************************/
 
-
+#define _GNU_SOURCE
 #include <unistd.h>
 #include <signal.h>
 #include <stdio.h>
 void thpool_wait(thpool_* thpool_p){
 
 /* Destroy the threadpool */
 void thpool_destroy(thpool_* thpool_p){
-
+/* No need to destory if it's NULL */
+if (thpool_p == NULL) return ;
+
 volatile int threads_total = thpool_p->num_threads_alive;
 
 /* End each thread 's infinite loop */
",310,54
forgot OS dependent macro,"
 * 
 ********************************/
 
+#if defined(__linux__)
 #define _GNU_SOURCE
+#endif
 #include <unistd.h>
 #include <signal.h>
 #include <stdio.h>
",310,54
Use prctl on Linux to follow standard GNU/Linux functions,"
 * 
 ********************************/
 
-#if defined(__linux__)
-#define _GNU_SOURCE
-#endif
 #include <unistd.h>
 #include <signal.h>
 #include <stdio.h>

 #include <pthread.h>
 #include <errno.h>
 #include <time.h> 
+#if defined(__linux__)
+#include <sys/prctl.h>
+#endif
 #include ""thpool.h""
 
 #ifdef THPOOL_DEBUG
 static void* thread_do(struct thread* thread_p){
 sprintf(thread_name, ""thread-pool-%d"", thread_p->id);
 
 #if defined(__linux__)
-pthread_setname_np(thread_p->pthread, thread_name);
+/* Use prctl instead to prevent using _GNU_SOURCE flag and implicit declaration */
+prctl(PR_SET_NAME, thread_name);
 #elif defined(__APPLE__) && defined(__MACH__)
 pthread_setname_np(thread_name);
 #else
",311,54
"Change worker return type to void; add extern C

1. Worker return type void* is not handled, changing to void. 
2. Added extern ""C"" clause to help in C++ integration."," typedef struct bsem {
 /* Job */
 typedef struct job{
 struct job* prev; /* pointer to previous job */
-void* (*function)(void* arg); /* function pointer */
+void (*function)(void* arg); /* function pointer */
 void* arg; /* function's argument */
 } job;
 
 struct thpool_* thpool_init(int num_threads){
 
 
 /* Add work to the thread pool */
-int thpool_add_work(thpool_* thpool_p, void *(*function_p)(void*), void* arg_p){
+int thpool_add_work(thpool_* thpool_p, void (*function_p)(void*), void* arg_p){
 job* newjob;
 
 newjob=(struct job*)malloc(sizeof(struct job));
 static void* thread_do(struct thread* thread_p){
 pthread_mutex_unlock(&thpool_p->thcount_lock);
 
 /* Read job from queue and execute it */
-void*(*func_buff)(void* arg);
-void* arg_buff;
+void (*func_buff)(void* arg);
+void* arg_buff;
 job* job_p;
 pthread_mutex_lock(&thpool_p->jobqueue_p->rwmutex);
 job_p = jobqueue_pull(thpool_p);
",311,54
Small stilistic changes," int main(int argc, char *argv[]){
 
 char* p;
 if (argc != 2){
-puts(""This testfile needs excactly one arguments"");
+puts(""This testfile needs exactly one arguments"");
 exit(1);
 }
 int num_threads = strtol(argv[1], &p, 10);
",17,2
Add API function to get number of working threads," void thpool_resume(thpool_* thpool_p) {
 }
 
 
+int thpool_num_threads_working(thpool_* thpool_p){
+return thpool_p->num_threads_working;
+}
+
+
 
 
 
",314,55
Solve warning about incompatible types," static void* thread_do(struct thread* thread_p){
 pthread_mutex_unlock(&thpool_p->thcount_lock);
 
 /* Read job from queue and execute it */
-void*(*func_buff)(void* arg);
+void (*func_buff)(void*);
 void* arg_buff;
 job* job_p = jobqueue_pull(&thpool_p->jobqueue);
 if (job_p) {
",306,54
Thread name warning should only appear under debug.," static void* thread_do(struct thread* thread_p){
 prctl(PR_SET_NAME, thread_name);
 #elif defined(__APPLE__) && defined(__MACH__)
 pthread_setname_np(thread_name);
-#else
+#elif THPOOL_DEBUG
 fprintf(stderr, ""thread_do(): pthread_setname_np is not supported on this system"");
 #endif
 
",306,55
Fix unused arg gcc warnings.," typedef struct thpool_{
 
 static int thread_init(thpool_* thpool_p, struct thread** thread_p, int id);
 static void* thread_do(struct thread* thread_p);
-static void thread_hold();
+static void thread_hold(int sig_id);
 static void thread_destroy(struct thread* thread_p);
 
 static int jobqueue_init(jobqueue* jobqueue_p);
 void thpool_pause(thpool_* thpool_p) {
 
 /* Resume all threads in threadpool */
 void thpool_resume(thpool_* thpool_p) {
+ (void)thpool_p;
 threads_on_hold = 0;
 }
 
 static int thread_init (thpool_* thpool_p, struct thread** thread_p, int id){
 
 
 /* Sets the calling thread on hold */
-static void thread_hold () {
+static void thread_hold(int sig_id) {
+ (void)sig_id;
 threads_on_hold = 1;
 while (threads_on_hold){
 sleep(1);
",307,54
Add POSIX macro to remove any warnings under strict C compilation,"
 *
 ********************************/
 
+#define _POSIX_C_SOURCE 200809L
 #include <unistd.h>
 #include <signal.h>
 #include <stdio.h>
",305,54
Commented the warning supression in thpool_resume.," void thpool_pause(thpool_* thpool_p) {
 
 /* Resume all threads in threadpool */
 void thpool_resume(thpool_* thpool_p) {
+ // resuming a single threadpool hasn't been
+ // implemented yet, meanwhile this supresses
+ // the warnings
 (void)thpool_p;
+
 threads_on_hold = 0;
 }
 
",307,54
"Update example.c

without the wait the 40 tasks will not have time to complete","
 
 #include <stdio.h>
 #include <pthread.h>
+#include <stdint.h>
 #include ""thpool.h""
 
-
-void task1(){
-printf(""Thread #%u working on task1\n"", (int)pthread_self());
-}
-
-
-void task2(){
-printf(""Thread #%u working on task2\n"", (int)pthread_self());
+void task(void *arg){
+printf(""Thread #%u working on %d\n"", (int)pthread_self(), (int) arg);
 }
 
 
 int main(){
 
 puts(""Adding 40 tasks to threadpool"");
 int i;
-for (i=0; i<20; i++){
-thpool_add_work(thpool, (void*)task1, NULL);
-thpool_add_work(thpool, (void*)task2, NULL);
+for (i=0; i<40; i++){
+thpool_add_work(thpool, (void*)task, (void*)(uintptr_t)i);
 };
 
+thpool_wait(thpool);
 puts(""Killing threadpool"");
 thpool_destroy(thpool);
 
",20,3
"thpool.c:458 ~ 464
modify Remark Message"," static void jobqueue_push(jobqueue* jobqueue_p, struct job* newjob){
 
 
 /* Get first job from queue(removes it from queue)
-<<<<<<< HEAD
- *
 * Notice: Caller MUST hold a mutex
-=======
->>>>>>> da2c0fe45e43ce0937f272c8cd2704bdc0afb490
 */
 static struct job* jobqueue_pull(jobqueue* jobqueue_p){
 
",307,54
"Fixed wrong check for malloc result, as found with cppcheck"," int thpool_num_threads_working(thpool_* thpool_p){
 static int thread_init (thpool_* thpool_p, struct thread** thread_p, int id){
 
 *thread_p = (struct thread*)malloc(sizeof(struct thread));
-if (thread_p == NULL){
+if (*thread_p == NULL){
 err(""thread_init(): Could not allocate memory for thread\n"");
 return -1;
 }
",307,54
"Fix warning at line 285.

It may cant catch the malloc error."," int thpool_num_threads_working(thpool_* thpool_p){
 static int thread_init (thpool_* thpool_p, struct thread** thread_p, int id){
 
 *thread_p = (struct thread*)malloc(sizeof(struct thread));
-if (thread_p == NULL){
+if (*thread_p == NULL){
 err(""thread_init(): Could not allocate memory for thread\n"");
 return -1;
 }
",307,54
"Fix casting of function pointers

Found via -Wpedantic"," int main(){
 puts(""Adding 40 tasks to threadpool"");
 int i;
 for (i=0; i<20; i++){
-thpool_add_work(thpool, (void*)task1, NULL);
-thpool_add_work(thpool, (void*)task2, NULL);
+thpool_add_work(thpool, task1, NULL);
+thpool_add_work(thpool, task2, NULL);
 };
 
 puts(""Killing threadpool"");
",22,4
"Use safe snprintf() instead of sprintf()

The use of sprintf is considered unsafe. And besides being in this case not vulnerable, CI services such as deepcode.ai will send an annoying alert for projects using thpool, as in this example: https://www.deepcode.ai/app/gh/nil0x42/duplicut/47376326b7e1fe987d60d6244ad76b0bb0b4a9e9/_/%2Fsrc%2Fthpool.c/cpp%2Fdc%2FBufferOverflowUnsafeFunction/321/code

The buffer is also bigger than needed: even if `thread_p->id` were to be an uint64_max, the generated string would still fit in 31 bytes (`thread-pool-9223372036854775807`); so buffer was set to 32 bytes instead of 128"," static void thread_hold(int sig_id) {
 static void* thread_do(struct thread* thread_p){
 
 /* Set thread name for profiling and debuging */
-char thread_name[128] = {0};
-sprintf(thread_name, ""thread-pool-%d"", thread_p->id);
+char thread_name[32] = {0};
+snprintf(thread_name, 32, ""thread-pool-%d"", thread_p->id);
 
 #if defined(__linux__)
 /* Use prctl instead to prevent using _GNU_SOURCE flag and implicit declaration */
",307,54
"Initial commit of the FlatBuffers code.

Change-Id: I4c9f0f722490b374257adb3fec63e44ae93da920
Tested: using VS2010 / Xcode / gcc on Linux.","
+/*
+ * Copyright 2014 Google Inc. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <android_native_app_glue.h>
+
+extern int main(int argc, char **argv);
+
+void android_main(android_app *app) {
+ // Make sure glue isn't stripped.
+ app_dummy();
+
+ main(0, NULL);
+}
",6,1
"Added project files for Visual Studio and Xcode.

Change-Id: Ife9775fdedc9e084c1e826ef13dff06a1b1b2ec2
Tested: on Windows and OS X."," static void GenStruct(StructDef &struct_def, std::string *code_ptr) {
 
 // Iterate through all definitions we haven't generate code for (enums, structs,
 // and tables) and output them to a single file.
-static std::string GenerateCPP(const Parser &parser) {
+std::string GenerateCPP(const Parser &parser) {
 using namespace cpp;
 
 // Generate code for all the enum declarations.
",282,70
"Fixed the web pages not scrolling by regenerating with doxygen.

Change-Id: Id1269f85ec2f522c8d4b0d05f84d050b42d70d60
Tested: on Android"," function initResizable()
 var _preventDefault = function(evt) { evt.preventDefault(); };
 $(""#splitbar"").bind(""dragstart"", _preventDefault).bind(""selectstart"", _preventDefault);
 $(document).bind('touchmove',function(e){
- try {
- var target = e.target;
- while (target) {
- if ($(target).css('-webkit-overflow-scrolling')=='touch') return;
- target = target.parentNode;
+ var device = navigator.userAgent.toLowerCase();
+ var ios = device.match(/(iphone|ipod|ipad)/);
+ if (ios) {
+ try {
+ var target = e.target;
+ while (target) {
+ if ($(target).css('-webkit-overflow-scrolling')=='touch') return;
+ target = target.parentNode;
+ }
+ e.preventDefault();
+ } catch(err) {
+ e.preventDefault();
 }
- e.preventDefault();
- } catch(err) {
- e.preventDefault();
 }
 });
 }
",89,21
"Fixed a bug in the Java code generation that would generate the wrong identifier in some cases.
Also added a safety check for buffers growing past 2 gigabytes.

Change-Id: I2bca7159f606cf1c08c4391e88ef9b4c8363be06
Tested: With the Java sdk."," public class FlatBufferBuilder {
 ByteBuffer growByteBuffer(ByteBuffer bb) {
 byte[] old_buf = bb.array();
 int old_buf_size = old_buf.length;
- int new_buf_size = old_buf_size * 2;
+ if ((old_buf_size & 0xC0000000) != 0)
+ throw new AssertionError(""FlatBuffers: cannot grow buffer beyond 2 gigabytes."");
+ int new_buf_size = old_buf_size << 1;
 byte[] new_buf = new byte[new_buf_size];
 System.arraycopy(old_buf, 0, new_buf, new_buf_size - old_buf_size, old_buf_size);
 ByteBuffer nbb = newByteBuffer(new_buf);
",165,60
Fix compilation with VS 2013 missing header,"
 #include <string>
 #include <type_traits>
 #include <vector>
+#include <algorithm>
 
 #if __cplusplus <= 199711L && \
 (!defined(_MSC_VER) || _MSC_VER < 1600) && \
",395,106
"Fixed various compiler warnings (most related to a 64bit size_t).

Change-Id: Ic2e0565ebc5243fc0be780bfbcb221d5170569fd
Tested: on VS2010"," void TestEq(T expval, U val, const char *exp, const char *file, int line) {
 }
 }
 
-#define TEST_EQ(exp, val) TestEq( exp, val, #exp, __FILE__, __LINE__)
-#define TEST_NOTNULL(exp) TestEq(!exp, false, #exp, __FILE__, __LINE__)
+#define TEST_EQ(exp, val) TestEq(exp, val, #exp, __FILE__, __LINE__)
+#define TEST_NOTNULL(exp) TestEq(exp == NULL, false, #exp, __FILE__, __LINE__)
 
 // Include simple random number generator to ensure results will be the
 // same cross platform.
",307,61
"Fixed bug that caused creating 0-length arrays to crash

Change-Id: Ibb0da5b57a2f63804c071863d8c60b845e0aece7
Tested: on Windows"," class FlatBufferBuilder {
 template<typename T> Offset<Vector<T>> CreateVector(const T *v, size_t len) {
 NotNested();
 StartVector(len, sizeof(T));
- auto i = len;
- do {
+ for (auto i = len; i > 0; ) {
 PushElement(v[--i]);
- } while (i);
+ }
 return Offset<Vector<T>>(EndVector(len));
 }
 
",394,106
"force_align was applied after struct size was set.

Change-Id: I9a35afac41f27dfdbc5e793c41ec768732cdc2a1
Tested: on Windows."," void Parser::ParseDecl() {
 struct_def.attributes.Lookup(""original_order"") == nullptr && !fixed;
 Expect('{');
 while (token_ != '}') ParseField(struct_def);
- struct_def.PadLastField(struct_def.minalign);
- Expect('}');
 auto force_align = struct_def.attributes.Lookup(""force_align"");
 if (fixed && force_align) {
 auto align = static_cast<size_t>(atoi(force_align->constant.c_str()));
 void Parser::ParseDecl() {
 ""struct\'s natural alignment to 256"");
 struct_def.minalign = align;
 }
+ struct_def.PadLastField(struct_def.minalign);
+ Expect('}');
 }
 
 bool Parser::SetRootType(const char *name) {
",581,185
"JSON text output now optionally doesn't output linefeeds either.

Change-Id: Iedac80ee00b27a97c21c7b4ac7c9792e5bafbcc8
Tested: On Windows"," class Parser {
 
 // Generate text (JSON) from a given FlatBuffer, and a given Parser
 // object that has been populated with the corresponding schema.
+// If ident_step is 0, no indentation will be generated. Additionally,
+// if it is less than 0, no linefeeds will be generated either.
 // See idl_gen_text.cpp.
 extern void GenerateText(const Parser &parser,
 const void *flatbuffer,
",184,33
"Generated C++ headers now have include guards.

Bug: 15700355
Change-Id: Iceccb5b344e394e399092ffaa81f9cad2f0418ab
Tested: on Windows"," extern void GenerateText(const Parser &parser,
 
 // Generate a C++ header from the definitions in the Parser object.
 // See idl_gen_cpp.
-extern std::string GenerateCPP(const Parser &parser);
+extern std::string GenerateCPP(const Parser &parser,
+ const std::string &include_guard_ident);
 extern bool GenerateCPP(const Parser &parser,
 const std::string &path,
 const std::string &file_name);
",185,33
"Switched VS build to -W4, and fixed all resulting warnings.

Change-Id: I654217cbd01a3a449503d95753e19b672ec7ec23
Tested: on Windows, Linux"," class Verifier {
 }
 return true;
 }
-
+ 
 // Verify this whole buffer, starting with root type T.
 template<typename T> bool VerifyBuffer() const {
 // Call T::Verify, which must be in the generated code for this type.
",465,131
"Fixed a bugs in the Java runtime that could cause an index out of bounds exception.

Tested: on Windows.

Change-Id: I0d4cdafc21690eb9a509ba31f21e80dacfb602ff"," class JavaTest {
 TestBuffer(bb, 0);
 
 // Second, let's create a FlatBuffer from scratch in Java, and test it also.
- // We set up the same values as monsterdata.json:
+ // We use an initial size of 1 to exercise the reallocation algorithm,
+ // normally a size larger than the typical FlatBuffer you generate would be
+ // better for performance.
+ FlatBufferBuilder fbb = new FlatBufferBuilder(1);
 
- FlatBufferBuilder fbb = new FlatBufferBuilder(1024);
+ // We set up the same values as monsterdata.json:
 
 int str = fbb.createString(""MyMonster"");
 
",92,8
"Fixed flatc not stripping the path from the base filename.

This caused two bugs when used with a path: not being able to save
the generated files, and preprocessor defines with / characters in
them.

Bug: 15676771

Tested: on Windows

Change-Id: I62a3c45d22e2545fdaad83728d83a42a6efa37f9"," std::string StripExtension(const std::string &filename) {
 return i != std::string::npos ? filename.substr(0, i) : filename;
 }
 
+std::string StripPath(const std::string &filename) {
+ size_t i = filename.find_last_of(
+ #ifdef WIN32
+ ""\\:""
+ #else
+ ""/""
+ #endif
+ );
+ return i != std::string::npos ? filename.substr(i + 1) : filename;
+}
+
 int main(int argc, const char *argv[]) {
 program_name = argv[0];
 flatbuffers::Parser parser;
 int main(int argc, const char *argv[]) {
 if (!parser.Parse(contents.c_str()))
 Error(parser.error_.c_str());
 
- std::string filebase = StripExtension(*file_it);
+ std::string filebase = StripPath(StripExtension(*file_it));
 
 for (size_t i = 0; i < num_generators; ++i) {
 if (generator_enabled[i]) {
",144,33
"Fixed helper function CreateVectorOfStructs calling wrong variant.

Change-Id: I4fd2a309276590227921ede467503f56b65ac689
Tested: on Windows and Linux"," class FlatBufferBuilder {
 
 template<typename T> Offset<Vector<const T *>> CreateVectorOfStructs(
 const std::vector<T> &v) {
- return CreateVector(&v[0], v.size());
+ return CreateVectorOfStructs(&v[0], v.size());
 }
 
 // Finish serializing a buffer by writing the root offset.
 class Verifier {
 }
 return true;
 }
- 
+
 // Verify this whole buffer, starting with root type T.
 template<typename T> bool VerifyBuffer() const {
 // Call T::Verify, which must be in the generated code for this type.
",465,131
"Made declaring the underlying type of an enum mandatory.

This is a breaking change, anyone having schema files with enums
that do not specify a type will get a specialized error:

must specify the underlying integer type for this
enum (e.g. ': short', which was the default).

All of the samples and docs already had a type specified,
so hopefully this will affect very few people.

Bug: 15777205
Change-Id: I9b8d7c0827867f7efb6c217346db7e402695eff0
Tested: on Windows"," void Parser::ParseEnum(bool is_union) {
 if (is_union) {
 enum_def.underlying_type.base_type = BASE_TYPE_UTYPE;
 enum_def.underlying_type.enum_def = &enum_def;
- } else if (IsNext(':')) {
- // short is the default type for fields when you use enums,
- // though people are encouraged to pick any integer type instead.
+ } else {
+ // Give specialized error message, since this type spec used to
+ // be optional in the first FlatBuffers release.
+ if (!IsNext(':')) Error(""must specify the underlying integer type for this""
+ "" enum (e.g. \': short\', which was the default)."");
+ // Specify the integer type underlying this enum.
 ParseType(enum_def.underlying_type);
 if (!IsInteger(enum_def.underlying_type.base_type))
 Error(""underlying enum type must be integral"");
- } else {
- enum_def.underlying_type.base_type = BASE_TYPE_SHORT;
 }
 ParseMetaData(enum_def);
 Expect('{');
",581,185
"Added a ""strict JSON"" mode to the text generator and compiler

This will add quotes around field names, as required by the official
standard. By default it will leave quotes out, as it is more readable,
more compact, and is accepted by almost all JSON parsers.
The -S switch to flatc turns on strict mode.

As per rfc 7159.

Change-Id: Ibabe9c8162c47339d00ec581d18721a2ba40c6d0
Tested: on Windows."," int main(int /*argc*/, const char * /*argv*/[]) {
 // to ensure it is correct, we now generate text back from the binary,
 // and compare the two:
 std::string jsongen;
- GenerateText(parser, parser.builder_.GetBufferPointer(), 2, &jsongen);
+ GenerateText(parser, parser.builder_.GetBufferPointer(),
+ flatbuffers::GeneratorOptions(), &jsongen);
 
 if (jsongen != jsonfile) {
 printf(""%s----------------\n%s"", jsongen.c_str(), jsonfile.c_str());
",25,5
"Fixed vectors reserving wrong amount of space in Java.

In the generated code, the type of the vector was used for
the element size, instead of the vector element type.

Change-Id: Ie16d5221a61474365292c948fd3af99e2a7716c7
Tested: on Windows."," static void GenStruct(StructDef &struct_def,
 code += "" public static void start"" + MakeCamel(field.name);
 code += ""Vector(FlatBufferBuilder builder, int numElems) "";
 code += ""{ builder.startVector("";
- code += NumToString(InlineSize(field.value.type));
+ code += NumToString(InlineSize(field.value.type.VectorType()));
 code += "", numElems); }\n"";
 }
 }
",314,71
"Fixed incorrect verifier code for nested tables.

It was outputting the type instead of the field name, and didn't deal
with NULL fields. Added test case.

Also fixed token enums having the wrong value, resulting in
unreadable error messages.

Change-Id: Icd9b4d22f417bfad5824c0f58e067ce3f2e2dc6f
Tested: on Windows and Linux."," class Verifier {
 return Verify(elem, sizeof(T));
 }
 
+ // Verify a pointer (may be NULL) of a table type.
+ template<typename T> bool VerifyTable(const T *table) const {
+ return !table || table->Verify(*this);
+ }
+
 // Verify a pointer (may be NULL) of any vector type.
 template<typename T> bool Verify(const Vector<T> *vec) const {
 const uint8_t *end;
",468,133
"Fixed namespace declaration not being cleared between files.

Change-Id: Ie9fedf894d82a403d0b6b4848d221d6bbee58984
Tested: on OS X."," bool Parser::Parse(const char *source) {
 while (token_ != kTokenEof) {
 if (token_ == kTokenNameSpace) {
 Next();
+ name_space_.clear();
 for (;;) {
 name_space_.push_back(attribute_);
 Expect(kTokenIdentifier);
",617,195
"Parser now correctly reads floats in scientific notation.

Change-Id: I7abb14a4b6c596674d6aff2b9de6e63603c0d2dc
Tested: on Windows and Linux."," void Parser::Next() {
 if (*cursor_ == '.') {
 cursor_++;
 while (isdigit(static_cast<unsigned char>(*cursor_))) cursor_++;
+ // See if this float has a scientific notation suffix. Both JSON
+ // and C++ (through strtod() we use) have the same format:
+ if (*cursor_ == 'e' || *cursor_ == 'E') {
+ cursor_++;
+ if (*cursor_ == '+' || *cursor_ == '-') cursor_++;
+ while (isdigit(static_cast<unsigned char>(*cursor_))) cursor_++;
+ }
 token_ = kTokenFloatConstant;
 } else {
 token_ = kTokenIntegerConstant;
",622,200
"The generated CreateX() calls now come with default values for args.

bug: 15777627
Change-Id: I9389de46ea883ab0ef1beab9370e5c8e96b4d0b5
Tested: on Windows and Linux"," static void GenTable(StructDef &struct_def, std::string *code_ptr) {
 ++it) {
 auto &field = **it;
 if (!field.deprecated) {
- code += "", "" + GenTypeWire(field.value.type, "" "") + field.name;
+ code += "",\n "" + GenTypeWire(field.value.type, "" "") + field.name;
+ code += "" = "" + field.value.constant;
 }
 }
 code += "") {\n "" + struct_def.name + ""Builder builder_(_fbb);\n"";
",384,87
"Made Java argument names help remind the user when something is an offset.

Bug: 15856217
Change-Id: I9163d13ca26c2d53064f5289c993692be711685f
Tested: on Windows"," static void GenStruct(StructDef &struct_def,
 if (field.deprecated) continue;
 code += "" public static void add"" + MakeCamel(field.name);
 code += ""(FlatBufferBuilder builder, "" + GenTypeBasic(field.value.type);
- code += "" "" + MakeCamel(field.name, false) + "") { builder.add"";
+ auto argname = MakeCamel(field.name, false);
+ if (!IsScalar(field.value.type.base_type)) argname += ""Offset"";
+ code += "" "" + argname + "") { builder.add"";
 code += GenMethod(field) + ""("";
 code += NumToString(it - struct_def.fields.vec.begin()) + "", "";
- code += MakeCamel(field.name, false) + "", "" + field.value.constant;
+ code += argname + "", "" + field.value.constant;
 code += ""); }\n"";
 if (field.value.type.base_type == BASE_TYPE_VECTOR) {
 code += "" public static void start"" + MakeCamel(field.name);
",316,72
"flatc can now convert flatbuffer binary files into json.

Also removed it appending _wire to filenames, renamed the json golden
file to .golden to not clash with generated files.

Bug: 15781201
Change-Id: I8322861e50d1e5b6a5ab5e4b5e5d8ae13c356eb2
Tested: on Windows and Linux"," class JavaTest {
 // This file was generated from monsterdata_test.json
 
 byte[] data = null;
- File file = new File(""monsterdata_test_wire.bin"");
+ File file = new File(""monsterdata_test.bin"");
 RandomAccessFile f = null;
 try {
 f = new RandomAccessFile(file, ""r"");
",92,8
"Port FlatBuffers to Go.

Implement code generation and runtime library for Go, derived from the
Java implementation. Additionally, the test suite verifies:

 - the exact bytes in the Builder buffer during object construction,
 - vtable deduplication, and
 - table construction, via a fuzzer derived from the C++ implementation.

Change-Id: Ib95a019c684891def2b50281e570b4843fea7baa"," var NAVTREE =
 [ ""Using the schema compiler"", ""md__compiler.html"", null ],
 [ ""Writing a schema"", ""md__schemas.html"", null ],
 [ ""Use in C++"", ""md__cpp_usage.html"", null ],
+ [ ""Use in Go"", ""md__go_usage.html"", null ],
 [ ""Use in Java"", ""md__java_usage.html"", null ],
 [ ""Benchmarks"", ""md__benchmarks.html"", null ],
 [ ""FlatBuffers white paper"", ""md__white_paper.html"", null ],
",505,121
"Small fixes to the core C++ FlatBuffers implementation.

- Ensured weak linkage with the version string is not used on Windows,
 especially cygwin (which throws a linker error).
- Avoided a VS debug error for taking the address of the first element
 of an empty vector.
- Made copy/assignment constructors for downward_vector and
 FlatBufferBuilder private, to avoid people unintentionally making
 expensive copies.
- Using the more correct _WIN32 instead of WIN32

Change-Id: I801b5c8b159e3721af6d1ef0978a3247ba168bab
Tested: on Windows (VS + Cygwin) and Linux."," std::string StripExtension(const std::string &filename) {
 
 std::string StripPath(const std::string &filename) {
 size_t i = filename.find_last_of(
- #ifdef WIN32
+ #ifdef _WIN32
 ""\\:""
 #else
 ""/""
",170,37
"A feature that officially supports nested FlatBuffers.

Generates convenient accessors for the nested root.

Change-Id: Ic0b1531de7ace475ff2a7b1f430d27f41c838430
Tested: on Windows."," public:
 iterator end() { return iterator(Data(), length_); }
 const_iterator end() const { return const_iterator(Data(), length_); }
 
+ // The raw data in little endian format. Use with care.
+ const uint8_t *Data() const {
+ return reinterpret_cast<const uint8_t *>(&length_ + 1);
+ }
+
 protected:
 // This class is only used to access pre-existing data. Don't ever
 // try to construct these manually.
 Vector();
 
- const uint8_t *Data() const {
- return reinterpret_cast<const uint8_t *>(&length_ + 1);
- }
-
 uoffset_t length_;
 };
 
",527,149
"Added a `bit_flags` attribute to enum declarations that 1<<N every value.

Change-Id: Ib9ec0cb3ddec60b1ca124eaf815fb1ae0cc53e1c
Tested: on Windows and Linux
Bug: 16186562"," static void EscapeString(const String &s, std::string *_text) {
 text += c;
 } else {
 auto u = static_cast<unsigned char>(c);
- text += ""\\x"" + IntToStringHex(u);
+ text += ""\\x"";
+ text += IntToStringHex(u);
 }
 break;
 }
",189,39
"Corrected the order of the comments on namespace close parens

Also removed the semicolon on the bracket. It makes -pedanic unhappy.

Bug: 16399323
Change-Id: I16ec0d67af13c3ca0bc6285741f5a95658d262bd"," std::string GenerateCPP(const Parser &parser, const std::string &include_guard_i
 }
 
 // Close the namespaces.
- for (auto it = parser.name_space_.begin();
- it != parser.name_space_.end(); ++it) {
- code += ""}; // namespace "" + *it + ""\n"";
+ for (auto it = parser.name_space_.rbegin();
+ it != parser.name_space_.rend(); ++it) {
+ code += ""} // namespace "" + *it + ""\n"";
 }
 
 // Close the include guard.
",393,88
"Terminate the output directory argument of flatc.

Given the command

flatc -o . -c test.fbs

it would generate header file

.test_generated.h

rather than

./test_generated.h

This fixes this issue.

Tested:
Manually verified that flatc generates the correct output files given output
paths ending with and without '/' on Linux and Windows.

Bug: 16464827
Change-Id: I854cb881286f22690f1885f942cf3fd2fc59ca8d","
 
 namespace flatbuffers {
 
+static const char kPosixPathSeparator = '/';
+#ifdef _WIN32
+static const char kPathSeparator = '\\';
+#else
+static const char kPathSeparator = kPosixPathSeparator;
+#endif // _WIN32
+
 // Convert an integer or floating point value to a string.
 // In contrast to std::stringstream, ""char"" values are
 // converted to a string of digits.
",51,13
"Fixed possible compile error in CreateVector* functions.

Change-Id: I3b1fca2ea536349240b7bee35eff360f3acbb539
Tested: on Windows and Linux."," class FlatBufferBuilder {
 }
 
 template<typename T> Offset<Vector<T>> CreateVector(const std::vector<T> &v){
- return CreateVector(v.begin(), v.size());
+ return CreateVector(v.data(), v.size());
 }
 
 template<typename T> Offset<Vector<const T *>> CreateVectorOfStructs(
 class FlatBufferBuilder {
 
 template<typename T> Offset<Vector<const T *>> CreateVectorOfStructs(
 const std::vector<T> &v) {
- return CreateVectorOfStructs(v.begin(), v.size());
+ return CreateVectorOfStructs(v.data(), v.size());
 }
 
 // Finish serializing a buffer by writing the root offset.
",530,150
"Extended symbolic enum parsing in JSON for integers and OR-ing.

Change-Id: Iedbd9914a1ca3897776fb92aa9a1fdfc4603da3c
Tested: on Windows and Linux"," inline size_t InlineAlignment(const Type &type) {
 }
 
 struct EnumVal {
- EnumVal(const std::string &_name, int _val)
+ EnumVal(const std::string &_name, int64_t _val)
 : name(_name), value(_val), struct_def(nullptr) {}
 
 std::string name;
 std::string doc_comment;
- int value;
+ int64_t value;
 StructDef *struct_def; // only set if this is a union
 };
 
 class Parser {
 void ParseMetaData(Definition &def);
 bool TryTypedValue(int dtoken, bool check, Value &e, BaseType req);
 void ParseSingleValue(Value &e);
+ int64_t ParseIntegerFromString(Type &type);
 StructDef *LookupCreateStruct(const std::string &name);
 void ParseEnum(bool is_union);
 void ParseDecl();
",212,28
"Fix OS X build

Change-Id: If0465b73843ad1a489fa66318a689801def3f0f0"," class vector_downward {
 
 void clear() { cur_ = buf_ + reserved_; }
 
- size_t growth_policy(size_t size) {
- return (size / 2) & ~(sizeof(largest_scalar_t) - 1);
+ size_t growth_policy(size_t bytes) {
+ return (bytes / 2) & ~(sizeof(largest_scalar_t) - 1);
 }
 
 uint8_t *make_space(size_t len) {
 class vector_downward {
 
 // push() & fill() are most frequently called with small byte counts (<= 4),
 // which is why we're using loops rather than calling memcpy/memset.
- void push(const uint8_t *bytes, size_t size) {
- auto dest = make_space(size);
- for (size_t i = 0; i < size; i++) dest[i] = bytes[i];
+ void push(const uint8_t *bytes, size_t num) {
+ auto dest = make_space(num);
+ for (size_t i = 0; i < num; i++) dest[i] = bytes[i];
 }
 
 void fill(size_t zero_pad_bytes) {
",530,150
"Enum definitions are generated without a trailing comma (-pedantic).

Change-Id: I07cd28e5915a0526614db85f894f27a5bd27f3bb
Tested: on Windows."," static void GenComment(const std::string &dc,
 auto &ev = **it;
 GenComment(ev.doc_comment, code_ptr, "" "");
 code += "" "" + enum_def.name + ""_"" + ev.name + "" = "";
- code += NumToString(ev.value) + "",\n"";
+ code += NumToString(ev.value);
+ code += (it + 1) != enum_def.vals.vec.end() ? "",\n"" : ""\n"";
 }
 code += ""};\n\n"";
 
",394,89
"Made FlatBuffers compile correctly with -pedantic

Change-Id: I88b5993219e10e2dfb60ff98d6594d19871988fc
Tested: on Linux"," inline int LookupEnum(const char **names, const char *name) {
 struct __declspec(align(alignment))
 #define STRUCT_END(name, size) \
 __pragma(pack()); \
- static_assert(sizeof(name) == size, ""compiler breaks packing rules"");
+ static_assert(sizeof(name) == size, ""compiler breaks packing rules"")
 #elif defined(__GNUC__) || defined(__clang__)
 #define MANUALLY_ALIGNED_STRUCT(alignment) \
- _Pragma(""pack(1)""); \
+ _Pragma(""pack(1)"") \
 struct __attribute__((aligned(alignment)))
 #define STRUCT_END(name, size) \
- _Pragma(""pack()""); \
- static_assert(sizeof(name) == size, ""compiler breaks packing rules"");
+ _Pragma(""pack()"") \
+ static_assert(sizeof(name) == size, ""compiler breaks packing rules"")
 #else
 #error Unknown compiler, please define structure alignment macros
 #endif
",530,150
"Fixed bugs that could cause struct values not to be stored or misaligned

Change-Id: Ie36fe581c000fa4571c96fafd39a9e12fa29e1ca
Tested: on Linux"," class FlatBufferBuilder {
 template<typename T> Offset<Vector<const T *>> CreateVectorOfStructs(
 const T *v, size_t len) {
 NotNested();
- StartVector(len, AlignOf<T>());
+ StartVector(len * sizeof(T) / AlignOf<T>(), AlignOf<T>());
 PushBytes(reinterpret_cast<const uint8_t *>(v), sizeof(T) * len);
 return Offset<Vector<const T *>>(EndVector(len));
 }
",530,150
"File identifier feature.

Allows you to add, and test for the presence of a magic 4-char
string in a FlatBuffer.

Tested: on OS X.

Change-Id: I090692a9e4fb53bed3543279a28563e67132cba0"," class Parser {
 
 FlatBufferBuilder builder_; // any data contained in the file
 StructDef *root_struct_def;
+ std::string file_identifier_;
+ std::string file_extension_;
 
 private:
 const char *source_, *cursor_;
",215,28
"Fix vector of strings for Java

Change-Id: If032b450230b15224b2661836c8a740398d207c5"," public class Table {
 
 // Create a java String from UTF-8 data stored inside the flatbuffer.
 protected String __string(int offset) {
- offset += bb_pos;
 offset += bb.getInt(offset);
 return new String(bb.array(), offset + SIZEOF_INT, bb.getInt(offset), Charset.forName(""UTF-8""));
 }
",35,7
"Fixed compile warning related to file identification feature.

Change-Id: Id33cf778caa818c7d3988edee82058e63bfecbf0
Tested: on Linux"," class FlatBufferBuilder {
 return CreateVectorOfStructs(v.data(), v.size());
 }
 
- static const int kFileIdentifierLength = 4;
+ static const size_t kFileIdentifierLength = 4;
 
 // Finish serializing a buffer by writing the root offset.
 // If a file_identifier is given, the buffer will be prefix with a standard
",542,153
"Parser now allows empty tables in JSON

Bug: 16870719
Change-Id: Ia5fdce49a67b1aa621ab1e37a815e2a3293257b6
Tested: on Linux"," static void GenStruct(const StructDef &struct_def, const Table *table,
 std::string *_text) {
 std::string &text = *_text;
 text += ""{"";
- text += NewLine(opts.indent_step);
 int fieldout = 0;
 StructDef *union_sd = nullptr;
 for (auto it = struct_def.fields.vec.begin();
 static void GenStruct(const StructDef &struct_def, const Table *table,
 // The field is present.
 if (fieldout++) {
 text += "","";
- text += NewLine(opts.indent_step);
 }
+ text += NewLine(opts.indent_step);
 text.append(indent + opts.indent_step, ' ');
 OutputIdentifier(fd.name, opts, _text);
 text += "": "";
",188,39
"Made the assert in the verifier optional

Change-Id: Ie6b0a8e137a0743bbf18531f29712cf5f11bf34f
Tested: on Linux"," class Verifier {
 // Verify any range within the buffer.
 bool Verify(const void *elem, size_t elem_len) const {
 bool ok = elem >= buf_ && elem <= end_ - elem_len;
- assert(ok);
+ #ifdef FLATBUFFERS_DEBUG_VERIFICATION_FAILURE
+ assert(ok);
+ #endif
 return ok;
 }
 
",542,154
"Fixed possible alignment issue in Java

Tested: on Linux

Change-Id: Ie80aa19ed13ac4fa15cd3fd768f1a35526bdc607"," public class FlatBufferBuilder {
 putInt(off);
 }
 
- public void startVector(int elem_size, int num_elems) {
+ public void startVector(int elem_size, int num_elems, int alignment) {
 notNested();
 vector_num_elems = num_elems;
 prep(SIZEOF_INT, elem_size * num_elems);
+ prep(alignment, elem_size * num_elems); // Just in case alignment > int.
 }
 
 public int endVector() {
 public class FlatBufferBuilder {
 public int createString(String s) {
 byte[] utf8 = s.getBytes(utf8charset);
 addByte((byte)0);
- startVector(1, utf8.length);
+ startVector(1, utf8.length, 1);
 System.arraycopy(utf8, 0, bb.array(), space -= utf8.length, utf8.length);
 return endVector();
 }
",170,62
"Fixed ""unused private field"" warning for clang.

Bug: 17095037
Change-Id: Iedbe56f6ddc0ba7876896b0bb7ed9da8e6a85f7e
Tested: on Linux & OS X."," static void GenStruct(StructDef &struct_def, std::string *code_ptr) {
 if (field.padding)
 code += "", __padding"" + NumToString(padding_id++) + ""(0)"";
 }
- code += "" {}\n\n"";
+ code += "" {"";
+ padding_id = 0;
+ for (auto it = struct_def.fields.vec.begin();
+ it != struct_def.fields.vec.end();
+ ++it) {
+ auto &field = **it;
+ if (field.padding)
+ code += "" (void)__padding"" + NumToString(padding_id++) + "";"";
+ }
+ code += "" }\n\n"";
 
 // Generate accessor methods of the form:
 // type name() const { return flatbuffers::EndianScalar(name_); }
",415,93
"Schemas now support include files.

Bug: 15521443
Change-Id: I2e1ef97e7225a1a0ecf2ca65e31d49d443003747
Tested: on Linux."," class Parser {
 
 // Parse the string containing either schema or JSON data, which will
 // populate the SymbolTable's or the FlatBufferBuilder above.
- bool Parse(const char *_source);
+ // filepath indicates the file that _source was loaded from, it is
+ // used to resolve any include statements.
+ bool Parse(const char *_source, const char *filepath);
 
 // Set the root type. May override the one set in the schema.
 bool SetRootType(const char *name);
 
+ // Mark all definitions as already having code generated.
+ void MarkGenerated();
+
 private:
 void Next();
 bool IsNext(int t);
 class Parser {
 
 std::vector<std::pair<Value, FieldDef *>> field_stack_;
 std::vector<uint8_t> struct_stack_;
+ std::map<std::string, bool> included_files_;
 };
 
 // Utility functions for generators:
",217,28
"Referring to types from other namespaces in C++ now works correctly.

Previously, it would ignore the fact that the type comes from a
different namespace. Now they are pre-declared in their own namespace,
and referenced with a qualified name if necessary.

Bug: 16851682
Change-Id: I5cb625b86d28e7436b9e93c70a0fa16a600d9884
Tested: on Linux"," StructDef *Parser::LookupCreateStruct(const std::string &name) {
 structs_.Add(name, struct_def);
 struct_def->name = name;
 struct_def->predecl = true;
+ struct_def->defined_namespace = namespaces_.back();
 }
 return struct_def;
 }
 bool Parser::Parse(const char *source, const char *filepath) {
 while (token_ != kTokenEof) {
 if (token_ == kTokenNameSpace) {
 Next();
- name_space_.clear();
+ auto ns = new Namespace();
+ namespaces_.push_back(ns);
 for (;;) {
- name_space_.push_back(attribute_);
+ ns->components.push_back(attribute_);
 Expect(kTokenIdentifier);
 if (!IsNext('.')) break;
 }
",725,232
"Fixed warnings for unused variables in Visual Studio.

Change-Id: I51eeed20c3e0a4914280bf33585ca03b9a9952aa
Tested: on Windows."," int main(int /*argc*/, const char * /*argv*/[]) {
 auto pos = monster->pos();
 assert(pos);
 assert(pos->z() == 3);
+ (void)pos;
 
 auto inv = monster->inventory();
 assert(inv);
 assert(inv->Get(9) == 9);
+ (void)inv;
 }
 
",25,1
"Support all JSON escape codes (including \u) for parsing & text gen.

Bug: 16624362
Change-Id: Ia09ea404c0c11dd1dc6993a8cbd155bf8152b65f
Tested: on Windows & Linux."," class Parser {
 void MarkGenerated();
 
 private:
+ int64_t ParseHexNum(int nibbles);
 void Next();
 bool IsNext(int t);
 void Expect(int t);
",230,30
"flatc now creates the output directory if it doesn't exist yet.

Also cleaned up the general mkdir functionality.

Tested: on OS X.

Tested that a command line like: ./flatc -j -o foo/bar/baz tests/monster_test.fbs
generates files in foo/bar/baz/MyGame/Example/*.java which previously didn't exist.

Windows code was previously tested but has been moved, so needs to be tested again.

Change-Id: Iee943121b3be4f92961a3ec94c2cb578165f114a"," int main(int argc, const char *argv[]) {
 
 for (size_t i = 0; i < num_generators; ++i) {
 if (generator_enabled[i]) {
+ flatbuffers::EnsureDirExists(output_path);
 if (!generators[i].generate(parser, output_path, filebase, opts)) {
 Error((std::string(""Unable to generate "") +
 generators[i].name +
",159,33
"Checking for clashes between field names and generated field names.

This happens when the schema is parsed, to avoid compile time errors
later, which would be harder to understand.

Bug: 16325216
Change-Id: I24cabf1adaf1700796b91e3a9641bca43a68bfbd
Tested: on OS X."," void ErrorTest() {
 TestError(""struct X { Y:int; } root_type X;"", ""a table"");
 TestError(""union X { Y }"", ""referenced"");
 TestError(""union Z { X } struct X { Y:int; }"", ""only tables"");
+ TestError(""table X { Y:[int]; YLength:int; }"", ""clash"");
 }
 
 // Additional parser testing not covered elsewhere.
",371,67
"The list of enum values is now allowed to end in a comma.

Bug: 16490424
Change-Id: Ic3dd5f06efb5cf2dc4aefbd3f2db64c7b59b6b93
Tested: on OS X."," void Parser::ParseEnum(bool is_union) {
 if (prevsize && enum_def.vals.vec[prevsize - 1]->value >= ev.value)
 Error(""enum values must be specified in ascending order"");
 }
- } while (IsNext(','));
+ } while (IsNext(',') && token_ != '}');
 Expect('}');
 if (enum_def.attributes.Lookup(""bit_flags"")) {
 for (auto it = enum_def.vals.vec.begin(); it != enum_def.vals.vec.end();
",769,248
"flatc now outputs the filename with error messages.

Bug: 16683956
Change-Id: Id8435e868899ca0bbf0add84852a54bfaea63b4a
Tested: on OS X."," int main(int argc, const char *argv[]) {
 contents.length());
 } else {
 if (!parser.Parse(contents.c_str(), file_it->c_str()))
- Error(parser.error_.c_str());
+ Error((*file_it + "": "" + parser.error_).c_str());
 }
 
 std::string filebase = flatbuffers::StripPath(
",159,33
"Prefixing of enum value identifiers in C++ is now optional.

See -P option to flatc.

Bug: 16814856
Change-Id: I855973df6afa27e0efa27cf9c4b4aee8a1fcdd22
Tested: on OS X."," struct GeneratorOptions {
 bool strict_json;
 int indent_step;
 bool output_enum_identifiers;
+ bool prefixed_enums;
 
 GeneratorOptions() : strict_json(false), indent_step(2),
- output_enum_identifiers(true) {}
+ output_enum_identifiers(true), prefixed_enums(true) {}
 };
 
 // Generate text (JSON) from a given FlatBuffer, and a given Parser
 extern void GenerateText(const Parser &parser,
 // Generate a C++ header from the definitions in the Parser object.
 // See idl_gen_cpp.
 extern std::string GenerateCPP(const Parser &parser,
- const std::string &include_guard_ident);
+ const std::string &include_guard_ident,
+ const GeneratorOptions &opts);
 extern bool GenerateCPP(const Parser &parser,
 const std::string &path,
 const std::string &file_name,
",232,30
"Fixed compile errors in VS / gcc for recent commits.

Tested: on Windows & Linux.

Change-Id: I90e18c448fc2fafeb83a6cdc3776174479874562"," inline void EnsureDirExists(const std::string &filepath) {
 auto parent = StripFileName(filepath);
 if (parent.length()) EnsureDirExists(parent);
 #ifdef _WIN32
- _mkdir(filepath.c_str())
+ _mkdir(filepath.c_str());
 #else
 mkdir(filepath.c_str(), S_IRWXU|S_IRGRP|S_IXGRP);
 #endif
 inline int ToUTF8(uint32_t ucc, std::string *out) {
 for (int i = 0; i < 6; i++) {
 // Max bits this encoding can represent.
 uint32_t max_bits = 6 + i * 5 + static_cast<int>(!i);
- if (ucc < (1 << max_bits)) { // does it fit?
+ if (ucc < (1u << max_bits)) { // does it fit?
 // Remaining bits not encoded in the first byte, store 6 bits each
 uint32_t remain_bits = i * 6;
 // Store first byte:
",109,33
"Fixed compiler warning for int to char conversion.

Change-Id: Idc6c152ebf9e733ac72c01f3888b69e3b5f33aa9
Tested: on Linux."," static std::string TokenToString(int t) {
 };
 if (t < 256) { // A single ascii char token.
 std::string s;
- s.append(1, t);
+ s.append(1, static_cast<char>(t));
 return s;
 } else { // Other tokens.
 return tokens[t - 256];
",769,248
"Made reading read-only ByteBuffers work.

Also added new constructor that allows ByteBuffer reuse.

Change-Id: I9c20ea96c67533066461f4e23b0d03b9b47cd068
Tested: on OS X."," public class FlatBufferBuilder {
 int space; // Remaining space in the ByteBuffer.
 static final Charset utf8charset = Charset.forName(""UTF-8"");
 int minalign = 1; // Minimum alignment encountered so far.
- int[] vtable; // The vtable for the current table, null otherwise.
+ int[] vtable = null; // The vtable for the current table, null otherwise.
 int object_start; // Starting offset of the current struct/table.
 int[] vtables = new int[16]; // List of offsets of all vtables.
 int num_vtables = 0; // Number of entries in `vtables` in use.
 public class FlatBufferBuilder {
 bb = newByteBuffer(new byte[initial_size]);
 }
 
+ // Alternative constructor allowing reuse of ByteBuffers
+ public FlatBufferBuilder(ByteBuffer existing_bb) {
+ bb = existing_bb;
+ bb.clear();
+ bb.order(ByteOrder.LITTLE_ENDIAN);
+ space = bb.capacity();
+ }
+
 ByteBuffer newByteBuffer(byte[] buf) {
 ByteBuffer newbb = ByteBuffer.wrap(buf);
 newbb.order(ByteOrder.LITTLE_ENDIAN);
",176,63
"Fixed flatc silently accepting non-scalars as default values.

Bug: 17304016
Change-Id: I4873f8ef32fbb2657f15fc53a2c8f767e10f2d96
Tested: on Linux"," void Parser::ParseField(StructDef &struct_def) {
 
 if (token_ == '=') {
 Next();
+ if (!IsScalar(type.base_type))
+ Error(""default values currently only supported for scalars"");
 ParseSingleValue(field.value);
 }
 
",771,249
"Setting a field twice in a JSON object now gives error.

Before, it would crash in FlatBufferBuilder.

Bug: 17357164
Change-Id: I6e6dbada5261745220345379eb53eb3eb113e8f8
Tested: on Linux."," uoffset_t Parser::ParseTable(const StructDef &struct_def) {
 || struct_def.fields.vec[fieldn] != field)) {
 Error(""struct field appearing out of order: "" + name);
 }
+ for (auto it = field_stack_.rbegin();
+ it != field_stack_.rbegin() + fieldn; ++it) {
+ if (it->second == field) Error(""field already set: "" + name);
+ }
 Expect(':');
 Value val = field->value;
 ParseAnyValue(val, field);
",775,251
"Fixed missing <functional> header (VS).

Change-Id: I89d0f9b18bfe4d27be325c7f7205dee14bc7e1be
Tested: on Windows.","
 
 #include <map>
 #include <memory>
+#include <functional>
 
 #include ""flatbuffers/flatbuffers.h""
 
",233,30
"Made ""field set more than once"" check in JSON parser faster.

Change-Id: I3ecc1aa610526c270faa56cc5266f14cd81db247
Tested: on Linux."," struct Definition {
 };
 
 struct FieldDef : public Definition {
- FieldDef() : deprecated(false), padding(0) {}
+ FieldDef() : deprecated(false), padding(0), used(false) {}
 
 Value value;
 bool deprecated;
- size_t padding; // bytes to always pad after this field
+ size_t padding; // Bytes to always pad after this field.
+ bool used; // Used during JSON parsing to check for repeated fields.
 };
 
 struct StructDef : public Definition {
",234,30
"Fixed possible alignment issue in Go

Java patch with same purpose:
cdb0dca39d683d577caa7fde21a1b6db9aa64734

Change-Id: I57d268cc0064843779eb7812a9e69326d9ab2498
Tested: on Darwin"," func (b *Builder) PrependUOffsetT(off UOffsetT) {
 // A vector has the following format:
 // <UOffsetT: number of elements in this vector>
 // <T: data>+, where T is the type of elements of this vector.
-func (b *Builder) StartVector(elemSize, numElems int) UOffsetT {
+func (b *Builder) StartVector(elemSize, numElems, alignment int) UOffsetT {
 b.notNested()
 b.Prep(SizeUint32, elemSize*numElems)
+b.Prep(alignment, elemSize*numElems) // Just in case alignment > int.
 return b.Offset()
 }
 
",378,97
"Changed hard-coded constant in JavaTest to enum value.

Change-Id: I7d2eac7fed6c36c966670a3e58f4dae7dff25029
Tested: on Linux."," class JavaTest {
 Monster.addHp(fbb, (short)80);
 Monster.addName(fbb, str);
 Monster.addInventory(fbb, inv);
- Monster.addTestType(fbb, (byte)1);
+ Monster.addTestType(fbb, (byte)Any.Monster);
 Monster.addTest(fbb, mon2);
 Monster.addTest4(fbb, test4);
 Monster.addTestarrayofstring(fbb, testArrayOfString);
",103,8
"Made Vector have a size() function, to make it more STL-alike.

Bug: 17316346
Change-Id: I52377b7fa51adccadc4e867d45666e683bc2c1ae
Tested: on Linux."," template<typename T> void PrintVector(const Vector<T> &v, Type type,
 std::string &text = *_text;
 text += ""["";
 text += NewLine(opts);
- for (uoffset_t i = 0; i < v.Length(); i++) {
+ for (uoffset_t i = 0; i < v.size(); i++) {
 if (i) {
 text += "","";
 text += NewLine(opts);
 template<typename T> void PrintVector(const Vector<T> &v, Type type,
 static void EscapeString(const String &s, std::string *_text) {
 std::string &text = *_text;
 text += ""\"""";
- for (uoffset_t i = 0; i < s.Length(); i++) {
+ for (uoffset_t i = 0; i < s.size(); i++) {
 char c = s.Get(i);
 switch (c) {
 case '\n': text += ""\\n""; break;
",200,44
"Implemented the file identifier functionality for Java.

Also fixed flatc not outputting these identifiers for files
compiled on the command-line.

Bug: 16983987
Change-Id: I8b714cfea3a8e144fa52133f62b2f7eda6eb044a
Tested: on Linux"," template<typename T> const T *GetRoot(const void *buf) {
 
 // Helper to see if the identifier in a buffer has the expected value.
 inline bool BufferHasIdentifier(const void *buf, const char *identifier) {
- return strncmp(reinterpret_cast<const char *>(buf) + 4, identifier,
- FlatBufferBuilder::kFileIdentifierLength) == 0;
+ return strncmp(reinterpret_cast<const char *>(buf) + sizeof(uoffset_t),
+ identifier, FlatBufferBuilder::kFileIdentifierLength) == 0;
 }
 
 // Helper class to verify the integrity of a FlatBuffer
",560,160
"Fixed JSON text output not finding symbolic names for enum value 1.

Change-Id: If3a062926dd86b95fa68ed64fc7ee2de7bc0d930
Tested: on Linux"," struct EnumDef : public Definition {
 EnumDef() : is_union(false) {}
 
 EnumVal *ReverseLookup(int enum_idx) {
- for (auto it = vals.vec.begin() + 1; it != vals.vec.end(); ++it) {
+ for (auto it = vals.vec.begin() + static_cast<int>(is_union);
+ it != vals.vec.end(); ++it) {
 if ((*it)->value == enum_idx) {
 return *it;
 }
",235,30
"A generated C++ function was missing ""inline"".

This would cause double definition linker errors when included in
multiple compilation units.

Change-Id: Ie6fd4af018055a099343182a92a7776f2fea4725
Tested: on Linux."," static void GenEnum(EnumDef &enum_def, std::string *code_ptr,
 // verifier function to call, this should be safe even if the union type
 // has been corrupted, since the verifiers will simply fail when called
 // on the wrong type.
- auto signature = ""bool Verify"" + enum_def.name +
+ auto signature = ""inline bool Verify"" + enum_def.name +
 ""(flatbuffers::Verifier &verifier, "" +
 ""const void *union_obj, uint8_t type)"";
 code += signature + "";\n\n"";
",478,100
"Non-alpha-numeric characters are filtered out of include guards

Since part of it is based on the filename, which may contain
characters that are not legal identifiers.

Change-Id: I62b8fe228a434a2040fd4ce47d220fc4d3398b41
Tested: on Linux.","
 // automatically generated by the FlatBuffers compiler, do not modify
 
-#ifndef FLATBUFFERS_GENERATED_MONSTER_TEST_MYGAME_EXAMPLE_H_
-#define FLATBUFFERS_GENERATED_MONSTER_TEST_MYGAME_EXAMPLE_H_
+#ifndef FLATBUFFERS_GENERATED_MONSTERTEST_MYGAME_EXAMPLE_H_
+#define FLATBUFFERS_GENERATED_MONSTERTEST_MYGAME_EXAMPLE_H_
 
 #include ""flatbuffers/flatbuffers.h""
 
 inline bool MonsterBufferHasIdentifier(const void *buf) { return flatbuffers::Bu
 } // namespace Example
 } // namespace MyGame
 
-#endif // FLATBUFFERS_GENERATED_MONSTER_TEST_MYGAME_EXAMPLE_H_
+#endif // FLATBUFFERS_GENERATED_MONSTERTEST_MYGAME_EXAMPLE_H_
",177,72
"Initial commit of .NET port of FlatBuffers

Include C# codegen in flatc and .NET FlatBuffer access via the
FlatBufferBuilder class

Tested: on Windows.

Change-Id: If5228a8df60a10e0751b245c6c64530264ea2d8a"," extern bool GenerateJava(const Parser &parser,
 const std::string &file_name,
 const GeneratorOptions &opts);
 
+// Generate C# files from the definitions in the Parser object.
+// See idl_gen_csharp.cpp.
+extern bool GenerateCSharp(const Parser &parser,
+ const std::string &path,
+ const std::string &file_name,
+ const GeneratorOptions &opts);
+
+
 } // namespace flatbuffers
 
 #endif // FLATBUFFERS_IDL_H_
",239,30
"Removed the use of b.array() to support DirectBuffers.

Also removed Table extend Constants.

Change-Id: I1770b613c58094fa572a3b26a31f01bd5fb8fdbf","
 
 package flatbuffers;
 
-import java.lang.String;
+import static flatbuffers.Constants.*;
 import java.nio.ByteBuffer;
 import java.nio.charset.Charset;
 
 // All tables in the generated code derive from this class, and add their own accessors.
-public class Table extends Constants {
+public class Table {
 protected int bb_pos;
 protected ByteBuffer bb;
 
",51,12
"Fixed test that was incompatible with 64bit offsets.

Change-Id: I35984d0ab3e849bec6cdaa364a39f66f2c37b4d0
Tested: on Linux."," void ScientificTest() {
 auto root = flatbuffers::GetRoot<float>(parser.builder_.GetBufferPointer());
 // root will point to the table, which is a 32bit vtable offset followed
 // by a float:
- TEST_EQ(fabs(root[1] - 3.14159) < 0.001, true);
+ TEST_EQ(sizeof(flatbuffers::soffset_t) == 4 && // Test assumes 32bit offsets
+ fabs(root[1] - 3.14159) < 0.001, true);
 }
 
 void EnumStringsTest() {
",374,68
"The parser and flatc now allow include directories to be specified.

Bug: 17139854
Change-Id: I0eac65d054951e00a8811ad1d80ba8c37012dbf0
Tested: on Linux."," class Parser {
 
 // Parse the string containing either schema or JSON data, which will
 // populate the SymbolTable's or the FlatBufferBuilder above.
- // filepath indicates the file that _source was loaded from, it is
- // used to resolve any include statements.
- bool Parse(const char *_source, const char *filepath);
+ // include_paths is used to resolve any include statements, and typically
+ // should at least include the project path (where you loaded source_ from).
+ // include_paths must be nullptr terminated if specified.
+ // If include_paths is nullptr, it will attempt to load from the current
+ // directory.
+ bool Parse(const char *_source, const char **include_paths = nullptr);
 
 // Set the root type. May override the one set in the schema.
 bool SetRootType(const char *name);
 class Parser {
 
 std::vector<std::pair<Value, FieldDef *>> field_stack_;
 std::vector<uint8_t> struct_stack_;
+
 std::map<std::string, bool> included_files_;
 };
 
",239,30
"Added missing assert.h to util.h.

This was only causing compiler errors on certain compiler configurations.

Change-Id: I110fb8c896f74aae7ef739e9a29c636393dbbde2
Tested: on Linux and Windows.","
 #include <string>
 #include <sstream>
 #include <stdlib.h>
+#include <assert.h>
 #ifdef _WIN32
 #include <direct.h>
 #else
",119,37
"Prepended com.google to the Java namespace.

Bug: 16507831
Change-Id: I5beee18f63f174e425dc1ab395807b578d5f9477
Tested: on Linux.","
 * limitations under the License.
 */
 
-package flatbuffers;
+package com.google.flatbuffers;
 
-import static flatbuffers.Constants.*;
+import static com.google.flatbuffers.Constants.*;
 import java.util.Arrays;
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
",191,67
"Refactored the Java and C# code generators into one.

Also made the C# implementation support unsigned types, and
made it more like the Java version.

Bug: 17359988
Change-Id: If5305c08cd5c97f35426639516ce05e53bbec36c
Tested: on Linux and Windows."," namespace FlatBuffers
 return t;
 }
 
- protected static bool __has_identifier(ByteBuffer bb, int offset, string ident)
+ protected static bool __has_identifier(ByteBuffer bb, string ident)
 {
 if (ident.Length != FlatBufferConstants.FileIdentifierLength)
 throw new ArgumentException(""FlatBuffers: file identifier must be length "" + FlatBufferConstants.FileIdentifierLength, ""ident"");
 
 for (var i = 0; i < FlatBufferConstants.FileIdentifierLength; i++)
 {
- if (ident[i] != (char)bb.Get(offset + sizeof(int) + i)) return false;
+ if (ident[i] != (char)bb.Get(bb.position() + sizeof(int) + i)) return false;
 }
 
 return true;
",54,11
"Add enum name lookup method to Java/C# enums

Tested: on Linux for Java and C#

Bug: 15781151
Change-Id: I7cb97bcc01d986cac2b24aaf7cb29521ddaa2f6b"," namespace FlatBuffers.Test
 {
 CanCreateNewFlatBufferFromScratch();
 CanReadCppGeneratedWireFile();
+ TestEnums();
 }
 
 public void CanCreateNewFlatBufferFromScratch()
 namespace FlatBuffers.Test
 var bb = new ByteBuffer(data);
 TestBuffer(bb);
 }
+
+ public void TestEnums()
+ {
+ Assert.AreEqual(Color.Name(Color.Red), ""Red"");
+ Assert.AreEqual(Color.Name(Color.Blue), ""Blue"");
+ Assert.AreEqual(Any.Name(Any.NONE), ""NONE"");
+ Assert.AreEqual(Any.Name(Any.Monster), ""Monster"");
+ }
 }
 }
",104,7
"Generate headers from spec, add option for installing targets

Change-Id: I16ddb06e887e618fa871e842054115909fbf235c"," inline const char **EnumNamesAny() {
 
 inline const char *EnumNameAny(int e) { return EnumNamesAny()[e]; }
 
-bool VerifyAny(flatbuffers::Verifier &verifier, const void *union_obj, uint8_t type);
+inline bool VerifyAny(flatbuffers::Verifier &verifier, const void *union_obj, uint8_t type);
 
 MANUALLY_ALIGNED_STRUCT(4) Vec3 {
 private:
 inline flatbuffers::Offset<Monster> CreateMonster(flatbuffers::FlatBufferBuilder
 return builder_.Finish();
 }
 
-bool VerifyAny(flatbuffers::Verifier &verifier, const void *union_obj, uint8_t type) {
+inline bool VerifyAny(flatbuffers::Verifier &verifier, const void *union_obj, uint8_t type) {
 switch (type) {
 case Any_NONE: return true;
 case Any_Monster: return verifier.VerifyTable(reinterpret_cast<const Monster *>(union_obj));
",99,36
"Support for required fields.

Change-Id: I560c7ca11b3d665eecafb528f3737b7e139ca9b0
Tested: on Linux and Windows."," struct Definition {
 };
 
 struct FieldDef : public Definition {
- FieldDef() : deprecated(false), padding(0), used(false) {}
+ FieldDef() : deprecated(false), required(false), padding(0), used(false) {}
 
 Value value;
 bool deprecated;
+ bool required;
 size_t padding; // Bytes to always pad after this field.
 bool used; // Used during JSON parsing to check for repeated fields.
 };
",238,24
"Added option to flatc to generate dependent header statements.

Bug: 17322776
Change-Id: I3a4d3cb4ccd40bc3200a87653aa0ab8ecb90ce60
Tested: on Linux."," std::string GenerateCPP(const Parser &parser,
 
 code += ""#include \""flatbuffers/flatbuffers.h\""\n\n"";
 
+ if (opts.include_dependence_headers) {
+ int num_includes = 0;
+ for (auto it = parser.included_files_.begin();
+ it != parser.included_files_.end(); ++it) {
+ auto basename = flatbuffers::StripPath(
+ flatbuffers::StripExtension(it->first));
+ if (basename != file_name) {
+ code += ""#include \"""" + basename + ""_generated.h\""\n"";
+ num_includes++;
+ }
+ }
+ if (num_includes) code += ""\n"";
+ }
+
 code += forward_decl_code_other_namespace;
 code += ""\n"";
 
",501,106
"Made flatc error messages look like what other compilers output.

Looks like MSVC on Windows and like gcc everywhere else.
For enhanced IDE clickability.

Bug: 17208371
Change-Id: Ie3e02658fccd3edfd464b4bacf4bc68c613a8570
Tested: on Linux and Windows.","
 #include <stdlib.h>
 #include <assert.h>
 #ifdef _WIN32
+#ifndef WIN32_LEAN_AND_MEAN
+ #define WIN32_LEAN_AND_MEAN
+#endif
+#ifndef NOMINMAX
+ #define NOMINMAX
+#endif
+#include <windows.h>
+#include <winbase.h>
 #include <direct.h>
 #else
 #include <sys/stat.h>
+#include <limits.h>
 #endif
 
 namespace flatbuffers {
 inline void EnsureDirExists(const std::string &filepath) {
 #endif
 }
 
+// Obtains the absolute path from any other path.
+// Returns the input path if the absolute path couldn't be resolved.
+inline std::string AbsolutePath(const std::string &filepath) {
+ #ifdef _WIN32
+ char abs_path[MAX_PATH];
+ return GetFullPathNameA(filepath.c_str(), MAX_PATH, abs_path, nullptr)
+ #else
+ char abs_path[PATH_MAX];
+ return realpath(filepath.c_str(), abs_path)
+ #endif
+ ? abs_path
+ : filepath;
+}
+
 // To and from UTF-8 unicode conversion functions
 
 // Convert a unicode code point into a UTF-8 representation by appending it
",130,40
"Enums in C++ are now strongly typed.

Accessors and constructors now take enum types rather than ints.

Bug: 16570507
Change-Id: I4b50fd64ad2e662ea2481bc0ccea784326fb31c0
Tested: on Linux and Windows."," public:
 return IndirectHelper<T>::Read(Data(), i);
 }
 
+ // If this is a Vector of enums, T will be its storage type, not the enum
+ // type. This function makes it convenient to retrieve value with enum
+ // type E.
+ template<typename E> E GetEnum(uoffset_t i) const {
+ return static_cast<E>(Get(i));
+ }
+
 const void *GetStructFromOffset(size_t o) const {
 return reinterpret_cast<const void *>(Data() + o);
 }
",576,164
"Fix vector of strings for Go

Mirrors Java patch 39d4b7e2bf

Change-Id: If8d0ab29f6eb508a156d468aeb0a9d5410149e53"," func (t *Table) Indirect(off UOffsetT) UOffsetT {
 
 // String gets a string from data stored inside the flatbuffer.
 func (t *Table) String(off UOffsetT) string {
-off += t.Pos
 off += GetUOffsetT(t.Bytes[off:])
 start := off + UOffsetT(SizeUOffsetT)
 length := GetUOffsetT(t.Bytes[off:])
",173,48
"Output multiline doc comments over multiple lines

Tested: on Linux

Bug: 15779934
Change-Id: I6f822f1705e443d8721ea208dcb021aad3c8715c"," std::string MakeCamel(const std::string &in, bool first) {
 }
 
 // Generate a documentation comment, if available.
-void GenComment(const std::string &dc, std::string *code_ptr,
+void GenComment(const std::vector<std::string> &dc, std::string *code_ptr,
 const char *prefix) {
 std::string &code = *code_ptr;
- if (dc.length()) {
- code += std::string(prefix) + ""///"" + dc + ""\n"";
+ for (auto it = dc.begin();
+ it != dc.end();
+ ++it) {
+ code += std::string(prefix) + ""///"" + *it + ""\n"";
 }
 }
 
",529,105
"Fixed bug in convenient constructors for Java/C#

Also fixed Go unit tests not being up to date with recent schema
changes.

Change-Id: I42e619f9c5ea05f6f937c68a5c8a92462c46bce3
Tested: on Linux and Windows."," static void GenStruct(const LanguageParameters &lang, const Parser &parser,
 if (has_no_struct_fields && num_fields) {
 // Generate a table constructor of the form:
 // public static void createName(FlatBufferBuilder builder, args...)
- code += "" public static void "" + FunctionStart(lang, 'C') + ""reate"";
+ code += "" public static int "" + FunctionStart(lang, 'C') + ""reate"";
 code += struct_def.name;
 code += ""(FlatBufferBuilder builder"";
 for (auto it = struct_def.fields.vec.begin();
 static void GenStruct(const LanguageParameters &lang, const Parser &parser,
 }
 }
 }
- code += "" builder."";
- code += FunctionStart(lang, 'E') + ""ndObject();\n }\n\n"";
+ code += "" return "" + struct_def.name + ""."";
+ code += FunctionStart(lang, 'E') + ""nd"" + struct_def.name;
+ code += ""(builder);\n }\n\n"";
 }
 // Generate a set of static methods that allow table construction,
 // of the form:
",530,105
"Added .proto parsing and convertion to .fbs.

Bug: 15777858
Change-Id: Iabef9b8c8044e593bb89510feebdee00d2f1840b
Tested: on Linux and Windows."," func (rcv *Monster) TestarrayofstringLength() int {
 return 0
 }
 
-/// an example documentation comment: this will end up in the generated code multiline too
+/// an example documentation comment: this will end up in the generated code
+/// multiline too
 func (rcv *Monster) Testarrayoftables(obj *Monster, j int) bool {
 o := flatbuffers.UOffsetT(rcv._tab.Offset(26))
 if o != 0 {
",208,66
"Fixed big-endian issue.

Noticed a memory read that isn't big-endian safe. Was somewhat
benign in that it would have simply caused vtable duplication
when constructing a FlatBuffer on a big-endian machine.

Change-Id: I5de3a2bb3ce6912fdd845ed40668719794920cac"," class FlatBufferBuilder {
 }
 offsetbuf_.clear();
 auto vt1 = reinterpret_cast<voffset_t *>(buf_.data());
- auto vt1_size = *vt1;
+ auto vt1_size = ReadScalar<voffset_t>(vt1);
 auto vt_use = GetSize();
 // See if we already have generated a vtable with this exact same
 // layout before. If so, make it point to the old one, remove this one.
",576,164
"Fix a build error on 32 bit go

Change-Id: Iac5894fd8f56da7e420714558a94d63d4fea2d72"," func (b *Builder) EndObject() UOffsetT {
 // Doubles the size of the byteslice, and copies the old data towards the
 // end of the new byteslice (since we build the buffer backwards).
 func (b *Builder) growByteBuffer() {
-if (len(b.Bytes) & 0xC0000000) != 0 {
+if (int64(len(b.Bytes)) & int64(0xC0000000)) != 0 {
 panic(""cannot grow buffer beyond 2 gigabytes"")
 }
 newSize := len(b.Bytes) * 2
",378,97
"Fixed required field checking incorrectly using unsigned offsets.

Reported by: https://github.com/google/flatbuffers/issues/99

Change-Id: Ia26da95bbac189836c257fa85f3bec1b153b6207
Tested: on Linux."," class FlatBufferBuilder {
 uoffset_t EndTable(uoffset_t start, voffset_t numfields) {
 // Write the vtable offset, which is the start of any Table.
 // We fill it's value later.
- auto vtableoffsetloc = PushElement<uoffset_t>(0);
+ auto vtableoffsetloc = PushElement<soffset_t>(0);
 // Write a vtable, which consists entirely of voffset_t elements.
 // It starts with the number of offsets, followed by a type id, followed
 // by the offsets themselves. In reverse:
 class FlatBufferBuilder {
 // just been constructed.
 template<typename T> void Required(Offset<T> table, voffset_t field) {
 auto table_ptr = buf_.data_at(table.o);
- auto vtable_ptr = table_ptr - ReadScalar<uoffset_t>(table_ptr);
+ auto vtable_ptr = table_ptr - ReadScalar<soffset_t>(table_ptr);
 bool ok = ReadScalar<voffset_t>(vtable_ptr + field) != 0;
 // If this fails, the caller will show what field needs to be set.
 assert(ok);
",593,167
"Made the memcmp address sanitizer clean.

Added extra check to ensure memcmp gets called with a size that is
guaranteed within range of the buffer. This wasn't a real problem,
but stops address sanitizer from complaining.

See:
https://github.com/google/flatbuffers/issues/88
https://github.com/joker-eph/flatbuffers/commit/517506b4e105814e0823353c3d6561085c26a1ab#commitcomment-8265231

Change-Id: I7de24da2d36d973e154f92eeb3e093070886037f
Tested: on Linux"," class FlatBufferBuilder {
 // See if we already have generated a vtable with this exact same
 // layout before. If so, make it point to the old one, remove this one.
 for (auto it = vtables_.begin(); it != vtables_.end(); ++it) {
- if (memcmp(buf_.data_at(*it), vt1, vt1_size)) continue;
+ auto vt2 = reinterpret_cast<voffset_t *>(buf_.data_at(*it));
+ auto vt2_size = *vt2;
+ if (vt1_size != vt2_size || memcmp(vt2, vt1, vt1_size)) continue;
 vt_use = *it;
 buf_.pop(GetSize() - vtableoffsetloc);
 break;
",595,168
"Fixes #90 - flatc chokes on IDL files starting with a comment

Change-Id: I5ab692ceb6809493720c1bff69a2e3210efd4618"," void Parser::Next() {
 const char *start = ++cursor_;
 while (*cursor_ && *cursor_ != '\n') cursor_++;
 if (*start == '/') { // documentation comment
- if (!seen_newline)
+ if (cursor_ != source_ && !seen_newline)
 Error(""a documentation comment should be on a line on its own"");
 doc_comment_.push_back(std::string(start + 1, cursor_));
 }
",909,291
"Added ""final"" to generated types to block inheritance.

People sometimes accidentally inherit from these types.

Bug: 18224703
Change-Id: Ia09489a834ac4941f9b4a46f240cbdcf456f03a1
Tested: on Windows and Linux."," inline const char **EnumNamesAny() {
 
 inline const char *EnumNameAny(Any e) { return EnumNamesAny()[e]; }
 
-inline bool VerifyAny(flatbuffers::Verifier &verifier, const void *union_obj, uint8_t type);
+inline bool VerifyAny(flatbuffers::Verifier &verifier, const void *union_obj, Any type);
 
 MANUALLY_ALIGNED_STRUCT(4) Vec3 {
 private:
 inline flatbuffers::Offset<Monster> CreateMonster(flatbuffers::FlatBufferBuilder
 return builder_.Finish();
 }
 
-inline bool VerifyAny(flatbuffers::Verifier &verifier, const void *union_obj, uint8_t type) {
+inline bool VerifyAny(flatbuffers::Verifier &verifier, const void *union_obj, Any type) {
 switch (type) {
 case Any_NONE: return true;
 case Any_Monster: return verifier.VerifyTable(reinterpret_cast<const Monster *>(union_obj));
",102,36
"Various documentation clarifications.

Change-Id: Ibc2bd88a636f3b4abf82a7c2722fc1e354dab848
Tested: on Linux."," var NAVTREE =
 [ ""Writing a schema"", ""md__schemas.html"", null ],
 [ ""Use in C++"", ""md__cpp_usage.html"", null ],
 [ ""Use in Go"", ""md__go_usage.html"", null ],
- [ ""Use in Java"", ""md__java_usage.html"", null ],
+ [ ""Use in Java/C"", ""md__java_usage.html"", null ],
 [ ""Benchmarks"", ""md__benchmarks.html"", null ],
 [ ""FlatBuffers white paper"", ""md__white_paper.html"", null ],
 [ ""FlatBuffer Internals"", ""md__internals.html"", null ],
",505,121
"Generate C++ function returning the file_identifier of a flatbuffer

Change-Id: I6ee09cf1e86a41b73bb3aa79b68871afb1a4e34f"," inline const Monster *GetMonster(const void *buf) { return flatbuffers::GetRoot<
 
 inline bool VerifyMonsterBuffer(flatbuffers::Verifier &verifier) { return verifier.VerifyBuffer<Monster>(); }
 
-inline void FinishMonsterBuffer(flatbuffers::FlatBufferBuilder &fbb, flatbuffers::Offset<Monster> root) { fbb.Finish(root, ""MONS""); }
+inline const char *MonsterIdentifier() { return ""MONS""; }
 
-inline bool MonsterBufferHasIdentifier(const void *buf) { return flatbuffers::BufferHasIdentifier(buf, ""MONS""); }
+inline bool MonsterBufferHasIdentifier(const void *buf) { return flatbuffers::BufferHasIdentifier(buf, MonsterIdentifier()); }
+
+inline void FinishMonsterBuffer(flatbuffers::FlatBufferBuilder &fbb, flatbuffers::Offset<Monster> root) { fbb.Finish(root, MonsterIdentifier()); }
 
 } // namespace Example
 } // namespace MyGame
",214,93
"Fixed Java ByteBuffer accessors generated for non-scalar vectors.

Change-Id: I9787ab88e5bd4846d92995e2bb05d0c2121113ca
Tested: on Linux."," static void GenStruct(const LanguageParameters &lang, const Parser &parser,
 code += ""Length("" + offset_prefix;
 code += ""__vector_len(o) : 0; }\n"";
 }
- if ((field.value.type.base_type == BASE_TYPE_VECTOR ||
+ // Generate a ByteBuffer accessor for strings & vectors of scalars.
+ if (((field.value.type.base_type == BASE_TYPE_VECTOR &&
+ IsScalar(field.value.type.VectorType().base_type)) ||
 field.value.type.base_type == BASE_TYPE_STRING) &&
 lang.language == GeneratorOptions::kJava) {
 code += "" public ByteBuffer "";
",531,106
"Fixed missing virtual destructor in allocator.

Change-Id: I458249d95e6d65ac039e84d947d2fdf4fd1c3809
Tested: on Linux."," struct String : public Vector<char> {
 // with custom allocation (see the FlatBufferBuilder constructor).
 class simple_allocator {
 public:
+ virtual ~simple_allocator() {}
 virtual uint8_t *allocate(size_t size) const { return new uint8_t[size]; }
 virtual void deallocate(uint8_t *p) const { delete[] p; }
 };
",596,169
"Added VectorLength helper function that works on nullptr.

Change-Id: Ie62096f7337a476bee7a6d46d652e594fb3124d2
Tested: on Linux.
Bug: 18201051"," protected:
 uoffset_t length_;
 };
 
+// Convenient helper function to get the length of any vector, regardless
+// of wether it is null or not (the field is not set).
+template<typename T> static inline size_t VectorLength(const Vector<T> *v) {
+ return v ? v->Length() : 0;
+}
+
 struct String : public Vector<char> {
 const char *c_str() const { return reinterpret_cast<const char *>(Data()); }
 };
",599,171
"C#: Allow ByteBuffer to use faster unsafe mode

If your C# runtime environment supports unsafe mode, you can use
the #define UNSAFE_BYTEBUFFER setting and build the FlatBuffers assembly
in unsafe mode for greatly increased performance.

Tested: Tested FlatBuffersTest on Windows using VS2010 with both safe
and unsafe versions. Added ByteBufferTest to test the byte reversing
functions.

Change-Id: I21334468b339334f9abf4317e6291b648b97f57b"," namespace FlatBuffers.Test
 var uut = new ByteBuffer(buffer);
 Assert.Throws<ArgumentOutOfRangeException>(() => uut.GetLong(0));
 }
+ public void ByteBuffer_ReverseBytesUshort()
+ {
+ ushort original = (ushort)0x1234U;
+ ushort reverse = ByteBuffer.ReverseBytes(original);
+ Assert.AreEqual(0x3412U, reverse);
+
+ ushort rereverse = ByteBuffer.ReverseBytes(reverse);
+ Assert.AreEqual(original, rereverse);
+ }
+
+ public void ByteBuffer_ReverseBytesUint()
+ {
+ uint original = 0x12345678;
+ uint reverse = ByteBuffer.ReverseBytes(original);
+ Assert.AreEqual(0x78563412U, reverse);
 
+ uint rereverse = ByteBuffer.ReverseBytes(reverse);
+ Assert.AreEqual(original, rereverse);
+ }
+
+ public void ByteBuffer_ReverseBytesUlong()
+ {
+ ulong original = 0x1234567890ABCDEFUL;
+ ulong reverse = ByteBuffer.ReverseBytes(original);
+ Assert.AreEqual(0xEFCDAB9078563412UL, reverse);
+
+ ulong rereverse = ByteBuffer.ReverseBytes(reverse);
+ Assert.AreEqual(original, rereverse);
+ }
 }
 }
",218,29
"update generated sources

Change-Id: I531c26572fca7fca9805178971d7e110d44627d8"," inline const char *EnumNameAny(Any e) { return EnumNamesAny()[e]; }
 
 inline bool VerifyAny(flatbuffers::Verifier &verifier, const void *union_obj, Any type);
 
-MANUALLY_ALIGNED_STRUCT(4) Vec3 {
+MANUALLY_ALIGNED_STRUCT(4) Vec3 FLATBUFFERS_FINAL_CLASS {
 private:
 float x_;
 float y_;
 MANUALLY_ALIGNED_STRUCT(4) Vec3 {
 };
 STRUCT_END(Vec3, 12);
 
-struct Monster : private flatbuffers::Table {
+struct Monster FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
 const Vec3 *pos() const { return GetStruct<const Vec3 *>(4); }
 int16_t mana() const { return GetField<int16_t>(6, 150); }
 int16_t hp() const { return GetField<int16_t>(8, 100); }
",102,39
"cast literal to csize to fix error

Change-Id: Ieddc3c5cd4f7c97a9739ae3046b8a1b328180ae1"," void AccessFlatBufferTest(const std::string &flatbuf) {
 TEST_EQ(pos->test3().b(), 20);
 
 auto inventory = monster->inventory();
- TEST_EQ(VectorLength(inventory), 10); // Works even if inventory is null.
+ TEST_EQ(VectorLength(inventory), 10UL); // Works even if inventory is null.
 TEST_NOTNULL(inventory);
 unsigned char inv_data[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
 for (auto it = inventory->begin(); it != inventory->end(); ++it)
",397,70
"non-generic version of CreateUninitializedVector for c ffi

Change-Id: Id7618e53797a158b82e7e480a6507887db3528bc"," class FlatBufferBuilder FLATBUFFERS_FINAL_CLASS {
 // Specialized version for non-copying use cases. Data to be written later.
 // After calling this function, GetBufferPointer() can be cast to the
 // corresponding Vector<> type to write the data (through Data()).
- template<typename T> Offset<Vector<T>> CreateUninitializedVector(size_t len) {
+ uoffset_t CreateUninitializedVector(size_t len, size_t elemsize) {
 NotNested();
- StartVector(len, sizeof(T));
- buf_.make_space(len * sizeof(T));
- return Offset<Vector<T>>(EndVector(len));
+ StartVector(len, elemsize);
+ buf_.make_space(len * elemsize);
+ return EndVector(len);
+ }
+
+ template<typename T> Offset<Vector<T>> CreateUninitializedVector(size_t len) {
+ return CreateUninitializedVector(len, sizeof(T));
 }
 
 template<typename T> Offset<Vector<T>> CreateVector(const std::vector<T> &v){
",602,172
"Made CreateUninitializedVector return the buffer.

Previously, obtaining the buffer was unclear and required multiple
casts.

Change-Id: I18e01c9e669886ac250e83aad10623cbddd629b6
Tested: on Linux."," std::string CreateFlatBufferTest() {
 unsigned char inv_data[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
 auto inventory = builder.CreateVector(inv_data, 10);
 
+ // Alternatively, create the vector first, and fill in data later:
+ // unsigned char *inv_buf = nullptr;
+ // auto inventory = builder.CreateUninitializedVector<unsigned char>(
+ // 10, &inv_buf);
+ // memcpy(inv_buf, inv_data, 10);
+
 Test tests[] = { Test(10, 20), Test(30, 40) };
 auto testv = builder.CreateVectorOfStructs(tests, 2);
 
",397,70
"Fixed C# showing up as C in the documentation

Change-Id: Id1cc75cee07fa2d3de3e7d346f6e2641e4692968"," var NAVTREE =
 [ ""Writing a schema"", ""md__schemas.html"", null ],
 [ ""Use in C++"", ""md__cpp_usage.html"", null ],
 [ ""Use in Go"", ""md__go_usage.html"", null ],
- [ ""Use in Java/C"", ""md__java_usage.html"", null ],
+ [ ""Use in Java/C-sharp"", ""md__java_usage.html"", null ],
 [ ""Benchmarks"", ""md__benchmarks.html"", null ],
 [ ""FlatBuffers white paper"", ""md__white_paper.html"", null ],
 [ ""FlatBuffer Internals"", ""md__internals.html"", null ],
",505,121
"Sorted Vector & binary search functionality.

Bug: 16659276
Tested: on Linux & Windows.

Change-Id: Ie7a73810345fad4cf0a3ad03dfaa5464e3ed5ac8"," void Parser::ParseField(StructDef &struct_def) {
 if (field.required && (struct_def.fixed ||
 IsScalar(field.value.type.base_type)))
 Error(""only non-scalar fields in tables may be 'required'"");
+ field.key = field.attributes.Lookup(""key"") != nullptr;
+ if (field.key) {
+ if (struct_def.has_key)
+ Error(""only one field may be set as 'key'"");
+ struct_def.has_key = true;
+ if (!IsScalar(field.value.type.base_type)) {
+ field.required = true;
+ if (field.value.type.base_type != BASE_TYPE_STRING)
+ Error(""'key' field must be string or scalar type"");
+ }
+ }
 auto nested = field.attributes.Lookup(""nested_flatbuffer"");
 if (nested) {
 if (nested->type.base_type != BASE_TYPE_STRING)
",929,298
"Reuse the same charset instance

Change-Id: I58b411a2c0f1ee6b856d5b1eaa42787036da1384"," package com.google.flatbuffers;
 
 import static com.google.flatbuffers.Constants.*;
 import java.nio.ByteBuffer;
-import java.nio.charset.Charset;
 
 // All tables in the generated code derive from this class, and add their own accessors.
 public class Table {
 public class Table {
 protected String __string(int offset) {
 offset += bb.getInt(offset);
 if (bb.hasArray()) {
- return new String(bb.array(), offset + SIZEOF_INT, bb.getInt(offset), Charset.forName(""UTF-8""));
+ return new String(bb.array(), offset + SIZEOF_INT, bb.getInt(offset), FlatBufferBuilder.utf8charset);
 } else {
 // We can't access .array(), since the ByteBuffer is read-only.
 // We're forced to make an extra copy:
 public class Table {
 bb.position(offset + SIZEOF_INT);
 bb.get(copy);
 bb.position(old_pos);
- return new String(copy, 0, copy.length, Charset.forName(""UTF-8""));
+ return new String(copy, 0, copy.length, FlatBufferBuilder.utf8charset);
 }
 }
 
",61,14
"Fixed C# SizedByteArray copying leading bytes of ByteBuffer.

Tested: on Windows.

Change-Id: I946dacf799eae835ec041ea759622f74b0384937"," namespace FlatBuffers
 // Utility function for copying a byte array that starts at 0.
 public byte[] SizedByteArray()
 {
- var newArray = new byte[_bb.Data.Length];
+ var newArray = new byte[_bb.Data.Length - _bb.position()];
 Buffer.BlockCopy(_bb.Data, _bb.position(), newArray, 0,
- _bb.Data.Length);
+ _bb.Data.Length - _bb.position());
 return newArray;
 }
 
",271,83
"Parser will allow a table or vector to have a trailing comma.

Unless in --strict-json mode.
Also added strict_json option to the parser, which in
addition controls if field names without quotes are allowed.

Change-Id: Id56fe5c780bdb9170958050ffa8fa23cf2babe95
Tested: on Linux."," struct EnumDef : public Definition {
 
 class Parser {
 public:
- Parser(bool proto_mode = false)
+ Parser(bool strict_json = false, bool proto_mode = false)
 : root_struct_def(nullptr),
 source_(nullptr),
 cursor_(nullptr),
 line_(1),
- proto_mode_(proto_mode) {
+ proto_mode_(proto_mode),
+ strict_json_(strict_json) {
 // Just in case none are declared:
 namespaces_.push_back(new Namespace());
 known_attributes_.insert(""deprecated"");
 class Parser {
 int line_; // the current line being parsed
 int token_;
 bool proto_mode_;
+ bool strict_json_;
 std::string attribute_;
 std::vector<std::string> doc_comment_;
 
",273,25
"Support for booleans in the Java/C# API

Change-Id: I72e92183a7b5f4145ea51fcec29257dc9553a461"," namespace flatbuffers {
 #define FLATBUFFERS_GEN_TYPES_SCALAR(TD) \
 TD(NONE, """", uint8_t, byte, byte, byte) \
 TD(UTYPE, """", uint8_t, byte, byte, byte) /* begin scalar/int */ \
- TD(BOOL, ""bool"", uint8_t, byte, byte, byte) \
+ TD(BOOL, ""bool"", uint8_t, boolean,byte, bool) \
 TD(CHAR, ""byte"", int8_t, byte, int8, sbyte) \
 TD(UCHAR, ""ubyte"", uint8_t, byte, byte, byte) \
 TD(SHORT, ""short"", int16_t, short, int16, short) \
",273,25
"cursor_ is not directly represent the hexadecimal

Change-Id: Ibdbd0e2f85284c1443403ed8c43acbd6e9de635f"," int64_t Parser::ParseHexNum(int nibbles) {
 if (!isxdigit(cursor_[i]))
 Error(""escape code must be followed by "" + NumToString(nibbles) +
 "" hex digits"");
- auto val = StringToInt(cursor_, 16);
+ std::string target(cursor_, cursor_ + nibbles);
+ auto val = StringToInt(target.c_str(), 16);
 cursor_ += nibbles;
 return val;
 }
",932,303
"Fixed flatc not writing Java files without namespace.

If the schema didn't contain a namespace, paths would contain a
leading /, causing files not to be written.

Change-Id: I508772cbf6d18d464ef7d9f8842d0dbff14358a3
Tested: on Linux.
Bug: 19067493"," static bool SaveClass(const LanguageParameters &lang, const Parser &parser,
 if (!classcode.length()) return true;
 
 std::string namespace_general;
- std::string namespace_dir = path;
+ std::string namespace_dir = path; // Either empty or ends in separator.
 auto &namespaces = parser.namespaces_.back()->components;
 for (auto it = namespaces.begin(); it != namespaces.end(); ++it) {
 if (namespace_general.length()) {
 namespace_general += ""."";
- namespace_dir += kPathSeparator;
 }
 namespace_general += *it;
- namespace_dir += *it;
+ namespace_dir += *it + kPathSeparator;
 }
 EnsureDirExists(namespace_dir);
 
 static bool SaveClass(const LanguageParameters &lang, const Parser &parser,
 if (needs_includes) code += lang.includes;
 code += classcode;
 code += lang.namespace_end;
- auto filename = namespace_dir + kPathSeparator + def.name +
- lang.file_extension;
+ auto filename = namespace_dir + def.name + lang.file_extension;
 return SaveFile(filename.c_str(), code, false);
 }
 
",541,111
"Applied Java namespace filename fix to Go.

Bug: 19067493
Change-Id: Ib32fef963306e27834c15e3bbabc60570924c1a9
Tested: on Linux."," static bool SaveType(const Parser &parser, const Definition &def,
 if (!classcode.length()) return true;
 
 std::string namespace_name;
- std::string namespace_dir = path;
+ std::string namespace_dir = path; // Either empty or ends in separator.
 auto &namespaces = parser.namespaces_.back()->components;
 for (auto it = namespaces.begin(); it != namespaces.end(); ++it) {
 if (namespace_name.length()) {
 namespace_name += ""."";
- namespace_dir += PATH_SEPARATOR;
 }
 namespace_name = *it;
- namespace_dir += *it;
- mkdir(namespace_dir.c_str(), S_IRWXU|S_IRGRP|S_IXGRP|S_IROTH|S_IXOTH);
+ namespace_dir += *it + kPathSeparator;
 }
-
+ EnsureDirExists(namespace_dir);
 
 std::string code = """";
 BeginFile(namespace_name, needs_imports, &code);
 code += classcode;
- std::string filename = namespace_dir + PATH_SEPARATOR + def.name + "".go"";
+ std::string filename = namespace_dir + def.name + "".go"";
 return SaveFile(filename.c_str(), code, false);
 }
 
",526,90
"Added FlatBufferBuilder reuse

init resets internal variables, but keeps memory that has been allocated
for temporary storage

Change-Id: If2aa7d27de3c2717cf4c82b1e4e4b6732e495cea"," public class FlatBufferBuilder {
 * @param existing_bb The byte buffer to reuse
 */
 public FlatBufferBuilder(ByteBuffer existing_bb) {
+ init(existing_bb);
+ }
+
+ /**
+ * Alternative initializer that allows reusing this object on an existing
+ * ByteBuffer. This method resets the builder's internal state, but keeps
+ * objects that have been allocated for temporary storage.
+ *
+ * @param existing_bb The byte buffer to reuse
+ * @return this
+ */
+ public FlatBufferBuilder init(ByteBuffer existing_bb){
 bb = existing_bb;
 bb.clear();
 bb.order(ByteOrder.LITTLE_ENDIAN);
+ minalign = 1;
 space = bb.capacity();
+ vtable_in_use = 0;
+ nested = false;
+ object_start = 0;
+ num_vtables = 0;
+ vector_num_elems = 0;
+ return this;
 }
 
 static ByteBuffer newByteBuffer(int capacity) {
",218,79
"added reuse option for root objects

getRootAs..() function now has a second implementation that
accepts an existing object to allow object reuse, much like
all other methods that refer to objects.

Change-Id: Iffef567c903a130761ef7de98867e5465d29a04d"," namespace MyGame.Example
 using FlatBuffers;
 
 public class Monster : Table {
- public static Monster GetRootAsMonster(ByteBuffer _bb) { return (new Monster()).__init(_bb.GetInt(_bb.position()) + _bb.position(), _bb); }
+ public static Monster GetRootAsMonster(ByteBuffer _bb) { return GetRootAsMonster(_bb, new Monster()); }
+ public static Monster GetRootAsMonster(ByteBuffer _bb, Monster obj) { return (obj.__init(_bb.GetInt(_bb.position()) + _bb.position(), _bb)); }
 public static bool MonsterBufferHasIdentifier(ByteBuffer _bb) { return __has_identifier(_bb, ""MONS""); }
 public Monster __init(int _i, ByteBuffer _bb) { bb_pos = _i; bb = _bb; return this; }
 
",66,80
"Reset minimum alignment when reusing FlatBufferBuilder

Previously, if you were re-using instances of FlatBufferBuilder
and an earlier buffer would use a 64bit item where later ones
do not, you could be wasting space.

Change-Id: Ic8090a38f97ce73194e991ba72bcfae74a7ace9f
Tested: on Linux."," class FlatBufferBuilder FLATBUFFERS_FINAL_CLASS {
 buf_.clear();
 offsetbuf_.clear();
 vtables_.clear();
+ minalign_ = 1;
 }
 
 // The current size of the serialized buffer, counting from the end.
",643,179
"Change nested_root accessor to be const function.

The `<field>_nested_root()` is not viable from const object. (We usually get `const Monster *`.)

Change-Id: I0d0adcb38dd974318608417ee3094c34fb9c480d"," static void GenTable(const Parser &parser, StructDef &struct_def,
 auto nested_root = parser.structs_.Lookup(nested->constant);
 assert(nested_root); // Guaranteed to exist by parser.
 code += "" const "" + nested_root->name + "" *"" + field.name;
- code += ""_nested_root() { return flatbuffers::GetRoot<"";
+ code += ""_nested_root() const { return flatbuffers::GetRoot<"";
 code += nested_root->name + "">("" + field.name + ""()->Data()); }\n"";
 }
 // Generate a comparison function for this field if it is a key.
",583,123
"Fix pointer underrun when allocating large vectors

Change-Id: Ia69fc3098468eb64420215dc1068342ccbbb1ede"," class vector_downward {
 }
 
 uint8_t *make_space(size_t len) {
- if (buf_ > cur_ - len) {
+ if (len > static_cast<size_t>(cur_ - buf_)) {
 auto old_size = size();
 reserved_ += std::max(len, growth_policy(reserved_));
 auto new_buf = allocator_.allocate(reserved_);
",643,179
"Added the hash attribute to ints and longs.

FlatBuffer schema files can now optionally specify a hash attribute that
will allow someone writing json files to enter a string to be hashed
rather than a specific value. The hashing algorithm to use is specified
by the schema.

Currently the only algorithms are fnv1 and fnv1a. There are 32 bit and
64 variatns for each. Additionally, a hashing command line tool was
added so that you can see what a string will hash to without needing to
inspect the flatbuffer binary blob.

Change-Id: I0cb359d0e2dc7d2dc1874b446dc19a17cc77109d","
 #include <functional>
 
 #include ""flatbuffers/flatbuffers.h""
+#include ""flatbuffers/hash.h""
 
 // This file defines the data types representing a parsed IDL (Interface
 // Definition Language) / schema file.
 class Parser {
 known_attributes_.insert(""deprecated"");
 known_attributes_.insert(""required"");
 known_attributes_.insert(""key"");
+ known_attributes_.insert(""hash"");
 known_attributes_.insert(""id"");
 known_attributes_.insert(""force_align"");
 known_attributes_.insert(""bit_flags"");
 class Parser {
 uoffset_t ParseVector(const Type &type);
 void ParseMetaData(Definition &def);
 bool TryTypedValue(int dtoken, bool check, Value &e, BaseType req);
+ void ParseHash(Value &e, FieldDef* field);
 void ParseSingleValue(Value &e);
 int64_t ParseIntegerFromString(Type &type);
 StructDef *LookupCreateStruct(const std::string &name);
",306,25
"Fixed C# Table.cs to work with Mono.

Cast to short for mono compatibility.

Change-Id: I568059a21369b895fa52002fa231f7594f0f736c"," namespace FlatBuffers
 protected int __offset(int vtableOffset)
 {
 int vtable = bb_pos - bb.GetInt(bb_pos);
- return vtableOffset < bb.GetShort(vtable) ? bb.GetShort(vtable + vtableOffset) : 0;
+ return vtableOffset < bb.GetShort(vtable) ? (int)bb.GetShort(vtable + vtableOffset) : 0;
 }
 
 // Retrieve the relative offset stored at ""offset""
",54,11
"Added Copyright headers

Change-Id: I106de8985cea572590d49c896b72c54f33e73bd2"," static void GenStruct(const LanguageParameters &lang, const Parser &parser,
 // of a FlatBuffer
 std::string method_name = FunctionStart(lang, 'G') + ""etRootAs"" + struct_def.name;
 std::string method_signature = "" public static "" + struct_def.name + "" "" + method_name;
- 
+
 // create convenience method that doesn't require an existing object
 code += method_signature + ""(ByteBuffer _bb) "";
 code += ""{ return "" + method_name + ""(_bb, new "" + struct_def.name+ ""()); }\n"";
- 
+
 // create method that allows object reuse
 code += method_signature + ""(ByteBuffer _bb, "" + struct_def.name + "" obj) { "";
 code += lang.set_bb_byteorder;
",634,127
"Add CreateByteVector function to Go's builder

This function gets around the inefficiency of populating a [ubyte] vector
byte by byte. Since ubyte vectors are probably the most commonly used type
of generic byte buffer, this seems like a worthwhile thing to create a
fast path for.

Benchmarks show a 6x improvement in throughput on x64.

There is a new test verifying the functionality of the function.

Change-Id: I82e0228ae0f815dd7ea89bf168b8c1925f3ce0d7"," func (b *Builder) CreateString(s string) UOffsetT {
 return b.EndVector(len(x))
 }
 
+// CreateByteVector writes a ubyte vector
+func (b *Builder) CreateByteVector(v []byte) UOffsetT {
+b.Prep(int(SizeUOffsetT), len(v)*SizeByte)
+
+l := UOffsetT(len(v))
+
+b.head -= l
+copy(b.Bytes[b.head:b.head+l], v)
+
+return b.EndVector(len(v))
+}
+
 func (b *Builder) notNested() {
 // Check that no other objects are being built while making this
 // object. If not, panic:
",385,98
"Unsigned types in Java now return bigger size signed types.

(Java doesn't support unsigned types).

ubyte/ushort return as int
uint returns as long
(all with correct masking)

ulong still returns as long, as before.

Tested: on Linux & Windows.
Bug 17521464

Change-Id: Id6bc8f38fc8c1a2f4e6733c6980dc6b6e322b452"," func (rcv *Stat) Val() int64 {
 return 0
 }
 
-func StatStart(builder *flatbuffers.Builder) { builder.StartObject(2) }
+func (rcv *Stat) Count() uint16 {
+o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
+if o != 0 {
+return rcv._tab.GetUint16(o + rcv._tab.Pos)
+}
+return 0
+}
+
+func StatStart(builder *flatbuffers.Builder) { builder.StartObject(3) }
 func StatAddId(builder *flatbuffers.Builder, id flatbuffers.UOffsetT) { builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(id), 0) }
 func StatAddVal(builder *flatbuffers.Builder, val int64) { builder.PrependInt64Slot(1, val, 0) }
+func StatAddCount(builder *flatbuffers.Builder, count uint16) { builder.PrependUint16Slot(2, count, 0) }
 func StatEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT { return builder.EndObject() }
",37,12
Add byte slice accessor to Go code," func (t *Table) Indirect(off UOffsetT) UOffsetT {
 
 // String gets a string from data stored inside the flatbuffer.
 func (t *Table) String(off UOffsetT) string {
+return string(t.ByteVector(off))
+}
+
+// ByteVector gets a byte slice from data stored inside the flatbuffer.
+func (t *Table) ByteVector(off UOffsetT) []byte {
 off += GetUOffsetT(t.Bytes[off:])
 start := off + UOffsetT(SizeUOffsetT)
 length := GetUOffsetT(t.Bytes[off:])
-return string(t.Bytes[start : start+length])
+return t.Bytes[start : start+length]
 }
 
 // VectorLen retrieves the length of the vector whose offset is stored at
",176,49
"Generate Java doc comments in JavaDoc style

Tested by regenerating all tests/ generated sources; note that only
Monster.java changes. Ran flattests as well.

Change-Id: I65b6ea7d208b0ccd6a0b34761162fed6ba391fc5"," class Parser {
 // Utility functions for multiple generators:
 
 extern std::string MakeCamel(const std::string &in, bool first = true);
+
+struct CommentConfig;
+
 extern void GenComment(const std::vector<std::string> &dc,
 std::string *code_ptr,
+ const CommentConfig *config,
 const char *prefix = """");
 
 // Container of options that may apply to any of the source/text generators.
",308,25
"Generate appropriate schema doc comments from .proto files

- Add parse handling of .proto struct and field doc comments (enums and
their values were already handled)
- Add FBS generation handling of doc comments for structs, their
fields, enums, and their values (requires linking idl_gen_general in
the test binary build)
- Tested using test.proto|golden with doc comments added. Xcode run of
flattest passes.

Change-Id: Idff64dd8064afba227174ab77d2c7be22d006628"," void Parser::ParseProtoDecl() {
 // These are identical in syntax to FlatBuffer's namespace decl.
 ParseNamespace();
 } else if (attribute_ == ""message"") {
+ std::vector<std::string> struct_comment = doc_comment_;
 Next();
 auto &struct_def = StartStruct();
+ struct_def.doc_comment = struct_comment;
 Expect('{');
 while (token_ != '}') {
+ std::vector<std::string> field_comment = doc_comment_;
 // Parse the qualifier.
 bool required = false;
 bool repeated = false;
 void Parser::ParseProtoDecl() {
 Expect('=');
 Expect(kTokenIntegerConstant);
 auto &field = AddField(struct_def, name, type);
+ field.doc_comment = field_comment;
 field.required = required;
 // See if there's a default specified.
 if (IsNext('[')) {
",1026,335
"Remove all string allocations during parsing.

Change the signature for 'string' getters and settings to use byte
slices instead of strings."," func (rcv *Stat) Init(buf []byte, i flatbuffers.UOffsetT) {
 rcv._tab.Pos = i
 }
 
-func (rcv *Stat) Id() string {
+func (rcv *Stat) Id() []byte {
 o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
 if o != 0 {
-return rcv._tab.String(o + rcv._tab.Pos)
+return rcv._tab.ByteVector(o + rcv._tab.Pos)
 }
-return """"
+return nil
 }
 
 func (rcv *Stat) Val() int64 {
",37,12
"Reduce allocations when building strings.

Builder has a new CreateByteString function that writes a
null-terimnated byte slice to the buffer. This results in zero
allocations for writing strings."," func (b *Builder) EndVector(vectorNumElems int) UOffsetT {
 
 // CreateString writes a null-terminated string as a vector.
 func (b *Builder) CreateString(s string) UOffsetT {
+return b.CreateByteString([]byte(s))
+}
+
+// CreateByteString writes a null-terminated byteslice as a vector.
+func (b *Builder) CreateByteString(s []byte) UOffsetT {
 b.Prep(int(SizeUOffsetT), (len(s)+1)*SizeByte)
 b.PlaceByte(0)
 
-x := []byte(s)
-l := UOffsetT(len(x))
+l := UOffsetT(len(s))
 
 b.head -= l
-copy(b.Bytes[b.head:b.head+l], x)
+copy(b.Bytes[b.head:b.head+l], s)
 
-return b.EndVector(len(x))
+return b.EndVector(len(s))
 }
 
 // CreateByteVector writes a ubyte vector
",387,99
"Reduce allocations when reusing a Builder.

Add the function `Reset` to the Builder, which facilitates reuse of the
underlying byte slice."," func BenchmarkBuildGold(b *testing.B) {
 reuse_fred := []byte(""Fred"")
 
 b.SetBytes(bytes_length)
+bldr := flatbuffers.NewBuilder(512)
 b.ReportAllocs()
 for i := 0; i < b.N; i++ {
-bldr := flatbuffers.NewBuilder(0)
+bldr.Reset()
+
 str := bldr.CreateByteString(reuse_str)
 test1 := bldr.CreateByteString(reuse_test1)
 test2 := bldr.CreateByteString(reuse_test2)
",1000,112
"Always add additional space if no more is available

Change-Id: If08b2d839489d40e977de794b13584fa66ff32c1"," func (b *Builder) Prep(size, additionalBytes int) {
 alignSize &= (size - 1)
 
 // Reallocate the buffer if needed:
-for int(b.head) < alignSize+size+additionalBytes {
+for int(b.head) <= alignSize+size+additionalBytes {
 oldBufSize := len(b.Bytes)
 b.growByteBuffer()
 b.head += UOffsetT(len(b.Bytes) - oldBufSize)
",385,98
"Add byte slice accessor to Go code

Change-Id: I15cc8924d6607bd93068c762fd67e6088cfd9789"," func (t *Table) Indirect(off UOffsetT) UOffsetT {
 
 // String gets a string from data stored inside the flatbuffer.
 func (t *Table) String(off UOffsetT) string {
+return string(t.ByteVector(off))
+}
+
+// ByteVector gets a byte slice from data stored inside the flatbuffer.
+func (t *Table) ByteVector(off UOffsetT) []byte {
 off += GetUOffsetT(t.Bytes[off:])
 start := off + UOffsetT(SizeUOffsetT)
 length := GetUOffsetT(t.Bytes[off:])
-return string(t.Bytes[start : start+length])
+return t.Bytes[start : start+length]
 }
 
 // VectorLen retrieves the length of the vector whose offset is stored at
",176,49
"Seal all classes in Java/C#

Makes enums/structs/tables unsubclassable (final or sealed) and
prevents instantiation of enum classes (which are solely static
constants).

Tested (Mac OS 10.10.2):
1. run flattests
2. cd tests && ../flatc -c monster_test.fbs && ../flatc -j
monster_test.fbs && ../flatc -g monster_test.fbs && ../flatc -n
monster_test.fbs # Note deltas for C# and Java.
3. ./JavaTest.sh

**Breaking api change**

Change-Id: Ie008c941c36d212690da58ddc72c9b228eb7a093","
 namespace MyGame.Example
 {
 
-public class Any
+public sealed class Any
 {
+ private Any() { }
 public static readonly byte NONE = 0;
 public static readonly byte Monster = 1;
 
",11,2
"Tolerate DOS-style EOL in IDL line comments

If an IDL file uses DOS-style EOLs (CR+LF), line comments need to
ignore the second linebreak character, otherwise, as is currently
the case, the parsed documentation comment includes a trailing `\r`
character, which is then output verbatim into the output source
code by flatc.

Change-Id: I39591631995a980622d20a4a32315178b33f18f6"," void Parser::Next() {
 case '/':
 if (*cursor_ == '/') {
 const char *start = ++cursor_;
- while (*cursor_ && *cursor_ != '\n') cursor_++;
+ while (*cursor_ && *cursor_ != '\n' && *cursor_ != '\r') cursor_++;
 if (*start == '/') { // documentation comment
 if (cursor_ != source_ && !seen_newline)
 Error(""a documentation comment should be on a line on its own"");
",1026,336
"Mutable FlatBuffers: in-place updates.

This commit contains the first step in providing mutable FlatBuffers,
non-const accessors and mutation functions for existing fields generated
from --gen-mutable.

Change-Id: Iebee3975f05c1001f8e22824725edeaa6d85fbee
Tested: on Linux.
Bug: 15777024"," struct GeneratorOptions {
 bool output_enum_identifiers;
 bool prefixed_enums;
 bool include_dependence_headers;
+ bool mutable_buffer;
 
 // Possible options for the more general generator below.
 enum Language { kJava, kCSharp, kGo, kMAX };
 struct GeneratorOptions {
 GeneratorOptions() : strict_json(false), indent_step(2),
 output_enum_identifiers(true), prefixed_enums(true),
 include_dependence_headers(false),
+ mutable_buffer(false),
 lang(GeneratorOptions::kJava) {}
 };
 
",310,25
"Added accessor for file_extension in generated code.

Change-Id: I2de7d14dbb1f7b8f81022dd2c9da65060ae49300
Tested: on Linux."," std::string GenerateCPP(const Parser &parser,
 code += name + ""Identifier()); }\n\n"";
 }
 
+ if (parser.file_extension_.length()) {
+ // Return the extension
+ code += ""inline const char *"" + name;
+ code += ""Extension() { return \"""" + parser.file_extension_;
+ code += ""\""; }\n\n"";
+ }
+
 // Finish a buffer with a given root object:
 code += ""inline void Finish"" + name;
 code += ""Buffer(flatbuffers::FlatBufferBuilder &fbb, flatbuffers::Offset<"";
",630,129
"Initial support for propagating namespaces from schema files to generated code

Change-Id: Ifc10c54845ea7553586d1896d509314d68e9ab0f"," class Parser {
 // Mark all definitions as already having code generated.
 void MarkGenerated();
 
+ // Given a (potentally unqualified) name, return the ""fully qualified"" name
+ // which has a full namespaced descriptor. If the parser has no current
+ // namespace context, or if the name passed is partially qualified the input
+ // is simply returned.
+ std::string GetFullyQualifiedName(const std::string &name) const;
+
 // Get the files recursively included by the given file. The returned
 // container will have at least the given file.
 std::set<std::string> GetIncludedFilesRecursive(
",311,25
"Fix u_int8_t to uint8_t

Change-Id: I475ef9454f51f1b7ec2a7f9086d711359456677a"," class Table {
 
 template<typename P> P GetStruct(voffset_t field) const {
 auto field_offset = GetOptionalFieldOffset(field);
- auto p = const_cast<u_int8_t *>(data_ + field_offset);
+ auto p = const_cast<uint8_t *>(data_ + field_offset);
 return field_offset ? reinterpret_cast<P>(p) : nullptr;
 }
 
",682,189
"[BREAKING CHANGE] Field accessors should use property getters in C#

In C#, plain field accessors should not be nonparametric methods
but should be standard property getters.

The accessor methods with parameters were renamed to `GetXxx`
because a method cannot be named identically to a property.

Also, `ByteBuffer.Position`, `FlatBufferBuilder.Offset` and
`FlatBufferBuilder.DataBuffer` are now properties instead
of nonparametric accessor methods, for more idiomatic C# style.

This is a breaking change, all client C# code accessing these
fields needs to be changed (i.e. remove those `()` or add the
`Get` prefix).

Issue: #77
Change-Id: Iaabe9ada076e5ea2c69911cf6170fdda2df3487e","
 //#define UNSAFE_BYTEBUFFER // uncomment this line to use faster ByteBuffer
 
 using System;
-using System.Linq;
 
 namespace FlatBuffers
 {
 namespace FlatBuffers
 _pos = 0;
 }
 
- public int position() { return _pos; }
+ public int Position { get { return _pos; } }
 
 // Pre-allocated helper arrays for convertion.
 private float[] floathelper = new[] { 0.0f };
",345,62
"Add missing newline in help text for flatc.

Tested: Help text displays correctly now.
Change-Id: Ibbdc810ae41e24321860879064bdc64f78a67cb9"," static void Error(const std::string &err, bool usage, bool show_exe_name) {
 "" generated file depends on (C++).\n""
 "" --gen-mutable Generate accessors that can mutate buffers in-place.\n""
 "" --raw-binary Allow binaries without file_indentifier to be read.\n""
- "" This may crash flatc given a mismatched schema.""
+ "" This may crash flatc given a mismatched schema.\n""
 "" --proto Input is a .proto, translate to .fbs.\n""
 ""FILEs may depend on declarations in earlier files.\n""
 ""FILEs after the -- must be binary flatbuffer format files.\n""
",202,38
"Added namespaced way to refer to types in schemas.
Also made proper namespacing work for enums.

You can now say namespace.MyTable as the type when declaring
a field that refers to a type in a different namespace.

Previously, it would work just referring to MyTable, however
with the recent commit fixing namespaced types this now
is ambiguous.

Change-Id: Ieaa3f4ac1662b8c4dc1f16e1898ea3cdb02e10fd
Tested: on Linux."," class Parser {
 void Next();
 bool IsNext(int t);
 void Expect(int t);
+ EnumDef *LookupEnum(const std::string &id);
+ void ParseNamespacing(std::string *id, std::string *last);
 void ParseTypeIdent(Type &type);
 void ParseType(Type &type);
 FieldDef &AddField(StructDef &struct_def,
",313,25
"Initially discussed in #178.

Allows adding an already encoded UTF-8 string directly without
having to convert to a ``String`` first.

Change-Id: I23f9c738eec18fd35f4c14f58dbd0f6cf0970dc7"," public class FlatBufferBuilder {
 return endVector();
 }
 
+ /**
+ * Encode the string {@code s} in the buffer using UTF-8.
+ *
+ * @param s An already encoded UTF-8 string
+ * @return The offset in the buffer where the encoded string starts
+ */
+ public int createString(ByteBuffer s) {
+ int length = s.remaining();
+ addByte((byte)0);
+ startVector(1, length, 1);
+ bb.position(space -= length);
+ bb.put(s);
+ return endVector();
+ }
+
 /**
 * Should not be creating any other object, string or vector
 * while an object is being constructed
",231,89
"Union accessors in C# should use generic type for the table

When accessing a union field, we should return the same object type
as was given to the method, i.e. the parameter should have a generic
type for any Table-derived type. This way, we do not need to make
superfluous casts (which also reduce type safety) like

var myUnionType = (MyUnionType)buff.GetUnionField(new MyUnionType());

when we can do just
var myUnionType = buff.GetUnionField(new MyUnionType());

Change-Id: Idac1b638e46cc50b1f2dc19f10741481202b1515"," namespace FlatBuffers
 }
 
 // Initialize any Table-derived type to point to the union at the given offset.
- protected Table __union(Table t, int offset)
+ protected TTable __union<TTable>(TTable t, int offset) where TTable : Table
 {
 offset += bb_pos;
 t.bb_pos = offset + bb.GetInt(offset);
",54,10
"Issue #188

When accessing the array directly of a byte buffer, need to offset
by ``arrayOffset``"," public class Table {
 protected String __string(int offset) {
 offset += bb.getInt(offset);
 if (bb.hasArray()) {
- return new String(bb.array(), offset + SIZEOF_INT, bb.getInt(offset), FlatBufferBuilder.utf8charset);
+ return new String(bb.array(), bb.arrayOffset() + offset + SIZEOF_INT, bb.getInt(offset), FlatBufferBuilder.utf8charset);
 } else {
 // We can't access .array(), since the ByteBuffer is read-only,
 // off-heap or a memory map
",60,14
update CheckClash for string accesses," void Parser::ParseDecl() {
 CheckClash(""Type"", BASE_TYPE_UNION);
 CheckClash(""_length"", BASE_TYPE_VECTOR);
 CheckClash(""Length"", BASE_TYPE_VECTOR);
+ CheckClash(""_byte_vector"", BASE_TYPE_STRING);
+ CheckClash(""ByteVector"", BASE_TYPE_STRING);
 Expect('}');
 }
 
",1024,335
remove remaining allocs during build," func BenchmarkBuildGold(b *testing.B) {
 reuse_fred := []byte(""Fred"")
 
 b.SetBytes(bytes_length)
-bldr := flatbuffers.NewBuilder(512)
+bldr := flatbuffers.NewBuilder(0)
+b.ResetTimer()
 b.ReportAllocs()
 for i := 0; i < b.N; i++ {
 bldr.Reset()
",1001,112
invoke many fewer growth events," func NewBuilder(initialSize int) *Builder {
 // Reset truncates the underlying Builder buffer, facilitating alloc-free
 // reuse of a Builder.
 func (b *Builder) Reset() {
-b.head = UOffsetT(0)
-b.minalign = 1
-
 if b.Bytes != nil {
-b.Bytes = b.Bytes[:0]
+b.Bytes = b.Bytes[:cap(b.Bytes)]
 }
 
 if b.vtables != nil {
 func (b *Builder) Reset() {
 if b.vtable != nil {
 b.vtable = b.vtable[:0]
 }
+
+b.head = UOffsetT(len(b.Bytes))
+b.minalign = 1
 }
 
 // StartObject initializes bookkeeping for writing a new object.
 func (b *Builder) growByteBuffer() {
 
 middle := newLen / 2
 copy(b.Bytes[middle:], b.Bytes[:middle])
-for i := 0; i < middle; i++ {
-b.Bytes[i] = 0
-}
 }
 
 // Head gives the start of useful data in the underlying byte buffer.
",412,107
"Added a default costructor for Java's FlatBufferBuilder.

Default's size of 1024b like in cpp. Fixes #190."," public class FlatBufferBuilder {
 bb = newByteBuffer(initial_size);
 }
 
+ /**
+ * Start with a buffer of 1KiB, then grow as required.
+ */
+ public FlatBufferBuilder() {
+ this(1024);
+ }
+
 /**
 * Alternative constructor allowing reuse of {@link ByteBuffer}s. The builder
 * can still grow the buffer as necessary. User classes should make sure
",226,89
"Fixed schemas inheriting namespace from included schemas.

Change-Id: Ib561430b235eddf4bfe20f68409e1dfdb359ef2b
Tested: on Linux."," bool Parser::Parse(const char *source, const char **include_paths,
 }
 Expect(';');
 }
+ // Start with a blank namespace just in case this file doesn't have one.
+ namespaces_.push_back(new Namespace());
 // Now parse all other kinds of declarations:
 while (token_ != kTokenEof) {
 if (proto_mode_) {
",1061,348
Fixed endianness Vector's begin() and end()," public:
 iterator begin() { return iterator(Data(), 0); }
 const_iterator begin() const { return const_iterator(Data(), 0); }
 
- iterator end() { return iterator(Data(), length_); }
- const_iterator end() const { return const_iterator(Data(), length_); }
+ iterator end() { return iterator(Data(), EndianScalar(length_)); }
+ const_iterator end() const { return const_iterator(Data(), EndianScalar(length_)); }
 
 // Change elements if you have a non-const pointer to this object.
 void Mutate(uoffset_t i, T val) {
",682,189
fix string catenation," def main():
 import os
 import sys
 if not len(sys.argv) == 4:
- sys.stderr.write(('Usage: %s <benchmark vtable count>')
- ('<benchmark read count> <benchmark build count>')
- ('\n' % sys.argv[0]))
- sys.stderr.write((' Provide COMPARE_GENERATED_TO_GO=1 to check')
- ('for bytewise comparison to Go data.\n'))
- sys.stderr.write((' Provide COMPARE_GENERATED_TO_JAVA=1 to check')
- ('for bytewise comparison to Java data.\n'))
+ sys.stderr.write('Usage: %s <benchmark vtable count>'
+ '<benchmark read count> <benchmark build count>\n'
+ % sys.argv[0])
+ sys.stderr.write(' Provide COMPARE_GENERATED_TO_GO=1 to check'
+ 'for bytewise comparison to Go data.\n')
+ sys.stderr.write(' Provide COMPARE_GENERATED_TO_JAVA=1 to check'
+ 'for bytewise comparison to Java data.\n')
 sys.stderr.flush()
 sys.exit(1)
 
",1011,135
use EnsureDirExists from util.h instead of mkdir," static bool SaveType(const Parser &parser, const Definition &def,
 }
 namespace_name = *it;
 namespace_dir += *it;
- mkdir(namespace_dir.c_str(), S_IRWXU|S_IRGRP|S_IXGRP|S_IROTH|S_IXOTH);
+ EnsureDirExists(namespace_dir.c_str());
 
 std::string init_py_filename = namespace_dir + ""/__init__.py"";
 SaveFile(init_py_filename.c_str(), """", false);
",520,88
fixed the windows build files," static void GenTable(const Parser &parser, StructDef &struct_def,
 nested->constant);
 auto nested_root = parser.structs_.Lookup(qualified_name);
 assert(nested_root); // Guaranteed to exist by parser.
+ (void)nested_root;
 std::string cpp_qualified_name = TranslateNameSpace(qualified_name);
 
 code += "" const "" + cpp_qualified_name + "" *"" + field.name;
",645,131
Regenerate Doxygen docs to add Python usage page.," var NAVTREE =
 [ ""Use in C++"", ""md__cpp_usage.html"", null ],
 [ ""Use in Go"", ""md__go_usage.html"", null ],
 [ ""Use in Java/C-sharp"", ""md__java_usage.html"", null ],
+ [ ""Use in Python"", ""md__python_usage.html"", null ],
 [ ""Benchmarks"", ""md__benchmarks.html"", null ],
 [ ""FlatBuffers white paper"", ""md__white_paper.html"", null ],
 [ ""FlatBuffer Internals"", ""md__internals.html"", null ],
",506,121
"Go: CreateString now needs zero allocs.

Big speed boost for the typical use case of building with strings."," func (b *Builder) EndVector(vectorNumElems int) UOffsetT {
 
 // CreateString writes a null-terminated string as a vector.
 func (b *Builder) CreateString(s string) UOffsetT {
-return b.CreateByteString([]byte(s))
+b.Prep(int(SizeUOffsetT), (len(s)+1)*SizeByte)
+b.PlaceByte(0)
+
+l := UOffsetT(len(s))
+
+b.head -= l
+copy(b.Bytes[b.head:b.head+l], s)
+
+return b.EndVector(len(s))
 }
 
 // CreateByteString writes a byte slice as a string (null-terminated).
",417,107
use escape codes here for non-unicode editors," func CheckByteLayout(fail func(string, ...interface{})) {
 // test 6b: CreateString unicode
 
 b = flatbuffers.NewBuilder(0)
-b.CreateString("""")
+b.CreateString(""\u65e5\u672c\u8a9e"") // chinese from blog.golang.org/strings
 check([]byte{9, 0, 0, 0, 230, 151, 165, 230, 156, 172, 232, 170, 158, 0, // null-terminated, 2-byte pad
 0, 0})
 
",1016,113
Improve comment for unicode check.," func CheckByteLayout(fail func(string, ...interface{})) {
 // test 6b: CreateString unicode
 
 b = flatbuffers.NewBuilder(0)
-b.CreateString(""\u65e5\u672c\u8a9e"") // chinese from blog.golang.org/strings
+// These characters are chinese from blog.golang.org/strings
+// We use escape codes here so that editors without unicode support
+// aren't bothered:
+uni_str := ""\u65e5\u672c\u8a9e""
+b.CreateString(uni_str) 
 check([]byte{9, 0, 0, 0, 230, 151, 165, 230, 156, 172, 232, 170, 158, 0, // null-terminated, 2-byte pad
 0, 0})
 
",1017,113
Add include for cstdlib for std::bsearch definition,"
 
 #include <cstdint>
 #include <cstddef>
+#include <cstdlib>
 #include <cstring>
 #include <string>
 #include <type_traits>
",681,188
"Java: Allow access to the underlying ByteBuffer from a table.

Change-Id: Id268e35de207c25c809a09071b81eea873c9123e
Tested: on Linux."," public class Table {
 protected int bb_pos;
 protected ByteBuffer bb;
 
+ public ByteBuffer getByteBuffer() { return bb; }
+
 // Look up a field in the vtable, return an offset into the object, or 0 if the field is not
 // present.
 protected int __offset(int vtable_offset) {
",61,15
"Fixed -Wunused-result warning.

Change-Id: Iea5fab66047ac0a5057a743dbb1fdb27c063188c
Tested: on Linux."," StructDef &Parser::StartStruct() {
 if (!files_being_parsed_.empty()) struct_def.file = files_being_parsed_.top();
 // Move this struct to the back of the vector just in case it was predeclared,
 // to preserve declaration order.
- remove(structs_.vec.begin(), structs_.vec.end(), &struct_def);
- structs_.vec.back() = &struct_def;
+ *remove(structs_.vec.begin(), structs_.vec.end(), &struct_def) = &struct_def;
 return struct_def;
 }
 
",1062,348
"Small readability improvements to recent commits.

Change-Id: I290c33c475f7b019ab0d3c571245d27351d22fa1
Tested: on Linux."," public:
 iterator begin() { return iterator(Data(), 0); }
 const_iterator begin() const { return const_iterator(Data(), 0); }
 
- iterator end() { return iterator(Data(), EndianScalar(length_)); }
- const_iterator end() const { return const_iterator(Data(), EndianScalar(length_)); }
+ iterator end() { return iterator(Data(), size()); }
+ const_iterator end() const { return const_iterator(Data(), size()); }
 
 // Change elements if you have a non-const pointer to this object.
 void Mutate(uoffset_t i, T val) {
 public:
 }
 
 template<typename K> return_type LookupByKey(K key) const {
- std::size_t count = size();
- void *search_result = std::bsearch(&key, Data(), count,
+ void *search_result = std::bsearch(&key, Data(), size(),
 IndirectHelper<T>::element_stride, KeyCompare<K>);
 
 if (!search_result) {
",680,188
"Added a #define for running tests without file access.

Change-Id: Ib2b7aa8a5641cf73fa0d6f2000db7fdd1aabab66
Tested: on Linux."," using namespace MyGame::Example;
 #include <android/log.h>
 #define TEST_OUTPUT_LINE(...) \
 __android_log_print(ANDROID_LOG_INFO, ""FlatBuffers"", __VA_ARGS__)
+ #define FLATBUFFERS_NO_FILE_TESTS
 #else
 #define TEST_OUTPUT_LINE(...) \
 { printf(__VA_ARGS__); printf(""\n""); }
 int main(int /*argc*/, const char * /*argv*/[]) {
 
 MutateFlatBuffersTest(flatbuf.get(), rawbuf.length());
 
- #ifndef __ANDROID__ // requires file access
+ #ifndef FLATBUFFERS_NO_FILE_TESTS
 ParseAndGenerateTextTest();
 ParseProtoTest();
 #endif
",459,82
"Added --defaults-json to output fields at default value.

Normal behavior is to not output fields that happen to have
the default value, since those will be reproduced anyway
when turned into a FlatBuffer binary. This however can be problematic
when using JSON to interop with other system since they might not
know this default value. This flatc option (and also flag
to GenerateText) will force those fields to be output anyway.

Tested: on Linux."," extern void GenComment(const std::vector<std::string> &dc,
 // Container of options that may apply to any of the source/text generators.
 struct GeneratorOptions {
 bool strict_json;
+ bool output_default_scalars_in_json;
 int indent_step;
 bool output_enum_identifiers;
 bool prefixed_enums;
 struct GeneratorOptions {
 
 Language lang;
 
- GeneratorOptions() : strict_json(false), indent_step(2),
+ GeneratorOptions() : strict_json(false),
+ output_default_scalars_in_json(false),
+ indent_step(2),
 output_enum_identifiers(true), prefixed_enums(true),
 include_dependence_headers(false),
 mutable_buffer(false),
",320,25
option to generate one file for C#," struct GeneratorOptions {
 bool prefixed_enums;
 bool include_dependence_headers;
 bool mutable_buffer;
+ bool one_file;
 
 // Possible options for the more general generator below.
 enum Language { kJava, kCSharp, kGo, kMAX };
 struct GeneratorOptions {
 output_enum_identifiers(true), prefixed_enums(true),
 include_dependence_headers(false),
 mutable_buffer(false),
+ one_file(false),
 lang(GeneratorOptions::kJava) {}
 };
 
",322,25
fix code formatting and bug with losing enums when using --gen-onefile," int main(int argc, const char *argv[]) {
 opts.mutable_buffer = true;
 } else if(arg == ""--gen-includes"") {
 opts.include_dependence_headers = true;
- }else if (arg == ""--gen-onefile"") {
+ } else if (arg == ""--gen-onefile"") {
 opts.one_file = true;
- }else if (arg == ""--raw-binary"") {
+ } else if (arg == ""--raw-binary"") {
 raw_binary = true;
 } else if(arg == ""--"") { // Separator between text and binary inputs.
 binary_files_from = filenames.size();
",213,40
"Namespace now optional for general generator

If you have a schema with no namespace, the resulting C#/Java won't have
an erroneous empty namespace keyword."," static bool SaveClass(const LanguageParameters &lang, const Parser &parser,
 EnsureDirExists(namespace_dir);
 
 std::string code = ""// automatically generated, do not modify\n\n"";
- code += lang.namespace_ident + namespace_general + lang.namespace_begin;
- code += ""\n\n"";
+ if (!namespace_general.empty()) {
+ code += lang.namespace_ident + namespace_general + lang.namespace_begin;
+ code += ""\n\n"";
+ }
 if (needs_includes) code += lang.includes;
 code += classcode;
- code += lang.namespace_end;
+ if (!namespace_general.empty()) code += lang.namespace_end;
 auto filename = namespace_dir + def.name + lang.file_extension;
 return SaveFile(filename.c_str(), code, false);
 }
",840,181
Follow Google code standards," static bool SaveClass(const LanguageParameters &lang, const Parser &parser,
 
 std::string code = ""// automatically generated, do not modify\n\n"";
 if (!namespace_general.empty()) {
- code += lang.namespace_ident + namespace_general + lang.namespace_begin;
- code += ""\n\n"";
+code += lang.namespace_ident + namespace_general + lang.namespace_begin;
+code += ""\n\n"";
 }
 if (needs_includes) code += lang.includes;
 code += classcode;
",840,181
"Allowing _ as first character of identifiers in .fbs/.json.

Change-Id: Ie2cb42632f6a907a38e10b2c9be1536cf330b2fa
Tested: on Linux."," void Parser::Next() {
 }
 // fall thru
 default:
- if (isalpha(static_cast<unsigned char>(c))) {
+ if (isalpha(static_cast<unsigned char>(c)) || c == '_') {
 // Collect all chars of an identifier:
 const char *start = cursor_ - 1;
 while (isalnum(static_cast<unsigned char>(*cursor_)) ||
",1062,349
"Make generating dependent include files for C++ the default.

--gen-includes is now deprecate but still accepted.
--no-includes can be used instead when needed.

Change-Id: I2cd46d193032b9b7c31c76c6f655e9333d3a393a
Tested: on Linux."," struct GeneratorOptions {
 output_default_scalars_in_json(false),
 indent_step(2),
 output_enum_identifiers(true), prefixed_enums(true),
- include_dependence_headers(false),
+ include_dependence_headers(true),
 mutable_buffer(false),
 lang(GeneratorOptions::kJava) {}
 };
",320,25
"Initial reflection and resizing functionality.

Tested: on Linux.

Change-Id: I8f7bccf9b1ad87fea788f85e23fa69435758feca"," class FlatBufferBuilder FLATBUFFERS_FINAL_CLASS {
 }
 
 template<typename T> Offset<Vector<Offset<T>>> CreateVectorOfSortedTables(
- std::vector<T> *v) {
+ std::vector<Offset<T>> *v) {
 return CreateVectorOfSortedTables(v->data(), v->size());
 }
 
 class Table {
 return true;
 }
 
+ uint8_t *GetVTable() { return data_ - ReadScalar<soffset_t>(data_); }
+
 bool CheckField(voffset_t field) const {
 return GetOptionalFieldOffset(field) != 0;
 }
",681,189
"Removed unused variable.

Tested: on OS X."," class ResizeContext {
 public:
 ResizeContext(const reflection::Schema &schema, uoffset_t start, int delta,
 std::vector<uint8_t> *flatbuf)
- : schema_(schema), start_(start), startptr_(flatbuf->data() + start),
+ : schema_(schema), startptr_(flatbuf->data() + start),
 delta_(delta), buf_(*flatbuf),
 dag_check_(flatbuf->size() / sizeof(uoffset_t), false) {
 auto mask = sizeof(largest_scalar_t) - 1;
 class ResizeContext {
 
 private:
 const reflection::Schema &schema_;
- uoffset_t start_;
 uint8_t *startptr_;
 int delta_;
 std::vector<uint8_t> &buf_;
",267,86
Fixed warnings on Windows," const char kTypeSizes[] = {
 // The enums in the reflection schema should match the ones we use internally.
 // Compare the last element to check if these go out of sync.
 static_assert(BASE_TYPE_UNION ==
- static_cast<BaseType>(reflection::BaseType::Union),
+ static_cast<BaseType>(reflection::Union),
 ""enums don't match"");
 
 static void Error(const std::string &msg) {
 Offset<reflection::Object> StructDef::Serialize(FlatBufferBuilder *builder)
 const {
 std::vector<Offset<reflection::Field>> field_offsets;
 for (auto it = fields.vec.begin(); it != fields.vec.end(); ++it) {
- field_offsets.push_back((*it)->Serialize(builder, it - fields.vec.begin()));
+ field_offsets.push_back(
+ (*it)->Serialize(builder,
+ static_cast<uint16_t>(it - fields.vec.begin())));
 }
 return reflection::CreateObject(*builder,
 builder->CreateString(name),
",1152,366
"Small improvements to the C++ API.

Change-Id: Ib30ffbbd140a8b82fe664129fa4e8c55836267f8
Tested: on Linux."," class ResizeContext {
 auto enumdef = schema_.enums()->Get(fielddef->type()->index());
 // TODO: this is clumsy and slow, but no other way to find it?
 auto type_field = fielddefs->LookupByKey(
- (fielddef->name()->c_str() + std::string(""_type"")).c_str());
+ (fielddef->name()->str() + ""_type"").c_str());
 assert(type_field);
 auto union_type = GetFieldI<uint8_t>(table, type_field);
 auto enumval = enumdef->values()->LookupByKey(union_type);
",272,86
"Fixed possible crash from reference to non-static variable.

Change-Id: I1842098a7ef461e2e92dd35d79d8ca303e814867
Tested: on Linux."," bool Parser::Parse(const char *source, const char **include_paths,
 files_being_parsed_.push(source_filename);
 }
 if (!include_paths) {
- const char *current_directory[] = { """", nullptr };
+ static const char *current_directory[] = { """", nullptr };
 include_paths = current_directory;
 }
 source_ = cursor_ = source;
",1152,366
Fixed argument value to correct type," int main(int argc, const char *argv[]) {
 }
 }
 
- if (!filenames.size()) Error(""missing input files"", nullptr, true);
+ if (!filenames.size()) Error(""missing input files"", false, true);
 
 if (!any_generator)
 Error(""no options: specify one of -c -g -j -t -b etc."", true);
",224,43
"Reflection: generically copy (parts of) FlatBuffers.

Change-Id: Ief3f1507c003079eac90c2bb6c2abd64a80a0a34
Tested: on Linux."," class FlatBufferBuilder FLATBUFFERS_FINAL_CLASS {
 return CreateString(str.c_str(), str.length());
 }
 
+ Offset<String> CreateString(const String *str) {
+ return CreateString(str->c_str(), str->Length());
+ }
+
 uoffset_t EndVector(size_t len) {
 return PushElement(static_cast<uoffset_t>(len));
 }
",688,194
"Fixed null root_table access in binary schema generation.

Change-Id: Ia2b7abc10bee52814e815befcad6a89697295d8f
Tested: on Linux."," void Parser::Serialize() {
 builder_.CreateVectorOfSortedTables(&enum_offsets),
 builder_.CreateString(file_identifier_),
 builder_.CreateString(file_extension_),
- root_struct_def_->serialized_location);
+ root_struct_def_
+ ? root_struct_def_->serialized_location
+ : 0);
 builder_.Finish(schema_offset, reflection::SchemaIdentifier());
 }
 
",1156,367
"Made warning settings in Xcode more aggressive.

Tested: on OS X."," struct StructDef : public Definition {
 bytesize(0)
 {}
 
- void PadLastField(size_t minalign) {
- auto padding = PaddingBytes(bytesize, minalign);
+ void PadLastField(size_t min_align) {
+ auto padding = PaddingBytes(bytesize, min_align);
 bytesize += padding;
 if (fields.vec.size()) fields.vec.back()->padding = padding;
 }
",333,25
"Round up allocation size to avoid misalignment (issue #226)

Before this change, requesting a large initial allocation could cause the
backing store to grow to an unaligned size. Since memory inside vector_downward
is relative to the end of the buffer, this then caused all memory in the buffer
to be misaligned and also misaligns any further loads and stores. Misaligned
loads and stores are undefined behavior and don't work in environments such as
emscripten (a JavaScript to C++ compiler)."," class vector_downward {
 uint8_t *make_space(size_t len) {
 if (len > static_cast<size_t>(cur_ - buf_)) {
 auto old_size = size();
+ auto largest_align = AlignOf<largest_scalar_t>();
 reserved_ += std::max(len, growth_policy(reserved_));
+ // Round up to avoid undefined behavior from unaligned loads and stores.
+ reserved_ = (reserved_ + (largest_align - 1)) & ~(largest_align - 1);
 auto new_buf = allocator_.allocate(reserved_);
 auto new_cur = new_buf + reserved_ - old_size;
 memcpy(new_cur, cur_, old_size);
",690,194
added #include <stdio.h>,"
 
 #include <cstdint>
 #include <cstring>
+#include <stdio.h>
 
 namespace flatbuffers {
 
",72,10
"Passed field name as prefix for nested structs

This pull request should fix #232.
Pass field name instead of struct name as nameprefix for nested structures. Continuously concatenate nameprefix arguments to support deeper nested structures."," static void GenStructArgs(const LanguageParameters &lang,
 // don't clash, and to make it obvious these arguments are constructing
 // a nested struct, prefix the name with the struct name.
 GenStructArgs(lang, *field.value.type.struct_def, code_ptr,
- (field.value.type.struct_def->name + ""_"").c_str());
+ (nameprefix + (field.name + ""_"")).c_str());
 } else {
 code += "", "";
 code += GenTypeForUser(lang,
",856,185
builder.put statements now use correct argument names," static void GenStructBody(const LanguageParameters &lang,
 }
 if (IsStruct(field.value.type)) {
 GenStructBody(lang, *field.value.type.struct_def, code_ptr,
- (field.value.type.struct_def->name + ""_"").c_str());
+ (nameprefix + (field.name + ""_"")).c_str());
 } else {
 code += "" builder."" + FunctionStart(lang, 'P') + ""ut"";
 code += GenMethod(lang, field.value.type) + ""("";
",856,185
applied struct parameter fix to Go and Python generated classes," static void StructBuilderArgs(const StructDef &struct_def,
 // don't clash, and to make it obvious these arguments are constructing
 // a nested struct, prefix the name with the struct name.
 StructBuilderArgs(*field.value.type.struct_def,
- (field.value.type.struct_def->name + ""_"").c_str(),
+ (nameprefix + (field.name + ""_"")).c_str(),
 code_ptr);
 } else {
 std::string &code = *code_ptr;
 static void StructBuilderBody(const StructDef &struct_def,
 code += "" builder.Pad("" + NumToString(field.padding) + "")\n"";
 if (IsStruct(field.value.type)) {
 StructBuilderBody(*field.value.type.struct_def,
- (field.value.type.struct_def->name + ""_"").c_str(),
+ (nameprefix + (field.name + ""_"")).c_str(),
 code_ptr);
 } else {
 code += "" builder.Prepend"" + GenMethod(field) + ""("";
",539,92
2Gb buffer size checks fixed for Python Builder," class Builder(object):
 The internal buffer is grown as needed.
 """"""
 
- if not (0 <= initialSize < (2**UOffsetTFlags.bytewidth - 1)):
+ if not (0 <= initialSize <= self.MaxBufferSize()):
 msg = ""flatbuffers: Cannot create Builder larger than 2 gigabytes.""
 raise BuilderSizeError(msg)
 
 class Builder(object):
 self.objectEnd = None
 self.vtables = []
 
+ def MaxBufferSize(self):
+ """"""
+ Maximum buffer size is 2Gb.
+ """"""
+ return 2**31
+
 def Output(self):
 """"""
 Output returns the portion of the buffer that has been used for
 class Builder(object):
 def growByteBuffer(self):
 """"""Doubles the size of the byteslice, and copies the old data towards
 the end of the new buffer (since we build the buffer backwards).""""""
- if not len(self.Bytes) <= 2**20:
+ if not len(self.Bytes) <= self.MaxBufferSize():
 msg = ""flatbuffers: cannot grow buffer beyond 2 gigabytes""
 raise BuilderSizeError(msg)
 
",280,59
"Fixed reflection resizing code not checking strings in vectors.

Change-Id: I4081160a8281939ab282d7914ae396276c767882
Tested: on Linux."," class ResizeContext {
 break;
 }
 case reflection::Vector: {
- if (fielddef.type()->element() != reflection::Obj) break;
+ auto elem_type = fielddef.type()->element();
+ if (elem_type != reflection::Obj && elem_type != reflection::String)
+ break;
 auto vec = reinterpret_cast<Vector<uoffset_t> *>(ref);
- auto elemobjectdef =
- schema_.objects()->Get(fielddef.type()->index());
- if (elemobjectdef->is_struct()) break;
+ auto elemobjectdef = elem_type == reflection::Obj
+ ? schema_.objects()->Get(fielddef.type()->index())
+ : nullptr;
+ if (elemobjectdef && elemobjectdef->is_struct()) break;
 for (uoffset_t i = 0; i < vec->size(); i++) {
 auto loc = vec->Data() + i * sizeof(uoffset_t);
 if (DagCheck(loc))
 continue; // This offset already visited.
 auto dest = loc + vec->Get(i);
 Straddle<uoffset_t, 1>(loc, dest ,loc);
- ResizeTable(*elemobjectdef, reinterpret_cast<Table *>(dest));
+ if (elemobjectdef)
+ ResizeTable(*elemobjectdef, reinterpret_cast<Table *>(dest));
 }
 break;
 }
",445,130
"Updated pointer syntax to be consistent in SetString, etc."," class ResizeContext {
 public:
 ResizeContext(const reflection::Schema &schema, uoffset_t start, int delta,
 std::vector<uint8_t> *flatbuf,
- const reflection::Object* root_table = nullptr)
+ const reflection::Object *root_table = nullptr)
 : schema_(schema), startptr_(flatbuf->data() + start),
 delta_(delta), buf_(*flatbuf),
 dag_check_(flatbuf->size() / sizeof(uoffset_t), false) {
 class ResizeContext {
 // pass in your root_table type as well.
 inline void SetString(const reflection::Schema &schema, const std::string &val,
 const String *str, std::vector<uint8_t> *flatbuf,
- const reflection::Object* root_table = nullptr) {
+ const reflection::Object *root_table = nullptr) {
 auto delta = static_cast<int>(val.size()) - static_cast<int>(str->Length());
 auto start = static_cast<uoffset_t>(reinterpret_cast<const uint8_t *>(str) -
 flatbuf->data() +
",443,127
"Fixed compile error in older gcc's for trailing comma in enum.

Change-Id: I60f6da32fb2a30557fcf842624f68ca184f65e1f
Tested: on Linux.","
 enum OutputFormat {
 kDecimal,
 kHexadecimal,
- kHexadecimal0x,
+ kHexadecimal0x
 };
 
 int main(int argc, char* argv[]) {
",77,20
Base type safety in C#. Clear FlatBufferBuilder in C#.," namespace flatbuffers {
 TD(FLOAT, ""float"", float, float, float32, float, float32) /* begin float */ \
 TD(DOUBLE, ""double"", double, double, float64, double, float64) /* end float/scalar */
 #define FLATBUFFERS_GEN_TYPES_POINTER(TD) \
- TD(STRING, ""string"", Offset<void>, int, int, int, int) \
- TD(VECTOR, """", Offset<void>, int, int, int, int) \
+ TD(STRING, ""string"", Offset<void>, int, int, StringOffset, int) \
+ TD(VECTOR, """", Offset<void>, int, int, VectorOffset, int) \
 TD(STRUCT, """", Offset<void>, int, int, int, int) \
 TD(UNION, """", Offset<void>, int, int, int, int)
 
",333,25
remove unused funciton.," static std::string GenOffsetType(const LanguageParameters &lang, const StructDef
 }
 }
 
-static std::string GenOffsetConstruct(const LanguageParameters &lang,
- const Type &type,
- const std::string &variable_name)
-{
- if(lang.language == GeneratorOptions::kCSharp) {
- switch(type.base_type) {
- case BASE_TYPE_VECTOR: return ""new VectorOffset("" + variable_name + "")"";
- case BASE_TYPE_STRING: return ""new StringOffset("" + variable_name + "")"";
- }
- }
- return variable_name;
-}
-
 static std::string GenOffsetConstruct(const LanguageParameters &lang,
 const StructDef &struct_def,
 const std::string &variable_name)
",904,205
"Fixed small inaccurracies in the schema grammar.

Change-Id: I6e9e66c3d7d67c54617bc892f612b7341bebd7e0"," var NAVTREE =
 [ ""Benchmarks"", ""md__benchmarks.html"", null ],
 [ ""FlatBuffers white paper"", ""md__white_paper.html"", null ],
 [ ""FlatBuffer Internals"", ""md__internals.html"", null ],
- [ ""Formal Grammar of the schema language"", ""md__grammar.html"", null ]
+ [ ""Grammar of the schema language"", ""md__grammar.html"", null ]
 ] ]
 ];
 
",506,121
support for scalar mutators," public sealed class Stat : Table {
 
 public string Id { get { int o = __offset(4); return o != 0 ? __string(o + bb_pos) : null; } }
 public long Val { get { int o = __offset(6); return o != 0 ? bb.GetLong(o + bb_pos) : (long)0; } }
+ public bool MutateVal(long val) { int o = __offset(6); if (o != 0) { bb.PutLong(o + bb_pos); return true } else { return false } }
 public ushort Count { get { int o = __offset(8); return o != 0 ? bb.GetUshort(o + bb_pos) : (ushort)0; } }
+ public bool MutateCount(ushort count) { int o = __offset(8); if (o != 0) { bb.PutUshort(o + bb_pos); return true } else { return false } }
 
 public static int CreateStat(FlatBufferBuilder builder,
 int id = 0,
",32,13
extended scalar mutator support," namespace FlatBuffers
 _pos = offset;
 }
 
+ // this method exists in order to conform with Java ByteBuffer standards
+ public void Put(int offset, byte value)
+ {
+ PutByte(offset, value);
+ }
+
 #if UNSAFE_BYTEBUFFER
 // Unsafe but more efficient versions of Put*.
 public void PutShort(int offset, short value)
",349,63
small refactor to GenSetter method," static std::string GenGetter(const LanguageParameters &lang,
 }
 }
 
+// Direct mutation is only allowed for scalar fields.
+// Hence a setter method will only be generated for such fields.
 static std::string GenSetter(const LanguageParameters &lang,
 const Type &type) {
- switch (type.base_type) {
- case BASE_TYPE_STRUCT: return """";
- default: {
- std::string setter = ""bb."" + FunctionStart(lang, 'P') + ""ut"";
- if (GenTypeBasic(lang, type) != ""byte"" && 
- type.base_type != BASE_TYPE_BOOL) {
- setter += MakeCamel(GenTypeGet(lang, type));
- }
- return setter;
+ if (IsScalar(type.base_type)) {
+ std::string setter = ""bb."" + FunctionStart(lang, 'P') + ""ut"";
+ if (GenTypeBasic(lang, type) != ""byte"" && 
+ type.base_type != BASE_TYPE_BOOL) {
+ setter += MakeCamel(GenTypeGet(lang, type));
 }
+ return setter;
+ } else {
+ return """";
 }
 }
 
",889,194
"Reworked reflection.h to be more general.

e.g. support generic reading/writing from structs/vectors etc.

Change-Id: I2eb6e24db088a72da444d5c8df7e506e53d5bc2d
Tested: on Linux.
Bug: 22660837"," void ReflectionTest(uint8_t *flatbuf, size_t length) {
 TEST_EQ(hp_int64, 80);
 auto hp_double = flatbuffers::GetAnyFieldF(root, hp_field);
 TEST_EQ(hp_double, 80.0);
- auto hp_string = flatbuffers::GetAnyFieldS(root, hp_field, schema);
+ auto hp_string = flatbuffers::GetAnyFieldS(root, hp_field, &schema);
 TEST_EQ_STR(hp_string.c_str(), ""80"");
 
 // We can also modify it.
",547,86
"Fixed AddFlatBuffer using wrong buffer length.

Also made the Xcode project link.

Tested: on OS X."," const uint8_t *AddFlatBuffer(std::vector<uint8_t> &flatbuf,
 }
 auto insertion_point = static_cast<uoffset_t>(flatbuf.size());
 // Insert the entire FlatBuffer minus the root pointer.
- flatbuf.insert(flatbuf.end(), newbuf + sizeof(uoffset_t),
- newbuf + newlen - sizeof(uoffset_t));
+ flatbuf.insert(flatbuf.end(), newbuf + sizeof(uoffset_t), newbuf + newlen);
 auto root_offset = ReadScalar<uoffset_t>(newbuf) - sizeof(uoffset_t);
 return flatbuf.data() + insertion_point + root_offset;
 }
",376,118
"Clarified the use of the deprecated flatc --gen-includes flag.

Also, removed the flag from the Android makefile.

Tested:
Verified flatc builds successfully on Linux and regenerated the docs.

Change-Id: I7140daa10b7cb9a29b5ffd63c6b20489e72a5899"," static void Error(const std::string &err, bool usage, bool show_exe_name) {
 "" --defaults-json Output fields whose value is the default when\n""
 "" writing JSON\n""
 "" --no-prefix Don\'t prefix enum values with the enum type in C++.\n""
- "" --gen-includes (deprecated), instead use:\n""
+ "" --gen-includes (deprecated), this is the default behavior.\n""
+ "" If the original behavior is required (no include\n""
+ "" statements) use --no-includes.\n""
 "" --no-includes Don\'t generate include statements for included\n""
 "" schemas the generated file depends on (C++).\n""
 "" --gen-mutable Generate accessors that can mutate buffers in-place.\n""
",226,43
"Changed maximum force_align to match the C++ code generator.

Change-Id: I7df2b0172f5de6f7bdbd8778361794004cd06062
Tested: on Linux."," void Parser::ParseDecl() {
 auto align = static_cast<size_t>(atoi(force_align->constant.c_str()));
 if (force_align->type.base_type != BASE_TYPE_INT ||
 align < struct_def.minalign ||
- align > 256 ||
+ align > 16 ||
 align & (align - 1))
 Error(""force_align must be a power of two integer ranging from the""
- ""struct\'s natural alignment to 256"");
+ ""struct\'s natural alignment to 16"");
 struct_def.minalign = align;
 }
 struct_def.PadLastField(struct_def.minalign);
",1156,367
"Fix missing break statement in SetAnyValueS case.

Causing SetAnyValueS to treat all scalars as integers.

Change-Id: Ib467b255e7f32a1478180a91e65def31676399eb"," void SetAnyValueF(reflection::BaseType type, uint8_t *data, double val) {
 void SetAnyValueS(reflection::BaseType type, uint8_t *data, const char *val) {
 switch (type) {
 case reflection::Float:
- case reflection::Double: SetAnyValueF(type, data, strtod(val, nullptr));
+ case reflection::Double:
+ SetAnyValueF(type, data, strtod(val, nullptr));
+ break;
 // TODO: support strings.
 default: SetAnyValueI(type, data, StringToInt(val)); break;
 }
",378,118
begin to correct C# bytebuffer behavior," public final class Stat extends Table {
 public long val() { int o = __offset(6); return o != 0 ? bb.getLong(o + bb_pos) : 0; }
 public boolean mutateVal(long val) { int o = __offset(6); if (o != 0) { bb.putLong(o + bb_pos, val); return true; } else { return false; } }
 public int count() { int o = __offset(8); return o != 0 ? bb.getShort(o + bb_pos) & 0xFFFF : 0; }
- public boolean mutateCount(short count) { int o = __offset(8); if (o != 0) { bb.putShort(o + bb_pos, count); return true; } else { return false; } }
+ public boolean mutateCount(int count) { int o = __offset(8); if (o != 0) { bb.putShort(o + bb_pos, (short)count); return true; } else { return false; } }
 
 public static int createStat(FlatBufferBuilder builder,
 int id,
",34,20
fixed C# bytebuffer put methods," namespace FlatBuffers
 
 public byte[] Data { get { return _buffer; } }
 
- public ByteBuffer(byte[] buffer)
+ public ByteBuffer(byte[] buffer) : this(buffer, 0) { }
+
+ public ByteBuffer(byte[] buffer, int pos)
 {
 _buffer = buffer;
- _pos = 0;
+ _pos = pos;
 }
 
- public int Position { get { return _pos; } }
+ public int Position {
+ get { return _pos; }
+ set { _pos = value; }
+ }
 
 // Pre-allocated helper arrays for convertion.
 private float[] floathelper = new[] { 0.0f };
 namespace FlatBuffers
 _buffer[offset + count - 1 - i] = (byte)(data >> i * 8);
 }
 }
- _pos = offset;
 }
 
 protected ulong ReadLittleEndian(int offset, int count)
 namespace FlatBuffers
 {
 AssertOffsetAndLength(offset, sizeof(sbyte));
 _buffer[offset] = (byte)value;
- _pos = offset;
 }
 
 public void PutByte(int offset, byte value)
 {
 AssertOffsetAndLength(offset, sizeof(byte));
 _buffer[offset] = value;
- _pos = offset;
 }
 
 // this method exists in order to conform with Java ByteBuffer standards
",350,64
removed console print from code," namespace FlatBuffers
 Buffer.BlockCopy(oldBuf, 0, newBuf, newBufSize - oldBufSize,
 oldBufSize);
 _bb = new ByteBuffer(newBuf, newBufSize);
- System.Diagnostics.Debug.WriteLine(_bb.Position);
 }
 
 // Prepare to write an element of `size` after `additional_bytes`
",278,86
added a successful test run console print," namespace FlatBuffers.Test
 
 }
 
+ Console.WriteLine(""FlatBuffers test: completed successfully"");
 return 0;
 }
 }
",42,3
"[Issue 252] Add type cast for default enum values in C#

When creating a CreateXxx(...) method for a simple table type,
enum-type fields with a non-zero default must have an explicit
cast for the respective argument default value, because in C#,
there is an implicit cast from int to an enum only for 0.

Also, added an example of such type into the example monster_test
type, so that we test this feature."," static void GenStruct(const LanguageParameters &lang, const Parser &parser,
 // Java doesn't have defaults, which means this method must always
 // supply all arguments, and thus won't compile when fields are added.
 if (lang.language != GeneratorOptions::kJava) {
- code += "" = "" + GenDefaultValue(lang, field.value, false);
+ code += "" = "";
+ // in C#, enum values have their own type, so we need to cast the
+ // numeric value to the proper type
+ if (lang.language == GeneratorOptions::kCSharp &&
+ field.value.type.enum_def != nullptr &&
+ field.value.type.base_type != BASE_TYPE_UNION) {
+ code += ""("" + field.value.type.enum_def->name + "")"";
+ }
+ code += GenDefaultValue(lang, field.value, false);
 }
 }
 code += "") {\n builder."";
",912,208
"Add missing Python files from type cast commit.

Change-Id: I800119d8fe19f4c3e95772aba629ef8b2deb9e4b","
+# automatically generated, do not modify
+
+# namespace: Example
+
+import flatbuffers
+
+class TestSimpleTableWithEnum(object):
+ __slots__ = ['_tab']
+
+ # TestSimpleTableWithEnum
+ def Init(self, buf, pos):
+ self._tab = flatbuffers.table.Table(buf, pos)
+
+ # TestSimpleTableWithEnum
+ def Color(self):
+ o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
+ if o != 0:
+ return self._tab.Get(flatbuffers.number_types.Int8Flags, o + self._tab.Pos)
+ return 2
+
+def TestSimpleTableWithEnumStart(builder): builder.StartObject(1)
+def TestSimpleTableWithEnumAddColor(builder, color): builder.PrependInt8Slot(0, color, 2)
+def TestSimpleTableWithEnumEnd(builder): return builder.EndObject()
",13,3
"Added a platform / language / feature support matrix to docs.

This is just a start, will need to be extended.

Change-Id: I5a9ad671911942dcb83fdd2bae537deed751cbfd"," var NAVTREE =
 [ ""Use in Go"", ""md__go_usage.html"", null ],
 [ ""Use in Java/C-sharp"", ""md__java_usage.html"", null ],
 [ ""Use in Python"", ""md__python_usage.html"", null ],
+ [ ""Platform / Language / Feature support"", ""md__support.html"", null ],
 [ ""Benchmarks"", ""md__benchmarks.html"", null ],
 [ ""FlatBuffers white paper"", ""md__white_paper.html"", null ],
 [ ""FlatBuffer Internals"", ""md__internals.html"", null ],
",507,121
Incorrect buffer size check fixed.," class Builder(object):
 def growByteBuffer(self):
 """"""Doubles the size of the byteslice, and copies the old data towards
 the end of the new buffer (since we build the buffer backwards).""""""
- if not len(self.Bytes) <= Builder.MAX_BUFFER_SIZE:
+ if len(self.Bytes) == Builder.MAX_BUFFER_SIZE:
 msg = ""flatbuffers: cannot grow buffer beyond 2 gigabytes""
 raise BuilderSizeError(msg)
 
- newSize = min( len(self.Bytes) * 2, Builder.MAX_BUFFER_SIZE )
+ newSize = min(len(self.Bytes) * 2, Builder.MAX_BUFFER_SIZE)
 if newSize == 0:
 newSize = 1
 bytes2 = bytearray(newSize)
",284,58
added vector mutators," namespace FlatBuffers.Test
 Assert.AreEqual(monster.MutateTestType(Any.Monster), true);
 Assert.AreEqual(monster.TestType, Any.Monster);
 
+ //mutate the inventory vector
+ Assert.AreEqual(monster.MutateInventory(0, 1), true);
+ Assert.AreEqual(monster.MutateInventory(1, 2), true);
+ Assert.AreEqual(monster.MutateInventory(2, 3), true);
+ Assert.AreEqual(monster.MutateInventory(3, 4), true);
+ Assert.AreEqual(monster.MutateInventory(4, 5), true);
+
+ for (int i = 0; i < monster.InventoryLength; i++)
+ {
+ Assert.AreEqual(monster.GetInventory(i), i + 1);
+ }
+
+ //reverse mutation
+ Assert.AreEqual(monster.MutateInventory(0, 0), true);
+ Assert.AreEqual(monster.MutateInventory(1, 1), true);
+ Assert.AreEqual(monster.MutateInventory(2, 2), true);
+ Assert.AreEqual(monster.MutateInventory(3, 3), true);
+ Assert.AreEqual(monster.MutateInventory(4, 4), true);
+
 // get a struct field and edit one of its fields
 Vec3 pos = monster.Pos;
 Assert.AreEqual(pos.X, 1.0f);
",136,8
"Clarified choice of types in Java/C# codegen.

Change-Id: I1f094f350145d13b12cbe367bae7c623cfbbd8d3"," static Type DestinationType(const LanguageParameters &lang, const Type &type,
 bool vectorelem) {
 if (lang.language != GeneratorOptions::kJava) return type;
 switch (type.base_type) {
+ // We use int for both uchar/ushort, since that generally means less casting
+ // than using short for uchar.
 case BASE_TYPE_UCHAR: return Type(BASE_TYPE_INT);
 case BASE_TYPE_USHORT: return Type(BASE_TYPE_INT);
 case BASE_TYPE_UINT: return Type(BASE_TYPE_LONG);
 static bool SaveClass(const LanguageParameters &lang, const Parser &parser,
 
 std::string code = ""// automatically generated, do not modify\n\n"";
 if (!namespace_general.empty()) {
-code += lang.namespace_ident + namespace_general + lang.namespace_begin;
-code += ""\n\n"";
+ code += lang.namespace_ident + namespace_general + lang.namespace_begin;
+ code += ""\n\n"";
 }
 if (needs_includes) code += lang.includes;
 code += classcode;
",912,208
"fixed code generator for array of bools

Change-Id: I3cdd801b641bf180222203a37634598350d340e3"," static void GenStruct(const LanguageParameters &lang, const Parser &parser,
 code += index;
 }
 code += "")"" + dest_mask + "" : "";
- code += IsScalar(field.value.type.element)
- ? default_cast + ""0""
- : ""null"";
+
+ code += field.value.type.element == BASE_TYPE_BOOL ? ""false"" :
+ (IsScalar(field.value.type.element) ? default_cast + ""0"" : ""null"");
 break;
 }
 case BASE_TYPE_UNION:
",977,233
"Fixed a clang warning about signed shifts.

Change-Id: I7c2bf87972ee0ba6811d6ed42e13300bff90e36f"," static void Error(const std::string &msg) {
 
 // Ensure that integer values we parse fit inside the declared integer type.
 static void CheckBitsFit(int64_t val, size_t bits) {
- auto mask = (1ll << bits) - 1; // Bits we allow to be used.
+ // Bits we allow to be used.
+ auto mask = static_cast<int64_t>((1ull << bits) - 1);
 if (bits < 64 &&
 (val & ~mask) != 0 && // Positive or unsigned.
 (val | mask) != -1) // Negative.
",1156,367
Python: Fix potential code generation issue of documentation comment.," static void GenStruct(const StructDef &struct_def,
 StructDef *root_struct_def) {
 if (struct_def.generated) return;
 
- GenComment(struct_def.doc_comment, code_ptr, nullptr);
+ GenComment(struct_def.doc_comment, code_ptr, nullptr, ""# "");
 BeginClass(struct_def, code_ptr);
 if (&struct_def == root_struct_def) {
 // Generate a special accessor for the table that has been declared as
 bool GeneratePython(const Parser &parser,
 }
 
 } // namespace flatbuffers
-
-
",520,88
"Improved the speed of LoadFile() in debug mode.

Apparently, istreambuf_iterator has a lot of overhead.

Change-Id: I804f4e8f2b380b05e939edefe0e1e88cd10e920c
Tested: on Linux."," inline bool FileExists(const char *name) {
 inline bool LoadFile(const char *name, bool binary, std::string *buf) {
 std::ifstream ifs(name, binary ? std::ifstream::binary : std::ifstream::in);
 if (!ifs.is_open()) return false;
- *buf = std::string(std::istreambuf_iterator<char>(ifs),
- std::istreambuf_iterator<char>());
+ ifs.seekg(0, std::ios::end);
+ (*buf).resize(ifs.tellg());
+ ifs.seekg(0, std::ios::beg);
+ ifs.read(&(*buf)[0], (*buf).size());
 return !ifs.bad();
 }
 
",169,48
"Add @SuppressWarnings(""unused"") to generated Java classes

Usually generators add @SuppressWarnings(""all"") to generated Java
classes to prevent IDEs from complaining about unused imports, etc.
Solving used imports seems pretty hard with current generator logic so
IMO this is the next best thing.

Yes, its appended to import block but that is the block that gives
these warnings in the first place."," LanguageParameters language_parameters[] = {
 ""position()"",
 ""offset()"",
 ""import java.nio.*;\nimport java.lang.*;\nimport java.util.*;\n""
- ""import com.google.flatbuffers.*;\n\n"",
+ ""import com.google.flatbuffers.*;\n\n@SuppressWarnings(\""unused\"")\n"",
 {
 ""/**"",
 "" *"",
",977,233
"Fix Visual Studio 2012 build warning.

Also, remove execute permissions on several source files.

Tested: Builds on Visual Studio 2012, and Linux.

Change-Id: Idaacb2ae8eba98ce2974218c2ab840e97a1d67e9"," inline bool LoadFile(const char *name, bool binary, std::string *buf) {
 std::ifstream ifs(name, binary ? std::ifstream::binary : std::ifstream::in);
 if (!ifs.is_open()) return false;
 ifs.seekg(0, std::ios::end);
- (*buf).resize(ifs.tellg());
+ (*buf).resize(static_cast<size_t>(ifs.tellg()));
 ifs.seekg(0, std::ios::beg);
 ifs.read(&(*buf)[0], (*buf).size());
 return !ifs.bad();
",169,48
"Implemented option --scoped-enum for C++ generator

This generates C++11 style scoped and strongly typed enums.
Enabling this option also implies --no-prefix."," struct GeneratorOptions {
 int indent_step;
 bool output_enum_identifiers;
 bool prefixed_enums;
+ bool scoped_enums;
 bool include_dependence_headers;
 bool mutable_buffer;
 bool one_file;
 struct GeneratorOptions {
 GeneratorOptions() : strict_json(false),
 output_default_scalars_in_json(false),
 indent_step(2),
- output_enum_identifiers(true), prefixed_enums(true),
+ output_enum_identifiers(true), prefixed_enums(true), scoped_enums(false),
 include_dependence_headers(true),
 mutable_buffer(false),
 one_file(false),
",334,25
"serialize boolean in JSON to ""true/false"" instead of ""0/1""

Change-Id: I90cf519c00eaf9ccd9fcab8035a91b9205587c3b"," template<typename T> void Print(T val, Type type, int /*indent*/,
 return;
 }
 }
- text += NumToString(val);
+
+ if (type.base_type == BASE_TYPE_BOOL) {
+ text += val ? ""true"" : ""false"";
+ } else {
+ text += NumToString(val);
+ }
 }
 
 // Print a vector a sequence of JSON values, comma separated, wrapped in ""[]"".
",246,58
"Fix an out-of bounds read when the element is bigger than the buffer.

Ensure the size of the buffer being checked is bigger than the element
of the buffer being checked. The buffer can be triggered when, for
example, the buffer is of length zero and we are checking for:

 Verify<uoffset_t>(buf_)

The condition above should fail."," class Verifier FLATBUFFERS_FINAL_CLASS {
 
 // Verify any range within the buffer.
 bool Verify(const void *elem, size_t elem_len) const {
- return Check(elem >= buf_ && elem <= end_ - elem_len);
+ return Check(elem_len <= (size_t) (end_ - buf_) && elem >= buf_ && elem <= end_ - elem_len);
 }
 
 // Verify a range indicated by sizeof(T).
",723,206
Remove duplicate Go test," func CheckReadBuffer(buf []byte, offset flatbuffers.UOffsetT, fail func(string,
 fail(FailString(""monster.TestType()"", example.AnyMonster, got))
 }
 
-if unionType := monster.TestType(); unionType != example.AnyMonster {
-fail(""monster.TestType()"")
-}
-
 // initialize a Table from a union field Test(...)
 var table2 flatbuffers.Table
 if ok := monster.Test(&table2); !ok {
",1073,127
"Removed call to pop_back on std::string.

The pop_back function was added to strings in C++11 and it appears not
all compilers we target support it. The call to pop_back has been
replaced with a call to erase.

Tested on Linux. All unit tests pass."," template<> inline std::string NumToString<double>(double t) {
 auto p = s.find_last_not_of('0');
 if (p != std::string::npos) {
 s.resize(p + 1); // Strip trailing zeroes.
- if (s.back() == '.') s.pop_back(); // Strip '.' if a whole number.
+ if (s.back() == '.')
+ s.erase(s.size() - 1, 1); // Strip '.' if a whole number.
 }
 return s;
 }
",170,48
"Fixed .proto translation making scalars into required fields.

Change-Id: If414d156b4e9bc7fead5f131823b2c419cdc4e2c
Tested: on Linux."," inline const char **EnumNamesColor() {
 return names;
 }
 
-inline const char *EnumNameColor(Color e) { return EnumNamesColor()[e]; }
+inline const char *EnumNameColor(Color e) { return EnumNamesColor()[static_cast<int>(e)]; }
 
 enum Any {
 Any_NONE = 0,
 inline const char **EnumNamesAny() {
 return names;
 }
 
-inline const char *EnumNameAny(Any e) { return EnumNamesAny()[e]; }
+inline const char *EnumNameAny(Any e) { return EnumNamesAny()[static_cast<int>(e)]; }
 
 inline bool VerifyAny(flatbuffers::Verifier &verifier, const void *union_obj, Any type);
 
",112,49
"Fix 32bit-system integer overflow (test only)

For #277"," func checkFuzz(fuzzFields, fuzzObjects int, fail func(string, ...interface{})) {
 
 for j := 0; j < fuzzFields; j++ {
 f := flatbuffers.VOffsetT((flatbuffers.VtableMetadataFields + j) * flatbuffers.SizeVOffsetT)
-choice := int(l.Next()) % testValuesMax
+choice := l.Next() % uint32(testValuesMax)
 
 switch choice {
 case 0:
",1073,127
Fixed LoadFile on Windows," inline bool FileExists(const char *name) {
 inline bool LoadFile(const char *name, bool binary, std::string *buf) {
 std::ifstream ifs(name, binary ? std::ifstream::binary : std::ifstream::in);
 if (!ifs.is_open()) return false;
- ifs.seekg(0, std::ios::end);
- (*buf).resize(static_cast<size_t>(ifs.tellg()));
- ifs.seekg(0, std::ios::beg);
- ifs.read(&(*buf)[0], (*buf).size());
+ if (binary) {
+ // The fastest way to read a file into a string.
+ ifs.seekg(0, std::ios::end);
+ (*buf).resize(static_cast<size_t>(ifs.tellg()));
+ ifs.seekg(0, std::ios::beg);
+ ifs.read(&(*buf)[0], (*buf).size());
+ } else {
+ // This is slower, but works correctly on all platforms for text files.
+ std::ostringstream oss;
+ oss << ifs.rdbuf();
+ *buf = oss.str();
+ }
 return !ifs.bad();
 }
 
",176,49
"Add self.assertNotNested() in CreateString

And also add a test case.
If you try to nest CreateString you will get a clear exception."," class Builder(object):
 def CreateString(self, s):
 """"""CreateString writes a null-terminated byte string as a vector.""""""
 
+ self.assertNotNested()
+
 if isinstance(s, compat.string_types):
 x = s.encode()
 elif isinstance(s, compat.binary_type):
",285,58
"Added support for imports and many other .proto features.

Change-Id: I6600021b7ec8c486794349511232c3e604421c5b
Tested: on Linux."," static void GenTable(const Parser &parser, StructDef &struct_def,
 }
 auto nested = field.attributes.Lookup(""nested_flatbuffer"");
 if (nested) {
- std::string qualified_name = parser.GetFullyQualifiedName(
- nested->constant);
+ std::string qualified_name =
+ parser.namespaces_.back()->GetFullyQualifiedName(nested->constant);
 auto nested_root = parser.structs_.Lookup(qualified_name);
 assert(nested_root); // Guaranteed to exist by parser.
 (void)nested_root;
 std::string GenerateCPP(const Parser &parser,
 // Generate convenient global helper functions:
 if (parser.root_struct_def_) {
 auto &name = parser.root_struct_def_->name;
- std::string qualified_name = parser.GetFullyQualifiedName(name);
+ std::string qualified_name =
+ parser.namespaces_.back()->GetFullyQualifiedName(name);
 std::string cpp_qualified_name = TranslateNameSpace(qualified_name);
 
 // The root datatype accessor:
",660,136
"Add support for JavaScript code generation

This adds a JavaScript language target. The generated JavaScript uses Google
Closure Compiler type annotations and can be compiled using the advanced
compilation mode, which performs type checking and optimizations such as
inlining and dead code elimination. The generated JavaScript also exports all
generated symbols for use with Node.js and RequireJS. This export behavior
can be turned off with the --no-js-exports flag for use with Google Closure
Compiler."," const Generator generators[] = {
 flatbuffers::GeneratorOptions::kJava,
 ""Generate Java classes for tables/structs"",
 flatbuffers::GeneralMakeRule },
+ { flatbuffers::GenerateJS, ""-s"", ""JavaScript"",
+ flatbuffers::GeneratorOptions::kMAX,
+ ""Generate JavaScript code for tables/structs"",
+ flatbuffers::JSMakeRule },
 { flatbuffers::GenerateGeneral, ""-n"", ""C#"",
 flatbuffers::GeneratorOptions::kCSharp,
 ""Generate C# classes for tables/structs"",
 int main(int argc, const char *argv[]) {
 include_directories.push_back(argv[argi]);
 } else if(arg == ""--strict-json"") {
 opts.strict_json = true;
+ } else if(arg == ""--no-js-exports"") {
+ opts.skip_js_exports = true;
 } else if(arg == ""--defaults-json"") {
 opts.output_default_scalars_in_json = true;
 } else if(arg == ""--no-prefix"") {
",237,45
"Add low-level fuzzer, fix 64-bit issue it found"," flatbuffers.ByteBuffer.prototype.writeInt32 = function(offset, value) {
 * @param {flatbuffers.Long} value
 */
 flatbuffers.ByteBuffer.prototype.writeInt64 = function(offset, value) {
- this.view_.setInt32(offset, value.low);
- this.view_.setInt32(offset + 4, value.high);
+ this.writeInt32(offset, value.low);
+ this.writeInt32(offset + 4, value.high);
 };
 
 /**
",446,125
remove unnecessary return," static void GenStruct(const Parser &parser, StructDef &struct_def,
 ""@param {flatbuffers.Offset} offset"");
 code += object_name + "".finish"" + struct_def.name + ""Buffer"";
 code += "" = function(builder, offset) {\n"";
- code += "" return builder.finish(offset"";
+ code += "" builder.finish(offset"";
 if (!parser.file_identifier_.empty()) {
 code += "", '"" + parser.file_identifier_ + ""'"";
 }
",589,143
Update monster_test_generated.js baseline after rebase," static void GenStruct(const Parser &parser, StructDef &struct_def,
 code += "" builder.startVector("" + NumToString(elem_size);
 code += "", data.length, "" + NumToString(alignment) + "");\n"";
 code += "" for (var i = data.length - 1; i >= 0; i--) {\n"";
- code += "" builder.add"" + GenWriteMethod(vector_type);
- code += ""(data[i]);\n"";
+ code += "" builder.add"" + GenWriteMethod(vector_type) + ""("";
+ if (vector_type.base_type == BASE_TYPE_BOOL) {
+ code += ""+"";
+ }
+ code += ""data[i]);\n"";
 code += "" }\n"";
 code += "" return builder.endVector();\n"";
 code += ""};\n\n"";
",592,144
"Ported some of the python fuzz tests to C#

* Refactored the test runner to use attribute based test discovery
* Ported value and vtable/object fuzzing tests from python to C#"," using MyGame.Example;
 
 namespace FlatBuffers.Test
 {
+ [FlatBuffersTestClass]
 public class FlatBuffersExampleTests
 {
 public void RunTests()
 namespace FlatBuffers.Test
 TestEnums();
 }
 
+ [FlatBuffersTestMethod]
 public void CanCreateNewFlatBufferFromScratch()
 {
 // Second, let's create a FlatBuffer from scratch in C#, and test it also.
 namespace FlatBuffers.Test
 Assert.AreEqual(false, monster.Testbool);
 }
 
+ [FlatBuffersTestMethod]
 public void CanReadCppGeneratedWireFile()
 {
 var data = File.ReadAllBytes(@""Resources/monsterdata_test.mon"");
 namespace FlatBuffers.Test
 TestBuffer(bb);
 }
 
+ [FlatBuffersTestMethod]
 public void TestEnums()
 {
 Assert.AreEqual(""Red"", Color.Red.ToString());
",140,8
"Vector of structs were not being verified correctly.

Because they are represented as `const T *` in the Vector template,
the sizeof(const T *) was accidentally used instead of sizeof(T).

Change-Id: Ib4dc73e1d21396ba2e30c84e5e229c4147204bb1
Tested: on Linux."," class Verifier FLATBUFFERS_FINAL_CLASS {
 &end);
 }
 
+ // Verify a pointer (may be NULL) of a vector to struct.
+ template<typename T> bool Verify(const Vector<const T *> *vec) const {
+ return Verify(reinterpret_cast<const Vector<T> *>(vec));
+ }
+
 // Verify a pointer (may be NULL) to string.
 bool Verify(const String *str) const {
 const uint8_t *end;
",726,207
Fixes for JS generator in VS," inline std::string IntToStringHex(int i, int xdigits) {
 return ss.str();
 }
 
-// Portable implementation of strtoull().
+// Portable implementation of strtoll().
 inline int64_t StringToInt(const char *str, int base = 10) {
+ #ifdef _MSC_VER
+ return _strtoi64(str, nullptr, base);
+ #else
+ return strtoll(str, nullptr, base);
+ #endif
+}
+
+// Portable implementation of strtoull().
+inline int64_t StringToUInt(const char *str, int base = 10) {
 #ifdef _MSC_VER
 return _strtoui64(str, nullptr, base);
 #else
",180,51
Fixes for JS generator in Xcode," template<typename T> void Print(T val, Type type, int /*indent*/,
 }
 
 if (type.base_type == BASE_TYPE_BOOL) {
- text += val ? ""true"" : ""false"";
+ text += val != 0 ? ""true"" : ""false"";
 } else {
 text += NumToString(val);
 }
",246,58
"Added assert for referring to 0 offsets.

Change-Id: I7c04d934bfacd4aeaa2ba476b934dd3a62d4fc0e
Tested: on Linux."," class FlatBufferBuilder FLATBUFFERS_FINAL_CLASS {
 // This function converts them to be relative to the current location
 // in the buffer (when stored here), pointing upwards.
 uoffset_t ReferTo(uoffset_t off) {
- Align(sizeof(uoffset_t)); // To ensure GetSize() below is correct.
- assert(off <= GetSize()); // Must refer to something already in buffer.
+ // Align to ensure GetSize() below is correct.
+ Align(sizeof(uoffset_t));
+ // Offset must refer to something already in buffer.
+ assert(off && off <= GetSize());
 return GetSize() - off + sizeof(uoffset_t);
 }
 
",726,208
"Improved C++ asserts for nesting and not finishing buffers.

Change-Id: I82a392bd262b13e978df748bc54b7ac43aec1e15
Tested: on Linux."," uoffset_t Parser::ParseTable(const StructDef &struct_def) {
 // be stored in-line later in the parent object.
 auto off = struct_stack_.size();
 struct_stack_.insert(struct_stack_.end(),
- builder_.GetBufferPointer(),
- builder_.GetBufferPointer() + struct_def.bytesize);
+ builder_.GetCurrentBufferPointer(),
+ builder_.GetCurrentBufferPointer() +
+ struct_def.bytesize);
 builder_.PopBytes(struct_def.bytesize);
 return static_cast<uoffset_t>(off);
 } else {
",1356,451
"Fixed assert in flatc converting to text.

Change-Id: Idac375b22aa9beaba162084cc3396f5536a4e721
Tested: on Linux."," class FlatBufferBuilder FLATBUFFERS_FINAL_CLASS {
 buf_.fill(PaddingBytes(buf_.size(), elem_size));
 }
 
+ void PushFlatBuffer(const uint8_t *bytes, size_t size) {
+ PushBytes(bytes, size);
+ finished = true;
+ }
+
 void PushBytes(const uint8_t *bytes, size_t size) {
 buf_.push(bytes, size);
 }
",751,211
"Allow structs to be parsed in JSON with out of order fields.

Also simplified the code and made it faster.

Change-Id: I1d83b1165a4a9a4380d1bfb5538769c012d2d367
Tested: on Linux."," namespace MyGame.Example
 
 using FlatBuffers;
 
+/// an example documentation comment: monster object
 public sealed class Monster : Table {
 public static Monster GetRootAsMonster(ByteBuffer _bb) { return GetRootAsMonster(_bb, new Monster()); }
 public static Monster GetRootAsMonster(ByteBuffer _bb, Monster obj) { return (obj.__init(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
",103,101
(C#) Add ByteBuffer property to Table," namespace FlatBuffers
 protected int bb_pos;
 protected ByteBuffer bb;
 
+ public ByteBuffer ByteBuffer { get { return bb; } }
+
 // Look up a field in the vtable, return an offset into the object, or 0 if the field is not
 // present.
 protected int __offset(int vtableOffset)
",55,10
"C# Unity can't cast integer represented enum value.

```
namespace MyGame;

enum CommandType : byte {
	None = 0,
}

table Command {
	id:int;
	type:CommandType;
}
```

then generate c# files. it'll output compile error like these.

```
Assets/MyGame/Command.cs(18,39): error CS1041: Identifier expected
Assets/MyGame/Command.cs(18,39): error CS1737: Optional parameter cannot precede required parameters

16: public static Offset<Command> CreateCommand(FlatBufferBuilder builder,
17: int id = 0,
18: CommandType type = (CommandType)0) {
```"," public sealed class TestSimpleTableWithEnum : Table {
 public bool MutateColor(Color color) { int o = __offset(4); if (o != 0) { bb.PutSbyte(o + bb_pos, (sbyte)color); return true; } else { return false; } }
 
 public static Offset<TestSimpleTableWithEnum> CreateTestSimpleTableWithEnum(FlatBufferBuilder builder,
- Color color = (Color)2) {
+ Color color = Color.Green) {
 builder.StartObject(1);
 TestSimpleTableWithEnum.AddColor(builder, color);
 return TestSimpleTableWithEnum.EndTestSimpleTableWithEnum(builder);
",23,9
"Fix C# vector of enum code generation

Fixes a bug where the logic to determine when to use a C# enum flags
both enums and vectors of enums. This causes the C# generator to
generate code that doesn't compile for tables that contain vectors of
enums.

The fix also consolidates type generation functions a bit and adds
some additional casting functions for clarity."," public sealed class Stat : Table {
 public bool MutateCount(ushort count) { int o = __offset(8); if (o != 0) { bb.PutUshort(o + bb_pos, count); return true; } else { return false; } }
 
 public static Offset<Stat> CreateStat(FlatBufferBuilder builder,
- StringOffset id = default(StringOffset),
+ StringOffset idOffset = default(StringOffset),
 long val = 0,
 ushort count = 0) {
 builder.StartObject(3);
 Stat.AddVal(builder, val);
- Stat.AddId(builder, id);
+ Stat.AddId(builder, idOffset);
 Stat.AddCount(builder, count);
 return Stat.EndStat(builder);
 }
",32,13
"Fixed crash related to flatc parsing duplicate input files.

Thanks @Chaosvex for reporting.

Change-Id: I73f60ab0bf875a3e0849eaec5f42f6d036881094
Tested: on Linux."," class Parser {
 const char *source_, *cursor_;
 int line_; // the current line being parsed
 int token_;
- std::stack<std::string> files_being_parsed_;
+ std::string files_being_parsed_;
 bool proto_mode_;
 bool strict_json_;
 std::string attribute_;
",372,29
"Made generated C++ code respect gcc -Werror=shadow.

Change-Id: I17de0bcc462770124227a9967e2aab620467f6eb
Tested: on Linux."," public:
 return nullptr; // Key not found.
 }
 
- const uint8_t *data = reinterpret_cast<const uint8_t *>(search_result);
+ const uint8_t *element = reinterpret_cast<const uint8_t *>(search_result);
 
- return IndirectHelper<T>::Read(data, 0);
+ return IndirectHelper<T>::Read(element, 0);
 }
 
 protected:
",751,211
"Added long form options for all generators (--cpp etc.)

Short-form versions are still supported, but are deprecated.

Change-Id: I15f70ca8d69ba5790368205caa9603b65e1b7fff
Tested: on Linux."," MyGame.Example.Stat.endStat = function(builder) {
 };
 
 /**
+ * an example documentation comment: monster object
+ *
 * @constructor
 */
 MyGame.Example.Monster = function() {
",416,152
"Return the full string when requested from a flatbuffers::String, even if it contains a NULL byte."," template<typename T> static inline size_t VectorLength(const Vector<T> *v) {
 
 struct String : public Vector<char> {
 const char *c_str() const { return reinterpret_cast<const char *>(Data()); }
- std::string str() const { return c_str(); }
+ std::string str() const { return std::string(c_str(), Length()); }
 
 bool operator <(const String &o) const {
 return strcmp(c_str(), o.c_str()) < 0;
",751,211
Fix use of std::max when Windows.h is imported.," class vector_downward {
 if (len > static_cast<size_t>(cur_ - buf_)) {
 auto old_size = size();
 auto largest_align = AlignOf<largest_scalar_t>();
- reserved_ += std::max(len, growth_policy(reserved_));
+ reserved_ += (std::max)(len, growth_policy(reserved_));
 // Round up to avoid undefined behavior from unaligned loads and stores.
 reserved_ = (reserved_ + (largest_align - 1)) & ~(largest_align - 1);
 auto new_buf = allocator_.allocate(reserved_);
",751,211
"Allow vectors to be aligned beyond their natural type.

Change-Id: I09ade6b688a6b97d65fd832558917225d86c9118"," class FlatBufferBuilder FLATBUFFERS_FINAL_CLASS {
 PreAlign(len * elemsize, elemsize); // Just in case elemsize > uoffset_t.
 }
 
+ // Call this right before StartVector/CreateVector if you want to force the
+ // alignment to be something different than what the element size would
+ // normally dictate.
+ // This is useful when storing a nested_flatbuffer in a vector of bytes,
+ // or when storing SIMD floats, etc.
+ void ForceVectorAlignment(size_t len, size_t elemsize, size_t alignment) {
+ PreAlign(len * elemsize, alignment);
+ }
+
 uint8_t *ReserveElements(size_t len, size_t elemsize) {
 return buf_.make_space(len * elemsize);
 }
",754,212
"Multiple schemas parsed by flatc are now parsed independently.

It used to be such that later schemas could depend on earlier
schemas. This was a convenience from days before include files
were implemented. Nowadays they cause subtle bugs rather than being
useful, so this functionality has been removed.

You now need to explicitly include files you depend upon.

Change-Id: Id8292c3c621fc38fbd796da2d2cbdd63efc230d1
Tested: on Linux."," inline std::string StripExtension(const std::string &filepath) {
 return i != std::string::npos ? filepath.substr(0, i) : filepath;
 }
 
+// Returns the extension, if any.
+inline std::string GetExtension(const std::string &filepath) {
+ size_t i = filepath.find_last_of(""."");
+ return i != std::string::npos ? filepath.substr(i + 1) : """";
+}
+
 // Return the last component of the path, after the last separator.
 inline std::string StripPath(const std::string &filepath) {
 size_t i = filepath.find_last_of(PathSeparatorSet);
",184,53
"Fixed implicit dereference in flatc.

Change-Id: If2e62a325b47399561b4c20d2def55ede4831d19
Tested: on Linux."," int main(int argc, const char *argv[]) {
 if (generator_enabled[i]) {
 if (!print_make_rules) {
 flatbuffers::EnsureDirExists(output_path);
- if (!generators[i].generate(parser, output_path, filebase, opts)) {
+ if (!generators[i].generate(*parser, output_path, filebase, opts)) {
 Error(std::string(""Unable to generate "") +
 generators[i].lang_name +
 "" for "" +
 int main(int argc, const char *argv[]) {
 }
 } else {
 std::string make_rule = generators[i].make_rule(
- parser, output_path, *file_it, opts);
+ *parser, output_path, *file_it, opts);
 if (!make_rule.empty())
 printf(""%s\n"", flatbuffers::WordWrap(
 make_rule, 80, "" "", "" \\"").c_str());
 int main(int argc, const char *argv[]) {
 }
 }
 
- if (proto_mode) GenerateFBS(parser, output_path, filebase, opts);
+ if (proto_mode) GenerateFBS(*parser, output_path, filebase, opts);
 }
 
 delete parser;
",253,50
"Added --gen-all to generate code for a schema and all its includes.

Also refactored the way options are stored.

Change-Id: I709ac908cd2aba396c9c282725cf1d42ccce0882
Tested: on Linux."," int main(int /*argc*/, const char * /*argv*/[]) {
 // to ensure it is correct, we now generate text back from the binary,
 // and compare the two:
 std::string jsongen;
- GenerateText(parser, parser.builder_.GetBufferPointer(),
- flatbuffers::GeneratorOptions(), &jsongen);
+ GenerateText(parser, parser.builder_.GetBufferPointer(), &jsongen);
 
 if (jsongen != jsonfile) {
 printf(""%s----------------\n%s"", jsongen.c_str(), jsonfile.c_str());
",25,5
Fix to #360 - Updated the general generator (Java/C#) to emit fully qualified names where the referenced object isn't directly in this namespace. Added test fbs files to verify compilation.,"
 import java.io.*;
 import java.nio.ByteBuffer;
 import MyGame.Example.*;
+import NamespaceA.*;
+import NamespaceA.NamespaceB.*;
 import com.google.flatbuffers.FlatBufferBuilder;
 
 class JavaTest {
 class JavaTest {
 
 TestExtendedBuffer(fbb.dataBuffer().asReadOnlyBuffer());
 
+ TestNamespaceNesting();
+
 System.out.println(""FlatBuffers test: completed successfully"");
 }
 
 class JavaTest {
 
 TestEq(monster.testhashu32Fnv1(), Integer.MAX_VALUE + 1L);
 }
+ 
+ static void TestNamespaceNesting() {
+ // reference / manipulate these to verify compilation
+ FlatBufferBuilder fbb = new FlatBufferBuilder(1);
+ 
+ TableInNestedNS.startTableInNestedNS(fbb);
+ TableInNestedNS.addFoo(fbb, 1234);
+ int nestedTableOff = TableInNestedNS.endTableInNestedNS(fbb);
+ 
+ TableInFirstNS.startTableInFirstNS(fbb); 
+ TableInFirstNS.addFooTable(fbb, nestedTableOff);
+ int off = TableInFirstNS.endTableInFirstNS(fbb);
+ }
 
 static <T> void TestEq(T a, T b) {
 if (!a.equals(b)) {
",161,12
"Correct the max/min signed/unsigned 32-bit int

The test was trying to pack an unsigned int which couldn't fit as a
signed int and putInt() wasn't doing the validation in the correct range"," class ByteBuffer
 */
 public function putInt($offset, $value)
 {
- self::validateValue(~PHP_INT_MAX, PHP_INT_MAX, $value, ""int"");
+ // 2147483647 = (1 << 31) -1 = Maximum signed 32-bit int
+ // -2147483648 = -1 << 31 = Minimum signed 32-bit int
+ self::validateValue(-2147483648, 2147483647, $value, ""int"");
 
 $this->assertOffsetAndLength($offset, 4);
 $this->writeLittleEndian($offset, 4, $value);
 class ByteBuffer
 public function putUint($offset, $value)
 {
 // NOTE: We can't put big integer value. this is PHP limitation.
- self::validateValue(0, PHP_INT_MAX, $value, ""uint"", "" php has big numbers limitation. check your PHP_INT_MAX"");
+ // 4294967295 = (1 << 32) -1 = Maximum unsigned 32-bin int
+ self::validateValue(0, 4294967295, $value, ""uint"", "" php has big numbers limitation. check your PHP_INT_MAX"");
 
 $this->assertOffsetAndLength($offset, 4);
 $this->writeLittleEndian($offset, 4, $value);
",259,58
"Optimize get* operation

It's slightly faster to convert the value to signed value in PHP as
opposed to use pack and unpack.

For 1M get operation the difference is:

 getShort in 3.3272678852081 seconds
 getInt in 3.8338589668274 seconds
 getLong in 5.6381590366364 seconds
 getLong (neg) in 5.6149101257324 seconds

vs

 getShort in 2.7564418315887 seconds
 getInt in 3.1612701416016 seconds
 getLong in 3.1369340419769 seconds
 getLong (neg) in 3.1478710174561 seconds

And since pack(""P"") and unpack(""q"") has been removed now ByteBuffer
works for PHP >= 5.4"," function testByteBuffer(Assert $assert) {
 $buffer[7] = chr(0x01);
 $uut = Google\FlatBuffers\ByteBuffer::wrap($buffer);
 $assert->Equal(0x010203040A0B0C0D, $uut->getLong(0));
+
+ //Test: Signed Long
+ $buffer = str_repeat(""\0"", 8);
+ $buffer[0] = chr(0x00);
+ $buffer[1] = chr(0x00);
+ $buffer[2] = chr(0x00);
+ $buffer[3] = chr(0x00);
+ $buffer[4] = chr(0x00);
+ $buffer[5] = chr(0x00);
+ $buffer[6] = chr(0x00);
+ $buffer[7] = chr(0x80);
+ $uut = Google\FlatBuffers\ByteBuffer::wrap($buffer);
+ $assert->Equal(-1 << 63, $uut->getLong(0));
 }
 
 //Test: ByteBuffer_GetLongChecksOffset
",434,46
"Fixed language for generators not being set correctly.

Change-Id: I36c1f05efa836b32635e3274ac0ba976a8961bdd
Tested: on Linux."," int main(int argc, const char *argv[]) {
 flatbuffers::StripExtension(*file_it));
 
 for (size_t i = 0; i < num_generators; ++i) {
- opts.lang = generators[i].lang;
+ parser->opts.lang = generators[i].lang;
 if (generator_enabled[i]) {
 if (!print_make_rules) {
 flatbuffers::EnsureDirExists(output_path);
",254,51
"Extend C# ByteBuffer Put method fix to unsafe methods

Fixes issue #243. Extends the initial C# ByteBuffer fix
(e4c3bf3d2cec00522fd1a8edd8704413cdc1303b) to Put methods
used when UNSAFE_BYTEBUFFER is defined."," namespace FlatBuffers
 ? value
 : ReverseBytes(value);
 }
- _pos = offset;
 }
 
 public void PutInt(int offset, int value)
 namespace FlatBuffers
 ? value
 : ReverseBytes(value);
 }
- _pos = offset;
 }
 
 public unsafe void PutLong(int offset, long value)
 namespace FlatBuffers
 ? value
 : ReverseBytes(value);
 }
- _pos = offset;
 }
 
 public unsafe void PutFloat(int offset, float value)
 namespace FlatBuffers
 *(uint*)(ptr + offset) = ReverseBytes(*(uint*)(&value));
 }
 }
- _pos = offset;
 }
 
 public unsafe void PutDouble(int offset, double value)
 namespace FlatBuffers
 *(ulong*)(ptr + offset) = ReverseBytes(*(ulong*)(ptr + offset));
 }
 }
- _pos = offset;
 }
 #else // !UNSAFE_BYTEBUFFER
 // Slower versions of Put* for when unsafe code is not allowed.
",349,65
"Fixed compiler warnings for cast to bool in generated code.

Change-Id: I7727aeb478feb23d8ef66fd1ba9499b142b3ea7d
Tested: on Linux."," static void GenEnum(const Parser &parser, EnumDef &enum_def,
 // underlying type to the interface type.
 std::string GenUnderlyingCast(const Parser &parser, const FieldDef &field,
 bool from, const std::string &val) {
- return (field.value.type.enum_def && IsScalar(field.value.type.base_type)) ||
- field.value.type.base_type == BASE_TYPE_BOOL
- ? ""static_cast<"" + GenTypeBasic(parser, field.value.type, from) + "">("" +
- val + "")""
- : val;
+ if (from && field.value.type.base_type == BASE_TYPE_BOOL) {
+ return val + "" != 0"";
+ } else if ((field.value.type.enum_def &&
+ IsScalar(field.value.type.base_type)) ||
+ field.value.type.base_type == BASE_TYPE_BOOL) {
+ return ""static_cast<"" + GenTypeBasic(parser, field.value.type, from) +
+ "">("" + val + "")"";
+ } else {
+ return val;
+ }
 }
 
 std::string GenFieldOffsetName(const FieldDef &field) {
",697,150
"Fixed root_type not accepting namespaced types.

Change-Id: I272f377742cc0a2c1bfccaa641b54eb9a8c762b6
Tested: on Linux."," void Parser::ParseDecl() {
 }
 
 bool Parser::SetRootType(const char *name) {
- root_struct_def_ = structs_.Lookup(
- namespaces_.back()->GetFullyQualifiedName(name));
+ root_struct_def_ = structs_.Lookup(name);
+ if (!root_struct_def_)
+ root_struct_def_ = structs_.Lookup(
+ namespaces_.back()->GetFullyQualifiedName(name));
 return root_struct_def_ != nullptr;
 }
 
 bool Parser::Parse(const char *source, const char **include_paths,
 Next();
 auto root_type = attribute_;
 Expect(kTokenIdentifier);
+ ParseNamespacing(&root_type, nullptr);
 if (!SetRootType(root_type.c_str()))
 Error(""unknown root type: "" + root_type);
 if (root_struct_def_->fixed)
",1349,448
"Performance tweak to FlatBufferBuilder.CreateString method to remove the unnecessary byte buffer allocation

(See https://github.com/google/flatbuffers/issues/55#issuecomment-164031718 for stats)"," namespace FlatBuffers
 
 public StringOffset CreateString(string s)
 {
- NotNested();
- byte[] utf8 = Encoding.UTF8.GetBytes(s);
- AddByte((byte)0);
- StartVector(1, utf8.Length, 1);
- Buffer.BlockCopy(utf8, 0, _bb.Data, _space -= utf8.Length,
- utf8.Length);
+ NotNested(); 
+ AddByte(0);
+ var utf8StringLen = Encoding.UTF8.GetByteCount(s);
+ StartVector(1, utf8StringLen, 1);
+ Encoding.UTF8.GetBytes(s, 0, s.Length, _bb.Data, _space -= utf8StringLen);
 return new StringOffset(EndVector().Value);
 }
 
",295,91
C# performance optimization to Pad/Prep methods," namespace FlatBuffers
 _buffer[offset] = value;
 }
 
+ public void PutByte(int offset, byte value, int count)
+ {
+ AssertOffsetAndLength(offset, sizeof(byte) * count);
+ for (var i = 0; i < count; ++i)
+ _buffer[offset + i] = value;
+ }
+
 // this method exists in order to conform with Java ByteBuffer standards
 public void Put(int offset, byte value)
 {
",355,67
"Made sure all namespace test files get generated.

Also included them in the C++ test.

Change-Id: Ib0c8470f0aacdf16616c27494abdda57a010195d
Tested: on Linux.","
 namespace NamespaceA.NamespaceB
 {
 
+using System;
 using FlatBuffers;
 
 public sealed class StructInNestedNS : Struct {
",18,4
"(PHP) fixes getting indirect table, also fixes getInt method on 32bit machine."," class ByteBuffer
 $sign = $index + (ByteBuffer::isLittleEndian() ? 3 : 0);
 $issigned = isset($this->_buffer[$sign]) && ord($this->_buffer[$sign]) & 0x80;
 
- // 4294967296 = 1 << 32 = Maximum unsigned 32-bit int
- return $issigned ? $result - 4294967296 : $result;
+ if (PHP_INT_SIZE > 4) {
+ // 4294967296 = 1 << 32 = Maximum unsigned 32-bit int
+ return $issigned ? $result - 4294967296 : $result;
+ } else {
+ // 32bit / Windows treated number as signed integer.
+ return $result;
+ }
 }
 
 /**
",251,62
"Added an IsFieldPresent helper function.

This is implemented as a template function, since Table::CheckField
is not reachable by subclasses of Table (private base class).

Change-Id: I1ed4d47ce7cb672460ccab61cf7442eb9136b0f1
Tested: on Linux.
Bug: 26273432"," class Table {
 uint8_t data_[1];
 };
 
+// Helper function to test if a field is present, using any of the field
+// enums in the generated code.
+// `table` must be a generated table type. Since this is a template parameter,
+// this is not typechecked to be a subclass of Table, so beware!
+// Note: this function will return false for fields equal to the default
+// value, since they're not stored in the buffer (unless force_defaults was
+// used).
+template<typename T> bool IsFieldPresent(const T *table, voffset_t field) {
+ // Cast, since Table is a private baseclass of any table types.
+ return reinterpret_cast<const Table *>(table)->CheckField(field);
+}
+
 // Utility function for reverse lookups on the EnumNames*() functions
 // (in the generated C++ code)
 // names must be NULL terminated.
",757,213
"Fixed reflection setting string not changing size field.

Change-Id: I3c3e88a79667d1733b6c47e43b55d8b2604ca8e2
Tested: on Linux."," void ReflectionTest(uint8_t *flatbuf, size_t length) {
 rtestarrayofstring->MutateOffset(2, string_ptr);
 TEST_EQ_STR(rtestarrayofstring->Get(0)->c_str(), ""bob"");
 TEST_EQ_STR(rtestarrayofstring->Get(2)->c_str(), ""hank"");
+ // Test integrity of all resize operations above.
+ flatbuffers::Verifier resize_verifier(
+ reinterpret_cast<const uint8_t *>(resizingbuf.data()),
+ resizingbuf.size());
+ TEST_EQ(VerifyMonsterBuffer(resize_verifier), true);
 // As an additional test, also set it on the name field.
 // Note: unlike the name change above, this just overwrites the offset,
 // rather than changing the string in-place.
",561,89
Fix #2775: Add parser option to skip unknown JSON fields," struct IDLOptions {
 bool one_file;
 bool proto_mode;
 bool generate_all;
+ bool skip_unexpected_fields_in_json;
 
 // Possible options for the more general generator below.
 enum Language { kJava, kCSharp, kGo, kMAX };
 struct IDLOptions {
 one_file(false),
 proto_mode(false),
 generate_all(false),
+ skip_unexpected_fields_in_json(false),
 lang(IDLOptions::kJava) {}
 };
 
 private:
 CHECKED_ERROR ParseProtoDecl();
 CHECKED_ERROR ParseProtoCurliesOrIdent();
 CHECKED_ERROR ParseTypeFromProtoType(Type *type);
-
+ CHECKED_ERROR SkipAnyJsonValue();
+ CHECKED_ERROR SkipJsonObject();
+ CHECKED_ERROR SkipJsonArray();
+ CHECKED_ERROR SkipJsonString();
 CHECKED_ERROR DoParse(const char *_source, const char **include_paths,
 const char *source_filename);
 
",385,34
(PHP) remove duplicate test," function main()
 fuzzTest1($assert);
 // testUnicode($assert);
 
-
- testAnyBuffer($assert);
-
 echo 'FlatBuffers php test: completed successfully' . PHP_EOL;
 }
 
 function testByteBuffer(Assert $assert) {
 
 }
 
-function testAnyBuffer(Assert $assert)
-{
-// PHP needs double quote. for now, use Fred directly
-// $js = json_decode(file_get_contents('monsterdata_test.json'), true);
- $data = file_get_contents('monsterdata_test.mon');
- $bb = Google\FlatBuffers\ByteBuffer::wrap($data);
- $mons = \MyGame\Example\Monster::getRootAsMonster($bb);
- $indirect_monster = new \MyGame\Example\Monster();
- $assert->Equal($mons->getTestType(), \MyGame\Example\Any::Monster);
- $mons->getTest($indirect_monster);
- $assert->Equal(""Fred"", $indirect_monster->getName());
-}
-
 class Assert {
 public function ok($result, $message = """") {
 if (!$result){
",441,46
"Made error checking macros less prone to clashes.

Change-Id: Ieb252ce01446551699d935507bc95ee286fe1ddd
Tested: on Linux."," static_assert(BASE_TYPE_UNION ==
 static_cast<BaseType>(reflection::Union),
 ""enums don't match"");
 
+// Any parsing calls have to be wrapped in this macro, which automates
+// handling of recursive error checking a bit. It will check the received
+// CheckedError object, and return straight away on error.
 #define ECHECK(call) { auto ce = (call); if (ce.Check()) return ce; }
+
+// These two functions are called hundreds of times below, so define a short
+// form:
 #define NEXT() ECHECK(Next())
 #define EXPECT(tok) ECHECK(Expect(tok))
 
",1459,454
"[BUG FIX] [MINOR] Fix encoding with unicode characters.

When passing a unicode string to builder.CreateString, the
default encoding assumed all characters can be encoded
using ascii. Added a fix so a user can specify the
encoding and how to handle errors when creating strings."," class Builder(object):
 self.PlaceUOffsetT(vectorNumElems)
 return self.Offset()
 
- def CreateString(self, s):
+ def CreateString(self, s, encoding='utf-8', errors='strict'):
 """"""CreateString writes a null-terminated byte string as a vector.""""""
 
 self.assertNotNested()
 self.nested = True
 
 if isinstance(s, compat.string_types):
- x = s.encode()
+ x = s.encode(encoding, errors)
 elif isinstance(s, compat.binary_type):
 x = s
 else:
",296,59
"Fixed compile warning with VS2012

flatbuffers\src\idl_parser.cpp(1525): warning C4127: conditional expression is constant
flatbuffers\src\idl_parser.cpp(1546): warning C4127: conditional expression is constant"," CheckedError Parser::SkipJsonObject() {
 EXPECT('{');
 size_t fieldn = 0;
 
- while (true) {
+ for (;;) {
 if ((!opts.strict_json || !fieldn) && Is('}')) break;
 
 if (!Is(kTokenStringConstant))
 CheckedError Parser::SkipJsonObject() {
 CheckedError Parser::SkipJsonArray() {
 EXPECT('[');
 
- while (true) {
+ for (;;) {
 if (Is(']')) break;
 
 ECHECK(SkipAnyJsonValue());
",1520,474
"Fixed compile warning with VS2012

flatbuffers\src\idl_parser.cpp(1516): warning C4244: 'argument' : conversion from 'int' to 'char', possible loss of data"," CheckedError Parser::SkipAnyJsonValue() {
 EXPECT(kTokenFloatConstant);
 break;
 default:
- return Error(std::string(""Unexpected token:"") + std::string(1, token_));
+ return Error(std::string(""Unexpected token:"") + std::string(1, static_cast<char>(token_)));
 }
 return NoError();
 }
",1520,474
"Fix build for platforms not supporting realpath

Added a check for a preprocessor definition that can be set if the platform you're building for doesn't support any notion of absolute path resolution/realpath()/etc."," inline void EnsureDirExists(const std::string &filepath) {
 // Obtains the absolute path from any other path.
 // Returns the input path if the absolute path couldn't be resolved.
 inline std::string AbsolutePath(const std::string &filepath) {
+#ifdef NO_ABSOLUTE_PATH_RESOLUTION
+return filepath;
+#else
 #ifdef _WIN32
 char abs_path[MAX_PATH];
 return GetFullPathNameA(filepath.c_str(), MAX_PATH, abs_path, nullptr)
 inline std::string AbsolutePath(const std::string &filepath) {
 #endif
 ? abs_path
 : filepath;
+#endif // NO_ABSOLUTE_PATH_RESOLUTION
 }
 
 // To and from UTF-8 unicode conversion functions
",185,54
"Fixed MS static analysis warnings

Cleaned up a few warnings to allow VS2012 to compile idl_parser and idl_gen_text (for exporting binary protobuf blobs as JSON) cleanly under static analysis."," inline void EnsureDirExists(const std::string &filepath) {
 auto parent = StripFileName(filepath);
 if (parent.length()) EnsureDirExists(parent);
 #ifdef _WIN32
+ #ifdef _MSC_VER
+ #pragma warning(suppress: 6031)
+ #endif
 _mkdir(filepath.c_str());
 #else
 mkdir(filepath.c_str(), S_IRWXU|S_IRGRP|S_IXGRP);
",184,54
Documented what the suppressed warning is about," inline void EnsureDirExists(const std::string &filepath) {
 if (parent.length()) EnsureDirExists(parent);
 #ifdef _WIN32
 #ifdef _MSC_VER
- #pragma warning(suppress: 6031)
+ #pragma warning(suppress: 6031) // ""return value ignored: <function> could return unexpected value""
 #endif
 _mkdir(filepath.c_str());
 #else
",184,54
Made requested revisions for naming and spacing," inline void EnsureDirExists(const std::string &filepath) {
 // Obtains the absolute path from any other path.
 // Returns the input path if the absolute path couldn't be resolved.
 inline std::string AbsolutePath(const std::string &filepath) {
-#ifdef NO_ABSOLUTE_PATH_RESOLUTION
-return filepath;
-#else
- #ifdef _WIN32
- char abs_path[MAX_PATH];
- return GetFullPathNameA(filepath.c_str(), MAX_PATH, abs_path, nullptr)
+ #ifdef FLATBUFFERS_NO_ABSOLUTE_PATH_RESOLUTION
+ return filepath;
 #else
- char abs_path[PATH_MAX];
- return realpath(filepath.c_str(), abs_path)
- #endif
- ? abs_path
- : filepath;
-#endif // NO_ABSOLUTE_PATH_RESOLUTION
+ #ifdef _WIN32
+ char abs_path[MAX_PATH];
+ return GetFullPathNameA(filepath.c_str(), MAX_PATH, abs_path, nullptr)
+ #else
+ char abs_path[PATH_MAX];
+ return realpath(filepath.c_str(), abs_path)
+ #endif
+ ? abs_path
+ : filepath;
+ #endif // NO_ABSOLUTE_PATH_RESOLUTION
 }
 
 // To and from UTF-8 unicode conversion functions
",185,54
Updated comment on endif for new name," inline std::string AbsolutePath(const std::string &filepath) {
 #endif
 ? abs_path
 : filepath;
- #endif // NO_ABSOLUTE_PATH_RESOLUTION
+ #endif // FLATBUFFERS_NO_ABSOLUTE_PATH_RESOLUTION
 }
 
 // To and from UTF-8 unicode conversion functions
",185,54
"Fixed warning building in VS2012

src\reflection.cpp(297): warning C4267: 'argument' : conversion from 'size_t' to 'flatbuffers::uoffset_t', possible loss of data

sizeof() was promoting the type from uoffset_t to size_t."," void SetString(const reflection::Schema &schema, const std::string &val,
 auto delta = static_cast<int>(val.size()) - static_cast<int>(str->Length());
 auto str_start = static_cast<uoffset_t>(
 reinterpret_cast<const uint8_t *>(str) - flatbuf->data());
- auto start = str_start + sizeof(uoffset_t);
+ auto start = str_start + static_cast<uoffset_t>(sizeof(uoffset_t));
 if (delta) {
 // Clear the old string, since we don't want parts of it remaining.
 memset(flatbuf->data() + start, 0, str->Length());
",380,118
Changed how the SA warning is suppressed to avoid pragma stuff," inline void EnsureDirExists(const std::string &filepath) {
 auto parent = StripFileName(filepath);
 if (parent.length()) EnsureDirExists(parent);
 #ifdef _WIN32
- #ifdef _MSC_VER
- #pragma warning(suppress: 6031) // ""return value ignored: <function> could return unexpected value""
- #endif
- _mkdir(filepath.c_str());
+ (void)_mkdir(filepath.c_str());
 #else
 mkdir(filepath.c_str(), S_IRWXU|S_IRGRP|S_IXGRP);
 #endif
",184,53
"Ensured code is not generated directly from .proto files.

The parser state generated from the .proto conversion process is
not exactly the same as what you get by parsing the generated
schema, which can cause problems. This check enforces that you
first convert the .proto, then generate code from the new schema.

Change-Id: I04b53af9288d87e256d1cc109388332fefb3a09f
Tested: on Linux."," int main(int argc, const char *argv[]) {
 binary_files_from = filenames.size();
 } else if(arg == ""--proto"") {
 opts.proto_mode = true;
- any_generator = true;
 } else if(arg == ""--schema"") {
 schema_binary = true;
 } else if(arg == ""-M"") {
 int main(int argc, const char *argv[]) {
 
 if (!filenames.size()) Error(""missing input files"", false, true);
 
- if (!any_generator)
+ if (opts.proto_mode) {
+ if (any_generator)
+ Error(""cannot generate code directly from .proto files"", true);
+ } else if (!any_generator) {
 Error(""no options: specify at least one generator."", true);
+ }
 
 // Now process the files:
 parser = new flatbuffers::Parser(opts);
",262,54
"Make flatc check for binary files to avoid accidental parsing.

Binary file arguments to flatc have to be preceded by -- to
identify them, forgetting this however results in them being
attempted to be parsed as schema/json, with cryptic errors.
This instead gives an error if 0 bytes are contained in your
text file.

Bug: 22069056
Change-Id: I226bf651dcb016f18d7c8ffadcf23466a1fc0b87
Tested: on Linux."," static void Error(const std::string &err, bool usage, bool show_exe_name) {
 "" This may crash flatc given a mismatched schema.\n""
 "" --proto Input is a .proto, translate to .fbs.\n""
 "" --schema Serialize schemas instead of JSON (use with -b)\n""
- ""FILEs may depend on declarations in earlier files.\n""
+ ""FILEs may be schemas, or JSON files (conforming to preceding schema)\n""
 ""FILEs after the -- must be binary flatbuffer format files.\n""
 ""Output files are named using the base file name of the input,\n""
 ""and written to the current directory or the path given by -o.\n""
 int main(int argc, const char *argv[]) {
 }
 }
 } else {
+ // Check if file contains 0 bytes.
+ if (contents.length() != strlen(contents.c_str())) {
+ Error(""input file appears to be binary: "" + *file_it, true);
+ }
 if (flatbuffers::GetExtension(*file_it) == ""fbs"") {
 // If we're processing multiple schemas, make sure to start each
 // one from scratch. If it depends on previous schemas it must do
",265,55
"Fix #3497: Add support for compiling in g++ 4.4 and 4.5

- Removed uses of lambda expressions

- Added custom defines for constexpr and nullptr

- Removed trailing comma of last value from generated enums","
 #include <cstdint>
 #include <cstring>
 
+#include ""flatbuffers/flatbuffers.h""
+
 namespace flatbuffers {
 
 template <typename T>
 struct FnvTraits<uint32_t> {
 
 template <>
 struct FnvTraits<uint64_t> {
- static const uint64_t kFnvPrime = 0x00000100000001b3;
- static const uint64_t kOffsetBasis = 0xcbf29ce484222645;
+ static const uint64_t kFnvPrime = 0x00000100000001b3ULL;
+ static const uint64_t kOffsetBasis = 0xcbf29ce484222645ULL;
 };
 
 template <typename T>
",72,10
Added check (& skipping) of the utf-8 byte order mark (0xEF BB BF) at the beginning of the file," private:
 FLATBUFFERS_CHECKED_ERROR Error(const std::string &msg);
 FLATBUFFERS_CHECKED_ERROR ParseHexNum(int nibbles, int64_t *val);
 FLATBUFFERS_CHECKED_ERROR Next();
+ FLATBUFFERS_CHECKED_ERROR SkipByteOrderMark();
 bool Is(int t);
 FLATBUFFERS_CHECKED_ERROR Expect(int t);
 std::string TokenToStringId(int t);
",391,34
"Added min/max values for enums/unions.

Bug: 21642898
Change-Id: Ifaf0b3c4274fe30ef29507ba1c1216d700efe85b
Tested: on Linux."," struct Monster;
 enum Color {
 Color_Red = 0,
 Color_Green = 1,
- Color_Blue = 2
+ Color_Blue = 2,
+ Color_MIN = Color_Red,
+ Color_MAX = Color_Blue
 };
 
 inline const char **EnumNamesColor() {
 inline const char *EnumNameColor(Color e) { return EnumNamesColor()[static_cast<
 
 enum Any {
 Any_NONE = 0,
- Any_Monster = 1
+ Any_Monster = 1,
+ Any_MIN = Any_NONE,
+ Any_MAX = Any_Monster
 };
 
 inline const char **EnumNamesAny() {
",124,49
"Silenced unused variable warnings.

When built for release, builds were failing with unused
variable warnings, since they were only used in `assert()`
calls.

I added explicit void casting to any potentially unused variables.

Change-Id: I9947ba46891fdda5aa925caa950642dedd4e009f"," int main(int /*argc*/, const char * /*argv*/[]) {
 assert(weps->Get(i)->name()->str() == expected_weapon_names[i]);
 assert(weps->Get(i)->damage() == expected_weapon_damages[i]);
 }
+ (void)expected_weapon_names;
+ (void)expected_weapon_damages;
 
 // Get and test the `Equipment` union (`equipped` field).
 assert(monster->equipped_type() == Equipment_Weapon);
 auto equipped = static_cast<const Weapon*>(monster->equipped());
 assert(equipped->name()->str() == ""Axe"");
 assert(equipped->damage() == 5);
+ (void)equipped;
 
 printf(""The FlatBuffer was successfully created and verified!\n"");
 }
",49,2
Disabled assignment operator of TableKeyComparator; was causing warning C4512 on VS2010 and thus causing the build to fail.," FLATBUFFERS_FINAL_CLASS
 return table_a->KeyCompareLessThan(table_b);
 }
 vector_downward& buf_;
+
+ private:
+ TableKeyComparator& operator= (const TableKeyComparator&);
 };
 /// @endcond
 
",772,216
"Fixed Python unit test breakage.

Test was testing for a field to be None, even though it is populated
in one particular instance.

Change-Id: Id19848d01498d4c0a684efdb2bf49ff12c5b6758
Tested: on Linux."," def CheckReadBuffer(buf, offset):
 asserter(monster.Testarrayofstring(0) == b""test1"")
 asserter(monster.Testarrayofstring(1) == b""test2"")
 
- asserter(monster.Enemy() is None)
-
 asserter(monster.TestarrayoftablesLength() == 0)
 asserter(monster.TestnestedflatbufferLength() == 0)
 asserter(monster.Testempty() is None)
 def BenchmarkMakeMonsterFromGeneratedCode(count, length):
 
 def backward_compatible_run_tests(**kwargs):
 if PY_VERSION < (2, 6):
- sys.stderr.write(""Python version less than 2.6 are not supported"") 
+ sys.stderr.write(""Python version less than 2.6 are not supported"")
 sys.stderr.flush()
 return False
 
 def backward_compatible_run_tests(**kwargs):
 return False
 return True
 
- # python2.7 and above let us not exit once unittest.main is run: 
+ # python2.7 and above let us not exit once unittest.main is run:
 kwargs['exit'] = False
 kwargs['verbosity'] = 0
 ret = unittest.main(**kwargs)
",1018,137
Added support for C# partial class generation when the `csharp_partial` attribute is used on a table/struct.," class Parser {
 known_attributes_.insert(""bit_flags"");
 known_attributes_.insert(""original_order"");
 known_attributes_.insert(""nested_flatbuffer"");
+ known_attributes_.insert(""csharp_partial"");
 }
 
 ~Parser() {
",396,34
Add -v --version arg support to the flatc command.,"
 #include ""flatbuffers/util.h""
 #include <limits>
 
+#define FLATC_VERSION ""1.2.0""
+
 static void Error(const std::string &err, bool usage = false,
 bool show_exe_name = true);
 
 static void Error(const std::string &err, bool usage, bool show_exe_name) {
 "" -o PATH Prefix PATH to all generated files.\n""
 "" -I PATH Search for includes in the specified path.\n""
 "" -M Print make rules for generated files.\n""
+ "" -v, --version Print the version number of flatc and exit.\n""
 "" --strict-json Strict JSON: field names must be / will be quoted,\n""
 "" no trailing commas in tables/vectors.\n""
 "" --defaults-json Output fields whose value is the default when\n""
 int main(int argc, const char *argv[]) {
 schema_binary = true;
 } else if(arg == ""-M"") {
 print_make_rules = true;
+ } else if(arg == ""-v"" || arg == ""--version"") {
+ printf(""flatc version %s\n"", FLATC_VERSION);
+ exit(0);
 } else {
 for (size_t i = 0; i < num_generators; ++i) {
 if (arg == generators[i].generator_opt_long ||
",270,57
Add __DATE__ to FLATC_VERSION based on PR feedback.,"
 #include ""flatbuffers/util.h""
 #include <limits>
 
-#define FLATC_VERSION ""1.2.0""
+#define FLATC_VERSION ""1.2.0 ("" __DATE__ "")""
 
 static void Error(const std::string &err, bool usage = false,
 bool show_exe_name = true);
",270,57
Remove -v as option for printing version # (based on PR feedback).," static void Error(const std::string &err, bool usage, bool show_exe_name) {
 "" -o PATH Prefix PATH to all generated files.\n""
 "" -I PATH Search for includes in the specified path.\n""
 "" -M Print make rules for generated files.\n""
- "" -v, --version Print the version number of flatc and exit.\n""
+ "" --version Print the version number of flatc and exit.\n""
 "" --strict-json Strict JSON: field names must be / will be quoted,\n""
 "" no trailing commas in tables/vectors.\n""
 "" --defaults-json Output fields whose value is the default when\n""
 int main(int argc, const char *argv[]) {
 schema_binary = true;
 } else if(arg == ""-M"") {
 print_make_rules = true;
- } else if(arg == ""-v"" || arg == ""--version"") {
+ } else if(arg == ""--version"") {
 printf(""flatc version %s\n"", FLATC_VERSION);
 exit(0);
 } else {
",270,56
"Bumped version to 1.3.0

Change-Id: I080041e533153b2bb2db53f030761852e95c88fa","
 #include ""flatbuffers/util.h""
 #include <limits>
 
-#define FLATC_VERSION ""1.2.0 ("" __DATE__ "")""
+#define FLATC_VERSION ""1.3.0 ("" __DATE__ "")""
 
 static void Error(const std::string &err, bool usage = false,
 bool show_exe_name = true);
",270,56
Python: remove ctypes dependency in runtime library.,"
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
-import ctypes
-
 from . import number_types as N
 from . import packer
 from .compat import memoryview_type
",7,2
"Fixed enum declaration values being parsed as int.

This caused values in the uint range to be made negative values.

Change-Id: Ia4284747f48508b589c034ff3aae0d141e96eb3c
Tested: on Linux."," CheckedError Parser::ParseEnum(bool is_union, EnumDef **dest) {
 }
 if (Is('=')) {
 NEXT();
- ev.value = atoi(attribute_.c_str());
+ ev.value = StringToInt(attribute_.c_str());
 EXPECT(kTokenIntegerConstant);
 if (!opts.proto_mode && prevsize &&
 enum_def.vals.vec[prevsize - 1]->value >= ev.value)
 CheckedError Parser::CheckClash(std::vector<FieldDef*> &fields,
 }
 return NoError();
 }
- 
+
 static bool compareFieldDefs(const FieldDef *a, const FieldDef *b) {
 auto a_id = atoi(a->attributes.Lookup(""id"")->constant.c_str());
 auto b_id = atoi(b->attributes.Lookup(""id"")->constant.c_str());
 CheckedError Parser::ParseProtoDecl() {
 if (Is(';')) NEXT();
 // Protobuf allows them to be specified in any order, so sort afterwards.
 auto &v = enum_def->vals.vec;
- std::sort(v.begin(), v.end(), compareEnumVals); 
+ std::sort(v.begin(), v.end(), compareEnumVals);
 
 // Temp: remove any duplicates, as .fbs files can't handle them.
 for (auto it = v.begin(); it != v.end(); ) {
",1541,484
"Add helper for javascript typed arrays

For scalar vector fields, emit an Array helper that
returns a typed array view of the underlying bytes buffer."," static void GenStruct(const Parser &parser, StructDef &struct_def,
 }
 code += ""};\n\n"";
 
- // Emit a length helper
+ // Emit vector helpers
 if (field.value.type.base_type == BASE_TYPE_VECTOR) {
+ // Emit a length helper
 GenDocComment(code_ptr, ""@returns {number}"");
 code += object_name + "".prototype."" + MakeCamel(field.name, false);
 code += ""Length = function() {\n"" + offset_prefix;
 code += ""this.bb.__vector_len(this.bb_pos + offset) : 0;\n};\n\n"";
+
+ // For scalar types, emit a typed array helper
+ auto vectorType = field.value.type.VectorType();
+ if (IsScalar(vectorType.base_type)) {
+ GenDocComment(code_ptr, ""@returns {"" + GenType(vectorType) + ""Array}"");
+ code += object_name + "".prototype."" + MakeCamel(field.name, false);
+ code += ""Array = function() {\n"" + offset_prefix;
+ code += ""new "" + GenType(vectorType) + ""Array(this.bb.bytes().buffer, ""
+ ""this.bb.__vector(this.bb_pos + offset), ""
+ ""this.bb.__vector_len(this.bb_pos + offset)) : null;\n};\n\n"";
+ }
 }
 }
 
",611,151
"Fixed namespace code generation for C++

The code generator was assuming all declarations for the current
file sit in the same namepace. Now uses the ""on demand"" namespace
switching we had for the forward declarations.

Also fixed a bug related to namespace lookup.

Change-Id: Ib54a3efbc752cbb9590302fa0707c0c73448db3d
Tested: on Linux.","
 
 namespace MyGame {
 namespace OtherNameSpace {
+
 struct Unused;
+
 } // namespace OtherNameSpace
 } // namespace MyGame
 
 namespace MyGame {
 namespace Example {
 
 struct Test;
+
 struct TestSimpleTableWithEnum;
+
 struct Vec3;
+
 struct Stat;
+
 struct Monster;
 
 enum Color {
",376,176
Fix #3775: Skip unknown field names if they're quoted," CheckedError Parser::SkipJsonObject() {
 for (;;) {
 if ((!opts.strict_json || !fieldn) && Is('}')) break;
 
- if (!Is(kTokenStringConstant))
+ if (!Is(kTokenStringConstant)) {
 EXPECT(opts.strict_json ? kTokenStringConstant : kTokenIdentifier);
+ }
+ else {
+ NEXT();
+ }
 
 EXPECT(':');
 ECHECK(SkipAnyJsonValue());
",1551,487
"Added support for easy string pooling.

Change-Id: I790cf681c1bffff800d77afb0e2f908d1c827679
Tested: on Linux.
Bug: 26186542"," inline bool SetFieldT(Table *table, const reflection::Field &field,
 // above resizing functionality has introduced garbage in a buffer you want
 // to remove.
 // Note: this does not deal with DAGs correctly. If the table passed forms a
-// DAG, the copy will be a tree instead (with duplicates).
+// DAG, the copy will be a tree instead (with duplicates). Strings can be
+// shared however, by passing true for use_string_pooling.
 
 Offset<const Table *> CopyTable(FlatBufferBuilder &fbb,
 const reflection::Schema &schema,
 const reflection::Object &objectdef,
- const Table &table);
+ const Table &table,
+ bool use_string_pooling = false);
 
 } // namespace flatbuffers
 
",255,52
"Allow JSON numeric fields to be specified by a numeric data in a string.

Change-Id: I6a3fae1e71434a7384edc39b8602bd84a0432edb
Tested: on Linux.
Bug: 24140897"," private:
 BaseType req, bool *destmatch);
 FLATBUFFERS_CHECKED_ERROR ParseHash(Value &e, FieldDef* field);
 FLATBUFFERS_CHECKED_ERROR ParseSingleValue(Value &e);
- FLATBUFFERS_CHECKED_ERROR ParseIntegerFromString(Type &type, int64_t *result);
+ FLATBUFFERS_CHECKED_ERROR ParseEnumFromString(Type &type, int64_t *result);
 StructDef *LookupCreateStruct(const std::string &name,
 bool create_if_new = true,
 bool definition = false);
",396,34
"Added RPC declarations to the schema parser.

This is the first step in RPC support. Actual code generation
to follow.

Change-Id: I96c40fec3db671d100dd9eb509a71c5cbe55bfb2
Tested: on Linux.
Bug: 20122696"," struct EnumDef : public Definition {
 Type underlying_type;
 };
 
+struct RPCCall {
+ std::string name;
+ StructDef *request, *response;
+};
+
+struct ServiceDef : public Definition {
+ SymbolTable<RPCCall> calls;
+};
+
 // Container of options that may apply to any of the source/text generators.
 struct IDLOptions {
 bool strict_json;
 private:
 FLATBUFFERS_CHECKED_ERROR StartStruct(const std::string &name,
 StructDef **dest);
 FLATBUFFERS_CHECKED_ERROR ParseDecl();
+ FLATBUFFERS_CHECKED_ERROR ParseService();
 FLATBUFFERS_CHECKED_ERROR ParseProtoFields(StructDef *struct_def,
 bool isextend, bool inside_oneof);
 FLATBUFFERS_CHECKED_ERROR ParseProtoOption();
 private:
 public:
 SymbolTable<StructDef> structs_;
 SymbolTable<EnumDef> enums_;
+ SymbolTable<ServiceDef> services_;
 std::vector<Namespace *> namespaces_;
 std::string error_; // User readable error_ if Parse() == false
 
",405,34
"Added stream & idempotent annotations for RPCs.

Change-Id: Ia8651c1051808fdda0dc0ba52ec991777f868e88
Tested: on Linux."," struct EnumDef : public Definition {
 
 struct RPCCall {
 std::string name;
+ SymbolTable<Value> attributes;
 StructDef *request, *response;
 };
 
 class Parser {
 known_attributes_.insert(""original_order"");
 known_attributes_.insert(""nested_flatbuffer"");
 known_attributes_.insert(""csharp_partial"");
+ known_attributes_.insert(""stream"");
+ known_attributes_.insert(""idempotent"");
 }
 
 ~Parser() {
 private:
 void SerializeStruct(const StructDef &struct_def, const Value &val);
 void AddVector(bool sortbysize, int count);
 FLATBUFFERS_CHECKED_ERROR ParseVector(const Type &type, uoffset_t *ovalue);
- FLATBUFFERS_CHECKED_ERROR ParseMetaData(Definition &def);
+ FLATBUFFERS_CHECKED_ERROR ParseMetaData(SymbolTable<Value> *attributes);
 FLATBUFFERS_CHECKED_ERROR TryTypedValue(int dtoken, bool check, Value &e,
 BaseType req, bool *destmatch);
 FLATBUFFERS_CHECKED_ERROR ParseHash(Value &e, FieldDef* field);
",408,34
"Added --gen-name-strings command line option.

To support the use case described in issue google/flatbuffers#3826, a new command line option --gen-name-strings
has been added, which will cause a static GetFullyQualifiedName function to be added
to the C++ output for tables/structs.","
 #else
 #define FLATBUFFERS_FINAL_CLASS
 #endif
+
+#if (!defined(_MSC_VER) || _MSC_VER >= 1900) && \
+ (!defined(__GNUC__) || (__GNUC__ * 100 + __GNUC_MINOR__ >= 406))
+ #define FLATBUFFERS_CONSTEXPR constexpr
+#else
+ #define FLATBUFFERS_CONSTEXPR
+#endif
+
 /// @endcond
 
 /// @file
",812,227
Fixed VS assignment constructor warning.," FLATBUFFERS_FINAL_CLASS
 bool force_defaults_; // Serialize values equal to their defaults anyway.
 
 struct StringOffsetCompare {
- StringOffsetCompare(const vector_downward &buf) : buf_(buf) {}
+ StringOffsetCompare(const vector_downward &buf) : buf_(&buf) {}
 bool operator() (const Offset<String> &a, const Offset<String> &b) const {
- auto stra = reinterpret_cast<const String *>(buf_.data_at(a.o));
- auto strb = reinterpret_cast<const String *>(buf_.data_at(b.o));
+ auto stra = reinterpret_cast<const String *>(buf_->data_at(a.o));
+ auto strb = reinterpret_cast<const String *>(buf_->data_at(b.o));
 return strncmp(stra->c_str(), strb->c_str(),
 std::min(stra->size(), strb->size()) + 1) < 0;
 }
- const vector_downward &buf_;
+ const vector_downward *buf_;
 };
 
 // For use with CreateSharedString. Instantiated on first use only.
",812,227
"Fix flatc build for msvc.

(from CL 117010760)

Change-Id: I0ee77cf87d0cb00b94887356745b85423b1375a6","
 #include <iomanip>
 #include <string>
 #include <sstream>
+#include <stdint.h>
 #include <stdlib.h>
 #include <assert.h>
 #ifdef _WIN32
",187,54
"Fix flatbuffers conversion warnings.

(from CL 116785833)

Change-Id: I0fb0e1318fd70cba51e229a93f535c6639bbb331"," class vector_downward {
 inline voffset_t FieldIndexToOffset(voffset_t field_id) {
 // Should correspond to what EndTable() below builds up.
 const int fixed_fields = 2; // Vtable size and Object Size.
- return (field_id + fixed_fields) * sizeof(voffset_t);
+ return static_cast<voffset_t>((field_id + fixed_fields) * sizeof(voffset_t));
 }
 
 // Computes how many bytes you'd have to pad to be able to write an
 FLATBUFFERS_FINAL_CLASS
 Align(sizeof(uoffset_t));
 // Offset must refer to something already in buffer.
 assert(off && off <= GetSize());
- return GetSize() - off + sizeof(uoffset_t);
+ return GetSize() - off + static_cast<uoffset_t>(sizeof(uoffset_t));
 }
 
 void NotNested() {
",816,227
"Remove unnecessary condition in AssertOffsetAndLength.

Condition is already checked and covered in the following condition, the second one was excess.

Signed-off-by: Wojciech Jaszczak <jaszczakw@gmail.com>"," namespace FlatBuffers
 private void AssertOffsetAndLength(int offset, int length)
 {
 if (offset < 0 ||
- offset >= _buffer.Length ||
- offset + length > _buffer.Length)
+ offset > _buffer.Length - length)
 throw new ArgumentOutOfRangeException();
 }
 
",354,66
"Fixed pre-declarations of included types in generated code.

This was harmless, but unnecessary.

Change-Id: I1365a725e254d4ebbda081110a50277cb5118323
Tested: on Linux."," std::string GenerateCPP(const Parser &parser,
 for (auto it = parser.structs_.vec.begin();
 it != parser.structs_.vec.end(); ++it) {
 auto &struct_def = **it;
- CheckNameSpace(struct_def, &code);
- code += ""struct "" + struct_def.name + "";\n\n"";
+ if (!struct_def.generated) {
+ CheckNameSpace(struct_def, &code);
+ code += ""struct "" + struct_def.name + "";\n\n"";
+ }
 }
 
 // Generate code for all the enum declarations.
",744,171
"Fixed JSON integers as strings not being parsed correctly.

Change-Id: If34aef46ef619e06de799cff14948b02e98da86d
Tested: on Linux."," CheckedError Parser::ParseSingleValue(Value &e) {
 assert(0); // Shouldn't happen, we covered all types.
 e.constant = ""0"";
 }
+ NEXT();
 }
 } else {
 bool match = false;
",1611,501
"Made user-defined attributes available in the reflection data.

Tested: on Linux.

Bug: 27923233
Change-Id: Ic16675650e4a8e138c163f1e2131a3aad7008ada","
 
 #include ""namespace_test1_generated.h""
 
-namespace NamespaceA {
-namespace NamespaceB {
-
-struct TableInNestedNS;
-
-struct StructInNestedNS;
-
-} // namespace NamespaceB
-} // namespace NamespaceA
-
 namespace NamespaceA {
 
 struct TableInFirstNS;
",129,43
"Fixed struct -> class pre-declaration error.

Change-Id: I3730a6823d603982c4250d514e827e3f93d1f81e
Tested: on Linux."," inline size_t SizeOf(BaseType t) {
 
 struct StructDef;
 struct EnumDef;
-struct Parser;
+class Parser;
 
 // Represents any type in the IDL, which is a combination of the BaseType
 // and additional information for vectors/structs_.
",415,34
"Fixed whole-number float default values missing a .0 suffix.

A previous commit that added ""f"" for C++/Java/C# would break
on gcc of constants like 3f, which are now output as 3.0f

Tested: on Linux

Change-Id: If9cabbe3c6d6948a5050b8b123bda9c06e181f52"," CheckedError Parser::ParseField(StructDef &struct_def) {
 if (!IsScalar(type.base_type))
 return Error(""default values currently only supported for scalars"");
 ECHECK(ParseSingleValue(field->value));
+ if (IsFloat(field->value.type.base_type)) {
+ if (!strpbrk(field->value.constant.c_str(), "".eE""))
+ field->value.constant += "".0"";
+ }
 }
 
 if (type.enum_def &&
",1641,507
size the allocation to the required bytes," public class Table {
 int required = (int)((float)length * decoder.maxCharsPerByte());
 CharBuffer dst = CHAR_BUFFER.get();
 if (dst == null || dst.capacity() < required) {
- dst = CharBuffer.allocate(Math.max(required, 128));
+ dst = CharBuffer.allocate(required);
 CHAR_BUFFER.set(dst);
 }
 
",86,19
"Fixed float suffix not being added on implicit float defaults.

Change-Id: I8dcbb5e93836356511d411ef86452babd3dd3c0b
Tested: on Linux."," CheckedError Parser::ParseField(StructDef &struct_def) {
 if (!IsScalar(type.base_type))
 return Error(""default values currently only supported for scalars"");
 ECHECK(ParseSingleValue(field->value));
- if (IsFloat(field->value.type.base_type)) {
- if (!strpbrk(field->value.constant.c_str(), "".eE""))
- field->value.constant += "".0"";
- }
+ }
+ if (IsFloat(field->value.type.base_type)) {
+ if (!strpbrk(field->value.constant.c_str(), "".eE""))
+ field->value.constant += "".0"";
 }
 
 if (type.enum_def &&
",1641,507
"Fixed SkipByteOrderMark advancing cursor_ too early.

Change-Id: Ie60f01d935ca6b4aa6ce0eab7598602ac0758342
Tested: on Linux."," CheckedError Parser::ParseHexNum(int nibbles, int64_t *val) {
 CheckedError Parser::SkipByteOrderMark() {
 if (static_cast<unsigned char>(*cursor_) != 0xef) return NoError();
 cursor_++;
- if (static_cast<unsigned char>(*cursor_++) != 0xbb) return Error(""invalid utf-8 byte order mark"");
- if (static_cast<unsigned char>(*cursor_++) != 0xbf) return Error(""invalid utf-8 byte order mark"");
+ if (static_cast<unsigned char>(*cursor_) != 0xbb) return Error(""invalid utf-8 byte order mark"");
+ cursor_++;
+ if (static_cast<unsigned char>(*cursor_) != 0xbf) return Error(""invalid utf-8 byte order mark"");
+ cursor_++;
 return NoError();
 }
 
",1643,507
"Fixed a verifier check that didn't return from its parent.

Change-Id: I1aef5fdba72de0c3bb8276c9f50fffa494f26e29
Tested: on Linux."," class Verifier FLATBUFFERS_FINAL_CLASS {
 // must be 0.
 auto size = ReadScalar<uoffset_t>(vec);
 auto max_elems = FLATBUFFERS_MAX_BUFFER_SIZE / elem_size;
- Check(size < max_elems); // Protect against byte_size overflowing.
+ if (!Check(size < max_elems))
+ return false; // Protect against byte_size overflowing.
 auto byte_size = sizeof(size) + elem_size * size;
 *end = vec + byte_size;
 return Verify(vec, byte_size);
",820,228
Fix heap allocation when reading a string.," func (t *Table) Indirect(off UOffsetT) UOffsetT {
 
 // String gets a string from data stored inside the flatbuffer.
 func (t *Table) String(off UOffsetT) string {
-return string(t.ByteVector(off))
+b := t.ByteVector(off)
+return byteSliceToString(b)
 }
 
 // ByteVector gets a byte slice from data stored inside the flatbuffer.
",177,49
"Can now use ``CharSequence`` of ``String``. Works with

1. [AsciiString]
(http://netty.io/4.1/api/io/netty/util/AsciiString.html)
2. [CharBuffer]
(https://docs.oracle.com/javase/8/docs/api/java/nio/CharBuffer.html)
3. [StringBuilder]
(https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuilder.html)"," public class FlatBufferBuilder {
 * @param s The string to encode.
 * @return The offset in the buffer where the encoded string starts.
 */
- public int createString(String s) {
+ public int createString(CharSequence s) {
 int length = s.length();
 int estimatedDstCapacity = (int) (length * encoder.maxBytesPerChar());
 if (dst == null || dst.capacity() < estimatedDstCapacity) {
",269,97
memory leak fix + php/js/python transition to class based generator," class CppGenerator : public BaseGenerator {
 
 bool GenerateCPP(const Parser &parser, const std::string &path,
 const std::string &file_name) {
- cpp::CppGenerator *generator = new cpp::CppGenerator(parser, path, file_name);
- return generator->generate();
+ cpp::CppGenerator generator(parser, path, file_name);
+ return generator.generate();
 }
 
 std::string CPPMakeRule(const Parser &parser,
",752,171
Fix undefined behavior in CheckBitsFit bit-shift on size_t," inline CheckedError NoError() { return CheckedError(false); }
 
 // Ensure that integer values we parse fit inside the declared integer type.
 CheckedError Parser::CheckBitsFit(int64_t val, size_t bits) {
- // Bits we allow to be used.
- auto mask = static_cast<int64_t>((1ull << bits) - 1);
- if (bits < 64 &&
- (val & ~mask) != 0 && // Positive or unsigned.
- (val | mask) != -1) // Negative.
- return Error(""constant does not fit in a "" + NumToString(bits) +
- ""-bit field"");
+ // Left-shifting a 64-bit value by 64 bits or more is undefined
+ // behavior (C99 6.5.7), so check *before* we shift.
+ if (bits < 64) {
+ // Bits we allow to be used.
+ auto mask = static_cast<int64_t>((1ull << bits) - 1);
+ if ((val & ~mask) != 0 && // Positive or unsigned.
+ (val | mask) != -1) // Negative.
+ return Error(""constant does not fit in a "" + NumToString(bits) +
+ ""-bit field"");
+ }
 return NoError();
 }
 
",1644,507
"Added helpers to access objects while creating the flatbuffer.

GetObject and GetMutableObject are similar to GetRoot and GetMutableRoot,
and can be useful when wanting to access data that has just been created.
Unfortunately there is a danger in using these methods, as it is possible
that the buffer reallocates which will invalidate the pointers."," template<typename T> const T *GetRoot(const void *buf) {
 return GetMutableRoot<T>(const_cast<void *>(buf));
 }
 
+/// Helpers to get a typed pointer to objects that are currently beeing built.
+/// @warning Creating new objects will lead to reallocations and invalidates the pointer!
+template<typename T> T *GetMutableObject(FlatBufferBuilder &fbb, Offset<T> offset) {
+ return reinterpret_cast<T *>(fbb.GetCurrentBufferPointer() +
+ fbb.GetSize() - offset.o);
+}
+
+template<typename T> const T *GetObject(FlatBufferBuilder &fbb, Offset<T> offset) {
+ return GetMutableObject<T>(fbb, offset);
+}
+
 // Helper to see if the identifier in a buffer has the expected value.
 inline bool BufferHasIdentifier(const void *buf, const char *identifier) {
 return strncmp(reinterpret_cast<const char *>(buf) + sizeof(uoffset_t),
",827,230
"Fixes verifier not catching odd vtable sizes.

Bug: 28762769
Change-Id: Iec370482f67c4585e97dd5175c1a4258ddba47fe
Tested: on Linux."," class Table {
 // Check the vtable size field, then check vtable fits in its entirety.
 return verifier.VerifyComplexity() &&
 verifier.Verify<voffset_t>(vtable) &&
+ (ReadScalar<voffset_t>(vtable) & (sizeof(voffset_t) - 1)) == 0 &&
 verifier.Verify(vtable, ReadScalar<voffset_t>(vtable));
 }
 
",821,229
"If the user passes in a {{CharBuffer}} himser, reward him by
eliminating the last remaining allocation in string creation"," public class FlatBufferBuilder {
 
 dst.clear();
 
- CharBuffer src = CharBuffer.wrap(s);
+ CharBuffer src = s instanceof CharBuffer ? (CharBuffer) s :
+ CharBuffer.wrap(s);
 CoderResult result = encoder.encode(src, dst, true);
 if (result.isError()) {
 try {
",270,98
"Added missing licenses to some sh/cs/py files.

Bug: https://github.com/google/flatbuffers/issues/3872
Change-Id: I5d551168e9bc925e867e5e4ddf5d809418fd44eb
Tested: on Linux.","
+/*
+ * Copyright 2016 Google Inc. All rights reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the ""License"");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an ""AS IS"" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 namespace FlatBuffers.Test
 {
 /// <summary>
",20,3
"Removed BOM marker from some files.

Also removed some trailing whitespace.

Change-Id: I40bf4f776ca4d467b7ee6f2c9a7500c13700f9d5","
-/*
+/*
 * Copyright 2014 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
",353,66
Clarify documentation based on review comments," public class FlatBufferBuilder {
 /// @endcond
 
 /**
- * Encode the string `s` in the buffer using UTF-8.
+ * Encode the string `s` in the buffer using UTF-8. If {@code s} is
+ * already a {@link CharBuffer}, this method is allocation free.
 *
 * @param s The string to encode.
 * @return The offset in the buffer where the encoded string starts.
",270,98
"Add a fuzzer for flatbuffers, derived from the one used in Chromium:
https://code.google.com/p/chromium/codesearch#chromium/src/testing/libfuzzer/fuzzers/flatbuffers_verifier_fuzzer.cc

(mirrored from cl 122676317)

Change-Id: I0074af435cf37f5e6368b040563c3733d9e02345","
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+#include <stddef.h>
+#include <stdint.h>
+#include <string>
+
+#include ""third_party/flatbuffers/tests/monster_test_generated.h""
+
+extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
+ flatbuffers::Verifier verifier(data, size);
+ MyGame::Example::VerifyMonsterBuffer(verifier);
+ return 0;
+}
",9,1
MSVC doesn't allow alignment on function params. This prevents the copy and thus avoids this issue https://msdn.microsoft.com/en-us/library/373ak2y1.aspx," public:
 
 // Change elements if you have a non-const pointer to this object.
 // Scalars only. See reflection.h, and the documentation.
- void Mutate(uoffset_t i, T val) {
+ void Mutate(uoffset_t i, const T& val) {
 assert(i < size());
 WriteScalar(data() + i, val);
 }
",821,229
shared method that exits early if everything is generated," class BaseGenerator {
 protected:
 virtual ~BaseGenerator(){};
 
+ bool IsEverythingGenerated() {
+ for (auto it = parser_.enums_.vec.begin(); it != parser_.enums_.vec.end();
+ ++it) {
+ if (!(*it)->generated) return false;
+ }
+ for (auto it = parser_.structs_.vec.begin();
+ it != parser_.structs_.vec.end(); ++it) {
+ if (!(*it)->generated) return false;
+ }
+ return true;
+ }
+
 const Parser &parser_;
 const std::string &path_;
 const std::string &file_name_;
",25,7
"Add simple libfuzzer based test.

This tests the verifier and the parser.

Tested: on Linux.
Bug: 27230459
Change-Id: I3417faba9385dc941199c57a08d8a50c2faec1aa","
+// Copyright 2015 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+#include <stddef.h>
+#include <stdint.h>
+#include <string>
+
+#include ""flatbuffers/idl.h""
+
+extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
+ flatbuffers::Parser parser;
+ // Guarantee 0-termination.
+ std::string s(reinterpret_cast<const char *>(data), size);
+ parser.Parse(s.c_str());
+ return 0;
+}
",10,1
sharing the Flatbuffers warning," class BaseGenerator {
 protected:
 virtual ~BaseGenerator(){};
 
+ const char * FlatBuffersGeneratedWarning() {
+ return ""automatically generated by the FlatBuffers compiler,""
+ "" do not modify\n\n"";
+ } 
+ 
 bool IsEverythingGenerated() {
 for (auto it = parser_.enums_.vec.begin(); it != parser_.enums_.vec.end();
 ++it) {
",29,8
sharing namespace_dir and the namespace string methods," class GoGenerator : public BaseGenerator {
 bool needs_imports) {
 if (!classcode.length()) return true;
 
- std::string namespace_name;
- std::string namespace_dir = path_; // Either empty or ends in separator.
- auto &namespaces = parser_.namespaces_.back()->components;
- for (auto it = namespaces.begin(); it != namespaces.end(); ++it) {
- if (namespace_name.length()) {
- namespace_name += ""."";
- }
- namespace_name = *it;
- namespace_dir += *it + kPathSeparator;
- }
- EnsureDirExists(namespace_dir);
-
 std::string code = """";
- BeginFile(namespace_name, needs_imports, &code);
+ BeginFile(LastNamespacePart(), needs_imports, &code);
 code += classcode;
- std::string filename = namespace_dir + def.name + "".go"";
+ std::string filename = namespace_dir_ + def.name + "".go"";
 return SaveFile(filename.c_str(), code, false);
 }
 };
",534,92
"Define bit mask operators for scoped enums bitfields

Close #3887"," volatile __attribute__((weak)) const char *flatbuffer_version_string =
 
 #endif // !defined(_WIN32) && !defined(__CYGWIN__)
 
+#define DEFINE_BITMASK_OPERATORS(E)\
+ inline E operator | (E lhs, E rhs){\
+ using T = std::underlying_type<E>::type;\
+ return E(T(lhs) | T(rhs));\
+ }\
+ inline E operator & (E lhs, E rhs){\
+ using T = std::underlying_type<E>::type;\
+ return E(T(lhs) & T(rhs));\
+ }\
+ inline E operator ^ (E lhs, E rhs){\
+ using T = std::underlying_type<E>::type;\
+ return E(T(lhs) ^ T(rhs));\
+ }\
+ inline E operator ~ (E lhs){\
+ using T = std::underlying_type<E>::type;\
+ return E(~T(lhs));\
+ }\
+ inline E operator |= (E &lhs, E rhs){\
+ lhs = lhs | rhs;\
+ return lhs;\
+ }\
+ inline E operator &= (E &lhs, E rhs){\
+ lhs = lhs & rhs;\
+ return lhs;\
+ }\
+ inline E operator ^= (E &lhs, E rhs){\
+ lhs = lhs ^ rhs;\
+ return lhs;\
+ }
 /// @endcond
 } // namespace flatbuffers
 
",821,229
"We already know the underlying_type.

We just need to pass it to DEFINE_BITMASK_OPERATORS macro"," volatile __attribute__((weak)) const char *flatbuffer_version_string =
 
 #endif // !defined(_WIN32) && !defined(__CYGWIN__)
 
-#define DEFINE_BITMASK_OPERATORS(E)\
+#define DEFINE_BITMASK_OPERATORS(E, T)\
 inline E operator | (E lhs, E rhs){\
- using T = std::underlying_type<E>::type;\
 return E(T(lhs) | T(rhs));\
 }\
 inline E operator & (E lhs, E rhs){\
- using T = std::underlying_type<E>::type;\
 return E(T(lhs) & T(rhs));\
 }\
 inline E operator ^ (E lhs, E rhs){\
- using T = std::underlying_type<E>::type;\
 return E(T(lhs) ^ T(rhs));\
 }\
 inline E operator ~ (E lhs){\
- using T = std::underlying_type<E>::type;\
 return E(~T(lhs));\
 }\
 inline E operator |= (E &lhs, E rhs){\
",821,229
"renamed functions

More descriptive name, show that it's really just a temporary object."," template<typename T> const T *GetRoot(const void *buf) {
 
 /// Helpers to get a typed pointer to objects that are currently beeing built.
 /// @warning Creating new objects will lead to reallocations and invalidates the pointer!
-template<typename T> T *GetMutableObject(FlatBufferBuilder &fbb, Offset<T> offset) {
+template<typename T> T *GetMutableTemporaryPointer(FlatBufferBuilder &fbb, Offset<T> offset) {
 return reinterpret_cast<T *>(fbb.GetCurrentBufferPointer() +
 fbb.GetSize() - offset.o);
 }
 
-template<typename T> const T *GetObject(FlatBufferBuilder &fbb, Offset<T> offset) {
- return GetMutableObject<T>(fbb, offset);
+template<typename T> const T *GetTemporaryPointer(FlatBufferBuilder &fbb, Offset<T> offset) {
+ return GetMutableTemporaryPointer<T>(fbb, offset);
 }
 
 // Helper to see if the identifier in a buffer has the expected value.
",827,230
cpp generator : pulling all methods inside the class," enum Color {
 Color_Red = 1,
 Color_Green = 2,
 Color_Blue = 8,
- Color_MIN = Color_Red,
- Color_MAX = Color_Blue
+ Color_NONE = 0,
+ Color_ANY = 11
 };
 
 inline const char **EnumNamesColor() {
",392,188
Better C++ namespace management," namespace NamespaceA {
 
 struct SecondTableInA;
 
-} // namespace NamespaceA
-
-namespace NamespaceA {
-
 struct TableInFirstNS FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
 enum {
 VT_FOO_TABLE = 4,
",127,43
Fixed compile errors on Windows," class BaseGenerator {
 namespace_dir_(BaseGenerator::NamespaceDir(parser, path)){};
 virtual ~BaseGenerator(){};
 
+ // No copy/assign.
+ BaseGenerator &operator=(const BaseGenerator &);
+ BaseGenerator(const BaseGenerator &);
+
 const char *FlatBuffersGeneratedWarning() {
 return ""automatically generated by the FlatBuffers compiler,""
 "" do not modify\n\n"";
",60,16
"Fixed LoadFile crashing on directory arguments.

Change-Id: I737f6fd0bb1302ab7cfa6ab8b06108e221ebb63c
Tested: on Linux.","
 #include <winbase.h>
 #include <direct.h>
 #else
-#include <sys/stat.h>
 #include <limits.h>
 #endif
+#include <sys/types.h>
+#include <sys/stat.h>
 
 #include ""flatbuffers/flatbuffers.h""
 
 FileExistsFunction SetFileExistsFunction(FileExistsFunction
 // Check if file ""name"" exists.
 bool FileExists(const char *name);
 
+// Check if ""name"" exists and it is also a directory.
+bool DirExists(const char *name);
+
 // Load file ""name"" into ""buf"" returning true if successful
 // false otherwise. If ""binary"" is false data is read
 // using ifstream's text mode, otherwise data is read with
",178,49
Emit GetRootAs methods for all types in Go and Python," static void GenTableBuilders(const StructDef &struct_def,
 
 // Generate struct or table methods.
 static void GenStruct(const StructDef &struct_def,
- std::string *code_ptr,
- StructDef *root_struct_def) {
+ std::string *code_ptr) {
 if (struct_def.generated) return;
 
 GenComment(struct_def.doc_comment, code_ptr, nullptr);
 BeginClass(struct_def, code_ptr);
- if (&struct_def == root_struct_def) {
+ if (!struct_def.fixed) {
 // Generate a special accessor for the table that has been declared as
 // the root type.
 NewRootTypeFromBuffer(struct_def, code_ptr);
 class GoGenerator : public BaseGenerator {
 for (auto it = parser_.structs_.vec.begin();
 it != parser_.structs_.vec.end(); ++it) {
 std::string declcode;
- go::GenStruct(**it, &declcode, parser_.root_struct_def_);
+ go::GenStruct(**it, &declcode);
 if (!SaveType(**it, declcode, true)) return false;
 }
 
",533,92
Add tests for GetRootAs* in Go and Python," class TestAllCodePathsOfExampleSchema(unittest.TestCase):
 self.assertEqual(7, mon2.Testhashs64Fnv1a())
 self.assertEqual(8, mon2.Testhashu64Fnv1a())
 
+ def test_getrootas_for_nonroot_table(self):
+ b = flatbuffers.Builder(0)
+ string = b.CreateString(""MyStat"")
+
+ MyGame.Example.Stat.StatStart(b)
+ MyGame.Example.Stat.StatAddId(b, string)
+ MyGame.Example.Stat.StatAddVal(b, 12345678)
+ MyGame.Example.Stat.StatAddCount(b, 12345)
+ stat = MyGame.Example.Stat.StatEnd(b)
+ b.Finish(stat)
+
+ stat2 = MyGame.Example.Stat.Stat.GetRootAsStat(b.Bytes, b.Head())
+
+ self.assertEqual(b""MyStat"", stat2.Id())
+ self.assertEqual(12345678, stat2.Val())
+ self.assertEqual(12345, stat2.Count())
+
 
 class TestVtableDeduplication(unittest.TestCase):
 ''' TestVtableDeduplication verifies that vtables are deduplicated. '''
",1041,139
Fix test using compat.binary_types (from March).," class TestFuzz(unittest.TestCase):
 ''' Low level stress/fuzz test: serialize/deserialize a variety of
 different kinds of data in different combinations '''
 
- ofInt32Bytes = compat.binary_type([0x83, 0x33, 0x33, 0x33])
- ofInt64Bytes = compat.binary_type([0x84, 0x44, 0x44, 0x44,
- 0x44, 0x44, 0x44, 0x44])
+ binary_type = compat.binary_types[0] # this will always exist
+ ofInt32Bytes = binary_type([0x83, 0x33, 0x33, 0x33])
+ ofInt64Bytes = binary_type([0x84, 0x44, 0x44, 0x44,
+ 0x44, 0x44, 0x44, 0x44])
 overflowingInt32Val = flatbuffers.encode.Get(flatbuffers.packer.int32,
 ofInt32Bytes, 0)
 overflowingInt64Val = flatbuffers.encode.Get(flatbuffers.packer.int64,
",1029,138
"Allow unions of table types with the same name but from different namespaces.

Also fixed most codegenerators using the wrong namespace when multiple
namespace were used in a file, with some files not being generated.

Change-Id: Ib42969221239d7244e431cbd667ef69200fc415f
Tested: on Linux.
Bug: 29338474"," class GoGenerator : public BaseGenerator {
 if (!classcode.length()) return true;
 
 std::string code = """";
- BeginFile(LastNamespacePart(), needs_imports, &code);
+ BeginFile(LastNamespacePart(*def.defined_namespace), needs_imports, &code);
 code += classcode;
- std::string filename = namespace_dir_ + def.name + "".go"";
+ std::string filename =
+ NamespaceDir(*def.defined_namespace) + def.name + "".go"";
 return SaveFile(filename.c_str(), code, false);
 }
 };
",535,92
"JSON Parser allows union type fields to come after unions.

This is useful because many JSON generators will sort the fields,
cause X_type to follow X.

Change-Id: I00ef3ac05418224fc05aee93e6b3b3597e73ffe3
Tested: on Linux.
Bug: 29221752"," template<typename T, typename U> pointer_inside_vector<T, U> piv(T *ptr,
 return pointer_inside_vector<T, U>(ptr, vec);
 }
 
+inline const char *UnionTypeFieldSuffix() { return ""_type""; }
+
 // Helper to figure out the actual table type a union refers to.
 inline const reflection::Object &GetUnionType(
 const reflection::Schema &schema, const reflection::Object &parent,
 inline const reflection::Object &GetUnionType(
 auto enumdef = schema.enums()->Get(unionfield.type()->index());
 // TODO: this is clumsy and slow, but no other way to find it?
 auto type_field = parent.fields()->LookupByKey(
- (unionfield.name()->str() + ""_type"").c_str());
+ (unionfield.name()->str() + UnionTypeFieldSuffix()).c_str());
 assert(type_field);
 auto union_type = GetFieldI<uint8_t>(table, *type_field);
 auto enumval = enumdef->values()->LookupByKey(union_type);
",256,53
sharing the WrapInNameSpace methods," class GoGenerator : public BaseGenerator {
 public:
 GoGenerator(const Parser &parser, const std::string &path,
 const std::string &file_name)
- : BaseGenerator(parser, path, file_name){};
+ : BaseGenerator(parser, path, file_name, """" /* not used*/,
+ """" /* not used */){};
 bool generate() {
 for (auto it = parser_.enums_.vec.begin(); it != parser_.enums_.vec.end();
 ++it) {
",536,92
"Added GRPC code generator to flatc.

Also added simple (in-process) test.

Change-Id: I38580d554dd52f590e3396ec4846e07546dcf07d
Tested: on Linux."," class Verifier FLATBUFFERS_FINAL_CLASS {
 size_t max_tables_;
 };
 
+// Convenient way to bundle a buffer and its length, to pass it around
+// typed by its root.
+// A BufferRef does not own its buffer.
+struct BufferRefBase {}; // for std::is_base_of
+template<typename T> struct BufferRef : BufferRefBase {
+ BufferRef() : buf(nullptr), len(0), must_free(false) {}
+ BufferRef(uint8_t *_buf, uoffset_t _len)
+ : buf(_buf), len(_len), must_free(false) {}
+
+ ~BufferRef() { if (must_free) free(buf); }
+
+ const T *GetRoot() const { return flatbuffers::GetRoot<T>(buf); }
+
+ bool Verify() {
+ Verifier verifier(buf, len);
+ return verifier.VerifyBuffer<T>();
+ }
+
+ uint8_t *buf;
+ uoffset_t len;
+ bool must_free;
+};
+
 // ""structs"" are flat structures that do not have an offset table, thus
 // always have all members present and do not support forwards/backwards
 // compatible extensions.
",865,242
Fixed operator++. Added CreateXXX for vector types.," public:
 }
 
 VectorIterator operator++(int) {
- VectorIterator temp(data_);
+ VectorIterator temp(data_,0);
 data_ += IndirectHelper<T>::element_stride;
 return temp;
 }
",865,242
Update idl_parser.cpp," CheckedError Parser::Next() {
 return NoError();
 } else if (isdigit(static_cast<unsigned char>(c)) || c == '-') {
 const char *start = cursor_ - 1;
+ const char *start_2 = cursor_ + 1;
+ if (c == '-' && *cursor_ == '0' && (*start_2 == 'x' || *start_2 == 'X')) {
+ ++start;
+ ++cursor_;
+ attribute_.append(&c, &c + 1);
+ c = '0';
+ }
 if (c == '0' && (*cursor_ == 'x' || *cursor_ == 'X')) {
 cursor_++;
 while (isxdigit(static_cast<unsigned char>(*cursor_))) cursor_++;
",1737,527
Update idl_gen_fbs.cpp," static void GenNameSpace(const Namespace &name_space, std::string *_schema,
 std::string GenerateFBS(const Parser &parser, const std::string &file_name, const bool &escape_proto_identifiers) {
 // Proto namespaces may clash with table names, so we have to prefix all:
 
-if (!escape_proto_identifiers) {
-for (auto it = parser.namespaces_.begin(); it != parser.namespaces_.end();
-++it) {
-for (auto comp = (*it)->components.begin(); comp != (*it)->components.end();
-++comp) {
-(*comp) = ""_"" + (*comp);
-}
+ if (!escape_proto_identifiers) {
+for (auto it = parser.namespaces_.begin(); it != parser.namespaces_.end();
+++it) {
+for (auto comp = (*it)->components.begin(); comp != (*it)->components.end();
+++comp) {
+(*comp) = ""_"" + (*comp);
 }
-}
-
+ }
+ }
 std::string schema;
 schema += ""// Generated from "" + file_name + "".proto\n\n"";
 if (parser.opts.include_dependence_headers) {
",99,24
fixed initialization of member var for old make (hopefully)," class CppGenerator : public BaseGenerator {
 public:
 CppGenerator(const Parser &parser, const std::string &path,
 const std::string &file_name)
- : BaseGenerator(parser, path, file_name, """", ""::""){};
+ : BaseGenerator(parser, path, file_name, """", ""::""), 
+ cur_name_space_(nullptr){};
 // Iterate through all definitions we haven't generate code for (enums,
 // structs,
 // and tables) and output them to a single file.
 class CppGenerator : public BaseGenerator {
 
 private:
 // This tracks the current namespace so we can insert namespace declarations.
- const Namespace *cur_name_space_ = nullptr;
+ const Namespace *cur_name_space_;
 
 const Namespace *CurrentNameSpace() { return cur_name_space_; }
 
",733,176
fix missing space (clang format)," class CppGenerator : public BaseGenerator {
 public:
 CppGenerator(const Parser &parser, const std::string &path,
 const std::string &file_name)
- : BaseGenerator(parser, path, file_name, """", ""::""), 
- cur_name_space_(nullptr){};
+ : BaseGenerator(parser, path, file_name, """", ""::""),
+ cur_name_space_(nullptr){};
 // Iterate through all definitions we haven't generate code for (enums,
 // structs,
 // and tables) and output them to a single file.
",733,176
same fix for general code generator," class GeneralGenerator : public BaseGenerator {
 public:
 GeneralGenerator(const Parser &parser, const std::string &path,
 const std::string &file_name)
- : BaseGenerator(parser, path, file_name, """", "".""){
- assert(parser_.opts.lang <= IDLOptions::kMAX);
+ : BaseGenerator(parser, path, file_name, """", "".""),
+ lang_(language_parameters[parser_.opts.lang]) {
+ assert(parser_.opts.lang <= IDLOptions::kMAX);
 };
 bool generate() {
 std::string one_file_code;
 void GenStruct(StructDef &struct_def, std::string *code_ptr) {
 }
 code += ""};\n\n"";
 } 
- const LanguageParameters & lang_ = language_parameters[parser_.opts.lang];
+ const LanguageParameters & lang_;
 };
 } // namespace general
 
",1020,246
js:add @namespace annotation to namespaces,"
 /// @addtogroup flatbuffers_javascript_api
 /// @{
 /// @cond FLATBUFFERS_INTERNAL
+/**
+ * @const
+ * @namespace
+ */
 var flatbuffers = {};
 
 /**
",495,136
"Don't crash if str is null

Is useful especially when we want to create a string from another message string that might be null."," FLATBUFFERS_FINAL_CLASS
 /// @param[in] str A const pointer to a `String` struct to add to the buffer.
 /// @return Returns the offset in the buffer where the string starts
 Offset<String> CreateString(const String *str) {
- return CreateString(str->c_str(), str->Length());
+ return str ? CreateString(str->c_str(), str->Length()) : 0;
 }
 
 /// @brief Store a string in the buffer, which can contain any binary data.
",865,243
Verify everything in one shot," class Verifier FLATBUFFERS_FINAL_CLASS {
 }
 
 // Verify this whole buffer, starting with root type T.
- template<typename T> bool VerifyBuffer() {
+ template<typename T> bool VerifyBuffer(const char *identifier) {
+ if (identifier && (size_t(end_ - buf_) < 2 * sizeof(flatbuffers::uoffset_t) ||
+ !BufferHasIdentifier(buf_, identifier))) {
+ return false;
+ }
+
 // Call T::Verify, which must be in the generated code for this type.
 return Verify<uoffset_t>(buf_) &&
 reinterpret_cast<const T *>(buf_ + ReadScalar<uoffset_t>(buf_))->
",883,254
clang formating cpp code generator and add missing generated classes," public final class Any {
 public static final byte TestSimpleTableWithEnum = 2;
 public static final byte MyGame_Example2_Monster = 3;
 
- private static final String[] names = { ""NONE"", ""Monster"", ""TestSimpleTableWithEnum"", ""MyGame_Example2_Monster"", };
+ public static final String[] names = { ""NONE"", ""Monster"", ""TestSimpleTableWithEnum"", ""MyGame_Example2_Monster"", };
 
 public static String name(int e) { return names[e]; }
-};
+}
 
",10,2
"Fix typo

Related to https://github.com/google/flatbuffers/pull/3904#issuecomment-224724181"," class FlatbufferBuilder
 public function putLong($x)
 {
 if ($x > PHP_INT_MAX) {
- throw new \InvalidArgumentException(""your platform can't handle long correctly. use 64bit machine."");
+ throw new \InvalidArgumentException(""Your platform can't handle long correctly. Use a 64bit machine."");
 }
 
 $this->bb->putLong($this->space -= 8, $x);
 class FlatbufferBuilder
 public function putUlong($x)
 {
 if ($x > PHP_INT_MAX) {
- throw new \InvalidArgumentException(""your platform can't handle ulong correctly. this is php limitations. please wait extension release."");
+ throw new \InvalidArgumentException(""Your platform can't handle ulong correctly. This is a php limitation. Please wait for the extension release."");
 }
 
 $this->bb->putUlong($this->space -= 8, $x);
",512,175
Implement mutators for Go," func (rcv *Stat) Val() int64 {
 return 0
 }
 
+func (rcv *Stat) MutateVal(n int64) bool {
+return rcv._tab.MutateInt64Slot(6, n)
+}
+
 func (rcv *Stat) Count() uint16 {
 o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
 if o != 0 {
 func (rcv *Stat) Count() uint16 {
 return 0
 }
 
+func (rcv *Stat) MutateCount(n uint16) bool {
+return rcv._tab.MutateUint16Slot(8, n)
+}
+
 func StatStart(builder *flatbuffers.Builder) { builder.StartObject(3) }
 func StatAddId(builder *flatbuffers.Builder, id flatbuffers.UOffsetT) { builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(id), 0) }
 func StatAddVal(builder *flatbuffers.Builder, val int64) { builder.PrependInt64Slot(1, val, 0) }
",43,14
"Added optional object based API for C++.

Change-Id: If927f3ea3fb3723088fa287f24bdd1ad43c8d1d1
Tested: on Linux."," struct IDLOptions {
 bool skip_unexpected_fields_in_json;
 bool generate_name_strings;
 bool escape_proto_identifiers;
- 
+ bool generate_object_based_api;
+
 // Possible options for the more general generator below.
 enum Language { kJava, kCSharp, kGo, kMAX };
 
 struct IDLOptions {
 skip_unexpected_fields_in_json(false),
 generate_name_strings(false),
 escape_proto_identifiers(false),
+ generate_object_based_api(false),
 lang(IDLOptions::kJava) {}
 };
 
",426,35
"This is a minimal amount of #ifdef's to make stlport work.

Minimal, in the sense that this will only allow flatbuffers.h +
generated code to work. Everything else (tests, parsing, reflection
etc.) may still not compile with stlport.

Functionality has been reduced, some utility functions are not
available.

Tested: on Linux (no stlport), Android (stlport).

Change-Id: I3f8b6a88258c07d78964dd455fb9f99f65266301"," uint8_t *ResizeAnyVector(const reflection::Schema &schema, uoffset_t newsize,
 uoffset_t elem_size, std::vector<uint8_t> *flatbuf,
 const reflection::Object *root_table = nullptr);
 
+#ifndef FLATBUFFERS_CPP98_STL
 template <typename T>
 void ResizeVector(const reflection::Schema &schema, uoffset_t newsize, T val,
 const Vector<T> *vec, std::vector<uint8_t> *flatbuf,
 void ResizeVector(const reflection::Schema &schema, uoffset_t newsize, T val,
 }
 }
 }
+#endif
 
 // Adds any new data (in the form of a new FlatBuffer) to an existing
 // FlatBuffer. This can be used when any of the above methods are not
",256,53
"Added missing Go generated files.

Change-Id: I9d738e84ab2e01ec117c825ade44cc865cf5f1c2"," func (rcv *StructInNestedNS) Init(buf []byte, i flatbuffers.UOffsetT) {
 }
 
 func (rcv *StructInNestedNS) A() int32 { return rcv._tab.GetInt32(rcv._tab.Pos + flatbuffers.UOffsetT(0)) }
+func (rcv *StructInNestedNS) MutateA(n int32) bool { return rcv._tab.MutateInt32(rcv._tab.Pos + flatbuffers.UOffsetT(0), n) }
+
 func (rcv *StructInNestedNS) B() int32 { return rcv._tab.GetInt32(rcv._tab.Pos + flatbuffers.UOffsetT(4)) }
+func (rcv *StructInNestedNS) MutateB(n int32) bool { return rcv._tab.MutateInt32(rcv._tab.Pos + flatbuffers.UOffsetT(4), n) }
+
 
 func CreateStructInNestedNS(builder *flatbuffers.Builder, a int32, b int32) flatbuffers.UOffsetT {
 builder.Prep(4, 8)
",21,6
"Fixed unused parameter warning.

Change-Id: I7a2576c6f366b89ef3e1f83941f90294ca7a07fd"," void MutateFlatBuffersTest(uint8_t *flatbuf, std::size_t length) {
 }
 
 // Unpack a FlatBuffer into objects.
-void ObjectFlatBuffersTest(uint8_t *flatbuf, std::size_t length) {
+void ObjectFlatBuffersTest(uint8_t *flatbuf) {
 // Turn a buffer into C++ objects.
 auto monster1 = GetMonster(flatbuf)->UnPack();
 
 int main(int /*argc*/, const char * /*argv*/[]) {
 
 MutateFlatBuffersTest(flatbuf.get(), rawbuf.length());
 
- ObjectFlatBuffersTest(flatbuf.get(), rawbuf.length());
+ ObjectFlatBuffersTest(flatbuf.get());
 
 #ifndef FLATBUFFERS_NO_FILE_TESTS
 ParseAndGenerateTextTest();
",759,99
"Added way to test two schemas for safe evolution.

Change-Id: I1dfc867e6df5932ab61dad431eb3cb02f15d04df
Tested: on Linux.
Bug: 30202327"," struct EnumDef : public Definition {
 Type underlying_type;
 };
 
+inline bool EqualByName(const Type &a, const Type &b) {
+ return a.base_type == b.base_type && a.element == b.element &&
+ (a.struct_def == b.struct_def ||
+ a.struct_def->name == b.struct_def->name) &&
+ (a.enum_def == b.enum_def ||
+ a.enum_def->name == b.enum_def->name);
+}
+
 struct RPCCall {
 std::string name;
 SymbolTable<Value> attributes;
 class Parser : public ParserState {
 // See reflection/reflection.fbs
 void Serialize();
 
+ // Checks that the schema represented by this parser is a safe evolution
+ // of the schema provided. Returns non-empty error on any problems.
+ std::string ConformTo(const Parser &base);
+
 FLATBUFFERS_CHECKED_ERROR CheckBitsFit(int64_t val, size_t bits);
 
 private:
",434,41
Fixed conversion warning in generated code.," class CppGenerator : public BaseGenerator {
 switch (field.value.type.base_type) {
 case BASE_TYPE_VECTOR: {
 code += prefix;
- code += ""{ for (size_t _i = 0; _i < _e->size(); _i++) { "";
+ code += ""{ for (flatbuffers::uoffset_t _i = 0;"";
+ code += "" _i < _e->size(); _i++) { "";
 code += dest + "".push_back("";
 std::string indexing = ""_e->Get(_i)"";
 if (field.value.type.element == BASE_TYPE_BOOL)
",1084,255
"Adding missing generated code from recent commits.

Also updated generated_code.sh to prevent this from happening in
the future.

Change-Id: Ib282e9b6c762a79d4b4e09bee06b14781cd2a4c1"," inline std::unique_ptr<MonsterT> Monster::UnPack() const {
 { auto _e = mana(); _o->mana = _e; };
 { auto _e = hp(); _o->hp = _e; };
 { auto _e = name(); if (_e) _o->name = _e->str(); };
- { auto _e = inventory(); if (_e) { for (size_t _i = 0; _i < _e->size(); _i++) { _o->inventory.push_back(_e->Get(_i)); } } };
+ { auto _e = inventory(); if (_e) { for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->inventory.push_back(_e->Get(_i)); } } };
 { auto _e = color(); _o->color = _e; };
- { auto _e = weapons(); if (_e) { for (size_t _i = 0; _i < _e->size(); _i++) { _o->weapons.push_back(_e->Get(_i)->UnPack()); } } };
+ { auto _e = weapons(); if (_e) { for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->weapons.push_back(_e->Get(_i)->UnPack()); } } };
 { auto _e = equipped_type(); _o->equipped.type = _e; };
 { auto _e = equipped(); if (_e) _o->equipped.table = EquipmentUnion::UnPack(_e, equipped_type()); };
 return std::unique_ptr<MonsterT>(_o);
",292,114
"Fixed reflection.h not modifying certain table configurations.

It would write 64bits offsets instead of 32bit ones, and update
the vtable pointer before the fields were processed.

Change-Id: I0c0fa942bbd3b42839294f5653ba8fa048612624
Tested: on Linux."," public:
 void MutateOffset(uoffset_t i, const uint8_t *val) {
 assert(i < size());
 assert(sizeof(T) == sizeof(uoffset_t));
- WriteScalar(data() + i, val - (Data() + i * sizeof(uoffset_t)));
+ WriteScalar(data() + i,
+ static_cast<uoffset_t>(val - (Data() + i * sizeof(uoffset_t))));
 }
 
 // Get a mutable pointer to tables/strings inside this vector.
 class Table {
 bool SetPointer(voffset_t field, const uint8_t *val) {
 auto field_offset = GetOptionalFieldOffset(field);
 if (!field_offset) return false;
- WriteScalar(data_ + field_offset, val - (data_ + field_offset));
+ WriteScalar(data_ + field_offset,
+ static_cast<uoffset_t>(val - (data_ + field_offset)));
 return true;
 }
 
",894,258
chore(generate-code): Generate the JS code after mutation has been added.," NamespaceA.TableInFirstNS.prototype.fooEnum = function() {
 return offset ? /** @type {NamespaceA.NamespaceB.EnumInNestedNS} */ (this.bb.readInt8(this.bb_pos + offset)) : NamespaceA.NamespaceB.EnumInNestedNS.A;
 };
 
+/**
+ * @param {NamespaceA.NamespaceB.EnumInNestedNS} value
+ * @returns {boolean}
+ */
+NamespaceA.TableInFirstNS.prototype.mutate_foo_enum = function(value) {
+ var offset = this.bb.__offset(this.bb_pos, 6)
+
+ if (offset === 0) {
+ return false;
+ }
+
+ this.bb.writeInt8(this.bb_pos + offset, value);
+ return true;
+}
+
 /**
 * @param {NamespaceA.NamespaceB.StructInNestedNS=} obj
 * @returns {NamespaceA.NamespaceB.StructInNestedNS}
",112,43
"feat(test): Added mutation testing for scalar values.

This is a port of the tests found in test.cpp"," function main() {
 
 fs.writeFileSync('monsterdata_javascript_wire.mon', new Buffer(fbb.asUint8Array()));
 
- // Test it:
+ // Tests mutation first. This will verify that we did not trample any other
+ // part of the byte buffer.
+ testMutation(fbb.dataBuffer());
+ 
 testBuffer(fbb.dataBuffer());
 
 test64bit();
 function main() {
 console.log('FlatBuffers test: completed successfully');
 }
 
+function testMutation(bb) {
+ var monster = MyGame.Example.Monster.getRootAsMonster(bb);
+
+ monster.mutate_hp(120);
+ assert.strictEqual(monster.hp(), 120);
+
+ monster.mutate_hp(80);
+ assert.strictEqual(monster.hp(), 80);
+
+ var manaRes = monster.mutate_mana(10);
+ assert.strictEqual(manaRes, false); // Field was NOT present, because default value.
+
+ // TODO: There is not the availability to mutate structs or vectors.
+}
+
 function testBuffer(bb) {
 assert.ok(MyGame.Example.Monster.bufferHasIdentifier(bb));
 
",253,43
Use fully qualified names of structs in UnPack," class CppGenerator : public BaseGenerator {
 if (invector) {
 return ""*"" + val;
 } else {
- return ""std::unique_ptr<"" + type.struct_def->name +
- "">(new "" + type.struct_def->name + ""(*"" + val + ""))"";
+ return ""std::unique_ptr<"" +
+ WrapInNameSpace (*type.struct_def) +
+ "">(new "" +
+ WrapInNameSpace (*type.struct_def) + ""(*"" + val + ""))"";
 }
 } else {
 return val + ""->UnPack()"";
",1086,255
"Added backwards compatible --no-union-value-namespacing

Change-Id: Ia78dd3b0f213e9ffa49dcec699dcbb21fe6517da
Tested: on Linux."," struct IDLOptions {
 bool generate_name_strings;
 bool escape_proto_identifiers;
 bool generate_object_based_api;
+ bool union_value_namespacing;
 
 // Possible options for the more general generator below.
 enum Language { kJava, kCSharp, kGo, kMAX };
 struct IDLOptions {
 generate_name_strings(false),
 escape_proto_identifiers(false),
 generate_object_based_api(false),
+ union_value_namespacing(true),
 lang(IDLOptions::kJava) {}
 };
 
",436,41
Validate UTF-8 by default when parsing IDL. Support Unicode values > U+FFFF in parse," struct IDLOptions {
 bool escape_proto_identifiers;
 bool generate_object_based_api;
 bool union_value_namespacing;
+ bool allow_non_utf8;
 
 // Possible options for the more general generator below.
 enum Language { kJava, kCSharp, kGo, kMAX };
 struct IDLOptions {
 escape_proto_identifiers(false),
 generate_object_based_api(false),
 union_value_namespacing(true),
+ allow_non_utf8(false),
 lang(IDLOptions::kJava) {}
 };
 
",438,41
"Make most of the Go code comply with gofmt (except enums).

Enums are not fixed because depending on they have comments or not they
will be aligned alogn the asssignment character."," package Example2
 import (
 flatbuffers ""github.com/google/flatbuffers/go""
 )
+
 type Monster struct {
 _tab flatbuffers.Table
 }
 type Monster struct {
 func GetRootAsMonster(buf []byte, offset flatbuffers.UOffsetT) *Monster {
 n := flatbuffers.GetUOffsetT(buf[offset:])
 x := &Monster{}
-x.Init(buf, n + offset)
+x.Init(buf, n+offset)
 return x
 }
 
 func (rcv *Monster) Init(buf []byte, i flatbuffers.UOffsetT) {
 rcv._tab.Pos = i
 }
 
-func MonsterStart(builder *flatbuffers.Builder) { builder.StartObject(0) }
-func MonsterEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT { return builder.EndObject() }
+func MonsterStart(builder *flatbuffers.Builder) {
+builder.StartObject(0)
+}
+func MonsterEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
+return builder.EndObject()
+}
",23,4
"Fixed incorrect generated code on convenient vector constructors.

Change-Id: Ib283eade157a436e0f3ca0e68d74e7dc6c51c65b"," class CppGenerator : public BaseGenerator {
 auto &field = **it;
 if (!field.deprecated) {
 if (field.value.type.base_type == BASE_TYPE_STRING) {
- code += "", "" + field.name + "" ? 0 : "";
- code += ""_fbb.CreateString("" + field.name + "")"";
+ code += "", "" + field.name + "" ? "";
+ code += ""_fbb.CreateString("" + field.name + "") : 0"";
 } else if (field.value.type.base_type == BASE_TYPE_VECTOR) {
- code += "", "" + field.name + "" ? 0 : "";
+ code += "", "" + field.name + "" ? "";
 code += ""_fbb.CreateVector<"";
 code += GenTypeWire(field.value.type.VectorType(), """", false);
- code += "">(*"" + field.name + "")"";
- } else
+ code += "">(*"" + field.name + "") : 0"";
+ } else {
 code += "", "" + field.name;
+ }
 }
 }
 code += "");\n}\n\n"";
",1087,255
"Added union namespacing test case.

Change-Id: I9a4f90889c311c454a9c19e78c7db3c79800b44e
Tested: on Linux."," void ParseUnionTest() {
 ""table V { X:U; }""
 ""root_type V;""
 ""{ X:{ A:1 }, X_type: T }""), true);
+ // Unions must be parsable with prefixed namespace.
+ flatbuffers::Parser parser2;
+ TEST_EQ(parser2.Parse(""namespace N; table A {} namespace; union U { N.A }""
+ ""table B { e:U; } root_type B;""
+ ""{ e_type: N_A, e: {} }""), true);
 }
 
 void ConformTest() {
",869,102
"Clarified in the docs how to get to the serialized bytes.

This was a frequent source of confusion, since in all implementations
the data doesn't start at offset 0 in the buffer.

Change-Id: I045966e65928e9acd9def84e215914ecb5510653"," flatbuffers.Builder.prototype.dataBuffer = function() {
 };
 
 /**
- * Get the ByteBuffer representing the FlatBuffer. Only call this after you've
- * called finish(). The actual data starts at the ByteBuffer's current position,
- * not necessarily at 0.
+ * Get the bytes representing the FlatBuffer. Only call this after you've
+ * called finish().
 *
 * @returns {Uint8Array}
 */
",495,136
"Added ""Direct"" suffix to vector/string object creation functions.

They were overloaded, but also had default arguments, so would
become ambiguous when used with few arguments.

Change-Id: Ifac7f3ea3a6391d971dfeda8e33129c8c38d6f12
Tested: on Linux."," inline flatbuffers::Offset<Monster> CreateMonster(flatbuffers::FlatBufferBuilder
 return builder_.Finish();
 }
 
-inline flatbuffers::Offset<Monster> CreateMonster(flatbuffers::FlatBufferBuilder &_fbb,
+inline flatbuffers::Offset<Monster> CreateMonsterDirect(flatbuffers::FlatBufferBuilder &_fbb,
 const Vec3 *pos = 0,
 int16_t mana = 150,
 int16_t hp = 100,
 inline flatbuffers::Offset<Weapon> CreateWeapon(flatbuffers::FlatBufferBuilder &
 return builder_.Finish();
 }
 
-inline flatbuffers::Offset<Weapon> CreateWeapon(flatbuffers::FlatBufferBuilder &_fbb,
+inline flatbuffers::Offset<Weapon> CreateWeaponDirect(flatbuffers::FlatBufferBuilder &_fbb,
 const char *name = nullptr,
 int16_t damage = 0) {
 return CreateWeapon(_fbb, name ? _fbb.CreateString(name) : 0, damage);
",292,114
"1.4 prep fixes

Change-Id: I001ad8dd5f95e6e5ad43daf956663218d19f5c96","
 #include ""flatbuffers/util.h""
 #include <limits>
 
-#define FLATC_VERSION ""1.3.0 ("" __DATE__ "")""
+#define FLATC_VERSION ""1.4.0 ("" __DATE__ "")""
 
 static void Error(const std::string &err, bool usage = false,
 bool show_exe_name = true);
",313,70
"Allow GenerateText() to indicate failure to encode flatbuffer to JSON (i.e., non-UTF-8 string data)"," extern void GenComment(const std::vector<std::string> &dc,
 // if it is less than 0, no linefeeds will be generated either.
 // See idl_gen_text.cpp.
 // strict_json adds ""quotes"" around field names if true.
-extern void GenerateText(const Parser &parser,
+// If the flatbuffer cannot be encoded in JSON (e.g., it contains non-UTF-8
+// byte arrays in String values), returns false.
+extern bool GenerateText(const Parser &parser,
 const void *flatbuffer,
 std::string *text);
 extern bool GenerateTextFile(const Parser &parser,
",438,41
"Remove invalid vector item heap alloc

Fixes #3986"," static void GetMemberOfVectorOfStruct(const StructDef &struct_def,
 if (!(vectortype.struct_def->fixed)) {
 code += ""\t\tx = rcv._tab.Indirect(x)\n"";
 }
- code += ""\t\tif obj == nil {\n"";
- code += ""\t\t\tobj = new("" + TypeName(field) + "")\n"";
- code += ""\t\t}\n"";
 code += ""\t\tobj.Init(rcv._tab.Bytes, x)\n"";
 code += ""\t\treturn true\n\t}\n"";
 code += ""\treturn false\n"";
",600,102
"Improve `LookupByKey` , update docs"," public class FlatBufferBuilder {
 /**
 * Create a vector of sorted by the key tables.
 *
- * @param obj Instance of the table class.
+ * @param obj Instance of the table subclass.
 * @param offsets Offsets of the tables.
 * @return Returns offset of the sorted vector.
 */
- public <T extends Table> int createSortedTableVector(T obj, int[] offsets) {
+ public <T extends Table> int createSortedVectorOfTables(T obj, int[] offsets) {
 obj.sortTables(offsets, bb);
 return createVectorOfTables(offsets);
 }
",280,101
"Add a generic way to deserialize a flatbuffer in Go.

Similar to what protobufs does with its `Message` interface, introduce here such interface and create a generic `GetRootAs` method to deserialize a flatbuffer.","
+package flatbuffers
+
+// FlatBuffer is the interface that represents a flatbuffer.
+type FlatBuffer interface {
+Table() Table
+Init(buf []byte, i UOffsetT)
+}
+
+// GetRootAs is a generic helper to initialize a FlatBuffer with the provided buffer bytes and its data offset.
+func GetRootAs(buf []byte, offset UOffsetT, fb FlatBuffer) {
+n := GetUOffsetT(buf[offset:])
+fb.Init(buf, n+offset)
+}
",9,1
Remove Struct::GetPointer() useless method," class Struct FLATBUFFERS_FINAL_CLASS {
 return ReadScalar<T>(&data_[o]);
 }
 
- template<typename T> T GetPointer(uoffset_t o) const {
- auto p = &data_[o];
- return reinterpret_cast<T>(p + ReadScalar<uoffset_t>(p));
- }
-
 template<typename T> T GetStruct(uoffset_t o) const {
 return reinterpret_cast<T>(&data_[o]);
 }
",893,258
"Fixed ""unknown command-line argument"" output format.

Change-Id: Idd49bc61118c29d6d7364d2cd54a6f7932917570"," int main(int argc, const char *argv[]) {
 goto found;
 }
 }
- Error(""unknown commandline argument"" + arg, true);
+ Error(""unknown commandline argument: "" + arg, true);
 found:;
 }
 } else {
",313,70
"Fix lookupByKey, improve compareStrings"," std::string GenLookupKeyGetter(flatbuffers::FieldDef *key_field) {
 if (key_field->value.type.base_type == BASE_TYPE_STRING) {
 key_getter += ""comp = "" + FunctionStart('C') + ""ompareStrings("";
 key_getter += GenOffsetGetter(key_field);
- key_getter += "", key, bb);\n"";
+ key_getter += "", byteKey, bb);\n"";
 }
 else {
 auto get_val = GenGetter(key_field->value.type) +
 void GenStruct(StructDef &struct_def, std::string *code_ptr) {
 code += ""ookupByKey("" + GenVectorOffsetType();
 code += "" vectorOffset, "" + GenTypeGet(key_field->value.type);
 code += "" key, ByteBuffer bb) {\n"";
+ code += "" byte[] byteKey = "";
+ if (lang_.language == IDLOptions::kJava)
+ code += ""key.getBytes(StandardCharsets.UTF_8);\n"";
+ else
+ code += ""System.Text.Encoding.UTF8.GetBytes(key);\n"";
 code += "" int vectorLocation = "" + GenByteBufferLength(""bb"");
 code += "" - vectorOffset.Value;\n int span = "";
 code += ""bb."" + FunctionStart('G') + ""etInt(vectorLocation), "";
",1151,266
Correct idl_gen_general," void GenStruct(StructDef &struct_def, std::string *code_ptr) {
 code += ""ookupByKey("" + GenVectorOffsetType();
 code += "" vectorOffset, "" + GenTypeGet(key_field->value.type);
 code += "" key, ByteBuffer bb) {\n"";
- code += "" byte[] byteKey = "";
- if (lang_.language == IDLOptions::kJava)
- code += ""key.getBytes(StandardCharsets.UTF_8);\n"";
- else
- code += ""System.Text.Encoding.UTF8.GetBytes(key);\n"";
+ if (key_field->value.type.base_type == BASE_TYPE_STRING) {
+ code += "" byte[] byteKey = "";
+ if (lang_.language == IDLOptions::kJava)
+ code += ""key.getBytes(StandardCharsets.UTF_8);\n"";
+ else
+ code += ""System.Text.Encoding.UTF8.GetBytes(key);\n"";
+ }
 code += "" int vectorLocation = "" + GenByteBufferLength(""bb"");
 code += "" - vectorOffset.Value;\n int span = "";
 code += ""bb."" + FunctionStart('G') + ""etInt(vectorLocation), "";
",1153,267
Update idl_gen_general.cpp," std::string GenLookupKeyGetter(flatbuffers::FieldDef *key_field) {
 auto get_val = GenGetter(key_field->value.type) +
 ""("" + GenOffsetGetter(key_field) + "")"";
 if (lang_.language == IDLOptions::kCSharp) {
- key_getter += ""comp = "" + get_val + "".CompateTo(key);\n"";
+ key_getter += ""comp = "" + get_val + "".CompareTo(key);\n"";
 }
 else {
 key_getter += GenTypeGet(key_field->value.type) + "" val = "";
 void GenStruct(StructDef &struct_def, std::string *code_ptr) {
 code += ""middle, start = 0, comp, tableOffset; \n"";
 code += "" vectorLocation += 4;\n"";
 code += "" while (span != 0) {\n"";
- code += "" int middle = span / 2;\n"";
+ code += "" middle = span / 2;\n"";
 code += GenLookupKeyGetter(key_field);
 code += "" if (comp > 0) span = middle;\n"";
 code += "" else if (comp < 0) {\n"";
",1153,267
"Fixed compile error in LookupByKey fix.

Change-Id: Ice94f09197235cf71b41a22d0767bd7b119284e1"," void GenStruct(StructDef &struct_def, std::string *code_ptr) {
 code += ""System.Text.Encoding.UTF8.GetBytes(key);\n"";
 code += "" int vectorLocation = "" + GenByteBufferLength(""bb"");
 code += "" - vectorOffset"";
- if (lang_.language == IDLOptions::kCsharp) code += "".Value"";
+ if (lang_.language == IDLOptions::kCSharp) code += "".Value"";
 code += "";\n int span = "";
 code += ""bb."" + FunctionStart('G') + ""etInt(vectorLocation);\n"";
 code += "" int start = 0;\n"";
",1151,267
Remove languages check," void GenStruct(StructDef &struct_def, std::string *code_ptr) {
 code += ""); }\n"";
 }
 }
- if (struct_def.has_key && (lang_.language == IDLOptions::kJava ||
- lang_.language == IDLOptions::kCSharp)) {
+ if (struct_def.has_key) {
 if (lang_.language == IDLOptions::kJava) {
 code += ""\n @Override\n protected int keysCompare("";
 code += ""Integer o1, Integer o2, ByteBuffer _bb) {"";
",1153,268
Switched C# accessors from classes to structs," namespace FlatBuffers
 PutInt(_vectorNumElems);
 return new VectorOffset(Offset);
 }
-
+
 /// <summary>
 /// Creates a vector of tables.
 /// </summary>
 /// <param name=""offsets"">Offsets of the tables.</param>
- public VectorOffset CreateVectorOfTables<T>(Offset<T>[] offsets) where T : class
+ public VectorOffset CreateVectorOfTables<T>(Offset<T>[] offsets) where T : struct
 {
 NotNested();
 StartVector(sizeof(int), offsets.Length, sizeof(int));
",301,103
"Fix Windows warnings.

Cmake issued a warning when the variable is in quotation marks
in an if statement.

Visual Studio upgrades constants to int and issues a truncation
warning, so inserted a cast.

Change-Id: I60cdcb5c2565cd5e97f80b9c2ff1e6abc32b1deb
Tested: Builds without warning on VS2015."," static bool EscapeString(const String &s, std::string *_text, const IDLOptions&
 } else if (ucc <= 0x10FFFF) {
 // Encode Unicode SMP values to a surrogate pair using two \u escapes.
 uint32_t base = ucc - 0x10000;
- uint16_t highSurrogate = (base >> 10) + 0xD800;
- uint16_t lowSurrogate = (base & 0x03FF) + 0xDC00;
+ auto high_surrogate = (base >> 10) + 0xD800;
+ auto low_surrogate = (base & 0x03FF) + 0xDC00;
 text += ""\\u"";
- text += IntToStringHex(highSurrogate, 4);
+ text += IntToStringHex(high_surrogate, 4);
 text += ""\\u"";
- text += IntToStringHex(lowSurrogate, 4);
+ text += IntToStringHex(low_surrogate, 4);
 }
 // Skip past characters recognized.
 i = static_cast<uoffset_t>(utf8 - s.c_str() - 1);
",280,68
Return error when full string cannot be parsed into int," inline std::string IntToStringHex(int i, int xdigits) {
 }
 
 // Portable implementation of strtoll().
-inline int64_t StringToInt(const char *str, int base = 10) {
+inline int64_t StringToInt(const char *str, char **endptr = nullptr, int base = 10) {
 #ifdef _MSC_VER
- return _strtoi64(str, nullptr, base);
+ return _strtoi64(str, endptr, base);
 #else
- return strtoll(str, nullptr, base);
+ return strtoll(str, endptr, base);
 #endif
 }
 
 // Portable implementation of strtoull().
-inline int64_t StringToUInt(const char *str, int base = 10) {
+inline int64_t StringToUInt(const char *str, char **endptr = nullptr, int base = 10) {
 #ifdef _MSC_VER
- return _strtoui64(str, nullptr, base);
+ return _strtoui64(str, endptr, base);
 #else
- return strtoull(str, nullptr, base);
+ return strtoull(str, endptr, base);
 #endif
 }
 
",201,62
Allow access to underlying ByteBuffer," void GenStruct(StructDef &struct_def, std::string *code_ptr) {
 code += "" private "";
 code += struct_def.fixed ? ""Struct"" : ""Table"";
 code += "" __p;\n"";
+
+ if (lang_.language == IDLOptions::kCSharp) {
+ code += "" public ByteBuffer ByteBuffer { get { return __p.bb; } }\n"";
+ }
+
 } else {
 code += lang_.inheritance_marker;
 code += struct_def.fixed ? ""Struct"" : ""Table"";
",1237,281
Remove extra semicolon," struct VectorIterator
 
 public:
 VectorIterator(const uint8_t *data, uoffset_t i) :
- data_(data + IndirectHelper<T>::element_stride * i) {};
+ data_(data + IndirectHelper<T>::element_stride * i) {}
 VectorIterator(const VectorIterator &other) : data_(other.data_) {}
 #ifndef FLATBUFFERS_CPP98_STL
 VectorIterator(VectorIterator &&other) : data_(std::move(other.data_)) {}
",893,258
"Generate type traits for unions to map a type to the corresponding u (#4032)

* Generate type traits for unions to map a type to the corresponding union enum value.

* Fixed break with union enum type traits when type is in a namespace.

* Fixed spacing and variable names in type traits generation to match style guidelines.

* Fixed spacing in type traits generation to match style guidelines.

* Regenerated test schema header."," class CppGenerator : public BaseGenerator {
 }
 code += ""]; }\n\n"";
 }
-
+ 
+ // Generate type traits for unions to map from a type to union enum value.
+ if (enum_def.is_union) {
+ for (auto it = enum_def.vals.vec.begin();
+ it != enum_def.vals.vec.end();
+ ++it) {
+ auto &ev = **it;
+ if (it == enum_def.vals.vec.begin()) {
+ code += ""template<typename T> struct "" + enum_def.name + ""Traits {\n"";
+ }
+ else {
+ code += ""template<> struct "" + enum_def.name + ""Traits<"" + WrapInNameSpace(*ev.struct_def) + ""> {\n"";
+ }
+ code += "" static const "" + enum_def.name + "" enum_value = "" + GenEnumValDecl(enum_def, ev.name, parser_.opts) + "";\n"";
+ code += ""};\n\n"";
+ }
+ }
+ 
 if (enum_def.is_union) {
 code += UnionVerifySignature(enum_def) + "";\n\n"";
 }
",1102,258
"flatc java generator: namespace_test2.fbs is missing namespace prefix for referToA2() return type (#4040)

* Fix flatc generating incorrect java/c# code for namespace_test2.fbs. In code for TableInC, method referToA2() returned type SecondTableInA instead of NamespaceA.SecondTableInA.

* Updated generated code.

* Fixed indendation."," public struct Monster : IFlatbufferObject
 
 
 public static void StartMonster(FlatBufferBuilder builder) { builder.StartObject(0); }
- public static Offset<MyGame.Example2.Monster> EndMonster(FlatBufferBuilder builder) {
+ public static Offset<Monster> EndMonster(FlatBufferBuilder builder) {
 int o = builder.EndObject();
- return new Offset<MyGame.Example2.Monster>(o);
+ return new Offset<Monster>(o);
 }
 };
 
",19,6
"External references for the object API thru a resolver function.

This allows hashed string fields to be used for lookup of any
C++ objects, a pointer to which are then stored in the object
besides the original hash for easy access.

Change-Id: I2247a13c349b905f1c54660becde2c818ad23e97
Tested: on Linux.
Bug: 30204449"," class Parser : public ParserState {
 known_attributes_[""csharp_partial""] = true;
 known_attributes_[""streaming""] = true;
 known_attributes_[""idempotent""] = true;
+ known_attributes_[""cpp_type""] = true;
 }
 
 ~Parser() {
",439,41
"Fixed line numbers being off in multi-line comments.

Change-Id: I4c27892c249527980d8f52a2cca801dace70289f"," CheckedError Parser::Next() {
 cursor_++;
 // TODO: make nested.
 while (*cursor_ != '*' || cursor_[1] != '/') {
+ if (*cursor_ == '\n') line_++;
 if (!*cursor_) return Error(""end of file in comment"");
 cursor_++;
 }
",1812,554
"Added missing generated code files.

Change-Id: Ifb977411b65f8721cf9db891d7a62798bd593c0c"," inline const char **EnumNamesEquipment() {
 
 inline const char *EnumNameEquipment(Equipment e) { return EnumNamesEquipment()[static_cast<int>(e)]; }
 
+template<typename T> struct EquipmentTraits {
+ static const Equipment enum_value = Equipment_NONE;
+};
+
+template<> struct EquipmentTraits<Weapon> {
+ static const Equipment enum_value = Equipment_Weapon;
+};
+
 inline bool VerifyEquipment(flatbuffers::Verifier &verifier, const void *union_obj, Equipment type);
 
 MANUALLY_ALIGNED_STRUCT(4) Vec3 FLATBUFFERS_FINAL_CLASS {
",298,114
"Fix lambda compilation error in VS.

Change-Id: I814008b6eeffec9bd4b8810e4b29db9ea6218bb8"," void ObjectFlatBuffersTest(uint8_t *flatbuf) {
 // and such.
 auto resolver = flatbuffers::resolver_function_t([](void **pointer_adr,
 flatbuffers::hash_value_t hash) {
- return nullptr; // Fail the lookup.
+ // Don't actually do anything, leave variable null.
 });
 auto rehasher = flatbuffers::rehasher_function_t([](void *pointer) {
 return 0;
",915,104
"Fixed inconsistent use of namespace directory prefixing.

Change-Id: I2cab7a1f68b8e643c1057e0a366572421a94ed41
Tested: on Linux."," std::string GeneralMakeRule(const Parser &parser, const std::string &path,
 auto &enum_def = **it;
 if (make_rule != """") make_rule += "" "";
 std::string directory =
- BaseGenerator::NamespaceDir(parser, path, *enum_def.defined_namespace) +
- kPathSeparator;
+ BaseGenerator::NamespaceDir(parser, path, *enum_def.defined_namespace);
 make_rule += directory + enum_def.name + lang.file_extension;
 }
 
 std::string GeneralMakeRule(const Parser &parser, const std::string &path,
 auto &struct_def = **it;
 if (make_rule != """") make_rule += "" "";
 std::string directory =
- BaseGenerator::NamespaceDir(parser, path, *struct_def.defined_namespace) +
- kPathSeparator;
+ BaseGenerator::NamespaceDir(parser, path,
+ *struct_def.defined_namespace);
 make_rule += directory + struct_def.name + lang.file_extension;
 }
 
",1243,283
"Allow other pointer types than unique_ptr for object API.

Change-Id: I945890ce667a2f5a6c0495e78fd5326ed33b9914
Tested: on Linux.
Bug: 30135763"," struct IDLOptions {
 bool generate_name_strings;
 bool escape_proto_identifiers;
 bool generate_object_based_api;
+ std::string cpp_object_api_pointer_type;
 bool union_value_namespacing;
 bool allow_non_utf8;
 
 struct IDLOptions {
 generate_name_strings(false),
 escape_proto_identifiers(false),
 generate_object_based_api(false),
+ cpp_object_api_pointer_type(""std::unique_ptr""),
 union_value_namespacing(true),
 allow_non_utf8(false),
 lang(IDLOptions::kJava) {}
 class Parser : public ParserState {
 known_attributes_[""streaming""] = true;
 known_attributes_[""idempotent""] = true;
 known_attributes_[""cpp_type""] = true;
+ known_attributes_[""cpp_ptr_type""] = true;
 }
 
 ~Parser() {
",442,41
Add missing include (#4052),"
 #ifndef GRPC_INTERNAL_COMPILER_SCHEMA_INTERFACE_H
 #define GRPC_INTERNAL_COMPILER_SCHEMA_INTERFACE_H
 
- #include <memory>
- #include <vector>
+#include <map>
+#include <memory>
+#include <vector>
 
 #ifndef GRPC_CUSTOM_STRING
 #include <string>
",46,4
"Fixed broken traits codegen for --scoped-enums.

Change-Id: I5f538d12ea37d11d2e239ddde32eefcdd91e347b
Tested: on Linux."," class CppGenerator : public BaseGenerator {
 }
 
 static std::string GenEnumValDecl(const EnumDef &enum_def,
- const std::string &enum_val,
- const IDLOptions &opts) {
+ const std::string &enum_val,
+ const IDLOptions &opts) {
 return opts.prefixed_enums ? enum_def.name + ""_"" + enum_val : enum_val;
 }
 
 class CppGenerator : public BaseGenerator {
 code += ""template<typename T> struct "" + enum_def.name + ""Traits {\n"";
 }
 else {
- code += ""template<> struct "" + enum_def.name + ""Traits<"" + WrapInNameSpace(*ev.struct_def) + ""> {\n"";
+ code += ""template<> struct "" + enum_def.name + ""Traits<"" +
+ WrapInNameSpace(*ev.struct_def) + ""> {\n"";
 }
- code += "" static const "" + enum_def.name + "" enum_value = "" + GenEnumValDecl(enum_def, ev.name, parser_.opts) + "";\n"";
+ code += "" static const "" + enum_def.name + "" enum_value = "" +
+ GetEnumValUse(enum_def, ev, parser_.opts) + "";\n"";
 code += ""};\n\n"";
 }
 }
",1160,273
"Fixed unused variable warnings, and made sure they are on.

Tested on Linux.

Change-Id: Ie18d6857f9ae8b1c3953a116203b4a8bb70a2ede"," void ObjectFlatBuffersTest(uint8_t *flatbuf) {
 // and such.
 auto resolver = flatbuffers::resolver_function_t([](void **pointer_adr,
 flatbuffers::hash_value_t hash) {
+ (void)pointer_adr;
+ (void)hash;
 // Don't actually do anything, leave variable null.
 });
 auto rehasher = flatbuffers::rehasher_function_t([](void *pointer) {
+ (void)pointer;
 return 0;
 });
 
",918,104
"Fixed lambda return value error on VS2010.

Change-Id: I6d0e8469bfa5b4c8a3f1cb119e186f4cf62c76ae"," void ObjectFlatBuffersTest(uint8_t *flatbuf) {
 // Optional: we can specify resolver and rehasher functions to turn hashed
 // strings into object pointers and back, to implement remote references
 // and such.
- auto resolver = flatbuffers::resolver_function_t([](void **pointer_adr,
- flatbuffers::hash_value_t hash) {
+ auto resolver = flatbuffers::resolver_function_t(
+ [](void **pointer_adr, flatbuffers::hash_value_t hash) {
 (void)pointer_adr;
 (void)hash;
 // Don't actually do anything, leave variable null.
 });
- auto rehasher = flatbuffers::rehasher_function_t([](void *pointer) {
+ auto rehasher = flatbuffers::rehasher_function_t(
+ [](void *pointer) -> flatbuffers::hash_value_t {
 (void)pointer;
 return 0;
 });
",919,104
"Added functionality to obtain a buffer pointer from a root.

Change-Id: Ia63e41d0304e8668ea4ce09a4c31dd999eb96994
Tested: on Linux.
Bug: 32218623"," CheckedError Parser::ParseDecl() {
 auto align = static_cast<size_t>(atoi(force_align->constant.c_str()));
 if (force_align->type.base_type != BASE_TYPE_INT ||
 align < struct_def->minalign ||
- align > 16 ||
+ align > FLATBUFFERS_MAX_ALIGNMENT ||
 align & (align - 1))
 return Error(""force_align must be a power of two integer ranging from the""
- ""struct\'s natural alignment to 16"");
+ ""struct\'s natural alignment to "" +
+ NumToString(FLATBUFFERS_MAX_ALIGNMENT));
 struct_def->minalign = align;
 }
 struct_def->PadLastField(struct_def->minalign);
",1816,554
"Fixed STLPort error for missing vector::data()

Change-Id: I06fb61edf018adf0f26a81de4596b4972226e466
Tested: on Android.
Bug: 30263829"," inline size_t PaddingBytes(size_t buf_size, size_t scalar_size) {
 template <typename T> const T* data(const std::vector<T> &v) {
 return v.empty() ? nullptr : &v.front();
 }
+template <typename T> T* data(std::vector<T> &v) {
+ return v.empty() ? nullptr : &v.front();
+}
+
 /// @endcond
 
 /// @addtogroup flatbuffers_cpp_api
 FLATBUFFERS_FINAL_CLASS
 /// where the vector is stored.
 template<typename T> Offset<Vector<Offset<T>>> CreateVectorOfSortedTables(
 std::vector<Offset<T>> *v) {
- return CreateVectorOfSortedTables(v->data(), v->size());
+ return CreateVectorOfSortedTables(data(*v), v->size());
 }
 
 /// @brief Specialized version of `CreateVector` for non-copying use cases.
",951,273
"Fixed javascript helper for typed arrays of scalars not taking into (#4068)

account underlying buffer's byte offset."," void GenStruct(const Parser &parser, StructDef &struct_def, std::string *code_pt
 code += object_name + "".prototype."" + MakeCamel(field.name, false);
 code += ""Array = function() {\n"" + offset_prefix;
 code += ""new "" + GenType(vectorType) + ""Array(this.bb.bytes().buffer, ""
- ""this.bb.__vector(this.bb_pos + offset), ""
+ ""this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), ""
 ""this.bb.__vector_len(this.bb_pos + offset)) : null;\n};\n\n"";
 }
 }
",618,150
"Fixes to support GCC 4.4.7

Fixed generation of a trailing comma and removed unnecessary use of a lambda.

Change-Id: I9993f6eb83e2ebc36fc40295a2059c340c1fbe03
Tested: on Linux."," enum BaseType {
 String = 13,
 Vector = 14,
 Obj = 15,
- Union = 16,
+ Union = 16
 };
 
 inline const char **EnumNamesBaseType() {
",504,203
"chore(lint) (#4079)

* chore(lint)

I accidentally let 2 pieces of lint in with my generated code.

* fix(generate-code): I did not generate all the required code for tests."," void GenStruct(const Parser &parser, StructDef &struct_def, std::string *code_pt
 ""@returns {boolean}"");
 
 code += object_name + "".prototype.mutate_"" + field.name + "" = function(value) {\n"";
- code += "" var offset = this.bb.__offset(this.bb_pos, "" + NumToString(field.value.offset) + "")\n\n"";
+ code += "" var offset = this.bb.__offset(this.bb_pos, "" + NumToString(field.value.offset) + "");\n\n"";
 code += "" if (offset === 0) {\n"";
 code += "" return false;\n"";
 code += "" }\n\n"";
 code += "" this.bb.write"" + MakeCamel(GenType(field.value.type)) + ""(this.bb_pos + offset, value);\n"";
 code += "" return true;\n"";
- code += ""}\n\n"";
+ code += ""};\n\n"";
 }
 
 // Emit vector helpers
",618,150
Making flatbuffers JSON parsing deal with unexpected null values when unknown JSON is allowed. (#4083)," CheckedError Parser::SkipAnyJsonValue() {
 case kTokenFloatConstant:
 EXPECT(kTokenFloatConstant);
 break;
+ case kTokenNull:
+ EXPECT(kTokenNull);
+ break;
 default:
 return Error(std::string(""Unexpected token:"") + std::string(1, static_cast<char>(token_)));
 }
",1819,555
"[PHP] Use mb_detect_encoding when available (#3952)

I've faced an issue where I want to serialize UTF-8 emojis and FlatBufferBuilder::is_utf8 would return false on them.
I was not able to add the corresponding hexadecimal code because I don't understand how the whole thing works but what i've done is using the `mb_detect_encoding` function which handles correctly all supposed UTF-8 characters."," class FlatbufferBuilder
 
 protected function is_utf8($bytes)
 {
+ if (function_exists('mb_detect_encoding')) {
+ return (bool) mb_detect_encoding($bytes, 'UTF-8', true);
+ }
+ 
 $len = strlen($bytes);
 if ($len < 1) {
 /* NOTE: always return 1 when passed string is null */
",515,176
"Allows structs to be stored directly as member variables.

Introduce a ""native_inline"" attribute that can be applied on fields that are structs.
This results in NativeTable code generation that sets the struct ""inline"" rather than
storing it in a pointer.

From cl/140527470.

Change-Id: I208724f552b8b921b20923e0bf82f42cb3582416"," struct FieldDef : public Definition {
 // written in new data nor accessed in new code.
 bool required; // Field must always be present.
 bool key; // Field functions as a key for creating sorted vectors.
+ bool native_inline; // Field will be defined inline (instead of as a pointer)
+ // for native tables if field is a struct.
 size_t padding; // Bytes to always pad after this field.
 };
 
 class Parser : public ParserState {
 known_attributes_[""idempotent""] = true;
 known_attributes_[""cpp_type""] = true;
 known_attributes_[""cpp_ptr_type""] = true;
+ known_attributes_[""native_inline""] = true;
 }
 
 ~Parser() {
",444,41
"Support for Golang GRPC (Experimental) (#4082)

* support for grpc golang

* refactored grpc go generator

* added grpc-go test and refactored

* refactored idl_gen_grpc.cpp

* fixed grpc generate method name

* refactored flatc and fixed line length issue

* added codec to go lib and fixed formatting issues

* fixed spacing issues","
+package flatbuffers
+
+// FlatbuffersCodec implements gRPC-go Codec which is used to encode and decode messages.
+var Codec string = ""flatbuffers""
+
+type FlatbuffersCodec struct{}
+
+func (FlatbuffersCodec) Marshal(v interface{}) ([]byte, error) {
+return v.(*Builder).FinishedBytes(), nil
+}
+
+func (FlatbuffersCodec) Unmarshal(data []byte, v interface{}) error {
+v.(flatbuffersInit).Init(data, GetUOffsetT(data))
+return nil
+}
+
+func (FlatbuffersCodec) String() string {
+return Codec
+}
+
+type flatbuffersInit interface {
+Init(data []byte, i UOffsetT)
+}
",16,3
"Restore the ''import ""unsafe'' removed in 36daedf35fd0cc2ad0e5e24d187b25613c13660e.
This was causing build failures with tools dependent on Flatbuffers in Go.
E.g.
go/src/github.com/google/flatbuffers/go/sizes.go:50: undefined: unsafe in unsafe.Pointer","
 package flatbuffers
 
+import (
+ ""unsafe""
+)
+
 const (
 // See http://golang.org/ref/spec#Numeric_types
 
",24,1
"Fixed JS outputting helper for Int64Array.

Change-Id: I7d23fa3416feb78ea18d2c451e7b4e1d9be11bfc"," inline bool IsInteger(BaseType t) { return t >= BASE_TYPE_UTYPE &&
 t <= BASE_TYPE_ULONG; }
 inline bool IsFloat (BaseType t) { return t == BASE_TYPE_FLOAT ||
 t == BASE_TYPE_DOUBLE; }
+inline bool IsLong (BaseType t) { return t == BASE_TYPE_LONG ||
+ t == BASE_TYPE_ULONG; }
 
 extern const char *const kTypeNames[];
 extern const char kTypeSizes[];
",449,43
"Add default values (if they exist) to native tables.

From cl/142307012.

Change-Id: I54d550573f6506b92ad18e7cc90bcd8589259e52"," struct MonsterT : public flatbuffers::NativeTable {
 Color color;
 std::vector<std::unique_ptr<WeaponT>> weapons;
 EquipmentUnion equipped;
+ MonsterT()
+ : mana(150),
+ hp(100),
+ color(Color_Blue) {}
 };
 
 struct Monster FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
 struct WeaponT : public flatbuffers::NativeTable {
 typedef Weapon TableType;
 std::string name;
 int16_t damage;
+ WeaponT()
+ : damage(0) {}
 };
 
 struct Weapon FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
",342,122
"Added missing generated code from previous commits.

Change-Id: Id7053e4cb5a085a4b047c86ff1f2269329ff7f54"," struct EquipmentUnion {
 Reset();
 type = EquipmentTraits<typename T::TableType>::enum_value;
 if (type != Equipment_NONE) {
- table = new T(std::move(value));
+ table = new T(std::forward<T>(value));
 }
 }
 
",342,122
"Fixed Windows build errors.

Change-Id: I11548bfa3cfe307598eb59c56412974c349d614d"," template<> struct EquipmentTraits<Weapon> {
 };
 
 struct EquipmentUnion {
- Equipment type = Equipment_NONE;
+ Equipment type;
 
 flatbuffers::NativeTable *table = nullptr;
 EquipmentUnion() : type(Equipment_NONE), table(nullptr) {}
",342,122
"Go related style fixes.

Change-Id: Ie854ace69a21ef685e1ade5584f9d9ce4e8b41f1","
 package flatbuffers
 
-// FlatbuffersCodec implements gRPC-go Codec which is used to encode and decode messages.
-var Codec string = ""flatbuffers""
+// Codec implements gRPC-go Codec which is used to encode and decode messages.
+var Codec = ""flatbuffers""
 
 type FlatbuffersCodec struct{}
 
",16,3
"Fixed Windows compiler warning.

Change-Id: I12b31227d4545a8897f638754d6a9ccd029f177e"," bool VerifyObject(flatbuffers::Verifier &v,
 if (!table->VerifyTableStart(v))
 return false;
 
- for (size_t i = 0; i < obj.fields()->size(); i++) {
+ for (uoffset_t i = 0; i < obj.fields()->size(); i++) {
 auto field_def = obj.fields()->Get(i);
 switch (field_def->type()->base_type()) {
 case reflection::None:
",598,193
"Fixed more Windows build errors.

Change-Id: I556e1c103e8501dc144b16c8698463253de6f4fb"," template<> struct EquipmentTraits<Weapon> {
 struct EquipmentUnion {
 Equipment type;
 
- flatbuffers::NativeTable *table = nullptr;
+ flatbuffers::NativeTable *table;
 EquipmentUnion() : type(Equipment_NONE), table(nullptr) {}
 EquipmentUnion(const EquipmentUnion &);
 EquipmentUnion &operator=(const EquipmentUnion &);
",342,122
"Added helper methods to access struct through reflection. (#4120)

* Added helper methods to access struct through reflection. Also added unit test for it.

* Added a TODO comment to check for the is_struct flag."," inline Table *GetFieldT(const Table &table,
 return table.GetPointer<Table *>(field.offset());
 }
 
+// Get a field, if you know it's a struct.
+inline const Struct *GetFieldStruct(const Table &table,
+ const reflection::Field &field) {
+ // TODO: This does NOT check if the field is a table or struct, but we'd need
+ // access to the schema to check the is_struct flag.
+ assert(field.type()->base_type() == reflection::Obj);
+ return table.GetStruct<const Struct *>(field.offset());
+}
+
+// Get a structure's field, if you know it's a struct.
+inline const Struct *GetFieldStruct(const Struct &structure,
+ const reflection::Field &field) {
+ assert(field.type()->base_type() == reflection::Obj);
+ return structure.GetStruct<const Struct *>(field.offset());
+}
+
 // Raw helper functions used below: get any value in memory as a 64bit int, a
 // double or a string.
 // All scalars get static_cast to an int64_t, strings use strtoull, every other
",270,55
Fix C++ gRPC test with streaming method (#4123)," class ServiceImpl final : public MyGame::Example::MonsterStorage::Service {
 }
 virtual ::grpc::Status Retrieve(::grpc::ServerContext *context,
 const flatbuffers::BufferRef<Stat> *request,
- flatbuffers::BufferRef<Monster> *response)
+ ::grpc::ServerWriter< flatbuffers::BufferRef<Monster>>* writer)
 override {
 assert(false); // We're not actually using this RPC.
 return grpc::Status::CANCELLED;
",70,6
fix memory leak (#4126)," CheckedError Parser::DoParse(const char *source, const char **include_paths,
 source_ = cursor_ = source;
 line_ = 1;
 error_.clear();
+ field_stack_.clear();
 builder_.Clear();
 // Start with a blank namespace just in case this file doesn't have one.
 namespaces_.push_back(new Namespace());
",1820,556
"Updated version to 1.5

Change-Id: I34007829cdd3ad024df21f68bb369016d5d21131","
 #endif // !defined(FLATBUFFERS_LITTLEENDIAN)
 
 #define FLATBUFFERS_VERSION_MAJOR 1
-#define FLATBUFFERS_VERSION_MINOR 0
+#define FLATBUFFERS_VERSION_MINOR 5
 #define FLATBUFFERS_VERSION_REVISION 0
 #define FLATBUFFERS_STRING_EXPAND(X) #X
 #define FLATBUFFERS_STRING(X) FLATBUFFERS_STRING_EXPAND(X)
",974,279
"Misc idl_gen_cpp cleanup

- Update to be const-correct where possible.
- Consistently pass |code| as pointer instead of non-const-ref.
- No newlines (\n) characters in the middle of code strings.
- Use if-else if-else statements instead of nested ternary operators.
- Ensure all lines end at 80 chars.
- Make utility functions static.

From cl/143505731.

Change-Id: If0fab9ee75de5af963367a948dddf53af93f73b4"," class GeneralGenerator : public BaseGenerator {
 return SaveFile(filename.c_str(), code, false);
 }
 
- const Namespace *CurrentNameSpace() { return cur_name_space_; }
+ const Namespace *CurrentNameSpace() const { return cur_name_space_; }
 
 std::string FunctionStart(char upper) {
 return std::string() + (lang_.language == IDLOptions::kJava
",1256,289
"Re-applied reverted fix, adding missing codegen files.

Change-Id: I301d29835fb0baffd859950eb0fb3056e4f4d66b"," template<> struct EquipmentTraits<Weapon> {
 struct EquipmentUnion {
 Equipment type;
 
- flatbuffers::NativeTable *table = nullptr;
+ flatbuffers::NativeTable *table;
 EquipmentUnion() : type(Equipment_NONE), table(nullptr) {}
 EquipmentUnion(const EquipmentUnion &);
 EquipmentUnion &operator=(const EquipmentUnion &);
",364,122
"Fixed GRPC method name generation.

Change-Id: I827b7e9aee1edb77752322455f7b6fafac16fb1d
Tested: on Linux."," std::string Namespace::GetFullyQualifiedName(const std::string &name,
 }
 stream << components[i];
 }
-
- stream << ""."" << name;
+ if (name.length()) stream << ""."" << name;
 return stream.str();
 }
 
",1820,557
"Resolve Go fmt and vet warnings (#4134)

* Resolve Go fmt and vet warnings.

* Undo generated code gofmt.","
 package flatbuffers
 
 import (
- ""unsafe""
+""unsafe""
 )
 
 const (
",24,1
"Fix unused field warning in clang.

Change-Id: I71d590a1e5b2709f0e2dcf97faaebda5cb918fc7
Tested: on Linux."," MANUALLY_ALIGNED_STRUCT(2) Test FLATBUFFERS_FINAL_CLASS {
 : a_(flatbuffers::EndianScalar(_a)),
 b_(flatbuffers::EndianScalar(_b)),
 padding0__(0) {
+ (void)padding0__;
 }
 int16_t a() const {
 return flatbuffers::EndianScalar(a_);
 MANUALLY_ALIGNED_STRUCT(16) Vec3 FLATBUFFERS_FINAL_CLASS {
 padding1__(0),
 test3_(_test3),
 padding2__(0) {
+ (void)padding0__;(void)padding1__;(void)padding2__;
 }
 float x() const {
 return flatbuffers::EndianScalar(x_);
",1147,287
"Fix compiler warning on Visual Studio.

Change-Id: Ifda5f2c32c6484508d5e12a463d6373798f1f523"," namespace grpc_go_generator {
 grpc::string unexportName(grpc::string s) {
 if (s.empty())
 return s;
-s[0] = std::tolower(s[0]);
+s[0] = static_cast<char>(std::tolower(s[0]));
 return s;
 }
 
 grpc::string unexportName(grpc::string s) {
 grpc::string exportName(grpc::string s) {
 if (s.empty())
 return s;
-s[0] = std::toupper(s[0]);
+s[0] = static_cast<char>(std::toupper(s[0]));
 return s;
 }
 
",354,56
"Add no-op for padding variables to prevent clang compiler warning.

Change-Id: I119ee7109bfa2b0be0f468d2b2be459f45d1bb11"," MANUALLY_ALIGNED_STRUCT(16) Vec3 FLATBUFFERS_FINAL_CLASS {
 padding1__(0),
 test3_(_test3),
 padding2__(0) {
- (void)padding0__;(void)padding1__;(void)padding2__;
+ (void)padding0__;
+ (void)padding1__;
+ (void)padding2__;
 }
 float x() const {
 return flatbuffers::EndianScalar(x_);
",1149,287
"go: fix unknown field 'UOffset' to 'Pos'

Signed-off-by: Koichi Shiraishi <zchee.io@gmail.com>"," func CheckVtableDeduplication(fail func(string, ...interface{})) {
 len(want), want, len(got), got)
 }
 
-table0 := &flatbuffers.Table{Bytes: b.Bytes, UOffset: flatbuffers.UOffsetT(len(b.Bytes)) - obj0}
-table1 := &flatbuffers.Table{Bytes: b.Bytes, UOffset: flatbuffers.UOffsetT(len(b.Bytes)) - obj1}
-table2 := &flatbuffers.Table{Bytes: b.Bytes, UOffset: flatbuffers.UOffsetT(len(b.Bytes)) - obj2}
+table0 := &flatbuffers.Table{Bytes: b.Bytes, Pos: flatbuffers.UOffsetT(len(b.Bytes)) - obj0}
+table1 := &flatbuffers.Table{Bytes: b.Bytes, Pos: flatbuffers.UOffsetT(len(b.Bytes)) - obj1}
+table2 := &flatbuffers.Table{Bytes: b.Bytes, Pos: flatbuffers.UOffsetT(len(b.Bytes)) - obj2}
 
 testTable := func(tab *flatbuffers.Table, a flatbuffers.VOffsetT, b, c, d byte) {
 // vtable size
",1362,127
Reword comment so that code editors can mark deprecation correctly (#4147)," type Table struct {
 
 // Offset provides access into the Table's vtable.
 //
-// Deprecated fields are ignored by checking against the vtable's length.
+// Fields which are deprecated are ignored by checking against the vtable's length.
 func (t *Table) Offset(vtableOffset VOffsetT) VOffsetT {
 vtable := UOffsetT(SOffsetT(t.Pos) - t.GetSOffsetT(t.Pos))
 if vtableOffset < t.GetVOffsetT(vtable) {
",321,88
minor fixes to the union vector code styles (#4149)," class CppGenerator : public BaseGenerator {
 code_ += "" if (values->size() != types->size()) return false;"";
 code_ += "" for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {"";
 code_ += "" if (!Verify"" + enum_def.name + ""("";
- code_ += "" verifier, values->Get(i), types->GetEnum<"" + enum_def.name + "">(i))) { "";
- code_ += "" return false; "";
+ code_ += "" verifier, values->Get(i), types->GetEnum<"" + enum_def.name + "">(i))) {"";
+ code_ += "" return false;"";
 code_ += "" }"";
 code_ += "" }"";
 code_ += "" return true;"";
",1548,320
"Moved union vector test to file dependent section.

Change-Id: I3a1fcf167eb0d0a51ef838e54246ef867e752218"," int main(int /*argc*/, const char * /*argv*/[]) {
 ParseAndGenerateTextTest();
 ReflectionTest(flatbuf.get(), rawbuf.length());
 ParseProtoTest();
+ UnionVectorTest();
 #endif
 
 FuzzTest1();
 int main(int /*argc*/, const char * /*argv*/[]) {
 InvalidUTF8Test();
 UnknownFieldsTest();
 ParseUnionTest();
- UnionVectorTest();
 ConformTest();
 
 if (!testing_fails) {
",985,105
"Fix unused variable build warning on Mac.

Change-Id: I330187be6a96bfd388c2776f676d47a9145d5e4a","
 
 static const char *g_program_name = nullptr;
 
-static void Warn(const flatbuffers::FlatCompiler* flatc,
+static void Warn(const flatbuffers::FlatCompiler *flatc,
 const std::string &warn,
 bool show_exe_name) {
+ (void)flatc;
 if (show_exe_name) {
 printf(""%s: "", g_program_name);
 }
 printf(""warning: %s\n"", warn.c_str());
 }
 
-static void Error(const flatbuffers::FlatCompiler* flatc,
+static void Error(const flatbuffers::FlatCompiler *flatc,
 const std::string &err,
 bool usage,
 bool show_exe_name) {
",81,6
"Some small speed optimizations to the core copying functions.

Change-Id: Id8c1afb84f4ab0e2edca4290e3de5589fa06e578
Tested: on Linux."," inline bool VerifyEquipmentVector(flatbuffers::Verifier &verifier, const flatbuf
 if (values->size() != types->size()) return false;
 for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
 if (!VerifyEquipment(
- verifier, values->Get(i), types->GetEnum<Equipment>(i))) { 
- return false; 
+ verifier, values->Get(i), types->GetEnum<Equipment>(i))) {
+ return false;
 }
 }
 return true;
",526,126
"Added tracking of order of types declared.

Change-Id: Iade313c99f119dcf1619674260648a33f61dc030"," private:
 BaseType baseType);
 
 public:
+ SymbolTable<Type> types_;
 SymbolTable<StructDef> structs_;
 SymbolTable<EnumDef> enums_;
 SymbolTable<ServiceDef> services_;
",461,43
"A bug fix to the union vector feature in FlatBuffers.

Change-Id: I302245969f6ec2443572799732fce2aa7c071879"," class CppGenerator : public BaseGenerator {
 break;
 }
 case BASE_TYPE_UNION: {
+ code_.SetValue(""ENUM_NAME"", field.value.type.enum_def->name);
 code_ += ""{{PRE}}Verify{{ENUM_NAME}}Vector(verifier, {{NAME}}(), {{NAME}}_type())\\"";
 break;
 }
",1549,320
"Remove max_message_size arg, which is not passed to Deserialize func.

Change-Id: Icc7b4c1cf626f49d0529ff4f66503ea8381bf67c"," class SerializationTraits<T, typename std::enable_if<std::is_base_of<
 
 // There is no de-serialization step in FlatBuffers, so we just receive
 // the data from GRPC.
- static grpc::Status Deserialize(grpc_byte_buffer *buffer,
- T *msg,
- int max_message_size) {
+ static grpc::Status Deserialize(grpc_byte_buffer *buffer, T *msg) {
 // TODO(wvo): make this more efficient / zero copy when possible.
 auto len = grpc_byte_buffer_length(buffer);
 msg->buf = reinterpret_cast<uint8_t *>(malloc(len));
",37,3
"JSON parser wasn't handling ulong values correctly.

It passed all scalar ints thru a int64_t, which would truncate
uint64_t values with the upper bit set.

Change-Id: I38fb8c68c911ae44d9863f8e35c2429ca0ab51e5
Tested: on Linux."," class Parser : public ParserState {
 
 private:
 FLATBUFFERS_CHECKED_ERROR Error(const std::string &msg);
- FLATBUFFERS_CHECKED_ERROR ParseHexNum(int nibbles, int64_t *val);
+ FLATBUFFERS_CHECKED_ERROR ParseHexNum(int nibbles, uint64_t *val);
 FLATBUFFERS_CHECKED_ERROR Next();
 FLATBUFFERS_CHECKED_ERROR SkipByteOrderMark();
 bool Is(int t);
",461,43
"Fixes for Windows compiler errors.

Change-Id: I909ea6866089f36f9cb79d435bbecd29623fd8f7"," void FlexBuffersTest() {
 slb += ""Fred"";
 slb.IndirectFloat(4.0f);
 });
- std::vector<int> ints = { 1, 2, 3 };
+ int ints[] = { 1, 2, 3 };
 slb.Add(""bar"", ints);
- slb.FixedTypedVector(""bar3"", ints.data(), ints.size()); // Static size.
+ slb.FixedTypedVector(""bar3"", ints, sizeof(ints) / sizeof(int));
 slb.Double(""foo"", 100);
 slb.Map(""mymap"", [&]() {
 slb.String(""foo"", ""Fred""); // Testing key and string reuse.
",1044,107
Fixed vector test on Windows," class Builder FLATBUFFERS_FINAL_CLASS {
 EndVector(start, false, false);
 }
 }
+ template<typename T> void Vector(const char *key, const T *elems,
+ size_t len) {
+ Key(key);
+ Vector(elems, len);
+ }
 template<typename T> void Vector(const std::vector<T> &vec) {
 Vector(vec.data(), vec.size());
 }
",1001,321
"Changes to make flatbuffers javascript compatible with the closure compiler.

Change-Id: Iab8d66a8f34910029deb8a5ff5ec7ba50c5b3421"," struct ServiceDef : public Definition {
 struct IDLOptions {
 bool strict_json;
 bool skip_js_exports;
+ bool use_goog_js_export_format;
 bool output_default_scalars_in_json;
 int indent_step;
 bool output_enum_identifiers;
 struct IDLOptions {
 IDLOptions()
 : strict_json(false),
 skip_js_exports(false),
+ use_goog_js_export_format(false),
 output_default_scalars_in_json(false),
 indent_step(2),
 output_enum_identifiers(true), prefixed_enums(true), scoped_enums(false),
",463,43
"Add move constructor to generated union class. (#4167)

* Add move constructor to generated union class.

* Unused default

* Add generated code"," struct EquipmentUnion {
 flatbuffers::NativeTable *table;
 
 EquipmentUnion() : type(Equipment_NONE), table(nullptr) {}
+ EquipmentUnion(EquipmentUnion&& u):
+ type(std::move(u.type)), table(std::move(u.table)) {}
 EquipmentUnion(const EquipmentUnion &);
 EquipmentUnion &operator=(const EquipmentUnion &);
 ~EquipmentUnion() { Reset(); }
",528,127
"Added --prefix-include option for generated includes.

Change-Id: I288cda33345362f9aec5cbe309e590bf64f328e1
Tested: on Linux."," struct IDLOptions {
 std::string cpp_object_api_pointer_type;
 bool union_value_namespacing;
 bool allow_non_utf8;
+ std::string include_prefix;
 
 // Possible options for the more general generator below.
 enum Language {
",464,43
"Fixed sorting assertion with some std::sort implementations.

Change-Id: Idd925c9cc5cd2a35e06f4d832734180f5c38378e
Tested: on Linux."," class Builder FLATBUFFERS_FINAL_CLASS {
 auto comp = strcmp(as, bs);
 // If this assertion hits, you've added two keys with the same value to
 // this map.
- assert(comp);
+ // TODO: Have to check for pointer equality, as some sort implementation
+ // apparently call this function with the same element?? Why?
+ assert(comp || &a == &b);
 return comp < 0;
 });
 // First create a vector out of all keys.
",1001,322
"Added doc comments to the binary schema.

Change-Id: I87f291ab6e07b1425850cae25ed500db594f17c8
Tested: on Linux."," struct IDLOptions {
 bool union_value_namespacing;
 bool allow_non_utf8;
 std::string include_prefix;
+ bool binary_schema_comments;
 
 // Possible options for the more general generator below.
 enum Language {
 struct IDLOptions {
 cpp_object_api_pointer_type(""std::unique_ptr""),
 union_value_namespacing(true),
 allow_non_utf8(false),
+ binary_schema_comments(false),
 lang(IDLOptions::kJava),
 lang_to_generate(0) {}
 };
",466,43
Round vector_downward initial size up (#4179)," class vector_downward {
 public:
 explicit vector_downward(size_t initial_size,
 const simple_allocator &allocator)
- : reserved_(initial_size),
+ : reserved_((initial_size + sizeof(largest_scalar_t) - 1) &
+ ~(sizeof(largest_scalar_t) - 1)),
 buf_(allocator.allocate(reserved_)),
 cur_(buf_ + reserved_),
- allocator_(allocator) {
- assert((initial_size & (sizeof(largest_scalar_t) - 1)) == 0);
- }
+ allocator_(allocator) {}
 
 ~vector_downward() {
 if (buf_)
",998,285
"Updated version numbers to 1.6

Change-Id: I215fcc7581253f14171b513d4fc75da960b2064a","
 #endif // !defined(FLATBUFFERS_LITTLEENDIAN)
 
 #define FLATBUFFERS_VERSION_MAJOR 1
-#define FLATBUFFERS_VERSION_MINOR 5
+#define FLATBUFFERS_VERSION_MINOR 6
 #define FLATBUFFERS_VERSION_REVISION 0
 #define FLATBUFFERS_STRING_EXPAND(X) #X
 #define FLATBUFFERS_STRING(X) FLATBUFFERS_STRING_EXPAND(X)
",998,285
"Removed spurious ""aa"" from flatc usage message.

Change-Id: Ia1812d594882ce6c51002d07827ccec267d138bb"," void FlatCompiler::Error(const std::string &err, bool usage,
 
 std::string FlatCompiler::GetUsageString(const char* program_name) const {
 std::stringstream ss;
- ss << ""Usageaa: "" << program_name << "" [OPTION]... FILE... [-- FILE...]\n"";
+ ss << ""Usage: "" << program_name << "" [OPTION]... FILE... [-- FILE...]\n"";
 for (size_t i = 0; i < params_.num_generators; ++i) {
 const Generator& g = params_.generators[i];
 
",299,85
fix #4180: Long.prototype.toFloat64() overflow (#4182)," flatbuffers.Long.create = function(low, high) {
 * @returns {number}
 */
 flatbuffers.Long.prototype.toFloat64 = function() {
- return this.low + this.high * 0x100000000;
+ return (this.low >>> 0) + this.high * 0x100000000;
 };
 
 /**
",498,136
"more safer (#4186)

push_small(T little_endian_t) => push_small(const T& little_endian_t)"," class vector_downward {
 }
 
 // Specialized version of push() that avoids memcpy call for small data.
- template<typename T> void push_small(T little_endian_t) {
+ template<typename T> void push_small(const T& little_endian_t) {
 auto dest = make_space(sizeof(T));
 *reinterpret_cast<T *>(dest) = little_endian_t;
 }
",998,285
"Fixed move constructor in generated union class (#4192)

* Fixed move constructor in generated union class

* Removed delegating constructor"," struct EquipmentUnion {
 
 EquipmentUnion() : type(Equipment_NONE), table(nullptr) {}
 EquipmentUnion(EquipmentUnion&& u):
- type(std::move(u.type)), table(std::move(u.table)) {}
+ type(Equipment_NONE), table(nullptr)
+ { std::swap(type, u.type); std::swap(table, u.table); }
 EquipmentUnion(const EquipmentUnion &);
 EquipmentUnion &operator=(const EquipmentUnion &);
 ~EquipmentUnion() { Reset(); }
",529,127
C++ generator: Pre-allocating std::vector in UnPack methods. (#4187)," class CppGenerator : public BaseGenerator {
 // for (uoffset_t i = 0; i < _e->size(); ++i) {
 // _o->field.push_back(_e->Get(_i));
 // }
+ code += ""{ _o->"" + field.name + "".resize(_e->size()); "";
 code += ""for (flatbuffers::uoffset_t _i = 0;"";
 code += "" _i < _e->size(); _i++) { "";
- code += ""_o->"" + field.name + "".push_back("";
+ code += ""_o->"" + field.name + ""[_i] = "";
 code += GenUnpackVal(field.value.type.VectorType(),
 indexing, true, field);
- code += ""); }"";
+ code += ""; } }"";
 break;
 }
 case BASE_TYPE_UTYPE: {
",1613,328
"optimization of FlatBufferBuilder::CreateVector() (#4198)

optimization of FlatBufferBuilder::CreateVector()
1. optimization of FlatBufferBuilder::CreateVector() for ""1 == sizeof(T)"" ( such as [byte], [ubyte]).
2. For my project, it was about 10x improvement on flatbuffers serialization.
3. why not ""string"": ""string, which may only hold UTF-8 or 7-bit ASCII. For other text encodings or general binary data use vectors ([byte] or [ubyte]) instead."""," FLATBUFFERS_FINAL_CLASS
 /// where the vector is stored.
 template<typename T> Offset<Vector<T>> CreateVector(const T *v, size_t len) {
 StartVector(len, sizeof(T));
- for (auto i = len; i > 0; ) {
- PushElement(v[--i]);
+ if (sizeof(T) == 1) {
+ PushBytes(reinterpret_cast<const uint8_t *>(v), len);
+ } else {
+ for (auto i = len; i > 0; ) {
+ PushElement(v[--i]);
+ }
 }
 return Offset<Vector<T>>(EndVector(len));
 }
",1002,286
Fixing broken link and added missing <map> header include. (#4199),"
 #ifndef FLATBUFFERS_FLEXBUFFERS_H_
 #define FLATBUFFERS_FLEXBUFFERS_H_
 
+#include <map>
 // We use the basic binary writing functions from the regular FlatBuffers.
 #include ""flatbuffers/flatbuffers.h""
 #include ""flatbuffers/util.h""
",1003,322
Add a backwards-compatible version of VerifyBuffer() (#4201)," class Verifier FLATBUFFERS_FINAL_CLASS {
 }
 
 // Verify this whole buffer, starting with root type T.
+ template<typename T> bool VerifyBuffer() {
+ return VerifyBuffer<T>(nullptr);
+ }
+
 template<typename T> bool VerifyBuffer(const char *identifier) {
 return VerifyBufferFromStart<T>(identifier, buf_);
 }
",1005,287
fixed path being ignored in GenerateCppGRPC (#4207)," bool GenerateGoGRPC(const Parser &parser,
 }
 
 bool GenerateCppGRPC(const Parser &parser,
- const std::string &/*path*/,
+ const std::string &path,
 const std::string &file_name) {
 
 int nservices = 0;
 bool GenerateCppGRPC(const Parser &parser,
 grpc_cpp_generator::GetSourceServices(&fbfile, generator_parameters) +
 grpc_cpp_generator::GetSourceEpilogue(&fbfile, generator_parameters);
 
- return flatbuffers::SaveFile((file_name + "".grpc.fb.h"").c_str(),
+ return flatbuffers::SaveFile((path + file_name + "".grpc.fb.h"").c_str(),
 header_code, false) &&
- flatbuffers::SaveFile((file_name + "".grpc.fb.cc"").c_str(),
+ flatbuffers::SaveFile((path + file_name + "".grpc.fb.cc"").c_str(),
 source_code, false);
 }
 
",198,55
"VS2015 warning ""conditional expression is constant"" (#4210)

* VS2015 warning ""conditional expression is constant""

* VS2015 warning ""conditional expression is constant""","
 #define FLATBUFFERS_CONSTEXPR
 #endif
 
+#if defined(_MSC_VER)
+#pragma warning(push)
+#pragma warning(disable: 4127) // C4127: conditional expression is constant
+#endif
+
 /// @endcond
 
 /// @file
 volatile __attribute__((weak)) const char *flatbuffer_version_string =
 /// @endcond
 } // namespace flatbuffers
 
+#if defined(_MSC_VER)
+#pragma warning(pop)
+#endif
+
 #endif // FLATBUFFERS_H_
",1005,287
"NoError was returning on DoParse method when file was empty (#4208)

* NoError was returning on DoParse method when file was empty.

* change NoError message in DoParse."," CheckedError Parser::DoParse(const char *source, const char **include_paths,
 namespaces_.push_back(new Namespace());
 ECHECK(SkipByteOrderMark());
 NEXT();
+
+ if (Is(kTokenEof))
+ return Error(""input file is empty"");
+
 // Includes must come before type declarations:
 for (;;) {
 // Parse pre-include proto statements if any:
",1864,568
"Pedantic Visual Studio build (/W4 /WX) (#4214)

* Pedantic Visual Studio build (/W4 /WX)

* Pedantic Visual Studio build (/W4 /WX)

* Pedantic Visual Studio build (/W4 /WX)

* Remove /wd4512 from CMakeLists.txt

* Suppress Visual Studio 4512 warning ('class' : assignment operator could not be generated)","
 #include <assert.h>
 #include ""flatbuffers/util.h""
 
+#if defined(_MSC_VER)
+#pragma warning(push)
+#pragma warning(disable: 4127) // C4127: conditional expression is constant
+#endif
+
 namespace flatbuffers {
 
 void CodeWriter::operator+=(std::string text) {
 void GenComment(const std::vector<std::string> &dc, std::string *code_ptr,
 }
 
 } // namespace flatbuffers
+
+#if defined(_MSC_VER)
+#pragma warning(pop)
+#endif
+
",113,37
Prevent flatbuffers::Vector and flatbuffers::VectorOfAny to be copied (#4217)," protected:
 uoffset_t length_;
 
 private:
+ // This class is a pointer. Copying will therefore create an invalid object.
+ // Private and unimplemented copy constructor.
+ Vector(const Vector&);
+
 template<typename K> static int KeyCompare(const void *ap, const void *bp) {
 const K *key = reinterpret_cast<const K *>(ap);
 const uint8_t *data = reinterpret_cast<const uint8_t *>(bp);
 protected:
 VectorOfAny();
 
 uoffset_t length_;
+ 
+private:
+ VectorOfAny(const VectorOfAny&);
 };
 
 // Convenient helper function to get the length of any vector, regardless
",1008,287
"sample: update auto-generated monster_generated.h (#4219)

Signed-off-by: Koichi Shiraishi <zchee.io@gmail.com>"," struct Monster FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
 const void *equipped() const {
 return GetPointer<const void *>(VT_EQUIPPED);
 }
+ template<typename T> const T *equipped_as() const;
+ const Weapon *equipped_as_Weapon() const {
+ return (equipped_type() == Equipment_Weapon)? static_cast<const Weapon *>(equipped()) : nullptr;
+ }
 void *mutable_equipped() {
 return GetPointer<void *>(VT_EQUIPPED);
 }
 struct Monster FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
 static flatbuffers::Offset<Monster> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MonsterT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
 };
 
+template<> inline const Weapon *Monster::equipped_as<Weapon>() const {
+ return equipped_as_Weapon();
+}
+
 struct MonsterBuilder {
 flatbuffers::FlatBufferBuilder &fbb_;
 flatbuffers::uoffset_t start_;
",536,130
"C++: add String::str() function (#4234)

for convenience"," class String : public Sized {
 
 size_t length() const { return size(); }
 const char *c_str() const { return reinterpret_cast<const char *>(data_); }
+ std::string str() const { return std::string(c_str(), length()); }
 
 static String EmptyString() {
 static const uint8_t empty_string[] = { 0/*len*/, 0/*terminator*/ };
",1004,323
"Add arbitrary string type to the native object API (#4218)

* Custom strings are very common for optimizations around small objects
 or growth style optimizations, i.e.: grow at 1.57 times vs doubling vs..

 A second common strategy is to cooperate w/ the memory allocator
 see FBString[1] and seastar[2] string for examples.

[1] fbstring: https://github.com/facebook/folly/blob/master/folly/docs/FBString.md
[2] sstring: https://github.com/scylladb/seastar/blob/master/core/sstring.hh"," FLATBUFFERS_FINAL_CLASS
 return str ? CreateString(str->c_str(), str->Length()) : 0;
 }
 
+ /// @brief Store a string in the buffer, which can contain any binary data.
+ /// @param[in] str A const reference to a std::string like type with support
+ /// of T::c_str() and T::length() to store in the buffer.
+ /// @return Returns the offset in the buffer where the string starts.
+ template<typename T>
+ Offset<String> CreateString(const T &str) {
+ return CreateString(str.c_str(), str.length());
+ }
+
 /// @brief Store a string in the buffer, which can contain any binary data.
 /// If a string with this exact contents has already been serialized before,
 /// instead simply returns the offset of the existing string.
",1012,288
add command line argument for go namespace (#4222)," struct IDLOptions {
 bool allow_non_utf8;
 std::string include_prefix;
 bool binary_schema_comments;
+ std::string go_namespace;
 
 // Possible options for the more general generator below.
 enum Language {
",469,43
"C++: Add default value handling to mutation/SetField code (#4230)

* Add default value handling to mutation/SetField code

* Shorten reflection SetField impl

* Modify impl to work with C++03

* Add more mutation tests

* Fail SetField if non-scalar

* Add IsScalar/IsInteger/IsFloat for reflection::BaseType

* Use new IsScalar/IsInteger/IsFloat in reflection SetField

* Assume scalar is either int or float"," class Table {
 return field_offset ? reinterpret_cast<P>(p) : nullptr;
 }
 
- template<typename T> bool SetField(voffset_t field, T val) {
+ template<typename T> bool SetField(voffset_t field, T val, T def) {
 auto field_offset = GetOptionalFieldOffset(field);
- if (!field_offset) return false;
+ if (!field_offset) return val == def;
 WriteScalar(data_ + field_offset, val);
 return true;
 }
",1012,288
"Fixing closure compile compatibility when --gen-mutable is used.

Change-Id: I8bf575ba6dc795d2d2eec02fa8977dcc2594eaa6"," flatbuffers.ByteBuffer.prototype.readFloat64 = function(offset) {
 
 /**
 * @param {number} offset
- * @param {number} value
+ * @param {number|boolean} value
 */
 flatbuffers.ByteBuffer.prototype.writeInt8 = function(offset, value) {
+ this.bytes_[offset] = /** @type {number} */(value);
+};
+
+/**
+ * @param {number} offset
+ * @param {number} value
+ */
+flatbuffers.ByteBuffer.prototype.writeUint8 = function(offset, value) {
 this.bytes_[offset] = value;
 };
 
",501,137
"Add a VectorCast function that safely casts from
Vector<Offset<T>> to Vector<Offset<U>> if U is a base
class of T.

This is useful for when you want to generically
iterate over a vector of objects that derive from
flatbuffers::Table.

Change-Id: I59161e3b9f40501f72e02b46509be9dc8ab86c6b"," private:
 VectorOfAny(const VectorOfAny&);
 };
 
+#ifndef FLATBUFFERS_CPP98_STL
+template<typename T, typename U>
+Vector<Offset<T>> *VectorCast(Vector<Offset<U>> *ptr) {
+ static_assert(std::is_base_of<T, U>::value, ""Unrelated types"");
+ return reinterpret_cast<Vector<Offset<T>> *>(ptr);
+}
+
+template<typename T, typename U>
+const Vector<Offset<T>> *VectorCast(const Vector<Offset<U>> *ptr) {
+ static_assert(std::is_base_of<T, U>::value, ""Unrelated types"");
+ return reinterpret_cast<const Vector<Offset<T>> *>(ptr);
+}
+#endif
+
 // Convenient helper function to get the length of any vector, regardless
 // of wether it is null or not (the field is not set).
 template<typename T> static inline size_t VectorLength(const Vector<T> *v) {
",1023,290
"Support binary search for struct in cpp (#4245)

* Support binary search for struct in cpp

CreateVectorOfSortedStruct is provided for convenience.

* fix continuous-integration error

* add generated files

* compile Ability.cs in csharp test

* compile Ability.cs in csharp

* modify according to code review"," class CppGenerator : public BaseGenerator {
 code_ += "" }"";
 }
 }
+
+ // Generate a comparison function for this field if it is a key.
+ if (field.key) {
+ code_ += "" bool KeyCompareLessThan(const {{STRUCT_NAME}} *o) const {"";
+ code_ += "" return {{FIELD_NAME}}() < o->{{FIELD_NAME}}();"";
+ code_ += "" }"";
+ auto type = GenTypeBasic(field.value.type, false);
+ if (parser_.opts.scoped_enums && field.value.type.enum_def &&
+ IsScalar(field.value.type.base_type)) {
+ type = GenTypeGet(field.value.type, "" "", ""const "", "" *"", true);
+ }
+
+ code_.SetValue(""KEY_TYPE"", type);
+ code_ += "" int KeyCompareWithValue({{KEY_TYPE}} val) const {"";
+ code_ += "" const auto key = {{FIELD_NAME}}();"";
+ code_ += "" return static_cast<int>(key > val) - static_cast<int>(key < val);"";
+ code_ += "" }"";
+ }
 }
 code_ += ""};"";
 
",1639,336
"C#: Fixed possible conflicts between usings and user-supplied namespace (#4247)

* C#: Fixed possible conflicts between usings and user-supplied namespace

C#: Added the global qualifier to using directives to prevent possible conflicts with the user-supplied namespace. Also prevents unintentional type hiding. Resolves issue #4242.

* Updated C# generated code files"," const LanguageParameters& GetLangParams(IDLOptions::Language lang) {
 ""__p."",
 ""Table."",
 ""?"",
- ""using System;\nusing FlatBuffers;\n\n"",
+ ""using global::System;\nusing global::FlatBuffers;\n\n"",
 {
 nullptr,
 ""///"",
",1221,286
"Added missing generated code for C#

Change-Id: I1affced255eb96977119d8480793b5bba42f065f","
 namespace MyGame.Example
 {
 
-using System;
-using FlatBuffers;
+using global::System;
+using global::FlatBuffers;
 
 public struct Ability : IFlatbufferObject
 {
",22,5
"Fix flatc code gen.

Mutable functions should return a non-const reference to the member variable.

Change-Id: I833077d2c9a38a5d71868e43aca6b250d79b6625"," class CppGenerator : public BaseGenerator {
 code_ += "" }"";
 
 if (parser_.opts.mutable_buffer) {
+ auto mut_field_type = GenTypeGet(field.value.type, "" "", """", "" &"", true);
+ code_.SetValue(""FIELD_TYPE"", mut_field_type);
 if (is_scalar) {
 code_.SetValue(""ARG"", GenTypeBasic(field.value.type, true));
 code_.SetValue(""FIELD_VALUE"",
",1641,336
"[C++]Use noexcept in union type move ctor/Add move assingment (#4249)

* Use noexcept in union type move ctor/Add move assingment

* Add NOEXCEPT macro to deal with _MS_VER/Remove delegating ctor in union type class

* Add FLATBUFFERS_NOEXCEPT to generated union class","
 #define FLATBUFFERS_CONSTEXPR
 #endif
 
+#if defined(__GXX_EXPERIMENTAL_CXX0X__) && __GNUC__ * 10 + __GNUC_MINOR__ >= 46 || \
+ defined(_MSC_FULL_VER) && _MSC_FULL_VER >= 190023026
+ #define FLATBUFFERS_NOEXCEPT noexcept
+#else
+ #define FLATBUFFERS_NOEXCEPT
+#endif
+
 #if defined(_MSC_VER)
 #pragma warning(push)
 #pragma warning(disable: 4127) // C4127: conditional expression is constant
",1040,293
make flatbuffers.js into a UMD module (#4228),"
 /// @{
 /// @cond FLATBUFFERS_INTERNAL
 
-/**
- * @fileoverview
- *
- * Need to suppress 'global this' error so the Node.js export line doesn't cause
- * closure compile to error out.
- * @suppress {globalThis}
- */
-
-/**
- * @const
- * @namespace
- */
+(function (global, factory) {
+typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = { flatbuffers: factory() } :
+typeof define === 'function' && define.amd ? define(factory) :
+(global.flatbuffers = factory());
+}(this, (function () { 'use strict';
+/**
+* @exports flatbuffers
+*/
 var flatbuffers = {};
 
 /**
 flatbuffers.ByteBuffer.prototype.createLong = function(low, high) {
 return flatbuffers.Long.create(low, high);
 };
 
-// Exports for Node.js and RequireJS
-this.flatbuffers = flatbuffers;
+return flatbuffers;
+
+})));
 
 /// @endcond
 /// @}
",507,141
"TypeScript support (#4232)

* Eclipse ignore

* TypeScript support

* Prefixing enums

* Test results

* Merged JS and TS generators

* Fixed AppVeyor build problems

* Fixed more AppVeyor build problems

* Fixed more AppVeyor build problems

* Changed TS flag to options struct

* Storing options by value

* Removed unneeded const

* Re-export support for unions

* Uint support

* Casting bools to numbers for mutation

* TS shell tests

* Reverted generates js test file to original version

* Backing up js tests and properly generating test data"," class BaseGenerator {
 
 std::string WrapInNameSpace(const Definition &def) const;
 
+ std::string GetNameSpace(const Definition &def) const;
+
 const Parser &parser_;
 const std::string &path_;
 const std::string &file_name_;
",65,7
"Fix Visual Studio 2017 new warning (C4244: 'argument': conversion fro (#4261)

* Fix Visual Studio 2017 new warning (C4244: 'argument': conversion from 'int' to 'const char', possible loss of data)

* Fix Visual Studio 2017 pedantic warnings

* Fix Visual Studio 2017 pedantic warnings"," inline uint64_t StringToUInt(const char *str, char **endptr = nullptr,
 #endif
 }
 
+// Pedantic warning free version of toupper().
+inline char ToUpper(char c) {
+ return static_cast<char>(::toupper(c));
+}
+
 typedef bool (*LoadFileFunction)(const char *filename, bool binary,
 std::string *dest);
 typedef bool (*FileExistsFunction)(const char *filename);
",206,63
"C++ fixed compile error C2678 with msvc when using std::find_if on vectors (#4262)

In Debug mode it is checked that iterator begin is less than end
therefore the operator< in class VectorIterator is needed"," public:
 return data_ == other.data_;
 }
 
+ bool operator<(const VectorIterator &other) const {
+ return data_ < other.data_;
+ }
+
 bool operator!=(const VectorIterator &other) const {
 return data_ != other.data_;
 }
",1043,294
"VS warning fixes.

Change-Id: I19662241d56560c064cff73dbebfb2a81d226934"," class CppGenerator : public BaseGenerator {
 : ev.name;
 } else {
 assert(false);
+ return ev.name;
 }
 }
 
",1743,369
"[C++] fix bounds checking on integer parsing (#4250)

* fix bounds checking on integer parsing

the previous code was allowing 255 for int8_t, similar for int16_t
and int32_t, and even negative values for unsignd types.

this patch fixes bounds checking for 8-bit, 16-bit and 32-bit types.
testing for both acceptable values and unacceptable values at the
boundaries are also improved.

bounds checking on 64-bit types isn't addressed by this patch.

* fix 'unary minus operator applied to unsigned type, result still unsigned'

* fix & placement"," class Parser : public ParserState {
 // of the schema provided. Returns non-empty error on any problems.
 std::string ConformTo(const Parser &base);
 
- FLATBUFFERS_CHECKED_ERROR CheckBitsFit(int64_t val, size_t bits);
+ FLATBUFFERS_CHECKED_ERROR CheckInRange(int64_t val, int64_t min, int64_t max);
 
 private:
 FLATBUFFERS_CHECKED_ERROR Error(const std::string &msg);
",476,43
"Fixed clang needing union copy constructor.

Move constructors are present, which it should use instead.

This is a temp fix to make it compile, but eventually we should
generate a proper copy constructor just in-case people want to
copy objects with unions.

Tested on: Linux, OS X.

Change-Id: Idf85419995c96f5959061882157541573e306083"," struct EquipmentUnion {
 EquipmentUnion(EquipmentUnion&& u) FLATBUFFERS_NOEXCEPT :
 type(Equipment_NONE), value(nullptr)
 { std::swap(type, u.type); std::swap(value, u.value); }
- EquipmentUnion(const EquipmentUnion &);
- EquipmentUnion &operator=(const EquipmentUnion &);
+ EquipmentUnion(const EquipmentUnion &) { assert(false); }
+ EquipmentUnion &operator=(const EquipmentUnion &) { assert(false); return *this; }
 EquipmentUnion &operator=(EquipmentUnion &&u) FLATBUFFERS_NOEXCEPT
 { std::swap(type, u.type); std::swap(value, u.value); return *this; }
 ~EquipmentUnion() { Reset(); }
",538,133
"Undo PR: make flatbuffers.js into a UMD module (#4228)

This PR did not work in all JS environments and caused
downstream breakage.

Change-Id: Ib565129e26622d02bad2d45816bd05f6b961b994","
 /// @{
 /// @cond FLATBUFFERS_INTERNAL
 
-(function (global, factory) {
-typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = { flatbuffers: factory() } :
-typeof define === 'function' && define.amd ? define(factory) :
-(global.flatbuffers = factory());
-}(this, (function () { 'use strict';
-/**
-* @exports flatbuffers
-*/
+/**
+ * @fileoverview
+ *
+ * Need to suppress 'global this' error so the Node.js export line doesn't cause
+ * closure compile to error out.
+ * @suppress {globalThis}
+ */
+
+/**
+ * @const
+ * @namespace
+ */
 var flatbuffers = {};
 
 /**
 flatbuffers.ByteBuffer.prototype.createLong = function(low, high) {
 return flatbuffers.Long.create(low, high);
 };
 
-return flatbuffers;
-
-})));
+// Exports for Node.js and RequireJS
+this.flatbuffers = flatbuffers;
 
 /// @endcond
 /// @}
",515,140
"Fixed hashed values in JSON for signed ints.

Change-Id: Iae389c6dc9776058b39f4017d30efbf9580aced1
Tested: on Linux."," CheckedError Parser::ParseHash(Value &e, FieldDef* field) {
 assert(field);
 Value *hash_name = field->attributes.Lookup(""hash"");
 switch (e.type.base_type) {
- case BASE_TYPE_INT:
+ case BASE_TYPE_INT: {
+ auto hash = FindHashFunction32(hash_name->constant.c_str());
+ int32_t hashed_value = static_cast<int32_t>(hash(attribute_.c_str()));
+ e.constant = NumToString(hashed_value);
+ break;
+ }
 case BASE_TYPE_UINT: {
 auto hash = FindHashFunction32(hash_name->constant.c_str());
 uint32_t hashed_value = hash(attribute_.c_str());
 e.constant = NumToString(hashed_value);
 break;
 }
- case BASE_TYPE_LONG:
+ case BASE_TYPE_LONG: {
+ auto hash = FindHashFunction64(hash_name->constant.c_str());
+ int64_t hashed_value = static_cast<int64_t>(hash(attribute_.c_str()));
+ e.constant = NumToString(hashed_value);
+ break;
+ }
 case BASE_TYPE_ULONG: {
 auto hash = FindHashFunction64(hash_name->constant.c_str());
 uint64_t hashed_value = hash(attribute_.c_str());
",1909,576
"VS fix for ambiguous union assignment operator.

Change-Id: I1c37db1ced462fd558d3e893a501341f3eca6379"," struct EquipmentUnion {
 type(Equipment_NONE), value(nullptr)
 { std::swap(type, u.type); std::swap(value, u.value); }
 EquipmentUnion(const EquipmentUnion &) FLATBUFFERS_NOEXCEPT;
- EquipmentUnion &operator=(EquipmentUnion u) FLATBUFFERS_NOEXCEPT
- { std::swap(type, u.type); std::swap(value, u.value); return *this; }
+ EquipmentUnion &operator=(const EquipmentUnion &u) FLATBUFFERS_NOEXCEPT
+ { EquipmentUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
 EquipmentUnion &operator=(EquipmentUnion &&u) FLATBUFFERS_NOEXCEPT
 { std::swap(type, u.type); std::swap(value, u.value); return *this; }
 ~EquipmentUnion() { Reset(); }
",549,134
Fix minor const correctness issue (#4271)," public:
 return temp;
 }
 
- VectorIterator operator+(const uoffset_t &offset) {
+ VectorIterator operator+(const uoffset_t &offset) const {
 return VectorIterator(data_ + offset * IndirectHelper<T>::element_stride, 0);
 }
 
",1055,297
"Fixed CreateVectorOfStructs for native_type (2nd try) (#4276)

* Added support for serializing native_type with CreateVectorOfNativeStructs

* Added support for serializing native_type with CreateVectorOfSortedNativeStructs

* Added C++ code generation for vectors of native_types"," class CppGenerator : public BaseGenerator {
 }
 case BASE_TYPE_STRUCT: {
 if (IsStruct(vector_type)) {
- code += ""_fbb.CreateVectorOfStructs("" + value + "")"";
+ auto native_type =
+ field.value.type.struct_def->attributes.Lookup(""native_type"");
+ if (native_type) {
+ code += ""_fbb.CreateVectorOfNativeStructs<"";
+ code += WrapInNameSpace(*vector_type.struct_def) + "">"";
+ } else {
+ code += ""_fbb.CreateVectorOfStructs""; 
+ }
+ code += ""("" + value + "")"";
 } else {
 code += ""_fbb.CreateVector<flatbuffers::Offset<"";
 code += WrapInNameSpace(*vector_type.struct_def) + "">>"";
",1791,377
Specify `std' namespace for remove function (#4268)," CheckedError Parser::StartStruct(const std::string &name, StructDef **dest) {
 struct_def.file = file_being_parsed_;
 // Move this struct to the back of the vector just in case it was predeclared,
 // to preserve declaration order.
- *remove(structs_.vec.begin(), structs_.vec.end(), &struct_def) = &struct_def;
+ *std::remove(structs_.vec.begin(), structs_.vec.end(), &struct_def) = &struct_def;
 *dest = &struct_def;
 return NoError();
 }
",1909,576
Added a clear function for purging all data that is holded by the FlatBuffer. (#4259)," public class FlatBufferBuilder {
 return this;
 }
 
+ /**
+ * Reset the FlatBufferBuilder by purging all data that it holds.
+ */
+ public void clear(){
+ space = bb.capacity();
+ bb.clear();
+ minalign = 1;
+ while(vtable_in_use > 0) vtable[--vtable_in_use] = 0;
+ vtable_in_use = 0;
+ nested = false;
+ finished = false;
+ object_start = 0;
+ num_vtables = 0;
+ vector_num_elems = 0;
+ }
+
 /// @cond FLATBUFFERS_INTERNAL
 /**
 * Create a `ByteBuffer` with a given capacity.
",307,105
"Fix Android STLPort build.

Change-Id: Iceca7b8b455c8463d9b82b928332a875dee3d19e","
 
 #include ""flatbuffers/flatbuffers.h""
 
+
 namespace flatbuffers {
 
 // Convert an integer or floating point value to a string.
 inline uint64_t StringToUInt(const char *str, char **endptr = nullptr,
 #endif
 }
 
-// Pedantic warning free version of toupper().
-inline char ToUpper(char c) {
- return static_cast<char>(::toupper(c));
-}
-
 typedef bool (*LoadFileFunction)(const char *filename, bool binary,
 std::string *dest);
 typedef bool (*FileExistsFunction)(const char *filename);
",203,62
"Fixes for VS 2015 build.

Change-Id: I23280e611163a89b8eba7b9b0016c297fea2396e"," class Builder FLATBUFFERS_FINAL_CLASS {
 // Write vector. First the keys width/offset if available, and size.
 if (keys) {
 WriteOffset(keys->u_, byte_width);
- Write<uint64_t>(1U << keys->min_bit_width_, byte_width);
+ Write<uint64_t>(1ULL << keys->min_bit_width_, byte_width);
 }
 if (!fixed) Write<uint64_t>(vec_len, byte_width);
 // Then the actual data.
",1005,323
"Made the verifier catch zero-offsets.

Zero offsets are non-sensical in FlatBuffers (since offsets are
relative to themselves) but were allowed by the verifier. This could
cause buffers made up of all zeroes to be interpreted as correct
buffers with an empty root object.

Generally, not allowing such offsets will make the verifier more
likely to catch problems earlier.

Change-Id: I54010bea29721b326ff8e5348fcd9fe78e5e7506
Tested: on Linux."," class CppGenerator : public BaseGenerator {
 code_.SetValue(""REQUIRED"", field.required ? ""Required"" : """");
 code_.SetValue(""SIZE"", GenTypeSize(field.value.type));
 code_.SetValue(""OFFSET"", GenFieldOffsetName(field));
- code_ += ""{{PRE}}VerifyField{{REQUIRED}}<{{SIZE}}>(verifier, {{OFFSET}})\\"";
+ if (IsScalar(field.value.type.base_type) || IsStruct(field.value.type)) {
+ code_ +=
+ ""{{PRE}}VerifyField{{REQUIRED}}<{{SIZE}}>(verifier, {{OFFSET}})\\"";
+ } else {
+ code_ += ""{{PRE}}VerifyOffset{{REQUIRED}}(verifier, {{OFFSET}})\\"";
+ }
 
 switch (field.value.type.base_type) {
 case BASE_TYPE_UNION: {
 class CppGenerator : public BaseGenerator {
 code += ""_fbb.CreateVectorOfNativeStructs<"";
 code += WrapInNameSpace(*vector_type.struct_def) + "">"";
 } else {
- code += ""_fbb.CreateVectorOfStructs""; 
+ code += ""_fbb.CreateVectorOfStructs"";
 }
 code += ""("" + value + "")"";
 } else {
",1799,380
[C++] Add grpc_slice_unref(slice) (#4294)," class SerializationTraits<T, typename std::enable_if<std::is_base_of<
 auto slice = gpr_slice_from_copied_buffer(
 reinterpret_cast<const char *>(msg.buf), msg.len);
 *buffer = grpc_raw_byte_buffer_create(&slice, 1);
+ grpc_slice_unref(slice);
 *own_buffer = true;
 return grpc::Status();
 }
",38,3
"Tweak fallthrough comments to get recognized by gcc7 (#4298)

GCC gained a new warning, -Wimplicit-fallthrough, which warns about
implicitly falling through a case statement. The regular expressions
used at the default level (-Wimplicit-fallthrough=3) don't match with
a colon at the end. The comment also needs to be followed (after
optional whitespace and other comments) by a 'case' or 'default'
keyword, i.e. it will not be recognized with a '}' between the comment
and the keyword."," Type DestinationType(const Type &type, bool vectorelem) {
 case BASE_TYPE_VECTOR:
 if (vectorelem)
 return DestinationType(type.VectorType(), vectorelem);
- // else fall thru:
+ // else fall thru
 default: return type;
 }
 }
 std::string DestinationMask(const Type &type, bool vectorelem) {
 case BASE_TYPE_VECTOR:
 if (vectorelem)
 return DestinationMask(type.VectorType(), vectorelem);
- // else fall thru:
+ // else fall thru
 default: return """";
 }
 }
",1221,286
"[C++] Add grpc/streaming test and fix Deserialize (#4296)

* [C++] Add delete msg->buf

* [C++] Add grpc streaming test

* Use free instead of delete

* Refactoring grpctest"," class SerializationTraits<T, typename std::enable_if<std::is_base_of<
 static grpc::Status Deserialize(grpc_byte_buffer *buffer, T *msg) {
 // TODO(wvo): make this more efficient / zero copy when possible.
 auto len = grpc_byte_buffer_length(buffer);
+ if(msg->buf != nullptr){
+ free(msg->buf);
+ } 
 msg->buf = reinterpret_cast<uint8_t *>(malloc(len));
 msg->len = static_cast<flatbuffers::uoffset_t>(len);
 msg->must_free = true;
",41,4
"Added --keep-prefix to not strip schema include path in C++ includes.

Change-Id: I3c6356fc6664072796f273096df64829108b4a34
Tested: on Linux."," struct IDLOptions {
 bool union_value_namespacing;
 bool allow_non_utf8;
 std::string include_prefix;
+ bool keep_include_path;
 bool binary_schema_comments;
 bool skip_flatbuffers_import;
 std::string go_namespace;
 struct IDLOptions {
 cpp_object_api_pointer_type(""std::unique_ptr""),
 union_value_namespacing(true),
 allow_non_utf8(false),
+ keep_include_path(false),
 binary_schema_comments(false),
 skip_flatbuffers_import(false),
 reexport_ts_modules(true),
",478,43
"Clarified the semantics of the Offset type.

Change-Id: Iccc36d24321ac4d556692ac715c0cc69a2c9e09e
Tested: on Linux."," typedef std::unique_ptr<uint8_t, std::function<void(uint8_t * /* unused */)>>
 #endif
 
 // Wrapper for uoffset_t to allow safe template specialization.
+// Value is allowed to be 0 to indicate a null object (see e.g. AddOffset).
 template<typename T> struct Offset {
 uoffset_t o;
 Offset() : o(0) {}
 Offset(uoffset_t _o) : o(_o) {}
 Offset<void> Union() const { return Offset<void>(o); }
+ bool IsNull() const { return !o; }
 };
 
 inline void EndianCheck() {
 FLATBUFFERS_FINAL_CLASS
 }
 
 template<typename T> void AddOffset(voffset_t field, Offset<T> off) {
- if (!off.o) return; // An offset of 0 means NULL, don't store.
+ if (off.IsNull()) return; // Don't store.
 AddElement(field, ReferTo(off.o), static_cast<uoffset_t>(0));
 }
 
",1096,308
"Added error message for union values out of range.

Change-Id: I481afcde6a554d1cad519ff95acac7f38a7f4ee5
Tested: on Linux."," CheckedError Parser::ParseEnum(bool is_union, EnumDef **dest) {
 enum_def.vals.vec[prevsize - 1]->value >= ev.value)
 return Error(""enum values must be specified in ascending order"");
 }
+ if (is_union) {
+ if (ev.value < 0 || ev.value >= 256)
+ return Error(""union enum value must fit in a ubyte"");
+ }
 if (opts.proto_mode && Is('[')) {
 NEXT();
 // ignore attributes on enums.
",1913,579
"Removed unnecessary check for Offset in AssertScalarT()

This will avoid it accidentally accepting structs of size 4.

Change-Id: I251285ae1e4bffb859367dcf89562741a3980bba
Tested: on Linux."," FLATBUFFERS_FINAL_CLASS
 template<typename T> void AssertScalarT() {
 #ifndef FLATBUFFERS_CPP98_STL
 // The code assumes power of 2 sizes and endian-swap-ability.
- static_assert(std::is_scalar<T>::value
- // The Offset<T> type is essentially a scalar but fails is_scalar.
- || sizeof(T) == sizeof(Offset<void>),
- ""T must be a scalar type"");
+ static_assert(std::is_scalar<T>::value, ""T must be a scalar type"");
 #endif
 }
 
",1094,307
"Reverting part of PR #4286

This is because it trips up the Closure compiler with errors like:

ERROR - assignment to property bb of SomeTable
found : undefined
required: (flatbuffers.ByteBuffer|null)
this.bb = undefined;
^^^^^^^^^^^^^^^^^^^

Change-Id: Iaf032b5249ec655e151331e81532e549c12bcd78"," void GenStruct(const Parser &parser, StructDef &struct_def,
 code += "" /**\n"";
 code += "" * @type {flatbuffers.ByteBuffer}\n"";
 code += "" */\n"";
- code += "" this.bb = undefined;\n"";
+ code += "" this.bb = null;\n"";
 code += ""\n"";
 code += "" /**\n"";
 code += "" * @type {number}\n"";
",985,216
"Adding support for s390x (#4297)

* changes to support s390x

* added flag for s390x

* Adding support for Linux s390x","
 
 // The wire format uses a little endian encoding (since that's efficient for
 // the common platforms).
+#if defined(__s390x__)
+ #define FLATBUFFERS_LITTLEENDIAN 0
+#endif // __s390x__
 #if !defined(FLATBUFFERS_LITTLEENDIAN)
 #if defined(__GNUC__) || defined(__clang__)
 #ifdef __BIG_ENDIAN__
",1094,307
"[C++] Fix code gen indentation when empty Print (#4313)

* Fix C++ code gen indentation when empty Print

* Also commit modified tests/monster_test.bfbs"," class FlatBufPrinter : public grpc_generator::Printer {
 }
 
 void Print(const char *s) {
+ if (s == nullptr || std::strlen(s) == 0) {
+ return;
+ }
 // Add this string, but for each part separated by \n, add indentation.
 for (;;) {
 // Current indentation.
",249,69
"Made codegen always output a file, even on an empty schema.

Previously, we had a check to simply skip such files, but this
tends to make build systems unhappy.

This only affects C++ and JS, since other language output per-class
files.

Change-Id: I54224642725bbafb9f6e1654ed3693e62ca9f7d7
Tested: on Linux."," class BaseGenerator {
 
 static const char *FlatBuffersGeneratedWarning();
 
- bool IsEverythingGenerated() const;
-
 static std::string FullNamespace(const char *separator, const Namespace &ns);
 
 static std::string LastNamespacePart(const Namespace &ns);
",64,7
"C#: Added <autogenerated> in cs generator file header comment (#4291)

* Added <autogenerated> in cs generator file header comment
#4287

* CS: Added xml-correct file header comment including ""<auto-generated>...</auto-generated>""
code_generators.cpp: FlatBuffersGeneratedWarning() function replaced by compile time constant ""GeneratedWarning""
 also removed extra newlines at end of GeneratedWarning to be able to generate a xml well formed file comment for cs files
#4291

* code_generators: Changed static string GeneratedWarning back to function FlatBuffersGeneratedWarning()
#4291

* Added modified Unit-Test files
#4291

* idl_gen_general: Add autogenerated only in C# code
#4291"," void CodeWriter::operator+=(std::string text) {
 
 const char *BaseGenerator::FlatBuffersGeneratedWarning() {
 return ""automatically generated by the FlatBuffers compiler,""
- "" do not modify\n\n"";
+ "" do not modify"";
 }
 
 std::string BaseGenerator::NamespaceDir(const Parser &parser,
",114,36
"added check for presence of required fields. (flatc) c++ (#4316)

* added check for presence of required fields.

* updates to resolve Travis CI build error.

* fixes for resolving appveyor build errors.

* fixes for resolving appveyor build errors.

* fixes for resolving appveyor build errors.

* updates per aardappel's comments.

* updated a variable's name.

* updates per aardappel's comments."," CheckedError Parser::ParseTable(const StructDef &struct_def, std::string *value,
 EXPECT(',');
 }
 
+ // Check if all required fields are parsed.
+ for (auto field_it = struct_def.fields.vec.begin();
+ field_it != struct_def.fields.vec.end();
+ ++field_it) {
+ auto required_field = *field_it;
+ if (!required_field->required) {
+ continue;
+ }
+ bool found = false;
+ for (auto pf_it = field_stack_.end() - fieldn;
+ pf_it != field_stack_.end();
+ ++pf_it) {
+ auto parsed_field = pf_it->second;
+ if (parsed_field == required_field) {
+ found = true;
+ break;
+ }
+ }
+ if (!found) {
+ return Error(""required field is missing: "" + required_field->name + "" in "" + struct_def.name);
+ }
+ }
+
 if (struct_def.fixed && fieldn != struct_def.fields.vec.size())
 return Error(""struct: wrong number of initializers: "" + struct_def.name);
 
",1934,584
"Standardized internal path handling on Posix separators.

There were several possible bugs involving paths not being
recognized as being the same on Windows. Rather than trying
to ensure all code deals with / and \ correctly, paths now
get transformed to / on input, fixing all current and
future such bugs.

Tested: on OS X."," class Parser : public ParserState {
 // directory.
 // If the source was loaded from a file and isn't an include file,
 // supply its name in source_filename.
+ // All paths specified in this call must be in posix format, if you accept
+ // paths from user input, please call PosixPath on them first.
 bool Parse(const char *_source, const char **include_paths = nullptr,
 const char *source_filename = nullptr);
 
",478,43
"Fixed --keep-prefix functionality.

Changing to keep include prefixes had two side effects: the main
file being parsed wasn't filtered out anymore, and include directory
paths would be added to the path in the include statement.

Also moved the include_test*.fbs files to sub directories so we
can actually test the handling of -I etc.

tested: on Linux.

Change-Id: Ibae095cea7ab0cccbac15cfb5171719f6b5cad8c"," private:
 FLATBUFFERS_CHECKED_ERROR SkipJsonString();
 FLATBUFFERS_CHECKED_ERROR DoParse(const char *_source,
 const char **include_paths,
- const char *source_filename);
+ const char *source_filename,
+ const char *include_filename);
 FLATBUFFERS_CHECKED_ERROR CheckClash(std::vector<FieldDef*> &fields,
 StructDef *struct_def,
 const char *suffix,
",479,43
"Track included files in PATH-agnostic way. (#4329)

* Track included files in PATH-agnostic way.

Use full paths as keys in the map of included files. Store logical
include path as a value, in order to put it to the generated file.

* Fix tests by accepting null |include_filename|.

* Fix self-includes code generators."," private:
 std::string file_identifier_;
 std::string file_extension_;
 
- std::map<std::string, bool> included_files_;
+ std::map<std::string, std::string> included_files_;
 std::map<std::string, std::set<std::string>> files_included_per_file_;
 std::vector<std::string> native_included_files_;
 
",479,43
"refactor flatbuffers.h and util.h so FlexBuffers do not depend on flatbuffers.h (#4331)

FlexBuffers are actually completely unrelated to FlatBuffers and can be used separately.
However, since they utilize several utility functions from flatbuffer.h, they require this header file, which creates unreasonable dependency.
By moving those utility functions to separate base header, both libraries can use same code but still be independent","
 
 #include <map>
 // We use the basic binary writing functions from the regular FlatBuffers.
-#include ""flatbuffers/flatbuffers.h""
 #include ""flatbuffers/util.h""
 
 #ifdef _MSC_VER
",1004,323
"Disallowing field name same as table name.

Change-Id: I4b5d822cc4eda975949d1b7cf33674c5bbf9d4b1
Tested: on Linux."," CheckedError Parser::AddField(StructDef &struct_def, const std::string &name,
 
 CheckedError Parser::ParseField(StructDef &struct_def) {
 std::string name = attribute_;
+
+ if (name == struct_def.name)
+ return Error(""field name can not be the same as table/struct name"");
+
 std::vector<std::string> dc = doc_comment_;
 EXPECT(kTokenIdentifier);
 EXPECT(':');
",1938,586
"[C++] Remove std::move around a raw pointer in flatbuffers.h (#4339)

* Remove std::move around a raw pointer

Calling std::move on a raw pointer has no advantage to just copying its value. Moreover, it is confusing, because it indicates that the argument is movable in some non-trivial way (e.g., is it actually meant to be a smart pointer?). More context in https://crbug.com/729393.

* Remove the move constructor altogether"," public:
 VectorIterator(const uint8_t *data, uoffset_t i) :
 data_(data + IndirectHelper<T>::element_stride * i) {}
 VectorIterator(const VectorIterator &other) : data_(other.data_) {}
- #ifndef FLATBUFFERS_CPP98_STL
- VectorIterator(VectorIterator &&other) : data_(std::move(other.data_)) {}
- #endif
 
 VectorIterator &operator=(const VectorIterator &other) {
 data_ = other.data_;
",1155,317
"Generate a C++ function for EnumValues{{ENUM_NAME}} (#4337)

* enables ""for each"" logic on enumeration types"," enum Color {
 Color_MAX = Color_Blue
 };
 
+inline Color (&EnumValuesColor())[3] {
+ static Color values[] = {
+ Color_Red,
+ Color_Green,
+ Color_Blue
+ };
+ return values;
+}
+
 inline const char **EnumNamesColor() {
 static const char *names[] = {
 ""Red"",
 enum Equipment {
 Equipment_MAX = Equipment_Weapon
 };
 
+inline Equipment (&EnumValuesEquipment())[2] {
+ static Equipment values[] = {
+ Equipment_NONE,
+ Equipment_Weapon
+ };
+ return values;
+}
+
 inline const char **EnumNamesEquipment() {
 static const char *names[] = {
 ""NONE"",
",564,136
"[C++] Remove std::iterator usage (#4340) (#4341)

* [C++] Remove std::iterator usage (#4340)

Inheriting from std::iterator has never been required, and it's
deprecated in C++17. It can be replaced by directly providing typedefs.

Include <iterator> for std::random_access_iterator_tag.

Note that structs default to public access control.

* [C++] Change whitespace style in typedefs.","
 #include <vector>
 #include <set>
 #include <algorithm>
+#include <iterator>
 #include <memory>
 
 #ifdef _STLPORT_VERSION
",40,6
"[cpp] Json parsing: adding support for parsing nested lists and top level lists (#4338)

* Extended json parsing capability: add support for parsing nested lists and top level lists

* Stylistic conformance with surrounding code + generalized comments

* More code tidy-up for stylistic conformance with surrounding code

* Blank lines

* Reverted changes related to top-level list parsing

* Styling: newline before else

* Taking out ProcessTableFields which is no longer needed as the top level list change was reverted."," void ValueTest() {
 12335089644688340133ULL);
 }
 
+void NestedListTest() {
+ flatbuffers::Parser parser1;
+ TEST_EQ(parser1.Parse(""struct Test { a:short; b:byte; } table T { F:[Test]; }""
+ ""root_type T;""
+ ""{ F:[ [10,20], [30,40]] }""), true);
+}
+
 void EnumStringsTest() {
 flatbuffers::Parser parser1;
 TEST_EQ(parser1.Parse(""enum E:byte { A, B, C } table T { F:[E]; }""
",1150,113
Fix memory leak in Message move operator (#4344)," class Message {
 Message(const Message &other) = delete;
 
 Message &operator=(Message &&other) {
+ grpc_slice_unref(slice_);
 slice_ = other.slice_;
 other.slice_ = grpc_empty_slice();
 return *this;
",151,29
"Added nested FlexBuffer parsing

Change-Id: I918b66eb5646d035e3aae675f745802eb54b03ea"," class Parser : public ParserState {
 explicit Parser(const IDLOptions &options = IDLOptions())
 : root_struct_def_(nullptr),
 opts(options),
+ uses_flexbuffers_(false),
 source_(nullptr),
 anonymous_counter(0) {
 // Just in case none are declared:
 class Parser : public ParserState {
 known_attributes_[""native_inline""] = true;
 known_attributes_[""native_type""] = true;
 known_attributes_[""native_default""] = true;
+ known_attributes_[""flexbuffer""] = true;
 }
 
 ~Parser() {
 private:
 std::map<std::string, bool> known_attributes_;
 
 IDLOptions opts;
+ bool uses_flexbuffers_;
 
 private:
 const char *source_;
",482,43
"Added (nested) FlexBuffer JSON parsing and output.

FlexBuffer parser is just 40 lines of code (on top of existing parser!).

Change-Id: Idebebadafb661ca5333f5621139031f6df3c3e1a
Tested: on Linux."," class CppGenerator : public BaseGenerator {
 code_ += "" }"";
 }
 
- if (field.attributes.Lookup(""flexbuffer"")) {
+ if (field.flexbuffer) {
 code_ += "" flexbuffers::Reference {{FIELD_NAME}}_flexbuffer_root()""
 "" const {"";
 code_ += "" auto v = {{FIELD_NAME}}();"";
",1822,385
"gRPC: fix memory leak (#4351)

SerializationTraits<T>::Deserialize _transfers_ ownership of the buffer,
so we must destroy it.

This commit also includes some misc fixes:
- Use grpc::Status::OK rather than default ctor for clarity.
- Check for a null buffer passed into Deserialize, and handle it the
 same way as the protobuf deserializer."," class SerializationTraits<flatbuffers::grpc::Message<T>> {
 // `grpc_byte_buffer`, incrementing the refcount in the process.
 *buffer = grpc_raw_byte_buffer_create(slice, 1);
 *own_buffer = true;
- return grpc::Status();
+ return grpc::Status::OK;
 }
 
 // Deserialize by pulling the
 static grpc::Status Deserialize(grpc_byte_buffer *buffer,
 flatbuffers::grpc::Message<T> *msg) {
+ if (!buffer) {
+ return ::grpc::Status(::grpc::StatusCode::INTERNAL, ""No payload"");
+ }
 // Check if this is a single uncompressed slice.
 if ((buffer->type == GRPC_BB_RAW) &&
 (buffer->data.raw.compression == GRPC_COMPRESS_NONE) &&
 class SerializationTraits<flatbuffers::grpc::Message<T>> {
 // We wrap a `Message<T>` around the slice, but dont increment refcount
 *msg = flatbuffers::grpc::Message<T>(slice, false);
 }
+ grpc_byte_buffer_destroy(buffer);
 #if FLATBUFFERS_GRPC_DISABLE_AUTO_VERIFICATION
 return ::grpc::Status::OK;
 #else
",155,30
"Fixed build error in Visual Studio 2017 (#4353)

flatbuffers.h(591): error C2220: warning treated as error - no 'object' file generated
flatbuffers.h(591): warning C4267: 'return': conversion from 'size_t' to 'flatbuffers::uoffset_t', possible loss of data"," class vector_downward {
 return static_cast<uoffset_t>(reserved_ - (cur_ - buf_));
 }
 
- uoffset_t capacity() const {
+ size_t capacity() const {
 return reserved_;
 }
 
",1184,324
"Fixed missing lambda return type.

Change-Id: I48d41a240c8bf362b1f931f20a3ed9ae64f2d295"," CheckedError Parser::ParseVectorDelimiters(size_t &count,
 
 CheckedError Parser::ParseVector(const Type &type, uoffset_t *ovalue) {
 size_t count = 0;
- auto err = ParseVectorDelimiters(count, [&]() {
+ auto err = ParseVectorDelimiters(count, [&]() -> CheckedError {
 Value val;
 val.type = type;
 ECHECK(ParseAnyValue(val, nullptr, 0, nullptr));
",2021,596
"Added convenient schema registry.

Change-Id: I9d71375059369fbc538d0d051d8d2885e467bf29
Tested: on Mac OS X."," class DefaultAllocator : public Allocator {
 // the DetachedBuffer can manage the memory lifetime.
 class DetachedBuffer {
 public:
+ DetachedBuffer() : allocator_(nullptr), own_allocator_(false), buf_(nullptr),
+ reserved_(0), cur_(nullptr), size_(0) {}
+
 DetachedBuffer(Allocator *allocator, bool own_allocator, uint8_t *buf,
 size_t reserved, uint8_t *cur, size_t sz)
 : allocator_(allocator), own_allocator_(own_allocator), buf_(buf),
 class DetachedBuffer {
 : allocator_(other.allocator_), own_allocator_(other.own_allocator_),
 buf_(other.buf_), reserved_(other.reserved_), cur_(other.cur_),
 size_(other.size_) {
- assert(allocator_);
 other.allocator_ = nullptr;
 other.own_allocator_ = false;
 other.buf_ = nullptr;
 class DetachedBuffer {
 }
 
 const uint8_t *data() const {
- assert(cur_);
 return cur_;
 }
 
 uint8_t *data() {
- assert(cur_);
 return cur_;
 }
 
 size_t size() const {
- assert(cur_);
 return size_;
 }
 
",1182,325
"Initial support for parsing (and generating) Protobuf ASCII.

Change-Id: I955b4b3eed27f26773d7dc0acceff13c88d1333d
Tested: on Linux."," struct IDLOptions {
 bool skip_flatbuffers_import;
 std::string go_namespace;
 bool reexport_ts_modules;
+ bool protobuf_ascii_alike;
 
 // Possible options for the more general generator below.
 enum Language {
 struct IDLOptions {
 binary_schema_comments(false),
 skip_flatbuffers_import(false),
 reexport_ts_modules(true),
+ protobuf_ascii_alike(false),
 lang(IDLOptions::kJava),
 lang_to_generate(0) {}
 };
 private:
 FieldDef **dest);
 FLATBUFFERS_CHECKED_ERROR ParseField(StructDef &struct_def);
 FLATBUFFERS_CHECKED_ERROR ParseString(Value &val);
+ FLATBUFFERS_CHECKED_ERROR ParseComma();
 FLATBUFFERS_CHECKED_ERROR ParseAnyValue(Value &val, FieldDef *field,
 size_t parent_fieldn,
 const StructDef *parent_struct_def);
",496,43
"Added move assignment operator to DetachedBuffer.

Change-Id: I4610946ac27d9d0d73c2fc2e4834bd2cfed88cdc
Tested: on Linux."," class DetachedBuffer {
 other.size_ = 0;
 }
 
+ DetachedBuffer &operator=(DetachedBuffer &&other) {
+ std::swap(allocator_, other.allocator_);
+ std::swap(own_allocator_, other.own_allocator_);
+ std::swap(buf_, other.buf_);
+ std::swap(reserved_, other.reserved_);
+ std::swap(cur_, other.cur_);
+ std::swap(size_, other.size_);
+ return *this;
+ }
+
 ~DetachedBuffer() {
 if (buf_) {
 assert(allocator_);
",1194,327
"Updated version numbers to 1.7.0

Change-Id: If2802ca48b61cfa7e5ec131e2a268400523217e2","
 #endif // !defined(FLATBUFFERS_LITTLEENDIAN)
 
 #define FLATBUFFERS_VERSION_MAJOR 1
-#define FLATBUFFERS_VERSION_MINOR 6
+#define FLATBUFFERS_VERSION_MINOR 7
 #define FLATBUFFERS_VERSION_REVISION 0
 #define FLATBUFFERS_STRING_EXPAND(X) #X
 #define FLATBUFFERS_STRING(X) FLATBUFFERS_STRING_EXPAND(X)
",40,6
"Avoiding wrong template specialization on new CreateVector

Change-Id: I0da57cc71318ea13c10b547e2dfe3a2d4f32b4d9
Tested: on OS X."," class FlatBufferBuilder
 /// @return Returns a typed `Offset` into the serialized data indicating
 /// where the vector is stored.
 template<typename T> Offset<Vector<T>> CreateVector(const T *v, size_t len) {
+ // If this assert hits, you're specifying a template argument that is
+ // causing the wrong overload to be selected, remove it.
+ AssertScalarT<T>();
 StartVector(len, sizeof(T));
 #if FLATBUFFERS_LITTLEENDIAN
 PushBytes(reinterpret_cast<const uint8_t *>(v), len * sizeof(T));
",1203,330
"Make flatbuffers work with ArduinoSTL (#4357) (#4361)

*Keep legacy compatibility with StandardCplusplus lib (utility.h)","
 #include <cstdlib>
 #include <cstring>
 #include <string>
-#ifndef ARDUINO
-#include <utility>
-#else
+#if defined(ARDUINO) && !defined(ARDUINOSTL_M_H)
 #include <utility.h>
+#else
+#include <utility>
 #endif
 #include <type_traits>
 #include <vector>
",40,6
Make inter-file cycles compile (#4364)," private:
 FLATBUFFERS_CHECKED_ERROR ParseFlexBufferValue(flexbuffers::Builder *builder);
 FLATBUFFERS_CHECKED_ERROR StartParseFile(const char *source,
 const char *source_filename);
- FLATBUFFERS_CHECKED_ERROR DoParse(const char *_source,
+ FLATBUFFERS_CHECKED_ERROR ParseRoot(const char *_source,
 const char **include_paths,
- const char *source_filename,
- const char *include_filename);
+ const char *source_filename);
+ FLATBUFFERS_CHECKED_ERROR DoParse(const char *_source,
+ const char **include_paths,
+ const char *source_filename,
+ const char *include_filename);
 FLATBUFFERS_CHECKED_ERROR CheckClash(std::vector<FieldDef*> &fields,
 StructDef *struct_def,
 const char *suffix,
",499,43
"Java: Added ByteBufferFactory interface and sizedInputStream method. (#4379)

The ByteBufferFactory interface gives the user an option to specify
the method in which the internal ByteBuffer is allocated. This provides
flexibility in the type of ByteBuffer that can be used.
The sizedInputStream method is an alternative to sizedByteArray that
does not make a copy of the data in memory."," void GenStructBody(const StructDef &struct_def, std::string *code_ptr,
 std::string GenByteBufferLength(const char *bb_name) {
 std::string bb_len = bb_name;
 if (lang_.language == IDLOptions::kCSharp) bb_len += "".Length"";
- else bb_len += "".array().length"";
+ else bb_len += "".capacity()"";
 return bb_len;
 }
 
",1242,290
"idl_parser.cpp ignores $schema in input json (#4382)

* idl_parser.cpp ignores $schema in input json
#4381

* idl_parser.cpp: Fixed ci error signed unsigned comparison

* idl_parser.cpp: replaced case insensitive search for $schema with case sensitive search

* idl_parser.cpp: Expecting a string constant after $schema
#4382"," CheckedError Parser::ParseTable(const StructDef &struct_def, std::string *value,
 size_t fieldn = 0;
 auto err = ParseTableDelimiters(fieldn, &struct_def,
 [&](const std::string &name) -> CheckedError {
+ if (name == ""$schema"") {
+ EXPECT(kTokenStringConstant);
+ return NoError();
+ }
 auto field = struct_def.fields.Lookup(name);
 if (!field) {
 if (!opts.skip_unexpected_fields_in_json) {
",2037,604
forwarding IDLOptions.strict_json to flexbuffers .ToString() (#4394)," static bool GenFieldOffset(const FieldDef &fd, const Table *table, bool fixed,
 } else if (fd.flexbuffer) {
 auto vec = table->GetPointer<const Vector<uint8_t> *>(fd.value.offset);
 auto root = flexbuffers::GetRoot(vec->data(), vec->size());
- root.ToString(true, false, *_text);
+ root.ToString(true, opts.strict_json, *_text);
 return true;
 } else {
 val = IsStruct(fd.value.type)
",236,58
"Test case for CreateVectorOfStructs() using a callback.

Fixes issue #4392, also fixed C++98 compatible code generation in tests.

Change-Id: Ia5833026e615ad19d24a0439bdba2e3b45c5f86c"," class FlatBufferBuilder
 private:
 // Allocates space for a vector of structures.
 // Must be completed with EndVectorOfStructs().
- template<typename T> const T* StartVectorOfStructs(size_t vector_size) {
+ template<typename T> T* StartVectorOfStructs(size_t vector_size) {
 StartVector(vector_size * sizeof(T) / AlignOf<T>(), AlignOf<T>());
 return reinterpret_cast<T *>(buf_.make_space(vector_size * sizeof(T)));
 }
",1226,336
Adding accessors for IsBlob and Blob.data (#4398)," class String : public Sized {
 
 class Blob : public Sized {
 public:
- Blob(const uint8_t *data, uint8_t byte_width)
- : Sized(data, byte_width) {}
+ Blob(const uint8_t *data_buf, uint8_t byte_width)
+ : Sized(data_buf, byte_width) {}
 
 static Blob EmptyBlob() {
 static const uint8_t empty_blob[] = { 0/*len*/ };
 return Blob(empty_blob + 1, 1);
 }
 bool IsTheEmptyBlob() const { return data_ == EmptyBlob().data_; }
+ const uint8_t *data() const { return data_; }
 };
 
 class Vector : public Sized {
 class Reference {
 bool IsKey() const { return type_ == TYPE_KEY; }
 bool IsVector() const { return type_ == TYPE_VECTOR || type_ == TYPE_MAP; }
 bool IsMap() const { return type_ == TYPE_MAP; }
+ bool IsBlob() const { return type_ == TYPE_BLOB; }
 
 // Reads any type as a int64_t. Never fails, does most sensible conversion.
 // Truncates floats, strings are attempted to be parsed for a number,
",1087,339
"[Python] (scalar) vector reading speedup via numpy (#4390)

* Add numpy accessor to python flatbuffers scalar vectors

* Update python tests to test numpy vector accessor

* Update appveyor CI to run Python tests, save generated code as artifact

* Update example generated python code

* Add numpy info to python usage docs

* Update test schema and python tests w/ multi-byte vector

* did not mean to push profiling code

* adding float64 numpy tests"," import collections
 import struct
 
 from . import packer
+from .compat import import_numpy, NumpyRequiredForThisFeature
 
+np = import_numpy()
 
 # For reference, see:
 # https://docs.python.org/2/library/ctypes.html#ctypes-fundamental-data-types-2
 def uint64_to_float64(n):
 packed = struct.pack(""<1Q"", n)
 (unpacked,) = struct.unpack(""<1d"", packed)
 return unpacked
+
+
+def to_numpy_type(number_type):
+ if np is not None:
+ return np.dtype(number_type.name).newbyteorder('<')
+ else:
+ raise NumpyRequiredForThisFeature('Numpy was not found.')
",118,13
"Add scalar type aliases for int8, uint8, ..., f32, f64 (#4400)

* Add type aliases

* Add generated code

* Rebase master"," class CppGenerator : public BaseGenerator {
 // Return a C++ type from the table in idl.h
 std::string GenTypeBasic(const Type &type, bool user_facing_type) const {
 static const char *ctypename[] = {
- #define FLATBUFFERS_TD(ENUM, IDLTYPE, CTYPE, JTYPE, GTYPE, NTYPE, PTYPE) \
+ #define FLATBUFFERS_TD(ENUM, IDLTYPE, ALIASTYPE, CTYPE, JTYPE, GTYPE, NTYPE, PTYPE) \
 #CTYPE,
 FLATBUFFERS_GEN_TYPES(FLATBUFFERS_TD)
 #undef FLATBUFFERS_TD
",1837,385
"[c++] Add support for boolean types in flexbuffers (#4386)

* Add support for boolean types in flexbuffers

* Simplify casting number <=> boolean

* Added comments for tests

* Add proper support for Booleans

* Bad rebase

* No special case for strings

* Removed unused test

* Simplify logic"," inline bool IsFloat (BaseType t) { return t == BASE_TYPE_FLOAT ||
 t == BASE_TYPE_DOUBLE; }
 inline bool IsLong (BaseType t) { return t == BASE_TYPE_LONG ||
 t == BASE_TYPE_ULONG; }
+inline bool IsBool (BaseType t) { return t == BASE_TYPE_BOOL; }
 
 extern const char *const kTypeNames[];
 extern const char kTypeSizes[];
",520,44
"Public accessor for buffer size of flexbuffers::Builder

Change-Id: Iff7895aebeba9c2940e26a3edbdf2d3f1b0d9b17"," class Builder FLATBUFFERS_FINAL_CLASS {
 return buf_;
 }
 
+ // Size of the buffer. Does not include unfinished values.
+ size_t GetSize() const {
+ return buf_.size();
+ }
+
 // Reset all state so we can re-use the buffer.
 void Clear() {
 buf_.clear();
",1106,353
"Fixed clang-tidy warnings.

Change-Id: Ib94ef29254c116b60e4ff298baa2ce323ac9655c
Tested: on Linux."," private:
 size_t &count, ParseVectorDelimitersBody body, void *state);
 FLATBUFFERS_CHECKED_ERROR ParseVector(const Type &type, uoffset_t *ovalue);
 FLATBUFFERS_CHECKED_ERROR ParseNestedFlatbuffer(Value &val, FieldDef *field,
- size_t parent_fieldn,
+ size_t fieldn,
 const StructDef *parent_struct_def);
 FLATBUFFERS_CHECKED_ERROR ParseMetaData(SymbolTable<Value> *attributes);
 FLATBUFFERS_CHECKED_ERROR TryTypedValue(int dtoken, bool check, Value &e,
",520,44
"Make it an error if a field has the same name as a table.

Change-Id: Ie5a3bb5a3643cd48e1cc75fe170a7b8a7c2cc8ed
Tested: on Linux."," CheckedError Parser::AddField(StructDef &struct_def, const std::string &name,
 CheckedError Parser::ParseField(StructDef &struct_def) {
 std::string name = attribute_;
 
- if (name == struct_def.name)
+ if (structs_.Lookup(name))
 return Error(""field name can not be the same as table/struct name"");
 
 std::vector<std::string> dc = doc_comment_;
",2119,610
"Added missing generated code.

Change-Id: I7201d6891f56094178656a76bf0f87cf36d12554","
 <?php
 // automatically generated by the FlatBuffers compiler, do not modify
 
-namespace ;
-
 use \Google\FlatBuffers\Struct;
 use \Google\FlatBuffers\Table;
 use \Google\FlatBuffers\ByteBuffer;
",51,10
Added VS crtdbg memory leak tracking,"
 #ifndef FLATBUFFERS_BASE_H_
 #define FLATBUFFERS_BASE_H_
 
+#if defined(_MSC_VER) && defined(_DEBUG)
+ #define _CRTDBG_MAP_ALLOC
+#endif
+
 #include <assert.h>
 
 #ifndef ARDUINO
 #include <cstdint>
 #endif
+
 #include <cstddef>
 #include <cstdlib>
 #include <cstring>
-#include <string>
+
+#if defined(_MSC_VER) && defined(_DEBUG)
+ #include <crtdbg.h>
+ #define DEBUG_NEW new(_NORMAL_BLOCK, __FILE__, __LINE__)
+ #define new DEBUG_NEW
+#endif
+
 #if defined(ARDUINO) && !defined(ARDUINOSTL_M_H)
-#include <utility.h>
+ #include <utility.h>
 #else
-#include <utility>
+ #include <utility>
 #endif
+
+#include <string>
 #include <type_traits>
 #include <vector>
 #include <set>

 #endif
 
 #if defined(_MSC_VER)
-#pragma warning(push)
-#pragma warning(disable: 4127) // C4127: conditional expression is constant
+ #pragma warning(push)
+ #pragma warning(disable: 4127) // C4127: conditional expression is constant
 #endif
 
 /// @endcond
",42,6
"C++ Add new type vector_bool flexbuffers (#4410)

* Add new type vector_bool

* Update stl_emulation.h

Fix Is same typo

* Update stl_emulation.h"," enum Type {
 TYPE_VECTOR_FLOAT4 = 24,
 TYPE_BLOB = 25,
 TYPE_BOOL = 26,
+ TYPE_VECTOR_BOOL = 36, // To Allow the same type of conversion of type to vector type
 };
 
 inline bool IsInline(Type t) { return t <= TYPE_FLOAT || t == TYPE_BOOL; }
 
 inline bool IsTypedVectorElementType(Type t) {
- return t >= TYPE_INT && t <= TYPE_STRING;
+ return (t >= TYPE_INT && t <= TYPE_STRING) || t == TYPE_BOOL;
 }
 
 inline bool IsTypedVector(Type t) {
- return t >= TYPE_VECTOR_INT && t <= TYPE_VECTOR_STRING;
+ return (t >= TYPE_VECTOR_INT && t <= TYPE_VECTOR_STRING) || t == TYPE_VECTOR_BOOL;
 }
 
 inline bool IsFixedTypedVector(Type t) {
 class Builder FLATBUFFERS_FINAL_CLASS {
 assert(flatbuffers::is_scalar<T>::value);
 return flatbuffers::is_floating_point<T>::value
 ? TYPE_FLOAT
- : (flatbuffers::is_unsigned<T>::value ? TYPE_UINT : TYPE_INT);
+ : flatbuffers::is_same<T, bool>::value ? TYPE_BOOL
+ : (flatbuffers::is_unsigned<T>::value ? TYPE_UINT : TYPE_INT);
 }
 
 struct Value {
",1108,356
"Fixed root_type leaking in from included files.

Change-Id: I9378e375901f8a883eaeb2182955d690c358ed4b
Tested: on Linux."," CheckedError Parser::DoParse(const char *source,
 name.c_str()));
 // We generally do not want to output code for any included files:
 if (!opts.generate_all) MarkGenerated();
+ // Reset root type just in case the included file had one, and the
+ // parent doesn't.
+ root_struct_def_ = nullptr;
 // This is the easiest way to continue this file after an include:
 // instead of saving and restoring all the state, we simply start the
 // file anew. This will cause it to encounter the same include
",2127,613
"Fixed file_identifier/extension leaking from included file.

Change-Id: I470143411e4ce6322e018a27bcc9cd40c15d9bf1
Tested: on Linux."," CheckedError Parser::DoParse(const char *source,
 name.c_str()));
 // We generally do not want to output code for any included files:
 if (!opts.generate_all) MarkGenerated();
- // Reset root type just in case the included file had one, and the
+ // Reset these just in case the included file had them, and the
 // parent doesn't.
 root_struct_def_ = nullptr;
+ file_identifier_.clear();
+ file_extension_.clear();
 // This is the easiest way to continue this file after an include:
 // instead of saving and restoring all the state, we simply start the
 // file anew. This will cause it to encounter the same include
",2129,613
"Missing FieldDef initializer.

Change-Id: I5ed1f77868e201d7231102a106e08f3376b6adcf"," struct Definition {
 
 struct FieldDef : public Definition {
 FieldDef() : deprecated(false), required(false), key(false),
- flexbuffer(false), nested_flatbuffer(NULL), padding(0) {}
+ native_inline(false), flexbuffer(false), nested_flatbuffer(NULL),
+ padding(0) {}
 
 Offset<reflection::Field> Serialize(FlatBufferBuilder *builder, uint16_t id,
 const Parser &parser) const;
",522,44
Fix use of min and max when Windows.h is imported (#4411)," class FlatBufferBuilder
 auto stra = reinterpret_cast<const String *>(buf_->data_at(a.o));
 auto strb = reinterpret_cast<const String *>(buf_->data_at(b.o));
 return strncmp(stra->c_str(), strb->c_str(),
- std::min(stra->size(), strb->size()) + 1) < 0;
+ (std::min)(stra->size(), strb->size()) + 1) < 0;
 }
 const vector_downward *buf_;
 };
 inline const uint8_t *GetBufferStartFromRootPointer(const void *root) {
 auto table = reinterpret_cast<const Table *>(root);
 auto vtable = table->GetVTable();
 // Either the vtable is before the root or after the root.
- auto start = std::min(vtable, reinterpret_cast<const uint8_t *>(root));
+ auto start = (std::min)(vtable, reinterpret_cast<const uint8_t *>(root));
 // Align to at least sizeof(uoffset_t).
 start = reinterpret_cast<const uint8_t *>(
 reinterpret_cast<uintptr_t>(start) & ~(sizeof(uoffset_t) - 1));
",1226,336
"Trimmed vtables of trailing zeroes.

This is something the format supports, but none of the builders
were doing. Can save 10-20% on FlatBuffer binary size!

Also fixed the Go tests.

Change-Id: I616c56ce9bbcfcaee23aa24f0532fcb60b6a8c75
Tested: on Linux."," func (b *Builder) WriteVtable() (n UOffsetT) {
 objectOffset := b.Offset()
 existingVtable := UOffsetT(0)
 
+// Trim vtable of trailing zeroes.
+i := len(b.vtable) - 1;
+for ; i >= 0 && b.vtable[i] == 0; i-- {}
+b.vtable = b.vtable[:i + 1];
+
 // Search backwards through existing vtables, because similar vtables
 // are likely to have been recently appended. See
 // BenchmarkVtableDeduplication for a case in which this heuristic
",448,112
"Cleaned up namespace handling.

A Namespace object is now guaranteed unique.
This cleaned up some old workarounds and latent bugs.

Change-Id: Ic3f12d89947871b03b2c449ba51b3186f953adde
Tested: on Linux.
Bug: 21336857"," class GeneralGenerator : public BaseGenerator {
 GeneralGenerator &operator=(const GeneralGenerator &);
 bool generate() {
 std::string one_file_code;
- cur_name_space_ = parser_.namespaces_.back();
+ cur_name_space_ = parser_.current_namespace_;
 
 for (auto it = parser_.enums_.vec.begin(); it != parser_.enums_.vec.end();
 ++it) {
 class GeneralGenerator : public BaseGenerator {
 }
 
 if (parser_.opts.one_file) {
- return SaveType(file_name_, *parser_.namespaces_.back(),
+ return SaveType(file_name_, *parser_.current_namespace_,
 one_file_code, true);
 }
 return true;
",1239,290
Fixed VS memory tracking leaking into user code,"
 #ifndef FLATBUFFERS_BASE_H_
 #define FLATBUFFERS_BASE_H_
 
-#if defined(_MSC_VER) && defined(_DEBUG)
+#if defined(FLATBUFFERS_MEMORY_LEAK_TRACKING) && \
+ defined(_MSC_VER) && defined(_DEBUG)
 #define _CRTDBG_MAP_ALLOC
 #endif
 

 #include <cstdlib>
 #include <cstring>
 
-#if defined(_MSC_VER) && defined(_DEBUG)
+#if defined(FLATBUFFERS_MEMORY_LEAK_TRACKING) && \
+ defined(_MSC_VER) && defined(_DEBUG)
 #include <crtdbg.h>
 #define DEBUG_NEW new(_NORMAL_BLOCK, __FILE__, __LINE__)
 #define new DEBUG_NEW
",42,6
"C++ Customise prefix/suffix of object API [Issue #4419] (#4422)

* Allow prefix/suffix of C++ Object API classes to be customised

* Address review comments"," struct IDLOptions {
 bool generate_object_based_api;
 std::string cpp_object_api_pointer_type;
 std::string cpp_object_api_string_type;
+ std::string object_prefix;
+ std::string object_suffix;
 bool union_value_namespacing;
 bool allow_non_utf8;
 std::string include_prefix;
 struct IDLOptions {
 escape_proto_identifiers(false),
 generate_object_based_api(false),
 cpp_object_api_pointer_type(""std::unique_ptr""),
+ object_suffix(""T""),
 union_value_namespacing(true),
 allow_non_utf8(false),
 keep_include_path(false),
",532,44
"Every type gets additionalProperties set to ""false"" (#4424)

#4423"," class JsonSchemaGenerator : public BaseGenerator {
 } 
 code_ += typeLine;
 }
+ code_ += "" },""; // close properties
+
 std::vector<FieldDef *> requiredProperties;
 std::copy_if(properties.begin(), properties.end(),
 back_inserter(requiredProperties),
 [](FieldDef const *prop) { return prop->required; });
 if (requiredProperties.size() > 0) {
- code_ += "" },""; // close properties
- std::string required_string("" \""required\"" : [ "");
+ std::string required_string("" \""required\"" : ["");
 for (auto req_prop = requiredProperties.cbegin();
 req_prop != requiredProperties.cend();
 ++req_prop) {
 class JsonSchemaGenerator : public BaseGenerator {
 required_string.append("", "");
 }
 }
- required_string.append(""]"");
+ required_string.append(""],"");
 code_ += required_string;
- } else {
- code_ += "" }""; // close properties
 }
-
+ code_ += "" \""additionalProperties\"" : false"";
 std::string closeType("" }"");
 if (*s != parser_.structs_.vec.back()) {
 closeType.append("","");
",188,46
"Forgot to bump flatc version to 1.7.1

Change-Id: I480a08f445858bce3d0336c2b22da30d64f90012","
 
 #include <list>
 
-#define FLATC_VERSION ""1.7.0 ("" __DATE__ "")""
+#define FLATC_VERSION ""1.7.1 ("" __DATE__ "")""
 
 namespace flatbuffers {
 
",340,98
"Fixed .proto not being accepted as schema file.

Change-Id: I1ccd52a847930fa636d24f9490d57577b8775d08"," int FlatCompiler::Compile(int argc, const char** argv) {
 
 bool is_binary = static_cast<size_t>(file_it - filenames.begin()) >=
 binary_files_from;
- auto is_schema = flatbuffers::GetExtension(filename) == ""fbs"";
+ auto ext = flatbuffers::GetExtension(filename);
+ auto is_schema = ext == ""fbs"" || ext == ""proto"";
 if (is_binary) {
 parser->builder_.Clear();
 parser->builder_.PushFlatBuffer(
",341,99
idl_gen_json_schema.cpp: Fixed detection of enum types (#4438)," std::string GenType(const std::string &name) {
 }
 
 std::string GenType(const Type &type) {
- if (type.base_type == BASE_TYPE_CHAR && type.enum_def != nullptr) {
+ if (type.enum_def != nullptr && !type.enum_def->is_union) {
 // it is a reference to an enum type
 return GenTypeRef(type.enum_def);
 }
",188,46
"Add constant accessors to C++ unions (#4433)

* Add constant accessors to C++ unions

* Remove redundant const pointer return type

* Update generate_code.bat to reflect generate_code.sh

* Add updated generated files

* Remove extra space from generated code

* Update generated files

* Change directory back to tests after generating code"," struct EquipmentUnion {
 return type == Equipment_Weapon ?
 reinterpret_cast<WeaponT *>(value) : nullptr;
 }
+ const WeaponT *AsWeapon() const {
+ return type == Equipment_Weapon ?
+ reinterpret_cast<const WeaponT *>(value) : nullptr;
+ }
 };
 
 bool VerifyEquipment(flatbuffers::Verifier &verifier, const void *obj, Equipment type);
",570,138
"Added support for mini-reflection tables.

Change-Id: I83453d074685fa57bbf1c7c87b1d9392ce972085
Tested: on Linux."," struct IDLOptions {
 
 Language lang;
 
+ enum MiniReflect { kNone, kTypes, kTypesAndNames };
+
+ MiniReflect mini_reflect;
+
 // The corresponding language bit will be set if a language is included
 // for code generation.
 unsigned long lang_to_generate;
 struct IDLOptions {
 reexport_ts_modules(true),
 protobuf_ascii_alike(false),
 lang(IDLOptions::kJava),
+ mini_reflect(IDLOptions::kNone),
 lang_to_generate(0) {}
 };
 
",535,44
"Made the parser not have any hard-coded keywords.

This prevented any keywords showing up as JSON field names, for example.

Change-Id: Ie9d0cada96778e06016ca02ca96d052410a37038
Tested: on Linux."," class CppGenerator : public BaseGenerator {
 // Return a C++ type from the table in idl.h
 std::string GenTypeBasic(const Type &type, bool user_facing_type) const {
 static const char *ctypename[] = {
- #define FLATBUFFERS_TD(ENUM, IDLTYPE, ALIASTYPE, CTYPE, JTYPE, GTYPE, NTYPE, PTYPE) \
+ #define FLATBUFFERS_TD(ENUM, IDLTYPE, CTYPE, JTYPE, GTYPE, NTYPE, PTYPE) \
 #CTYPE,
 FLATBUFFERS_GEN_TYPES(FLATBUFFERS_TD)
 #undef FLATBUFFERS_TD
",2003,435
"Fixed TypeTable function not being inline.

Change-Id: Id335980daf909e885ed26a21b64623b78d01fb49
Tested: on OS X."," class CppGenerator : public BaseGenerator {
 
 void GenMiniReflectPre(const StructDef *struct_def) {
 code_.SetValue(""NAME"", struct_def->name);
- code_ += ""flatbuffers::TypeTable *{{NAME}}TypeTable();"";
+ code_ += ""inline flatbuffers::TypeTable *{{NAME}}TypeTable();"";
 code_ += """";
 }
 
 class CppGenerator : public BaseGenerator {
 code_.SetValue(""REFS"", rs);
 code_.SetValue(""NAMES"", ns);
 code_.SetValue(""VALUES"", vs);
- code_ += ""flatbuffers::TypeTable *{{NAME}}TypeTable() {"";
+ code_ += ""inline flatbuffers::TypeTable *{{NAME}}TypeTable() {"";
 if (num_fields) {
 code_ += "" static flatbuffers::TypeCode type_codes[] = {"";
 code_ += "" {{TYPES}}"";
",2003,435
"Add template version for As method. (#4443)

* Add template version for As method.

* Fix compilation error on Linux.

* Fix linux issue (2).

* Linux fix (3)

* Add few tests."," void FlexBuffersTest() {
 TEST_EQ(vec[2].AsString().IsTheEmptyString(), true); // Wrong Type.
 TEST_EQ_STR(vec[2].AsString().c_str(), """"); // This still works though.
 TEST_EQ_STR(vec[2].ToString().c_str(), ""4.0""); // Or have it converted.
+
+ // Few tests for templated version of As.
+ TEST_EQ(vec[0].As<int64_t>(), -100);
+ TEST_EQ_STR(vec[1].As<std::string>().c_str(), ""Fred"");
+ TEST_EQ(vec[1].As<int64_t>(), 0); // Number parsing failed.
+ TEST_EQ(vec[2].As<double>(), 4.0);
+
 // Test that the blob can be accessed.
 TEST_EQ(vec[3].IsBlob(), true);
 auto blob = vec[3].AsBlob();
",1326,120
"Fix issue #4389, if field is ommitted the return type is the same for (#4444)

* Fix issue #4389, if field is ommitted the return type is the same for python generator

* Fix issue #4389, bytes is returned when field is omitted

* Fix issue #4389, added generated python code after generator modification"," static void GetStringField(const StructDef &struct_def,
 code += OffsetPrefix(field);
 code += Indent + Indent + Indent + ""return "" + GenGetter(field.value.type);
 code += ""o + self._tab.Pos)\n"";
- code += Indent + Indent + ""return \""\""\n\n"";
+ code += Indent + Indent + ""return bytes()\n\n"";
 }
 
 // Get the value of a union from an object.
",555,97
Python: CreateByteVector function in builder. (#4453)," class Builder(object):
 
 return self.EndVector(len(x))
 
+ def CreateByteVector(self, x):
+ """"""CreateString writes a byte vector.""""""
+
+ self.assertNotNested()
+ ## @cond FLATBUFFERS_INTERNAL
+ self.nested = True
+ ## @endcond
+
+ if not isinstance(x, compat.binary_types):
+ raise TypeError(""non-byte vector passed to CreateByteVector"")
+
+ self.Prep(N.UOffsetTFlags.bytewidth, len(x)*N.Uint8Flags.bytewidth)
+
+ l = UOffsetTFlags.py_type(len(x))
+ ## @cond FLATBUFFERS_INTERNAL
+ self.head = UOffsetTFlags.py_type(self.Head() - l)
+ ## @endcond
+ self.Bytes[self.Head():self.Head()+l] = x
+
+ return self.EndVector(len(x))
+
 ## @cond FLATBUFFERS_INTERNAL
 def assertNested(self):
 """"""
",325,75
"[C++] Add explicit keyword on generated constructors for Builder structs (#4452)

* Add explicit keyword on C++ generated constructors for Builder structs

* Add missing generated code for review"," struct MonsterBuilder {
 void add_equipped(flatbuffers::Offset<void> equipped) {
 fbb_.AddOffset(Monster::VT_EQUIPPED, equipped);
 }
- MonsterBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+ explicit MonsterBuilder(flatbuffers::FlatBufferBuilder &_fbb)
 : fbb_(_fbb) {
 start_ = fbb_.StartTable();
 }
 struct WeaponBuilder {
 void add_damage(int16_t damage) {
 fbb_.AddElement<int16_t>(Weapon::VT_DAMAGE, damage, 0);
 }
- WeaponBuilder(flatbuffers::FlatBufferBuilder &_fbb)
+ explicit WeaponBuilder(flatbuffers::FlatBufferBuilder &_fbb)
 : fbb_(_fbb) {
 start_ = fbb_.StartTable();
 }
",676,143
"Improved .proto conversion.

- Allowed enums to be declared before use.
- Generalized parsing of `required`.
- Reworked escaping of namespaces.
- Escaping field names that are C++ keywords.
- Many smaller fixes.

Change-Id: Ie580de7b70dc208f676f4f71bb0d061808648b8d
Tested: on Linux."," std::string FlatCompiler::GetUsageString(const char* program_name) const {
 "" --gen-mutable Generate accessors that can mutate buffers in-place.\n""
 "" --gen-onefile Generate single output file for C#.\n""
 "" --gen-name-strings Generate type name functions for C++.\n""
- "" --escape-proto-ids Disable appending '_' in namespaces names.\n""
 "" --gen-object-api Generate an additional object-based API.\n""
 "" --cpp-ptr-type T Set object API pointer type (default std::unique_ptr)\n""
 "" --cpp-str-type T Set object API string type (default std::string)\n""
 int FlatCompiler::Compile(int argc, const char** argv) {
 binary_files_from = filenames.size();
 } else if(arg == ""--proto"") {
 opts.proto_mode = true;
- } else if(arg == ""--escape-proto-ids"") {
- opts.escape_proto_identifiers = true;
 } else if(arg == ""--schema"") {
 schema_binary = true;
 } else if(arg == ""-M"") {
",344,100
"_Nullable cpp interface (#4451)

* add _Nullable Support for C++ interface

* add _Nullable Support for C++ interface"," struct IDLOptions {
 bool generate_object_based_api;
 std::string cpp_object_api_pointer_type;
 std::string cpp_object_api_string_type;
+ bool clang_nullable;
 std::string object_prefix;
 std::string object_suffix;
 bool union_value_namespacing;
 struct IDLOptions {
 generate_name_strings(false),
 generate_object_based_api(false),
 cpp_object_api_pointer_type(""std::unique_ptr""),
+ clang_nullable(false),
 object_suffix(""T""),
 union_value_namespacing(true),
 allow_non_utf8(false),
",543,44
"Add new flatbuffer_go_library to generate Go library for flatbuffers

This CL also introduces the following changes to allow the generation of the
Go library for flatbuffers:

- add support for --gen-onefile for Go to simplify the build rule (mapping each
 input .fbs to a single separate .go file)

- add a new --go-import flag to override the default import line (currently
 github.com/google/flatbuffers/go)

- add new go_library in BUILD for flatbuffer (for files in flatbuffers/go)

(mirrored from cr/171126159)

Change-Id: I83e705a9a9d9544837af0baf9366ec37757799aa"," struct IDLOptions {
 bool keep_include_path;
 bool binary_schema_comments;
 bool skip_flatbuffers_import;
+ std::string go_import;
 std::string go_namespace;
 bool reexport_ts_modules;
 bool protobuf_ascii_alike;
",544,44
"Use flatbuffer unique_ptr instead of std's.

Stlport does not have std unique_ptr, so using the one provided by
flatbuffers.
Also fixing a problem with the flatbuffer unique_ptr, and a test."," struct StructDef : public Definition {
 size_t minalign; // What the whole object needs to be aligned to.
 size_t bytesize; // Size if fixed.
 
- std::unique_ptr<std::string> original_location;
+ flatbuffers::unique_ptr<std::string> original_location;
 };
 
 inline bool IsStruct(const Type &type) {
",544,44
"Nullable java (#4455)

* add _Nullable Support for C++ interface

* generate @Nullable for Java generated code"," struct IDLOptions {
 bool generate_object_based_api;
 std::string cpp_object_api_pointer_type;
 std::string cpp_object_api_string_type;
- bool clang_nullable;
+ bool gen_nullable;
 std::string object_prefix;
 std::string object_suffix;
 bool union_value_namespacing;
 struct IDLOptions {
 generate_name_strings(false),
 generate_object_based_api(false),
 cpp_object_api_pointer_type(""std::unique_ptr""),
- clang_nullable(false),
+ gen_nullable(false),
 object_suffix(""T""),
 union_value_namespacing(true),
 allow_non_utf8(false),
",544,44
"Changed how vector_data works. (#4467)

In some debug environments using vector[i] does bounds checking even
though the standard specifies that it should not. Using
*(vector.begin()) sidesteps this though, giving the same result without
the bounds checking."," inline char string_back(const std::string &value) {
 // Helper method that retrieves ::data() from a vector in a way that is
 // compatible with pre C++11 STLs (e.g stlport).
 template <typename T> inline T *vector_data(std::vector<T> &vector) {
- return &(vector[0]);
+ // In some debug environments, operator[] does bounds checking, so &vector[0]
+ // can't be used.
+ return &(*vector.begin());
 }
 
 template <typename T> inline const T *vector_data(
 const std::vector<T> &vector) {
- return &(vector[0]);
+ return &(*vector.begin());
 }
 
 template <typename T, typename V>
",130,35
"Added missing EndTable() call to VerifyObject() (#4468)

VerifyObject called VerifyTableStart() but not EndTable(). This made Verifier::VerifyComplexity() increase depth_ with each table, not with the depth of tables.

https://groups.google.com/forum/#!topic/flatbuffers/OpxtW5UFAdg"," bool VerifyObject(flatbuffers::Verifier &v,
 }
 }
 
+ if (!v.EndTable())
+ return false;
+ 
 return true;
 }
 
",604,194
"Made stl_emulation.h usable by itself.

Change-Id: I1d9d301412fe0a036f12eb2cc82a3fbee5bb838d","
 #include <string>
 #include <type_traits>
 #include <vector>
+#include <memory>
+#include <limits>
 
 #if defined(_STLPORT_VERSION) && !defined(FLATBUFFERS_CPP98_STL)
 #define FLATBUFFERS_CPP98_STL
",132,35
Fix valid params limit exceeded for generated table constructor (#4490)," void GenStruct(StructDef &struct_def, std::string *code_ptr) {
 num_fields++;
 }
 }
- if (has_no_struct_fields && num_fields) {
+ // JVM specifications restrict default constructor params to be < 255.
+ // Longs and doubles take up 2 units, so we set the limit to be < 127.
+ if (has_no_struct_fields && num_fields && num_fields < 127) {
 // Generate a table constructor of the form:
 // public static int createName(FlatBufferBuilder builder, args...)
 code += "" public static "" + GenOffsetType(struct_def) + "" "";
",1253,296
"Remove copy constructor to make flatbuffers struct trivially copyable (#4476)

* Remove copy constructor to make flatbuffers struct trivially copyable + add tests.

* Add support non c++11 compliant compilers.

* Fix std::trivially_copyiable test for non-C++11 compliant compilers.

* Fix trivially_copyable not part of glibc < 5 even with c++11 switch enabled."," class CppGenerator : public BaseGenerator {
 code_ += "" memset(this, 0, sizeof({{STRUCT_NAME}}));"";
 code_ += "" }"";
 
- // Generate a copy constructor.
- code_ += "" {{STRUCT_NAME}}(const {{STRUCT_NAME}} &_o) {"";
- code_ += "" memcpy(this, &_o, sizeof({{STRUCT_NAME}}));"";
- code_ += "" }"";
-
 // Generate a constructor that takes all fields as arguments.
 std::string arg_list;
 std::string init_list;
",2042,443
"Fixed potential strict-aliasing violation in big-endian code.

Also added a test.

Tested on: Linux.

Change-Id: I7b3230f8f6043eec139d5e3e8c9cb45814124274"," template<typename T> T EndianSwap(T t) {
 if (sizeof(T) == 1) { // Compile-time if-then's.
 return t;
 } else if (sizeof(T) == 2) {
- auto r = FLATBUFFERS_BYTESWAP16(*reinterpret_cast<uint16_t *>(&t));
- return *reinterpret_cast<T *>(&r);
+ union { T t; uint16_t i; } u;
+ u.t = t;
+ u.i = FLATBUFFERS_BYTESWAP16(u.i);
+ return u.t;
 } else if (sizeof(T) == 4) {
- auto r = FLATBUFFERS_BYTESWAP32(*reinterpret_cast<uint32_t *>(&t));
- return *reinterpret_cast<T *>(&r);
+ union { T t; uint32_t i; } u;
+ u.t = t;
+ u.i = FLATBUFFERS_BYTESWAP32(u.i);
+ return u.t;
 } else if (sizeof(T) == 8) {
- auto r = FLATBUFFERS_BYTESWAP64(*reinterpret_cast<uint64_t *>(&t));
- return *reinterpret_cast<T *>(&r);
+ union { T t; uint64_t i; } u;
+ u.t = t;
+ u.i = FLATBUFFERS_BYTESWAP64(u.i);
+ return u.t;
 } else {
 assert(0);
 }
",64,13
"Missing generated code files.

Change-Id: I8808b0b419981ba7d0699da4a1effb0b660a21cb"," MANUALLY_ALIGNED_STRUCT(4) Vec3 FLATBUFFERS_FINAL_CLASS {
 Vec3() {
 memset(this, 0, sizeof(Vec3));
 }
- Vec3(const Vec3 &_o) {
- memcpy(this, &_o, sizeof(Vec3));
- }
 Vec3(float _x, float _y, float _z)
 : x_(flatbuffers::EndianScalar(_x)),
 y_(flatbuffers::EndianScalar(_y)),
",673,142
"Updated version numbers to 1.8.0

Change-Id: I9cf9fe1e2572d3f9c4066624a87249ca1e62a297","
 #endif // !defined(FLATBUFFERS_LITTLEENDIAN)
 
 #define FLATBUFFERS_VERSION_MAJOR 1
-#define FLATBUFFERS_VERSION_MINOR 7
+#define FLATBUFFERS_VERSION_MINOR 8
 #define FLATBUFFERS_VERSION_REVISION 0
 #define FLATBUFFERS_STRING_EXPAND(X) #X
 #define FLATBUFFERS_STRING(X) FLATBUFFERS_STRING_EXPAND(X)
",64,13
"this is allow custom allocator for obj-api structs/tables. (#4520)

added ""native_custom_alloc"" attribute to tables/structs, eg.

table parent_table( native_custom_alloc:""custom_alloc_name"" ) {
...
}

with a custom allocator defined as

template <typename T> class custom_alloc_name : public std::allocator<T> {
public:

 typedef T* pointer;

 template <class U>
 struct rebind {
 typedef custom_alloc_name<U> other;
 };

 pointer allocate(const std::size_t n) {
 return ....;
 }

 void deallocate(T* ptr, std::size_t n) {
 ...
 }

 custom_alloc_name() throw() {}
 template <class U> custom_alloc_name(const custom_alloc_name<U>&) throw() {}
};
};"," inline voffset_t FieldIndexToOffset(voffset_t field_id) {
 return static_cast<voffset_t>((field_id + fixed_fields) * sizeof(voffset_t));
 }
 
-template <typename T> const T* data(const std::vector<T> &v) {
+template <typename T, typename Alloc> const T* data(const std::vector<T, Alloc> &v) {
 return v.empty() ? nullptr : &v.front();
 }
-template <typename T> T* data(std::vector<T> &v) {
+template <typename T, typename Alloc> T* data(std::vector<T, Alloc> &v) {
 return v.empty() ? nullptr : &v.front();
 }
 
 class FlatBufferBuilder
 /// serialize into the buffer as a `vector`.
 /// @return Returns a typed `Offset` into the serialized data indicating
 /// where the vector is stored.
- template<typename T> Offset<Vector<const T *>> CreateVectorOfStructs(
- const std::vector<T> &v) {
+ template<typename T, typename Alloc> Offset<Vector<const T *>> CreateVectorOfStructs(
+ const std::vector<T, Alloc> &v) {
 return CreateVectorOfStructs(data(v), v.size());
 }
 
",1257,333
Replace the non standard M_PI with a constant (#4528),"
 #include <list>
 #include <iostream>
 
-#ifdef _WIN32
-#if !defined(_USE_MATH_DEFINES)
-#define _USE_MATH_DEFINES // For M_PI.
-#endif // !defined(_USE_MATH_DEFINES)
-#endif // _WIN32
-
 #include <math.h>
 
 #include ""flatbuffers/idl.h""

 
 namespace flatbuffers {
 
+const double kPi = 3.14159265358979323846;
+
 const char *const kTypeNames[] = {
 #define FLATBUFFERS_TD(ENUM, IDLTYPE, \
 CTYPE, JTYPE, GTYPE, NTYPE, PTYPE) \
 CheckedError Parser::ParseSingleValue(Value &e) {
 auto x = strtod(e.constant.c_str(), nullptr); \
 e.constant = NumToString(op); \
 }
- FLATBUFFERS_FN_DOUBLE(""deg"", x / M_PI * 180);
- FLATBUFFERS_FN_DOUBLE(""rad"", x * M_PI / 180);
+ FLATBUFFERS_FN_DOUBLE(""deg"", x / kPi * 180);
+ FLATBUFFERS_FN_DOUBLE(""rad"", x * kPi / 180);
 FLATBUFFERS_FN_DOUBLE(""sin"", sin(x));
 FLATBUFFERS_FN_DOUBLE(""cos"", cos(x));
 FLATBUFFERS_FN_DOUBLE(""tan"", tan(x));
",2187,644
"Fixed CreateStruct not testing for nesting.

Change-Id: I16bf46682ad68c62b778ed1514b6b706c8cb8f6f
Tested: on Linux."," class DetachedBuffer {
 : allocator_(other.allocator_), own_allocator_(other.own_allocator_),
 buf_(other.buf_), reserved_(other.reserved_), cur_(other.cur_),
 size_(other.size_) {
- other.reset(); 
+ other.reset();
 }
 
 DetachedBuffer &operator=(DetachedBuffer &&other) {
 class FlatBufferBuilder
 
 /// @brief Write a struct by itself, typically to be part of a union.
 template<typename T> Offset<const T *> CreateStruct(const T &structobj) {
+ NotNested();
 Align(AlignOf<T>());
 buf_.push_small(structobj);
 return Offset<const T *>(GetSize());
",1258,333
"grpc bindings generator for Java and a few minor supporting changes i (#4553)

* grpc bindings generator for Java and a few minor supporting changes in improvements

* restored formatting before my previous changes for ease of review

* Fixed grpc java code generation bug resulting in duplicate extractor declarations in case the same is used in more than a single RPC method"," struct RPCCall {
 std::string name;
 SymbolTable<Value> attributes;
 StructDef *request, *response;
+ std::vector<std::string> rpc_comment;
 };
 
 struct ServiceDef : public Definition {
 bool GenerateCppGRPC(const Parser &parser,
 bool GenerateGoGRPC(const Parser &parser,
 const std::string &path,
 const std::string &file_name);
+ 
+// Generate GRPC Java classes.
+// See idl_gen_grpc.cpp
+bool GenerateJavaGRPC(const Parser &parser,
+ const std::string &path,
+ const std::string &file_name);
 
 } // namespace flatbuffers
 
",549,44
"Made all C++ files clang-formatted.

Also added missing generated files.

Change-Id: Ifd22a643a08e3f2edfce92812ed57b87fc0e1875","
 #include <vector>
 
 #ifndef GRPC_CUSTOM_STRING
-#include <string>
-#define GRPC_CUSTOM_STRING std::string
+# include <string>
+# define GRPC_CUSTOM_STRING std::string
 #endif
 
 namespace grpc {
",58,5
"fixed java codegen bug documented in #4563 (#4565)

* grpc bindings generator for Java and a few minor supporting changes in improvements

* restored formatting before my previous changes for ease of review

* Fixed grpc java code generation bug resulting in duplicate extractor declarations in case the same is used in more than a single RPC method

* fixed previous merge issue

* removed extra space

* restored extra space

* restored extra space

* fixed java codegen bug documented in https://github.com/google/flatbuffers/issues/4563"," class GeneralGenerator : public BaseGenerator {
 for (auto kit = fields.begin(); kit != fields.end(); ++kit) {
 auto &key_field = **kit;
 if (key_field.key) {
- code += "" public "" + sd.name + lang_.optional_suffix + "" "";
+ auto qualified_name = WrapInNameSpace(sd);
+ code += "" public "" + qualified_name + lang_.optional_suffix + "" "";
 code += MakeCamel(field.name, lang_.first_camel_upper) + ""ByKey("";
 code += GenTypeNameDest(key_field.value.type) + "" key)"";
 code += offset_prefix;
- code += sd.name + "".__lookup_by_key("";
+ code += qualified_name + "".__lookup_by_key("";
 code += lang_.accessor_prefix + ""__vector(o), key, "";
 code += lang_.accessor_prefix + ""bb) : null; "";
 code += ""}\n"";
",1246,296
Various build fixes; update checked-in codegen. (#4572)," static void PrintStub(Printer* p, VARS& vars, const ServiceDescriptor* service,
 break;
 case BLOCKING_CLIENT_INTERFACE:
 interface = true;
- FALLTHROUGH_INTENDED;
+ FALLTHROUGH_INTENDED; // fallthrough
 case BLOCKING_CLIENT_IMPL:
 call_type = BLOCKING_CALL;
 stub_name += ""BlockingStub"";
 static void PrintStub(Printer* p, VARS& vars, const ServiceDescriptor* service,
 break;
 case FUTURE_CLIENT_INTERFACE:
 interface = true;
- FALLTHROUGH_INTENDED;
+ FALLTHROUGH_INTENDED; // fallthrough
 case FUTURE_CLIENT_IMPL:
 call_type = FUTURE_CALL;
 stub_name += ""FutureStub"";
",903,124
"Added missing nullptr check in vector of union verifiers.

Change-Id: Iec720991e68ad27580537135bfd8eb4159333921
Tested: on Linux."," inline bool VerifyEquipment(flatbuffers::Verifier &verifier, const void *obj, Eq
 }
 
 inline bool VerifyEquipmentVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
+ if (!values || !types) return !values && !types;
 if (values->size() != types->size()) return false;
 for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
 if (!VerifyEquipment(
",674,145
Fix error in ConCatPathFileName (#4575)," namespace flatbuffers {
 
 // Retrieve ::back() from a string in a way that is compatible with pre C++11
 // STLs (e.g stlport).
+inline char& string_back(std::string &value) {
+ return value[value.length() - 1];
+}
+
 inline char string_back(const std::string &value) {
 return value[value.length() - 1];
 }
",135,36
"Portable range check for *cursor_ value. (#4582)

Avoids the following compile error when char is unsigned:

error: comparison of unsigned expression >= 0 is always true [-Werror,-Wtautological-unsigned-zero-compare]"," CheckedError Parser::Next() {
 int unicode_high_surrogate = -1;
 
 while (*cursor_ != c) {
- if (*cursor_ < ' ' && *cursor_ >= 0)
+ if (*cursor_ < ' ' && static_cast<signed char>(*cursor_) >= 0)
 return Error(""illegal character in string constant"");
 if (*cursor_ == '\\') {
 cursor_++;
",2189,644
"Add char * overload for FlatBufferBuilder::CreateString() (#4583)

Without this change, the compiler tries to select the following overload
when CreateString is passed a `char *`:

 template<typename T>
 Offset<String> CreateString(const T &str) {
 return CreateString(str.c_str(), str.length());
 }

which is not valid since char pointers don't have methods.

(Fixes #4579)

Signed-off-by: Andrew Gunnerson <chenxiaolong@cxl.epac.to>"," class FlatBufferBuilder {
 return CreateString(str, strlen(str));
 }
 
+ /// @brief Store a string in the buffer, which is null-terminated.
+ /// @param[in] str A char pointer to a C-string to add to the buffer.
+ /// @return Returns the offset in the buffer where the string starts.
+ Offset<String> CreateString(char *str) {
+ return CreateString(str, strlen(str));
+ }
+
 /// @brief Store a string in the buffer, which can contain any binary data.
 /// @param[in] str A const reference to a std::string to store in the buffer.
 /// @return Returns the offset in the buffer where the string starts.
",1253,334
"Cleaned up FlatBufferBuilder clearing.

Change-Id: I81cf4d268670bdd11d1d56ca9f2de78c120df842
Tested: on Linux."," class vector_downward {
 if (buf_) {
 assert(allocator_);
 allocator_->deallocate(buf_, reserved_);
+ buf_ = nullptr;
 }
- reserved_ = 0;
- buf_ = nullptr;
- cur_ = nullptr;
- scratch_ = nullptr;
+ clear();
 }
 
 void clear() {
 if (buf_) {
 cur_ = buf_ + reserved_;
- scratch_ = buf_;
 } else {
 reserved_ = 0;
- buf_ = nullptr;
 cur_ = nullptr;
- scratch_ = nullptr;
 }
+ clear_scratch();
+ }
+
+ void clear_scratch() {
+ scratch_ = buf_;
 }
 
 // Relinquish the pointer to the caller.
 class vector_downward {
 size());
 allocator_ = nullptr;
 own_allocator_ = false;
- reserved_ = 0;
 buf_ = nullptr;
- cur_ = nullptr;
- scratch_ = nullptr;
+ clear();
 return fb;
 }
 
 class FlatBufferBuilder {
 
 void Finish(uoffset_t root, const char *file_identifier, bool size_prefix) {
 NotNested();
+ buf_.clear_scratch();
 // This will cause the whole buffer to be aligned.
 PreAlign((size_prefix ? sizeof(uoffset_t) : 0) + sizeof(uoffset_t) +
 (file_identifier ? kFileIdentifierLength : 0),
",1277,340
"Author: Daniel Lin <danielin@umich.edi> (#4595)

Date: Mon Jan 15 11:38:20 2018 -0200

Compilation failure with grpc.h

If cmake run with flag FLATBUFFERS_BUILD_GRPCTEST=ON
compilation fails.

Fix :
	-Fix argument list for overriden function in grpc.
	-Fix member function name called by FlatBufferBuilder from
	buf() to scratch_data()"," class Allocator {
 size_t in_use_front) {
 assert(new_size > old_size); // vector_downward only grows
 uint8_t *new_p = allocate(new_size);
+ memcpy_downward(old_p, old_size, new_p, new_size, in_use_back,
+ in_use_front);
+ deallocate(old_p, old_size);
+ return new_p;
+ }
+
+ protected:
+ // Called by `reallocate_downward` to copy memory from `old_p` of `old_size`
+ // to `new_p` of `new_size`. Only memory of size `in_use_front` and
+ // `in_use_back` will be copied from the front and back of the old memory
+ // allocation.
+ void memcpy_downward(uint8_t *old_p, size_t old_size,
+ uint8_t *new_p, size_t new_size,
+ size_t in_use_back, size_t in_use_front) {
 memcpy(new_p + new_size - in_use_back, old_p + old_size - in_use_back,
 in_use_back);
 memcpy(new_p, old_p, in_use_front);
- deallocate(old_p, old_size);
- return new_p;
 }
 };
 
",1284,341
"Removed internal variable with name ""data"" inside a generated method _nested_root(). Local variable with name ""data"" violates [-Werror=shadow]. (#4587)"," class CppGenerator : public BaseGenerator {
 code_.SetValue(""CPP_NAME"", TranslateNameSpace(qualified_name));
 
 code_ += "" const {{CPP_NAME}} *{{FIELD_NAME}}_nested_root() const {"";
- code_ += "" auto data = {{FIELD_NAME}}()->Data();"";
- code_ += "" return flatbuffers::GetRoot<{{CPP_NAME}}>(data);"";
+ code_ += "" return flatbuffers::GetRoot<{{CPP_NAME}}>({{FIELD_NAME}}()->Data());"";
 code_ += "" }"";
 }
 
",2123,449
"Added missing generated code.

Change-Id: I9420bf01d2bdb6ccfe3703c835297be73457c0d7"," struct Monster FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
 return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_TESTNESTEDFLATBUFFER);
 }
 const MyGame::Example::Monster *testnestedflatbuffer_nested_root() const {
- auto data = testnestedflatbuffer()->Data();
- return flatbuffers::GetRoot<MyGame::Example::Monster>(data);
+ return flatbuffers::GetRoot<MyGame::Example::Monster>(testnestedflatbuffer()->Data());
 }
 const Stat *testempty() const {
 return GetPointer<const Stat *>(VT_TESTEMPTY);
",2084,471
"Removed date/time from generated code, causing commit polution.

Change-Id: I79724416110a3d2241d7eeecf0e12aa6d5b760a0","
-//Generated by flatc compiler (version 1.8.0) on Dec 28 2017 10:07:47 
+//Generated by flatc compiler (version 1.8.0)
 //If you make any local changes, they will be lost
 //source: monster_test.fbs
 
",271,41
"Disallow defaults on structs.

Change-Id: Ia098126c92ea6f8abe94561bd9c09b29ac8f61f5
Context: https://github.com/google/flatbuffers/issues/4591
Tested: on Linux."," CheckedError Parser::ParseField(StructDef &struct_def) {
 
 if (token_ == '=') {
 NEXT();
- if (!IsScalar(type.base_type))
- return Error(""default values currently only supported for scalars"");
+ if (!IsScalar(type.base_type) || struct_def.fixed)
+ return Error(
+ ""default values currently only supported for scalars in tables"");
 ECHECK(ParseSingleValue(field->value));
 }
 if (IsFloat(field->value.type.base_type)) {
",2190,645
"New error: declaring an enum field without a default in range of the enum.

Change-Id: I4db7f032440c00d31c7434975b8a3f17c29d74b9
Tested: on Linux."," void ErrorTest() {
 TestError(""table X { Y:int; Y:int; }"", ""field already"");
 TestError(""table Y {} table X { Y:int; }"", ""same as table"");
 TestError(""struct X { Y:string; }"", ""only scalar"");
+ TestError(""table X { Y:string = 1; }"", ""default values"");
+ TestError(""enum Y:byte { Z = 1 } table X { y:Y; }"", ""not part of enum"");
 TestError(""struct X { Y:int (deprecated); }"", ""deprecate"");
 TestError(""union Z { X } table X { Y:Z; } root_type X; { Y: {}, A:1 }"",
 ""missing type field"");
 int main(int /*argc*/, const char * /*argv*/ []) {
 EndianSwapTest();
 
 JsonDefaultTest();
- 
+
 FlexBuffersTest();
 
 if (!testing_fails) {
",1419,125
"Fixed native_include not requiring a ; terminator.

Change-Id: Ic4f49e94c67ba23f07e5ba7e87ca94e8db5d5906
Tested: on Linux."," CheckedError Parser::DoParse(const char *source, const char **include_paths,
 NEXT();
 vector_emplace_back(&native_included_files_, attribute_);
 EXPECT(kTokenStringConstant);
+ EXPECT(';');
 } else if (IsIdent(""include"") || (opts.proto_mode && IsIdent(""import""))) {
 NEXT();
 if (opts.proto_mode && attribute_ == ""public"") NEXT();
",2198,649
"Removed truncating of enum vals to int in ReverseLookup.

Some implementations (e.g. C++98) won't support 64-bit enum values,
but there is no reason to silently truncate them.

Change-Id: I8629563523a96e887068f9c0efcd53741f60e0d6
Tested: on Linux."," struct EnumVal {
 struct EnumDef : public Definition {
 EnumDef() : is_union(false), uses_type_aliases(false) {}
 
- EnumVal *ReverseLookup(int enum_idx, bool skip_union_default = true) {
+ EnumVal *ReverseLookup(int64_t enum_idx, bool skip_union_default = true) {
 for (auto it = vals.vec.begin() +
 static_cast<int>(is_union && skip_union_default);
 it != vals.vec.end(); ++it) {
",543,44
"Cleaned up & fixed buffer alignment handling.

- Fixed ForceVectorAlignment (and possibly other call-sites) not
 setting minalign_.
- Fixed flipped alignment parameters in CopyTable (reflection).
- Made aligment for FlatBufferBuilder internal buffer configurable
 (useful when reading a constructed buffer directly).
- Ensured Alignment rounding is always up.

Change-Id: I33ca4887d92a09cb11a369c14a109f4b07ae707a
Tested: on Linux."," Offset<const Table *> CopyTable(FlatBufferBuilder &fbb,
 auto element_size = GetTypeSize(element_base_type);
 if (elemobjectdef && elemobjectdef->is_struct())
 element_size = elemobjectdef->bytesize();
- fbb.StartVector(element_size, vec->size());
+ fbb.StartVector(vec->size(), element_size);
 fbb.PushBytes(vec->Data(), element_size * vec->size());
 offset = fbb.EndVector(vec->size());
 break;
",566,194
"Fix compiler errors in parser (#4612)

src/idl_parser.cpp: In member function 'flatbuffers::CheckedError flatbuffers::Parser::ParseHexNum(int, uint64_t*)':
src/idl_parser.cpp:220:62: error: type qualifiers ignored on cast result type [-Werror=ignored-qualifiers]
 if (!isxdigit(static_cast<const unsigned char>(cursor_[i])))
 ^
src/idl_parser.cpp: In member function 'flatbuffers::CheckedError flatbuffers::Parser::Next()':
src/idl_parser.cpp:260:62: error: type qualifiers ignored on cast result type [-Werror=ignored-qualifiers]
 if(!isdigit(static_cast<const unsigned char>(*cursor_))) return NoError();
 ^
cc1plus: all warnings being treated as errors"," std::string Parser::TokenToStringId(int t) {
 // Parses exactly nibbles worth of hex digits into a number, or error.
 CheckedError Parser::ParseHexNum(int nibbles, uint64_t *val) {
 for (int i = 0; i < nibbles; i++)
- if (!isxdigit(static_cast<const unsigned char>(cursor_[i])))
+ if (!isxdigit(static_cast<unsigned char>(cursor_[i])))
 return Error(""escape code must be followed by "" + NumToString(nibbles) +
 "" hex digits"");
 std::string target(cursor_, cursor_ + nibbles);
 CheckedError Parser::Next() {
 case ';':
 case '=': return NoError();
 case '.':
- if (!isdigit(static_cast<const unsigned char>(*cursor_)))
+ if (!isdigit(static_cast<unsigned char>(*cursor_)))
 return NoError();
 return Error(""floating point constant can\'t start with \"".\"""");
 case '\""':
",2198,649
"Misc fixes from internal integration / clang tidy.

Change-Id: Ic5e8f6a423b426abb9f8b90d39db0f85f28b94be
Tested: on Linux."," typedef grpc_generator::CommentHolder
 typedef grpc_generator::Method MethodDescriptor;
 
 namespace grpc_java_generator {
+typedef std::string string;
 // Generates imports for the service
 void GenerateImports(grpc_generator::File* file,
 grpc_generator::Printer* printer, VARS& vars) {
 void GenerateImports(grpc_generator::File* file,
 printer->Print(vars, ""//source: $filename$.fbs\n\n"");
 printer->Print(vars, ""package $Package$;\n\n"");
 vars[""Package""] = vars[""Package""] + ""."";
- if (file->additional_headers() != """") {
+ if (!file->additional_headers().empty()) {
 printer->Print(file->additional_headers().c_str());
 printer->Print(""\n\n"");
 }
",903,124
Fix vector_data failure under debug (#4606)," inline char string_back(const std::string &value) {
 template <typename T> inline T *vector_data(std::vector<T> &vector) {
 // In some debug environments, operator[] does bounds checking, so &vector[0]
 // can't be used.
- return &(*vector.begin());
+ return vector.empty() ? nullptr : &vector[0];
 }
 
 template <typename T> inline const T *vector_data(
 const std::vector<T> &vector) {
- return &(*vector.begin());
+ return vector.empty() ? nullptr : &vector[0];
 }
 
 template <typename T, typename V>
",135,38
"C++: mini_reflect: Add DefaultTypeTable (#4614)

* mini_reflect: Add DefaultTypeTable

Currently it's very easy to make a mistake when it comes to
instantiating the TypeTable to print a buffer because it is not type
safe.

This will allow us to write safer cpp code:

flatbuffers::FlatBufferToString(reinterpret_cast<const uint8_t *>(&t),
 decltype(t)::DefaultTypeTable());

* c++: mini_reflect: update generated code

* Ensure types and names are set for mini_reflect

* c++: mini_refelct: update unit tests with new typed TypeTable

* Adding PR feedback of sylte and naming convention"," struct TableInNestedNS;
 
 struct StructInNestedNS;
 
+inline flatbuffers::TypeTable *TableInNestedNSTypeTable();
+
+inline flatbuffers::TypeTable *StructInNestedNSTypeTable();
+
 enum EnumInNestedNS {
 EnumInNestedNS_A = 0,
 EnumInNestedNS_B = 1,
 MANUALLY_ALIGNED_STRUCT(4) StructInNestedNS FLATBUFFERS_FINAL_CLASS {
 STRUCT_END(StructInNestedNS, 8);
 
 struct TableInNestedNS FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
+ static flatbuffers::TypeTable *MiniReflectTypeTable() {
+ return TableInNestedNSTypeTable();
+ }
 enum {
 VT_FOO = 4
 };
 inline flatbuffers::Offset<TableInNestedNS> CreateTableInNestedNS(
 return builder_.Finish();
 }
 
-inline flatbuffers::TypeTable *TableInNestedNSTypeTable();
-
-inline flatbuffers::TypeTable *StructInNestedNSTypeTable();
-
 inline flatbuffers::TypeTable *EnumInNestedNSTypeTable() {
 static flatbuffers::TypeCode type_codes[] = {
 { flatbuffers::ET_CHAR, 0, 0 },
",152,22
"[C++] better type mismatch error (#4623)

* better parse error

* pass str as a pointer instead of a reference for more efficient performance"," class Parser : public ParserState {
 size_t fieldn,
 const StructDef *parent_struct_def);
 FLATBUFFERS_CHECKED_ERROR ParseMetaData(SymbolTable<Value> *attributes);
- FLATBUFFERS_CHECKED_ERROR TryTypedValue(int dtoken, bool check, Value &e,
+ FLATBUFFERS_CHECKED_ERROR TryTypedValue(const std::string *name, int dtoken, bool check, Value &e,
 BaseType req, bool *destmatch);
 FLATBUFFERS_CHECKED_ERROR ParseHash(Value &e, FieldDef* field);
 FLATBUFFERS_CHECKED_ERROR TokenError();
- FLATBUFFERS_CHECKED_ERROR ParseSingleValue(Value &e);
+ FLATBUFFERS_CHECKED_ERROR ParseSingleValue(const std::string *name, Value &e);
 FLATBUFFERS_CHECKED_ERROR ParseEnumFromString(Type &type, int64_t *result);
 StructDef *LookupCreateStruct(const std::string &name,
 bool create_if_new = true,
",543,44
"Add new c++ helpers to ease usage of size prefixed FlatBuffers (#4626)

It was missing some helpers when we choose to use
size prefixed FlatBuffers.

* Add general helper : GetPrefixedSize
* Add generated helpers :
 * GetSizePrefixedXXX
 * VerfifySizePrefixedXXXBuffer
 * FinishSizePrefixedXXXBuffer"," inline const uint8_t *GetBufferStartFromRootPointer(const void *root) {
 return nullptr;
 }
 
+/// @brief This return the prefixed size of a FlatBuffer.
+inline uoffset_t GetPrefixedSize(const uint8_t* buf){ return ReadScalar<uoffset_t>(buf); }
+
 // Base class for native objects (FlatBuffer data de-serialized into native
 // C++ data structures).
 // Contains no functionality, purely documentative.
",1290,342
"added support for parsing hash on vector elements (#4502)

* added support for parsing hash on vector elements

reversed check for scalar to check for vector

added C++ generation of cpp_type vectors

removed ctor call for vector fields
added condition !vector for cpp_type check

added Pack() and UnPack() code generation for vector of hashes

* schema change:
added table Referrable and weak references towards it from Monster

added single_weak_reference to Monster table
changed order with vector_of_weak_references

* re-generated monster schema dependent code

added Referrable.cs to FlatBuffers.Test.csproj"," CheckedError Parser::ParseField(StructDef &struct_def) {
 field->deprecated = field->attributes.Lookup(""deprecated"") != nullptr;
 auto hash_name = field->attributes.Lookup(""hash"");
 if (hash_name) {
- switch (type.base_type) {
+ switch ((type.base_type == BASE_TYPE_VECTOR) ? type.element : type.base_type) {
 case BASE_TYPE_INT:
 case BASE_TYPE_UINT: {
 if (FindHashFunction32(hash_name->constant.c_str()) == nullptr)
",2201,654
"In Java, allow reusing ByteBuffer in getters (#4633)

* In Java, allow reusing ByteBuffer in getters

* In Java, allow reusing ByteBuffer in getters

* In Java, allow reusing ByteBuffer in getters"," public class Table {
 return bb;
 }
 
+ /**
+ * Initialize vector as a ByteBuffer.
+ *
+ * This is more efficient than using duplicate, since it doesn't copy the data
+ * nor allocattes a new {@link ByteBuffer}, creating no garbage to be collected.
+ *
+ * @param bb The {@link ByteBuffer} for the array
+ * @param vector_offset The position of the vector in the byte buffer
+ * @param elem_size The size of each element in the array
+ * @return The {@link ByteBuffer} for the array
+ */
+ protected ByteBuffer __vector_in_bytebuffer(ByteBuffer bb, int vector_offset, int elem_size) {
+ int o = this.__offset(vector_offset);
+ if (o == 0) return null;
+ int vectorstart = __vector(o);
+ bb.rewind();
+ bb.limit(vectorstart + __vector_len(o) * elem_size);
+ bb.position(vectorstart);
+ return bb;
+ }
+
 /**
 * Initialize any Table-derived type to point to the union at the given `offset`.
 *
",145,34
"made HashFnv functions constexpr (#4640)

* added FLATBUFFERS_CONSTEXPR_CPP14 define for C++14 and above constexpr

* made HashFnv functions constexpr (depending on FLATBUFFERS_CONSTEXPR)","
 #define FLATBUFFERS_CONSTEXPR
 #endif
 
+#if (defined(__cplusplus) && __cplusplus >= 201402L) || \
+ (defined(__cpp_constexpr) && __cpp_constexpr >= 201304)
+ #define FLATBUFFERS_CONSTEXPR_CPP14 FLATBUFFERS_CONSTEXPR
+#else
+ #define FLATBUFFERS_CONSTEXPR_CPP14
+#endif
+
 #if defined(__GXX_EXPERIMENTAL_CXX0X__) && __GNUC__ * 10 + __GNUC_MINOR__ >= 46 || \
 defined(_MSC_FULL_VER) && _MSC_FULL_VER >= 190023026
 #define FLATBUFFERS_NOEXCEPT noexcept
",64,13
Fix for Java infinite loop encoding into 0-sized buffer (#4654)," public class FlatBufferBuilder {
 int old_buf_size = bb.capacity();
 if ((old_buf_size & 0xC0000000) != 0) // Ensure we don't grow beyond what fits in an int.
 throw new AssertionError(""FlatBuffers: cannot grow buffer beyond 2 gigabytes."");
- int new_buf_size = old_buf_size << 1;
+ int new_buf_size = old_buf_size == 0 ? 1 : old_buf_size << 1;
 bb.position(0);
 ByteBuffer nbb = bb_factory.newByteBuffer(new_buf_size);
 nbb.position(new_buf_size - old_buf_size);
",343,114
"Java + C#, reuse object in lookup_by_key (#4648)

* Java + C#, reuse object in lookup_by_key

* Java + C#, reuse object in lookup_by_key"," public final class Stat extends Table {
 
 public String id() { int o = __offset(4); return o != 0 ? __string(o + bb_pos) : null; }
 public ByteBuffer idAsByteBuffer() { return __vector_as_bytebuffer(4, 1); }
+ public ByteBuffer idInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 4, 1); }
 public long val() { int o = __offset(6); return o != 0 ? bb.getLong(o + bb_pos) : 0L; }
 public boolean mutateVal(long val) { int o = __offset(6); if (o != 0) { bb.putLong(o + bb_pos, val); return true; } else { return false; } }
 public int count() { int o = __offset(8); return o != 0 ? bb.getShort(o + bb_pos) & 0xFFFF : 0; }
",37,22
"Make nested flatbuffer lookup consistent. (#4656)

Lookup type of nested flatbuffer field with either raw name or fully qualified name as already done in the parser.
LookupCreateStruct tries both the raw name and the fully qualified one.
Without this, we cannot reference types outside of the current namespace, e.g. in a different module."," class CppGenerator : public BaseGenerator {
 
 auto nested = field.attributes.Lookup(""nested_flatbuffer"");
 if (nested) {
- std::string qualified_name =
- parser_.current_namespace_->GetFullyQualifiedName(nested->constant);
- auto nested_root = parser_.LookupStruct(qualified_name);
+ std::string qualified_name = nested->constant;
+ auto nested_root = parser_.LookupStruct(nested->constant);
+ if (nested_root == nullptr) {
+ qualified_name = parser_.current_namespace_->GetFullyQualifiedName(
+ nested->constant);
+ nested_root = parser_.LookupStruct(qualified_name);
+ }
 assert(nested_root); // Guaranteed to exist by parser.
 (void)nested_root;
 code_.SetValue(""CPP_NAME"", TranslateNameSpace(qualified_name));
",2200,465
"Protobufs: Added '--oneof-union' option. (#4647)

* Added '--oneof-union' option.

Used with the .proto -> .fbs converter, will translate protobuff oneofs to flatbuffer unions.
Updated proto test to check both methods of converting oneofs.

* Added '--oneof-union' option.

Used with the .proto -> .fbs converter, will translate protobuff oneofs to flatbuffer unions.
Updated proto test to check both methods of converting oneofs.

* FlatBuffers: Moved MakeCamel() into idl_parser.cpp

Removes library dependency on Java/C# generator code."," struct IDLOptions {
 bool mutable_buffer;
 bool one_file;
 bool proto_mode;
+ bool proto_oneof_union;
 bool generate_all;
 bool skip_unexpected_fields_in_json;
 bool generate_name_strings;
 struct IDLOptions {
 mutable_buffer(false),
 one_file(false),
 proto_mode(false),
+ proto_oneof_union(false),
 generate_all(false),
 skip_unexpected_fields_in_json(false),
 generate_name_strings(false),
 class Parser : public ParserState {
 FLATBUFFERS_CHECKED_ERROR ParseNamespace();
 FLATBUFFERS_CHECKED_ERROR StartStruct(const std::string &name,
 StructDef **dest);
+ FLATBUFFERS_CHECKED_ERROR StartEnum(const std::string &name,
+ bool is_union,
+ EnumDef **dest);
 FLATBUFFERS_CHECKED_ERROR ParseDecl();
 FLATBUFFERS_CHECKED_ERROR ParseService();
 FLATBUFFERS_CHECKED_ERROR ParseProtoFields(StructDef *struct_def,
",549,44
"Added missing generated code files.

Change-Id: Ie1cab284cb6e0fe5bd2b2c293c3136c148927ac3","
+# automatically generated by the FlatBuffers compiler, do not modify
+
+# namespace: Example
+
+import flatbuffers
+
+class Referrable(object):
+ __slots__ = ['_tab']
+
+ @classmethod
+ def GetRootAsReferrable(cls, buf, offset):
+ n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
+ x = Referrable()
+ x.Init(buf, n + offset)
+ return x
+
+ # Referrable
+ def Init(self, buf, pos):
+ self._tab = flatbuffers.table.Table(buf, pos)
+
+ # Referrable
+ def Id(self):
+ o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
+ if o != 0:
+ return self._tab.Get(flatbuffers.number_types.Uint64Flags, o + self._tab.Pos)
+ return 0
+
+def ReferrableStart(builder): builder.StartObject(1)
+def ReferrableAddId(builder, id): builder.PrependUint64Slot(0, id, 0)
+def ReferrableEnd(builder): return builder.EndObject()
",19,4
Fix broken Java/C# codegen," public final class Monster extends Table {
 start += middle;
 span -= middle;
 } else {
- return (obj == null ? new Monster(), obj).__assign(tableOffset, bb);
+ return (obj == null ? new Monster() : obj).__assign(tableOffset, bb);
 }
 }
 return null;
",240,322
"Swapped the order of two conditions in an assert. (#4663)

An assert in flexbuffers was bit-shifting a 64-bit number by
64 bits, which throws up warnings in some automated tools.

The same assert also checks to see if the number of bytes
being shifted is 8. Swapped the order, so that the bitshift
only occurs if the number of bits being shifted is not 64.

Should be the same behavior, but plays nicer with diagnostic
tools."," class Builder FLATBUFFERS_FINAL_CLASS {
 
 void WriteOffset(uint64_t o, uint8_t byte_width) {
 auto reloff = buf_.size() - o;
- assert(reloff < 1ULL << (byte_width * 8) || byte_width == 8);
+ assert(byte_width == 8 || reloff < 1ULL << (byte_width * 8));
 Write(reloff, byte_width);
 }
 
",1149,374
"Json : Add --size-prefixed option to flatc (#4645)

to be able to convert to json size prefixed buffers."," struct IDLOptions {
 std::string go_namespace;
 bool reexport_ts_modules;
 bool protobuf_ascii_alike;
+ bool size_prefixed;
 
 // Possible options for the more general generator below.
 enum Language {
 struct IDLOptions {
 skip_flatbuffers_import(false),
 reexport_ts_modules(true),
 protobuf_ascii_alike(false),
+ size_prefixed(false),
 lang(IDLOptions::kJava),
 mini_reflect(IDLOptions::kNone),
 lang_to_generate(0) {}
",551,44
"Convert to unsigned char before applying bit shift operator (#4664)

* Convert to unsigned char before applying bit shift operator

* convert to const unsigned char inline

* convert to unsigned char inline"," inline int FromUTF8(const char **in) {
 break;
 }
 }
- if ((**in << len) & 0x80) return -1; // Bit after leading 1's must be 0.
+ if ((static_cast<const unsigned char>(**in) << len) & 0x80) return -1; // Bit after leading 1's must be 0.
 if (!len) return *(*in)++;
 // UTF-8 encoded values with a length are between 2 and 4 bytes.
 if (len < 2 || len > 4) { return -1; }
",264,83
Const correctness in generated code and in code generators. Added missing \reflection\generate_code.bat file. (#4679)," enum ElementaryType {
 #undef FLATBUFFERS_ET
 };
 
-inline const char **ElementaryTypeNames() {
- static const char *names[] = {
+inline const char * const *ElementaryTypeNames() {
+ static const char * const names[] = {
 #define FLATBUFFERS_ET(E) #E,
 FLATBUFFERS_GEN_ELEMENTARY_TYPES(FLATBUFFERS_ET)
 #undef FLATBUFFERS_ET
 static_assert(sizeof(TypeCode) == 2, ""TypeCode"");
 struct TypeTable;
 
 // Signature of the static method present in each type.
-typedef TypeTable *(*TypeFunction)();
+typedef const TypeTable *(*TypeFunction)();
 
 struct TypeTable {
 SequenceType st;
 struct TypeTable {
 const TypeCode *type_codes;
 const TypeFunction *type_refs;
 const int32_t *values; // Only set for non-consecutive enum/union or structs.
- const char **names; // Only set if compiled with --reflect-names.
+ const char * const *names; // Only set if compiled with --reflect-names.
 };
 
 // String which identifies the current version of FlatBuffers.
",1291,343
"Update version number to 1.9

Change-Id: I0b0ed43129c4d8fc88a177792df50adfeb52a1e3"," from conans import ConanFile, CMake, tools
 
 class FlatbuffersConan(ConanFile):
 name = ""flatbuffers""
- version = ""1.8.0""
+ version = ""1.9.0""
 license = ""https://github.com/google/flatbuffers/blob/master/LICENSE.txt""
 url = ""https://github.com/google/flatbuffers""
 description = ""Memory Efficient Serialization Library""
",36,4
"Add FLATBUFFERS_ prefix to defines [C++] (#4695)

* Rename STRUCT_END to add FLATBUFFERS_ prefix, now FLATBUFFERS_STRUCT_END. Via running `ag -l STRUCT_END | xargs rpl STRUCT_END FLATBUFFERS_STRUCT_END`

* Rename MANUALLY_ALIGNED_STRUCT to add FLATBUFFERS_ prefix, now FLATBUFFERS_MANUALLY_ALIGNED_STRUCT. Via running `ag -l MANUALLY_ALIGNED_STRUCT | xargs rpl MANUALLY_ALIGNED_STRUCT FLATBUFFERS_MANUALLY_ALIGNED_STRUCT && cd tests && sh generate_code.sh`

* Rename DEFINE_BITMASK_OPERATORS to add FLATBUFFERS_ prefix, now FLATBUFFERS_DEFINE_BITMASK_OPERATORS. Via running `ag -l DEFINE_BITMASK_OPERATORS | xargs rpl DEFINE_BITMASK_OPERATORS FLATBUFFERS_DEFINE_BITMASK_OPERATORS`"," MANUALLY_ALIGNED_STRUCT(4) Vec3 FLATBUFFERS_FINAL_CLASS {
 flatbuffers::WriteScalar(&z_, _z);
 }
 };
-STRUCT_END(Vec3, 12);
+FLATBUFFERS_STRUCT_END(Vec3, 12);
 
 struct MonsterT : public flatbuffers::NativeTable {
 typedef Monster TableType;
",692,150
Rename MANUALLY_ALIGNED_STRUCT to add FLATBUFFERS_ prefix in generated code within tests/. Via running `cd tests && sh generate_code.sh` (#4696)," struct EquipmentUnion {
 bool VerifyEquipment(flatbuffers::Verifier &verifier, const void *obj, Equipment type);
 bool VerifyEquipmentVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);
 
-MANUALLY_ALIGNED_STRUCT(4) Vec3 FLATBUFFERS_FINAL_CLASS {
+FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec3 FLATBUFFERS_FINAL_CLASS {
 private:
 float x_;
 float y_;
",692,150
"Remove unnecessary const qualifier (#4698)

In file included from include/flatbuffers/flexbuffers.h:24,
 from src/idl_gen_text.cpp:20:
include/flatbuffers/util.h: In function 'int flatbuffers::FromUTF8(const char**)':
include/flatbuffers/util.h:324:45: error: type qualifiers ignored on cast result type [-Werror=ignored-qualifiers]
 if ((static_cast<const unsigned char>(**in) << len) & 0x80) return -1; // Bit after leading 1's must be 0.
 ^
cc1plus: all warnings being treated as errors
make[2]: *** [CMakeFiles/flatbuffers_shared.dir/build.make:92: CMakeFiles/flatbuffers_shared.dir/src/idl_gen_text.cpp.o] Error 1"," inline int FromUTF8(const char **in) {
 break;
 }
 }
- if ((static_cast<const unsigned char>(**in) << len) & 0x80) return -1; // Bit after leading 1's must be 0.
+ if ((static_cast<unsigned char>(**in) << len) & 0x80) return -1; // Bit after leading 1's must be 0.
 if (!len) return *(*in)++;
 // UTF-8 encoded values with a length are between 2 and 4 bytes.
 if (len < 2 || len > 4) { return -1; }
",264,83
"The asserts replaced by FLATBUFFERS_ASSERT. (#4701)

* The asserts replaced by FLATBUFFERS_ASSERT. Several asserts have converted to static_asserts.

* Regenerate header monster generate_code.sh","
 
 #include <assert.h>
 
+#if !defined(FLATBUFFERS_ASSERT)
+#define FLATBUFFERS_ASSERT assert
+#endif
+
 #ifndef ARDUINO
 #include <cstdint>
 #endif
 template<typename T> T EndianSwap(T t) {
 u.i = FLATBUFFERS_BYTESWAP64(u.i);
 return u.t;
 } else {
- assert(0);
+ FLATBUFFERS_ASSERT(0);
 }
 }
 
",64,13
"Adding JS function to get the File Identifier (#4715)

* Adding JS function to get the File Identifier

* Update flatbuffers.js"," flatbuffers.ByteBuffer.prototype.writeFloat64 = function(offset, value) {
 this.writeInt32(offset + 4, flatbuffers.int32[flatbuffers.isLittleEndian ? 1 : 0]);
 };
 
+/**
+ * Return the file identifier. Behavior is undefined for FlatBuffers whose
+ * schema does not include a file_identifier (likely points at padding or the
+ * start of a the root vtable).
+ * @returns {string}
+ */
+flatbuffers.ByteBuffer.prototype.getBufferIdentifier = function() {
+ if (this.bytes_.length < this.position_ + flatbuffers.SIZEOF_INT +
+ flatbuffers.FILE_IDENTIFIER_LENGTH) {
+ throw new Error(
+ 'FlatBuffers: ByteBuffer is too short to contain an identifier.');
+ }
+ var result = """";
+ for (var i = 0; i < flatbuffers.FILE_IDENTIFIER_LENGTH; i++) {
+ result += String.fromCharCode(
+ this.readInt8(this.position_ + flatbuffers.SIZEOF_INT + i));
+ }
+ return result;
+};
+
 /**
 * Look up a field in the vtable, return an offset into the object, or 0 if the
 * field is not present.
",531,145
"Include services in reflection data (fixes #4639) (#4713)

* include service in reflection data (fixes #4639)

* changes from review

* regenerated test data"," std::string FlatCompiler::GetUsageString(const char *program_name) const {
 "" --grpc Generate GRPC interfaces for the specified languages\n""
 "" --schema Serialize schemas instead of JSON (use with -b)\n""
 "" --bfbs-comments Add doc comments to the binary schema files.\n""
+ "" --bfbs-builtins Add builtin attributes to the binary schema files.\n""
 "" --conform FILE Specify a schema the following schemas should be\n""
 "" an evolution of. Gives errors if not.\n""
 "" --conform-includes Include path for the schema given with --conform\n""
 int FlatCompiler::Compile(int argc, const char **argv) {
 grpc_enabled = true;
 } else if (arg == ""--bfbs-comments"") {
 opts.binary_schema_comments = true;
+ } else if (arg == ""--bfbs-builtins"") {
+ opts.binary_schema_builtins = true;
 } else if (arg == ""--no-fb-import"") {
 opts.skip_flatbuffers_import = true;
 } else if (arg == ""--no-ts-reexport"") {
",358,106
"Fix union escaping order. (#4722)

* Fix union escaping order.

Fixes #4712

* style"," class CppGenerator : public BaseGenerator {
 auto full_struct_name = GetUnionElement(ev, true, true);
 
 // @TODO: Mby make this decisions more universal? How?
- code_.SetValue(""U_GET_TYPE"", Name(field) + UnionTypeFieldSuffix());
+ code_.SetValue(
+ ""U_GET_TYPE"",
+ EscapeKeyword(field.name + UnionTypeFieldSuffix()));
 code_.SetValue(
 ""U_ELEMENT_TYPE"",
 WrapInNameSpace(u->defined_namespace, GetEnumValUse(*u, ev)));
 class CppGenerator : public BaseGenerator {
 std::string GenUnionUnpackVal(const FieldDef &afield,
 const char *vec_elem_access,
 const char *vec_type_access) {
- return afield.value.type.enum_def->name + ""Union::UnPack("" + ""_e"" +
- vec_elem_access + "", "" + Name(afield) + UnionTypeFieldSuffix() +
+ return afield.value.type.enum_def->name +
+ ""Union::UnPack("" + ""_e"" + vec_elem_access + "", "" +
+ EscapeKeyword(afield.name + UnionTypeFieldSuffix()) +
 ""()"" + vec_type_access + "", _resolver)"";
 }
 
",2205,465
"Output JSON strings as natural UTF-8 text without escapes (#4710)

* Added support for the non-escaped print of utf-8 string.

* EscapeString: the first invalid symbol resets print_natural_utf8 flag to false.

* Move the test to ParseAndGenerateTextTest. Fixes.

* Removed dependence between `natural_utf8` and `allow_non_utf8` flags."," class Reference {
 if (type_ == TYPE_STRING) {
 String str(Indirect(), byte_width_);
 if (strings_quoted) {
- flatbuffers::EscapeString(str.c_str(), str.length(), &s, true);
+ flatbuffers::EscapeString(str.c_str(), str.length(), &s, true, false);
 } else {
 s.append(str.c_str(), str.length());
 }
 } else if (IsKey()) {
 auto str = AsKey();
 if (keys_quoted) {
- flatbuffers::EscapeString(str, strlen(str), &s, true);
+ flatbuffers::EscapeString(str, strlen(str), &s, true, false);
 } else {
 s += str;
 }
",1149,374
"Add --root-type option to flatc [C++, parser, JSON] (#4728)

* Add --root-type option to flatc

To select or override a root_type

* Add help text from flatc --root-type to Compiler.md doc"," struct IDLOptions {
 bool reexport_ts_modules;
 bool protobuf_ascii_alike;
 bool size_prefixed;
+ std::string root_type;
 
 // Possible options for the more general generator below.
 enum Language {
",554,44
"Remove @Nullable (Java) for required fields (fixes #4724) (#4726)

@Nullable is only a compiler informational attribute.
Removing for required fields improves compiler warnings
but doesn't impact any running code."," class GeneralGenerator : public BaseGenerator {
 std::string dest_cast = DestinationCast(field.value.type);
 std::string src_cast = SourceCast(field.value.type);
 std::string method_start = "" public "" +
- GenNullableAnnotation(field.value.type) +
+ (field.required ? """" : GenNullableAnnotation(field.value.type)) +
 type_name_dest + optional + "" "" +
 MakeCamel(field.name, lang_.first_camel_upper);
 std::string obj = lang_.language == IDLOptions::kCSharp
",1269,297
"Python: return None for missing strings. (#4733)

[BREAKING CHANGE] Python: return None for missing strings."," static void GetStringField(const StructDef &struct_def, const FieldDef &field,
 code += OffsetPrefix(field);
 code += Indent + Indent + Indent + ""return "" + GenGetter(field.value.type);
 code += ""o + self._tab.Pos)\n"";
- code += Indent + Indent + ""return bytes()\n\n"";
+ code += Indent + Indent + ""return None\n\n"";
 }
 
 // Get the value of a union from an object.
",522,97
"[BREAKING CHANGE] Python: handle bool table fields properly. (#4736)

* Python: handle bool table fields properly.

* Small refactor.

* Use snake_case instead of camelCase. Use auto."," static void GetScalarFieldOfTable(const StructDef &struct_def,
 code += MakeCamel(field.name);
 code += ""(self):"";
 code += OffsetPrefix(field);
- code += Indent + Indent + Indent + ""return "" + getter;
- code += ""o + self._tab.Pos)\n"";
- code += Indent + Indent + ""return "" + field.value.constant + ""\n\n"";
+ getter += ""o + self._tab.Pos)"";
+ auto is_bool = field.value.type.base_type == BASE_TYPE_BOOL;
+ if (is_bool) {
+ getter = ""bool("" + getter + "")"";
+ }
+ code += Indent + Indent + Indent + ""return "" + getter + ""\n"";
+ auto defaultValue = (is_bool ? ""False"" : field.value.constant);
+ code += Indent + Indent + ""return "" + defaultValue + ""\n\n"";
 }
 
 // Get a struct by initializing an existing struct.
",527,99
"Fix undertermined execution behavior (#4751)

Fix for the issue #4744: Ambiguous side-effect execution on vector_downward::make_space() method.
C++ does not impose evaluation order on the two expressions on the right side of the assignment, so compiler can freely decide. As ensure_space() method can change the value of ""cur_"" variable, the result of the subtraction may be different depending on the evaluation order, which is ambiguous in C++.
In order to make this code deterministic and correct, cur_ must be evaluated after ensure_space() is called."," class vector_downward {
 }
 
 inline uint8_t *make_space(size_t len) {
- cur_ -= ensure_space(len);
+ size_t space = ensure_space(len);
+ cur_ -= space;
 return cur_;
 }
 
",1300,345
Fix of namespace problem described in #4747 (#4752)," class CppGenerator : public BaseGenerator {
 auto cpp_type = field.attributes.Lookup(""cpp_type"");
 std::string indexing;
 if (field.value.type.enum_def) {
- indexing += ""("" + field.value.type.enum_def->name + "")"";
+ indexing += ""("" + WrapInNameSpace(*field.value.type.enum_def) + "")"";
 }
 indexing += ""_e->Get(_i)"";
 if (field.value.type.element == BASE_TYPE_BOOL) { indexing += "" != 0""; }
",2205,465
"Fixed ASAN false positive.

Change-Id: I79d9b2cddc61df5919bc4a93627fba2aa69e5d49
Tested: on Linux."," inline CheckedError atot(const char *s, Parser &parser, T *val) {
 int64_t i = StringToInt(s);
 const int64_t min = flatbuffers::numeric_limits<T>::min();
 const int64_t max = flatbuffers::numeric_limits<T>::max();
- ECHECK(parser.CheckInRange(i, min, max));
- *val = (T)i;
- return NoError();
+ *val = (T)i; // Assign this first to make ASAN happy.
+ return parser.CheckInRange(i, min, max);
 }
 template<>
 inline CheckedError atot<uint64_t>(const char *s, Parser &parser,
",2340,692
"renamed flexbuffers::Type enum values TYPE_ -> FBT_ (#4761)

reason: TYPE_BOOL is a macro defined in some iOS build configurations."," void FlexBuffersTest() {
 TEST_EQ(tvec3[2].AsInt8(), 3);
 TEST_EQ(map[""bool""].AsBool(), true);
 auto tvecb = map[""bools""].AsTypedVector();
- TEST_EQ(tvecb.ElementType(), flexbuffers::TYPE_BOOL);
+ TEST_EQ(tvecb.ElementType(), flexbuffers::FBT_BOOL);
 TEST_EQ(map[""foo""].AsUInt8(), 100);
 TEST_EQ(map[""unknown""].IsNull(), true);
 auto mymap = map[""mymap""].AsMap();
",1448,125
Makes VectorIterator compatible with STL iterators. (#4768)," template<typename T> struct IndirectHelper<const T *> {
 template<typename T, typename IT> struct VectorIterator {
 typedef std::random_access_iterator_tag iterator_category;
 typedef IT value_type;
- typedef uoffset_t difference_type;
+ typedef ptrdiff_t difference_type;
 typedef IT *pointer;
 typedef IT &reference;
 
 template<typename T, typename IT> struct VectorIterator {
 return data_ != other.data_;
 }
 
- ptrdiff_t operator-(const VectorIterator &other) const {
+ difference_type operator-(const VectorIterator &other) const {
 return (data_ - other.data_) / IndirectHelper<T>::element_stride;
 }
 
",1301,350
"Enforcing CreateUninitializedVector is only used with scalars.

This function cannot work with any offset types (since offsets
must always point forward) so this avoid possible mistakes.

Change-Id: I1b3dfbefc8d40da630345b9b04f9aff4a990e8e5"," class FlatBufferBuilder {
 /// in the buffer.
 template<typename T>
 Offset<Vector<T>> CreateUninitializedVector(size_t len, T **buf) {
+ AssertScalarT<T>();
 return CreateUninitializedVector(len, sizeof(T),
 reinterpret_cast<uint8_t **>(buf));
 }
",1302,350
"Python: fix default bool value. (#4773)

* Python: fix default bool value.

* Small style tweak."," static void GetScalarFieldOfTable(const StructDef &struct_def,
 getter = ""bool("" + getter + "")"";
 }
 code += Indent + Indent + Indent + ""return "" + getter + ""\n"";
- auto defaultValue = (is_bool ? ""False"" : field.value.constant);
- code += Indent + Indent + ""return "" + defaultValue + ""\n\n"";
+ std::string default_value;
+ if (is_bool) {
+ default_value = field.value.constant == ""0"" ? ""False"" : ""True"";
+ } else {
+ default_value = field.value.constant;
+ }
+ code += Indent + Indent + ""return "" + default_value + ""\n\n"";
 }
 
 // Get a struct by initializing an existing struct.
",532,100
"Dart: Generate the enum from 0 if value is null and fix inconsistent naming when generating object builder (#4782)

* Dart: Generate the enum from 0 if value is null

* Dart: Fix inconsistent naming when generating object builder"," class DartGenerator : public BaseGenerator {
 code += "" final int value;\n"";
 code += "" const "" + name + ""._(this.value);\n\n"";
 code += "" factory "" + name + "".fromValue(int value) {\n"";
- code += "" if (value == null) return null;\n"";
+ code += "" if (value == null) value = 0;\n"";
 
 code += "" if (!values.containsKey(value)) {\n"";
 code +=
 class DartGenerator : public BaseGenerator {
 }
 code += ""\n : null;\n"";
 } else if (field.value.type.base_type == BASE_TYPE_STRING) {
- code += "" = fbBuilder.writeString(_"" + field.name + "");\n"";
+ code += "" = fbBuilder.writeString(_"" + MakeCamel(field.name, false) + "");\n"";
 } else {
 code += "" = _"" + MakeCamel(field.name, false) +
 ""?.getOrCreateOffset(fbBuilder);\n"";
",741,181
Fix misaligned nested buffers (#4785)," CheckedError Parser::ParseTable(const StructDef &struct_def, std::string *value,
 flexbuffers::BUILDER_FLAG_SHARE_ALL);
 ECHECK(parser->ParseFlexBufferValue(&builder));
 builder.Finish();
+ // Force alignment for nested flexbuffer
+ parser->builder_.ForceVectorAlignment(builder.GetSize(), sizeof(uint8_t),
+ sizeof(largest_scalar_t));
 auto off = parser->builder_.CreateVector(builder.GetBuffer());
 val.constant = NumToString(off.o);
 } else if (field->nested_flatbuffer) {
 CheckedError Parser::ParseNestedFlatbuffer(Value &val, FieldDef *field,
 if (!nested_parser.Parse(substring.c_str(), nullptr, nullptr)) {
 ECHECK(Error(nested_parser.error_));
 }
+ // Force alignment for nested flatbuffer
+ builder_.ForceVectorAlignment(nested_parser.builder_.GetSize(), sizeof(uint8_t),
+ nested_parser.builder_.GetBufferMinAlignment());
+ 
 auto off = builder_.CreateVector(nested_parser.builder_.GetBufferPointer(),
 nested_parser.builder_.GetSize());
 val.constant = NumToString(off.o);
",2344,692
"Fixed ASan array out of bounds.

Change-Id: I53366bd14548aa41c3d25bcd187d7436d47e8665
Tested: on Linux."," CheckedError Parser::ParseTableDelimiters(size_t &fieldn,
 if ((!opts.strict_json || !fieldn) && Is(terminator)) break;
 std::string name;
 if (is_nested_vector) {
- if (fieldn > struct_def->fields.vec.size()) {
+ if (fieldn >= struct_def->fields.vec.size()) {
 return Error(""too many unnamed fields in nested array"");
 }
 name = struct_def->fields.vec[fieldn]->name;
 CheckedError Parser::ParseNestedFlatbuffer(Value &val, FieldDef *field,
 // Force alignment for nested flatbuffer
 builder_.ForceVectorAlignment(nested_parser.builder_.GetSize(), sizeof(uint8_t),
 nested_parser.builder_.GetBufferMinAlignment());
- 
+
 auto off = builder_.CreateVector(nested_parser.builder_.GetBufferPointer(),
 nested_parser.builder_.GetSize());
 val.constant = NumToString(off.o);
",2344,692
"Protected parser against infinite recursion.

Will error-out after e.g. 64 levels of nested JSON tables.

Change-Id: I3ab66cdd509378bfab87b85f85c07ab42aded788
Tested: on Linux."," class Parser : public ParserState {
 opts(options),
 uses_flexbuffers_(false),
 source_(nullptr),
- anonymous_counter(0) {
+ anonymous_counter(0),
+ recurse_protection_counter(0) {
 // Start out with the empty namespace being current.
 empty_namespace_ = new Namespace();
 namespaces_.push_back(empty_namespace_);
 class Parser : public ParserState {
 bool SupportsVectorOfUnions() const;
 Namespace *UniqueNamespace(Namespace *ns);
 
+ enum { kMaxParsingDepth = 64 };
+ FLATBUFFERS_CHECKED_ERROR RecurseError();
+ template<typename F> CheckedError Recurse(F f) {
+ if (++recurse_protection_counter >= kMaxParsingDepth) return RecurseError();
+ auto ce = f();
+ recurse_protection_counter--;
+ return ce;
+ }
+
 public:
 SymbolTable<Type> types_;
 SymbolTable<StructDef> structs_;
 class Parser : public ParserState {
 std::vector<std::pair<Value, FieldDef *>> field_stack_;
 
 int anonymous_counter;
+ int recurse_protection_counter;
 };
 
 // Utility functions for multiple generators:
",573,46
"CreateUnitializedVectorOfStructs and tests (#4781)

* CreateUnitializedVectorOfStructs and tests

* Incorporating review comments

* snake_case variable names"," class FlatBufferBuilder {
 reinterpret_cast<uint8_t **>(buf));
 }
 
+ template<typename T>
+ Offset<Vector<const T*>> CreateUninitializedVectorOfStructs(size_t len, T **buf) {
+ return CreateUninitializedVector(len, sizeof(T),
+ reinterpret_cast<uint8_t **>(buf));
+ }
+
 /// @brief Write a struct by itself, typically to be part of a union.
 template<typename T> Offset<const T *> CreateStruct(const T &structobj) {
 NotNested();
",1307,351
"Comment update for ForceDefaults. (#4788)

Current comment is a bit ambiguous. Default values can be read either if field is not written (like in table), or if they are written explicitly by client but not serialized due to optimization. Impression from current comment is that all the default values which are coming during read are from binaries when we turn-on Force-Defaults. However, that will be a wrong interpretation.

Force_Defaults = true ensures to turn OFF later optimization. In case a field is not written, during read we will get default values but they will still not be serialized."," class FlatBufferBuilder {
 
 /// @brief In order to save space, fields that are set to their default value
 /// don't get serialized into the buffer.
- /// @param[in] bool fd When set to `true`, always serializes default values.
+ /// @param[in] bool fd When set to `true`, always serializes default values that are set.
+ /// Optional fields which are not set explicitly, will still not be serialized.
 void ForceDefaults(bool fd) { force_defaults_ = fd; }
 
 /// @brief By default vtables are deduped in order to save space.
",1307,351
"Fixed documentation comments at the start of a file.

Change-Id: Ic24018a6cd604c71b4d8d3cd35dc7a583fb18394"," bool IsIdentifierStart(char c) {
 
 CheckedError Parser::Next() {
 doc_comment_.clear();
- bool seen_newline = false;
+ bool seen_newline = cursor_ == source_;
 attribute_.clear();
 for (;;) {
 char c = *cursor_++;
 CheckedError Parser::Next() {
 const char *start = ++cursor_;
 while (*cursor_ && *cursor_ != '\n' && *cursor_ != '\r') cursor_++;
 if (*start == '/') { // documentation comment
- if (cursor_ != source_ && !seen_newline)
+ if (!seen_newline)
 return Error(
 ""a documentation comment should be on a line on its own"");
 doc_comment_.push_back(std::string(start + 1, cursor_));
",2357,692
"Add --force-defaults option to flatc [C++, parser] (#4729)

* Add --force-defaults option to flatc

To emit default values for fields which are not present or which are set
to the default value.

* flatc option --force-defaults should have a default value (false) and take action on the builder_ within the Parser constructor

* Add help text from flatc --force-defaults to Compiler.md doc

* Clarified docs for flatc --force-defaults, and imply that this behaviour is not normally needed.

* Updated docs and flatc help text for --force-defaults option"," struct IDLOptions {
 bool protobuf_ascii_alike;
 bool size_prefixed;
 std::string root_type;
+ bool force_defaults;
 
 // Possible options for the more general generator below.
 enum Language {
 struct IDLOptions {
 reexport_ts_modules(true),
 protobuf_ascii_alike(false),
 size_prefixed(false),
+ force_defaults(false),
 lang(IDLOptions::kJava),
 mini_reflect(IDLOptions::kNone),
 lang_to_generate(0) {}
 class Parser : public ParserState {
 source_(nullptr),
 anonymous_counter(0),
 recurse_protection_counter(0) {
+ if (opts.force_defaults) {
+ builder_.ForceDefaults(true);
+ }
 // Start out with the empty namespace being current.
 empty_namespace_ = new Namespace();
 namespaces_.push_back(empty_namespace_);
",578,47
Dart: Fix default values (#4795)," class DartGenerator : public BaseGenerator {
 code += "".vTableGet(_bc, _bcOffset, "" +
 NumToString(field.value.offset) + "", "";
 if (!field.value.constant.empty() && field.value.constant != ""0"") {
- code += field.value.constant;
+ if (IsBool(field.value.type.base_type)) {
+ code += ""true"";
+ } else {
+ code += field.value.constant;
+ }
 } else {
- code += ""null"";
+ if (IsBool(field.value.type.base_type)) {
+ code += ""false"";
+ } else if (IsScalar(field.value.type.base_type)) {
+ code += ""0"";
+ } else {
+ code += ""null"";
+ }
 }
 code += "")"";
 }
",751,184
"Helper function to get empty string on nullptr (#4800)

Adds helper function to get empty string when String is nullptr.

This is to get over the fact that flat buffer builders will record null when data
is not present."," const Vector<Offset<T>> *VectorCast(const Vector<Offset<U>> *ptr) {
 #endif
 
 // Convenient helper function to get the length of any vector, regardless
-// of wether it is null or not (the field is not set).
+// of whether it is null or not (the field is not set).
 template<typename T> static inline size_t VectorLength(const Vector<T> *v) {
 return v ? v->Length() : 0;
 }
 struct String : public Vector<char> {
 }
 };
 
+// Convenience function to get std::string from a String returning an empty
+// string on null pointer.
+static inline std::string GetString(const String * str) {
+ return str ? str->str() : """";
+}
+
+// Convenience function to get char* from a String returning an empty string on
+// null pointer.
+static inline const char * GetCstring(const String * str) {
+ return str ? str->c_str() : """";
+}
+
 // Allocator interface. This is flatbuffers-specific and meant only for
 // `vector_downward` usage.
 class Allocator {
",1313,355
"[Go] Unroll WriteUint64 and WriteInt64.

This enables both WriteUint64 and WriteInt64 to both be inlined as
well as implemented with a single assembly instruction. The current Go
compiler refuses to inline functions with for loops. The compiler is
also not smart enough to produce a single assembly instruction for the
for-loop."," func WriteUint32(buf []byte, n uint32) {
 
 // WriteUint64 encodes a little-endian uint64 into a byte slice.
 func WriteUint64(buf []byte, n uint64) {
-for i := uint(0); i < uint(SizeUint64); i++ {
-buf[i] = byte(n >> (i * 8))
-}
+buf[0] = byte(n)
+buf[1] = byte(n >> 8)
+buf[2] = byte(n >> 16)
+buf[3] = byte(n >> 24)
+buf[4] = byte(n >> 32)
+buf[5] = byte(n >> 40)
+buf[6] = byte(n >> 48)
+buf[7] = byte(n >> 56)
 }
 
 // WriteInt8 encodes a little-endian int8 into a byte slice.
 func WriteInt32(buf []byte, n int32) {
 
 // WriteInt64 encodes a little-endian int64 into a byte slice.
 func WriteInt64(buf []byte, n int64) {
-for i := uint(0); i < uint(SizeInt64); i++ {
-buf[i] = byte(n >> (i * 8))
-}
+buf[0] = byte(n)
+buf[1] = byte(n >> 8)
+buf[2] = byte(n >> 16)
+buf[3] = byte(n >> 24)
+buf[4] = byte(n >> 32)
+buf[5] = byte(n >> 40)
+buf[6] = byte(n >> 48)
+buf[7] = byte(n >> 56)
 }
 
 // WriteFloat32 encodes a little-endian float32 into a byte slice.
",159,31
"C++ verifier now primarily uses offsets instead of pointers.

Fix for: https://bugs.chromium.org/p/chromium/issues/detail?id=834710

Before, the verifier would create pointers to objects, and then
verify they are inside the buffer. But since even constructing pointers
that are outside a valid allocation is Undefinied Behavior in C++, this
can trigger UBSAN (with -fsanitize=pointer-overflow).

Now instead the bounds checking is first performed using offsets
before pointers are even created.

Change-Id: If4d376e90df9847e543247e70a062671914dae1b
Tested: on Linux."," bool VerifyStruct(flatbuffers::Verifier &v,
 if (required && !offset) { return false; }
 
 return !offset ||
- v.Verify(reinterpret_cast<const uint8_t *>(&parent_table) + offset,
+ v.Verify(reinterpret_cast<const uint8_t *>(&parent_table), offset,
 obj.bytesize());
 }
 
 bool VerifyVectorOfStructs(flatbuffers::Verifier &v,
 voffset_t field_offset,
 const reflection::Object &obj, bool required) {
 auto p = parent_table.GetPointer<const uint8_t *>(field_offset);
- const uint8_t *end;
 if (required && !p) { return false; }
 
- return !p || v.VerifyVector(p, obj.bytesize(), &end);
+ return !p || v.VerifyVector(p, obj.bytesize());
 }
 
 // forward declare to resolve cyclic deps between VerifyObject and VerifyVector
",566,194
"Fixed assert in ParseSingleValue (found by fuzzer)

Change-Id: I84674eaab75b2b455e918b04e3027920430678ac"," CheckedError Parser::ParseField(StructDef &struct_def) {
 
 if (token_ == '=') {
 NEXT();
- ECHECK(ParseSingleValue(&field->name, field->value));
 if (!IsScalar(type.base_type) ||
 (struct_def.fixed && field->value.constant != ""0""))
 return Error(
 ""default values currently only supported for scalars in tables"");
+ ECHECK(ParseSingleValue(&field->name, field->value));
 }
 if (type.enum_def &&
 !type.enum_def->is_union &&
",2357,692
flatbuffer force-empty option (#4822)," struct IDLOptions {
 // for code generation.
 unsigned long lang_to_generate;
 
+ // If set (default behavior), empty string and vector fields will be set to
+ // nullptr to make the flatbuffer more compact.
+ bool set_empty_to_null;
+
 IDLOptions()
 : strict_json(false),
 skip_js_exports(false),
 struct IDLOptions {
 force_defaults(false),
 lang(IDLOptions::kJava),
 mini_reflect(IDLOptions::kNone),
- lang_to_generate(0) {}
+ lang_to_generate(0),
+ set_empty_to_null(true) {}
 };
 
 // This encapsulates where the parser is in the current source file.
",584,47
"Renamed Verifier methods

The name Verify was getting too overloaded, and confused
the VS compiler

Change-Id: I26423a4d513e4def2f4e41d7f278bb683fc12518"," struct Monster FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
 VerifyField<int16_t>(verifier, VT_MANA) &&
 VerifyField<int16_t>(verifier, VT_HP) &&
 VerifyOffset(verifier, VT_NAME) &&
- verifier.Verify(name()) &&
+ verifier.VerifyString(name()) &&
 VerifyOffset(verifier, VT_INVENTORY) &&
- verifier.Verify(inventory()) &&
+ verifier.VerifyVector(inventory()) &&
 VerifyField<int8_t>(verifier, VT_COLOR) &&
 VerifyOffset(verifier, VT_WEAPONS) &&
- verifier.Verify(weapons()) &&
+ verifier.VerifyVector(weapons()) &&
 verifier.VerifyVectorOfTables(weapons()) &&
 VerifyField<uint8_t>(verifier, VT_EQUIPPED_TYPE) &&
 VerifyOffset(verifier, VT_EQUIPPED) &&
 struct Weapon FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
 bool Verify(flatbuffers::Verifier &verifier) const {
 return VerifyTableStart(verifier) &&
 VerifyOffset(verifier, VT_NAME) &&
- verifier.Verify(name()) &&
+ verifier.VerifyString(name()) &&
 VerifyField<int16_t>(verifier, VT_DAMAGE) &&
 verifier.EndTable();
 }
",692,150
"Missing Lua generated files

Change-Id: Id668ade474805dd9c7e108a478db3551d6a62b48","
+-- automatically generated by the FlatBuffers compiler, do not modify
+
+-- namespace: NamespaceB
+
+local flatbuffers = require('flatbuffers')
+
+local StructInNestedNS = {} -- the module
+local StructInNestedNS_mt = {} -- the class metatable
+
+function StructInNestedNS.New()
+ local o = {}
+ setmetatable(o, {__index = StructInNestedNS_mt})
+ return o
+end
+function StructInNestedNS_mt:Init(buf, pos)
+ self.view = flatbuffers.view.New(buf, pos)
+end
+function StructInNestedNS_mt:A()
+ return self.view:Get(flatbuffers.N.Int32, self.view.pos + 0)
+end
+function StructInNestedNS_mt:B()
+ return self.view:Get(flatbuffers.N.Int32, self.view.pos + 4)
+end
+function StructInNestedNS.CreateStructInNestedNS(builder, a, b)
+ builder:Prep(4, 8)
+ builder:PrependInt32(b)
+ builder:PrependInt32(a)
+ return builder:Offset()
+end
+
+return StructInNestedNS -- return the module
\ No newline at end of file
",24,5
"Fixing an assert in flexbuffers CreateVector (#4824)

An assert was blocking the creation of typedvectors. It was wrongly checking for limited types even though vector was not of fixedTyped."," class Builder FLATBUFFERS_FINAL_CLASS {
 }
 // If you get this assert, your fixed types are not one of:
 // Int / UInt / Float / Key.
- FLATBUFFERS_ASSERT(IsTypedVectorElementType(vector_type));
+ FLATBUFFERS_ASSERT(!fixed || IsTypedVectorElementType(vector_type));
 auto byte_width = Align(bit_width);
 // Write vector. First the keys width/offset if available, and size.
 if (keys) {
",1149,375
"Restricting (typed=false, fixed=true) combination in flexbuffer CreateVector (#4825)

https://github.com/google/flatbuffers/issues/4815"," class Builder FLATBUFFERS_FINAL_CLASS {
 
 Value CreateVector(size_t start, size_t vec_len, size_t step, bool typed,
 bool fixed, const Value *keys = nullptr) {
+ FLATBUFFERS_ASSERT(!fixed || typed); // typed=false, fixed=true combination is not supported.
 // Figure out smallest bit width we can store this vector with.
 auto bit_width = (std::max)(force_min_bit_width_, WidthU(vec_len));
 auto prefix_elems = 1;
",1150,376
"Adds ForceStringAlignment to flatbuffers. (#4828)

ForceStringAlignment is useful for memory aligning string fields in flatbuffers."," class FlatBufferBuilder {
 void ForceVectorAlignment(size_t len, size_t elemsize, size_t alignment) {
 PreAlign(len * elemsize, alignment);
 }
+ 
+ // Similar to ForceVectorAlignment but for String fields.
+ void ForceStringAlignment(size_t len, size_t alignment) {
+ PreAlign((len + 1) * sizeof(char), alignment);
+ }
 
 /// @endcond
 
",1335,362
python: do not clobber minalign when we create objects (#4833)," class Builder(object):
 # use 32-bit offsets so that arithmetic doesn't overflow.
 self.current_vtable = [0 for _ in range_func(numfields)]
 self.objectEnd = self.Offset()
- self.minalign = 1
 self.nested = True
 
 def WriteVtable(self):
",335,79
go: do not clobber minalign when we create objects (#4834)," func (b *Builder) StartObject(numfields int) {
 }
 
 b.objectEnd = b.Offset()
-b.minalign = 1
 }
 
 // WriteVtable serializes the vtable for the current object, if applicable.
",459,116
"Performance Increase of Vector of Structures using .NET BlockCopy (#4830)

* Added Get<vector_name>Array() method for accessing vectors of structures in C# using Buffer.Blockcopy().

* Added Get<vector_name>Array() method for accessing vectors of structures in C# using Buffer.Blockcopy().

Added Create<Name>VectorBlock() method to add a typed array using Buffer.BlockCopy() to speed up creation of vector of arrays

New Lua files for namespace test

* fixed c++ style issue"," namespace FlatBuffers
 return bb.ToArraySegment(pos, len);
 }
 
+ // Get the data of a vector whoses offset is stored at ""offset"" in this object as an
+ // T[]. If the vector is not present in the ByteBuffer, then a null value will be
+ // returned.
+ public T[] __vector_as_array<T>(int offset)
+ where T : struct
+ {
+ if(!BitConverter.IsLittleEndian)
+ {
+ throw new NotSupportedException(""Getting typed arrays on a Big Endian "" +
+ ""system is not support"");
+ }
+
+ var o = this.__offset(offset);
+ if (0 == o)
+ {
+ return null;
+ }
+
+ var pos = this.__vector(o);
+ var len = this.__vector_len(o);
+ return bb.ToArray<T>(pos, len);
+ }
+
 // Initialize any Table-derived type to point to the union at the given offset.
 public T __union<T>(int offset) where T : struct, IFlatbufferObject
 {
",123,22
Update FLATBUFFERS_HAS_STRING_VIEW __cplusplus checks to the versions provided by the standard feature test macros. (#4841),"
 // to detect a header that provides an implementation
 #if defined(__has_include)
 // Check for std::string_view (in c++17)
- #if __has_include(<string_view>) && (__cplusplus > 201402)
+ #if __has_include(<string_view>) && (__cplusplus >= 201606)
 #include <string_view>
 namespace flatbuffers {
 typedef std::string_view string_view;
 }
 #define FLATBUFFERS_HAS_STRING_VIEW 1
 // Check for std::experimental::string_view (in c++14, compiler-dependent)
- #elif __has_include(<experimental/string_view>) && (__cplusplus > 201103)
+ #elif __has_include(<experimental/string_view>) && (__cplusplus >= 201411)
 #include <experimental/string_view>
 namespace flatbuffers {
 typedef std::experimental::string_view string_view;
",72,13
"For sparse enums, use a switch statement to generate EnumNameXXX(). (#4845)"," class CppGenerator : public BaseGenerator {
 code_ += "";"";
 
 code_ += "" return EnumNames{{ENUM_NAME}}()[index];"";
+ code_ += ""}"";
+ code_ += """";
+ } else {
+ code_ += ""inline const char *EnumName{{ENUM_NAME}}({{ENUM_NAME}} e) {"";
+
+ code_ += "" switch (e) {"";
+
+ for (auto it = enum_def.vals.vec.begin(); it != enum_def.vals.vec.end();
+ ++it) {
+ const auto &ev = **it;
+ code_ += "" case {{ENUM_NAME}}_"" + Name(ev) + "": return \"""" +
+ Name(ev) + ""\"";"";
+ }
+
+ code_ += "" default: return \""\"";"";
+ code_ += "" }"";
+
 code_ += ""}"";
 code_ += """";
 }
",2214,467
"FlatBuffers implementation for the Lobster programming language

Language, see: http://strlen.com/lobster/ and https://github.com/aardappel/lobster"," struct IDLOptions {
 kJsonSchema = 1 << 10,
 kDart = 1 << 11,
 kLua = 1 << 12,
+ kLobster = 1 << 13,
 kMAX
 };
 
 extern bool GeneratePython(const Parser &parser,
 const std::string &path,
 const std::string &file_name);
 
+// Generate Lobster files from the definitions in the Parser object.
+// See idl_gen_lobster.cpp.
+extern bool GenerateLobster(const Parser &parser,
+ const std::string &path,
+ const std::string &file_name);
+
 // Generate Lua files from the definitions in the Parser object.
 // See idl_gen_lua.cpp.
 extern bool GenerateLua(const Parser &parser,
",588,47
Remove using namespace std; (#4851)," class LogHelper {
 // Abort the program after logging the mesage.
 #define GRPC_CODEGEN_FAIL GRPC_CODEGEN_CHECK(false)
 
-using namespace std;
-
 namespace grpc_java_generator {
 struct Parameters {
 // //Defines the custom parameter types for methods
",28,5
Clarify flatbuffer reflection struct sizes to be less error-prone. (#4870)," typedef const TypeTable *(*TypeFunction)();
 
 struct TypeTable {
 SequenceType st;
- size_t num_elems; // of each of the arrays below.
- const TypeCode *type_codes;
- const TypeFunction *type_refs;
+ size_t num_elems; // of type_codes, values, names (but not type_refs).
+ const TypeCode *type_codes; // num_elems count
+ const TypeFunction *type_refs; // less than num_elems entries (see TypeCode).
 const int32_t *values; // Only set for non-consecutive enum/union or structs.
 const char * const *names; // Only set if compiled with --reflect-names.
 };
",1336,362
"Correctly generate identifier for enums. (#4871)

This should allow the EnumName* function to work with enums generated
using the --scoped-enum flag."," class CppGenerator : public BaseGenerator {
 for (auto it = enum_def.vals.vec.begin(); it != enum_def.vals.vec.end();
 ++it) {
 const auto &ev = **it;
- code_ += "" case {{ENUM_NAME}}_"" + Name(ev) + "": return \"""" +
+ code_ += "" case "" + GetEnumValUse(enum_def, ev) + "": return \"""" +
 Name(ev) + ""\"";"";
 }
 
",2214,467
"Use string_view if _HAS_CXX17 is true (#4876)

Current version of VC2017 is not setting __cplusplus to correct value, instead they use _MSC_VER, _MSVC_LANG and _HAS_CXX17 macros.","
 // to detect a header that provides an implementation
 #if defined(__has_include)
 // Check for std::string_view (in c++17)
- #if __has_include(<string_view>) && (__cplusplus >= 201606)
+ #if __has_include(<string_view>) && (__cplusplus >= 201606 || _HAS_CXX17)
 #include <string_view>
 namespace flatbuffers {
 typedef std::string_view string_view;
",72,13
"Add C#/Java generator behaviour for 'private' attribute (#4882)

* Added 'private' attribute, supported when generating C# and Java

* Added use of 'private' attribute in monster_test"," class Parser : public ParserState {
 known_attributes_[""native_type""] = true;
 known_attributes_[""native_default""] = true;
 known_attributes_[""flexbuffer""] = true;
+ known_attributes_[""private""] = true;
 }
 
 ~Parser() {
",589,47
"Revert ""Performance Increase of Vector of Structures using .NET BlockCopy (#4830)""

This reverts commit 7b50004ec9a1b86db2b1b61a9906e52227f62b35.

Change-Id: I09d6869c16aa3c7fadc537fc9c76eaa3cf7ee7ea"," namespace FlatBuffers
 return bb.ToArraySegment(pos, len);
 }
 
- // Get the data of a vector whoses offset is stored at ""offset"" in this object as an
- // T[]. If the vector is not present in the ByteBuffer, then a null value will be
- // returned.
- public T[] __vector_as_array<T>(int offset)
- where T : struct
- {
- if(!BitConverter.IsLittleEndian)
- {
- throw new NotSupportedException(""Getting typed arrays on a Big Endian "" +
- ""system is not support"");
- }
-
- var o = this.__offset(offset);
- if (0 == o)
- {
- return null;
- }
-
- var pos = this.__vector(o);
- var len = this.__vector_len(o);
- return bb.ToArray<T>(pos, len);
- }
-
 // Initialize any Table-derived type to point to the union at the given offset.
 public T __union<T>(int offset) where T : struct, IFlatbufferObject
 {
",106,20
"Mono Fix for Unsafe Mode (#4887)

* Added preprocessor define for C++ if Template Aliases are supported by the compiler

* Revert ""Revert ""Performance Increase of Vector of Structures using .NET BlockCopy (#4830)""""

This reverts commit 1f5eae5d6a135ff6811724f6c57f911d1f46bb15.

* Put<T> method was inside #if UNSAFE_BYTEBUFFER which caused compilation failure when building in unsafe mode

* Revert ""Added preprocessor define for C++ if Template Aliases are supported by the compiler""

This reverts commit a75af7352127c261baf0b6cca5cb823e13e78f11."," namespace FlatBuffers
 return bb.ToArraySegment(pos, len);
 }
 
+ // Get the data of a vector whoses offset is stored at ""offset"" in this object as an
+ // T[]. If the vector is not present in the ByteBuffer, then a null value will be
+ // returned.
+ public T[] __vector_as_array<T>(int offset)
+ where T : struct
+ {
+ if(!BitConverter.IsLittleEndian)
+ {
+ throw new NotSupportedException(""Getting typed arrays on a Big Endian "" +
+ ""system is not support"");
+ }
+
+ var o = this.__offset(offset);
+ if (0 == o)
+ {
+ return null;
+ }
+
+ var pos = this.__vector(o);
+ var len = this.__vector_len(o);
+ return bb.ToArray<T>(pos, len);
+ }
+
 // Initialize any Table-derived type to point to the union at the given offset.
 public T __union<T>(int offset) where T : struct, IFlatbufferObject
 {
",123,22
"C# support for directly reading and writting to memory other than byte[]. For example, ByteBuffer can be initialized with a custom allocator which uses shared memory / memory mapped files. (#4886)

Public access to the backing buffer uses Span<T> instead of ArraySegment<T>.

Writing to the buffer now supports Span<T> in addition to T[].

To maintain backwards compatibility ENABLE_SPAN_T must be defined."," class GeneralGenerator : public BaseGenerator {
 code += ""); }\n"";
 break;
 case IDLOptions::kCSharp:
+ code += ""#if ENABLE_SPAN_T\n"";
+ code += "" public Span<byte> Get"";
+ code += MakeCamel(field.name, lang_.first_camel_upper);
+ code += ""Bytes() { return "";
+ code += lang_.accessor_prefix + ""__vector_as_span("";
+ code += NumToString(field.value.offset);
+ code += ""); }\n"";
+ code += ""#else\n"";
 code += "" public ArraySegment<byte>? Get"";
 code += MakeCamel(field.name, lang_.first_camel_upper);
 code += ""Bytes() { return "";
 code += lang_.accessor_prefix + ""__vector_as_arraysegment("";
 code += NumToString(field.value.offset);
 code += ""); }\n"";
+ code += ""#endif\n"";
 
 // For direct blockcopying the data into a typed array
 code += "" public "";
",1333,311
"Add move semantics to MessageBuilder, FlatBufferBuilder, SliceAllocator, and vector_downward (#4893)

Unit tests
Update flatbuffers + gRPC build instructions
Update CMakeLists.txt with cmake variables for grpc and protobuf install paths
Update tests for travis build","
 #include ""monster_test_generated.h""
 
 using namespace MyGame::Example;
+int builder_tests();
 
 // The callback implementation of our server, that derives from the generated
 // code. It implements all rpcs specified in the FlatBuffers schema.
 void RunServer() {
 server_instance->Wait();
 }
 
-int main(int /*argc*/, const char * /*argv*/ []) {
+int grpc_server_test() {
 // Launch server.
 std::thread server_thread(RunServer);
 
 int main(int /*argc*/, const char * /*argv*/ []) {
 
 return 0;
 }
+
+int main(int /*argc*/, const char * /*argv*/ []) {
+ return builder_tests() + grpc_server_test();
+}
+
",108,10
"Port FlatBuffers to Rust (#4898)

This is a port of FlatBuffers to Rust. It provides code generation and a
runtime library derived from the C++ implementation. It utilizes the
Rust type system to provide safe and fast traversal of FlatBuffers data.

There are 188 tests, including many fuzz tests of roundtrips for various
serialization scenarios. Initial benchmarks indicate that the canonical
example payload can be written in ~700ns, and traversed in ~100ns.

Rustaceans may be interested in the Follow, Push, and SafeSliceAccess
traits. These traits lift traversals, reads, writes, and slice accesses
into the type system, providing abstraction with no runtime penalty."," int main(int argc, const char *argv[]) {
 flatbuffers::IDLOptions::kLua,
 ""Generate Lua files for tables/structs"",
 flatbuffers::GeneralMakeRule },
+ { flatbuffers::GenerateRust, ""-r"", ""--rust"", ""Rust"", true, nullptr,
+ flatbuffers::IDLOptions::kRust,
+ ""Generate Rust files for tables/structs"",
+ flatbuffers::RustMakeRule },
 { flatbuffers::GeneratePhp, nullptr, ""--php"", ""PHP"", true, nullptr,
 flatbuffers::IDLOptions::kPhp, ""Generate PHP files for tables/structs"",
 flatbuffers::GeneralMakeRule },
",79,6
"Fix extern crate in root namespace (#4905)

Imports the Rust FlatBuffers runtime crate even when not using a namespace in a schema."," class RustGenerator : public BaseGenerator {
 bool generate() {
 code_.Clear();
 code_ += ""// "" + std::string(FlatBuffersGeneratedWarning()) + ""\n\n"";
+ code_ += ""#![allow(dead_code)]"";
+ code_ += ""#![allow(unused_imports)]"";
+ code_ += ""extern crate flatbuffers;\n"";
 
 assert(!cur_name_space_);
 
",1432,318
rust generator: fix enum member comments (#4911)," class RustGenerator : public BaseGenerator {
 void GenEnum(const EnumDef &enum_def) {
 code_.SetValue(""ENUM_NAME"", Name(enum_def));
 code_.SetValue(""BASE_TYPE"", GetEnumTypeForDecl(enum_def.underlying_type));
- code_.SetValue(""SEP"", """");
 
 GenComment(enum_def.doc_comment);
 code_ += ""#[allow(non_camel_case_types)]"";
 class RustGenerator : public BaseGenerator {
 GenComment(ev.doc_comment, "" "");
 code_.SetValue(""KEY"", Name(ev));
 code_.SetValue(""VALUE"", NumToString(ev.value));
- code_ += ""{{SEP}} {{KEY}} = {{VALUE}}\\"";
- code_.SetValue(""SEP"", "",\n"");
+ code_ += "" {{KEY}} = {{VALUE}},"";
 
 minv = !minv || minv->value > ev.value ? &ev : minv;
 maxv = !maxv || maxv->value < ev.value ? &ev : maxv;
",1430,318
rust generator: fix builder lifetime switch (#4912)," class RustGenerator : public BaseGenerator {
 case ftInteger:
 case ftFloat:
 case ftBool:
- case ftTable:
 case ftEnumKey:
 case ftUnionKey:
 case ftStruct: { return false; }
",1429,317
rust: more builder lifetimes logic (#4917)," class RustGenerator : public BaseGenerator {
 case ftFloat:
 case ftBool:
 case ftEnumKey:
- case ftUnionKey:
- case ftStruct: { return false; }
+ case ftUnionKey: { return false; }
 default: { return true; }
 }
 }
",1428,316
rust: more builder lifetimes predicates (#4923)," class RustGenerator : public BaseGenerator {
 
 const Namespace *CurrentNameSpace() const { return cur_name_space_; }
 
- // Determine if a Type needs a lifetime template parameter when used in Rust.
- bool TypeNeedsLifetimeParameter(const Type &type) const {
+ // Determine if a Type needs a lifetime template parameter when used in the
+ // Rust builder args.
+ bool TableBuilderTypeNeedsLifetime(const Type &type) const {
 switch (GetFullType(type)) {
 case ftInteger:
 case ftFloat:
 case ftBool:
 case ftEnumKey:
- case ftUnionKey: { return false; }
+ case ftUnionKey:
+ case ftUnionValue: { return false; }
 default: { return true; }
 }
 }
 class RustGenerator : public BaseGenerator {
 continue;
 }
 
- if (TypeNeedsLifetimeParameter(field.value.type)) {
+ if (TableBuilderTypeNeedsLifetime(field.value.type)) {
 return true;
 }
 }
",1429,317
"Add ByteBufferFactory#releaseByteBuffer (#4914)

This adds the ability to dispose unused buffers or to return them to an object pool"," public class FlatBufferBuilder {
 * @return Returns the new `ByteBuffer` that was allocated.
 */
 ByteBuffer newByteBuffer(int capacity);
+
+ /**
+ * Release a ByteBuffer. Current {@link FlatBufferBuilder}
+ * released any reference to it, so it is safe to dispose the buffer
+ * or return it to a pool.
+ * It is not guaranteed that the buffer has been created
+ * with {@link #newByteBuffer(int) }.
+ *
+ * @param bb the buffer to release
+ */
+ default void releaseByteBuffer(ByteBuffer bb) {
+ }
 }
 
 /**
 public class FlatBufferBuilder {
 // Reallocate the buffer if needed.
 while (space < align_size + size + additional_bytes) {
 int old_buf_size = bb.capacity();
- bb = growByteBuffer(bb, bb_factory);
+ ByteBuffer old = bb;
+ bb = growByteBuffer(old, bb_factory);
+ if (old != bb) {
+ bb_factory.releaseByteBuffer(old);
+ }
 space += bb.capacity() - old_buf_size;
 }
 pad(align_size);
",364,123
"[C#] Fix compile issue when compiling with older versions of C# (#4938)

* C# support for directly reading and writting to memory other than byte[]. For example, ByteBuffer can be initialized with a custom allocator which uses shared memory / memory mapped files.

Public access to the backing buffer uses Span<T> instead of ArraySegment<T>.

Writing to the buffer now supports Span<T> in addition to T[].

To maintain backwards compatibility ENABLE_SPAN_T must be defined.

* Remove usage of expression bodied method so that ByteBuffer can be compiled with older version of C#."," namespace FlatBuffers
 }
 
 #if !ENABLE_SPAN_T
- public override byte[] ByteArray => _buffer;
+ public override byte[] ByteArray
+ {
+ get { return _buffer; }
+ }
 #endif
 
 #if UNSAFE_BYTEBUFFER
",630,115
"Changed JS/TS codegen to use stable non-compiler dependent hash.

Different implementations of std::hash kept littering commits with
namespace changes.

Change-Id: Ic2d4fdcd76f8fef9802bc1572eb74ae7427085e3"," class JsGenerator : public BaseGenerator {
 }
 
 static std::string GenFileNamespacePrefix(const std::string &file) {
- return ""NS"" + std::to_string(static_cast<unsigned long long>(
- std::hash<std::string>()(file)));
+ return ""NS"" + std::to_string(HashFnv1a<uint64_t>(file.c_str()));
 }
 
 static std::string GenPrefixedImport(const std::string &full_file_name,
",1082,243
"Add compare operator to code generated for c++ (#4940)

* Add operator== for c++ genated code

New ""--gen-compare"" option for flatc to generate compare operators. The operators are defined based on object based api types.

Inspired by issue #263.

* Improve compare operator for c++.
Thanks for the code review.

- Improve robustness against future schema extensions
- Code style
- Fix --rust generation in generate_code.sh"," struct IDLOptions {
 bool skip_unexpected_fields_in_json;
 bool generate_name_strings;
 bool generate_object_based_api;
+ bool gen_compare;
 std::string cpp_object_api_pointer_type;
 std::string cpp_object_api_string_type;
 bool gen_nullable;
 struct IDLOptions {
 skip_unexpected_fields_in_json(false),
 generate_name_strings(false),
 generate_object_based_api(false),
+ gen_compare(false),
 cpp_object_api_pointer_type(""std::unique_ptr""),
 gen_nullable(false),
 object_suffix(""T""),
",600,49
ToStringVisitor settings to allow pretty formatted JSON (#4933)," void UnionVectorTest() {
 ""characters_type: [ Belle, MuLan, BookFan, Other, Unused ], ""
 ""characters: [ { books_read: 7 }, { sword_attack_damage: 5 }, ""
 ""{ books_read: 2 }, \""Other\"", \""Unused\"" ] }"");
+
+
+ flatbuffers::ToStringVisitor visitor(""\n"", true, "" "");
+ IterateFlatBuffer(fbb.GetBufferPointer(), MovieTypeTable(), &visitor);
+ TEST_EQ_STR(
+ visitor.s.c_str(),
+ ""{\n""
+ "" \""main_character_type\"": \""Rapunzel\"",\n""
+ "" \""main_character\"": {\n""
+ "" \""hair_length\"": 6\n""
+ "" },\n""
+ "" \""characters_type\"": [\n""
+ "" \""Belle\"",\n""
+ "" \""MuLan\"",\n""
+ "" \""BookFan\"",\n""
+ "" \""Other\"",\n""
+ "" \""Unused\""\n""
+ "" ],\n""
+ "" \""characters\"": [\n""
+ "" {\n""
+ "" \""books_read\"": 7\n""
+ "" },\n""
+ "" {\n""
+ "" \""sword_attack_damage\"": 5\n""
+ "" },\n""
+ "" {\n""
+ "" \""books_read\"": 2\n""
+ "" },\n""
+ "" \""Other\"",\n""
+ "" \""Unused\""\n""
+ "" ]\n""
+ ""}"");
 }
 
 void ConformTest() {
",1534,129
"Add FlatBufferBuilder move semantics tests to the main test suite (#4902)

* Add FlatBufferBuilder move semantics tests to main

Do not eagerly delete/reset allocators in release and release_raw functions
Update android, vs2010 build files
New tests for various types of FlatBufferBuilders and move semantics

* Improve test failure output with function names","
 
 #include ""monster_test.grpc.fb.h""
 #include ""monster_test_generated.h""
+#include ""test_assert.h""
 
 using namespace MyGame::Example;
-int builder_tests();
+void message_builder_tests();
 
 // The callback implementation of our server, that derives from the generated
 // code. It implements all rpcs specified in the FlatBuffers schema.
 int grpc_server_test() {
 }
 
 int main(int /*argc*/, const char * /*argv*/ []) {
- return builder_tests() + grpc_server_test();
+ message_builder_tests();
+ grpc_server_test();
+
+ if (!testing_fails) {
+ TEST_OUTPUT_LINE(""ALL TESTS PASSED"");
+ return 0;
+ } else {
+ TEST_OUTPUT_LINE(""%d FAILED TESTS"", testing_fails);
+ return 1;
+ }
 }
 
",117,11
"rust: Fixed MakeCamelCase (#4932) (#4936)

* Fixed MakeCamelCase behavior when supplied Upper_Camel_Case,
snake_case and UPPERCASE strings.
* Modified the rust integration test to reflect changes."," static std::string GeneratedFileName(const std::string &path,
 std::string MakeSnakeCase(const std::string &in) {
 std::string s;
 for (size_t i = 0; i < in.length(); i++) {
- if (islower(in[i])) {
- s += static_cast<char>(in[i]);
- } else {
- if (i > 0) {
+ if (i == 0) {
+ s += static_cast<char>(tolower(in[0]));
+ } else if (in[i] == '_') {
+ s += '_';
+ } else if (!islower(in[i])) {
+ // Prevent duplicate underscores for Upper_Snake_Case strings
+ // and UPPERCASE strings.
+ if (islower(in[i - 1])) {
 s += '_';
 }
 s += static_cast<char>(tolower(in[i]));
+ } else {
+ s += in[i];
 }
 }
 return s;
",1433,319
don't return Option from required table field accessors (#4926)," impl<'a> Monster<'a> {
 self._tab.get::<i16>(Monster::VT_HP, Some(100)).unwrap()
 }
 #[inline]
- pub fn name(&'a self) -> Option<&'a str> {
- self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Monster::VT_NAME, None)
+ pub fn name(&'a self) -> &'a str {
+ self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Monster::VT_NAME, None).unwrap()
 }
 #[inline]
 pub fn key_compare_less_than(&self, o: &Monster) -> bool {
 impl<'a> Monster<'a> {
 }
 
 #[inline]
- pub fn key_compare_with_value(&self, val: Option<&str>) -> ::std::cmp::Ordering {
+ pub fn key_compare_with_value(&self, val: & str) -> ::std::cmp::Ordering {
 let key = self.name();
 key.cmp(&val)
 }
",1587,21
Add missed defined(clang) and fix the wrong placement of #pragma push/pop for MSVC compiler (#4946)," class FlatBufferBuilder {
 }
 
 /// @brief Get the released pointer to the serialized buffer.
- /// @param The size of the memory block containing 
+ /// @param The size of the memory block containing
 /// the serialized `FlatBuffer`.
- /// @param The offset from the released pointer where the finished 
+ /// @param The offset from the released pointer where the finished
 /// `FlatBuffer` starts.
- /// @return A raw pointer to the start of the memory block containing 
- /// the serialized `FlatBuffer`. 
+ /// @return A raw pointer to the start of the memory block containing
+ /// the serialized `FlatBuffer`.
 /// @remark If the allocator is owned, it gets deleted during this call.
 uint8_t *ReleaseRaw(size_t &size, size_t &offset) {
 Finished();
 volatile __attribute__((weak)) const char *flatbuffer_version_string =
 /// @endcond
 } // namespace flatbuffers
 
-#if defined(_MSC_VER)
- #pragma warning(pop)
-#endif
 // clang-format on
 
 #endif // FLATBUFFERS_H_
",1423,375
loosen lifetimes in type signature of Table::get (#4925)," impl<'a> Table<'a> {
 Table { buf: buf, loc: loc }
 }
 #[inline]
- pub fn vtable(&'a self) -> VTable<'a> {
+ pub fn vtable(&self) -> VTable<'a> {
 <BackwardsSOffset<VTable<'a>>>::follow(self.buf, self.loc)
 }
 #[inline]
 pub fn get<T: Follow<'a> + 'a>(
- &'a self,
+ &self,
 slot_byte_loc: VOffsetT,
 default: Option<T::Inner>,
 ) -> Option<T::Inner> {
",56,3
"Remove lifetime specifier on table getter methods (#4949)

With the old-style code, the test fails with a borrow-checker error:

```
 #[inline]
 pub fn name(&'a self) -> &'a str {
 self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Monster::VT_NAME, None).unwrap()
 }
```

```
error[E0597]: `e` does not live long enough
 --> tests/integration_test.rs:273:57
 |
273 | let enemy_of_my_enemy = monster.enemy().map(|e| e.name());
 | ^ - `e` dropped here while still borrowed
 | |
 | borrowed value does not live long enough
274 | assert_eq!(enemy_of_my_enemy, Some(""Fred""));
275 | }
 | - borrowed value needs to live until here
```"," class RustGenerator : public BaseGenerator {
 
 GenComment(field.doc_comment, "" "");
 code_ += "" #[inline]"";
- code_ += "" pub fn {{FIELD_NAME}}(&'a self) -> {{RETURN_TYPE}} {"";
+ code_ += "" pub fn {{FIELD_NAME}}(&self) -> {{RETURN_TYPE}} {"";
 code_ += "" {{FUNC_BODY}}"";
 code_ += "" }"";
 
",1436,319
Parser error message reports both the line number and the cursor position. (#4954)," struct IDLOptions {
 
 // This encapsulates where the parser is in the current source file.
 struct ParserState {
- ParserState() : cursor_(nullptr), line_(1), token_(-1) {}
+ ParserState()
+ : cursor_(nullptr), line_start_(nullptr), line_(0), token_(-1) {}
 
 protected:
+ void ResetState(const char *source) {
+ cursor_ = source;
+ line_ = 0;
+ MarkNewLine();
+ }
+
+ void MarkNewLine() {
+ line_start_ = cursor_;
+ line_ += 1;
+ }
+
+ int64_t CursorPosition() const {
+ FLATBUFFERS_ASSERT(cursor_ && line_start_ && cursor_ >= line_start_);
+ return static_cast<int64_t>(cursor_ - line_start_);
+ }
+
 const char *cursor_;
+ const char *line_start_;
 int line_; // the current line being parsed
 int token_;
 
",615,54
Allow tables that are entirely composed of native inlines to be copied. (#4958)," class CppGenerator : public BaseGenerator {
 for (auto fit = ev.union_type.struct_def->fields.vec.begin();
 fit != ev.union_type.struct_def->fields.vec.end(); ++fit) {
 const auto &field = **fit;
- if (!field.deprecated && field.value.type.struct_def) {
+ if (!field.deprecated && field.value.type.struct_def &&
+ !field.native_inline) {
 copyable = false;
 break;
 }
",2295,485
"Use standard header for generated Go files (#4961)

As recommended by https://golang.org/pkg/cmd/go/internal/generate/:

 To convey to humans and machine tools that code is generated,
 generated source should have a line early in the file that
 matches the following regular expression (in Go syntax):

 ^// Code generated .* DO NOT EDIT\.$"," class GoGenerator : public BaseGenerator {
 void BeginFile(const std::string name_space_name, const bool needs_imports,
 std::string *code_ptr) {
 std::string &code = *code_ptr;
- code = code + ""// "" + FlatBuffersGeneratedWarning() + ""\n\n"";
+ code = code + ""// Code generated by the FlatBuffers compiler. DO NOT EDIT.\n\n"";
 code += ""package "" + name_space_name + ""\n\n"";
 if (needs_imports) {
 code += ""import (\n"";
",639,116
"Assert tests on the first failure. (#4952)

* Assert tests on the first failure. Disable pop-up message box on assertion.

* Fix format and code style

* Move MSVC dependent code to ifdef","
-/*
+/*
 * Copyright 2014 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 int FlatBufferTests() {
 }
 
 int main(int /*argc*/, const char * /*argv*/ []) {
+ InitTestEngine();
 
 FlatBufferTests();
 FlatBufferBuilderTest();
",1520,125
"Adds __reset method to Struct and Table (#4966)

This allow recycling/pooling instances without leaking ByteBuffers, by
providing a mechanism to reset instance to newly constructed state."," public class Struct {
 protected int bb_pos;
 /** The underlying ByteBuffer to hold the data of the Struct. */
 protected ByteBuffer bb;
+
+ /**
+ * Resets internal state with a null {@code ByteBuffer} and a zero position.
+ *
+ * This method exists primarily to allow recycling Struct instances without risking memory leaks
+ * due to {@code ByteBuffer} references. The instance will be unusable until it is assigned
+ * again to a {@code ByteBuffer}.
+ *
+ * @param struct the instance to reset to initial state
+ */
+ public void __reset() {
+ bb = null;
+ bb_pos = 0;
+ }
 }
 
 /// @endcond
",10,1
"Bumped version to 1.10.1 for all languages.

Change-Id: I9a6256d90ea800834a887afdcf888df412018933"," from conans import ConanFile, CMake, tools
 
 class FlatbuffersConan(ConanFile):
 name = ""flatbuffers""
- version = ""1.9.0""
+ version = ""1.10.0""
 license = ""Apache-2.0""
 url = ""https://github.com/google/flatbuffers""
 homepage = ""http://google.github.io/flatbuffers/""
",51,11
"Fix recursion counter check. Add control to override depth of nested  (#4953)

* Fix recursion counter check. Add control to override depth of nested objects.

* Change if-condition to `>=`","
 // This file defines the data types representing a parsed IDL (Interface
 // Definition Language) / schema file.
 
+// Limits maximum depth of nested objects.
+// Prevents stack overflow while parse flatbuffers or json.
+#if !defined(FLATBUFFERS_MAX_PARSING_DEPTH)
+# define FLATBUFFERS_MAX_PARSING_DEPTH 64
+#endif
+
 namespace flatbuffers {
 
 // The order of these matters for Is*() functions below.
 class Parser : public ParserState {
 bool SupportsVectorOfUnions() const;
 Namespace *UniqueNamespace(Namespace *ns);
 
- enum { kMaxParsingDepth = 64 };
 FLATBUFFERS_CHECKED_ERROR RecurseError();
 template<typename F> CheckedError Recurse(F f) {
- if (++recurse_protection_counter >= kMaxParsingDepth) return RecurseError();
+ if (recurse_protection_counter >= (FLATBUFFERS_MAX_PARSING_DEPTH))
+ return RecurseError();
+ recurse_protection_counter++;
 auto ce = f();
 recurse_protection_counter--;
 return ce;
",616,54
"In Javascript, generate bidirectional mappings for enums, between Name: Value and between Value: Name. (#4960)"," class JsGenerator : public BaseGenerator {
 if (it != enum_def.vals.vec.begin()) { code += '\n'; }
 GenDocComment(ev.doc_comment, code_ptr, """", "" "");
 }
+
+ // Generate mapping between EnumName: EnumValue(int)
 code += "" "" + ev.name;
 code += lang_.language == IDLOptions::kTs ? ""= "" : "": "";
 code += NumToString(ev.value);
+
+ if (lang_.language == IDLOptions::kJs) {
+ // In pure Javascript, generate mapping between EnumValue(int):
+ // 'EnumName' so enums can be looked up by their ID.
+ code += "", "";
+
+ code += NumToString(ev.value);
+ code += lang_.language == IDLOptions::kTs ? ""= "" : "": "";
+ code += ""'"" + ev.name + ""'"";
+ }
+
 code += (it + 1) != enum_def.vals.vec.end() ? "",\n"" : ""\n"";
 
 if (ev.union_type.struct_def) {
",1088,245
Use enum types in generated read/mutate methods for Go (#4978)," static std::string GenGetter(const Type &type) {
 case BASE_TYPE_STRING: return ""rcv._tab.ByteVector"";
 case BASE_TYPE_UNION: return ""rcv._tab.Union"";
 case BASE_TYPE_VECTOR: return GenGetter(type.VectorType());
- default: return ""rcv._tab.Get"" + MakeCamel(GenTypeGet(type));
+ default: return ""rcv._tab.Get"" + MakeCamel(GenTypeBasic(type));
 }
 }
 
 static std::string GenTypePointer(const Type &type) {
 }
 
 static std::string GenTypeGet(const Type &type) {
+ if (type.enum_def != nullptr && !type.enum_def->is_union) {
+ return GetEnumTypeName(*type.enum_def);
+ }
 return IsScalar(type.base_type) ? GenTypeBasic(type) : GenTypePointer(type);
 }
 
",642,118
"Fix expected type of enum values in reflection tables (#4944)

Fixes #4930"," struct TypeTable {
 size_t num_elems; // of type_codes, values, names (but not type_refs).
 const TypeCode *type_codes; // num_elems count
 const TypeFunction *type_refs; // less than num_elems entries (see TypeCode).
- const int32_t *values; // Only set for non-consecutive enum/union or structs.
+ const int64_t *values; // Only set for non-consecutive enum/union or structs.
 const char * const *names; // Only set if compiled with --reflect-names.
 };
 
",1425,375
"don't crash when calling EnumNameXXX on sparse enum (#4982)

Make an out-of-bounds check for enum values before using them to index the
names array. For consistency with non-sparse enums an empty string is
returned.

Fixes #4821"," inline const char * const *EnumNamesColor() {
 }
 
 inline const char *EnumNameColor(Color e) {
+ if (e < Color_Red || e > Color_Blue) return """";
 const size_t index = static_cast<int>(e);
 return EnumNamesColor()[index];
 }
 inline const char * const *EnumNamesEquipment() {
 }
 
 inline const char *EnumNameEquipment(Equipment e) {
+ if (e < Equipment_NONE || e > Equipment_Weapon) return """";
 const size_t index = static_cast<int>(e);
 return EnumNamesEquipment()[index];
 }
",734,171
"Add @javax.annotation.Generated to generated flatbuffer Java types (#4986)

* Add @javax.annotation.Generated to generated flatbuffer Java types.

* Updating test goldens."," struct LanguageParameters {
 std::string optional_suffix;
 std::string includes;
 std::string class_annotation;
+ std::string generated_type_annotation;
 CommentConfig comment_config;
 };
 
 const LanguageParameters &GetLangParams(IDLOptions::Language lang) {
 """",
 ""import java.nio.*;\nimport java.lang.*;\nimport ""
 ""java.util.*;\nimport com.google.flatbuffers.*;\n"",
- ""\n@SuppressWarnings(\""unused\"")\n"",
+ ""\n@SuppressWarnings(\""unused\"")"",
+ ""\n@javax.annotation.Generated(value=\""flatc\"")\n"",
 {
 ""/**"",
 "" *"",
 const LanguageParameters &GetLangParams(IDLOptions::Language lang) {
 ""?"",
 ""using global::System;\nusing global::FlatBuffers;\n\n"",
 """",
+ """",
 {
 nullptr,
 ""///"",
 class GeneralGenerator : public BaseGenerator {
 }
 code += lang_.class_annotation;
 }
+ code += lang_.generated_type_annotation;
 code += classcode;
 if (!namespace_name.empty()) code += lang_.namespace_end;
 auto filename = NamespaceDir(ns) + defname + lang_.file_extension;
",1337,311
"Refactoring of idl_parser (#4948)

* Refactoring of numbers parser

More accurate parse of float and double.
Hexadecimal floats.
Check ""out-of-range"" of uint64 fields.
Check correctness of default values and metadata.

* Remove locale-independent code strtod/strtof from PR #4948.

* small optimization

* Add is_(ascii) functions

* is_ascii cleanup

* Fix format conversation

* Refine number parser

* Make code compatible with Android build

* Remove unnecessary suppression of warning C4127","
 #endif // __has_include
 #endif // !FLATBUFFERS_HAS_STRING_VIEW
 
+#ifndef FLATBUFFERS_HAS_NEW_STRTOD
+ // Modern (C++11) strtod and strtof functions are available for use.
+ // 1) nan/inf strings as argument of strtod;
+ // 2) hex-float as argument of strtod/strtof.
+ #if (defined(_MSC_VER) && _MSC_VER >= 1900) || \
+ (defined(__GNUC__) && (__GNUC__ * 100 + __GNUC_MINOR__ >= 409)) || \
+ (defined(__clang__))
+ #define FLATBUFFERS_HAS_NEW_STRTOD 1
+ #endif
+#endif // !FLATBUFFERS_HAS_NEW_STRTOD
+
 /// @endcond
 
 /// @file
",72,13
fix missing newline in flatc help message (#4992)," std::string FlatCompiler::GetUsageString(const char *program_name) const {
 "" --reflect-names Add minimal type/name reflection.\n""
 "" --root-type T Select or override the default root_type\n""
 "" --force-defaults Emit default values in binary output from JSON\n""
- "" --force-empty When serializing from object API representation, ""
+ "" --force-empty When serializing from object API representation,\n""
 "" force strings and vectors to empty rather than null.\n""
 ""FILEs may be schemas (must end in .fbs), or JSON files (conforming to preceding\n""
 ""schema). FILEs after the -- must be binary flatbuffer format files.\n""
",387,116
"disallow c style casts (#4981)

Fixes #4857."," class FlatBufferBuilder {
 extern T Pack(const S &);
 typedef T (*Pack_t)(const S &);
 std::vector<T> vv(len);
- std::transform(v, v + len, vv.begin(), *(Pack_t)&Pack);
+ std::transform(v, v + len, vv.begin(), static_cast<Pack_t&>(Pack));
 return CreateVectorOfStructs<T>(vv.data(), vv.size());
 }
 
 class FlatBufferBuilder {
 extern T Pack(const S &);
 typedef T (*Pack_t)(const S &);
 std::vector<T> vv(len);
- std::transform(v, v + len, vv.begin(), *(Pack_t)&Pack);
+ std::transform(v, v + len, vv.begin(), static_cast<Pack_t&>(Pack));
 return CreateVectorOfSortedStructs<T>(vv, len);
 }
 
",1425,375
"Go - Use Go bool type for bool fields (#4962)

* Use Go bool type for bool fields, and store non-default bool field to test data"," namespace flatbuffers {
 #define FLATBUFFERS_GEN_TYPES_SCALAR(TD) \
 TD(NONE, """", uint8_t, byte, byte, byte, uint8, u8) \
 TD(UTYPE, """", uint8_t, byte, byte, byte, uint8, u8) /* begin scalar/int */ \
- TD(BOOL, ""bool"", uint8_t, boolean,byte, bool, bool, bool) \
+ TD(BOOL, ""bool"", uint8_t, boolean,bool, bool, bool, bool) \
 TD(CHAR, ""byte"", int8_t, byte, int8, sbyte, int8, i8) \
 TD(UCHAR, ""ubyte"", uint8_t, byte, byte, byte, uint8, u8) \
 TD(SHORT, ""short"", int16_t, short, int16, short, int16, i16) \
",605,52
"CI check generate code (#4998)

* call reflection code generation from tests

This simplifies instructions to contributors so they don't forget to update
reflection code.

* add error handling to generate_code scripts

Let them propagate their errors instead of swallowing them so they show
up when called in CI.

* apply editorconfig to shell scripts

* use ordered map in dart codegen

Using an unordered map in the codegen can lead to spurious diffs in the
generated dart code.

* add CI check for generate_code being run

* update reflection_generated.h

* disable diff-check for monster_test.bfbs

Work around #5008."," inline const char * const *EnumNamesBaseType() {
 }
 
 inline const char *EnumNameBaseType(BaseType e) {
+ if (e < None || e > Union) return """";
 const size_t index = static_cast<int>(e);
 return EnumNamesBaseType()[index];
 }
",1088,306
"Add fuzzer test for scalar numbers in json. (#4996)

* Add fuzzer test for scalar numbers in json. Grammar-based regex used to check correctness.

* Fix conversation","
 #define _CRTDBG_MAP_ALLOC
 #endif
 
-#include <assert.h>
-
 #if !defined(FLATBUFFERS_ASSERT)
+#include <assert.h>
 #define FLATBUFFERS_ASSERT assert
+#elif defined(FLATBUFFERS_ASSERT_INCLUDE)
+// Include file with forward declaration
+#include FLATBUFFERS_ASSERT_INCLUDE
 #endif
 
 #ifndef ARDUINO
",73,13
"make flatbuffers::IsFieldPresent safer (#4988)

Give the vtable offset enum inside each table the name
""FlatBuffersVTableOffset"" and base type voffset_t so it can be used as a
dependent type in IsFieldPresent. This makes that function slightly
safer since it prevents calling it with arbitrary, non-table types.
Now, the only way to use IsFieldPresent incorrectly is to create your
own type which does not inherit from flatbuffers::Table but has a
dependent voffset convertible type ""FlatBuffersVTableOffset"".","
 defined(__clang__)
 #define FLATBUFFERS_FINAL_CLASS final
 #define FLATBUFFERS_OVERRIDE override
+ #define FLATBUFFERS_VTABLE_UNDERLYING_TYPE : flatbuffers::voffset_t
 #else
 #define FLATBUFFERS_FINAL_CLASS
 #define FLATBUFFERS_OVERRIDE
+ #define FLATBUFFERS_VTABLE_UNDERLYING_TYPE
 #endif
 
 #if (!defined(_MSC_VER) || _MSC_VER >= 1900) && \
",73,13
Use stdlib context in generated Go files (#4904)," void GenerateImports(grpc_generator::File *file, grpc_generator::Printer *printe
 }
 printer->Print(""import (\n"");
 printer->Indent();
-printer->Print(vars, ""$context$ \""golang.org/x/net/context\""\n"");
+printer->Print(vars, ""$context$ \""context\""\n"");
 printer->Print(vars, ""$grpc$ \""google.golang.org/grpc\""\n"");
 printer->Outdent();
 printer->Print("")\n\n"");
",361,60
"clean up unnecessary outer rust gen-snippet (#5013)

* clean up unneeded outer rust gen-snippet

* update generated rust file"," class RustGenerator : public BaseGenerator {
 // structs, and tables) and output them to a single file.
 bool generate() {
 code_.Clear();
- code_ += ""// "" + std::string(FlatBuffersGeneratedWarning()) + ""\n\n"";
- code_ += ""#![allow(dead_code)]"";
- code_ += ""#![allow(unused_imports)]"";
- code_ += ""extern crate flatbuffers;\n"";
+ code_ += ""// "" + std::string(FlatBuffersGeneratedWarning()) + ""\n\n""; 
 
 assert(!cur_name_space_);
 
",1433,319
"Add 'fsanitize=address,undefined' to tests and flatc targets (#5009)

* Add '-fsanitize' optional flags to flattests and flatc targets

Control: -DFLATBUFFERS_CODE_SANITIZE=(ON | OFF | ""=memory,undefined"")
Travis-CI: building with -DFLATBUFFERS_CODE_SANITIZE=ON

* Fix -pie flag

* Cleanup","
 #endif
 #endif // !FLATBUFFERS_HAS_NEW_STRTOD
 
+// Suppress sanitizer directives.
+#if defined(__clang__)
+ #define __no_sanitize_undefined__(reason) __attribute__((no_sanitize(""undefined"")))
+#elif defined(__GNUC__) && (__GNUC__ * 100 + __GNUC_MINOR__ >= 408)
+ #define __no_sanitize_undefined__(reason) __attribute__((no_sanitize_undefined))
+#else
+ #define __no_sanitize_undefined__(reason)
+#endif
+
 /// @endcond
 
 /// @file
 template<typename T> T EndianScalar(T t) {
 #endif
 }
 
-template<typename T> T ReadScalar(const void *p) {
+template<typename T>
+__no_sanitize_undefined__(""C++ aliasing type rules, see std::bit_cast<>"")
+T ReadScalar(const void *p) {
 return EndianScalar(*reinterpret_cast<const T *>(p));
 }
 
-template<typename T> void WriteScalar(void *p, T t) {
+template<typename T>
+__no_sanitize_undefined__(""C++ aliasing type rules, see std::bit_cast<>"")
+void WriteScalar(void *p, T t) {
 *reinterpret_cast<T *>(p) = EndianScalar(t);
 }
 
",77,13
"Disallowed 0 byte structs.

This is because they are incompatible with C++ and possibly other
languages that make them minimum size 1 (to make sure multiple
such objects don't reside at the same address). Forcing them to size
1 was also not practical, as that is requires updating the logic
of a lot of implementations and thus possibly backwards incompatible.

More here: https://github.com/google/flatbuffers/issues/4122

Change-Id: I2bfdc8597b7cfd2235bb4074bb2ae06f81f8e57d"," void ErrorTest() {
 TestError(""enum X:byte (bit_flags) { Y=8 }"", ""bit flag out"");
 TestError(""table X { Y:int; } table X {"", ""datatype already"");
 TestError(""struct X (force_align: 7) { Y:int; }"", ""force_align"");
+ TestError(""struct X {}"", ""size 0"");
 TestError(""{}"", ""no root"");
 TestError(""table X { Y:byte; } root_type X; { Y:1 } { Y:1 }"", ""end of file"");
 TestError(""table X { Y:byte; } root_type X; { Y:1 } table Y{ Z:int }"",
",1808,152
"make unions with type aliases more usable (#5019)

Some generic C++ and Rust code is not generated when unions use type
aliases because of potential ambiguity. Actually check for this
ambiguity and only disable offending code only if it is found."," struct EnumVal {
 };
 
 struct EnumDef : public Definition {
- EnumDef() : is_union(false), uses_type_aliases(false) {}
+ EnumDef() : is_union(false), uses_multiple_type_instances(false) {}
 
 EnumVal *ReverseLookup(int64_t enum_idx, bool skip_union_default = true) {
 for (auto it = vals.vec.begin() +
 struct EnumDef : public Definition {
 
 SymbolTable<EnumVal> vals;
 bool is_union;
- bool uses_type_aliases;
+ // Type is a union which uses type aliases where at least one type is
+ // available under two different names.
+ bool uses_multiple_type_instances;
 Type underlying_type;
 };
 
",605,52
"Fix a memory leak in builder test (#5021)

* Fix a memory leak in builder test

* using RAII to free memory"," bool release_n_verify(flatbuffers::grpc::MessageBuilder &mbb, const std::string
 // clang-format off
 #if !defined(FLATBUFFERS_CPP98_STL)
 // clang-format on
+// Invokes this function when testing the following Builder types
+// FlatBufferBuilder, TestHeapBuilder, and GrpcLikeMessageBuilder
 template <class Builder>
 void builder_move_assign_after_releaseraw_test(Builder b1) {
 auto root_offset1 = populate1(b1);
 b1.Finish(root_offset1);
 size_t size, offset;
- b1.ReleaseRaw(size, offset);
+ std::shared_ptr<uint8_t> raw(b1.ReleaseRaw(size, offset), [size](uint8_t *ptr) {
+ flatbuffers::DefaultAllocator::dealloc(ptr, size);
+ });
 Builder src;
 auto root_offset2 = populate2(src);
 src.Finish(root_offset2);
",250,28
"Fixed missing code from @javax.annotation PR.

https://github.com/google/flatbuffers/pull/4986 missed part of the
implementation.

Change-Id: Ie41771eb018a550c289c77ebe9ef5c50d1ad6751"," struct IDLOptions {
 std::string cpp_object_api_pointer_type;
 std::string cpp_object_api_string_type;
 bool gen_nullable;
+ bool gen_generated;
 std::string object_prefix;
 std::string object_suffix;
 bool union_value_namespacing;
 struct IDLOptions {
 gen_compare(false),
 cpp_object_api_pointer_type(""std::unique_ptr""),
 gen_nullable(false),
+ gen_generated(false),
 object_suffix(""T""),
 union_value_namespacing(true),
 allow_non_utf8(false),
 extern bool GenerateLobster(const Parser &parser,
 // Generate Lua files from the definitions in the Parser object.
 // See idl_gen_lua.cpp.
 extern bool GenerateLua(const Parser &parser,
- const std::string &path,
- const std::string &file_name);
+ const std::string &path,
+ const std::string &file_name);
 
 // Generate Rust files from the definitions in the Parser object.
 // See idl_gen_rust.cpp.
",607,52
"Fixed vectors of enums in object API serialized incorrectly.

And also added tests for them.

Change-Id: I91af1904105435601287291412e82d5066f476a5
Tested: on Linux."," class FlatBufferBuilder {
 reinterpret_cast<uint8_t **>(buf));
 }
 
+
+ // @brief Create a vector of scalar type T given as input a vector of scalar
+ // type U, useful with e.g. pre ""enum class"" enums, or any existing scalar
+ // data of the wrong type.
+ template<typename T, typename U>
+ Offset<Vector<T>> CreateVectorScalarCast(const U *v, size_t len) {
+ AssertScalarT<T>();
+ AssertScalarT<U>();
+ StartVector(len, sizeof(T));
+ for (auto i = len; i > 0;) { PushElement(static_cast<T>(v[--i])); }
+ return Offset<Vector<T>>(EndVector(len));
+ }
+
 /// @brief Write a struct by itself, typically to be part of a union.
 template<typename T> Offset<const T *> CreateStruct(const T &structobj) {
 NotNested();
",1443,380
"Fixed STLPort build

Change-Id: I2b9508f547667695475be64fa56f64f129603fd4"," class CppGenerator : public BaseGenerator {
 // the underlying storage type (eg. uint8_t).
 const auto basetype = GenTypeBasic(
 field.value.type.enum_def->underlying_type, false);
- code += ""_fbb.CreateVectorScalarCast<"" + basetype + "">("" + value +
- "".data(), "" + value + "".size())"";
+ code += ""_fbb.CreateVectorScalarCast<"" + basetype +
+ "">(flatbuffers::data("" + value + ""), "" + value +
+ "".size())"";
 } else if (field.attributes.Lookup(""cpp_type"")) {
 auto type = GenTypeBasic(vector_type, false);
 code += ""_fbb.CreateVector<"" + type + "">("" + value + "".size(), "";
",2303,488
"FlexBuffer to JSON convertor for typed and fixedTypedvectors (#4947)

* FlexBuffer to JSON convertor for typed and fixedTypedvectors

* moving the common implementation to template

* signed unsigned comparison fix

* fix a formatting ({

* changing logic to append comma in vector of elements in json"," class Map : public Vector {
 bool IsTheEmptyMap() const { return data_ == EmptyMap().data_; }
 };
 
+template<typename T>
+void AppendToString(std::string &s, T &&v, bool keys_quoted) {
+ s += ""[ "";
+ for (size_t i = 0; i < v.size(); i++) {
+ if (i) s += "", "";
+ v[i].ToString(true, keys_quoted, s);
+ }
+ s += "" ]"";
+}
+
 class Reference {
 public:
 Reference(const uint8_t *data, uint8_t parent_width, uint8_t byte_width,
 class Reference {
 }
 s += "" }"";
 } else if (IsVector()) {
- s += ""[ "";
- auto v = AsVector();
- for (size_t i = 0; i < v.size(); i++) {
- v[i].ToString(true, keys_quoted, s);
- if (i < v.size() - 1) s += "", "";
- }
- s += "" ]"";
+ AppendToString<Vector>(s, AsVector(), keys_quoted);
+ } else if (IsTypedVector()) {
+ AppendToString<TypedVector>(s, AsTypedVector(), keys_quoted);
+ } else if (IsFixedTypedVector()) {
+ AppendToString<FixedTypedVector>(s, AsFixedTypedVector(), keys_quoted);
 } else {
 s += ""(?)"";
 }
",1160,384
"Wrong int32 min-max range definition on numTypes.lua (#5031)

* Update numTypes.lua

int32 range was wrongly defined.

* Update numTypes.lua

Fix number 32 to 31"," local int16_mt =
 local int32_mt = 
 {
 bytewidth = 4,
- min_value = -2^15,
- max_value = 2^15-1,
+ min_value = -2^31,
+ max_value = 2^31-1,
 lua_type = type(1),
 name = ""int32"",
 packFmt = ""<i4""
 end
 
 GenerateTypes(m)
 
-return m
\ No newline at end of file
+return m
",166,18
flexbuffers blob to string implementation (#5039)," class Reference {
 AppendToString<TypedVector>(s, AsTypedVector(), keys_quoted);
 } else if (IsFixedTypedVector()) {
 AppendToString<FixedTypedVector>(s, AsFixedTypedVector(), keys_quoted);
+ } else if (IsBlob()) {
+ auto blob = AsBlob();
+ flatbuffers::EscapeString(reinterpret_cast<const char*>(blob.data()), blob.size(), &s, true, false);
 } else {
 s += ""(?)"";
 }
",1163,385
"Make flatbuffer C++ tests work when vendored with bazel (#5040)

Tests for third_party code are run out of the main workspace. This
isn't an issue when the main workspace is the
com_github_google_flatbuffers workspace, but is an issue when you are
running the tests from another repository.

To reproduce, use ""git_repository"" to add flatbuffers to a project and
then run:
 bazel test @com_github_google_flatbuffers//:flatbuffers_test"," uint32_t lcg_rand() {
 }
 void lcg_reset() { lcg_seed = 48271; }
 
-std::string test_data_path = ""tests/"";
+std::string test_data_path =
+#ifdef BAZEL_TEST_DATA_PATH
+ ""../com_github_google_flatbuffers/tests/"";
+#else
+ ""tests/"";
+#endif
 
 // example of how to build up a serialized buffer algorithmically:
 flatbuffers::DetachedBuffer CreateFlatBufferTest(std::string &buffer) {
",1821,153
"Fixed double generated file name postfix (#5046)

* Fixed double generated file name postfix

* Fixed missing file postfix on imports without reexports"," class JsGenerator : public BaseGenerator {
 const auto basename =
 flatbuffers::StripPath(flatbuffers::StripExtension(file.first));
 if (basename != file_name_) {
- const auto file_name = basename + kGeneratedFileNamePostfix;
-
 if (imported_files.find(file.first) == imported_files.end()) {
- code += GenPrefixedImport(file.first, file_name);
+ code += GenPrefixedImport(file.first, basename);
 imported_files.emplace(file.first);
 }
 
",1123,253
"Make the Parser independent from the global C-locale (#5028)

* Make the Parser independent from the global C-locale

* Set a specific test locale using the environment variable FLATBUFFERS_TEST_LOCALE

* Remove redundant static qualifiers","
-/*
+/*
 * Copyright 2014 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 CheckedError Parser::ParseHexNum(int nibbles, uint64_t *val) {
 return Error(""escape code must be followed by "" + NumToString(nibbles) +
 "" hex digits"");
 std::string target(cursor_, cursor_ + nibbles);
- *val = StringToUInt(target.c_str(), nullptr, 16);
+ *val = StringToUInt(target.c_str(), 16);
 cursor_ += nibbles;
 return NoError();
 }
",2371,729
"Make string/vector field serialization order not depend on optimizer.

Multiple calls of e.g. CreateString inside a call to a CreateTable
could cause those strings to end up in different locations in the
wire format, since order or argument evaluation is undefined.

This is allowed by the FlatBuffer format, but it is not helpful,
especially when debugging the contents of binaries, or comparing
against a ""golden"" binary for tests etc.

Now making sure that all the CreateTableDirect calls first serialize
sub strings/vectors before calling CreateTable.

Also made similar changes to the serialization of ""binary schemas"".

Change-Id: I5747c4038b37a0d400aca2bc592bec751cf5c172"," inline flatbuffers::Offset<Movie> CreateMovieDirect(
 flatbuffers::Offset<void> main_character = 0,
 const std::vector<uint8_t> *characters_type = nullptr,
 const std::vector<flatbuffers::Offset<void>> *characters = nullptr) {
+ auto characters_type__ = characters_type ? _fbb.CreateVector<uint8_t>(*characters_type) : 0;
+ auto characters__ = characters ? _fbb.CreateVector<flatbuffers::Offset<void>>(*characters) : 0;
 return CreateMovie(
 _fbb,
 main_character_type,
 main_character,
- characters_type ? _fbb.CreateVector<uint8_t>(*characters_type) : 0,
- characters ? _fbb.CreateVector<flatbuffers::Offset<void>>(*characters) : 0);
+ characters_type__,
+ characters__);
 }
 
 flatbuffers::Offset<Movie> CreateMovie(flatbuffers::FlatBufferBuilder &_fbb, const MovieT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
",742,182
disable unimportant RAM-heavy test b/c Windows (#5047)," fn serialized_example_is_accessible_and_correct(bytes: &[u8], identifier_require
 Ok(())
 }
 
-#[test]
-fn builder_initializes_with_maximum_buffer_size() {
- flatbuffers::FlatBufferBuilder::new_with_capacity(flatbuffers::FLATBUFFERS_MAX_BUFFER_SIZE);
-}
+// Disabled due to Windows CI limitations.
+// #[test]
+// fn builder_initializes_with_maximum_buffer_size() {
+// flatbuffers::FlatBufferBuilder::new_with_capacity(flatbuffers::FLATBUFFERS_MAX_BUFFER_SIZE);
+// }
 
 #[should_panic]
 #[test]
",2403,92
"Fix create_vector_of_strings to use the stack, and test it. (#5074)"," pub use monster_test_generated::my_game;
 // verbatim from the test suite:
 fn create_serialized_example_with_generated_code(builder: &mut flatbuffers::FlatBufferBuilder) {
 let mon = {
+ let _ = builder.create_vector_of_strings(&[""these"", ""unused"", ""strings"", ""check"", ""the"", ""create_vector_of_strings"", ""function""]);
+
 let s0 = builder.create_string(""test1"");
 let s1 = builder.create_string(""test2"");
 let fred_name = builder.create_string(""Fred"");
 fn main() {
 create_serialized_example_with_generated_code(builder);
 }
 
- // reset the builder, clearing its heap-allocted memory:
+ // reset the builder, clearing its heap-allocated memory:
 builder.reset();
 
 {
",106,5
[net] Fix issue #5036 when write a double value into bytebuffer at big endian machine with unsafe mode. (#5076)," namespace FlatBuffers
 }
 else
 {
- *(ulong*)(ptr + offset) = ReverseBytes(*(ulong*)(ptr + offset));
+ *(ulong*)(ptr + offset) = ReverseBytes(*(ulong*)(&value));
 }
 }
 #else // !UNSAFE_BYTEBUFFER
",630,115
Renamed JS generator to explicitly state it generates TS too (#5043)," extern bool GenerateDart(const Parser &parser,
 
 // Generate JavaScript or TypeScript code from the definitions in the Parser object.
 // See idl_gen_js.
-extern bool GenerateJS(const Parser &parser,
+extern bool GenerateJSTS(const Parser &parser,
 const std::string &path,
 const std::string &file_name);
 
 extern bool GenerateFBS(const Parser &parser,
 
 // Generate a make rule for the generated JavaScript or TypeScript code.
 // See idl_gen_js.cpp.
-extern std::string JSMakeRule(const Parser &parser,
+extern std::string JSTSMakeRule(const Parser &parser,
 const std::string &path,
 const std::string &file_name);
 
",607,52
"Get rid of reproducible build warning by removing build date & time from flatc version (#5086)

* disable reproducible build warning due to date/time macros

* wrapped GCC pragmas in #ifdef _GNUC_

* removed __DATE__ and __TIME__ macros from flatc.cpp","
 
 #include <list>
 
-#define FLATC_VERSION ""1.10.0 ("" __DATE__ "" "" __TIME__ "")""
+#define FLATC_VERSION ""1.10.0""
 
 namespace flatbuffers {
 
",390,117
Fix 'no_sanitize_undefined' attribute for GCC4.8 (#5090),"
 // - __supress_ubsan__(""signed-integer-overflow"")
 #if defined(__clang__)
 #define __supress_ubsan__(type) __attribute__((no_sanitize(type)))
-#elif defined(__GNUC__) && (__GNUC__ * 100 + __GNUC_MINOR__ >= 408)
+#elif defined(__GNUC__) && (__GNUC__ * 100 + __GNUC_MINOR__ >= 409)
 #define __supress_ubsan__(type) __attribute__((no_sanitize_undefined))
 #else
 #define __supress_ubsan__(type)
",80,14
"Performance improvement to generated+supporting PHP (#5080)

By avoiding redundant alignment+alloc checks (startVector does prep) and virtual calls
(by making the class final) in inner loops.","
 
 namespace Google\FlatBuffers;
 
-class FlatbufferBuilder
+final class FlatbufferBuilder
 {
 /**
 * Internal ByteBuffer for the FlatBuffer data.
 class FlatbufferBuilder
 {
 $this->bb->putDouble($this->space -= 8, $x);
 }
+
+ /**
+ * @param $off
+ */
+ public function putOffset($off)
+ {
+ $new_off = $this->offset() - $off + Constants::SIZEOF_INT;
+ $this->putInt($new_off);
+ }
 /// @endcond
 
 /**
 class FlatbufferBuilder
 if ($off > $this->offset()) {
 throw new \Exception("""");
 }
-
- $off = $this->offset() - $off + Constants::SIZEOF_INT;
- $this->putInt($off);
+ $this->putOffset($off);
 }
 
 /// @cond FLATBUFFERS_INTERNAL
",522,179
"Add `NaN` and `Inf` defaults to the C++ generated code. (#5102)

* Add `NaN` and `Inf` defaults to the C++ generated code.

* Refactoring: add FloatConstantGenerator

* Refactoring-2:

- remove isnan checking for all float/double values
- add most probable implementation of virtual methods of FloatConstantGenerator

* Add conditional (FLATBUFFERS_NAN_DEFAULTS) isnan checking"," extern void GenComment(const std::vector<std::string> &dc,
 std::string *code_ptr, const CommentConfig *config,
 const char *prefix = """");
 
+class FloatConstantGenerator {
+ public:
+ virtual ~FloatConstantGenerator(){};
+ std::string GenFloatConstant(const FieldDef &field) const;
+
+ private:
+ virtual std::string Inf(double v) const = 0;
+ virtual std::string NaN(double v) const = 0;
+ virtual std::string Value(double v, const std::string &src) const {
+ (void)v;
+ return src;
+ }
+
+ virtual std::string Inf(float v) const {
+ return this->Inf(static_cast<double>(v));
+ }
+ virtual std::string NaN(float v) const {
+ return this->NaN(static_cast<double>(v));
+ }
+ virtual std::string Value(float v, const std::string &src) const {
+ return this->Value(static_cast<double>(v), src);
+ }
+
+ template<typename T>
+ std::string GenFloatConstantImpl(const FieldDef &field) const;
+};
+
 } // namespace flatbuffers
 
 #endif // FLATBUFFERS_CODE_GENERATORS_H_
",85,12
Move all platform dependent headers and code to util.cpp module (#5106),"
 (defined(__cpp_constexpr) && __cpp_constexpr >= 200704)
 #define FLATBUFFERS_CONSTEXPR constexpr
 #else
- #define FLATBUFFERS_CONSTEXPR
+ #define FLATBUFFERS_CONSTEXPR const
 #endif
 
 #if (defined(__cplusplus) && __cplusplus >= 201402L) || \
",80,14
"JS- support clear() method on builder (#5109)

* support clearing flatBuffer builder in js

* remove unused member
 reset force_defaults
dont actually need to clear data in bytebuffer"," flatbuffers.Builder = function(opt_initial_size) {
 this.force_defaults = false;
 };
 
+flatbuffers.Builder.prototype.clear = function() {
+ this.bb.clear();
+ this.space = this.bb.capacity();
+ this.minalign = 1;
+ this.vtable = null;
+ this.vtable_in_use = 0;
+ this.isNested = false;
+ this.object_start = 0;
+ this.vtables = [];
+ this.vector_num_elems = 0;
+ this.force_defaults = false;
+};
+
 /**
 * In order to save space, fields that are set to their default value
 * don't get serialized into the buffer. Forcing defaults provides a
 flatbuffers.ByteBuffer = function(bytes) {
 * @private
 */
 this.position_ = 0;
+
 };
 
 /**
 flatbuffers.ByteBuffer.allocate = function(byte_size) {
 return new flatbuffers.ByteBuffer(new Uint8Array(byte_size));
 };
 
+flatbuffers.ByteBuffer.prototype.clear = function() { 
+ this.position_ = 0;
+};
+
 /**
 * Get the underlying `Uint8Array`.
 *
",546,147
"Add default NaN/Inf to C#, Java, Python (#5107)

* Add default NaN/Inf to C#, Java, Python

* Python NaN/Inf test added

* Remove MSVC2010/13 dependent code"," import NamespaceA.NamespaceB.*;
 import com.google.flatbuffers.ByteBufferUtil;
 import static com.google.flatbuffers.Constants.*;
 import com.google.flatbuffers.FlatBufferBuilder;
+import MyGame.MonsterExtra;
 
 class JavaTest {
 public static void main(String[] args) {
",304,26
Reference::ToString should be const (#5118)," class Reference {
 }
 
 // Unlike AsString(), this will convert any type to a std::string.
- std::string ToString() {
+ std::string ToString() const {
 std::string s;
 ToString(false, false, s);
 return s;
",1163,385
"Fix high certainty warnings from PVS-studio (#5115)

* Fix high certainty warnings from PVS-studio

- Introduced FLATBUFFERS_ATTRIBUTE macro to use [[attribute]] if modern C++ compiler used

* Update the note about __cplusplus usage in the MSVC"," inline size_t InlineAlignment(const Type &type) {
 
 struct EnumVal {
 EnumVal(const std::string &_name, int64_t _val) : name(_name), value(_val) {}
- EnumVal(){};
+ EnumVal() : value(0){};
 
 Offset<reflection::EnumVal> Serialize(FlatBufferBuilder *builder, const Parser &parser) const;
 
 class Parser : public ParserState {
 bool Deserialize(const reflection::Schema* schema);
 
 Type* DeserializeType(const reflection::Type* type);
- 
+
 // Checks that the schema represented by this parser is a safe evolution
 // of the schema provided. Returns non-empty error on any problems.
 std::string ConformTo(const Parser &base);
",621,53
"[C++]Support reverse iterator in Vector (#5128)

* Add `const` keyword to the `operator-(const uoffset_t &)` function in
`VectorIterator`

* Support reverse iterator in Vector

Introduced a new VectorReverseIterator type. We cannot directly use
`std::reverse_iterator<VectorIterator>` because the signature of
`operator*` and `operator->` in the VectorIterator class are not
standard signatures.

Also added `rbegin()`, `rend()`, `cbegin()`, `cend()`, `crbegin()`
and `crend()` in the Vector class."," void AccessFlatBufferTest(const uint8_t *flatbuf, size_t length,
 TEST_EQ(*it, inv_data[indx]);
 }
 
+ for (auto it = inventory->cbegin(); it != inventory->cend(); ++it) {
+ auto indx = it - inventory->cbegin();
+ TEST_EQ(*it, inv_vec.at(indx)); // Use bounds-check.
+ TEST_EQ(*it, inv_data[indx]);
+ }
+
+ for (auto it = inventory->rbegin(); it != inventory->rend(); ++it) {
+ auto indx = inventory->rend() - it;
+ TEST_EQ(*it, inv_vec.at(indx)); // Use bounds-check.
+ TEST_EQ(*it, inv_data[indx]);
+ }
+
+ for (auto it = inventory->crbegin(); it != inventory->crend(); ++it) {
+ auto indx = inventory->crend() - it;
+ TEST_EQ(*it, inv_vec.at(indx)); // Use bounds-check.
+ TEST_EQ(*it, inv_data[indx]);
+ }
+
 TEST_EQ(monster->color(), Color_Blue);
 
 // Example of accessing a union:
",1906,160
"[Rust] Added global namespace imports (#5121)

* [Rust] Added global namespace imports

* Documented the need for global imports

* Added white_space params to GenNamespaceImports

* Removed a \n from GenNamespaceImports","
 // automatically generated by the FlatBuffers compiler, do not modify
 
 
+#![allow(dead_code)]
+#![allow(unused_imports)]
+
+use std::mem;
+use std::cmp::Ordering;
+
+extern crate flatbuffers;
+use self::flatbuffers::EndianScalar;
+
 pub mod my_game {
 #![allow(dead_code)]
 #![allow(unused_imports)]
",1836,36
Repair MSVC-CRT leakage detector and enable this detection with Appveyor-CI (#5105),"
 #define FLATBUFFERS_BASE_H_
 
 // clang-format off
+
+// If activate should be declared and included first.
 #if defined(FLATBUFFERS_MEMORY_LEAK_TRACKING) && \
 defined(_MSC_VER) && defined(_DEBUG)
+ // The _CRTDBG_MAP_ALLOC inside <crtdbg.h> will replace
+ // calloc/free (etc) to its debug version using #define directives.
 #define _CRTDBG_MAP_ALLOC
+ #include <stdlib.h>
+ #include <crtdbg.h>
+ // Replace operator new by trace-enabled version.
+ #define DEBUG_NEW new(_NORMAL_BLOCK, __FILE__, __LINE__)
+ #define new DEBUG_NEW
 #endif
 
 #if !defined(FLATBUFFERS_ASSERT)

 #include <cstdlib>
 #include <cstring>
 
-#if defined(FLATBUFFERS_MEMORY_LEAK_TRACKING) && \
- defined(_MSC_VER) && defined(_DEBUG)
- #include <crtdbg.h>
- #define DEBUG_NEW new(_NORMAL_BLOCK, __FILE__, __LINE__)
- #define new DEBUG_NEW
-#endif
-
 #if defined(ARDUINO) && !defined(ARDUINOSTL_M_H)
 #include <utility.h>
 #else
",81,14
"Replace deprecated Vector::Length() with Vector::size() (#5131)

- enable FLATBUFFERS_ATTRIBUTE if C++17 or higher"," template<typename T> FLATBUFFERS_CONSTEXPR inline bool IsConstTrue(T t) {
 return !!t;
 }
 
-// Enable of std:c++17 or higher.
+// Enable C++ attribute [[]] if std:c++17 or higher.
 #if (defined(__cplusplus) && (__cplusplus >= 201703L)) || \
 (defined(_MSVC_LANG) && (_MSVC_LANG >= 201703L))
 // All attributes unknown to an implementation are ignored without causing an error.
- #define FLATBUFFERS_ATTRIBUTE(attr) // [[attr]] - will be enabled in a future release
+ #define FLATBUFFERS_ATTRIBUTE(attr) [[attr]]
 #else
 #define FLATBUFFERS_ATTRIBUTE(attr)
 #endif
",81,14
"Repair `fallthrough` was broken by d4493165 (#5115) (#5139)

- GCC: fixed broken `fallthrough` (checked with 7.3 and 8.2)
- Clang: added `fallthrough` support
- Clang: added `-Wimplicit-fallthrough` checking","
 #define XSTR(s) STR(s)
 #endif
 
-#ifndef FALLTHROUGH_INTENDED
-#define FALLTHROUGH_INTENDED
-#endif
 
 typedef grpc_generator::Printer Printer;
 typedef std::map<grpc::string, grpc::string> VARS;
 static void PrintStub(Printer* p, VARS& vars, const ServiceDescriptor* service,
 break;
 case BLOCKING_CLIENT_INTERFACE:
 interface = true;
- FALLTHROUGH_INTENDED; // fallthrough
+ FLATBUFFERS_FALLTHROUGH(); // fall thru
 case BLOCKING_CLIENT_IMPL:
 call_type = BLOCKING_CALL;
 stub_name += ""BlockingStub"";
 static void PrintStub(Printer* p, VARS& vars, const ServiceDescriptor* service,
 break;
 case FUTURE_CLIENT_INTERFACE:
 interface = true;
- FALLTHROUGH_INTENDED; // fallthrough
+ FLATBUFFERS_FALLTHROUGH(); // fall thru
 case FUTURE_CLIENT_IMPL:
 call_type = FUTURE_CALL;
 stub_name += ""FutureStub"";
",904,132
"Make changes on the make_unsigned type trait (#5136)

Fix a typo in the static assert message in `make_unsigned`

Support more specifications for `make_unsigned`"," inline void vector_emplace_back(std::vector<T> *vector, V &&data) {
 template <typename T> using is_unsigned = std::tr1::is_unsigned<T>;
 // Android NDK doesn't have std::make_unsigned or std::tr1::make_unsigned.
 template<typename T> struct make_unsigned {
- static_assert(is_unsigned<T>::value, ""Specialization not impelented!"");
+ static_assert(is_unsigned<T>::value, ""Specialization not implemented!"");
 using type = T;
 };
 template<> struct make_unsigned<char> { using type = unsigned char; };
- template<> struct make_unsigned<int> { using type = unsigned int; };
+ template<> struct make_unsigned<short> { using type = unsigned short; };
+ template<> struct make_unsigned<int> { using type = unsigned int; };
+ template<> struct make_unsigned<long> { using type = unsigned long; };
+ template<>
+ struct make_unsigned<long long> { using type = unsigned long long; };
 #endif // !FLATBUFFERS_CPP98_STL
 #else
 // MSVC 2010 doesn't support C++11 aliases.
",168,43
"Only use __movsb on architectures that support it (#5147)

With the introduction of Windows 10 on ARM (ARM64), code that assumes
that Windows targets are always x86 or x86_64 targets needs to be
updated.

The hot function ReadUInt64 has been optimized in MSVC builds using the
compiler intrinsic __movsb. Since this does not exist on ARM64 Windows,
this change uses the pure C++ path that other platforms use instead."," inline uint64_t ReadUInt64(const uint8_t *data, uint8_t byte_width) {
 // constant, which here it isn't. Test if memcpy is still faster than
 // the conditionals in ReadSizedScalar. Can also use inline asm.
 // clang-format off
- #ifdef _MSC_VER
+ #if defined(_MSC_VER) && (defined(_M_X64) || defined _M_IX86)
 uint64_t u = 0;
 __movsb(reinterpret_cast<uint8_t *>(&u),
 reinterpret_cast<const uint8_t *>(data), byte_width);
",1163,385
"Changing array to be an associative array so that the Name function can work with non-sequential enums as well as those beginning at something other than zero. (#5151)

Also including the resulting changes in php files."," class PhpGenerator : public BaseGenerator {
 for (auto it = enum_def.vals.vec.begin(); it != enum_def.vals.vec.end();
 ++it) {
 auto &ev = **it;
- code += Indent + Indent + ""\"""" + ev.name + ""\"",\n"";
+ code += Indent + Indent + enum_def.name + ""::"" + ev.name + ""=>"" + ""\"""" + ev.name + ""\"",\n"";
 }
 
 code += Indent + "");\n\n"";
",764,127
"Removing 'using namespace' usage in test_builder (#5154)

* Removing 'using namespace' usage in test_builder

* Fix GRPC tests","
 #include ""test_assert.h""
 #include ""test_builder.h""
 
+using MyGame::Example::Vec3;
+using MyGame::Example::CreateStat;
+using MyGame::Example::Any_NONE;
+
 bool verify(flatbuffers::grpc::Message<Monster> &msg, const std::string &expected_name, Color color) {
 const Monster *monster = msg.GetRoot();
 return (monster->name()->str() == expected_name) && (monster->color() == color);
",261,40
"Reduced `force_align` in tests to 8, to work with --object-api.

More detail:
https://github.com/google/flatbuffers/projects/6#card-17401359

See also the .md changes in this commit.

Change-Id: Idfa68b2fd3bdb19979833737d3a3cf83ec1d6775"," public struct Vec3 : IFlatbufferObject
 public Test Test3 { get { return (new Test()).__assign(__p.bb_pos + 26, __p.bb); } }
 
 public static Offset<Vec3> CreateVec3(FlatBufferBuilder builder, float X, float Y, float Z, double Test1, Color Test2, short test3_A, sbyte test3_B) {
- builder.Prep(16, 32);
+ builder.Prep(8, 32);
 builder.Pad(2);
 builder.Prep(2, 4);
 builder.Pad(1);
",39,8
"Turn on -Werror=unused-private-field for Clang.

Change-Id: Ibabc1456baf190eba191ebe0b81e3d73a4acc98f"," class Verifier FLATBUFFERS_FINAL_CLASS {
 return (size > size_) ? 0 : size;
 #else
 // Must turn on FLATBUFFERS_TRACK_VERIFIER_BUFFER_SIZE for this to work.
+ (void)upper_bound_;
 FLATBUFFERS_ASSERT(false);
 return 0;
 #endif
",1481,403
"Implement (shared) attribute for C++ (#5157)

* Implement native_shared attribute for C++.

Fixes #5141. See also #5145.

* Refine comment in idl.h

* Also refine docs

* Revert ""Also refine docs""

This reverts commit 09dab7b45c56c2d17eac493203adc8caaa0df2cc.

* Also refine docs again.

* grumble"," CheckedError Parser::ParseField(StructDef &struct_def) {
 return Error(""'key' field must be string or scalar type"");
 }
 }
+ field->shared = field->attributes.Lookup(""shared"") != nullptr;
+ if (field->shared && field->value.type.base_type != BASE_TYPE_STRING)
+ return Error(""shared can only be defined on strings"");
 
 auto field_native_custom_alloc =
 field->attributes.Lookup(""native_custom_alloc"");
 CheckedError Parser::ParseField(StructDef &struct_def) {
 
 field->native_inline = field->attributes.Lookup(""native_inline"") != nullptr;
 if (field->native_inline && !IsStruct(field->value.type))
- return Error(""native_inline can only be defined on structs'"");
+ return Error(""native_inline can only be defined on structs"");
 
 auto nested = field->attributes.Lookup(""nested_flatbuffer"");
 if (nested) {
",2663,817
"Make ByteBufferFactory an abstract class in order to make FlatBuffers compatible with Java7. (#5155)

Introduce a HeapByteBufferFactory singleton instance in order to reduce allocations.
Clarify the usage of LITTLE_ENDIAN ByteBuffers in ByteBufferFactory."," class JavaTest {
 }
 
 static void TestByteBufferFactory() {
- final class MappedByteBufferFactory implements FlatBufferBuilder.ByteBufferFactory {
+ final class MappedByteBufferFactory extends FlatBufferBuilder.ByteBufferFactory {
 @Override
 public ByteBuffer newByteBuffer(int capacity) {
 ByteBuffer bb;
",304,26
"Add flag to make short names in JS/TS. (#5152)

* Add flag to make short names in JS/TS.

* Synced all missing docs in Compiler.md <-> flatc.cpp.

* Review changes."," struct IDLOptions {
 std::string go_import;
 std::string go_namespace;
 bool reexport_ts_modules;
+ bool js_ts_short_names;
 bool protobuf_ascii_alike;
 bool size_prefixed;
 std::string root_type;
 struct IDLOptions {
 binary_schema_builtins(false),
 skip_flatbuffers_import(false),
 reexport_ts_modules(true),
+ js_ts_short_names(false),
 protobuf_ascii_alike(false),
 size_prefixed(false),
 force_defaults(false),
",626,53
Generting imports for external enums in TS (#5175)," class JsTsGenerator : public BaseGenerator {
 GenPrefixedTypeName(GenTypeName(field.value.type, false, true),
 field.value.type.enum_def->file) +
 "" {\n"";
+
+ if (!parser_.opts.generate_all) {
+ imported_files.insert(field.value.type.enum_def->file);
+ }
 } else {
 code += ""):"" + GenTypeName(field.value.type, false, true) + "" {\n"";
 }
 class JsTsGenerator : public BaseGenerator {
 // Generate a convenient CreateX function
 code += ""static create"" + Verbose(struct_def);
 code += ""(builder:flatbuffers.Builder"";
- 
+
 for (auto it = struct_def.fields.vec.begin();
 it != struct_def.fields.vec.end(); ++it) {
 const auto &field = **it;
 class JsTsGenerator : public BaseGenerator {
 return argname;
 }
 
- std::string Verbose(const StructDef &struct_def, 
+ std::string Verbose(const StructDef &struct_def,
 const char* prefix = """")
 {
 return parser_.opts.js_ts_short_names ? """" : prefix + struct_def.name;
",1129,256
"[C#] Fix FlatBuffers.Tests when ENABLE_SPAN_T is defined (#5182)

There is a test code error that causes the CanReadCppGeneratedWireFile test to fail when ENABLE_SPAN_T is defined. When TestarrayofboolsLength is not 0, then the GetTestarrayofboolsBytes() should have a length."," namespace FlatBuffers.Test
 }
 else
 {
- Assert.IsTrue(monster.GetTestarrayofboolsBytes().Length == 0);
+ Assert.IsTrue(monster.GetTestarrayofboolsBytes().Length != 0);
 }
 #else
 var nameBytes = monster.GetNameBytes().Value;
",241,18
Changed the JavaScript generation to emit createX helper functions just like the TypeScript code generation. I also added code so that the create methods have documentation in both JavaScript and TypeScript. (#5168)," NamespaceA.NamespaceB.TableInNestedNS.endTableInNestedNS = function(builder) {
 return offset;
 };
 
+/**
+ * @param {flatbuffers.Builder} builder
+ * @param {number} foo
+ * @returns {flatbuffers.Offset}
+ */
+NamespaceA.NamespaceB.TableInNestedNS.createTableInNestedNS = function(builder, foo) {
+ NamespaceA.NamespaceB.TableInNestedNS.startTableInNestedNS(builder);
+ NamespaceA.NamespaceB.TableInNestedNS.addFoo(builder, foo);
+ return NamespaceA.NamespaceB.TableInNestedNS.endTableInNestedNS(builder);
+}
+
 /**
 * @constructor
 */
",84,21
"Fixed use of WIN32 needs to be _WIN32.

Change-Id: Ie1f88ac5613cc09ed1074608dd6517ae20c7973d"," void TestError_(const char *src, const char *error_substr, const char *file,
 TestError_(src, error_substr, false, file, line, func);
 }
 
-#ifdef WIN32
+#ifdef _WIN32
 # define TestError(src, ...) \
 TestError_(src, __VA_ARGS__, __FILE__, __LINE__, __FUNCTION__)
 #else
",1903,160
"Utility for checking the encoding and line ending of source files (#5188)

* Add utility for checking the encoding of source files

- accept source files with ASCII or UTF-8 without BOM
- accept only CRLF line ending

* Fix non-ascii symbol in idl_parcer.cpp

* Remove BOM from test.cpp"," CheckedError Parser::Next() {
 
 auto dot_lvl = (c == '.') ? 0 : 1; // dot_lvl==0 <=> exactly one '.' seen
 if (!dot_lvl && !is_digit(*cursor_)) return NoError(); // enum?
- // Parser accepts hexadecimal-oating-literal (see C++ 5.13.4).
+ // Parser accepts hexadecimal-floating-literal (see C++ 5.13.4).
 if (is_digit(c) || has_sign || !dot_lvl) {
 const auto start = cursor_ - 1;
 auto start_digits = !is_digit(c) ? cursor_ : cursor_ - 1;
",2663,817
"Fixed vector of unions crash in java (#5190)

* Fixed vector of unions crash in java

* Regenerated test code

* Fixed windows tests"," const LanguageParameters &GetLangParams(IDLOptions::Language lang) {
 """",
 ""import java.nio.*;\nimport java.lang.*;\nimport ""
 ""java.util.*;\nimport com.google.flatbuffers.*;\n"",
- ""\n@SuppressWarnings(\""unused\"")"",
+ ""\n@SuppressWarnings(\""unused\"")\n"",
 ""\n@javax.annotation.Generated(value=\""flatc\"")\n"",
 {
 ""/**"",
 class GeneralGenerator : public BaseGenerator {
 ? index
 : lang_.accessor_prefix + ""__indirect("" + index + "")"";
 code += "", "" + lang_.accessor_prefix + ""bb"";
+ } else if (vectortype.base_type == BASE_TYPE_UNION) {
+ code += index + "" - bb_pos"";
 } else {
 code += index;
 }
",1357,313
"Improve endian detection. (#5204)

Add support for using __BYTE_ORDER__, to support platforms where g++
doesn't explicitly define __BIG_ENDIAN__, like Solaris Sparc.","
 #endif // __s390x__
 #if !defined(FLATBUFFERS_LITTLEENDIAN)
 #if defined(__GNUC__) || defined(__clang__)
- #ifdef __BIG_ENDIAN__
+ #if (defined(__BIG_ENDIAN__) || \
+ (defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__))
 #define FLATBUFFERS_LITTLEENDIAN 0
 #else
 #define FLATBUFFERS_LITTLEENDIAN 1
",81,14
"Fix big-endian build. (#5205)

For some reason, Offset<T> is being considered a scalar, which
causes EndianSwap to be passed an Offset<T>. This doesn't work,
as it does not support types with non-trivial constructors. This
change adds an overload to WriteScalar(), which works around this."," void WriteScalar(void *p, T t) {
 *reinterpret_cast<T *>(p) = EndianScalar(t);
 }
 
+template<typename T> struct Offset;
+template<typename T> __supress_ubsan__(""alignment"") void WriteScalar(void *p, Offset<T> t) {
+ *reinterpret_cast<uoffset_t *>(p) = EndianScalar(t.o);
+}
+
 // Computes how many bytes you'd have to pad to be able to write an
 // ""scalar_size"" scalar if the buffer had grown to ""buf_size"" (downwards in
 // memory).
",85,15
"Added -Wextra-semi to Clang build.

Also fixed warnings this generated.

Change-Id: If3607907b2dd609f854b7b81225d9cf66af75a60"," extern void GenComment(const std::vector<std::string> &dc,
 
 class FloatConstantGenerator {
 public:
- virtual ~FloatConstantGenerator(){};
+ virtual ~FloatConstantGenerator() {}
 std::string GenFloatConstant(const FieldDef &field) const;
 
 private:
",115,8
"Added -Wc++98-compat-extra-semi

And fixed 2 more extra semi-colons.

Change-Id: I1ee08e5b2f67cd0c886847c05cd4d63cfcafec3e"," inline int LookupEnum(const char **names, const char *name) {
 // clang-format off
 #if defined(_MSC_VER)
 #define FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(alignment) \
- __pragma(pack(1)); \
+ __pragma(pack(1)) \
 struct __declspec(align(alignment))
 #define FLATBUFFERS_STRUCT_END(name, size) \
- __pragma(pack()); \
+ __pragma(pack()) \
 static_assert(sizeof(name) == size, ""compiler breaks packing rules"")
 #elif defined(__GNUC__) || defined(__clang__)
 #define FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(alignment) \
",1481,403
"Fix incorrect code generation on Solaris Sparc. (#5208)

On Solaris Sparc, calling NumToString() with a char called the primary
version, not the signed char or unsigned char specializations, which
caused integer to string conversions to be missed."," template<> inline std::string NumToString<signed char>(signed char t) {
 template<> inline std::string NumToString<unsigned char>(unsigned char t) {
 return NumToString(static_cast<int>(t));
 }
+template<> inline std::string NumToString<char>(char t) {
+ return NumToString(static_cast<int>(t));
+}
 #if defined(FLATBUFFERS_CPP98_STL)
 template<> inline std::string NumToString<long long>(long long t) {
 char buf[21]; // (log((1 << 63) - 1) / log(10)) + 2
",360,113
"Lua library: fix vtable reuse. (#5214)

Fixed a bug that prevented vtable reuse during buffer construction in the lua library.

Also fixed a bug in vtable equality check that was revealed after the first fix."," local function vtableEqual(a, objectStart, b)
 end
 
 for i, elem in ipairs(a) do
- local x = VOffsetT:Unpack(b, i * VOffsetT.bytewidth)
+ local x = string.unpack(VOffsetT.packFmt, b, 1 + (i - 1) * VOffsetT.bytewidth)
 if x ~= 0 or elem ~= 0 then
 local y = objectStart - elem
 if x ~= y then
 function mt:WriteVtable()
 i = i - 1
 end
 
+ i = #self.vtables
 while i >= 1 do
 
 local vt2Offset = self.vtables[i]
 local vt2Start = #self.bytes - vt2Offset
- local vt2len = VOffsetT:Unpack(self.bytes, vt2Start)
+ local vt2lenstr = self.bytes:Slice(vt2Start, vt2Start+1)
+ local vt2Len = string.unpack(VOffsetT.packFmt, vt2lenstr, 1)
 
 local metadata = VtableMetadataFields * VOffsetT.bytewidth
 local vt2End = vt2Start + vt2Len
 function mt:Place(x, flags)
 self.bytes:Set(d, h)
 end
 
-return m
\ No newline at end of file
+return m
",300,78
"Java: Removed unused duplicate of bytebuffer from ""Table#__string"" method. (#5211)"," public class Table {
 */
 protected String __string(int offset) {
 offset += bb.getInt(offset);
- ByteBuffer src = bb.duplicate().order(ByteOrder.LITTLE_ENDIAN);
- int length = src.getInt(offset);
+ int length = bb.getInt(offset);
 return utf8.decodeUtf8(bb, offset + SIZEOF_INT, length);
 }
 
",119,30
"Java: Calculation of vtable and vtable size moved to the __init method. (#5210)

vtable and vtable size depends only on `Table#bb_pos` but calculated in
`Table#_offset` method on each field lookup.
Doing this with every call of `Table#__offset` is redundant.

These values can be read once with change of `Table#bb_pos` and reused
for any field lookup."," class GeneralGenerator : public BaseGenerator {
 // accessor object. This is to allow object reuse.
 code += "" public void __init(int _i, ByteBuffer _bb) "";
 code += ""{ "" + lang_.accessor_prefix + ""bb_pos = _i; "";
- code += lang_.accessor_prefix + ""bb = _bb; }\n"";
+ code += lang_.accessor_prefix + ""bb = _bb; "";
+ if (!struct_def.fixed && lang_.language == IDLOptions::kJava) {
+ code += lang_.accessor_prefix + ""vtable_start = "" + lang_.accessor_prefix + ""bb_pos - "";
+ code += lang_.accessor_prefix + ""bb."" + FunctionStart('G') + ""etInt("";
+ code += lang_.accessor_prefix + ""bb_pos); "" + lang_.accessor_prefix + ""vtable_size = "";
+ code += lang_.accessor_prefix + ""bb."" + FunctionStart('G') + ""etShort("";
+ code += lang_.accessor_prefix + ""vtable_start); "";
+ }
+ code += ""}\n"";
 code +=
 "" public "" + struct_def.name + "" __assign(int _i, ByteBuffer _bb) "";
 code += ""{ __init(_i, _bb); return this; }\n\n"";
",1365,315
"Rust: Fix lifetime in union _as_ accessors (#5140)

* Fix lifetime in union _as_ accessors

In the accessors for union field, the return value is implicitly taking the lifetime of &self.
This is irrelevant and prevents usages of the returned value, because it is needlessly bound to the parent field lifetime.

This patch makes the return value inherit the lifetime of the data, like other methods do."," class RustGenerator : public BaseGenerator {
 
 code_ += "" #[inline]"";
 code_ += "" #[allow(non_snake_case)]"";
- code_ += "" pub fn {{FIELD_NAME}}_as_{{U_ELEMENT_NAME}}(&'a self) -> ""
- ""Option<{{U_ELEMENT_TABLE_TYPE}}> {"";
+ code_ += "" pub fn {{FIELD_NAME}}_as_{{U_ELEMENT_NAME}}(&self) -> ""
+ ""Option<{{U_ELEMENT_TABLE_TYPE}}<'a>> {"";
 code_ += "" if self.{{FIELD_NAME}}_type() == {{U_ELEMENT_ENUM_TYPE}} {"";
 code_ += "" self.{{FIELD_NAME}}().map(|u| ""
 ""{{U_ELEMENT_TABLE_TYPE}}::init_from_table(u))"";
",1439,319
[Fix #5112] flatc generates constructors with memset for non-trivial types (#5222)," FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec3 FLATBUFFERS_FINAL_CLASS {
 
 public:
 Vec3() {
- memset(this, 0, sizeof(Vec3));
+ memset(static_cast<void *>(this), 0, sizeof(Vec3));
 }
 Vec3(float _x, float _y, float _z)
 : x_(flatbuffers::EndianScalar(_x)),
",738,171
"[Go] Add mutation functions for vector elements (#5221)

Fixes #5206"," func (rcv *TypeAliases) V8Length() int {
 return 0
 }
 
+func (rcv *TypeAliases) MutateV8(j int, n int8) bool {
+o := flatbuffers.UOffsetT(rcv._tab.Offset(24))
+if o != 0 {
+a := rcv._tab.Vector(o)
+return rcv._tab.MutateInt8(a+flatbuffers.UOffsetT(j*1), n)
+}
+return false
+}
+
 func (rcv *TypeAliases) Vf64(j int) float64 {
 o := flatbuffers.UOffsetT(rcv._tab.Offset(26))
 if o != 0 {
 func (rcv *TypeAliases) Vf64Length() int {
 return 0
 }
 
+func (rcv *TypeAliases) MutateVf64(j int, n float64) bool {
+o := flatbuffers.UOffsetT(rcv._tab.Offset(26))
+if o != 0 {
+a := rcv._tab.Vector(o)
+return rcv._tab.MutateFloat64(a+flatbuffers.UOffsetT(j*8), n)
+}
+return false
+}
+
 func TypeAliasesStart(builder *flatbuffers.Builder) {
 builder.StartObject(12)
 }
",214,61
[Rust] Fixed codegen documentation for Tables (#5227)," class RustGenerator : public BaseGenerator {
 // Generate an accessor struct, builder struct, and create function for a
 // table.
 void GenTable(const StructDef &struct_def) {
- GenComment(struct_def.doc_comment);
-
 code_.SetValue(""STRUCT_NAME"", Name(struct_def));
 code_.SetValue(""OFFSET_TYPELABEL"", Name(struct_def) + ""Offset"");
 code_.SetValue(""STRUCT_NAME_SNAKECASE"", MakeSnakeCase(Name(struct_def)));
 class RustGenerator : public BaseGenerator {
 code_ += ""pub enum {{OFFSET_TYPELABEL}} {}"";
 code_ += ""#[derive(Copy, Clone, Debug, PartialEq)]"";
 code_ += """";
+
+ GenComment(struct_def.doc_comment);
+
 code_ += ""pub struct {{STRUCT_NAME}}<'a> {"";
 code_ += "" pub _tab: flatbuffers::Table<'a>,"";
 code_ += ""}"";
",1439,319
"[Rust] Don't use inner attributes for `allow` (#5212)

* Don't use inner attributes for `allow`
Messes with being able to easily include elsewhere

* Regenerate tests

* No-op to retrigger CI

* Add the rest of the `allow` attributes"," class RustGenerator : public BaseGenerator {
 
 void GenNamespaceImports(const int white_spaces) {
 std::string indent = std::string(white_spaces, ' ');
- code_ += indent + ""#![allow(dead_code)]"";
- code_ += indent + ""#![allow(unused_imports)]"";
 code_ += """";
 code_ += indent + ""use std::mem;"";
 code_ += indent + ""use std::cmp::Ordering;"";
 class RustGenerator : public BaseGenerator {
 // open namespace parts to reach the ns namespace
 // in the previous example, E, then F, then G are opened
 for (auto j = common_prefix_size; j != new_size; ++j) {
+ code_ += ""#[allow(unused_imports, dead_code)]"";
 code_ += ""pub mod "" + MakeSnakeCase(ns->components[j]) + "" {"";
 // Generate local namespace imports.
 GenNamespaceImports(2);
",1438,319
Narrows template ascii routines to prevent a possible signed overflow in generic code. (#5232)," CheckedError Parser::Next() {
 ""illegal Unicode sequence (unpaired high surrogate)"");
 }
 // reset if non-printable
- attr_is_trivial_ascii_string_ &= check_in_range(*cursor_, ' ', '~');
+ attr_is_trivial_ascii_string_ &= check_ascii_range(*cursor_, ' ', '~');
 
 attribute_ += *cursor_++;
 }
 CheckedError Parser::Next() {
 }
 std::string ch;
 ch = c;
- if (false == check_in_range(c, ' ', '~')) ch = ""code: "" + NumToString(c);
+ if (false == check_ascii_range(c, ' ', '~')) ch = ""code: "" + NumToString(c);
 return Error(""illegal character: "" + ch);
 }
 }
",2691,824
"Made JS enum declarations compatible with google closure

Original change by: https://github.com/alexames

Change-Id: Ib65bd02156d1c3637ed278a8334a2307caacaa44"," var NamespaceA = NamespaceA || {};
 NamespaceA.NamespaceB = NamespaceA.NamespaceB || {};
 
 /**
- * @enum
+ * @enum {number}
 */
 NamespaceA.NamespaceB.EnumInNestedNS = {
- A: 0, 0: 'A',
- B: 1, 1: 'B',
- C: 2, 2: 'C'
+ A: 0,
+ B: 1,
+ C: 2
+};
+
+/**
+ * @enum {string}
+ */
+NamespaceA.NamespaceB.EnumInNestedNSName = {
+ 0: 'A',
+ 1: 'B',
+ 2: 'C'
 };
 
 /**
",89,21
"Fixed shadowing warning in older gcc for vector_delimited

Change-Id: Ia4d56a5eb086f86eb5d1ad6ddae64e4a51bf3aa3"," struct ToStringVisitor : public IterationVisitor {
 size_t indent_level;
 bool vector_delimited;
 ToStringVisitor(std::string delimiter, bool quotes, std::string indent,
- bool vector_delimited = true)
+ bool vdelimited = true)
 : d(delimiter),
 q(quotes),
 in(indent),
 indent_level(0),
- vector_delimited(vector_delimited) {}
+ vector_delimited(vdelimited) {}
 ToStringVisitor(std::string delimiter)
 : d(delimiter),
 q(false),
",345,121
"Fixed vector_delimited excluding delimiter

Change-Id: I3e758d44b9845d6df91332bb609b4b7ad88659ac"," struct ToStringVisitor : public IterationVisitor {
 void Unknown(const uint8_t *) { s += ""(?)""; }
 void StartVector() {
 s += ""["";
+ s += d;
 if (vector_delimited) {
- s += d;
 indent_level++;
 append_indent();
 }
 }
 void EndVector() {
+ s += d;
 if (vector_delimited) {
- s += d;
 indent_level--;
 append_indent();
 }
 struct ToStringVisitor : public IterationVisitor {
 const TypeTable * /*type_table*/, const uint8_t * /*val*/) {
 if (i) {
 s += "","";
+ s += d;
 if (vector_delimited) {
- s += d;
 append_indent();
 }
 }
",345,121
"Unify line ending rules in '.editorconfig' and '.gitattributes' (#5231)

* Unify line ending rules in '.editorconfig' and '.gitattributes'

* Revert '.gitattributes'

- fix invalid comments in the check-source.py"," def check_encoding(encoding, scan_dir, regex_pattern):
 btext.decode(encoding=encoding, errors=""strict"")
 if encoding == ""utf-8"" and btext.startswith(b'\xEF\xBB\xBF'):
 raise ValueError(""unexpected BOM in file"")
- # check strict CRLF line-ending
- LF = btext.count(b'\r')
- CRLF = btext.count(b'\r\n')
- assert LF >= CRLF, ""CRLF logic error""
- if CRLF != LF:
- raise ValueError(""CRLF violation: found {} LF characters"".format(LF - CRLF))
+ # check LF line endings
+ LF = btext.count(b'\n')
+ CR = btext.count(b'\r')
+ if CR!=0:
+ raise ValueError(""invalid line endings: LF({})/CR({})"".format(LF, CR))
 except Exception as err:
 print(""ERROR with [{}]: {}"".format(fname, err))
 return -1
",30,9
"Further fixes to make minireflect compatible with old behavior.

Change-Id: I92c257ec4ab4a0cf4676bd98523b766ce25bf4f6"," struct ToStringVisitor : public IterationVisitor {
 void Unknown(const uint8_t *) { s += ""(?)""; }
 void StartVector() {
 s += ""["";
- s += d;
 if (vector_delimited) {
+ s += d;
 indent_level++;
 append_indent();
+ } else {
+ s += "" "";
 }
 }
 void EndVector() {
- s += d;
 if (vector_delimited) {
+ s += d;
 indent_level--;
 append_indent();
+ } else {
+ s += "" "";
 }
 s += ""]"";
 }
 struct ToStringVisitor : public IterationVisitor {
 const TypeTable * /*type_table*/, const uint8_t * /*val*/) {
 if (i) {
 s += "","";
- s += d;
 if (vector_delimited) {
+ s += d;
 append_indent();
+ } else {
+ s += "" "";
 }
 }
 }
",351,121
"[C++] Changes in the flathash program (#5255)

* Correct the usage in the flathash program

As it is possible to have -- before the occurrence of the first
input STRING.

* Exit with 1 in the flathash program when an error occurs"," enum OutputFormat { kDecimal, kHexadecimal, kHexadecimal0x };
 int main(int argc, char *argv[]) {
 const char *name = argv[0];
 if (argc <= 1) {
- printf(""%s HASH [OPTION]... STRING... [-- STRING...]\n"", name);
+ printf(""%s HASH [OPTION]... [--] STRING...\n"", name);
 printf(""Available hashing algorithms:\n"");
 printf("" 16 bit:\n"");
 size_t size = sizeof(flatbuffers::kHashFunctions16) /
 int main(int argc, char *argv[]) {
 "" -x Output hash in hexadecimal.\n""
 "" -0x Output hash in hexadecimal and prefix with 0x.\n""
 "" -c Append the string to the output in a c-style comment.\n"");
- return 0;
+ return 1;
 }
 
 const char *hash_algorithm = argv[1];
 int main(int argc, char *argv[]) {
 
 if (!hash_function16 && !hash_function32 && !hash_function64) {
 printf(""\""%s\"" is not a known hash algorithm.\n"", hash_algorithm);
- return 0;
+ return 1;
 }
 
 OutputFormat output_format = kHexadecimal;
",89,23
Add inequality operator (inspired from #263) (#5257)," class CppGenerator : public BaseGenerator {
 NativeName(Name(struct_def), &struct_def, parser_.opts);
 code_ += ""bool operator==(const "" + nativeName + "" &lhs, const "" +
 nativeName + "" &rhs);"";
+ code_ += ""bool operator!=(const "" + nativeName + "" &lhs, const "" +
+ nativeName + "" &rhs);"";
 }
 }
 code_ += """";
 class CppGenerator : public BaseGenerator {
 code_ += "" }"";
 code_ += "" }"";
 code_ += ""}"";
+
+ code_ += """";
+ code_ +=
+ ""inline bool operator!=(const {{NAME}}Union &lhs, const ""
+ ""{{NAME}}Union &rhs) {"";
+ code_ += "" return !(lhs == rhs);"";
+ code_ += ""}"";
+ code_ += """";
 }
 }
 
 class CppGenerator : public BaseGenerator {
 ""{{NATIVE_NAME}} &{{CMP_RHS}}) {"";
 code_ += ""{{CMP_OP}}"";
 code_ += ""}"";
+
+ code_ += """";
+ code_ +=
+ ""inline bool operator!=(const {{NATIVE_NAME}} &lhs, const ""
+ ""{{NATIVE_NAME}} &rhs) {"";
+ code_ += "" return !(lhs == rhs);"";
+ code_ += ""}"";
+ code_ += """";
 }
 
 void GenOperatorNewDelete(const StructDef &struct_def) {
",2395,500
Fix a warning on compiling with clang (#5258)," inline const char * const *EnumNamesBaseType() {
 
 inline const char *EnumNameBaseType(BaseType e) {
 if (e < None || e > Union) return """";
- const size_t index = static_cast<int>(e);
+ const size_t index = static_cast<size_t>(e);
 return EnumNamesBaseType()[index];
 }
 
",1115,306
Fix for build break in c# vector of unions (#5271)," class GeneralGenerator : public BaseGenerator {
 : lang_.accessor_prefix + ""__indirect("" + index + "")"";
 code += "", "" + lang_.accessor_prefix + ""bb"";
 } else if (vectortype.base_type == BASE_TYPE_UNION) {
- code += index + "" - bb_pos"";
+ code += index + "" - "" + lang_.accessor_prefix + ""bb_pos"";
 } else {
 code += index;
 }
",1365,315
"Add method GenerateTextFromTable issue #5249 (#5266)

* Create a function GenerateGenerateTextFromTable in order to create a json from any Table

Signed-off-by: Anthony Liot <anthony.liot@gmail.com>

* Update the test to failed if loadfile or parser return false

Signed-off-by: Anthony Liot <anthony.liot@gmail.com>

* Fix snake_case name typo + space before &/*

Signed-off-by: Anthony Liot <anthony.liot@gmail.com>

* use auto

Signed-off-by: Anthony Liot <anthony.liot@gmail.com>

* Use clang-format on the added code

Signed-off-by: Anthony Liot <anthony.liot@gmail.com>"," extern std::string MakeCamel(const std::string &in, bool first = true);
 // strict_json adds ""quotes"" around field names if true.
 // If the flatbuffer cannot be encoded in JSON (e.g., it contains non-UTF-8
 // byte arrays in String values), returns false.
+extern bool GenerateTextFromTable(const Parser &parser,
+ const void *table,
+ const std::string &tablename,
+ std::string *text);
 extern bool GenerateText(const Parser &parser,
 const void *flatbuffer,
 std::string *text);
",636,53
"Ensure we don't subtract with underflow getting enum names (#5246)

* Ensure we don't subtract with underflow getting enum names

* Yep - forgot to run this"," class RustGenerator : public BaseGenerator {
 code_ += ""pub fn enum_name_{{ENUM_NAME_SNAKE}}(e: {{ENUM_NAME}}) -> ""
 ""&'static str {"";
 
- code_ += "" let index: usize = e as usize\\"";
+ code_ += "" let index = e as {{BASE_TYPE}}\\"";
 if (enum_def.vals.vec.front()->value) {
 auto vals = GetEnumValUse(enum_def, *enum_def.vals.vec.front());
- code_ += "" - "" + vals + "" as usize\\"";
+ code_ += "" - "" + vals + "" as {{BASE_TYPE}}\\"";
 }
 code_ += "";"";
 
- code_ += "" ENUM_NAMES_{{ENUM_NAME_CAPS}}[index]"";
+ code_ += "" ENUM_NAMES_{{ENUM_NAME_CAPS}}[index as usize]"";
 code_ += ""}"";
 code_ += """";
 }
",1438,319
"Part of #5265, neutral changes (#5281)"," std::string GenerateFBS(const Parser &parser, const std::string &file_name) {
 else
 schema += ""enum "" + enum_def.name + "" : "";
 schema += GenType(enum_def.underlying_type, true) + "" {\n"";
- for (auto it = enum_def.vals.vec.begin(); it != enum_def.vals.vec.end();
- ++it) {
+ for (auto it = enum_def.Vals().begin(); it != enum_def.Vals().end(); ++it) {
 auto &ev = **it;
 GenComment(ev.doc_comment, &schema, nullptr, "" "");
 if (enum_def.is_union)
",104,27
"Fix the proto-enum leaking issue (#5286)

* Detect leak with sanitizer

* Fix proto-enum leak issue"," CheckedError Parser::ParseProtoDecl() {
 
 // Temp: remove any duplicates, as .fbs files can't handle them.
 for (auto it = v.begin(); it != v.end();) {
- if (it != v.begin() && it[0]->value == it[-1]->value)
+ if (it != v.begin() && it[0]->value == it[-1]->value) {
+ auto ref = it[-1];
+ auto ev = it[0];
+ for (auto dit = enum_def->vals.dict.begin();
+ dit != enum_def->vals.dict.end(); ++dit) {
+ if (dit->second == ev) dit->second = ref; // reassign
+ }
+ delete ev; // delete enum value
 it = v.erase(it);
- else
+ } else {
 ++it;
+ }
 }
 } else if (IsIdent(""syntax"")) { // Skip these.
 NEXT();
",2699,826
"Allow Set() methods to handle reference types

Change-Id: I487ded77d28490189dd5d38236cb04bffaf5f11a"," struct EquipmentUnion {
 void Reset();
 
 #ifndef FLATBUFFERS_CPP98_STL
- template <typename T>
+ template <typename T, typename RT = typename std::remove_reference<T>::type>
 void Set(T&& val) {
 Reset();
- type = EquipmentTraits<typename T::TableType>::enum_value;
+ type = EquipmentTraits<typename RT::TableType>::enum_value;
 if (type != Equipment_NONE) {
- value = new T(std::forward<T>(val));
+ value = new RT(std::forward<T>(val));
 }
 }
 #endif // FLATBUFFERS_CPP98_STL
",777,185
"Fixed VS2010 build.

Change-Id: I3ee68c5f250d6baa02060ab2ecbc0f0fe254a9d8"," struct EquipmentUnion {
 void Reset();
 
 #ifndef FLATBUFFERS_CPP98_STL
- template <typename T, typename RT = typename std::remove_reference<T>::type>
+ template <typename T>
 void Set(T&& val) {
+ using RT = typename std::remove_reference<T>::type;
 Reset();
 type = EquipmentTraits<typename RT::TableType>::enum_value;
 if (type != Equipment_NONE) {
",778,185
Add logging of warnings from the flatc compiler (#5289)," void FlatCompiler::ParseFile(
 include_directories.push_back(local_include_directory.c_str());
 include_directories.push_back(nullptr);
 if (!parser.Parse(contents.c_str(), &include_directories[0],
- filename.c_str()))
+ filename.c_str())) {
 Error(parser.error_, false, false);
+ }
+ if (!parser.error_.empty()) { Warn(parser.error_, false); }
 include_directories.pop_back();
 include_directories.pop_back();
 }
",425,127
"Struct typetable (#5291)

* C++: Generate MiniReflectTypeTable for Structs as well as Tables

* Update generated code

* add test"," FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec3 FLATBUFFERS_FINAL_CLASS {
 float z_;
 
 public:
+ static const flatbuffers::TypeTable *MiniReflectTypeTable() {
+ return Vec3TypeTable();
+ }
 Vec3() {
 memset(static_cast<void *>(this), 0, sizeof(Vec3));
 }
",781,186
"fix check for Enum defaults (#5292)

fixes #5288"," CheckedError Parser::ParseField(StructDef &struct_def) {
 
 if (token_ == '=') {
 NEXT();
+ ECHECK(ParseSingleValue(&field->name, field->value, true));
 if (!IsScalar(type.base_type) ||
 (struct_def.fixed && field->value.constant != ""0""))
 return Error(
 ""default values currently only supported for scalars in tables"");
- ECHECK(ParseSingleValue(&field->name, field->value, true));
 }
 if (type.enum_def &&
 !type.enum_def->is_union &&
",2700,827
"Fix heap-buffer-overflow if there is a struct within a union

The validator previously did not check if a struct within a union was
valid, causing a heap buffer overflow. Add a check to make sure that
the struct is valid in this case.

Change-Id: I87d41b12fdfc2a99406789531ba92b841c063c76"," class CppGenerator : public BaseGenerator {
 "" auto ptr = reinterpret_cast<const {{TYPE}} *>(obj);"";
 if (ev.union_type.base_type == BASE_TYPE_STRUCT) {
 if (ev.union_type.struct_def->fixed) {
- code_ += "" return true;"";
+ code_ += "" return verifier.Verify<{{TYPE}}>(static_cast<const ""
+ ""uint8_t *>(obj), 0);"";
 } else {
 code_ += getptr;
 code_ += "" return verifier.VerifyTable(ptr);"";
",2398,501
"Fixed file access test in the wrong location.

Change-Id: I520339b442306204563d97743efe988eab459c08"," int FlatBufferTests() {
 ParseProtoTest();
 UnionVectorTest();
 LoadVerifyBinaryTest();
+ GenerateTableTextTest();
 #endif
 // clang-format on
 
 int FlatBufferTests() {
 IsAsciiUtilsTest();
 ValidFloatTest();
 InvalidFloatTest();
- GenerateTableTextTest();
 return 0;
 }
 
",2026,166
"[Javascript] Remove newly introduced trailing whitespace in flatbuffer.js (#5300)

* Remove newly introduced trailing whitespace in flatbuffer.js

The newly introduced clear function has some trailing white space in an
otherwise whitespace clean file. Remove it.

* Remove spurious new line in the BytesBuffer construction

Another spurious white space introduced by the clear() PR."," flatbuffers.ByteBuffer = function(bytes) {
 * @private
 */
 this.position_ = 0;
-
 };
 
 /**
 flatbuffers.ByteBuffer.allocate = function(byte_size) {
 return new flatbuffers.ByteBuffer(new Uint8Array(byte_size));
 };
 
-flatbuffers.ByteBuffer.prototype.clear = function() { 
+flatbuffers.ByteBuffer.prototype.clear = function() {
 this.position_ = 0;
 };
 
",546,147
"Bumped version to 1.11.0

Change-Id: I0c87ad2cf8f8768cf40c5b7abea0add087a5518a","
 #endif // !defined(FLATBUFFERS_LITTLEENDIAN)
 
 #define FLATBUFFERS_VERSION_MAJOR 1
-#define FLATBUFFERS_VERSION_MINOR 10
+#define FLATBUFFERS_VERSION_MINOR 11
 #define FLATBUFFERS_VERSION_REVISION 0
 #define FLATBUFFERS_STRING_EXPAND(X) #X
 #define FLATBUFFERS_STRING(X) FLATBUFFERS_STRING_EXPAND(X)
",85,15
"Update GRPC Java generated file.

Change-Id: I57ccbe0b9ccbbec65ca04f9db3cbd62243480d92","
-//Generated by flatc compiler (version 1.10.0)
+//Generated by flatc compiler (version 1.11.0)
 //If you make any local changes, they will be lost
 //source: monster_test.fbs
 
",373,53
"Added common rust traits to FlatBufferBuilder (#5307)

* Added Clone, Debug and Default"," struct FieldLoc {
 /// FlatBufferBuilder builds a FlatBuffer through manipulating its internal
 /// state. It has an owned `Vec<u8>` that grows as needed (up to the hardcoded
 /// limit of 2GiB, which is set by the FlatBuffers format).
+#[derive(Clone, Debug)]
 pub struct FlatBufferBuilder<'fbb> {
 owned_buf: Vec<u8>,
 head: usize,
 fn padding_bytes(buf_size: usize, scalar_size: usize) -> usize {
 // ((!buf_size) + 1) & (scalar_size - 1)
 (!buf_size).wrapping_add(1) & (scalar_size.wrapping_sub(1))
 }
+
+impl<'fbb> Default for FlatBufferBuilder<'fbb> {
+ fn default() -> Self {
+ Self::new_with_capacity(0)
+ }
+}
",427,42
"Fix issues with uint64 enums (#5265)

* Fix issues with uint64 enums

- hide the implementation of enums from code generators
- fix uint64 the issue in the cpp-generator
- fix #5108
- new tests
- enums with bit_flags attribute should be unsigned

* Refine objectives of EnumDef's FindByValue and ReverseLookup methods

- move EnumDef::ReverseLookup implementation to idl_parser.cpp
- fix typos

* Make the IsUInt64 method private"," class CodeWriter {
 value_map_[key] = value;
 }
 
+ std::string GetValue(const std::string &key) const {
+ const auto it = value_map_.find(key);
+ return it == value_map_.end() ? """" : it->second;
+ }
+
 // Appends the given text to the generated code as well as a newline
 // character. Any text within {{ and }} delimeters is replaced by values
 // previously stored in the CodeWriter by calling SetValue above. The newline
",119,10
"Fix out-of-range error (MSVC2010) in idl_gen_dart.cpp (#5335)

-- MSVC2010 doesn't support indexed access to \0-terminator."," class DartGenerator : public BaseGenerator {
 std::ostream_iterator<std::string>(sstream, "".""));
 
 auto ret = sstream.str() + ns.components.back();
- for (int i = 0; ret[i]; i++) {
+ for (size_t i = 0; i < ret.size(); i++) {
 auto lower = tolower(ret[i]);
 if (lower != ret[i]) {
 ret[i] = static_cast<char>(lower);
",761,188
"Make Monster's Color unsigned (#5318)

- update C++ monster_test::Color to unsigned type
- update Go Color:ubyte in the go_test.go
- add workaround for unsigned enum in java test
- sync generate.bat and generate.sh"," inline const BaseType (&EnumValuesBaseType())[17] {
 }
 
 inline const char * const *EnumNamesBaseType() {
- static const char * const names[] = {
+ static const char * const names[18] = {
 ""None"",
 ""UType"",
 ""Bool"",
",1115,306
"Set default CRTReportMode for the `flatc` target (#5336)

* Set default CRTReportMode for the `flatc` target

* Add util.cpp to GRPC test target

* Fix path to util.h"," bool SetGlobalTestLocale(const char *locale_name,
 bool ReadEnvironmentVariable(const char *var_name,
 std::string *_value = nullptr);
 
+// MSVC specific: Send all assert reports to STDOUT to prevent CI hangs.
+void SetupDefaultCRTReportMode();
+
 } // namespace flatbuffers
 
 #endif // FLATBUFFERS_UTIL_H_
",360,113
"[Go] Generate imports with fixed order (#5340)

* use fixed order for golang imports

* grumble"," struct Namespace {
 size_t from_table; // Part of the namespace corresponds to a message/table.
 };
 
+inline bool operator<(const Namespace &a, const Namespace &b) {
+ size_t min_size = std::min(a.components.size(), b.components.size());
+ for (size_t i = 0; i < min_size; ++i) {
+ if (a.components[i] != b.components[i])
+ return a.components[i] < b.components[i];
+ }
+ return a.components.size() < b.components.size();
+}
+
 // Base class for all definition types (fields, structs_, enums_).
 struct Definition {
 Definition()
",684,75
"[JS/TS] Size prefix support (#5326)

* WIP size prefix support

* Consider size prefix in overloaded variant

* Work on code gen

* Disabled helper functions in code gen

* Enabled helper functions in code gen

* Fix size prefixed test

* Fix bad function call

* Add SIZE_PREFIX_LENGTH

* Fix review comments"," function testUnicode() {
 MyGame.Example.Monster.addTestarrayofstring(fbb, testarrayofstringOffset);
 MyGame.Example.Monster.addTestarrayoftables(fbb, testarrayoftablesOffset);
 MyGame.Example.Monster.addName(fbb, name);
- MyGame.Example.Monster.finishMonsterBuffer(fbb, MyGame.Example.Monster.endMonster(fbb));
- testReadingUnicode(new flatbuffers.ByteBuffer(fbb.asUint8Array()));
+ MyGame.Example.Monster.finishSizePrefixedMonsterBuffer(fbb, MyGame.Example.Monster.endMonster(fbb));
+ var bb = new flatbuffers.ByteBuffer(fbb.asUint8Array())
+ bb.setPosition(4);
+ testReadingUnicode(bb);
 }
 
 var __imul = Math.imul ? Math.imul : function(a, b) {
",268,46
Add support for IAR compiler (#5347)," inline int LookupEnum(const char **names, const char *name) {
 #define FLATBUFFERS_STRUCT_END(name, size) \
 __pragma(pack()) \
 static_assert(sizeof(name) == size, ""compiler breaks packing rules"")
-#elif defined(__GNUC__) || defined(__clang__)
+#elif defined(__GNUC__) || defined(__clang__) || defined(__ICCARM__)
 #define FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(alignment) \
 _Pragma(""pack(1)"") \
 struct __attribute__((aligned(alignment)))
",1484,403
"[Go] Make enums into real types, add String() (#5235)

* [Go] Make enums into real types, add String()

This changes the generated code for enums: instead of type aliases,
they're now distinct types, allowing for better type-checking. Some
client code may have to be changed to add casts.

Enum types now have a String() method, so they implement fmt.Stringer.

An EnumValues map is now generated, in addition to the existing
EnumNames map, to easily map strings to values.

Generated enum files are now gofmt-clean.

Fixes #5207

* use example.ColorGreen explicitly

* use valid enum value in mutation test, add new test for ""invalid"" enum

* add length check and comment","
 
 package Example
 
-type Any = byte
+import ""strconv""
+
+type Any byte
+
 const (
-AnyNONE Any = 0
-AnyMonster Any = 1
+AnyNONE Any = 0
+AnyMonster Any = 1
 AnyTestSimpleTableWithEnum Any = 2
 AnyMyGame_Example2_Monster Any = 3
 )
 
 var EnumNamesAny = map[Any]string{
-AnyNONE:""NONE"",
-AnyMonster:""Monster"",
-AnyTestSimpleTableWithEnum:""TestSimpleTableWithEnum"",
-AnyMyGame_Example2_Monster:""MyGame_Example2_Monster"",
+AnyNONE: ""NONE"",
+AnyMonster: ""Monster"",
+AnyTestSimpleTableWithEnum: ""TestSimpleTableWithEnum"",
+AnyMyGame_Example2_Monster: ""MyGame_Example2_Monster"",
 }
 
+var EnumValuesAny = map[string]Any{
+""NONE"": AnyNONE,
+""Monster"": AnyMonster,
+""TestSimpleTableWithEnum"": AnyTestSimpleTableWithEnum,
+""MyGame_Example2_Monster"": AnyMyGame_Example2_Monster,
+}
+
+func (v Any) String() string {
+if s, ok := EnumNamesAny[v]; ok {
+return s
+}
+return ""Any("" + strconv.FormatInt(int64(v), 10) + "")""
+}
",27,2
"Added a CPP UnPackSizePrefixed<struct_name> generated helper function (#5350)

* Added a cpp UnPackSizePrefixed<struct_name> generated helper function

Missing helper function added to the cpp API generator for unpacking size prefixed structures

* Added generated test files"," inline flatbuffers::unique_ptr<MonsterT> UnPackMonster(
 return flatbuffers::unique_ptr<MonsterT>(GetMonster(buf)->UnPack(res));
 }
 
+inline flatbuffers::unique_ptr<MonsterT> UnPackSizePrefixedMonster(
+ const void *buf,
+ const flatbuffers::resolver_function_t *res = nullptr) {
+ return flatbuffers::unique_ptr<MonsterT>(GetSizePrefixedMonster(buf)->UnPack(res));
+}
+
 } // namespace Sample
 } // namespace MyGame
 
",786,187
"[Go] Change two more sites to use enum types (#5359)

Fixes #5357 (regression introduced by #5235)"," func (rcv *TestSimpleTableWithEnum) MutateColor(n Color) bool {
 func TestSimpleTableWithEnumStart(builder *flatbuffers.Builder) {
 builder.StartObject(1)
 }
-func TestSimpleTableWithEnumAddColor(builder *flatbuffers.Builder, color byte) {
-builder.PrependByteSlot(0, color, 2)
+func TestSimpleTableWithEnumAddColor(builder *flatbuffers.Builder, color Color) {
+builder.PrependByteSlot(0, byte(color), 2)
 }
 func TestSimpleTableWithEnumEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
 return builder.EndObject()
",39,9
Change usage of std::string's .at() to more widely-compatible []. (#5365)," CheckedError Parser::TryTypedValue(const std::string *name, int dtoken,
 const auto &s = e.constant;
 const auto k = s.find_first_of(""0123456789."");
 if ((std::string::npos != k) && (s.length() > (k + 1)) &&
- (s.at(k) == '0' && is_alpha_char(s.at(k + 1), 'X')) &&
+ (s[k] == '0' && is_alpha_char(s[k + 1], 'X')) &&
 (std::string::npos == s.find_first_of(""pP"", k + 2))) {
 return Error(
 ""invalid number, the exponent suffix of hexadecimal ""
",2836,866
Made Lobster builder offsets strongly typed," class LobsterGenerator : public BaseGenerator {
 std::string LobsterType(const Type &type) {
 if (IsFloat(type.base_type)) return ""float"";
 if (IsScalar(type.base_type) && type.enum_def) return NormalizedName(*type.enum_def);
+ if (!IsScalar(type.base_type)) return ""flatbuffers_offset"";
 return ""int"";
 }
 
 class LobsterGenerator : public BaseGenerator {
 MakeCamel(NormalizedName(field)) + ""(b_:flatbuffers_builder, "" +
 NormalizedName(field) + "":"" + LobsterType(field.value.type) +
 ""):\n b_.Prepend"" + GenMethod(field.value.type) + ""Slot("" +
- NumToString(offset) + "", "" + NormalizedName(field) + "", "" +
- field.value.constant + "")\n"";
+ NumToString(offset) + "", "" + NormalizedName(field);
+ if (IsScalar(field.value.type.base_type))
+ code += "", "" + field.value.constant;
+ code += "")\n"";
 if (field.value.type.base_type == BASE_TYPE_VECTOR) {
 code += ""def "" + NormalizedName(struct_def) + ""Start"" +
 MakeCamel(NormalizedName(field)) +
",312,69
"Generate FlagsAttribute for Csharp (#5370)

For schema enums with the bit_flags attribute, generate the
corresponding System.FlagsAttribute in generated Csharp code."," class GeneralGenerator : public BaseGenerator {
 std::string &code = *code_ptr;
 if (enum_def.generated) return;
 
+ // In C# this indicates enumeration values can be treated as bit flags.
+ if (lang_.language == IDLOptions::kCSharp && enum_def.attributes.Lookup(""bit_flags"")) {
+ code += ""[System.FlagsAttribute]\n"";
+ }
+
 // Generate enum definitions of the form:
 // public static (final) int name = value;
 // In Java, we use ints rather than the Enum feature, because we want them
",1361,316
Rename AnyUniqueAliases.T to AnyUniqueAliases.TS to avoid naming conflict (#5362)," type AnyUniqueAliases byte
 const (
 AnyUniqueAliasesNONE AnyUniqueAliases = 0
 AnyUniqueAliasesM AnyUniqueAliases = 1
-AnyUniqueAliasesT AnyUniqueAliases = 2
+AnyUniqueAliasesTS AnyUniqueAliases = 2
 AnyUniqueAliasesM2 AnyUniqueAliases = 3
 )
 
 var EnumNamesAnyUniqueAliases = map[AnyUniqueAliases]string{
 AnyUniqueAliasesNONE: ""NONE"",
 AnyUniqueAliasesM: ""M"",
-AnyUniqueAliasesT: ""T"",
+AnyUniqueAliasesTS: ""TS"",
 AnyUniqueAliasesM2: ""M2"",
 }
 
 var EnumValuesAnyUniqueAliases = map[string]AnyUniqueAliases{
 ""NONE"": AnyUniqueAliasesNONE,
 ""M"": AnyUniqueAliasesM,
-""T"": AnyUniqueAliasesT,
+""TS"": AnyUniqueAliasesTS,
 ""M2"": AnyUniqueAliasesM2,
 }
 
",27,2
"[C++] Fix Undefined behavior for zero length vectors (#5355)

* Fix Undefined behavior for zero length vectors

* Change fix for UBSan"," inline voffset_t FieldIndexToOffset(voffset_t field_id) {
 
 template<typename T, typename Alloc>
 const T *data(const std::vector<T, Alloc> &v) {
- return v.empty() ? nullptr : &v.front();
+ // Eventually the returned pointer gets passed down to memcpy, so
+ // we need it to be non-null to avoid undefined behavior.
+ static uint8_t t;
+ return v.empty() ? reinterpret_cast<const T*>(&t) : &v.front();
 }
 template<typename T, typename Alloc> T *data(std::vector<T, Alloc> &v) {
- return v.empty() ? nullptr : &v.front();
+ // Eventually the returned pointer gets passed down to memcpy, so
+ // we need it to be non-null to avoid undefined behavior.
+ static uint8_t t;
+ return v.empty() ? reinterpret_cast<T*>(&t) : &v.front();
 }
 
 /// @endcond
",1486,403
[C#] add FlatBuffersBuilder.CreateSharedString (#5372)," namespace FlatBuffers.Test
 }, builder.DataBuffer.ToFullArray());
 }
 
+ [FlatBuffersTestMethod]
+ public void TestCreateSharedAsciiString()
+ {
+ var builder = new FlatBufferBuilder(1);
+ builder.CreateSharedString(""foo"");
+ Assert.ArrayEqual(new byte[] { 3, 0, 0, 0, (byte)'f', (byte)'o', (byte)'o', 0 }, builder.DataBuffer.ToFullArray());
+
+ builder.CreateSharedString(""foo"");
+ Assert.ArrayEqual(new byte[] { 3, 0, 0, 0, (byte)'f', (byte)'o', (byte)'o', 0 }, builder.DataBuffer.ToFullArray());
+ }
+
 [FlatBuffersTestMethod]
 public void TestCreateArbitarytring()
 {
",712,55
"Dereference of null pointer #5353 (#5376)

add an assert to make sure that `key_field` is not a null pointer."," class GeneralGenerator : public BaseGenerator {
 // Only generate key compare function for table,
 // because `key_field` is not set for struct
 if (struct_def.has_key && !struct_def.fixed) {
+ FLATBUFFERS_ASSERT(key_field);
 if (lang_.language == IDLOptions::kJava) {
 code += ""\n @Override\n protected int keysCompare("";
 code += ""Integer o1, Integer o2, ByteBuffer _bb) {"";
",1362,316
"Enforce matching version in Java and C#.

Change-Id: I7f1f12f2f97e5227e0dabc2965ce66a6d41c229c"," public class Constants {
 static final int FILE_IDENTIFIER_LENGTH = 4;
 /** The number of bytes in a size prefix. */
 public static final int SIZE_PREFIX_LENGTH = 4;
+ /** A version identifier to force a compile error if someone
+ accidentally tries to build generated code with a runtime of
+ two mismatched version. Versions need to always match, as
+ the runtime and generated code are modified in sync.
+ Changes to the Java implementation need to be sure to change
+ the version here and in the code generator on every possible
+ incompatible change */
+ public static void FLATBUFFERS_1_11_1() {}
 }
 
 /// @endcond
",12,1
"Break internal Java/C# APIs

This is done on purpose, to avoid API version mismatches that
can cause bad decoding results, see:
https://github.com/google/flatbuffers/issues/5368

Change-Id: I2c857438377e080caad0e2d8bcc758c9b19bd6ec"," public class FlatBufferBuilder {
 *
 * @param numfields The number of fields found in this object.
 */
- public void startObject(int numfields) {
+ public void startTable(int numfields) {
 notNested();
 if (vtable == null || vtable.length < numfields) vtable = new int[numfields];
 vtable_in_use = numfields;
 public class FlatBufferBuilder {
 * Finish off writing the object that is under construction.
 *
 * @return The offset to the object inside {@link #dataBuffer()}.
- * @see #startObject(int)
+ * @see #startTable(int)
 */
- public int endObject() {
+ public int endTable() {
 if (vtable == null || !nested)
- throw new AssertionError(""FlatBuffers: endObject called without startObject"");
+ throw new AssertionError(""FlatBuffers: endTable called without startTable"");
 addInt(0);
 int vtableloc = offset();
 // Write out the current vtable.
",360,120
"Fix multi-line comments for cpp enums (#5345) (#5346)

- fix CSharp comments generation
- fix Python comments generation
- fix Lua comments generation
- fix PHP comments generation
- fix Dart comments generation
- add brief description of Color enum
- add multi-line comments to the Monster:Color"," class DartGenerator : public BaseGenerator {
 }
 
 auto &code = *code_ptr;
- if (indent) code += indent;
 
 for (auto it = dc.begin(); it != dc.end(); ++it) {
 if (indent) code += indent;
 class DartGenerator : public BaseGenerator {
 std::string type_name = GenDartTypeName(
 field.value.type, struct_def.defined_namespace, field, false);
 
- GenDocComment(field.doc_comment, &code, """");
+ GenDocComment(field.doc_comment, &code, """", "" "");
 
 code += "" "" + type_name + "" get "" + field_name;
 if (field.value.type.base_type == BASE_TYPE_UNION) {
",760,187
[rust] Derive Eq + PartialEq on FieldLoc and FlatBufferBuilder (#5394)," use vector::{SafeSliceAccess, Vector};
 
 pub const N_SMALLVEC_STRING_VECTOR_CAPACITY: usize = 16;
 
-#[derive(Clone, Copy, Debug)]
+#[derive(Clone, Copy, Debug, Eq, PartialEq)]
 struct FieldLoc {
 off: UOffsetT,
 id: VOffsetT,
 struct FieldLoc {
 /// FlatBufferBuilder builds a FlatBuffer through manipulating its internal
 /// state. It has an owned `Vec<u8>` that grows as needed (up to the hardcoded
 /// limit of 2GiB, which is set by the FlatBuffers format).
-#[derive(Clone, Debug)]
+#[derive(Clone, Debug, Eq, PartialEq)]
 pub struct FlatBufferBuilder<'fbb> {
 owned_buf: Vec<u8>,
 head: usize,
",427,42
"[rust] Use read_scalar_at where possible (#5385)

This slightly improves readability."," use std::marker::PhantomData;
 use std::ptr::write_bytes;
 use std::slice::from_raw_parts;
 
-use endian_scalar::{read_scalar, emplace_scalar};
+use endian_scalar::{read_scalar_at, emplace_scalar};
 use primitives::*;
 use push::{Push, PushAlignment};
 use table::Table;
 impl<'fbb> FlatBufferBuilder<'fbb> {
 
 {
 let n = self.head + self.used_space() - object_revloc_to_vtable.value() as usize;
- let saw = read_scalar::<UOffsetT>(&self.owned_buf[n..n + SIZE_SOFFSET]);
+ let saw = read_scalar_at::<UOffsetT>(&self.owned_buf, n);
 debug_assert_eq!(saw, 0xF0F0F0F0);
 emplace_scalar::<SOffsetT>(&mut self.owned_buf[n..n + SIZE_SOFFSET],
 vt_use as SOffsetT - object_revloc_to_vtable.value() as SOffsetT);
",427,42
Excluded crtdbg.h from non-MSVC compilation (#5401),"
 # ifndef NOMINMAX
 # define NOMINMAX
 # endif
-# include <crtdbg.h>
+# ifdef _MSC_VER
+# include <crtdbg.h>
+# endif
 # include <windows.h> // Must be included before <direct.h>
 # include <direct.h>
 # include <winbase.h>
",159,59
[Go] Fix namespaces on enums (#5406)," class GoGenerator : public BaseGenerator {
 
 // Construct the name of the type for this enum.
 std::string GetEnumTypeName(const EnumDef &enum_def) {
- return WrapInNameSpaceAndTrack(cur_name_space_, GoIdentity(enum_def.name));
+ return WrapInNameSpaceAndTrack(enum_def.defined_namespace, GoIdentity(enum_def.name));
 }
 
 // Create a type for the enum values.
",793,152
"[C#, Java, C++] Fixes issue #5399 by always including namespaces (#5404)

* [C#] Fixes issue #5399 by always including namespaces

* Updated tests for code generator changes

* Fixed 'As' method names"," class BaseGenerator {
 // which works for js and php
 virtual const Namespace *CurrentNameSpace() const { return nullptr; }
 
- // Ensure that a type is prefixed with its namespace whenever it is used
- // outside of its namespace.
+ // Ensure that a type is prefixed with its namespace even within
+ // its own namespace to avoid conflict between generated method
+ // names and similarly named classes or structs
 std::string WrapInNameSpace(const Namespace *ns,
 const std::string &name) const;
 
",119,10
"Add FLATBUFFERS_COMPATIBILITY string (#5381)

* Add FLATBUFFERS_COMPATIBILITY string

- Add a new __reset method NET/JAVA which hides internal state

* Resolve PR notes

* Use operator new() to __init of Struct and Table

* Restrict visibility of C# Table/Struct to internal level","
 #define FLATBUFFERS_VERSION_REVISION 0
 #define FLATBUFFERS_STRING_EXPAND(X) #X
 #define FLATBUFFERS_STRING(X) FLATBUFFERS_STRING_EXPAND(X)
+namespace flatbuffers {
+ // Returns version as string ""MAJOR.MINOR.REVISION"".
+ const char* FLATBUFFERS_VERSION();
+}
 
 #if (!defined(_MSC_VER) || _MSC_VER > 1600) && \
 (!defined(__GNUC__) || (__GNUC__ * 100 + __GNUC_MINOR__ >= 407)) || \
",89,16
Add support for fixed-size arrays (#5313),"
+# automatically generated by the FlatBuffers compiler, do not modify
+
+# namespace: Example
+
+import flatbuffers
+
+class ArrayTable(object):
+ __slots__ = ['_tab']
+
+ @classmethod
+ def GetRootAsArrayTable(cls, buf, offset):
+ n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
+ x = ArrayTable()
+ x.Init(buf, n + offset)
+ return x
+
+ # ArrayTable
+ def Init(self, buf, pos):
+ self._tab = flatbuffers.table.Table(buf, pos)
+
+ # ArrayTable
+ def A(self):
+ o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
+ if o != 0:
+ x = o + self._tab.Pos
+ from .ArrayStruct import ArrayStruct
+ obj = ArrayStruct()
+ obj.Init(self._tab.Bytes, x)
+ return obj
+ return None
+
+def ArrayTableStart(builder): builder.StartObject(1)
+def ArrayTableAddA(builder, a): builder.PrependStructSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(a), 0)
+def ArrayTableEnd(builder): return builder.EndObject()
",23,4
"Updated missing generated code for PR #5313 (fixed arrays)

Change-Id: I249140119e6241beb5aec5670d0e5ccddc8f5251"," public struct ArrayStruct : IFlatbufferObject
 {
 private Struct __p;
 public ByteBuffer ByteBuffer { get { return __p.bb; } }
- public void __init(int _i, ByteBuffer _bb) { __p.bb_pos = _i; __p.bb = _bb; }
+ public void __init(int _i, ByteBuffer _bb) { __p = new Struct(_i, _bb); }
 public ArrayStruct __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }
 
 public float A { get { return __p.bb.GetFloat(__p.bb_pos + 0); } }
",40,12
Fix generating nested Flatbuffer accessors when they cross namespaces (#5414)," CheckedError Parser::ParseField(StructDef &struct_def) {
 ""nested_flatbuffer attribute may only apply to a vector of ubyte"");
 // This will cause an error if the root type of the nested flatbuffer
 // wasn't defined elsewhere.
- LookupCreateStruct(nested->constant);
-
- // Keep a pointer to StructDef in FieldDef to simplify re-use later
- auto nested_qualified_name =
- current_namespace_->GetFullyQualifiedName(nested->constant);
- field->nested_flatbuffer = LookupStruct(nested_qualified_name);
+ field->nested_flatbuffer = LookupCreateStruct(nested->constant);
 }
 
 if (field->attributes.Lookup(""flexbuffer"")) {
",2926,889
"Fixed broken Utf8Old.java

This would not correctly encode/decode strings when substituted for
the default Utf8Safe.java

Change-Id: Ib303697663b5b8cbf6888492f5255b2a45384c04"," public class Utf8Old extends Utf8 {
 throw new IllegalArgumentException(""bad character encoding"", e);
 }
 }
+ cache.lastOutput.flip();
 return cache.lastOutput.remaining();
 }
 
 public class Utf8Old extends Utf8 {
 buffer.limit(offset + length);
 try {
 CharBuffer result = decoder.decode(buffer);
- result.flip();
 return result.toString();
 } catch (CharacterCodingException e) {
 throw new IllegalArgumentException(""Bad encoding"", e);
",66,11
Don't check ForceDefaults when adding Offfset values (#5415)," namespace FlatBuffers
 /// </summary>
 /// <param name=""o"">The index into the vtable</param>
 /// <param name=""x"">The value to put into the buffer. If the value is equal to the default
- /// and <see cref=""ForceDefaults""/> is false, the value will be skipped.</param>
+ /// the value will be skipped.</param>
 /// <param name=""d"">The default value to compare the value against</param>
- public void AddOffset(int o, int x, int d) { if (ForceDefaults || x != d) { AddOffset(x); Slot(o); } }
+ public void AddOffset(int o, int x, int d) { if (x != d) { AddOffset(x); Slot(o); } }
 /// @endcond
 
 /// <summary>
",382,119
Set C# Struct/Table visibility to public (#5381) (#5416)," namespace FlatBuffers
 /// <summary>
 /// All structs in the generated code derive from this class, and add their own accessors.
 /// </summary>
- internal struct Struct
+ public struct Struct
 {
 public int bb_pos { get; private set; }
 public ByteBuffer bb { get; private set; }
",13,1
Fix for FLATBUFFERS_PREFER_PRINTF writing zero-length strings (#5418)," std::string NumToStringImplWrapper(T t, const char *fmt, int precision = 0) {
 size_t string_width = NumToStringWidth(t, precision);
 std::string s(string_width, 0x00);
 // Allow snprintf to use std::string trailing null to detect buffer overflow
- snprintf(const_cast<char *>(s.data()), (s.size() + 1), fmt, precision, t);
+ snprintf(const_cast<char *>(s.data()), (s.size() + 1), fmt, string_width, t);
 return s;
 }
 #endif // FLATBUFFERS_PREFER_PRINTF
",360,113
"Update Utf8.java: more detailed exception message (#5421)

Provide more detailed exception message for malformed 2 byte utf8 character"," public abstract class Utf8 {
 throws IllegalArgumentException {
 // Simultaneously checks for illegal trailing-byte in leading position (<= '11000000') and
 // overlong 2-byte, '11000001'.
- if (byte1 < (byte) 0xC2
- || isNotTrailingByte(byte2)) {
- throw new IllegalArgumentException(""Invalid UTF-8"");
+ if (byte1 < (byte) 0xC2) {
+ throw new IllegalArgumentException(""Invalid UTF-8: Illegal leading byte in 2 bytes utf"");
+ }
+ if (isNotTrailingByte(byte2)) {
+ throw new IllegalArgumentException(""Invalid UTF-8: Illegal trailing byte in 2 bytes utf"");
 }
 resultArr[resultPos] = (char) (((byte1 & 0x1F) << 6) | trailingByteValue(byte2));
 }
",91,27
"Fix undefined behavior. Closes #5422 (#5423)

* Fix undefined behavior. Closes #5422

* Move check into callers of make_space"," class vector_downward {
 uint8_t *data_at(size_t offset) const { return buf_ + reserved_ - offset; }
 
 void push(const uint8_t *bytes, size_t num) {
- memcpy(make_space(num), bytes, num);
+ if (num > 0) { memcpy(make_space(num), bytes, num); }
 }
 
 // Specialized version of push() that avoids memcpy call for small data.
 class vector_downward {
 }
 
 // Version for when we know the size is larger.
+ // Precondition: zero_pad_bytes > 0
 void fill_big(size_t zero_pad_bytes) {
 memset(make_space(zero_pad_bytes), 0, zero_pad_bytes);
 }
",1527,421
"Remove unused variables (#5382)

- Fix GenerateTextFromTable (aliasing typo)
- Fix unused variable in idl_gen_dart.cpp
- Fix std::string passing (should be non-const value or const-reference)
- Remove unused variables"," class BaseGenerator {
 protected:
 BaseGenerator(const Parser &parser, const std::string &path,
 const std::string &file_name,
- const std::string qualifying_start,
- const std::string qualifying_separator)
+ std::string qualifying_start,
+ std::string qualifying_separator)
 : parser_(parser),
 path_(path),
 file_name_(file_name),
",119,10
"Extend the test of MonsterExtra (#5428)

* Extend the test of MonsterExtra

- Extend C++ test of MonsterExtra
- Add conversion of fbs/json NaNs to unsigned quiet-NaN
- Update documentation (cross-platform interoperability)

* Fix declaration of infinity constants int the test","
 
 namespace flatbuffers {
 // Generic 'operator==' with conditional specialisations.
+// T e - new value of a scalar field.
+// T def - default of scalar (is known at compile-time).
 template<typename T> inline bool IsTheSameAs(T e, T def) { return e == def; }
 
 #if defined(FLATBUFFERS_NAN_DEFAULTS) && \
- (!defined(_MSC_VER) || _MSC_VER >= 1800)
+ defined(FLATBUFFERS_HAS_NEW_STRTOD) && (FLATBUFFERS_HAS_NEW_STRTOD > 0)
 // Like `operator==(e, def)` with weak NaN if T=(float|double).
+template<typename T> inline bool IsFloatTheSameAs(T e, T def) {
+ return (e == def) || ((def != def) && (e != e));
+}
 template<> inline bool IsTheSameAs<float>(float e, float def) {
- return (e == def) || (std::isnan(def) && std::isnan(e));
+ return IsFloatTheSameAs(e, def);
 }
 template<> inline bool IsTheSameAs<double>(double e, double def) {
- return (e == def) || (std::isnan(def) && std::isnan(e));
+ return IsFloatTheSameAs(e, def);
 }
 #endif
 
",1530,420
[rust] Ran rustfmt against library code (#5389)," pub trait EndianScalar: Sized + PartialEq + Copy + Clone {
 /// Macro for implementing a no-op endian conversion. This is used for types
 /// that are one byte wide.
 macro_rules! impl_endian_scalar_noop {
- ($ty:ident) => (
+ ($ty:ident) => {
 impl EndianScalar for $ty {
 #[inline]
 fn to_little_endian(self) -> Self {
 macro_rules! impl_endian_scalar_noop {
 self
 }
 }
- )
+ };
 }
 
 /// Macro for implementing an endian conversion using the stdlib `to_le` and
 macro_rules! impl_endian_scalar_noop {
 /// floats, because the `to_le` and `from_le` are not implemented for them in
 /// the stdlib.
 macro_rules! impl_endian_scalar_stdlib_le_conversion {
- ($ty:ident) => (
+ ($ty:ident) => {
 impl EndianScalar for $ty {
 #[inline]
 fn to_little_endian(self) -> Self {
 macro_rules! impl_endian_scalar_stdlib_le_conversion {
 Self::from_le(self)
 }
 }
- )
+ };
 }
 
 impl_endian_scalar_noop!(bool);
 pub fn read_scalar<T: EndianScalar>(s: &[u8]) -> T {
 
 x.from_little_endian()
 }
-
",121,15
[C++] fix static_cast expression (#5441)," class FlatBufferBuilder {
 extern T Pack(const S &);
 typedef T (*Pack_t)(const S &);
 std::vector<T> vv(len);
- std::transform(v, v + len, vv.begin(), static_cast<Pack_t&>(Pack));
+ std::transform(v, v + len, vv.begin(), static_cast<Pack_t>(&Pack));
 return CreateVectorOfStructs<T>(vv.data(), vv.size());
 }
 
",1530,420
Support nested_flatbuffer attribute when parsing bfbs schema (#5448)," Offset<reflection::Field> FieldDef::Serialize(FlatBufferBuilder *builder,
 }
 
 bool FieldDef::Deserialize(Parser &parser, const reflection::Field *field) {
- name = parser.UnqualifiedName(field->name()->str());
+ name = field->name()->str();
 defined_namespace = parser.current_namespace_;
 if (!value.type.Deserialize(parser, field->type()))
 return false;
 bool FieldDef::Deserialize(Parser &parser, const reflection::Field *field) {
 value.type.element != BASE_TYPE_UCHAR)
 return false;
 }
+ if (auto nested = attributes.Lookup(""nested_flatbuffer"")) {
+ auto nested_qualified_name =
+ parser.current_namespace_->GetFullyQualifiedName(nested->constant);
+ nested_flatbuffer = parser.LookupStruct(nested_qualified_name);
+ if (!nested_flatbuffer) return false;
+ }
 DeserializeDoc(doc_comment, field->documentation());
 return true;
 }
",2938,900
Fix numeric_limits<T>::max() to avoid conflict with windows.h header (#5462)," template<typename T> inline bool StringToNumber(const char *s, T *val) {
 int64_t i64;
 // The errno check isn't needed, will return MAX/MIN on overflow.
 if (StringToIntegerImpl(&i64, s, 0, false)) {
- const int64_t max = flatbuffers::numeric_limits<T>::max();
+ const int64_t max = (flatbuffers::numeric_limits<T>::max)();
 const int64_t min = flatbuffers::numeric_limits<T>::lowest();
 if (i64 > max) {
 *val = static_cast<T>(max);
 inline bool StringToNumber<uint64_t>(const char *str, uint64_t *val) {
 if (*s == '-') {
 // For unsigned types return the max to distinguish from
 // ""no conversion can be performed"".
- *val = flatbuffers::numeric_limits<uint64_t>::max();
+ *val = (flatbuffers::numeric_limits<uint64_t>::max)();
 return false;
 }
 }
",360,113
Replace '--cpp-include' brackets to quotes (#5438) (#5464)," class CppGenerator : public BaseGenerator {
 
 void GenExtraIncludes() {
 for(std::size_t i = 0; i < parser_.opts.cpp_includes.size(); ++i) {
- code_ += ""#include <"" + parser_.opts.cpp_includes[i] + "">"";
+ code_ += ""#include \"""" + parser_.opts.cpp_includes[i] + ""\"""";
 }
 if (!parser_.opts.cpp_includes.empty()) {
 code_ += """";
",2488,525
"Fix for Boolean types (#5379) (#5466)

The packing/unpacking steps for Boolean values was failing because the
code expected numerical values. I overrode the functions for the Boolean
metatable to account for this. I also had to exclude the Boolean
metatable from the GenerateTypes helper function, as that was overriding
the Pack/Unpack functions defined in its metatable.

Added Linux bash script to run Lua tests from the command line.

Bug: google/flatbuffers#5379

Tested: Added Lua tests that were failing and are now fixed with the
code changes."," local function checkReadBuffer(buf, offset, sizePrefix)
 
 if sizePrefix then 
 local size = flatbuffers.N.Int32:Unpack(buf, offset)
- -- no longer matches python tests, but the latest 'monsterdata_test.mon'
- -- is 448 bytes, minus 4 to arrive at the 444
- assert(size == 444)
+ assert(size == #buf - offset - 4)
 offset = offset + flatbuffers.N.Int32.bytewidth
 end 
 
 local function generateMonster(sizePrefix)
 monster.AddTestType(b, 1)
 monster.AddTest(b, mon2)
 monster.AddTest4(b, test4)
+ monster.AddTestbool(b, true)
+ monster.AddTestbool(b, false)
+ monster.AddTestbool(b, null)
+ monster.AddTestbool(b,""true"")
 monster.AddTestarrayofstring(b, testArrayOfString)
 monster.AddVectorOfLongs(b, vectorOfLongs)
 monster.AddVectorOfDoubles(b, vectorOfDoubles)
",234,25
"[C++ ] Correctly serialize bit_flags enums to JSON with output_enum_identifiers option (#5454)

* Support output_enum_identifiers for enums with multiple bit values

* Cast bit_flag enum val to uint64_t instead of int64_t"," bool Print(T val, Type type, int /*indent*/, Type * /*union_type*/,
 const IDLOptions &opts, std::string *_text) {
 std::string &text = *_text;
 if (type.enum_def && opts.output_enum_identifiers) {
- auto ev = type.enum_def->ReverseLookup(static_cast<int64_t>(val));
- if (ev) {
- text += ""\"""";
- text += ev->name;
- text += ""\"""";
+ std::vector<EnumVal const *> enum_values;
+ if (auto ev = type.enum_def->ReverseLookup(static_cast<int64_t>(val))) {
+ enum_values.push_back(ev);
+ } else if (val && type.enum_def->attributes.Lookup(""bit_flags"")) {
+ for (auto it = type.enum_def->Vals().begin(),
+ e = type.enum_def->Vals().end();
+ it != e; ++it) {
+ if ((*it)->GetAsUInt64() & static_cast<uint64_t>(val))
+ enum_values.push_back(*it);
+ }
+ }
+ if (!enum_values.empty()) {
+ text += '\""';
+ for (auto it = enum_values.begin(), e = enum_values.end(); it != e; ++it)
+ text += (*it)->name + ' ';
+ text[text.length() - 1] = '\""';
 return true;
 }
 }
",276,75
"Fix compilation error in tests. (#5472)

Local variables were shadowing member fields, causing errors."," namespace Native {
 float z;
 
 Vector3D() { x = 0; y = 0; z = 0; };
- Vector3D(float x, float y, float z) { this->x = x; this->y = y; this->z = z; }
+ Vector3D(float _x, float _y, float _z) { this->x = _x; this->y = _y; this->z = _z; }
 };
 }
 
",16,2
"has_method support for primitive fields in java runtime. Changed: idl.h, FlatBufferBuilder.java , idl_gen_general.cpp, idl_parser.cpp, flatc.cpp (#5468)

* has_method support for primitive fields in java runtime

* adding the new flag to flatc

* addressing the review comments"," struct IDLOptions {
 bool size_prefixed;
 std::string root_type;
 bool force_defaults;
+ bool java_primitive_has_method;
 std::vector<std::string> cpp_includes;
 
 // Possible options for the more general generator below.
 struct IDLOptions {
 protobuf_ascii_alike(false),
 size_prefixed(false),
 force_defaults(false),
+ java_primitive_has_method(false),
 lang(IDLOptions::kJava),
 mini_reflect(IDLOptions::kNone),
 lang_to_generate(0),
 class Parser : public ParserState {
 
 extern std::string MakeCamel(const std::string &in, bool first = true);
 
+extern std::string MakeScreamingCamel(const std::string &in);
+
 // Generate text (JSON) from a given FlatBuffer, and a given Parser
 // object that has been populated with the corresponding schema.
 // If ident_step is 0, no indentation will be generated. Additionally,
",717,83
"reflection: check for valid union enum value during object verification (#5475)

... to avoid assertion failure or invalid access due to invalid vector index"," bool VerifyObject(flatbuffers::Verifier &v, const reflection::Schema &schema,
 if (utype != 0) {
 // Means we have this union field present
 auto fb_enum = schema.enums()->Get(field_def->type()->index());
+ if (utype >= fb_enum->values()->size()) return false;
 auto child_obj = fb_enum->values()->Get(utype)->object();
 if (!VerifyObject(v, schema, *child_obj,
 flatbuffers::GetFieldT(*table, *field_def),
",569,195
"C++ IDL generation adds superfluous semicolon in GenTablePost, causing (#5483)

-Wextra-semi-stmt warning when building with Clang 8.0.0. Update generated
files for testing"," class CppGenerator : public BaseGenerator {
 code_.SetValue(""FIELD_NAME"", Name(field));
 auto prefix = "" { auto _e = {{FIELD_NAME}}(); "";
 auto check = IsScalar(field.value.type.base_type) ? """" : ""if (_e) "";
- auto postfix = "" };"";
+ auto postfix = "" }"";
 code_ += std::string(prefix) + check + statement + postfix;
 }
 code_ += ""}"";
",2488,525
Fix incorrect padding in arrays of structs (Issue #5484) (#5491)," inline size_t InlineSize(const Type &type) {
 }
 
 inline size_t InlineAlignment(const Type &type) {
- return IsStruct(type)
- ? type.struct_def->minalign
- : (SizeOf(IsArray(type) ? type.element : type.base_type));
+ if (IsStruct(type)) {
+ return type.struct_def->minalign;
+ } else if (IsArray(type)) {
+ return IsStruct(type.VectorType()) ? type.struct_def->minalign
+ : SizeOf(type.element);
+ } else {
+ return SizeOf(type.base_type);
+ }
 }
 
 struct EnumDef;
",722,84
"[bugfix]flexbuffers isvector bugfix (#5488)

* commit isvector bugfix (change email recommit to pass cla)

* commit IsUntypedVector

* delete isvectorormap function"," class Reference {
 bool IsString() const { return type_ == FBT_STRING; }
 bool IsKey() const { return type_ == FBT_KEY; }
 bool IsVector() const { return type_ == FBT_VECTOR || type_ == FBT_MAP; }
+ bool IsUntypedVector() const { return type_ == FBT_VECTOR; }
 bool IsTypedVector() const { return flexbuffers::IsTypedVector(type_); }
 bool IsFixedTypedVector() const { return flexbuffers::IsFixedTypedVector(type_); }
 bool IsAnyVector() const { return (IsTypedVector() || IsFixedTypedVector() || IsVector());}
 bool IsMap() const { return type_ == FBT_MAP; }
 bool IsBlob() const { return type_ == FBT_BLOB; }
-
 bool AsBool() const {
 return (type_ == FBT_BOOL ? ReadUInt64(data_, parent_width_)
 : AsUInt64()) != 0;
",1164,386
"Fixed STLPort Android compile error

Change-Id: I3595b9c6803718f34ce61fdfc367da97b50dc444"," class FlatBufferBuilder {
 extern T Pack(const S &);
 std::vector<T> vv(len);
 std::transform(v, v + len, vv.begin(), Pack);
- return CreateVectorOfStructs<T>(vv.data(), vv.size());
+ return CreateVectorOfStructs<T>(data(vv), vv.size());
 }
 
 // clang-format off
",1529,420
"Android: remove app_dummy() calls

Change-Id: I0ebd4502f98d009ce5afe8c8bafb629284f0366c","
 
 extern int main(int argc, char **argv);
 
-void android_main(android_app *app) {
- // Make sure glue isn't stripped.
- app_dummy();
-
+void android_main(android_app *) {
 main(0, NULL);
 }
",5,1
Use all of the available space in the buffer returned by ByteBufferFactory to allow the factory to keep a pool of larger than initialsize sized buffers. (#5500)," public class FlatBufferBuilder {
 if (initial_size <= 0) {
 initial_size = 1;
 }
- space = initial_size;
 this.bb_factory = bb_factory;
 if (existing_bb != null) {
 bb = existing_bb;
 public class FlatBufferBuilder {
 bb = bb_factory.newByteBuffer(initial_size);
 }
 this.utf8 = utf8;
+ space = bb.capacity();
 }
 
 /**
",363,121
"[C#] Fix retrieving enumeration vectors as arrays (#5457)

* [C#] Fix retrieving enumeration vectors as arrays

* [C#] Don't generate CreateVectorBlock for enums"," namespace FlatBuffers.Test
 Assert.AreEqual(""Monster"", Any.Monster.ToString());
 }
 
+ [FlatBuffersTestMethod]
+ public void TestVectorOfEnums()
+ {
+ const string monsterName = ""TestVectorOfEnumsMonster"";
+ var colorVec = new Color[] { Color.Red, Color.Green, Color.Blue };
+ var fbb = new FlatBufferBuilder(32);
+ var str1 = fbb.CreateString(monsterName);
+ var vec1 = Monster.CreateVectorOfEnumsVector(fbb, colorVec);
+ Monster.StartMonster(fbb);
+ Monster.AddName(fbb, str1);
+ Monster.AddVectorOfEnums(fbb, vec1);
+ var monster1 = Monster.EndMonster(fbb);
+ Monster.FinishMonsterBuffer(fbb, monster1);
+
+ var mons = Monster.GetRootAsMonster(fbb.DataBuffer);
+ var colors = mons.GetVectorOfEnumsArray();
+ Assert.ArrayEqual(colorVec, colors);
+ }
+
 [FlatBuffersTestMethod]
 public void TestNestedFlatBuffer()
 {
",319,42
"[Javascript] Fix syntax error for signed enum (#5503)

* wrap quotes to enum name map to prevent syntax errorn when enum value is negative

* Add a test that covers signed enum case"," class JsTsGenerator : public BaseGenerator {
 
 // Generate mapping between EnumName: EnumValue(int)
 if (reverse) {
- code += "" "" + enum_def.ToString(ev);
+ code += "" '"" + enum_def.ToString(ev) + ""'"";
 code += lang_.language == IDLOptions::kTs ? ""= "" : "": "";
 code += ""'"" + ev.name + ""'"";
 } else {
",1191,277
"Rust: Fixed cargo clippy on non-generated code (#5485)

* Cargo clippy lints

* more lints

* more lints

* Restored a doc comment

* Comment on float eps-eq and adjusted casting"," pub struct Table<'a> {
 impl<'a> Table<'a> {
 #[inline]
 pub fn new(buf: &'a [u8], loc: usize) -> Self {
- Table { buf: buf, loc: loc }
+ Table { buf, loc }
 }
 #[inline]
 pub fn vtable(&self) -> VTable<'a> {
 impl<'a> Follow<'a> for Table<'a> {
 type Inner = Table<'a>;
 #[inline]
 fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
- Table { buf: buf, loc: loc }
+ Table { buf, loc }
 }
 }
 
",56,3
"Annotate getters with @Pure when --java-checkerframework is specified. (#5510)

Together with @Nullable, this allows users to use static analysis tools
like CheckerFramework to catch NPEs caused by unset fields."," struct IDLOptions {
 std::string cpp_object_api_string_type;
 bool cpp_object_api_string_flexible_constructor;
 bool gen_nullable;
+ bool java_checkerframework;
 bool gen_generated;
 std::string object_prefix;
 std::string object_suffix;
 struct IDLOptions {
 cpp_object_api_pointer_type(""std::unique_ptr""),
 cpp_object_api_string_flexible_constructor(false),
 gen_nullable(false),
+ java_checkerframework(false),
 gen_generated(false),
 object_suffix(""T""),
 union_value_namespacing(true),
",724,84
"Add element size parameter to __vector_as_arraysegment [c#] (#5512)

* Add element size parameter to __vector_as_arraysegment

Add element size parameter to __vector_as_arraysegment fixing issue where VectorAsBytes returns incorrect size span for multibyte element types.

* Update codegen

Update codegen and Table to return typed span.

* update test files

update test files","
 
 using System;
 using System.Text;
+using System.Runtime.InteropServices;
 
 namespace FlatBuffers
 {
 namespace FlatBuffers
 // Get the data of a vector whoses offset is stored at ""offset"" in this object as an
 // Spant&lt;byte&gt;. If the vector is not present in the ByteBuffer,
 // then an empty span will be returned.
- public Span<byte> __vector_as_span(int offset)
+ public Span<T> __vector_as_span<T>(int offset, int elementSize) where T : struct
 {
+ if (!BitConverter.IsLittleEndian)
+ {
+ throw new NotSupportedException(""Getting typed span on a Big Endian "" +
+ ""system is not support"");
+ }
+
 var o = this.__offset(offset);
 if (0 == o)
 {
- return new Span<byte>();
+ return new Span<T>();
 }
 
 var pos = this.__vector(o);
 var len = this.__vector_len(o);
- return bb.ToSpan(pos, len);
+ return MemoryMarshal.Cast<byte, T>(bb.ToSpan(pos, len * elementSize));
 }
 #else
 // Get the data of a vector whoses offset is stored at ""offset"" in this object as an
",145,25
"Fixed GenerateText not handling vectors of unions.

Change-Id: Ie82abaf178495c4692e7d10be6b4a13f2fa1bee6"," void UnionVectorTest() {
 
 TestMovie(repacked_movie);
 
+ // Generate text using mini-reflection.
 auto s =
 flatbuffers::FlatBufferToString(fbb.GetBufferPointer(), MovieTypeTable());
 TEST_EQ_STR(
 void UnionVectorTest() {
 "" ]\n""
 ""}"");
 
+ // Generate text using parsed schema.
+ std::string jsongen;
+ auto result = GenerateText(parser, fbb.GetBufferPointer(), &jsongen);
+ TEST_EQ(result, true);
+ TEST_EQ_STR(
+ jsongen.c_str(),
+ ""{\n""
+ "" main_character_type: \""Rapunzel\"",\n""
+ "" main_character: {\n""
+ "" hair_length: 6\n""
+ "" },\n""
+ "" characters_type: [\n""
+ "" \""Belle\"",\n""
+ "" \""MuLan\"",\n""
+ "" \""BookFan\"",\n""
+ "" \""Other\"",\n""
+ "" \""Unused\""\n""
+ "" ],\n""
+ "" characters: [\n""
+ "" {\n""
+ "" books_read: 7\n""
+ "" },\n""
+ "" {\n""
+ "" sword_attack_damage: 5\n""
+ "" },\n""
+ "" {\n""
+ "" books_read: 2\n""
+ "" },\n""
+ "" \""Other\"",\n""
+ "" \""Unused\""\n""
+ "" ]\n""
+ ""}\n"");
+
 flatbuffers::Parser parser2(idl_opts);
 TEST_EQ(parser2.Parse(""struct Bool { b:bool; }""
 ""union Any { Bool }""
",2365,187
"Fixed Reflection Verifier not handling vectors of unions.

Change-Id: Ie94386ff8e10fd2a964bd9155139b50953746a37"," class Verifier FLATBUFFERS_FINAL_CLASS {
 return VerifyAlignment<T>(elem) && Verify(elem, sizeof(T));
 }
 
+ bool VerifyFromPointer(const uint8_t *p, size_t len) {
+ auto o = static_cast<size_t>(p - buf_);
+ return Verify(o, len);
+ }
+
 // Verify relative to a known-good base pointer.
 bool Verify(const uint8_t *base, voffset_t elem_off, size_t elem_len) const {
 return Verify(static_cast<size_t>(base - buf_) + elem_off, elem_len);
",1533,421
Fixed DetachedBuffer self move assignment (#5521)," class DetachedBuffer {
 #if !defined(FLATBUFFERS_CPP98_STL)
 // clang-format on
 DetachedBuffer &operator=(DetachedBuffer &&other) {
+ if (this == &other)
+ return *this;
+
 destroy();
 
 allocator_ = other.allocator_;
",1535,422
"Java: Added access object for vector of struct and vector of tables. (#5233)

* Java: Added access object for vector of struct and vector of tables.

* Java: Workarounds removed when accessing the union vector."," namespace FlatBuffers
 // Initialize any Table-derived type to point to the union at the given offset.
 public T __union<T>(int offset) where T : struct, IFlatbufferObject
 {
- offset += bb_pos;
 T t = new T();
- t.__init(offset + bb.GetInt(offset), bb);
+ t.__init(__indirect(offset), bb);
 return t;
 }
 
",144,25
"[FlexBuffers][Java] Fix wrong access to a string using Reference::asString(). (#5532)

The real position of a string is calculated by using the indirect() method,
which should be based on parentWidth and not byteWidth, as it was implemented.

We are also fixing the flag BUILDER_FLAG_SHARE_STRINGS on FlexBuffersBuilder
that was set as '1', same value as BUILDER_FLAG_SHARE_KEYS."," public class FlexBuffers {
 */
 public String asString() {
 if (isString()) {
- int start = indirect(bb, end, byteWidth);
+ int start = indirect(bb, end, parentWidth);
 int size = readInt(bb, start - byteWidth, byteWidth);
 return Utf8.getDefault().decodeUtf8(bb, start, size);
 }
",612,211
[FlexBuffers][Java] Add override Key::toString (#5533)," public class FlexBuffers {
 */
 @Override
 public StringBuilder toString(StringBuilder sb) {
+ return sb.append(toString());
+ }
+
+ @Override
+ public String toString() {
 int size;
 for (int i = end; ; i++) {
 if (bb.get(i) == 0) {
 public class FlexBuffers {
 break;
 }
 }
- sb.append(Utf8.getDefault().decodeUtf8(bb, end, size));
- return sb;
+ return Utf8.getDefault().decodeUtf8(bb, end, size);
 }
 
 int compareTo(byte[] other) {
",615,212
"Adds XOPEN_SOURCE for PATH_MAX and POSIX 1993 for stat (#5529)

* Adds XOPEN_SOURCE for PATH_MAX and POSIX 1993 for stat

These are the only two required extension for compilation of
flatbuffers using -std=c++11 instead of gnu++11.

* Sets _XOPEN_SOURCE to 600 and enable POSIX2001 for fseeko","
 
 // clang-format off
 // Dont't remove `format off`, it prevent reordering of win-includes.
+#define _POSIX_C_SOURCE 200112L // For stat from stat/stat.h and fseeko() (POSIX extensions).
 #ifdef _WIN32
 # ifndef WIN32_LEAN_AND_MEAN
 # define WIN32_LEAN_AND_MEAN

 # include <winbase.h>
 # undef interface // This is also important because of reasons
 #else
+# define _XOPEN_SOURCE 600 // For PATH_MAX from limits.h (SUSv2 extension) 
 # include <limits.h>
 #endif
 // clang-format on
",159,59
"[flac] Add FlexBuffers option for generating data (#5519)

Alongside --binary and --json, an additional
switch (--flexbuffers) can be passed to convert
data using FlexBuffers"," void AppendToString(std::string &s, T &&v, bool keys_quoted) {
 
 class Reference {
 public:
+ Reference()
+ : data_(nullptr),
+ parent_width_(0),
+ byte_width_(BIT_WIDTH_8),
+ type_(FBT_NULL) {}
+
 Reference(const uint8_t *data, uint8_t parent_width, uint8_t byte_width,
 Type type)
 : data_(data),
",1182,390
"Fix namespaced struct/field name collision detection (#5540) (#5545)

Changes the use of `LookupStruct` to `LookupCreateStruct` in
`ParseField` to also detect when collisions happen in namespaces."," CheckedError Parser::AddField(StructDef &struct_def, const std::string &name,
 CheckedError Parser::ParseField(StructDef &struct_def) {
 std::string name = attribute_;
 
- if (LookupStruct(name))
+ if (LookupCreateStruct(name, false, false))
 return Error(""field name can not be the same as table/struct name"");
 
 std::vector<std::string> dc = doc_comment_;
",2958,904
"Fixed Android STLPort related error.

Change-Id: I59ff072e526fc63b3215767a4d4a2a8944b65654"," class GeneralGenerator : public BaseGenerator {
 code += MakeCamel(field.name, lang_.first_camel_upper);
 code += ""Bytes() { return "";
 code += lang_.accessor_prefix + ""__vector_as_arraysegment("";
- code += NumToString(field.value.offset); 
+ code += NumToString(field.value.offset);
 code += ""); }\n"";
 code += ""#endif\n"";
 
 bool GenerateBinary(const Parser &parser, const std::string &path,
 const std::string &file_name) {
 if (parser.opts.use_flexbuffers) {
 auto data_vec = parser.flex_builder_.GetBuffer();
- auto data_ptr = reinterpret_cast<char *>(data_vec.data());
+ auto data_ptr = reinterpret_cast<char *>(data(data_vec));
 return !parser.flex_builder_.GetSize() ||
 flatbuffers::SaveFile(
 BinaryFileName(parser, path, file_name).c_str(), data_ptr,
",1568,368
"Fix issue #5542 (#5543)

Empty objects that inherit from Sized would try to access internal
ByteBuffer when Sized::size was called. So we add a single byte in
the empty buffer, so when size() is called it would return 0"," class JavaTest {
 FlexBuffers.getRoot(b.getBuffer()).toString());
 }
 
+ public static void testFlexBuferEmpty() {
+ FlexBuffers.Blob blob = FlexBuffers.Blob.empty();
+ FlexBuffers.Map ary = FlexBuffers.Map.empty();
+ FlexBuffers.Vector map = FlexBuffers.Vector.empty();
+ FlexBuffers.TypedVector typedAry = FlexBuffers.TypedVector.empty();
+ TestEq(blob.size(), 0);
+ TestEq(map.size(), 0);
+ TestEq(ary.size(), 0);
+ TestEq(typedAry.size(), 0);
+ }
+
 public static void testHashMapToMap() {
 int entriesCount = 12;
 
 class JavaTest {
 testSingleElementMap();
 testFlexBuffersTest();
 testHashMapToMap();
+ testFlexBuferEmpty();
 }
 
 static <T> void TestEq(T a, T b) {
",746,58
"[FlexBuffers][Java] Cache size of Sized objects in FlexBuffers (#5551)

In my benchmarks it shows deserialization performance improvements of
around 7%"," public class FlexBuffers {
 
 // Stores size in `byte_width_` bytes before end position.
 private static abstract class Sized extends Object {
+
+ private final int size;
+
 Sized(ByteBuffer buff, int end, int byteWidth) {
 super(buff, end, byteWidth);
+ size = readInt(bb, end - byteWidth, byteWidth);
 }
 
 public int size() {
- return readInt(bb, end - byteWidth, byteWidth);
+ return size;
 }
 }
 
",617,212
"Fixed JSON parser not sorting vectors of tables/structs with key.

Change-Id: Iacc0c8513af80a736700e6cbaf513ebdf8e3ac89"," void AccessFlatBufferTest(const uint8_t *flatbuf, size_t length,
 // Example of accessing a vector of tables:
 auto vecoftables = monster->testarrayoftables();
 TEST_EQ(vecoftables->size(), 3U);
- for (auto it = vecoftables->begin(); it != vecoftables->end(); ++it)
+ for (auto it = vecoftables->begin(); it != vecoftables->end(); ++it) {
 TEST_EQ(strlen(it->name()->c_str()) >= 4, true);
+ }
 TEST_EQ_STR(vecoftables->Get(0)->name()->c_str(), ""Barney"");
 TEST_EQ(vecoftables->Get(0)->hp(), 1000);
 TEST_EQ_STR(vecoftables->Get(1)->name()->c_str(), ""Fred"");
",2372,187
Fix build with gcc version 7.4.0 (#5570)," namespace flatbuffers {
 // to detect a header that provides an implementation
 #if defined(__has_include)
 // Check for std::string_view (in c++17)
- #if __has_include(<string_view>) && (__cplusplus >= 201606 || _HAS_CXX17)
+ #if __has_include(<string_view>) && (__cplusplus >= 201606 || (defined(_HAS_CXX17) && _HAS_CXX17))
 #include <string_view>
 namespace flatbuffers {
 typedef std::string_view string_view;
",87,16
"[Java] byte buffer factory returned buffer capcity is used instead of the requested size (#5558)

* byte buffer factory returned buffer is used instead of the requested capacity

* byte buffer factory returned buffer is used instead of the requested capacity

* Comment fix"," public class FlatBufferBuilder {
 int new_buf_size = old_buf_size == 0 ? 1 : old_buf_size << 1;
 bb.position(0);
 ByteBuffer nbb = bb_factory.newByteBuffer(new_buf_size);
+ new_buf_size = nbb.clear().capacity(); // Ensure the returned buffer is treated as empty
 nbb.position(new_buf_size - old_buf_size);
 nbb.put(bb);
 return nbb;
",364,121
"Fixed warnings generated by recent JSON sorting feature.

Change-Id: I6fd6283b616c7a39bb878b1610e4ddf6e208fa0a"," CheckedError Parser::ParseVectorDelimiters(uoffset_t &count, F body) {
 return NoError();
 }
 
-static int CompareType(const uint8_t *a, const uint8_t *b, BaseType ftype) {
+static bool CompareType(const uint8_t *a, const uint8_t *b, BaseType ftype) {
 switch (ftype) {
 #define FLATBUFFERS_TD(ENUM, IDLTYPE, CTYPE, JTYPE, GTYPE, NTYPE, \
 PTYPE, RTYPE, KTYPE) \
 CheckedError Parser::ParseVector(const Type &type, uoffset_t *ovalue,
 // stored in memory, so compute the distance between these pointers:
 ptrdiff_t diff = (b - a) * sizeof(Offset<Table>);
 assert(diff >= 0); // Guaranteed by SimpleQsort.
- a->o = EndianScalar(ReadScalar<uoffset_t>(a) - diff);
- b->o = EndianScalar(ReadScalar<uoffset_t>(b) + diff);
+ auto udiff = static_cast<uoffset_t>(diff);
+ a->o = EndianScalar(ReadScalar<uoffset_t>(a) - udiff);
+ b->o = EndianScalar(ReadScalar<uoffset_t>(b) + udiff);
 std::swap(*a, *b);
 });
 }
",3034,916
"Java: Don't annotate vector-of-tables item getters with @nullable. (#5562)

* Annotate getters with @Pure when --java-checkerframework is specified.

Together with @Nullable, this allows users to use static analysis tools
like CheckerFramework to catch NPEs caused by unset fields.

* Don't annotate vector-of-tables item getters with @Nullable.

Since Flatbuffers don't support null items in vectors of tables."," class GeneralGenerator : public BaseGenerator {
 
 std::string GenNullableAnnotation(const Type &t) const {
 return lang_.language == IDLOptions::kJava && parser_.opts.gen_nullable &&
- !IsScalar(DestinationType(t, true).base_type)
+ !IsScalar(DestinationType(t, true).base_type) &&
+ t.base_type != BASE_TYPE_VECTOR
 ? "" @Nullable ""
 : """";
 }
",1569,369
"Avoid intentional unsigned integer overflow getting caught by sanitizers (#5572)

* Avoid intentional unsigned integer overflow getting caught by sanitizers

* Adapt from suggested compiler compatible solution

* And a third way :)"," class Verifier FLATBUFFERS_FINAL_CLASS {
 return true;
 }
 
+ __supress_ubsan__(""unsigned-integer-overflow"")
 bool VerifyTableStart(const uint8_t *table) {
 // Check the vtable offset.
 auto tableo = static_cast<size_t>(table - buf_);
",1565,426
"Fix issue #5557 (#5573)

- remove not necessary file `monster_test_generated.h` from sample_bfbs.cpp","
 #include ""flatbuffers/idl.h""
 #include ""flatbuffers/util.h""
 
-#include ""monster_test_generated.h""
 #include ""monster_generated.h"" // Already includes ""flatbuffers/flatbuffers.h"".
 
 using namespace MyGame::Sample;
",43,7
Fix Follow implementation for bool (#5554)," impl<'a, T: Follow<'a> + 'a> Follow<'a> for SkipFileIdentifier<T> {
 }
 }
 
+impl<'a> Follow<'a> for bool {
+ type Inner = bool;
+ #[inline(always)]
+ fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
+ read_scalar_at::<u8>(buf, loc) != 0
+ }
+}
+
 /// Follow trait impls for primitive types.
 ///
 /// Ideally, these would be implemented as a single impl using trait bounds on
 macro_rules! impl_follow_for_endian_scalar {
 };
 }
 
-impl_follow_for_endian_scalar!(bool);
 impl_follow_for_endian_scalar!(u8);
 impl_follow_for_endian_scalar!(u16);
 impl_follow_for_endian_scalar!(u32);
",209,15
"Rust: Fix Copy and Clone impls for a few generic types (#5577)

* Rust: Fix Copy and Clone impls for a few generic types

* Add tests for Copy+Clone

* Wrap Copy+Clone checks in a #[test] function"," use endian_scalar::{read_scalar, read_scalar_at};
 use follow::Follow;
 use primitives::*;
 
-#[derive(Debug, Clone, Copy)]
+#[derive(Debug)]
 pub struct Vector<'a, T: 'a>(&'a [u8], usize, PhantomData<T>);
 
+// We cannot use derive for these two impls, as it would only implement Copy
+// and Clone for `T: Copy` and `T: Clone` respectively. However `Vector<'a, T>`
+// can always be copied, no matter that `T` you have.
+impl<'a, T> Copy for Vector<'a, T> {}
+impl<'a, T> Clone for Vector<'a, T> {
+ fn clone(&self) -> Self {
+ *self
+ }
+}
+
 impl<'a, T: 'a> Vector<'a, T> {
 #[inline(always)]
 pub fn new(buf: &'a [u8], loc: usize) -> Self {
",123,6
C++ verifier for evolved union fields should return true (#5586)," inline bool VerifyEquipment(flatbuffers::Verifier &verifier, const void *obj, Eq
 auto ptr = reinterpret_cast<const MyGame::Sample::Weapon *>(obj);
 return verifier.VerifyTable(ptr);
 }
- default: return false;
+ default: return true;
 }
 }
 
",786,187
"Fix typos in comments (#5590)

Found by the https://github.com/OSGeo/gdal/blob/master/gdal/scripts/fix_typos.sh
script on the internal copy of flatbuffers inside GDAL","
 #if !defined(__clang__) && \
 defined(__GNUC__) && \
 (__GNUC__ * 10000 + __GNUC_MINOR__ * 100 + __GNUC_PATCHLEVEL__ < 40600)
- // Backwards compatability for g++ 4.4, and 4.5 which don't have the nullptr
+ // Backwards compatibility for g++ 4.4, and 4.5 which don't have the nullptr
 // and constexpr keywords. Note the __clang__ check is needed, because clang
 // presents itself as an older GNUC compiler.
 #ifndef nullptr_t
",87,16
"[Go] Object API support (#5339)

* start

* works for current usages!

* unpack: vector of struct

* optimize byte slice

* support nested struct

* support null table

* support struct

* support union

* update generated code

* grumble

* fix compiler warning

* update generated code

* wrap type in namespace

* bug

* wrap in namespace

* enum byte arrays

* generate struct for unions

* basic testing

* remove branching

* fix assert

* pack vector of fixed structs correctly

* omit null vectors

* Refactor Union Pack and UnPack methods

Remove append usage to increase code efficiency when dealing with large vectors

* generate goldens"," import (
 flatbuffers ""github.com/google/flatbuffers/go""
 )
 
+type AbilityT struct {
+Id uint32
+Distance uint32
+}
+
+func AbilityPack(builder *flatbuffers.Builder, t *AbilityT) flatbuffers.UOffsetT {
+if t == nil { return 0 }
+return CreateAbility(builder, t.Id, t.Distance)
+}
+func (rcv *Ability) UnPack() *AbilityT {
+if rcv == nil { return nil }
+t := &AbilityT{}
+t.Id = rcv.Id()
+t.Distance = rcv.Distance()
+return t
+}
+
 type Ability struct {
 _tab flatbuffers.Struct
 }
",47,11
[Go] Add UnPackTo functions (#5598)," func AbilityPack(builder *flatbuffers.Builder, t *AbilityT) flatbuffers.UOffsetT
 if t == nil { return 0 }
 return CreateAbility(builder, t.Id, t.Distance)
 }
+func (rcv *Ability) UnPackTo(t *AbilityT) {
+t.Id = rcv.Id()
+t.Distance = rcv.Distance()
+}
+
 func (rcv *Ability) UnPack() *AbilityT {
 if rcv == nil { return nil }
 t := &AbilityT{}
-t.Id = rcv.Id()
-t.Distance = rcv.Distance()
+rcv.UnPackTo(t)
 return t
 }
 
",50,12
"[flatc] Remove an always true condition for flexbuffers (#5604)

The condition was unnecessary and Detected by

PVS-Studio
V560 [CWE-571] A part of conditional expression is always true: !opts.use_flexbuffers. flatc.cpp 438"," int FlatCompiler::Compile(int argc, const char **argv) {
 }
 } else {
 ParseFile(*parser.get(), filename, contents, include_directories);
- if (!opts.use_flexbuffers && !is_schema &&
- !parser->builder_.GetSize()) {
+ if (!is_schema && !parser->builder_.GetSize()) {
 // If a file doesn't end in .fbs, it must be json/binary. Ensure we
 // didn't just parse a schema with a different extension.
 Error(""input file is neither json nor a .fbs (schema) file: "" +
",450,136
"[Kotlin] Fix union vector accessor after change in Java API (#5605)

Kolin uses java library as dependency, which changed the way it access union vector recently
(e365c502ffc659752f9b7a8d60b0052a07e33659).

This changes updates kotlin code generation to match Java's changes."," class KotlinGenerator : public BaseGenerator {
 params = ""obj: "" + field_type + "", j: Int"";
 }
 
-
- writer.SetValue(""toType"", ""YYYYY"");
-
 auto ret_type = return_type + nullable;
 GenerateFun(writer, field_name, params, ret_type, [&](){
 auto inline_size = NumToString(InlineSize(vectortype));
 class KotlinGenerator : public BaseGenerator {
 GenerateFun(writer, field_name, ""obj: "" + field_type,
 return_type + ""?"", [&](){
 writer += OffsetWrapperOneLine(offset_val,
- bbgetter + ""(obj, o)"",
+ bbgetter + ""(obj, o + bb_pos)"",
 ""null"");
 });
 break;
",1203,279
Add Lua FlatbufferBuilder Clean() method to enable reuseable builders (#5606)," function m.New(initialSize)
 return o
 end
 
+-- Clears the builder and resets the state. It does not actually clear the backing binary array, it just reuses it as
+-- needed. This is a performant way to use the builder for multiple constructions without the overhead of multiple
+-- builder allocations.
+function mt:Clear()
+ self.finished = false
+ self.nested = false
+ self.minalign = 1
+ self.currentVTable = nil
+ self.objectEnd = nil
+ self.head = #self.bytes -- place the head at the end of the binary array
+
+ -- clear vtables instead of making a new table
+ local vtable = self.vtables
+ local vtableCount = #vtable
+ for i=1,vtableCount do vtable[i] = nil end
+end
+
 function mt:Output(full)
 assert(self.finished, ""Builder Not Finished"")
 if full then
",311,80
"flatbuffers.h: fix documentation warning (#5607)

Fixes following clang -Wdocumentation warning:
```
flatbuffers.h:1762:17: error: parameter ']' not found in the function declaration [-Werror,-Wdocumentation]
 /// @param[in]] v A const reference to the `std::vector` of structs to
```"," class FlatBufferBuilder {
 /// `vector`.
 /// @tparam T The data type of the `std::vector` struct elements.
 /// @tparam S The data type of the `std::vector` native struct elements.
- /// @param[in]] v A const reference to the `std::vector` of structs to
+ /// @param[in] v A const reference to the `std::vector` of structs to
 /// serialize into the buffer as a `vector`.
 /// @return Returns a typed `Offset` into the serialized data indicating
 /// where the vector is stored.
",1565,426
"[C++, Java, C#, TypeScript, JavaScript] Skip generation of mutable union types (#5599)

* Skip generation of mutable union types

* Removed C# and Java unit tests that mutated a Union type"," struct Monster FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
 MyGame::Sample::Equipment equipped_type() const {
 return static_cast<MyGame::Sample::Equipment>(GetField<uint8_t>(VT_EQUIPPED_TYPE, 0));
 }
- bool mutate_equipped_type(MyGame::Sample::Equipment _equipped_type) {
- return SetField<uint8_t>(VT_EQUIPPED_TYPE, static_cast<uint8_t>(_equipped_type), 0);
- }
 const void *equipped() const {
 return GetPointer<const void *>(VT_EQUIPPED);
 }
",783,186
"include/flatbuffers/base.h: fix no_sanitize issue with old clang (#5610)

Older clang versions raise:
```
./flatbuffers/base.h:365:1: error: unknown attribute 'no_sanitize' ignored [-Werror,-Wattributes]
__supress_ubsan__(""alignment"")
^
./flatbuffers/base.h:246:50: note: expanded from macro '__supress_ubsan__'
 #define __supress_ubsan__(type) __attribute__((no_sanitize(type)))
 ^
```

Comparing https://releases.llvm.org/3.6.0/tools/clang/docs/AttributeReference.html
with https://releases.llvm.org/3.7.0/tools/clang/docs/AttributeReference.html
shows that __attribute__((no_sanitize(type))) is available since 3.7.0"," namespace flatbuffers {
 // Suppress Undefined Behavior Sanitizer (recoverable only). Usage:
 // - __supress_ubsan__(""undefined"")
 // - __supress_ubsan__(""signed-integer-overflow"")
-#if defined(__clang__)
+#if defined(__clang__) && (__clang_major__ > 3 || (__clang_major__ == 3 && __clang_minor__ >=7))
 #define __supress_ubsan__(type) __attribute__((no_sanitize(type)))
 #elif defined(__GNUC__) && (__GNUC__ * 100 + __GNUC_MINOR__ >= 409)
 #define __supress_ubsan__(type) __attribute__((no_sanitize_undefined))
",87,16
"Fixed deprecated method in GRPC Java test.

Change-Id: Iccae8fe9409adbf3cd3013a5cf3368e068175ad3"," public class JavaGrpcTest {
 if (monster.hp() > maxHp.get()) {
 // Found a monster of higher hit points.
 maxHp.set(monster.hp());
- maxHpMonsterName.set(monster.name()); 
+ maxHpMonsterName.set(monster.name());
 maxHpCount.set(1);
 }
 else if (monster.hp() == maxHp.get()) {
 public class JavaGrpcTest {
 channel = ManagedChannelBuilder.forAddress(""localhost"", port)
 // Channels are secure by default (via SSL/TLS). For the example we disable TLS to avoid
 // needing certificates.
- .usePlaintext(true)
+ .usePlaintext()
 .directExecutor()
 .build();
 blockingStub = MonsterStorageGrpc.newBlockingStub(channel);
 public class JavaGrpcTest {
 final CountDownLatch streamAlive = new CountDownLatch(1);
 
 StreamObserver<Stat> statObserver = new StreamObserver<Stat>() {
- public void onCompleted() { 
+ public void onCompleted() {
 streamAlive.countDown();
 }
 public void onError(Throwable ex) { }
",188,20
"[C++] Refactor to conform to Google C++ style guide (#5608)

* Automatic refractor of C++ headers to Google C++ style guide

* Automatic refractor of C++ source to Google C++ style guide

* Automatic refractor of C++ tests to Google C++ style guide

* Fixed clang-format issues by running clang-format twice to correct itself. Kotlin was missing clang-format on after turning it off, so it was changed,","
 
 #include <map>
 #include <sstream>
+
 #include ""flatbuffers/idl.h""
 
 namespace flatbuffers {
 class BaseGenerator {
 
 protected:
 BaseGenerator(const Parser &parser, const std::string &path,
- const std::string &file_name,
- std::string qualifying_start,
+ const std::string &file_name, std::string qualifying_start,
 std::string qualifying_separator)
 : parser_(parser),
 path_(path),
",127,13
Change monster_extra generation to use flatbuffers::unique_ptr (#5612)," inline void FinishSizePrefixedMonsterExtraBuffer(
 fbb.FinishSizePrefixed(root, MonsterExtraIdentifier());
 }
 
-inline std::unique_ptr<MyGame::MonsterExtraT> UnPackMonsterExtra(
+inline flatbuffers::unique_ptr<MyGame::MonsterExtraT> UnPackMonsterExtra(
 const void *buf,
 const flatbuffers::resolver_function_t *res = nullptr) {
- return std::unique_ptr<MyGame::MonsterExtraT>(GetMonsterExtra(buf)->UnPack(res));
+ return flatbuffers::unique_ptr<MyGame::MonsterExtraT>(GetMonsterExtra(buf)->UnPack(res));
 }
 
-inline std::unique_ptr<MyGame::MonsterExtraT> UnPackSizePrefixedMonsterExtra(
+inline flatbuffers::unique_ptr<MyGame::MonsterExtraT> UnPackSizePrefixedMonsterExtra(
 const void *buf,
 const flatbuffers::resolver_function_t *res = nullptr) {
- return std::unique_ptr<MyGame::MonsterExtraT>(GetSizePrefixedMonsterExtra(buf)->UnPack(res));
+ return flatbuffers::unique_ptr<MyGame::MonsterExtraT>(GetSizePrefixedMonsterExtra(buf)->UnPack(res));
 }
 
 } // namespace MyGame
",367,86
Ran src/clang-format-all.sh (#5617),"
 #ifndef GRPC_INTERNAL_COMPILER_SCHEMA_INTERFACE_H
 #define GRPC_INTERNAL_COMPILER_SCHEMA_INTERFACE_H
 
-#include ""src/compiler/config.h""
-
 #include <memory>
 #include <vector>
 
+#include ""src/compiler/config.h""
+
 #ifndef GRPC_CUSTOM_STRING
 # include <string>
 # define GRPC_CUSTOM_STRING std::string
",58,5
add check for root_type specified for json schema generation (#5622)," class JsonSchemaGenerator : public BaseGenerator {
 : BaseGenerator(base_generator) {}
 
 bool generate() {
+ if (parser_.root_struct_def_ == nullptr) { return false; }
 code_.Clear();
 code_ += ""{"";
 code_ += "" \""$schema\"": \""http://json-schema.org/draft-04/schema#\"","";
",182,50
"[C++, C#, Java] Separated C# and Java generators into their own classes (#5618)

* Cloned idl_gen_general.cpp to idl_gen_csharp.cpp and removed java references

* Java generator changes"," extern bool GenerateBinary(const Parser &parser, const std::string &path,
 extern bool GenerateCPP(const Parser &parser, const std::string &path,
 const std::string &file_name);
 
+// Generate C# files from the definitions in the Parser object.
+// See idl_gen_csharp.cpp.
+extern bool GenerateCSharp(const Parser &parser, const std::string &path,
+ const std::string &file_name);
+
 extern bool GenerateDart(const Parser &parser, const std::string &path,
 const std::string &file_name);
 
+// Generate Java files from the definitions in the Parser object.
+// See idl_gen_java.cpp.
+extern bool GenerateJava(const Parser &parser, const std::string &path,
+ const std::string &file_name);
+
 // Generate JavaScript or TypeScript code from the definitions in the Parser
 // object. See idl_gen_js.
 extern bool GenerateJSTS(const Parser &parser, const std::string &path,
",713,86
Removed idl_gen_general.cpp and move contents to code_generators.cpp (#5625)," int FlatCompiler::Compile(int argc, const char **argv) {
 params_.generators[i].lang_name + "" for "" + filebase);
 }
 } else {
- std::string make_rule = params_.generators[i].make_rule(
- *parser.get(), output_path, filename);
- if (!make_rule.empty())
- printf(""%s\n"",
- flatbuffers::WordWrap(make_rule, 80, "" "", "" \\"").c_str());
+ if (params_.generators[i].make_rule == nullptr) {
+ Error(std::string(""Cannot generate make rule for "") +
+ params_.generators[i].lang_name);
+ } else {
+ std::string make_rule = params_.generators[i].make_rule(
+ *parser.get(), output_path, filename);
+ if (!make_rule.empty())
+ printf(""%s\n"",
+ flatbuffers::WordWrap(make_rule, 80, "" "", "" \\"").c_str());
+ }
 }
 if (grpc_enabled) {
 if (params_.generators[i].generateGRPC != nullptr) {
",456,137
"Support for python grpc - continuing the work from the pull request #4270 #4705 (#5613)

* Support for python grpc

* add few fixes

* Fixes build

* Fix python generator

* Add tests

* Fix grpc python test

* Fix tests and add incomplete python generator

* Fix python generator

* Add python generator methods

* Fix Appveyor build

* grpc python support v0.1

* Update tests

* update grpctest

* Remove duplicated code and fix a brace

* tests for flatbuffers grpc python

* Updated tests + removed SerializeToString, From String

* remove pickle import

* include missing files in ci - BUILD and generated test result"," struct Method : public CommentHolder {
 
 virtual grpc::string get_input_type_name() const = 0;
 virtual grpc::string get_output_type_name() const = 0;
+
+ virtual grpc::string get_fb_builder() const = 0;
+
 virtual bool NoStreaming() const = 0;
 virtual bool ClientStreaming() const = 0;
 virtual bool ServerStreaming() const = 0;
",59,5
add namespace prefix in FLATBUFFERS_MAX_BUFFER_SIZE (#5629)," typedef uint16_t voffset_t;
 typedef uintmax_t largest_scalar_t;
 
 // In 32bits, this evaluates to 2GB - 1
-#define FLATBUFFERS_MAX_BUFFER_SIZE ((1ULL << (sizeof(soffset_t) * 8 - 1)) - 1)
+#define FLATBUFFERS_MAX_BUFFER_SIZE ((1ULL << (sizeof(::flatbuffers::soffset_t) * 8 - 1)) - 1)
 
 // We support aligning the contents of buffers up to this size.
 #define FLATBUFFERS_MAX_ALIGNMENT 16
",87,16
read vtable size through ReadScalar() (#5636)," class FlatBufferBuilder {
 it += sizeof(uoffset_t)) {
 auto vt_offset_ptr = reinterpret_cast<uoffset_t *>(it);
 auto vt2 = reinterpret_cast<voffset_t *>(buf_.data_at(*vt_offset_ptr));
- auto vt2_size = *vt2;
+ auto vt2_size = ReadScalar<voffset_t>(vt2);
 if (vt1_size != vt2_size || 0 != memcmp(vt2, vt1, vt1_size)) continue;
 vt_use = *vt_offset_ptr;
 buf_.pop(GetSize() - vtableoffsetloc);
",1561,426
Simplify declarations of x-macro FLATBUFFERS_TD (#5638)," class CppGenerator : public BaseGenerator {
 std::string GenTypeBasic(const Type &type, bool user_facing_type) const {
 // clang-format off
 static const char *const ctypename[] = {
- #define FLATBUFFERS_TD(ENUM, IDLTYPE, CTYPE, JTYPE, GTYPE, NTYPE, PTYPE, \
- RTYPE, KTYPE) \
- #CTYPE,
+ #define FLATBUFFERS_TD(ENUM, IDLTYPE, CTYPE, ...) \
+ #CTYPE,
 FLATBUFFERS_GEN_TYPES(FLATBUFFERS_TD)
- #undef FLATBUFFERS_TD
+ #undef FLATBUFFERS_TD
 };
 // clang-format on
 if (user_facing_type) {
",2515,535
Fix ambiguity of a type deduction in TEST_EQ macro if arguments have `enum class` type. (#5630)," static TestFailEventListener fail_listener_ = nullptr;
 
 void TestFail(const char *expval, const char *val, const char *exp,
 const char *file, int line, const char *func) {
- TEST_OUTPUT_LINE(""VALUE: \""%s\"""", expval);
- TEST_OUTPUT_LINE(""EXPECTED: \""%s\"""", val);
+ TEST_OUTPUT_LINE(""EXPECTED: \""%s\"""", expval);
+ TEST_OUTPUT_LINE(""VALUE: \""%s\"""", val);
 TEST_OUTPUT_LINE(""TEST FAILED: %s:%d, %s in %s"", file, line, exp,
 func ? func : """");
 testing_fails++;
 void TestFail(const char *expval, const char *val, const char *exp,
 }
 
 void TestEqStr(const char *expval, const char *val, const char *exp,
- const char *file, int line) {
- if (strcmp(expval, val) != 0) { TestFail(expval, val, exp, file, line); }
+ const char *file, int line, const char *func) {
+ if (strcmp(expval, val) != 0) { TestFail(expval, val, exp, file, line, func); }
 }
 
 #if defined(FLATBUFFERS_MEMORY_LEAK_TRACKING) && defined(_MSC_VER) && \
",38,11
"[GO] Fix support for enums with underscores and Unions with imported members (#5600)

* Fix Enum Stringer method when Enum has underscores

Fixes #5481

* Fix go package importing itself when Union has imported members."," class GoGenerator : public BaseGenerator {
 tracked_imported_namespaces_.clear();
 needs_imports = false;
 std::string enumcode;
+ GenEnum(**it, &enumcode);
 if ((*it)->is_union && parser_.opts.generate_object_based_api) {
 GenNativeUnion(**it, &enumcode);
 GenNativeUnionPack(**it, &enumcode);
 GenNativeUnionUnPack(**it, &enumcode);
 needs_imports = true;
 }
- GenEnum(**it, &enumcode);
 if (parser_.opts.one_file) {
 one_file_code += enumcode;
 } else {
",1129,229
[Clang 10]: definition of implicit copy constructor for 'TableKeyComparatoris deprecated #5649 (#5650)," class FlatBufferBuilder {
 /// @cond FLATBUFFERS_INTERNAL
 template<typename T> struct TableKeyComparator {
 TableKeyComparator(vector_downward &buf) : buf_(buf) {}
+ TableKeyComparator(const TableKeyComparator &other) : buf_(other.buf_) {}
 bool operator()(const Offset<T> &a, const Offset<T> &b) const {
 auto table_a = reinterpret_cast<T *>(buf_.data_at(a.o));
 auto table_b = reinterpret_cast<T *>(buf_.data_at(b.o));
 class FlatBufferBuilder {
 vector_downward &buf_;
 
 private:
- TableKeyComparator &operator=(const TableKeyComparator &);
+ TableKeyComparator &operator=(const TableKeyComparator &other) {
+ buf_ = other.buf_;
+ return *this;
+ }
 };
 /// @endcond
 
",1565,428
"Remove a static_assert (#5643)

Having a static_assert on MSAN and ASAN prevents
the fuzzers from being used with different engines,
like TSAN, UBSAN,  but also with fuzzers that aren't
using MSAN/ASAN like afl for example.","
 #include ""fuzzer_assert.h""
 #include ""test_assert.h""
 
-static_assert(__has_feature(memory_sanitizer) ||
- __has_feature(address_sanitizer),
- ""sanitizer disabled"");
-
 // Utility for test run.
 struct OneTimeTestInit {
 // Declare trap for the Flatbuffers test engine.
 struct OneTimeTestInit {
 static OneTimeTestInit one_time_init_;
 };
 
-#endif // !FUZZER_TEST_INIT_H_
\ No newline at end of file
+#endif // !FUZZER_TEST_INIT_H_
",33,5
"Split Bazel targets into multiple packages (#5640)

* Split Bazel targets into multiple packages

* Merge /include/BUILD back into /BUILD","
 * limitations under the License.
 */
 
-#include ""java_generator.h""
+#include ""src/compiler/java_generator.h""
 
 #include <algorithm>
 #include <iostream>
",904,132
"Fixed enum min/max values not properly escaped.

Change-Id: I503fbfaff1d2579807ca71a07cca8363dff75e52"," class CppGenerator : public BaseGenerator {
 code_ += ""{{SEP}} {{KEY}} = {{VALUE}}\\"";
 } else { // MIN & MAX are useless for bit_flags
 code_.SetValue(""KEY"", GenEnumValDecl(enum_def, ""MIN""));
- code_.SetValue(""VALUE"", GenEnumValDecl(enum_def, minv->name));
+ code_.SetValue(""VALUE"", GenEnumValDecl(enum_def, Name(*minv)));
 code_ += ""{{SEP}} {{KEY}} = {{VALUE}}\\"";
 
 code_.SetValue(""KEY"", GenEnumValDecl(enum_def, ""MAX""));
- code_.SetValue(""VALUE"", GenEnumValDecl(enum_def, maxv->name));
+ code_.SetValue(""VALUE"", GenEnumValDecl(enum_def, Name(*maxv)));
 code_ += ""{{SEP}} {{KEY}} = {{VALUE}}\\"";
 }
 }
",2515,535
"Add --force-empty-vectors option (#5653)

The rationale for this option is that JSON clients typically want empty arrays (i.e [] in the JSON) instead of missing properties, but not empty strings when the value isn't set.
--force-empty is kept as-is, i.e. it will force both empty strings and vectors.

Closes #5652"," struct IDLOptions {
 // for code generation.
 unsigned long lang_to_generate;
 
- // If set (default behavior), empty string and vector fields will be set to
- // nullptr to make the flatbuffer more compact.
- bool set_empty_to_null;
+ // If set (default behavior), empty string fields will be set to nullptr to make
+ // the flatbuffer more compact.
+ bool set_empty_strings_to_null;
+
+ // If set (default behavior), empty vector fields will be set to nullptr to make
+ // the flatbuffer more compact.
+ bool set_empty_vectors_to_null;
 
 IDLOptions()
 : use_flexbuffers(false),
 struct IDLOptions {
 lang(IDLOptions::kJava),
 mini_reflect(IDLOptions::kNone),
 lang_to_generate(0),
- set_empty_to_null(true) {}
+ set_empty_strings_to_null(true),
+ set_empty_vectors_to_null(true) {}
 };
 
 // This encapsulates where the parser is in the current source file.
",716,86
Supress unsigned-integer-overflow for PaddingBytes (#5647)," template<typename T> __supress_ubsan__(""alignment"") void WriteScalar(void *p, Of
 // Computes how many bytes you'd have to pad to be able to write an
 // ""scalar_size"" scalar if the buffer had grown to ""buf_size"" (downwards in
 // memory).
+__supress_ubsan__(""unsigned-integer-overflow"")
 inline size_t PaddingBytes(size_t buf_size, size_t scalar_size) {
 return ((~buf_size) + 1) & (scalar_size - 1);
 }
",88,16
"[gRPC] Uncomment MessageBuilder (#5658)

The line where the MessageBuilder was
constructed was commented out (perhaps
an oversight)."," class GreeterServiceImpl final : public Greeter::Service {
 grpc::ServerContext *context,
 const flatbuffers::grpc::Message<HelloRequest> *request_msg,
 flatbuffers::grpc::Message<HelloReply> *response_msg) override {
- // flatbuffers::grpc::MessageBuilder mb_;
+ flatbuffers::grpc::MessageBuilder mb_;
+
 // We call GetRoot to ""parse"" the message. Verification is already
 // performed by default. See the notes below for more details.
 const HelloRequest *request = request_msg->GetRoot();
",53,5
wrap multiple statements in do {} while(!IsConstTrue(true)) (#5655),"
 #define FLATBUFFERS_NO_FILE_TESTS
 #else
 #define TEST_OUTPUT_LINE(...) \
- { printf(__VA_ARGS__); printf(""\n""); }
+ do { printf(__VA_ARGS__); printf(""\n""); } while(!IsConstTrue(true))
 #endif
 
 #define TEST_EQ(exp, val) TestEq(exp, val, ""'"" #exp ""' != '"" #val ""'"", __FILE__, __LINE__, """")
",44,5
Add namespace qualification to union types (#5666)," class CppGenerator : public BaseGenerator {
 }
 }
 case BASE_TYPE_UNION: {
- return type.enum_def->name + ""Union"";
+ auto type_name = WrapInNameSpace(*type.enum_def);
+ return type_name + ""Union"";
 }
 default: {
 return GenTypeBasic(type, true);
 class CppGenerator : public BaseGenerator {
 std::string GenUnionUnpackVal(const FieldDef &afield,
 const char *vec_elem_access,
 const char *vec_type_access) {
- return afield.value.type.enum_def->name + ""Union::UnPack("" + ""_e"" +
+ auto type_name = WrapInNameSpace(*afield.value.type.enum_def);
+ return type_name + ""Union::UnPack("" + ""_e"" +
 vec_elem_access + "", "" +
 EscapeKeyword(afield.name + UnionTypeFieldSuffix()) + ""()"" +
 vec_type_access + "", _resolver)"";
",2517,535
"Added Check to VerifyAlignment (#5675)

* Added missing EndTable() call to VerifyObject()

VerifyObject called VerifyTableStart() but not EndTable(). This made Verifier::VerifyComplexity() increase depth_ with each table, not with the depth of tables.

https://groups.google.com/forum/#!topic/flatbuffers/OpxtW5UFAdg

* Added Check to VerifyAlignment

https://stackoverflow.com/questions/59376308/flatbuffers-verifier-returns-false-without-any-assertion-flatbuffers-debug-veri"," class Verifier FLATBUFFERS_FINAL_CLASS {
 }
 
 template<typename T> bool VerifyAlignment(size_t elem) const {
- return (elem & (sizeof(T) - 1)) == 0 || !check_alignment_;
+ return Check((elem & (sizeof(T) - 1)) == 0 || !check_alignment_);
 }
 
 // Verify a range indicated by sizeof(T).
",1565,428
"Removed test proto output.

Change-Id: Iaf64bec068d03dd1b75670e9a28dde7392ebddb5"," void ParseProtoTestWithIncludes() {
 flatbuffers::Parser parser2;
 TEST_EQ(parser2.Parse(import_fbs.c_str(), include_directories, ""imported.fbs""), true);
 TEST_EQ(parser2.Parse(fbs.c_str(), nullptr), true);
- //printf(""Golden\n%s\n"", goldenfile.c_str());
- printf(""FBS\n%s\n"", fbs.c_str());
 TEST_EQ_STR(fbs.c_str(), goldenfile.c_str());
 
 // Parse proto with --oneof-union option.
",2484,193
"Fixed warnings in FlexBuffers.java

- Missing return statement <- bug!
- Missing hashCode function.

Change-Id: I6333cac72adf8ead92ab2e6c7215650ce4571a73"," public class FlexBuffers {
 public boolean isNull() {
 return type == FBT_NULL;
 }
- 
+
 /**
 * Checks whether the element is boolean type
 * @return true if boolean type
 public class FlexBuffers {
 case FBT_NULL: return 0;
 case FBT_STRING: return Long.parseLong(asString());
 case FBT_VECTOR: return asVector().size();
- case FBT_BOOL: readInt(bb, end, parentWidth);
+ case FBT_BOOL: return readInt(bb, end, parentWidth);
 default:
 // Convert other things to uint.
 return 0;
 public class FlexBuffers {
 
 return ((Key) obj).end == end && ((Key) obj).byteWidth == byteWidth;
 }
+
+ public int hashCode() {
+ return end ^ byteWidth;
+ }
 }
 
 /**
",620,213
"Fixed struct initialization error on older versions of C#

""'this' object cannot be used before all of its fields are assigned to""

Change-Id: Icccdcc0d0be0fe0b87abe0eb28fe1cc91116fcfb"," namespace FlatBuffers
 public ByteBuffer bb { get; private set; }
 
 // Re-init the internal state with an external buffer {@code ByteBuffer} and an offset within.
- public Struct(int _i, ByteBuffer _bb)
+ public Struct(int _i, ByteBuffer _bb) : this()
 {
 bb = _bb;
 bb_pos = _i;
",13,1
"CI: New Docker tests for Python with numpy (#5677)

* New Docker tests for Python with numpy

* print numpy status in test suite"," def main():
 
 kwargs = dict(argv=sys.argv[:-3])
 
+ # show whether numpy is present, as it changes the test logic:
+ try:
+ import numpy
+ print('numpy available')
+ except ImportError:
+ print('numpy not available')
+
 # run tests, and run some language comparison checks if needed:
 success = backward_compatible_run_tests(**kwargs)
 if success and os.environ.get('COMPARE_GENERATED_TO_GO', 0) == ""1"":
",1883,227
"Add support for absl::string_view when available (#5682)

For C++11 platforms, absl::string_view is sometimes available. This can
be used for string_view when std::string_view is not available."," namespace flatbuffers {
 typedef std::experimental::string_view string_view;
 }
 #define FLATBUFFERS_HAS_STRING_VIEW 1
+ // Check for absl::string_view
+ #elif __has_include(""absl/strings/string_view.h"")
+ #include ""absl/strings/string_view.h""
+ namespace flatbuffers {
+ typedef absl::string_view string_view;
+ }
+ #define FLATBUFFERS_HAS_STRING_VIEW 1
 #endif
 #endif // __has_include
 #endif // !FLATBUFFERS_HAS_STRING_VIEW
",92,16
"[C++] Add Builder and Table typedefs (#5685)

* Add Builder and Table typedefs

This gives us a way to use templates to go from a builder to a table
and back again without having to pass both types in.

* Fix tests/cpp17/generated_cpp17/monster_test_generated.h"," struct NestedStruct;
 struct ArrayStruct;
 
 struct ArrayTable;
+struct ArrayTableBuilder;
 struct ArrayTableT;
 
 bool operator==(const NestedStruct &lhs, const NestedStruct &rhs);
 inline bool operator!=(const ArrayTableT &lhs, const ArrayTableT &rhs) {
 
 struct ArrayTable FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
 typedef ArrayTableT NativeTableType;
+ typedef ArrayTableBuilder Builder;
 static const flatbuffers::TypeTable *MiniReflectTypeTable() {
 return ArrayTableTypeTable();
 }
 struct ArrayTable FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
 };
 
 struct ArrayTableBuilder {
+ typedef ArrayTable Table;
 flatbuffers::FlatBufferBuilder &fbb_;
 flatbuffers::uoffset_t start_;
 void add_a(const MyGame::Example::ArrayStruct *a) {
",400,77
"Correct inverted logic around include prefixes. (#5689)

4d1a9f8d9eab9fc6762e03cd862576965a0c6920 inverted the logic around
keeping the include prefix. This change fixes the error."," std::string GenerateFBS(const Parser &parser, const std::string &file_name) {
 continue;
 std::string basename;
 if(parser.opts.keep_include_path) {
+ basename = flatbuffers::StripExtension(it->second);
+ } else {
 basename = flatbuffers::StripPath(
 flatbuffers::StripExtension(it->second));
- } else {
- basename = flatbuffers::StripExtension(it->second);
 }
 schema += ""include \"""" + basename + "".fbs\"";\n"";
 num_includes++;
",111,31
"Rust: Temporarily disable 2 endianness unit tests (#5695)

Rare failures occur on AppVeyor in these functions; the failures appear
spurious."," mod roundtrip_byteswap {
 assert_eq!(x, back_again);
 }
 
- #[test]
- fn fuzz_f32() { quickcheck::QuickCheck::new().max_tests(N).quickcheck(prop_f32 as fn(f32)); }
- #[test]
- fn fuzz_f64() { quickcheck::QuickCheck::new().max_tests(N).quickcheck(prop_f64 as fn(f64)); }
+ // TODO(rw): Replace the implementations with the new stdlib endian-conversion functions.
+ // TODO(rw): Re-enable these tests (currently, rare CI failures occur that seem spurious).
+ // #[test]
+ // fn fuzz_f32() { quickcheck::QuickCheck::new().max_tests(N).quickcheck(prop_f32 as fn(f32)); }
+ // #[test]
+ // fn fuzz_f64() { quickcheck::QuickCheck::new().max_tests(N).quickcheck(prop_f64 as fn(f64)); }
 }
 
 #[cfg(test)]
",2491,137
"[Java] Replace Table.UTF8_CHARSET with StandardCharsets.UTF_8 (#5696)

StandardCharsets.UTF_8 is already used in FlexBuffersBuilder."," package com.google.flatbuffers;
 import static com.google.flatbuffers.Constants.*;
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
-import java.nio.charset.Charset;
 
 /// @cond FLATBUFFERS_INTERNAL
 
 import java.nio.charset.Charset;
 * All tables in the generated code derive from this class, and add their own accessors.
 */
 public class Table {
- public final static ThreadLocal<Charset> UTF8_CHARSET = new ThreadLocal<Charset>() {
- @Override
- protected Charset initialValue() {
- return Charset.forName(""UTF-8"");
- }
- };
 /** Used to hold the position of the `bb` buffer. */
 protected int bb_pos;
 /** The underlying ByteBuffer to hold the data of the Table. */
",128,33
"(Optionally) add an additional suffix namespace to generated fbs files. (#5698)

This change allows for the generation of fbs files (from proto) that
don't contain name collisions with the protobuf generated C++ code,
allowing both the proto and fbs message types to be linked into the same binary."," struct IDLOptions {
 bool java_primitive_has_method;
 std::vector<std::string> cpp_includes;
 std::string cpp_std;
+ std::string proto_namespace_suffix;
 
 // Possible options for the more general generator below.
 enum Language {
",718,86
"Changed direct calls to strtod to use StringToNumber

StringToNumber will correctly use locale-insensitive functions
when available.

Change-Id: I6bde11039a541634186f8f791012af2eb0d86b8d"," class Reference {
 case FBT_INDIRECT_UINT:
 return static_cast<double>(ReadUInt64(Indirect(), byte_width_));
 case FBT_NULL: return 0.0;
- case FBT_STRING: return strtod(AsString().c_str(), nullptr);
+ case FBT_STRING: {
+ double d;
+ flatbuffers::StringToNumber(AsString().c_str(), &d);
+ return d;
+ }
 case FBT_VECTOR: return static_cast<double>(AsVector().size());
 case FBT_BOOL:
 return static_cast<double>(ReadUInt64(data_, parent_width_));
",1214,396
"Added create function for swift (#5707)

Fixed the create functions and updated the test cases in swift

Removes unneeded code

Updated documentation"," final class FlatBuffersUnionTests: XCTestCase {
 ]
 let types = fb.createVector(characterType)
 let characterVector = fb.createVector(ofOffsets: characters)
- 
- let movieStart = Movie.startMovie(fb)
- Movie.addVectorOf(charactersType: types, fb)
- Movie.addVectorOf(characters: characterVector, fb)
- let end = Movie.endMovie(fb, start: movieStart)
+ let end = Movie.createMovie(fb, vectorOfCharactersType: types, vectorOfCharacters: characterVector)
 Movie.finish(fb, end: end)
 
 let movie = Movie.getRootAsMovie(bb: fb.buffer)
",186,35
"[Swift] Support create long string (#5709)

* [Swift] Support create long string

* [Swift] Move the test case to correct dir"," final class FlatBuffersTests: XCTestCase {
 b.clear()
 XCTAssertEqual(b.create(string: helloWorld).o, 20)
 XCTAssertEqual(b.create(string: country).o, 32)
+ b.clear()
+ XCTAssertEqual(b.create(string: String(repeating: ""a"", count: 257)).o, 264)
 }
 
 func testStartTable() {
",98,17
"[C++] Fix for printing of enum in case output_enum_identifiers=1. (#5706)

* Add test-case for testing of the future Color in json (output_enum_identifiers = true)

* Refactoring of idl_gen_text.cpp. Fix for printing of bit-enum with active output_enum_identifiers=1.

* Move GenerateText implementation into class

* Remove unnecessary code from flatbuffers.h"," template<typename T, uint16_t length> class Array {
 
 return_type operator[](uoffset_t i) const { return Get(i); }
 
+ // If this is a Vector of enums, T will be its storage type, not the enum
+ // type. This function makes it convenient to retrieve value with enum
+ // type E.
+ template<typename E> E GetEnum(uoffset_t i) const {
+ return static_cast<E>(Get(i));
+ }
+
 const_iterator begin() const { return const_iterator(Data(), 0); }
 const_iterator end() const { return const_iterator(Data(), size()); }
 
 template<typename T, uint16_t length> class Array<Offset<T>, length> {
 static_assert(flatbuffers::is_same<T, void>::value, ""unexpected type T"");
 
 public:
+ typedef const void* return_type;
+
 const uint8_t *Data() const { return data_; }
 
 // Make idl_gen_text.cpp::PrintContainer happy.
- const void *operator[](uoffset_t) const {
+ return_type operator[](uoffset_t) const {
 FLATBUFFERS_ASSERT(false);
 return nullptr;
 }
",1583,432
"[Go] Replace references to hardcoded Monster"" etc with idiomatic go wherever possible (#5716)

* go: replace objAPI-generated Pack func with method

See discussion at https://github.com/google/flatbuffers/issues/5668

* go: replace generated union type UnPack func with method

Similar to discussion https://github.com/google/flatbuffers/issues/5668

But signature:
```
func AnyUnPack(t Any, table flatbuffers.Table) *AnyT
```

Becomes,
```
func (rcv Any) UnPack(table flatbuffers.Table) *AnyT
```"," type AbilityT struct {
 Distance uint32
 }
 
-func AbilityPack(builder *flatbuffers.Builder, t *AbilityT) flatbuffers.UOffsetT {
+func (t *AbilityT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
 if t == nil { return 0 }
 return CreateAbility(builder, t.Id, t.Distance)
 }
",50,12
"[typescript] Size-prefixed root accessors not taking into account size prefix (#5717)

* [typescript/javascript] Size-prefixed root accessor needs to account for the size prefix.

* [typescript] Add parentheses after ""new"" expression.

* Update generated test files"," NamespaceA.NamespaceB.TableInNestedNS.getRootAsTableInNestedNS = function(bb, ob
 * @returns {NamespaceA.NamespaceB.TableInNestedNS}
 */
 NamespaceA.NamespaceB.TableInNestedNS.getSizePrefixedRootAsTableInNestedNS = function(bb, obj) {
+ bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
 return (obj || new NamespaceA.NamespaceB.TableInNestedNS).__init(bb.readInt32(bb.position()) + bb.position(), bb);
 };
 
",93,23
"[Dart] Fix deprecated field support, inf/nan (#5724)

* Fix deprecated field support, inf/nan

* unused params

* rerun tests"," public struct MonsterExtra : IFlatbufferObject
 float f3 = Single.NegativeInfinity,
 VectorOffset dvecOffset = default(VectorOffset),
 VectorOffset fvecOffset = default(VectorOffset)) {
- builder.StartTable(10);
+ builder.StartTable(11);
 MonsterExtra.AddD3(builder, d3);
 MonsterExtra.AddD2(builder, d2);
 MonsterExtra.AddD1(builder, d1);
 public struct MonsterExtra : IFlatbufferObject
 return MonsterExtra.EndMonsterExtra(builder);
 }
 
- public static void StartMonsterExtra(FlatBufferBuilder builder) { builder.StartTable(10); }
+ public static void StartMonsterExtra(FlatBufferBuilder builder) { builder.StartTable(11); }
 public static void AddD0(FlatBufferBuilder builder, double d0) { builder.AddDouble(0, d0, Double.NaN); }
 public static void AddD1(FlatBufferBuilder builder, double d1) { builder.AddDouble(1, d1, Double.NaN); }
 public static void AddD2(FlatBufferBuilder builder, double d2) { builder.AddDouble(2, d2, Double.PositiveInfinity); }
",91,59
"[Swift] Fix padding function overflow when bufSize is 0 (#5721)

* [Swift] Fix padding function overflow when bufSize is 0

[Swift] Generate linuxmain

* [Swift] Using the overflow addition operator to resolve integer overflow"," extension FlatBufferBuilder {
 /// - bufSize: Current size of the buffer + the offset of the object to be written
 /// - elementSize: Element size
 fileprivate func padding(bufSize: UInt32, elementSize: UInt32) -> UInt32 {
- ((~bufSize) + 1) & (elementSize - 1)
+ ((~bufSize) &+ 1) & (elementSize - 1)
 }
 
 /// Prealigns the buffer before writting a new object into the buffer
",281,63
"[Go] Implements a SharedStrings function (#5733)

* Adds the sharedstring implementation for go

* Reimplemented testcase according to request"," type Builder struct {
 head UOffsetT
 nested bool
 finished bool
+
+sharedStrings map[string]UOffsetT
 }
 
 const fileIdentifierLength = 4
 func NewBuilder(initialSize int) *Builder {
 b.head = UOffsetT(initialSize)
 b.minalign = 1
 b.vtables = make([]UOffsetT, 0, 16) // sensible default capacity
-
 return b
 }
 
 func (b *Builder) EndVector(vectorNumElems int) UOffsetT {
 return b.Offset()
 }
 
+// CreateSharedString Checks if the string is already written
+// to the buffer before calling CreateString
+func (b *Builder) CreateSharedString(s string) UOffsetT {
+if b.sharedStrings == nil {
+b.sharedStrings = make(map[string]UOffsetT)
+}
+if v, ok := b.sharedStrings[s]; ok {
+return v
+}
+off := b.CreateString(s)
+b.sharedStrings[s] = off
+return off
+}
+
 // CreateString writes a null-terminated string as a vector.
 func (b *Builder) CreateString(s string) UOffsetT {
 b.assertNotNested()
",471,119
Creates a flatbuffers validation function + small fix (#5725)," extension UInt32: Scalar {
 extension UInt64: Scalar {
 public typealias NumericValue = UInt64
 }
+
+public func FlatBuffersVersion_1_11_1() {}
",64,1
"Use VS 2017 and 2019 on CI, fix cast issue in dart_idl (#5740)

* vs2019

* another attempt

* syntax

* fewer

* fix dart"," class DartGenerator : public BaseGenerator {
 it != struct_def.fields.vec.end(); ++it) {
 auto &field = **it;
 if (field.deprecated) continue;
- auto offset = it - struct_def.fields.vec.begin();
+ auto offset = static_cast<int>(it - struct_def.fields.vec.begin());
 non_deprecated_fields.push_back(std::make_pair(offset, &field));
 }
 
",793,189
"Adds min and max, comments, and all of swift's keywords + fix docs (#5737)"," public final class ByteBuffer {
 public func duplicate(removing removeBytes: Int = 0) -> ByteBuffer {
 return ByteBuffer(memory: _memory, count: _capacity, removing: _writerSize - removeBytes)
 }
+}
+
+extension ByteBuffer: CustomDebugStringConvertible {
 
- #if DEBUG
- func debugMemory(str: String) {
- let bufprt = UnsafeBufferPointer(start: _memory.assumingMemoryBound(to: UInt8.self),
- count: _capacity)
- let a = Array(bufprt)
- print(str, a, "" \nwith buffer size: \(a.count) and writer size: \(_writerSize)"")
+ public var debugDescription: String {
+ """"""
+ buffer located at: \(_memory), with capacity of \(_capacity)
+ { writerSize: \(_writerSize), readerSize: \(reader), writerIndex: \(writerIndex) }
+ """"""
 }
- #endif
 }
",144,26
"FlexBuffers: C++: scalar-only typed vectors were not aligned.

This means data written with older versions of this code has
potentially misaligned data, which we'll need to support.
This isn't a problem on most architectures, but could be on
older ARM chips. To support them properly may require swapping
out uses of `flatbuffers::ReadScalar` with a version that does a
memcpy internally.

Change-Id: Ib352aab4a586f3a8c6602fb25488dcfff61e06e0"," class Builder FLATBUFFERS_FINAL_CLASS {
 // TODO: instead of asserting, could write vector with larger elements
 // instead, though that would be wasteful.
 FLATBUFFERS_ASSERT(WidthU(len) <= bit_width);
+ Align(bit_width);
 if (!fixed) Write<uint64_t>(len, byte_width);
 auto vloc = buf_.size();
 for (size_t i = 0; i < len; i++) Write(elems[i], byte_width);
",1215,396
[Python] Fixed issue #5499 (#5764)," def CheckReadBuffer(buf, offset, sizePrefix=False, file_identifier=None):
 # test prior to removal of size_prefix
 asserter(util.GetBufferIdentifier(buf, offset, size_prefixed=sizePrefix) == file_identifier)
 asserter(util.BufferHasIdentifier(buf, offset, file_identifier=file_identifier, size_prefixed=sizePrefix))
+ asserter(MyGame.Example.Monster.Monster.MonsterBufferHasIdentifier(buf, offset, size_prefixed=sizePrefix))
 if sizePrefix:
 size = util.GetSizePrefix(buf, offset)
 asserter(size == len(buf[offset:])-4)
",1884,227
"Fix memory leak on cpp object api (#5761)

Previously UnPack would allocate data with new and assign it to a
raw pointer. This behavior makes it possible for the pointer to be
leaked in case of OOM. This commit defaults to use the user specified
pointer (which needs to implement a move constructor, a .get() and a
 .release() operators), thus preventing these leaks."," class CppGenerator : public BaseGenerator {
 code_.SetValue(""STRUCT_NAME"", Name(struct_def));
 code_.SetValue(""NATIVE_NAME"",
 NativeName(Name(struct_def), &struct_def, opts_));
+ auto native_name =
+ NativeName(WrapInNameSpace(struct_def), &struct_def, parser_.opts);
+ code_.SetValue(""POINTER_TYPE"",
+ GenTypeNativePtr(native_name, nullptr, false));
 
 if (opts_.generate_object_based_api) {
 // Generate the X::UnPack() method.
 code_ +=
 ""inline "" + TableUnPackSignature(struct_def, false, opts_) + "" {"";
- code_ += "" auto _o = new {{NATIVE_NAME}}();"";
- code_ += "" UnPackTo(_o, _resolver);"";
- code_ += "" return _o;"";
+
+ code_ +=
+ "" {{POINTER_TYPE}} _o = {{POINTER_TYPE}}(new {{NATIVE_NAME}}());"";
+ code_ += "" UnPackTo(_o.get(), _resolver);"";
+ code_ += "" return _o.release();"";
+
 code_ += ""}"";
 code_ += """";
 
",2613,555
[Python] Fixed potential allignment issue (#5768)," class Builder(object):
 N.enforce_number(rootTable, N.UOffsetTFlags)
 
 if file_identifier is not None:
- self.Prep(N.UOffsetTFlags.bytewidth, N.Uint8Flags.bytewidth*4)
+ self.Prep(N.UOffsetTFlags.bytewidth, encode.FILE_IDENTIFIER_LENGTH)
 
 # Convert bytes object file_identifier to an array of 4 8-bit integers,
 # and use big-endian to enforce size compliance.
 class Builder(object):
 file_identifier = N.struct.unpack("">BBBB"", file_identifier)
 for i in range(encode.FILE_IDENTIFIER_LENGTH-1, -1, -1):
 # Place the bytes of the file_identifer in reverse order:
- self.Place(file_identifier[i], N.Uint8Flags) 
+ self.Place(file_identifier[i], N.Uint8Flags)
 
 self.PrependUOffsetTRelative(rootTable)
 if sizePrefix:
",364,89
"[Java][FlexBuffers] Abstract buffer access from ByteBuffer (#5743)

To read and build flexbuffers on Java, one needs to wrap the data
using ByteBuffer. But for the common case of having ByteBuffers
backed by arrays, accessing from a ByteBuffer might be inefficient.

So this change introduces two interfaces: ReadBuf and ReadWriteBuf.
It allows one to read and writes data directly on an array. It also allow
 other buffer implementations to be used with flexbuffers.

Another change is that FlexBuffersBuilder backed by array allows
the buffer to grow with the increase of the message size. Something
that could not be done with ByteBuffer."," final public class Utf8Safe extends Utf8 {
 return utf8Length;
 }
 
- private static String decodeUtf8Array(byte[] bytes, int index, int size) {
+ public static String decodeUtf8Array(byte[] bytes, int index, int size) {
 // Bitwise OR combines the sign bits so any negative value fails the check.
 if ((index | size | bytes.length - index - size) < 0) {
 throw new ArrayIndexOutOfBoundsException(
 final public class Utf8Safe extends Utf8 {
 return new String(resultArr, 0, resultPos);
 }
 
- private static String decodeUtf8Buffer(ByteBuffer buffer, int offset,
+ public static String decodeUtf8Buffer(ByteBuffer buffer, int offset,
 int length) {
 // Bitwise OR combines the sign bits so any negative value fails the check.
 if ((offset | length | buffer.limit() - offset - length) < 0) {
",291,76
"Added --filename-suffix and --filename-ext to flatc (#5778)

* Fixed refractoring issue in reflection/generate_code.sh. Also, mv deletes the original file, so I don't need to clean it up manually in that case.

* Added --filename-suffix and --filename-ext to flatc

* Fixed typo and added example generation of suffix and extension for C++

* Removed extra ;

* Removed clang-format block from a region that didn't need it. Fixed an auto format of another clang-format block

* Added docs, fixed pointer alignment, removed suffix test file"," class BaseGenerator {
 static std::string NamespaceDir(const Parser &parser, const std::string &path,
 const Namespace &ns);
 
+ std::string GeneratedFileName(const std::string &path,
+ const std::string &file_name,
+ const IDLOptions &options) const;
+
 protected:
 BaseGenerator(const Parser &parser, const std::string &path,
 const std::string &file_name, std::string qualifying_start,
- std::string qualifying_separator)
+ std::string qualifying_separator, std::string default_extension)
 : parser_(parser),
 path_(path),
 file_name_(file_name),
 qualifying_start_(qualifying_start),
- qualifying_separator_(qualifying_separator) {}
+ qualifying_separator_(qualifying_separator),
+ default_extension_(default_extension) {}
 virtual ~BaseGenerator() {}
 
 // No copy/assign.
 class BaseGenerator {
 const std::string &file_name_;
 const std::string qualifying_start_;
 const std::string qualifying_separator_;
+ const std::string default_extension_;
 };
 
 struct CommentConfig {
",132,13
"[C#] add ObjectAPI Serialization Utility (#5785)

* [C#] add ObjectAPI Serialization Utility

* set InitialBufferSize to 64k

* rename SerializeToFlatBuffers to SerializeToBinary"," class CSharpGenerator : public BaseGenerator {
 ""Newtonsoft.Json.Formatting.Indented);\n"";
 code += "" }\n"";
 }
+ if (parser_.root_struct_def_ == &struct_def) {
+ code += "" public static "" + class_name +
+ "" DeserializeFromBinary(byte[] fbBuffer) {\n"";
+ code += "" return "" + struct_def.name + "".GetRootAs"" + struct_def.name +
+ ""(new ByteBuffer(fbBuffer)).UnPack();\n"";
+ code += "" }\n"";
+ code += "" public byte[] SerializeToBinary() {\n"";
+ code += "" var fbb = new FlatBufferBuilder(0x10000);\n"";
+ code +=
+ "" fbb.Finish("" + struct_def.name + "".Pack(fbb, this).Value);\n"";
+ code += "" return fbb.DataBuffer.ToSizedArray();\n"";
+ code += "" }\n"";
+ }
 code += ""}\n\n"";
 }
 
",1810,365
"Removed assert that wasn't backwards compatible.

Change-Id: I8e74d6fddf91fe955fffc572af9d671160325731"," switch (type) {
 }
 */
 
-// If not all FLATBUFFERS_GEN_() arguments are necessary for implementation 
+// If not all FLATBUFFERS_GEN_() arguments are necessary for implementation
 // of FLATBUFFERS_TD, you can use a variadic macro (with __VA_ARGS__ if needed).
 // In the above example, only CTYPE is used to generate the code, it can be rewritten:
 
 struct EnumDef : public Definition {
 size_t size() const { return vals.vec.size(); }
 
 const std::vector<EnumVal *> &Vals() const {
- FLATBUFFERS_ASSERT(false == vals.vec.empty());
 return vals.vec;
 }
 
",729,86
"[Rust] Add gen-name-strings for Rust (#5757)

* Add gen-name-strings for Rust

* Clang format

* Add tests and generate with gen-name-strings

* Clang-format

* Stop doing gen-name-strings with C++ code

* Bring generate_code.bat up with generate_code.sh"," std::string FlatCompiler::GetUsageString(const char *program_name) const {
 "" schemas the generated file depends on (C++ / Python).\n""
 "" --gen-mutable Generate accessors that can mutate buffers in-place.\n""
 "" --gen-onefile Generate single output file for C# and Go.\n""
- "" --gen-name-strings Generate type name functions for C++.\n""
+ "" --gen-name-strings Generate type name functions for C++ and Rust.\n""
 "" --gen-object-api Generate an additional object-based API.\n""
 "" --gen-compare Generate operator== for object-based API types.\n""
 "" --gen-nullable Add Clang _Nullable for C++ pointer. or @Nullable for Java\n""
",492,150
rust: pub export the VectorIter type (#5736)," impl<'a, T: Follow<'a> + 'a> Follow<'a> for Vector<'a, T> {
 }
 }
 
+/// An iterator over a `Vector`.
 #[derive(Debug)]
 pub struct VectorIter<'a, T: 'a> {
 buf: &'a [u8],
",223,6
"[C++] Generate code for vector force_align attribute. (#5796)

* [Flatbuffer] Generate code for force_align with CreateXDirect and Pack functions.

* Fixed Visual Studio 10.0 compile error for std::to_string.

* Fixed Visual Studio 10.0 compile error for std::to_string."," CheckedError Parser::ParseVector(const Type &type, uoffset_t *ovalue,
 });
 ECHECK(err);
 
- builder_.StartVector(count * InlineSize(type) / InlineAlignment(type),
- InlineAlignment(type));
+ const auto *force_align = field->attributes.Lookup(""force_align"");
+ const size_t align =
+ force_align ? static_cast<size_t>(atoi(force_align->constant.c_str()))
+ : 1;
+ const size_t len = count * InlineSize(type) / InlineAlignment(type);
+ const size_t elemsize = InlineAlignment(type);
+ if (align > 1) { builder_.ForceVectorAlignment(len, elemsize, align); }
+
+ builder_.StartVector(len, elemsize);
 for (uoffset_t i = 0; i < count; i++) {
 // start at the back, since we're building the data backwards.
 auto &val = field_stack_.back().first;
",3024,915
Replace 'assert' by 'FLATBUFFERS_ASSERT' inside idl_parser.cpp (#5799)," CheckedError Parser::ParseVector(const Type &type, uoffset_t *ovalue,
 break;
 }
 }
- assert(key);
+ FLATBUFFERS_ASSERT(key);
 // Now sort it.
 // We can't use std::sort because for structs the size is not known at
 // compile time, and for tables our iterators dereference offsets, so can't
 CheckedError Parser::ParseVector(const Type &type, uoffset_t *ovalue,
 // These are serialized offsets, so are relative where they are
 // stored in memory, so compute the distance between these pointers:
 ptrdiff_t diff = (b - a) * sizeof(Offset<Table>);
- assert(diff >= 0); // Guaranteed by SimpleQsort.
+ FLATBUFFERS_ASSERT(diff >= 0); // Guaranteed by SimpleQsort.
 auto udiff = static_cast<uoffset_t>(diff);
 a->o = EndianScalar(ReadScalar<uoffset_t>(a) - udiff);
 b->o = EndianScalar(ReadScalar<uoffset_t>(b) + udiff);
",3024,915
"Escape characters in jsonschema descriptions (#5644)

* Escape JSON Schema comments

* Add quotes to monster comment

Thus exercising the JSON Schema comment escape support."," class JsonSchemaGenerator : public BaseGenerator {
 comment.append(*comment_line);
 }
 if (comment.size() > 0) {
- code_ += "" \""description\"" : \"""" + comment + ""\"","";
+ std::string description;
+ if (!EscapeString(comment.c_str(), comment.length(), &description, true,
+ true)) {
+ return false;
+ }
+ code_ += "" \""description\"" : "" + description + "","";
 }
 code_ += "" \""properties\"" : {"";
 
",190,51
Removes the inner loop in the endtable check written tables (#5803)," public final class ByteBuffer {
 /// - size: Size of Value being written to the buffer
 func push(struct value: UnsafeMutableRawPointer, size: Int) {
 ensureSpace(size: UInt32(size))
- _memory.advanced(by: writerIndex - size).copyMemory(from: value, byteCount: size)
+ memcpy(_memory.advanced(by: writerIndex - size), value, size)
 defer { value.deallocate() }
 _writerSize += size
 }
",163,28
"pre-tag version bump for 1.12

Change-Id: I84a9365e9d8a1afe333b1df85058401ffe0a6b7c","
 #endif // !defined(FLATBUFFERS_LITTLEENDIAN)
 
 #define FLATBUFFERS_VERSION_MAJOR 1
-#define FLATBUFFERS_VERSION_MINOR 11
+#define FLATBUFFERS_VERSION_MINOR 12
 #define FLATBUFFERS_VERSION_REVISION 0
 #define FLATBUFFERS_STRING_EXPAND(X) #X
 #define FLATBUFFERS_STRING(X) FLATBUFFERS_STRING_EXPAND(X)
",92,16
"Fix interpretation of 'nan(number)' by the idl_parser (#5810)

* Parser reject ""nan(n)"" string as it does with nan(n)

* Adjust scalar fuzzer to ignore '$schema' substrings

- Scalar fuzzer ignores '$schema' substrings at the input
- Added 'scalar_debug' target to simplify research of fuzzed cases

* Improve formatting of './tests/fuzzer/CMakeLists.txt'"," class FlatBufferBuilder {
 return a.KeyCompareLessThan(&b);
 }
 
- private:
- StructKeyComparator &operator=(const StructKeyComparator &);
+ FLATBUFFERS_DELETE_FUNC(StructKeyComparator &operator=(const StructKeyComparator &))
 };
 /// @endcond
 
",1582,432
"[C++] Add max_depth and max_tables parameters to reflection::Verify (#5815)

* Added missing EndTable() call to VerifyObject()

VerifyObject called VerifyTableStart() but not EndTable(). This made Verifier::VerifyComplexity() increase depth_ with each table, not with the depth of tables.

https://groups.google.com/forum/#!topic/flatbuffers/OpxtW5UFAdg

* Added Check to VerifyAlignment

https://stackoverflow.com/questions/59376308/flatbuffers-verifier-returns-false-without-any-assertion-flatbuffers-debug-veri

* [C++] Add max_depth and max_tables parameters to reflection::Verify

Co-authored-by: Felkel <stefan@eas.local>
Co-authored-by: stefan301 <Stefan.Felkel@de.Zuken.com>"," Offset<const Table *> CopyTable(FlatBufferBuilder &fbb,
 // buf should point to the start of flatbuffer data.
 // length specifies the size of the flatbuffer data.
 bool Verify(const reflection::Schema &schema, const reflection::Object &root,
- const uint8_t *buf, size_t length);
+ const uint8_t *buf, size_t length,
+ uoffset_t max_depth = 64,
+ uoffset_t max_tables = 1000000);
 
 } // namespace flatbuffers
 
",290,67
"Correct calculation of vector element size (#5831)

Number of elements on the stack shouldn't affect the calculation
of ElemWidth(). Variable 'start' needs to be subtracted from the
loop variable 'i' to make indexing zero-based.

There is an additional unit test to pack nested vectors. Size of
the packed buffer *without* this fix is 798 and only 664 bytes
*with* the fix."," class Builder FLATBUFFERS_FINAL_CLASS {
 Type vector_type = FBT_KEY;
 // Check bit widths and types for all elements.
 for (size_t i = start; i < stack_.size(); i += step) {
- auto elem_width = stack_[i].ElemWidth(buf_.size(), i + prefix_elems);
+ auto elem_width =
+ stack_[i].ElemWidth(buf_.size(), i - start + prefix_elems);
 bit_width = (std::max)(bit_width, elem_width);
 if (typed) {
 if (i == start) {
",1215,396
Improves performance for the swift library by using structs + a storage class (#5835)," func createDocument(Benchmarks: [Benchmark]) -> String {
 }
 
 @inlinable func create10Strings() {
- let fb = FlatBufferBuilder(initialSize: 1<<20)
+ var fb = FlatBufferBuilder(initialSize: 1<<20)
 for _ in 0..<10_000 {
 _ = fb.create(string: ""foobarbaz"")
 }
 }
 
 @inlinable func create100Strings(str: String) {
- let fb = FlatBufferBuilder(initialSize: 1<<20)
+ var fb = FlatBufferBuilder(initialSize: 1<<20)
 for _ in 0..<10_000 {
 _ = fb.create(string: str)
 }
 }
 
 @inlinable func benchmarkFiveHundredAdds() {
- let fb = FlatBufferBuilder(initialSize: 1024 * 1024 * 32)
+ var fb = FlatBufferBuilder(initialSize: 1024 * 1024 * 32)
 for _ in 0..<500_000 {
 let off = fb.create(string: ""T"")
 let s = fb.startTable(with: 4)
",65,11
"[ts] Fix empty source/dest namespaces when reexporting. (#5841)

When either source or destination or both namespaces were empty, flatc
was generating incorrect TS code.

For example:

```
export namespace {
export import ObjectId = NS10770172024577249292..ObjectId;}
```

In this case the target namespace is empty, and so is the namespace
between the NSxxx placeholder and the target type."," class JsTsGenerator : public BaseGenerator {
 imported_files.emplace(file.first);
 }
 
- code += ""export namespace "" + file.second.target_namespace + "" { \n"";
+ if (!file.second.target_namespace.empty()) {
+ code += ""export namespace "" + file.second.target_namespace + "" { \n"";
+ }
 code += ""export import "" + file.second.symbol + "" = "";
- code += GenFileNamespacePrefix(file.first) + ""."" +
- file.second.source_namespace + ""."" + file.second.symbol +
- ""; }\n"";
+ code += GenFileNamespacePrefix(file.first) + ""."";
+ if (!file.second.source_namespace.empty()) {
+ code += file.second.source_namespace + ""."";
+ }
+ code += file.second.symbol + "";\n"";
+ if (!file.second.target_namespace.empty()) {
+ code += ""}\n"";
+ }
 }
 }
 }
",1197,283
"Upgraded swift implementation for grpc (#5843)

Updated version number"," void GenerateClientClass(const grpc_generator::Service *service,
 printer->Print(vars,
 ""$ACCESS$ final class $ServiceName$ServiceClient: GRPCClient, ""
 ""$ServiceName$Service {\n"");
- printer->Print(vars, ""\t$ACCESS$ let connection: ClientConnection\n"");
+ printer->Print(vars, ""\t$ACCESS$ let channel: GRPCChannel\n"");
 printer->Print(vars, ""\t$ACCESS$ var defaultCallOptions: CallOptions\n"");
 printer->Print(""\n"");
 printer->Print(vars,
- ""\t$ACCESS$ init(connection: ClientConnection, ""
+ ""\t$ACCESS$ init(channel: GRPCChannel, ""
 ""defaultCallOptions: CallOptions = CallOptions()) {\n"");
- printer->Print(""\t\tself.connection = connection\n"");
+ printer->Print(""\t\tself.channel = channel\n"");
 printer->Print(""\t\tself.defaultCallOptions = defaultCallOptions\n"");
 printer->Print(""\t}"");
 printer->Print(""\n"");
",261,28
"[Swift] Object API support (#5826)

* Adds Object-api support to swift

* Fixed indentation issues

* Removed indentation within namespaces"," class CodeWriter {
 void DecrementIdentLevel() {
 if (cur_ident_lvl_) cur_ident_lvl_--;
 }
+ 
+ void SetPadding(const std::string &padding) {
+ pad_ = padding;
+ }
 
 private:
 std::map<std::string, std::string> value_map_;
",135,14
"Not using reexports with --gen-all (#5873)

Co-authored-by: Kamil Rojewski <kamil.rojewski@gmail.com>"," int FlatCompiler::Compile(int argc, const char **argv) {
 } else if (arg == ""--gen-all"") {
 opts.generate_all = true;
 opts.include_dependence_headers = false;
+ opts.reexport_ts_modules = false;
 } else if (arg == ""--gen-includes"") {
 // Deprecated, remove this option some time in the future.
 Warn(""warning: --gen-includes is deprecated (it is now default)\n"");
",493,150
"[Rust] idl_gen_rust.cpp: (Option/required-aware codegen for unions) (#5850)

* idl_gen_rust.cpp: Fix google/flatbuffers#5849 (Option/required-aware
codegen for unions)

The generated code was assuming that an Option is always returned by the
union-getter method: however, this is only true if the field is not
marked as `(required)`.

* idl_gen_rust.cpp: flip conditional

* idl_gen_rust.cpp: Add comment, as requested in review

The code added is not covered by the integration test"," class RustGenerator : public BaseGenerator {
 code_ +=
 "" if self.{{FIELD_TYPE_FIELD_NAME}}_type() == ""
 ""{{U_ELEMENT_ENUM_TYPE}} {"";
- code_ +=
+
+ // The following logic is not tested in the integration test,
+ // as of April 10, 2020
+ if (field.required) {
+ code_ += "" let u = self.{{FIELD_NAME}}();"";
+ code_ += "" Some({{U_ELEMENT_TABLE_TYPE}}::init_from_table(u))"";
+ } else {
+ code_ +=
 "" self.{{FIELD_NAME}}().map(|u| ""
 ""{{U_ELEMENT_TABLE_TYPE}}::init_from_table(u))"";
+ }
 code_ += "" } else {"";
 code_ += "" None"";
 code_ += "" }"";
",1465,321
"Updates swift docs for package management (#5883)

Small fix for the clear function"," public struct FlatBufferBuilder {
 mutating public func clear() {
 _minAlignment = 0
 isNested = false
- _bb.clear()
 stringOffsetMap = [:]
+ _vtable = []
+ _vtables = []
+ _bb.clear()
 }
 
 /// Removes all the offsets from the VTable
",295,63
include/flatbuffers: typo fixes in comments (#5884)," class CodeWriter {
 }
 
 // Appends the given text to the generated code as well as a newline
- // character. Any text within {{ and }} delimeters is replaced by values
+ // character. Any text within {{ and }} delimiters is replaced by values
 // previously stored in the CodeWriter by calling SetValue above. The newline
 // will be suppressed if the text ends with the \\ character.
 void operator+=(std::string text);
",135,14
"Respect shared attribute in Parser (#5885)

Respects the 'shared' field attribute when reading data with Parser."," class Parser : public ParserState {
 const std::string &name, const Type &type,
 FieldDef **dest);
 FLATBUFFERS_CHECKED_ERROR ParseField(StructDef &struct_def);
- FLATBUFFERS_CHECKED_ERROR ParseString(Value &val);
+ FLATBUFFERS_CHECKED_ERROR ParseString(Value &val, bool use_string_pooling);
 FLATBUFFERS_CHECKED_ERROR ParseComma();
 FLATBUFFERS_CHECKED_ERROR ParseAnyValue(Value &val, FieldDef *field,
 size_t parent_fieldn,
",730,86
"only add native_include_files if object based api is enabled (#5886)

The native include files tag is intended to be used together with the object based api. A client which does not use the object based api should have no need to know about the additional include files needed for the object based api. The generated flatbuffers code without object api enabled should compile without the additional header files."," class CppGenerator : public BaseGenerator {
 
 void GenIncludeDependencies() {
 int num_includes = 0;
- for (auto it = parser_.native_included_files_.begin();
- it != parser_.native_included_files_.end(); ++it) {
- code_ += ""#include \"""" + *it + ""\"""";
- num_includes++;
+ if (opts_.generate_object_based_api) {
+ for (auto it = parser_.native_included_files_.begin();
+ it != parser_.native_included_files_.end(); ++it) {
+ code_ += ""#include \"""" + *it + ""\"""";
+ num_includes++;
+ }
 }
 for (auto it = parser_.included_files_.begin();
 it != parser_.included_files_.end(); ++it) {
",2628,562
[Java][FlexBuffers] Make FlexBuffersBuilder reusable by adding clear() (#5889) (#5890)," public class ArrayReadWriteBuf implements ReadWriteBuf {
 this.writePos = startPos;
 }
 
+ @Override
+ public void clear() {
+ this.writePos = 0;
+ }
+
 @Override
 public boolean getBoolean(int index) {
 return buffer[index] != 0;
",194,35
"[swift] Moves code to use VTablesStorage (#5888)

* Moves the code to use _vtablestorage

Rebuilt the test to confirm to the new API

Adds documentation + generates code for grpc

Reverts indentation

v0.4.0

Updated swift/readme.md

Updates VtableStorage to ensure space instead of reallocating each time

Fixes str count not being correct

* Fixes issue with boolean constant not being set + removes unused function"," public struct ByteBuffer {
 ensureSpace(size: padding)
 _writerSize += (MemoryLayout<UInt8>.size * Int(padding))
 }
-
+ 
 ///Adds an array of type Scalar to the buffer memory
 /// - Parameter elements: An array of Scalars
 @usableFromInline mutating func push<T: Scalar>(elements: [T]) {
 public struct ByteBuffer {
 /// Resizes the buffer size
 /// - Parameter size: new size for the buffer
 @usableFromInline mutating internal func resize(_ size: Int) {
+ assert((_writerSize - size) > 0)
+ var zero: UInt8 = 0
+ for i in 0..<(_writerSize - size) {
+ memcpy(_storage.memory.advanced(by: writerIndex + i), &zero, MemoryLayout<UInt8>.size)
+ }
 _writerSize = size
 }
 
",187,35
"[C#] Thread safe reads of Double and Float values from a ByteBuffer (#5900)

* Fixed refractoring issue in reflection/generate_code.sh. Also, mv deletes the original file, so I don't need to clean it up manually in that case.

* Thread safe reads of Double and Floats from ByteBuffer"," namespace FlatBuffers.Test
 var data = new dummyStruct[10];
 Assert.Throws<ArgumentException>(() => uut.Put(1024, data));
 }
+
+ [FlatBuffersTestMethod]
+ public void ByteBuffer_Get_Double()
+ {
+ var uut = new ByteBuffer(1024);
+ double value = 3.14159265;
+ uut.PutDouble(900, value);
+ double getValue = uut.GetDouble(900);
+ Assert.AreEqual(value, getValue);
+ }
+
+ [FlatBuffersTestMethod]
+ public void ByteBuffer_Get_Float()
+ {
+ var uut = new ByteBuffer(1024);
+ float value = 3.14159265F;
+ uut.PutFloat(900, value);
+ double getValue = uut.GetFloat(900);
+ Assert.AreEqual(value, getValue);
+ }
 }
 }
",480,48
"fixed invalid imports with --gen-all (#5895)

* fixed invalid imports with --gen-all

* only excluding crate imports

Co-authored-by: Kamil Rojewski <kamil.rojewski@gmail.com>"," class RustGenerator : public BaseGenerator {
 void GenNamespaceImports(const int white_spaces) {
 std::string indent = std::string(white_spaces, ' ');
 code_ += """";
- for (auto it = parser_.included_files_.begin();
- it != parser_.included_files_.end(); ++it) {
- if (it->second.empty()) continue;
- auto noext = flatbuffers::StripExtension(it->second);
- auto basename = flatbuffers::StripPath(noext);
+ if (!parser_.opts.generate_all) {
+ for (auto it = parser_.included_files_.begin();
+ it != parser_.included_files_.end(); ++it) {
+ if (it->second.empty()) continue;
+ auto noext = flatbuffers::StripExtension(it->second);
+ auto basename = flatbuffers::StripPath(noext);
 
- code_ += indent + ""use crate::"" + basename + ""_generated::*;"";
+ code_ += indent + ""use crate::"" + basename + ""_generated::*;"";
+ }
 }
+
 code_ += indent + ""use std::mem;"";
 code_ += indent + ""use std::cmp::Ordering;"";
 code_ += """";
",1467,322
"[TS] Make Obj-API work with --short-names (#5898)

* changed function used for getting struct name

* re-generated code"," constructor(
 * @returns flatbuffers.Offset
 */
 pack(builder:flatbuffers.Builder): flatbuffers.Offset {
- return TableInNestedNS.createTableInNestedNS(builder,
+ return NamespaceA.NamespaceB.TableInNestedNS.createTableInNestedNS(builder,
 this.foo
 );
 };
 constructor(
 * @returns flatbuffers.Offset
 */
 pack(builder:flatbuffers.Builder): flatbuffers.Offset {
- return StructInNestedNS.createStructInNestedNS(builder,
+ return NamespaceA.NamespaceB.StructInNestedNS.createStructInNestedNS(builder,
 this.a,
 this.b
 );
",131,2
"Schema parser: prohibit declaration of an array of pointers inside structs (#5907)

* Fix issue #5906, Prohibit declaration of an array of pointers inside structs

- idl_parser.cpp: Prohibit declaration of an array of pointers inside structs
- idl_gen_cpp.cpp: Extract GenStructConstructor() method from GenStruct() to simplify future modification
- idl_gen_cpp.cpp: Add assert for checking of Array fields in structs on code-generation stage

* Fix the error 'unused local variable' in release build

* Fix: format the PR code according to coding rules

* Add test-case and fix review notes"," CheckedError Parser::ParseField(StructDef &struct_def) {
 Type type;
 ECHECK(ParseType(type));
 
- if (struct_def.fixed && !IsScalar(type.base_type) && !IsStruct(type) &&
- !IsArray(type))
- return Error(""structs_ may contain only scalar or struct fields"");
+ if (struct_def.fixed) {
+ auto valid = IsScalar(type.base_type) || IsStruct(type);
+ if (!valid && IsArray(type)) {
+ const auto& elem_type = type.VectorType();
+ valid |= IsScalar(elem_type.base_type) || IsStruct(elem_type);
+ }
+ if (!valid)
+ return Error(""structs may contain only scalar or struct fields"");
+ }
 
 if (!struct_def.fixed && IsArray(type))
 return Error(""fixed-length array in table must be wrapped in struct"");
",3045,921
"[Dart] Getting tests/DartTest.sh to work on master. (#5915)

* Fixed refractoring issue in reflection/generate_code.sh. Also, mv deletes the original file, so I don't need to clean it up manually in that case.

* Fixed Dart Tests by removing code-gen for included files."," class CppGenerator : public BaseGenerator {
 *code_ptr += "" (void)padding"" + NumToString((*id)++) + ""__;"";
 }
 
- void GenStructConstructor(const StructDef& struct_def) {
+ void GenStructConstructor(const StructDef &struct_def) {
 std::string arg_list;
 std::string init_list;
 int padding_id = 0;
 class CppGenerator : public BaseGenerator {
 }
 const auto member_name = Name(field) + ""_"";
 const auto arg_name = ""_"" + Name(field);
- const auto arg_type =
- GenTypeGet(field_type, "" "", ""const "", "" &"", true);
+ const auto arg_type = GenTypeGet(field_type, "" "", ""const "", "" &"", true);
 
 if (it != first) { arg_list += "", ""; }
 arg_list += arg_type;
",2637,565
"[C#] Add file identifier to ObjectAPI Serialization Utility. (#5920)

* use Finish***Buffer instead.

* add file_identifier test."," class CSharpGenerator : public BaseGenerator {
 code += ""[idx"" + NumToString(j++) + ""]"";
 }
 code += "";"";
- for (size_t i = 0; i < array_only_lengths.size(); ++i) { code += ""}""; }
+ for (size_t i = 0; i < array_only_lengths.size(); ++i) {
+ code += ""}"";
+ }
 } else {
 code += ""_o"";
 for (size_t i = 0; i < array_lengths.size(); ++i) {
 class CSharpGenerator : public BaseGenerator {
 code += "" }\n"";
 code += "" public byte[] SerializeToBinary() {\n"";
 code += "" var fbb = new FlatBufferBuilder(0x10000);\n"";
- code +=
- "" fbb.Finish("" + struct_def.name + "".Pack(fbb, this).Value);\n"";
+ code += "" "" + struct_def.name + "".Finish"" + struct_def.name +
+ ""Buffer(fbb, "" + struct_def.name + "".Pack(fbb, this));\n"";
 code += "" return fbb.DataBuffer.ToSizedArray();\n"";
 code += "" }\n"";
 }
",1848,375
"General Codebase clean up (#5939)

* Fixed refractoring issue in reflection/generate_code.sh. Also, mv deletes the original file, so I don't need to clean it up manually in that case.

* Ensuring test/generate_code.sh was ran

* Fixed Dart Tests by removing code-gen for included files.

* General cleanup of codebase."," class CodeWriter {
 void DecrementIdentLevel() {
 if (cur_ident_lvl_) cur_ident_lvl_--;
 }
- 
- void SetPadding(const std::string &padding) {
- pad_ = padding;
- }
+
+ void SetPadding(const std::string &padding) { pad_ = padding; }
 
 private:
 std::map<std::string, std::string> value_map_;
",133,14
"Add static asserts to ensure that reflection API arrays are kept in sync (#5934)

* Add static asserts to ensure that reflection API arrays are kept in sync

* Move changes from generated file into source fbs file

* Rename enum value and regenerate reflection_generated.h

* Add comments to each entries of type sizes array"," inline bool IsLong(reflection::BaseType t) {
 // Size of a basic type, don't use with structs.
 inline size_t GetTypeSize(reflection::BaseType base_type) {
 // This needs to correspond to the BaseType enum.
- static size_t sizes[] = { 0, 1, 1, 1, 1, 2, 2, 4, 4, 8, 8, 4, 8, 4, 4, 4, 4 };
+ static size_t sizes[] = {
+ 0, // None
+ 1, // UType
+ 1, // Bool
+ 1, // Byte
+ 1, // UByte
+ 2, // Short
+ 2, // UShort
+ 4, // Int
+ 4, // UInt
+ 8, // Long
+ 8, // ULong
+ 4, // Float
+ 8, // Double
+ 4, // String
+ 4, // Vector
+ 4, // Obj
+ 4, // Union
+ 0, // Array. Only used in structs. 0 was chosen to prevent out-of-bounds errors.
+
+ 0 // MaxBaseType. This must be kept the last entry in this array.
+ };
+ static_assert(sizeof(sizes) / sizeof(size_t) == reflection::MaxBaseType + 1,
+ ""Size of sizes[] array does not match the count of BaseType enum values."");
 return sizes[base_type];
 }
 
",310,67
"fixed mutating inline values (#5942)

Co-authored-by: Kamil Rojewski <kamil.rojewski@gmail.com>"," NamespaceA.NamespaceB.StructInNestedNS.prototype.a = function() {
 * @returns {boolean}
 */
 NamespaceA.NamespaceB.StructInNestedNS.prototype.mutate_a = function(value) {
- var offset = this.bb.__offset(this.bb_pos, 0);
-
- if (offset === 0) {
- return false;
- }
-
- this.bb.writeInt32(this.bb_pos + offset, value);
+ this.bb.writeInt32(this.bb_pos + 0, value);
 return true;
 };
 
 NamespaceA.NamespaceB.StructInNestedNS.prototype.b = function() {
 * @returns {boolean}
 */
 NamespaceA.NamespaceB.StructInNestedNS.prototype.mutate_b = function(value) {
- var offset = this.bb.__offset(this.bb_pos, 4);
-
- if (offset === 0) {
- return false;
- }
-
- this.bb.writeInt32(this.bb_pos + offset, value);
+ this.bb.writeInt32(this.bb_pos + 4, value);
 return true;
 };
 
",85,21
Adds bool support in structs + updates grpc support + CI upgrades (#5943)," grpc::string GenerateServerExtensionBody(const grpc_generator::Method *method) {
 ""return ClientStreamingCallHandler(callHandlerContext: ""
 ""callHandlerContext) { context in""
 ""\n\t\t\t""
- ""return { request in""
- ""\n\t\t\t\t""
- ""self.$MethodName$(request: request, context: context)""
- ""\n\t\t\t}""
+ ""self.$MethodName$(context: context)""
 ""\n\t\t}"";
 }
 if (method->ServerStreaming()) {
 grpc::string GenerateServerExtensionBody(const grpc_generator::Method *method) {
 ""return BidirectionalStreamingCallHandler(callHandlerContext: ""
 ""callHandlerContext) { context in""
 ""\n\t\t\t""
- ""return { request in""
- ""\n\t\t\t\t""
- ""self.$MethodName$(request: request, context: context)""
- ""\n\t\t\t}""
+ ""self.$MethodName$(context: context)""
 ""\n\t\t}"";
 }
 return """";
",255,28
"[rust] Add FlatBufferBuilder::force_defaults API (#5946)

* [rust] Add force_defaults method FlatBufferBuilder

This works just like the same method already available in other
languages.

* Add binary format test for force_defaults"," mod byte_layouts {
 ]);
 }
 
+ #[test]
+ fn layout_09b_vtable_with_one_default_bool_force_defaults() {
+ let mut b = flatbuffers::FlatBufferBuilder::new();
+ check(&b, &[]);
+ let off = b.start_table();
+ check(&b, &[]);
+ b.force_defaults(true);
+ b.push_slot(fi2fo(0), false, false);
+ b.end_table(off);
+ check(&b, &[
+ 6, 0, // vtable bytes
+ 8, 0, // length of object including vtable offset
+ 7, 0, // start of bool value
+ 6, 0, 0, 0, // offset for start of vtable (int32)
+ 0, 0, 0, // padded to 4 bytes
+ 0, // bool value
+ ]);
+ }
+
 #[test]
 fn layout_10_vtable_with_one_int16() {
 let mut b = flatbuffers::FlatBufferBuilder::new();
",2539,137
fix error on GRPC Python - ignore namespace tree if not specified (#5862) (#5922)," bool GeneratePythonGRPC(const Parser &parser, const std::string & /*path*/,
 namespace_dir += *it;
 }
 
- std::string grpc_py_filename =
- namespace_dir + kPathSeparator + file_name + ""_grpc_fb.py"";
+ std::string grpc_py_filename = namespace_dir;
+ if (!namespace_dir.empty()) grpc_py_filename += kPathSeparator;
+ grpc_py_filename += file_name + ""_grpc_fb.py"";
+
 return flatbuffers::SaveFile(grpc_py_filename.c_str(), code, false);
 }
 
",342,96
Fix error in SimpleQSort (#5955)," void SimpleQsort(T *begin, T *end, size_t width, F comparator, S swapper) {
 r -= width;
 swapper(l, r);
 } else {
- l++;
+ l += width;
 }
 }
 l -= width;
",3042,921
"[Swift] Improving reallocation time by using memcpy and moving reallocation code to storage (#5960)

Removes stride

Use capacity - current size to initialize

Fixes memory leak

Updated test code for linux"," public struct FlatBufferBuilder {
 return _bb.size
 }
 
- 
 /// Endtable will let the builder know that the object that's written to it is completed
 ///
 /// This would be called after all the elements are serialized, it will add the vtable into the buffer.
 public struct FlatBufferBuilder {
 _bb.write(value: VOffset(tableObjectSize), index: _bb.writerIndex + sizeofVoffset, direct: true)
 _bb.write(value: VOffset(_max), index: _bb.writerIndex, direct: true)
 
- for index in stride(from: 0, to: _vtableStorage.writtenIndex, by: _vtableStorage.size) {
- let loaded = _vtableStorage.load(at: index)
+ var itr = 0
+ while itr < _vtableStorage.writtenIndex {
+ let loaded = _vtableStorage.load(at: itr)
+ itr += _vtableStorage.size
 guard loaded.offset != 0 else { continue }
 let _index = (_bb.writerIndex + Int(loaded.position))
 _bb.write(value: VOffset(vTableOffset - loaded.offset), index: _index, direct: true)
",326,65
Propagate boolean default values from proto to fbs (#5964)," CheckedError Parser::ParseProtoFields(StructDef *struct_def, bool isextend,
 auto val = attribute_;
 ECHECK(ParseProtoCurliesOrIdent());
 if (key == ""default"") {
- // Temp: skip non-numeric defaults (enums).
+ // Temp: skip non-numeric and non-boolean defaults (enums).
 auto numeric = strpbrk(val.c_str(), ""0123456789-+."");
- if (IsScalar(type.base_type) && numeric == val.c_str())
+ if (IsScalar(type.base_type) && numeric == val.c_str()) {
 field->value.constant = val;
+ } else if (val == ""true"") {
+ field->value.constant = val;
+ } // ""false"" is default, no need to handle explicitly.
 } else if (key == ""deprecated"") {
 field->deprecated = val == ""true"";
 }
",3045,922
"[idl_parser] Mark typefield as deprecated (#5958)

* Mark typefield as deprecated

* Add UnionDeprecation Test.

* Update to use evolution schema instead.

* Use --scoped-enums to compile."," CheckedError Parser::ParseField(StructDef &struct_def) {
 val->constant = NumToString(id - 1);
 typefield->attributes.Add(""id"", val);
 }
+ // if this field is a union that is deprecated,
+ // the automatically added type field should be deprecated as well
+ if (field->deprecated) {
+ typefield->deprecated = true;
+ }
 }
 
 EXPECT(';');
",3048,923
"Rust Flexbuffers Documentation update (#5979)

* Update samples and docs

* Fixed a line of documentation

Co-authored-by: Casper Neo <cneo@google.com>","
 //! See [Flexbuffer Internals](https://google.github.io/flatbuffers/flatbuffers_internals.html)
 //! for details on the binary format.
 //!
-//! * [See the examples for usage.](https://github.com/CasperN/flexbuffers/tree/master/examples)
+//! See the examples for usage:
+//! * [Example](https://github.com/google/flatbuffers/blob/master/samples/sample_flexbuffers.rs)
+//! * [Serde Example](https://github.com/google/flatbuffers/blob/master/samples/sample_flexbuffers_serde.rs)
 //!
 //! This rust implementation is in progress and, until the 1.0 release, breaking API changes may
-/// happen between minor versions.
+//! happen between minor versions.
 // TODO(cneo): serde stuff are behind a default-on feature flag
 // Reader to Json is behind a default-off feature flag
 // Serializable structs are Pushable
",55,2
"[Swift] Internal library improvements (#5965)

* Moves addition to overflow addition in swift by using &+

Moves code to use Int instead of UInt32 & fixes functions

Updates swift performance to great

Updated version to 0.5.2

Updated swift package version to 5.2

Updated docker to swift 5.2

Removed all none & arithmetic operations

* Small refactoring"," extension Scalar where Self: FixedWidthInteger {
 ///
 /// Converts values to little endian on machines that work with BigEndian, however this is NOT TESTED yet.
 public var convertedEndian: NumericValue {
- if isLitteEndian { return self as! Self.NumericValue }
- fatalError(""This is not tested! please report an issue on the offical flatbuffers repo"")
+ return self as! Self.NumericValue
 }
 }
 
 extension Double: Scalar {
 public typealias NumericValue = UInt64
 
 public var convertedEndian: UInt64 {
- if isLitteEndian { return self.bitPattern }
 return self.bitPattern.littleEndian
 }
 }
 extension Float32: Scalar {
 public typealias NumericValue = UInt32
 
 public var convertedEndian: UInt32 {
- if isLitteEndian { return self.bitPattern }
 return self.bitPattern.littleEndian
 }
 }
",67,1
"Mark GetBufferMinAlignment() const (#5985)

Like GetBufferPointer() and GetSize(), marks GetBufferMinAlignment function as const"," class FlatBufferBuilder {
 /// you call Finish()). You can use this information if you need to embed
 /// a FlatBuffer in some other buffer, such that you can later read it
 /// without first having to copy it into its own buffer.
- size_t GetBufferMinAlignment() {
+ size_t GetBufferMinAlignment() const {
 Finished();
 return minalign_;
 }
",1586,434
"Do not remove the last digit from float values (#5974)

Trailing zeros are already removed inside the function FloatToString,
that is called immediately before the lines deleted by this commit."," bool FieldDef::Deserialize(Parser &parser, const reflection::Field *field) {
 value.constant = NumToString(field->default_integer());
 } else if (IsFloat(value.type.base_type)) {
 value.constant = FloatToString(field->default_real(), 16);
- size_t last_zero = value.constant.find_last_not_of('0');
- if (last_zero != std::string::npos && last_zero != 0) {
- value.constant.erase(last_zero, std::string::npos);
- }
 }
 deprecated = field->deprecated();
 required = field->required();
",3044,921
"[Swift] Add parsing from unowned UnsafeMutableRawPointer for ByteBuffer (#5981)

* RFC: Add ExternalStorage for ByteBuffer in Swift implementation

This PR proposed one more API for ByteBuffer such that no copy is
required to parse FlatBuffers content. This API has limited use, but for
cases that you need to read part of the flatbuffers' data to decide
whether you want to parse / copy the full buffer out, it is useful.

* Use a variable rather than protocol.

* Revert grouping changes from the other PR.

* Add unit test to read from unowned UnsafePointer.

* Manifest changed."," extension FlatBuffersMonsterWriterTests {
 (""testCreateMonsterPrefixed"", testCreateMonsterPrefixed),
 (""testCreateMonsterResizedBuffer"", testCreateMonsterResizedBuffer),
 (""testData"", testData),
- (""testReadFromOtherLangagues"", testReadFromOtherLangagues),
+ (""testReadFromOtherLanguages"", testReadFromOtherLanguages),
+ (""testReadMonsterFromUnsafePointerWithoutCopying"", testReadMonsterFromUnsafePointerWithoutCopying),
 ]
 }
 
",72,1
"[Kotlin] Fix Access to union of vector element (#5994)

Kotlin code generation was producing wrong logic for accessors
of vector of union elements. This was shadowed by the fact[1] that asserts
in Kotlin are silently ignored unless the flag ""-ea"" is passed to the JVM.

The tests are also updated to enable asserts.

1 - https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/assert.html"," class KotlinGenerator : public BaseGenerator {
 break;
 }
 case BASE_TYPE_UNION:
- found = ""{{bbgetter}}(obj, {{index}} - bb_pos){{ucast}}"";
+ found = ""{{bbgetter}}(obj, {{index}}){{ucast}}"";
 break;
 default: found = ""{{bbgetter}}({{index}}){{ucast}}"";
 }
",1128,279
"[Swift] Initialize memory when clear ByteBuffer (#5982)

* Initialize memory when clear ByteBuffer

It seems (based on my limited understanding) that FlatBuffers requires
the writable area to be 0 initialized. However, we missed it when clear
the buffer to reinitialize it.

This PR fixed that by calling initialize (also fixed the typo)
explicitly.

* Update version to 0.5.3"," public struct ByteBuffer {
 memory.copyMemory(from: ptr, byteCount: count)
 }
 
- func initalize(for size: Int) {
+ func initialize(for size: Int) {
 precondition(!unowned)
 memset(memory, 0, size)
 }
 public struct ByteBuffer {
 init(initialSize size: Int) {
 let size = size.convertToPowerofTwo
 _storage = Storage(count: size, alignment: alignment)
- _storage.initalize(for: size)
+ _storage.initialize(for: size)
 }
 
 /// Constructor that creates a Flatbuffer from unsafe memory region without copying
 public struct ByteBuffer {
 alignment = 1
 _storage.memory.deallocate()
 _storage.memory = UnsafeMutableRawPointer.allocate(byteCount: _storage.capacity, alignment: alignment)
+ _storage.initialize(for: _storage.capacity)
 }
 
 /// Resizes the buffer size
",203,38
"Re-added Evolution Schema Code Generation Command (#5999)

* Fixed refractoring issue in reflection/generate_code.sh. Also, mv deletes the original file, so I don't need to clean it up manually in that case.

* Fixed Dart Tests by removing code-gen for included files.

* Added code gen for evolution tests back in.

* General generate code and clang format

* Added evolution schema generation to .bat file

* Added code gen for evolution tests back in.

* General generate code and clang format

* Added evolution schema generation to .bat file

* reran generate_code.sh

* Removed wildcard from generate_code.bat that doesn't work"," class CppGenerator : public BaseGenerator {
 code_.SetValue(""NATIVE_NAME"",
 NativeName(Name(struct_def), &struct_def, opts_));
 // In >= C++11, default member initializers are generated.
- if (opts_.g_cpp_std >= cpp::CPP_STD_11) {
- return;
- }
+ if (opts_.g_cpp_std >= cpp::CPP_STD_11) { return; }
 std::string initializer_list;
 for (auto it = struct_def.fields.vec.begin();
 it != struct_def.fields.vec.end(); ++it) {
",2683,575
"Add warning to schema parser if field name is not snake_case. (#6005)

* Added code gen for evolution tests back in.

* General generate code and clang format

* Added code gen for evolution tests back in.

* General generate code and clang format

* reran generate_code.sh

* Added code gen for evolution tests back in.

* General generate code and clang format

* Added code gen for evolution tests back in.

* General generate code and clang format

* Enforce snake_case for schema field names

* Switched to basic for loop, Fixed warning message"," static bool ValidateUTF8(const std::string &str) {
 return true;
 }
 
+static bool IsLowerSnakeCase(const std::string &str) {
+ for (size_t i = 0; i < str.length(); i++) {
+ char c = str[i];
+ if (!check_ascii_range(c, 'a', 'z') && !is_digit(c) && c != '_') {
+ return false;
+ }
+ }
+ return true;
+}
+
 // Convert an underscore_based_indentifier in to camelCase.
 // Also uppercases the first character if first is true.
 std::string MakeCamel(const std::string &in, bool first) {
 CheckedError Parser::ParseField(StructDef &struct_def) {
 if (LookupCreateStruct(name, false, false))
 return Error(""field name can not be the same as table/struct name"");
 
+ if (!IsLowerSnakeCase(name)) {
+ Warning(""field names should be lowercase snake_case, got: "" + name);
+ }
+
 std::vector<std::string> dc = doc_comment_;
 EXPECT(kTokenIdentifier);
 EXPECT(':');
",3052,924
"Serde with bytes maps to Blob (#6009)

* Serde with_bytes maps to Blob

* Bump rust flexbuffers minor version number

Co-authored-by: Casper Neo <cneo@google.com>"," impl<'a> ser::Serializer for &'a mut FlexbufferSerializer {
 self.finish_if_not_nested()
 }
 fn serialize_bytes(self, v: &[u8]) -> Result<Self::Ok, Self::Error> {
- self.builder.push(v);
+ self.builder.push(crate::Blob(v));
 self.finish_if_not_nested()
 }
 fn serialize_none(self) -> Result<Self::Ok, Self::Error> {
",504,32
"Code cleanup + updates test and readme (#6004)

Updates Readme + adds asserts

Fixes documentation"," final class FlatBuffersTests: XCTestCase {
 XCTAssertEqual(b.startTable(with: 0), 12)
 }
 
- func testCreate() {
- var b = FlatBufferBuilder(initialSize: 16)
- _ = Country.createCountry(builder: &b, name: country, log: 200, lan: 100)
- let v: [UInt8] = [10, 0, 16, 0, 4, 0, 8, 0, 12, 0, 10, 0, 0, 0, 12, 0, 0, 0, 100, 0, 0, 0, 200, 0, 0, 0, 6, 0, 0, 0, 78, 111, 114, 119, 97, 121, 0, 0]
- XCTAssertEqual(b.sizedByteArray, v)
- }
- 
 func testCreateFinish() {
 var b = FlatBufferBuilder(initialSize: 16)
 let countryOff = Country.createCountry(builder: &b, name: country, log: 200, lan: 100)
",92,16
"[Java] Add support for shared strings on FlatBufferBuilder. (#6012)

Added a method FlatBufferBuilder::createSharedString that
enable string sharing for building messages on java.

The shared pool will only contains strings inserted by
this methods."," import java.io.*;
 import java.math.BigInteger;
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
+import java.nio.CharBuffer;
 import java.nio.channels.FileChannel;
+import java.nio.charset.StandardCharsets;
 import java.util.Arrays;
 import java.util.HashMap;
 import java.util.Map;
 class JavaTest {
 
 TestVectorOfBytes();
 
+ TestSharedStringPool();
+
 System.out.println(""FlatBuffers test: completed successfully"");
 }
 
 class JavaTest {
 TestEq(monsterObject8.inventoryLength(), 2048);
 }
 
+ static void TestSharedStringPool() {
+ FlatBufferBuilder fb = new FlatBufferBuilder(1);
+ String testString = ""My string"";
+ int offset = fb.createSharedString(testString);
+ for (int i=0; i< 10; i++) {
+ TestEq(offset, fb.createSharedString(testString));
+ }
+ }
+
 static <T> void TestEq(T a, T b) {
 if (!a.equals(b)) {
 System.out.println("""" + a.getClass().getName() + "" "" + b.getClass().getName());
",959,76
"Updated FB import (#6019)

Previous FB import was based on the original early TS implementation
and did not take into accout NPM. There doesn't seem to be a use
for current implemenentation anymore, while NPM compatibility is
needed.

Co-authored-by: Kamil Rojewski <kamil.rojewski@gmail.com>"," class JsTsGenerator : public BaseGenerator {
 ++it) {
 if (lang_.language == IDLOptions::kTs) {
 if (it->find('.') == std::string::npos) {
- code += ""import { flatbuffers } from \""./flatbuffers\""\n"";
+ code += ""import * as flatbuffers from 'flatbuffers';\n"";
 break;
 }
 } else {
",1711,372
"Silence false positive ""-Wstringop-overflow"" on GCC 10.0 to 11.0 (#6020)"," T ReadScalar(const void *p) {
 return EndianScalar(*reinterpret_cast<const T *>(p));
 }
 
+// See https://github.com/google/flatbuffers/issues/5950
+
+#if (FLATBUFFERS_GCC >= 100000) && (FLATBUFFERS_GCC < 110000)
+ #pragma GCC diagnostic push
+ #pragma GCC diagnostic ignored ""-Wstringop-overflow""
+#endif
+
 template<typename T>
 // UBSAN: C++ aliasing type rules, see std::bit_cast<> for details.
 __supress_ubsan__(""alignment"")
 template<typename T> __supress_ubsan__(""alignment"") void WriteScalar(void *p, Of
 *reinterpret_cast<uoffset_t *>(p) = EndianScalar(t.o);
 }
 
+#if (FLATBUFFERS_GCC >= 100000) && (FLATBUFFERS_GCC < 110000)
+ #pragma GCC diagnostic pop
+#endif
+
 // Computes how many bytes you'd have to pad to be able to write an
 // ""scalar_size"" scalar if the buffer had grown to ""buf_size"" (downwards in
 // memory).
",94,16
"[Dart] Generate constant values map for enums (#6025)

Dart schema compiler generated a static getter for enum values, which
always created a new map instance for its callers. See #5819.
Now it generates const map for better performance
and readability."," class DartGenerator : public BaseGenerator {
 code += ""const "" + name + ""._("" + enum_def.ToString(ev) + "");\n"";
 }
 
- code += "" static get values => {"";
+ code += "" static const values = {"";
 for (auto it = enum_def.Vals().begin(); it != enum_def.Vals().end(); ++it) {
 auto &ev = **it;
 code += enum_def.ToString(ev) + "": "" + ev.name + "","";
",804,186
"Flatc parser support for nullable scalars (#6026)

* Parser support for nullable scalars

* Use older C++ features

* use default element

* Add a test for json, flexbuffers, and null

* test comments and names

Co-authored-by: Casper Neo <cneo@google.com>"," struct FieldDef : public Definition {
 shared(false),
 native_inline(false),
 flexbuffer(false),
+ nullable(false),
 nested_flatbuffer(NULL),
 padding(0) {}
 
 struct FieldDef : public Definition {
 bool native_inline; // Field will be defined inline (instead of as a pointer)
 // for native tables if field is a struct.
 bool flexbuffer; // This field contains FlexBuffer data.
+ bool nullable; // If True, this field is Null (as opposed to default
+ // valued).
 StructDef *nested_flatbuffer; // This field contains nested FlatBuffer data.
 size_t padding; // Bytes to always pad after this field.
 };
 class Parser : public ParserState {
 
 bool SupportsAdvancedUnionFeatures() const;
 bool SupportsAdvancedArrayFeatures() const;
+ bool SupportsNullableScalars() const;
 Namespace *UniqueNamespace(Namespace *ns);
 
 FLATBUFFERS_CHECKED_ERROR RecurseError();
",731,86
"[Swift] Optional Scalars Preparation (#6028)

* Perpares swift to take optional scalars + adds optional string helper method + disables linters in generated code

* Small fix for generated code

* Update grpc support to alpha 17 for swift"," public extension GreeterProvider {
 func handleMethod(_ methodName: String, callHandlerContext: CallHandlerContext) -> GRPCCallHandler? {
 switch methodName {
 case ""SayHello"":
-return UnaryCallHandler(callHandlerContext: callHandlerContext) { context in
+return CallHandlerFactory.makeUnary(callHandlerContext: callHandlerContext) { context in
 return { request in
 self.SayHello(request, context: context)
 }
 }
 case ""SayManyHellos"":
-return ServerStreamingCallHandler(callHandlerContext: callHandlerContext) { context in
+return CallHandlerFactory.makeServerStreaming(callHandlerContext: callHandlerContext) { context in
 return { request in
 self.SayManyHellos(request: request, context: context)
 }
",58,8
"Optional Scalars support for Rust (#6034)

* First draft of rust optionals

* Code cleanup around ftBool and ftVectorOfBool

* Tests for Rust optional scalars

* test bools too

Co-authored-by: Casper Neo <cneo@google.com>"," extern crate bitflags;
 extern crate byteorder;
 #[macro_use]
 extern crate serde_derive;
-#[macro_use]
 extern crate num_enum;
 extern crate serde;
 
",44,2
"adds code gen for optional scalars in swift (#6038)

Adds swift test code

Replaces if statments

Adds swift to supported languages for optionals

Moved std::string to auto

Adds nullable scalars support in object api"," CheckedError Parser::CheckClash(std::vector<FieldDef *> &fields,
 
 
 bool Parser::SupportsNullableScalars() const {
- return !(opts.lang_to_generate & ~IDLOptions::kRust);
+ return !(opts.lang_to_generate & ~(IDLOptions::kRust | IDLOptions::kSwift));
 }
 
 bool Parser::SupportsAdvancedUnionFeatures() const {
",3069,932
"Rust codegen improvements and lint fixes (#6046)

* Improve rust codegen

* one more unneeded lifetime

* Added a derive default

Co-authored-by: Casper Neo <cneo@google.com>"," pub fn lifted_follow<'a, T: Follow<'a>>(buf: &'a [u8], loc: usize) -> T::Inner {
 
 /// FollowStart wraps a Follow impl in a struct type. This can make certain
 /// programming patterns more ergonomic.
-#[derive(Debug)]
+#[derive(Debug, Default)]
 pub struct FollowStart<T>(PhantomData<T>);
 impl<'a, T: Follow<'a> + 'a> FollowStart<T> {
 #[inline]
",32,2
"[Swift] RFC: Switch Swift namespace from public enum to ordinary concat with _ (#6045)

This PR attempts to switch namespace from public enum back to ordinary
concat with _ in Swift. This kept style similar with protobuf, but
different from other popular style guide in Swift.

This is needed because previously, when we do `public enum`, we don't
really know when to declare and when to extend (extension). With namespace
implementation in this PR, there is no such ambiguity."," final class FlatBuffersTests: XCTestCase {
 
 func testWriteOptionalValues() {
 var b = FlatBufferBuilder()
- let root = optional_scalars.ScalarStuff.createScalarStuff(&b,
+ let root = optional_scalars_ScalarStuff.createScalarStuff(&b,
 justI8: 80,
 maybeI8: nil,
 justU8: 100,
 maybeU8: 10)
 b.finish(offset: root)
- let scalarTable = optional_scalars.ScalarStuff.getRootAsScalarStuff(bb: b.sizedBuffer)
+ let scalarTable = optional_scalars_ScalarStuff.getRootAsScalarStuff(bb: b.sizedBuffer)
 XCTAssertEqual(scalarTable.justI8, 80)
 XCTAssertNil(scalarTable.maybeI8)
 XCTAssertEqual(scalarTable.defaultI8, 42)
",107,17
"[Feature] Checks for Nullable strings (#6050)

* Allows null strings in createString method c#

* Adds nullable strings to JS and swift

* Changes js checks

* Fixes typo"," namespace FlatBuffers
 /// </returns>
 public StringOffset CreateString(string s)
 {
+ if (s == null)
+ {
+ return new StringOffset(0);
+ }
 NotNested();
 AddByte(0);
 var utf8StringLen = Encoding.UTF8.GetByteCount(s);
 namespace FlatBuffers
 /// </returns>
 public StringOffset CreateSharedString(string s)
 {
+ if (s == null)
+ {
+ return new StringOffset(0);
+ }
+
 if (_sharedStringMap == null)
 {
 _sharedStringMap = new Dictionary<string, StringOffset>();
",390,121
"adding fb import when no other imports are present (#6030)

Co-authored-by: Kamil Rojewski <kamil.rojewski@gmail.com>
Co-authored-by: Wouter van Oortmerssen <aardappel@gmail.com>"," class JsTsGenerator : public BaseGenerator {
 // Emit namespaces in a form that Closure Compiler can optimize
 std::string &code = *code_ptr;
 std::string &exports = *exports_ptr;
+
+ if (lang_.language == IDLOptions::kTs) {
+ code += ""import * as flatbuffers from 'flatbuffers';\n"";
+ }
+
 for (auto it = sorted_namespaces.begin(); it != sorted_namespaces.end();
 ++it) {
 if (lang_.language == IDLOptions::kTs) {
 if (it->find('.') == std::string::npos) {
- code += ""import * as flatbuffers from 'flatbuffers';\n"";
 break;
 }
 } else {
",1715,374
"[Swift] Append namespace for Swift Grpc implementation (#6049)

* [Swift] Append namespace for Swift Grpc implementation
* Separate ServiceName from ServiceQualifiedName."," struct Method : public CommentHolder {
 grpc::string *str, grpc::string generator_file_name,
 bool generate_in_pb2_grpc, grpc::string import_prefix) const = 0;
 
+ virtual std::vector<grpc::string> get_input_namespace_parts() const = 0;
 virtual grpc::string get_input_type_name() const = 0;
+ virtual std::vector<grpc::string> get_output_namespace_parts() const = 0;
 virtual grpc::string get_output_type_name() const = 0;
 
 virtual grpc::string get_fb_builder() const = 0;
 struct Method : public CommentHolder {
 struct Service : public CommentHolder {
 virtual ~Service() {}
 
+ virtual std::vector<grpc::string> namespace_parts() const = 0;
 virtual grpc::string name() const = 0;
 
 virtual int method_count() const = 0;
",62,5
"Adds a serialize helper function to native table (#6059)

* Adds a serialize helper function to native table
* Updated version"," class FlatBuffersMonsterWriterTests: XCTestCase {
 func readMonster(fb: ByteBuffer) {
 var monster = Monster.getRootAsMonster(bb: fb)
 readFlatbufferMonster(monster: &monster)
- var unpacked: MyGame_Example_MonsterT? = monster.unpack()
+ let unpacked: MyGame_Example_MonsterT? = monster.unpack()
 readObjectApi(monster: unpacked!)
- var builder = FlatBufferBuilder()
- let root = Monster.pack(&builder, obj: &unpacked)
- builder.finish(offset: root)
- var newMonster = Monster.getRootAsMonster(bb: builder.sizedBuffer)
+ guard let buffer = unpacked?.serialize() else { fatalError(""Couldnt generate bytebuffer"") }
+ var newMonster = Monster.getRootAsMonster(bb: buffer)
 readFlatbufferMonster(monster: &newMonster)
 }
 
",242,26
[Lobster] optional scalars support," class LobsterGenerator : public BaseGenerator {
 offsets + "")"";
 
 } else {
+ auto defval = field.nullable ? ""0"" : field.value.constant;
 acc = ""buf_.flatbuffers_field_"" + GenTypeName(field.value.type) +
- ""(pos_, "" + offsets + "", "" + field.value.constant + "")"";
+ ""(pos_, "" + offsets + "", "" + defval + "")"";
 }
 if (field.value.type.enum_def)
 acc = NormalizedName(*field.value.type.enum_def) + ""("" + acc + "")"";
+ if (field.nullable)
+ acc += "", buf_.flatbuffers_field_present(pos_, "" + offsets + "")"";
 code += def + ""():\n return "" + acc + ""\n"";
 return;
 }
 class LobsterGenerator : public BaseGenerator {
 NormalizedName(field) + "":"" + LobsterType(field.value.type) +
 ""):\n b_.Prepend"" + GenMethod(field.value.type) + ""Slot("" +
 NumToString(offset) + "", "" + NormalizedName(field);
- if (IsScalar(field.value.type.base_type))
+ if (IsScalar(field.value.type.base_type) && !field.nullable)
 code += "", "" + field.value.constant;
 code += "")\n return this\n"";
 }
",325,74
[Lobster] missed a test," void NullableScalarsTest() {
 
 // Test if nullable scalars are allowed for each language.
 const int kNumLanguages = 17;
- const auto supported = (flatbuffers::IDLOptions::kRust | flatbuffers::IDLOptions::kSwift);
+ const auto supported = (flatbuffers::IDLOptions::kRust |
+ flatbuffers::IDLOptions::kSwift |
+ flatbuffers::IDLOptions::kLobster);
 for (int lang=0; lang<kNumLanguages; lang++) {
 flatbuffers::IDLOptions opts;
 opts.lang_to_generate |= 1 << lang;
",2701,212
"Adds proper access types for swift object api & flatbuffers & grpc (#6081)

Fixes accessor in greeter.swift

Small fix for ci"," struct Service : public CommentHolder {
 
 virtual std::vector<grpc::string> namespace_parts() const = 0;
 virtual grpc::string name() const = 0;
+ virtual bool is_internal() const = 0;
 
 virtual int method_count() const = 0;
 virtual std::unique_ptr<const Method> method(int i) const = 0;
",63,5
"Wrap verify file id condition in Check call (#6085)

Run clang-format

Update testcase"," class Verifier FLATBUFFERS_FINAL_CLASS {
 
 template<typename T>
 bool VerifyBufferFromStart(const char *identifier, size_t start) {
- if (identifier && (size_ < 2 * sizeof(flatbuffers::uoffset_t) ||
- !BufferHasIdentifier(buf_ + start, identifier))) {
+ if (identifier && !Check((size_ >= 2 * sizeof(flatbuffers::uoffset_t) &&
+ BufferHasIdentifier(buf_ + start, identifier)))) {
 return false;
 }
 
",1583,433
Fix for issue 6100: incorrect shrinking logic in ResizeContext() (#6102)," class ResizeContext {
 if (delta_ > 0)
 buf_.insert(buf_.begin() + start, delta_, 0);
 else
- buf_.erase(buf_.begin() + start, buf_.begin() + start - delta_);
+ buf_.erase(buf_.begin() + start + delta_, buf_.begin() + start);
 }
 
 // Check if the range between first (lower address) and second straddles
",600,202
"Avoid memcpy call for empty vectors (#6111)

Co-authored-by: kuddai <kuddai92@gmail.com>"," class FlatBufferBuilder {
 // causing the wrong overload to be selected, remove it.
 AssertScalarT<T>();
 StartVector(len, sizeof(T));
+ if (len == 0) {
+ return Offset<Vector<T>>(EndVector(len));
+ }
 // clang-format off
 #if FLATBUFFERS_LITTLEENDIAN
 PushBytes(reinterpret_cast<const uint8_t *>(v), len * sizeof(T));
",1586,434
"Rename Nullable scalars to Optional scalars (#6112)

Co-authored-by: Casper Neo <cneo@google.com>"," struct FieldDef : public Definition {
 shared(false),
 native_inline(false),
 flexbuffer(false),
- nullable(false),
+ optional(false),
 nested_flatbuffer(NULL),
 padding(0) {}
 
 struct FieldDef : public Definition {
 bool native_inline; // Field will be defined inline (instead of as a pointer)
 // for native tables if field is a struct.
 bool flexbuffer; // This field contains FlexBuffer data.
- bool nullable; // If True, this field is Null (as opposed to default
+ bool optional; // If True, this field is Null (as opposed to default
 // valued).
 StructDef *nested_flatbuffer; // This field contains nested FlatBuffer data.
 size_t padding; // Bytes to always pad after this field.
 class Parser : public ParserState {
 
 bool SupportsAdvancedUnionFeatures() const;
 bool SupportsAdvancedArrayFeatures() const;
- bool SupportsNullableScalars() const;
+ bool SupportsOptionalScalars() const;
 Namespace *UniqueNamespace(Namespace *ns);
 
 FLATBUFFERS_CHECKED_ERROR RecurseError();
",733,86
"Optional-ness in reflection (#6097)

* Optional scalars in reflection

* fixed name collision

* Remove code duplicated by merge

Co-authored-by: Casper Neo <cneo@google.com>"," void ReflectionTest(uint8_t *flatbuf, size_t length) {
 TEST_EQ_STR(hp_field.name()->c_str(), ""hp"");
 TEST_EQ(hp_field.id(), 2);
 TEST_EQ(hp_field.type()->base_type(), reflection::Short);
+
 auto friendly_field_ptr = fields->LookupByKey(""friendly"");
 TEST_NOTNULL(friendly_field_ptr);
 TEST_NOTNULL(friendly_field_ptr->attributes());
 void ReflectionTest(uint8_t *flatbuf, size_t length) {
 TEST_NOTNULL(pos_table_ptr);
 TEST_EQ_STR(pos_table_ptr->name()->c_str(), ""MyGame.Example.Vec3"");
 
+ // Test nullability of fields: hp is a 0-default scalar, pos is a struct =>
+ // optional, and name is a required string => not optional.
+ TEST_EQ(hp_field.optional(), false);
+ TEST_EQ(pos_field_ptr->optional(), true);
+ TEST_EQ(fields->LookupByKey(""name"")->optional(), false);
+
 // Now use it to dynamically access a buffer.
 auto &root = *flatbuffers::GetAnyRoot(flatbuf);
 
",2704,212
"[Swift] Migrates struct write APIS to write directly to the buffer (#6093)

* Migrates struct write APIS to in place APIS

* Fixes indentation in grpc swift"," extension FlatBuffersStructsTests {
 // `swift test --generate-linuxmain`
 // to regenerate.
 static let __allTests__FlatBuffersStructsTests = [
- (""testCreatingEnums"", testCreatingEnums),
- (""testCreatingStruct"", testCreatingStruct),
- (""testCreatingVectorStruct"", testCreatingVectorStruct),
- (""testCreatingVectorStructWithForcedDefaults"", testCreatingVectorStructWithForcedDefaults),
- (""testReadingStruct"", testReadingStruct),
- (""testReadingStructWithEnums"", testReadingStructWithEnums),
 (""testWritingAndMutatingBools"", testWritingAndMutatingBools),
 ]
 }
 extension FlatBuffersTests {
 (""testOffset"", testOffset),
 (""testReadCountry"", testReadCountry),
 (""testStartTable"", testStartTable),
+ (""testWriteNullableStrings"", testWriteNullableStrings),
 (""testWriteOptionalValues"", testWriteOptionalValues),
 ]
 }
",68,1
"[JS] Add getFullyQualifiedName() (#6119)

This optionally generates a static `getFullyQualifiedName()` function to get
the fully-qualified name of a type in JavaScript and TypeScript in a similar
fashion to the C++ codegen."," class JsTsGenerator : public BaseGenerator {
 }
 }
 
+ // Emit the fully qualified name
+ if (parser_.opts.generate_name_strings) {
+ GenDocComment(code_ptr, GenTypeAnnotation(kReturns, ""string"", """", false));
+ if (lang_.language == IDLOptions::kTs) {
+ code += ""static getFullyQualifiedName():string {\n"";
+ } else {
+ code += object_name + "".getFullyQualifiedName = function() {\n"";
+ }
+ code += "" return '"" + WrapInNameSpace(struct_def) + ""';\n"";
+ code += ""}\n\n"";
+ }
+
 // Emit a factory constructor
 if (struct_def.fixed) {
 std::string annotations =
",1768,388
[JS/TS] Modernize TypeScript / JavaScript flatbuffers support (#6095),"
+export function createLong(low: number, high: number): Long {
+ return Long.create(low, high);
+}
+ 
+export class Long {
+ static readonly ZERO = new Long(0, 0)
+ low: number
+ high: number
+ constructor(low: number, high: number) {
+ this.low = low | 0;
+ this.high = high | 0;
+ }
+ static create(low: number, high: number): Long {
+ // Special-case zero to avoid GC overhead for default values
+ return low == 0 && high == 0 ? Long.ZERO : new Long(low, high);
+ }
+ toFloat64(): number {
+ return (this.low >>> 0) + this.high * 0x100000000;
+ }
+ equals(other: Long): boolean {
+ return this.low == other.low && this.high == other.high;
+ }
+}
\ No newline at end of file
",21,2
"[Kotlin] Support for optional scalars. (#6115)

More information on #6014"," struct FieldDef : public Definition {
 
 bool Deserialize(Parser &parser, const reflection::Field *field);
 
+ bool IsScalarOptional() const {
+ return IsScalar(value.type.base_type) && optional;
+ }
+
 Value value;
 bool deprecated; // Field is allowed to be present in old data, but can't be.
 // written in new data nor accessed in new code.
",736,88
Add support of Optional<T> scalars to C++ code generator (#6092)," class Parser : public ParserState {
 
 FLATBUFFERS_CHECKED_ERROR Error(const std::string &msg);
 
+ // @brief Verify that any of 'opts.lang_to_generate' supports Optional scalars
+ // in a schema.
+ // @param opts Options used to parce a schema and generate code.
+ static bool SupportsOptionalScalars(const flatbuffers::IDLOptions &opts);
+
 private:
 void Message(const std::string &msg);
 void Warning(const std::string &msg);
",737,88
"Add CharToLower and CharToUpper into util.s (#6126)

This commit adds replacement of `::tolower` and `::toupper`.
Added CharToLower and CharToUpper routines reduce the number of cast operators
that required for correct usage of standard C/C++ `::tolower/toupper` routines."," inline bool is_xdigit(char c) {
 // Case-insensitive isalnum
 inline bool is_alnum(char c) { return is_alpha(c) || is_digit(c); }
 
+inline char CharToUpper(char c) {
+ return static_cast<char>(::toupper(static_cast<unsigned char>(c)));
+}
+
+inline char CharToLower(char c) {
+ return static_cast<char>(::tolower(static_cast<unsigned char>(c)));
+}
+
 // @end-locale-independent functions for ASCII character set
 
 #ifdef FLATBUFFERS_PREFER_PRINTF
",390,121
"Minireflect fixed array (#6129)

* CMakeLists: also really generate optional_scalars as needed by test elsewhere

* [C++] Handle fixed-length array in minireflection

Fixes #6128"," inline const char * const *ElementaryTypeNames() {
 // Basic type info cost just 16bits per field!
 struct TypeCode {
 uint16_t base_type : 4; // ElementaryType
- uint16_t is_vector : 1;
+ uint16_t is_repeating : 1; // Either vector (in table) or array (in struct)
 int16_t sequence_ref : 11; // Index into type_refs below, or -1 for none.
 };
 
 struct TypeTable {
 size_t num_elems; // of type_codes, values, names (but not type_refs).
 const TypeCode *type_codes; // num_elems count
 const TypeFunction *type_refs; // less than num_elems entries (see TypeCode).
+ const int16_t *array_sizes; // less than num_elems entries (see TypeCode).
 const int64_t *values; // Only set for non-consecutive enum/union or structs.
 const char *const *names; // Only set if compiled with --reflect-names.
 };
",1614,441
"Add static cast to avoid implicit double promotion. (#6132)

Add static cast from float to double in flexbuffers.h to avoid implicit double promotion error. This error is surfacing during the tensorflow lite for microcontrollers build since we enabled -Werror and -Wdouble-promotion."," class Builder FLATBUFFERS_FINAL_CLASS {
 Value(uint64_t u, Type t, BitWidth bw)
 : u_(u), type_(t), min_bit_width_(bw) {}
 
- Value(float f) : f_(f), type_(FBT_FLOAT), min_bit_width_(BIT_WIDTH_32) {}
+ Value(float f)
+ : f_(static_cast<double>(f)),
+ type_(FBT_FLOAT),
+ min_bit_width_(BIT_WIDTH_32) {}
 Value(double f) : f_(f), type_(FBT_FLOAT), min_bit_width_(WidthF(f)) {}
 
 uint8_t StoredPackedType(BitWidth parent_bit_width_ = BIT_WIDTH_8) const {
",1218,396
SpanT is available in .Net Standard 2.0. (#6137)," namespace FlatBuffers
 _space = _bb.Put(_space, x);
 }
 
-#if ENABLE_SPAN_T
+#if ENABLE_SPAN_T && (UNSAFE_BYTEBUFFER || NETSTANDARD2_1)
 /// <summary>
 /// Puts a span of type T into this builder at the
 /// current offset
 namespace FlatBuffers
 Put(x);
 }
 
-#if ENABLE_SPAN_T
+#if ENABLE_SPAN_T && (UNSAFE_BYTEBUFFER || NETSTANDARD2_1)
 /// <summary>
 /// Add a span of type T to the buffer (aligns the data and grows if necessary).
 /// </summary>
 namespace FlatBuffers
 }
 
 
-#if ENABLE_SPAN_T
+#if ENABLE_SPAN_T && (UNSAFE_BYTEBUFFER || NETSTANDARD2_1)
 /// <summary>
 /// Creates a string in the buffer from a Span containing
 /// a UTF8 string.
",390,121
"[Python/JS/TS] Codegen SizeOf method for structs (#6136)

* [Python] Codegen SizeOf classmethod for structs

This codegens a `SizeOf()` classmethod for all structs since we can't
determine the size of a FlatBuffer generated struct from Python otherwise.

* [JS/TS] Codegen sizeOf static method for structs

This codegens a `sizeOf()` static method for all structs since we can't
determine the size of a FlatBuffer generated struct from JavaScript or
TypeScript otherwise."," class JsTsGenerator : public BaseGenerator {
 code += ""}\n\n"";
 }
 
+ // Emit the size of the struct.
+ if (struct_def.fixed) {
+ GenDocComment(code_ptr, GenTypeAnnotation(kReturns, ""number"", """", false));
+ if (lang_.language == IDLOptions::kTs) {
+ code += ""static sizeOf():number {\n"";
+ } else {
+ code += object_name + "".sizeOf = function() {\n"";
+ }
+ code += "" return "" + NumToString(struct_def.bytesize) + "";\n"";
+ code += ""}\n\n"";
+ }
+
 // Emit a factory constructor
 if (struct_def.fixed) {
 std::string annotations =
",1778,390
Fix generation of C++ code with Optional<Enum> (#6155)," struct ScalarStuffT : public flatbuffers::NativeTable {
 flatbuffers::Optional<double> maybe_f64 = flatbuffers::nullopt;
 double default_f64 = 42.0;
 bool just_bool = false;
- flatbuffers::Optional<bool> maybe_bool = true;
+ flatbuffers::Optional<bool> maybe_bool = flatbuffers::nullopt;
 bool default_bool = true;
 optional_scalars::OptionalByte just_enum = optional_scalars::OptionalByte::None;
 optional_scalars::OptionalByte default_enum = optional_scalars::OptionalByte::One;
",838,179
"Ruopt enum (#6156)

* Rust support for optional enums

* make optional_scalars2 for languages that support optional enums

Co-authored-by: Casper Neo <cneo@google.com>"," mod monster_test_generated;
 pub use monster_test_generated::my_game;
 
 #[allow(dead_code, unused_imports)]
-#[path = ""../../optional_scalars_generated.rs""]
+#[path = ""../../optional_scalars2_generated.rs""]
 mod optional_scalars_generated;
 
 #[rustfmt::skip] // TODO: Use standard rust formatting and remove dead code.
",2543,137
"Enables optional enums in swift (#6160)

[Swift] Enables optional enums"," final class FlatBuffersTests: XCTestCase {
 justI8: 80,
 maybeI8: nil,
 justU8: 100,
- maybeU8: 10)
+ maybeU8: 10,
+ maybeBool: true,
+ justEnum: .one,
+ maybeEnum: nil)
 b.finish(offset: root)
 let scalarTable = optional_scalars_ScalarStuff.getRootAsScalarStuff(bb: b.sizedBuffer)
 XCTAssertEqual(scalarTable.justI8, 80)
 XCTAssertNil(scalarTable.maybeI8)
+ XCTAssertEqual(scalarTable.maybeBool, true)
 XCTAssertEqual(scalarTable.defaultI8, 42)
 XCTAssertEqual(scalarTable.justU8, 100)
 XCTAssertEqual(scalarTable.maybeU8, 10)
+ XCTAssertEqual(scalarTable.justEnum, .one)
+ XCTAssertNil(scalarTable.maybeEnum)
 }
 }
 
",118,18
"[Rust] Upgrade flatbuffers library to 2018 edition (#6159)

* [Rust] Upgrade flatbuffers lib to 2018 edition

* Pushed version","
 extern crate smallvec;
 
 use std::cmp::max;
+use std::iter::{DoubleEndedIterator, ExactSizeIterator};
 use std::marker::PhantomData;
 use std::ptr::write_bytes;
 use std::slice::from_raw_parts;
-use std::iter::{DoubleEndedIterator, ExactSizeIterator};
 
-use endian_scalar::{emplace_scalar, read_scalar_at};
-use primitives::*;
-use push::{Push, PushAlignment};
-use table::Table;
-use vector::{SafeSliceAccess, Vector};
-use vtable::{field_index_to_field_offset, VTable};
-use vtable_writer::VTableWriter;
+use crate::endian_scalar::{emplace_scalar, read_scalar_at};
+use crate::primitives::*;
+use crate::push::{Push, PushAlignment};
+use crate::table::Table;
+use crate::vector::{SafeSliceAccess, Vector};
+use crate::vtable::{field_index_to_field_offset, VTable};
+use crate::vtable_writer::VTableWriter;
 
 pub const N_SMALLVEC_STRING_VECTOR_CAPACITY: usize = 16;
 
",530,21
"Moved C++ to optional_scalars2 and added some tests. (#6162)

* Moved C++ to optional_scalars2 and added some tests.

Also deleted unused optional_scalars_generated.lobster

* Fixed whitespece in C++ gencode & fixed BUILD file

* Moved C++ onto optional_scalars2 in the .bat file

Co-authored-by: Casper Neo <cneo@google.com>","
-/*
+ /*
 * Copyright 2014 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 class CppGenerator : public BaseGenerator {
 const auto &type = field.value.type;
 code_.SetValue(""PARAM_VALUE"", GetDefaultScalarValue(field, false));
 if (field.IsScalarOptional())
- code_.SetValue(""PARAM_TYPE"", GenOptionalDecl(type));
+ code_.SetValue(""PARAM_TYPE"", GenOptionalDecl(type) + "" "");
 else
 code_.SetValue(""PARAM_TYPE"", GenTypeWire(type, "" "", true));
 }
",2751,596
"[TS] GRPC Implementation (#6141)

* GRPC implementation for Typescript

* Fixes a couple of issues

* Finished implementing the typescript support for grpc

* Updated generated code

* Fixes CI","
+import grpc from 'grpc';
+import { HelloRequest } from './greeter_generated';
+import { GreeterClient } from './greeter_grpc';
+import { flatbuffers } from 'flatbuffers';
+
+async function main() {
+ const _server = new GreeterClient('localhost:3000', grpc.credentials.createInsecure());
+ const builder = new flatbuffers.Builder();
+ const offset = builder.createString('mustii');
+ const root = HelloRequest.createHelloRequest(builder, offset);
+ builder.finish(root);
+ const buffer = HelloRequest.getRootAsHelloRequest(new flatbuffers.ByteBuffer(builder.asUint8Array()));
+
+ _server.SayHello(buffer, (err, response) => {
+ console.log(response.message());
+ });
+
+ const data = _server.SayManyHellos(buffer, null);
+
+ data.on('data', (data) => {
+ console.log(data.message());
+ });
+ data.on('end', (data) => {
+ console.log('end');
+ });
+}
+
+main();
\ No newline at end of file
",23,4
"Fixed rust nested flatbuffers for tables other than self (#6062)

* Fixed rust nested flatbuffers for tables other than self

* replaced lifetimes

* Use WrapInNameSpace and also update samples

Co-authored-by: Casper Neo <cneo@google.com>"," class RustGenerator : public BaseGenerator {
 nested_root = parser_.LookupStruct(qualified_name);
 }
 FLATBUFFERS_ASSERT(nested_root); // Guaranteed to exist by parser.
- (void)nested_root;
 
- code_.SetValue(""OFFSET_NAME"",
- offset_prefix + ""::"" + GetFieldOffsetName(field));
+ code_.SetValue(""NESTED"", WrapInNameSpace(*nested_root));
 code_ +=
 "" pub fn {{FIELD_NAME}}_nested_flatbuffer(&'a self) -> ""
- "" Option<{{STRUCT_NAME}}<'a>> {"";
- code_ += "" match self.{{FIELD_NAME}}() {"";
- code_ += "" None => { None }"";
- code_ += "" Some(data) => {"";
- code_ += "" use self::flatbuffers::Follow;"";
- code_ +=
- "" Some(<flatbuffers::ForwardsUOffset""
- ""<{{STRUCT_NAME}}<'a>>>::follow(data, 0))"";
- code_ += "" },"";
- code_ += "" }"";
+ ""Option<{{NESTED}}<'a>> {"";
+ code_ += "" self.{{FIELD_NAME}}().map(|data| {"";
+ code_ += "" use flatbuffers::Follow;"";
+ code_ += "" <flatbuffers::ForwardsUOffset<{{NESTED}}<'a>>>""
+ ""::follow(data, 0)"";
+ code_ += "" })"";
 code_ += "" }"";
 }
 }
",1449,333
"Cast to right type for reserved_ subtraction (#6167)

reserved_ is a size_t so ensure that the output of cur_ - buf_ is cast to that to avoid compiler warnings."," class vector_downward {
 Allocator *get_custom_allocator() { return allocator_; }
 
 uoffset_t size() const {
- return static_cast<uoffset_t>(reserved_ - (cur_ - buf_));
+ return static_cast<uoffset_t>(reserved_ - static_cast<size_t>(cur_ - buf_));
 }
 
 uoffset_t scratch_size() const {
",1614,441
"Add Array initialization from struct constructor (#5865) (#6147)

- add flatbuffers::span
- add new constructor for `struct` with `array`
- add some test for flatbuffers::span and 'arrays_test.fbs'"," namespace flatbuffers {
 #define FLATBUFFERS_CONSTEXPR_CPP11
 #endif
 
-// This macro is never used in code!
 #if (defined(__cplusplus) && __cplusplus >= 201402L) || \
 (defined(__cpp_constexpr) && __cpp_constexpr >= 201304)
- #define FLATBUFFERS_CONSTEXPR_CPP14 FLATBUFFERS_CONSTEXPR
+ #define FLATBUFFERS_CONSTEXPR_CPP14 FLATBUFFERS_CONSTEXPR_CPP11
 #else
 #define FLATBUFFERS_CONSTEXPR_CPP14
 #endif
",92,16
"[C++] Add option to not generate direct copy methods. (#6166)

* Add option to not generate direct copy methods.

The direct copy methods generated by flatc utilize std::vector which isn't allowed on some embedded systems. Permit users of the compiler to not generate these methods so they don't have to be stubbed out.

* Update docs for no-cpp-direct-copy option."," struct IDLOptions {
 std::string cpp_object_api_pointer_type;
 std::string cpp_object_api_string_type;
 bool cpp_object_api_string_flexible_constructor;
+ bool cpp_direct_copy;
 bool gen_nullable;
 bool java_checkerframework;
 bool gen_generated;
 struct IDLOptions {
 gen_compare(false),
 cpp_object_api_pointer_type(""std::unique_ptr""),
 cpp_object_api_string_flexible_constructor(false),
+ cpp_direct_copy(true),
 gen_nullable(false),
 java_checkerframework(false),
 gen_generated(false),
",741,88
"Add generation of JSON Schema to library (#6165)

* Fix C/C++ Create<Type>Direct with sorted vectors

If a struct has a key the vector has to be sorted. To sort the vector
you can't use ""const"".

* Changes due to code review

* Improve code readability

* Add generate of JSON schema to string to lib

* option indent_step is supported

* Remove unused variables

* Fix break in test

* Fix style to be consistent with rest of the code"," extern bool GenerateText(const Parser &parser, const void *flatbuffer,
 extern bool GenerateTextFile(const Parser &parser, const std::string &path,
 const std::string &file_name);
 
+// Generate Json schema to string
+// See idl_gen_json_schema.cpp.
+extern bool GenerateJsonSchema(const Parser &parser, std::string *json);
+
 // Generate binary files from a given FlatBuffer, and a given Parser
 // object that has been populated with the corresponding schema.
 // See code_generators.cpp.
",742,88
fix(go_test): remove deprecated grpc call (#6183)," func TestGRPC(t *testing.T) {
 if err != nil {
 t.Fatalf(""Failed to listen: %v"", err)
 }
-ser := grpc.NewServer(grpc.CustomCodec(flatbuffers.FlatbuffersCodec{}))
+ser := grpc.NewServer()
+ encoding.RegisterCodec(flatbuffers.FlatbuffersCodec{})
 Example.RegisterMonsterStorageServer(ser, &server{})
 go func() {
 if err := ser.Serve(lis); err != nil {
",80,13
"[JS/TS] Rewrite flexbuffers JS to TS (#6148)

* Partial TS rewrite

* Completed port but bugs remain

* Expose builder function

* Break out and fix stack-value and formatting","
+export function fromUTF8Array(data: BufferSource): string {
+ const decoder = new TextDecoder();
+ return decoder.decode(data);
+}
+
+export function toUTF8Array(str: string) : Uint8Array {
+ const encoder = new TextEncoder();
+ return encoder.encode(str);
+}
\ No newline at end of file
",8,2
"Updated SupportsAdvancedUnionFeatures to look out for string (#6190)

Co-authored-by: Casper Neo <cneo@google.com>"," struct EnumDef : public Definition {
 SymbolTable<EnumVal> vals;
 };
 
+inline bool IsString(const Type &type) {
+ return type.base_type == BASE_TYPE_STRING;
+}
+
 inline bool IsStruct(const Type &type) {
 return type.base_type == BASE_TYPE_STRUCT && type.struct_def->fixed;
 }
",745,89
"Mass Refactoring to use `IsString` and other BASE_TYPE helpers (#6193)

* Updated SupportsAdvancedUnionFeatures to look out for string

* Mass refactoring to use BASE_TYPE helper functions.

Co-authored-by: Casper Neo <cneo@google.com>"," std::string GenType(BaseType type) {
 std::string GenBaseType(const Type &type) {
 if (type.struct_def != nullptr) { return GenTypeRef(type.struct_def); }
 if (type.enum_def != nullptr) { return GenTypeRef(type.enum_def); }
- if (type.base_type == BASE_TYPE_ARRAY || type.base_type == BASE_TYPE_VECTOR) {
+ if (IsArray(type) || IsVector(type)) {
 return ""\""type\"" : \""array\"", \""items\"" : {"" + GenType(type.element) + ""}"";
 }
 return GenType(type.base_type);
 class JsonSchemaGenerator : public BaseGenerator {
 std::string arrayInfo = """";
 if (IsArray(property->value.type)) {
 arrayInfo = "","" + NewLine() + Indent(8) + ""\""minItems\"": "" +
- NumToString(property->value.type.fixed_length) + 
+ NumToString(property->value.type.fixed_length) +
 "","" + NewLine() + Indent(8) + ""\""maxItems\"": "" +
 NumToString(property->value.type.fixed_length);
 }
",241,61
"Kotlin test optional enum (#6201)

* Add test for optional enums in Kotlin

* Rename optional_scalars2.fbs into optional_scalars.fbs

Also updated all references in the project to point to
""optional_scalars.fbs"" instead of ""optional_scalars2.fbs"".","
 // automatically generated by the FlatBuffers compiler, do not modify
 
 
-#ifndef FLATBUFFERS_GENERATED_OPTIONALSCALARS2_OPTIONAL_SCALARS_H_
-#define FLATBUFFERS_GENERATED_OPTIONALSCALARS2_OPTIONAL_SCALARS_H_
+#ifndef FLATBUFFERS_GENERATED_OPTIONALSCALARS_OPTIONAL_SCALARS_H_
+#define FLATBUFFERS_GENERATED_OPTIONALSCALARS_OPTIONAL_SCALARS_H_
 
 #include ""flatbuffers/flatbuffers.h""
 
 inline flatbuffers::unique_ptr<optional_scalars::ScalarStuffT> UnPackSizePrefixe
 
 } // namespace optional_scalars
 
-#endif // FLATBUFFERS_GENERATED_OPTIONALSCALARS2_OPTIONAL_SCALARS_H_
+#endif // FLATBUFFERS_GENERATED_OPTIONALSCALARS_OPTIONAL_SCALARS_H_
",939,222
Removed C# references from java generator. Move annotations closer to definitions (#6204)," import java.lang.*;
 import java.util.*;
 import com.google.flatbuffers.*;
 
-@SuppressWarnings(""unused"")
 /**
 * an example documentation comment: ""monster object""
 */
+@SuppressWarnings(""unused"")
 public final class Monster extends Table {
 public static void ValidateVersion() { Constants.FLATBUFFERS_1_12_0(); }
 public static Monster getRootAsMonster(ByteBuffer _bb) { return getRootAsMonster(_bb, new Monster()); }
",307,410
"Empties the sharedString map on reset on go and csharp (#6187)

Fixes go tests"," func (b *Builder) Reset() {
 b.vtable = b.vtable[:0]
 }
 
+if b.sharedStrings != nil {
+for key := range b.sharedStrings {
+delete(b.sharedStrings, key)
+}
+}
+
 b.head = UOffsetT(len(b.Bytes))
 b.minalign = 1
 b.nested = false
",476,121
"[Java] Implement optional scalars (#6212)

Java implementation of optional scalars, following issue #6014."," CheckedError Parser::CheckClash(std::vector<FieldDef *> &fields,
 bool Parser::SupportsOptionalScalars(const flatbuffers::IDLOptions &opts) {
 static FLATBUFFERS_CONSTEXPR unsigned long supported_langs =
 IDLOptions::kRust | IDLOptions::kSwift | IDLOptions::kLobster |
- IDLOptions::kKotlin | IDLOptions::kCpp;
+ IDLOptions::kKotlin | IDLOptions::kCpp | IDLOptions::kJava;
 unsigned long langs = opts.lang_to_generate;
 return (langs > 0 && langs < IDLOptions::kMAX) && !(langs & ~supported_langs);
 }
",3093,942
"optional scalars for ts/js (#6215)

* optional scalars for ts/js

* removed range based for

* removed range based for"," CheckedError Parser::CheckClash(std::vector<FieldDef *> &fields,
 bool Parser::SupportsOptionalScalars(const flatbuffers::IDLOptions &opts) {
 static FLATBUFFERS_CONSTEXPR unsigned long supported_langs =
 IDLOptions::kRust | IDLOptions::kSwift | IDLOptions::kLobster |
- IDLOptions::kKotlin | IDLOptions::kCpp | IDLOptions::kJava;
+ IDLOptions::kKotlin | IDLOptions::kCpp | IDLOptions::kJava |
+ IDLOptions::kTs | IDLOptions::kJs;
 unsigned long langs = opts.lang_to_generate;
 return (langs > 0 && langs < IDLOptions::kMAX) && !(langs & ~supported_langs);
 }
",3094,942
"Updated comments and fixed a fundamental type error. (#6214)

* Updated comments and fixed a fundemental type error.

* bump rust flatbuffers semver

Co-authored-by: Casper Neo <cneo@google.com>"," pub const SIZE_VOFFSET: usize = SIZE_I16;
 
 pub const SIZE_SIZEPREFIX: usize = SIZE_UOFFSET;
 
-/// SOffsetT is an i32 that is used by tables to reference their vtables.
+/// SOffsetT is a relative pointer from tables to their vtables.
 pub type SOffsetT = i32;
 
-/// UOffsetT is a u32 that is used by pervasively to represent both pointers
-/// and lengths of vectors.
+/// UOffsetT is used represent both for relative pointers and lengths of vectors.
 pub type UOffsetT = u32;
 
-/// VOffsetT is a i32 that is used by vtables to store field data.
-pub type VOffsetT = i16;
+/// VOffsetT is a relative pointer in vtables to point from tables to field data.
+pub type VOffsetT = u16;
 
 /// TableFinishedWIPOffset marks a WIPOffset as being for a finished table.
 #[derive(Clone, Copy)]
",223,17
"Implement `Debug` trait for Rust flatbuffers. (#6207)

* Refactor idl_gen_rust to a ForAllX continuation pattern.

* Removed unneeded SetValue and updated sample rust gencode

* Make Rust flatbuffers print right

* Generated code and removed unnecessary trait constraint

* bumped rust version. Release required

* removed an unwrap in Rust Debug-print unions

* Tested formatting flatbuffers in rust.

* Set float precision in flaky debug-print test

* impl Debug for structs too

Co-authored-by: Casper Neo <cneo@google.com>"," use std::marker::PhantomData;
 use std::mem::size_of;
 use std::slice::from_raw_parts;
 use std::str::from_utf8_unchecked;
+use std::fmt::{Debug, Result, Formatter};
 
 use crate::endian_scalar::read_scalar_at;
 #[cfg(target_endian = ""little"")]
 use crate::endian_scalar::EndianScalar;
 use crate::follow::Follow;
 use crate::primitives::*;
 
-#[derive(Debug)]
 pub struct Vector<'a, T: 'a>(&'a [u8], usize, PhantomData<T>);
 
+impl<'a, T> Debug for Vector<'a, T>
+where
+ T: 'a + Follow<'a>,
+ <T as Follow<'a>>::Inner : Debug
+{
+ fn fmt(&self, f: &mut Formatter) -> Result {
+ f.debug_list().entries(self.iter()).finish()
+ }
+}
+
+
 // We cannot use derive for these two impls, as it would only implement Copy
 // and Clone for `T: Copy` and `T: Clone` respectively. However `Vector<'a, T>`
 // can always be copied, no matter that `T` you have.
",230,7
Support size-prefixed buffers and add tests for size-prefixed messages (#6232)," func GetRootAs(buf []byte, offset UOffsetT, fb FlatBuffer) {
 n := GetUOffsetT(buf[offset:])
 fb.Init(buf, n+offset)
 }
+
+// GetSizePrefixedRootAs is a generic helper to initialize a FlatBuffer with the provided size-prefixed buffer
+// bytes and its data offset
+func GetSizePrefixedRootAs(buf []byte, offset UOffsetT, fb FlatBuffer) {
+n := GetUOffsetT(buf[offset+sizePrefixLength:])
+fb.Init(buf, n+offset+sizePrefixLength)
+}
+
+// GetSizePrefix reads the size from a size-prefixed flatbuffer
+func GetSizePrefix(buf []byte, offset UOffsetT) uint32 {
+return GetUint32(buf[offset:])
+}
",16,3
"Added required-nested-flatbuffer to monster_test and fixed rust (#6236)

Co-authored-by: Casper Neo <cneo@google.com>"," class RustGenerator : public BaseGenerator {
 
 code_.SetValue(""NESTED"", WrapInNameSpace(*nested_root));
 code_ +=
- "" pub fn {{FIELD_NAME}}_nested_flatbuffer(&'a self) -> ""
- ""Option<{{NESTED}}<'a>> {"";
- code_ += "" self.{{FIELD_NAME}}().map(|data| {"";
- code_ += "" use flatbuffers::Follow;"";
- code_ += "" <flatbuffers::ForwardsUOffset<{{NESTED}}<'a>>>""
- ""::follow(data, 0)"";
- code_ += "" })"";
+ "" pub fn {{FIELD_NAME}}_nested_flatbuffer(&'a self) -> \\"";
+ if (field.required) {
+ code_ += ""{{NESTED}}<'a> {"";
+ code_ += "" let data = self.{{FIELD_NAME}}();"";
+ code_ += "" use flatbuffers::Follow;"";
+ code_ += "" <flatbuffers::ForwardsUOffset<{{NESTED}}<'a>>>""
+ ""::follow(data, 0)"";
+ } else {
+ code_ += ""Option<{{NESTED}}<'a>> {"";
+ code_ += "" self.{{FIELD_NAME}}().map(|data| {"";
+ code_ += "" use flatbuffers::Follow;"";
+ code_ += "" <flatbuffers::ForwardsUOffset<{{NESTED}}<'a>>>""
+ ""::follow(data, 0)"";
+ code_ += "" })"";
+ }
 code_ += "" }"";
 }
 });
",1494,313
"Add GetBufferSpan() function to bufferbuilder (#6235)

This will return the finished internal buffer data as a span"," class FlatBufferBuilder {
 return buf_.data();
 }
 
+ /// @brief Get the serialized buffer (after you call `Finish()`) as a span.
+ /// @return Returns a constructed flatbuffers::span that is a view over the 
+ /// FlatBuffer data inside the buffer.
+ flatbuffers::span<uint8_t> GetBufferSpan() const {
+ Finished();
+ return flatbuffers::span<uint8_t>(buf_.data(), buf_.size());
+ }
+
 /// @brief Get a pointer to an unfinished buffer.
 /// @return Returns a `uint8_t` pointer to the unfinished buffer.
 uint8_t *GetCurrentBufferPointer() const { return buf_.data(); }
",1657,455
"Resets buffer without deallocating current pointer (#6247)

Resets buffer without deallocating current pointer & Bumps version"," public struct ByteBuffer {
 mutating public func clear() {
 _writerSize = 0
 alignment = 1
- _storage.memory.deallocate()
- _storage.memory = UnsafeMutableRawPointer.allocate(byteCount: _storage.capacity, alignment: alignment)
 _storage.initialize(for: _storage.capacity)
 }
 
",212,37
"Remove _POSIX_C_SOURCE and _XOPEN_SOURCE definitions when compiling o (#6205)

* Remove _POSIX_C_SOURCE and _XOPEN_SOURCE definitions when compiling on OpenBSD

* Only define _POSIX_C_SOURCE and _XOPEN_SOURCE for mingw/cygwin platforms

* Only define POSIX statements for mingw/cygwin/qnx platforms","
 // clang-format off
 // Dont't remove `format off`, it prevent reordering of win-includes.
 
+#if defined(__MINGW32__) || defined(__MINGW64__) || defined(__CYGWIN__) || \
+ defined(__QNXNTO__)
 # define _POSIX_C_SOURCE 200809L
 # define _XOPEN_SOURCE 700L
+#endif
 
 #ifdef _WIN32
 # ifndef WIN32_LEAN_AND_MEAN
",165,60
"BREAKING: Rust flexbuffers serde human readable set to false (#6257)

Co-authored-by: Casper Neo <cneo@google.com>"," impl<'a> ser::Serializer for &'a mut FlexbufferSerializer {
 type SerializeStructVariant = &'a mut FlexbufferSerializer;
 type Ok = ();
 type Error = Error;
+ fn is_human_readable(&self) -> bool {
+ cfg!(serialize_human_readable)
+ }
 fn serialize_bool(self, v: bool) -> Result<Self::Ok, Self::Error> {
 self.builder.push(v);
 self.finish_if_not_nested()
",507,32
Adds a fix for enum generation (#6263)," class SwiftGenerator : public BaseGenerator {
 const auto &ev = **enum_def.Vals().begin();
 name = Name(ev);
 }
- std::transform(name.begin(), name.end(), name.begin(), CharToLower);
 return ""."" + name;
 }
 
",1346,280
"[Swift] Adds a format file and reformats the swift project (#6250)

* Formats files & adds licence

* Revert arrays

* Keeps array indentation as is

* Adds licence to code formatter

* Updates code generators"," class SwiftGenerator : public BaseGenerator {
 const std::string &file_name)
 : BaseGenerator(parser, path, file_name, """", ""_"", ""swift"") {
 namespace_depth = 0;
- code_.SetPadding("" "");
+ code_.SetPadding("" "");
 static const char *const keywords[] = {
 ""associatedtype"",
 ""class"",
 class SwiftGenerator : public BaseGenerator {
 code_.SetValue(""ACCESS"", ""_accessor"");
 code_.SetValue(""TABLEOFFSET"", ""VTOFFSET"");
 code_ += ""// "" + std::string(FlatBuffersGeneratedWarning());
- code_ += ""// swiftlint:disable all\n"";
+ code_ += ""// swiftlint:disable all"";
+ code_ += ""// swiftformat:disable all\n"";
 code_ += ""import FlatBuffers\n"";
 // Generate code for all the enum declarations.
 
",1347,280
"Add type annotation to unspecified array (#6264)

The lack of any type on the `ret` variable was causing our typescript compiler to complain."," export class Builder {
 * @returns list of offsets of each non null object
 */
 createObjectOffsetList(list: string[]): Offset[] {
- const ret = [];
+ const ret: number[] = [];
 
 for(let i = 0; i < list.length; ++i) {
 const val = list[i];
 export class Builder {
 this.createObjectOffsetList(list);
 return this.endVector();
 }
- }
\ No newline at end of file
+ }
",370,3
"Add --require-explicit-ids to require explicit ids (#6277)

* Add --require-explicit-ids to require explicit ids

We just got bit by a well intentioned developer forgetting that field
order by default is the field index. 3 people missed it in review.

I'm looking at ways to make it harder to mess up. We are requesting
that developers explicitly id all fields in tables. Automatic (opt in
for others) enforcement of this will help the effort succeed. This
patch adds a command line flag which lets the user require ids on all
fields in tables.

* Added docs to Compiler.md as well"," struct IDLOptions {
 
 MiniReflect mini_reflect;
 
+ // If set, require all fields in a table to be explicitly numbered.
+ bool require_explicit_ids;
+
 // The corresponding language bit will be set if a language is included
 // for code generation.
 unsigned long lang_to_generate;
 struct IDLOptions {
 filename_extension(),
 lang(IDLOptions::kJava),
 mini_reflect(IDLOptions::kNone),
+ require_explicit_ids(false),
 lang_to_generate(0),
 set_empty_strings_to_null(true),
 set_empty_vectors_to_null(true) {}
",747,89
Fixed FlexBufferBuilder asserting on duplicate keys," CheckedError Parser::ParseFlexBufferValue(flexbuffers::Builder *builder) {
 });
 ECHECK(err);
 builder->EndMap(start);
+ if (builder->HasDuplicateKeys())
+ return Error(""FlexBuffers map has duplicate keys"");
 break;
 }
 case '[': {
",3101,945
"[C++] Add ParseJson(), Parser(Parser&&), update fuzzers (#6284)

- add a new method ParseJson to minimize failures during fuzzing
- add default (conditional) move-constructor for Parser
- add a new monster_fuzzer
- switch fuzzers to C++17 and `test/cpp17` generated code"," namespace flatbuffers {
 #if (!defined(_MSC_VER) || _MSC_FULL_VER >= 180020827) && \
 (!defined(__GNUC__) || (__GNUC__ * 100 + __GNUC_MINOR__ >= 404)) || \
 defined(__clang__)
+ #define FLATBUFFERS_DEFAULT_DECLARATION
 #define FLATBUFFERS_DELETE_FUNC(func) func = delete;
 #else
 #define FLATBUFFERS_DELETE_FUNC(func) private: func;
",92,16
"[idl_parser] Unify parsing of NaN values read from .fbs and .json files (#6296)

This commit unifies parsing of NaN values read
from .fbs and .json files by converting them to unsigned NaN."," namespace flatbuffers {
 #if (!defined(_MSC_VER) || _MSC_FULL_VER >= 180020827) && \
 (!defined(__GNUC__) || (__GNUC__ * 100 + __GNUC_MINOR__ >= 404)) || \
 defined(__clang__)
- #define FLATBUFFERS_DEFAULT_DECLARATION
 #define FLATBUFFERS_DELETE_FUNC(func) func = delete;
 #else
 #define FLATBUFFERS_DELETE_FUNC(func) private: func;
 #endif
 
+#if (!defined(_MSC_VER) || _MSC_VER >= 1900) && \
+ (!defined(__GNUC__) || (__GNUC__ * 100 + __GNUC_MINOR__ >= 409)) || \
+ defined(__clang__)
+ #define FLATBUFFERS_DEFAULT_DECLARATION
+#endif
+
 // Check if we can use template aliases
 // Not possible if Microsoft Compiler before 2012
 // Possible is the language feature __cpp_alias_templates is defined well
",92,16
Add default to offset param of Python generated GetRootAs (#6312)," class PythonGenerator : public BaseGenerator {
 code += Indent + ""@classmethod\n"";
 code += Indent + ""def GetRootAs"";
 code += NormalizedName(struct_def);
- code += ""(cls, buf, offset):"";
+ code += ""(cls, buf, offset=0):"";
 code += ""\n"";
 code += Indent + Indent;
 code += ""n = flatbuffers.encode.Get"";
",1353,239
"[fuzzer] Fix mistakes in the `parser` and `scalar` fuzzers. (#6314)

The flatbuffers::Parser::Parse() isn't an idempotent method for schema parsing.
This commit removes a wrong for-loop that tried to check the same schema twice."," extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
 const uint8_t flags = data[0];
 // normalize to ascii alphabet
 const int extra_rep_number =
- std::max(5, (data[1] < '0' ? (data[1] - '0') : 0));
+ std::max(5, (data[1] > '0' ? (data[1] - '0') : 0));
 data += 2;
 size -= 2; // bypass
 
",262,61
"Set default initialSize for Builder to 0 (#6310)

* Set default initialSize for Builder to 0

* Change default size of builder to 1024.

This matches what the C++ and Java versions do."," class Builder(object):
 MAX_BUFFER_SIZE = 2**31
 ## @endcond
 
- def __init__(self, initialSize):
+ def __init__(self, initialSize=1024):
 """"""Initializes a Builder of size `initial_size`.
 
 The internal buffer is grown as needed.
",370,91
"[fuzzer] Rename fuzzing dictionaries for `oss-fuzz` (#6318)

This commit makes the names of fuzzing dictionaries the same as the target binary names.
Also it explicitly limits size of test inputs to prevent failures in `regex` and fuzzing time-outs.","
 
 namespace {
 
+static constexpr size_t kMinInputLength = 1;
+static constexpr size_t kMaxInputLength = 99000;
+
 static constexpr uint8_t flags_strict_json = 0x80;
 static constexpr uint8_t flags_skip_unexpected_fields_in_json = 0x40;
 static constexpr uint8_t flags_allow_non_utf8 = 0x20;
 extern ""C"" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
 
 const std::string original(reinterpret_cast<const char *>(data), size);
 auto input = std::string(original.c_str()); // until '\0'
- if (input.empty()) return 0;
+ if (input.size() < kMinInputLength || input.size() > kMaxInputLength)
+ return 0;
 
 flatbuffers::IDLOptions opts;
 opts.strict_json = (flags & flags_strict_json);
",69,9
"Add flatc option to inhibit all warnings #6005 (#6301)

* Fix C/C++ Create<Type>Direct with sorted vectors

If a struct has a key the vector has to be sorted. To sort the vector
you can't use ""const"".

* Changes due to code review

* Improve code readability

* Add generate of JSON schema to string to lib

* option indent_step is supported

* Remove unused variables

* Fix break in test

* Fix style to be consistent with rest of the code

* Add option --no-warnings to inhibit all warnings

* Fix order of member initialization

* Add documentation for --no-warnings"," struct IDLOptions {
 std::string proto_namespace_suffix;
 std::string filename_suffix;
 std::string filename_extension;
+ bool no_warnings;
 
 // Possible options for the more general generator below.
 enum Language {
 struct IDLOptions {
 cs_gen_json_serializer(false),
 filename_suffix(""_generated""),
 filename_extension(),
+ no_warnings(false),
 lang(IDLOptions::kJava),
 mini_reflect(IDLOptions::kNone),
 require_explicit_ids(false),
",753,89
[Python] Commit some orphan python genfile diffs. (#6325)," class ArrayTable(object):
 __slots__ = ['_tab']
 
 @classmethod
- def GetRootAsArrayTable(cls, buf, offset):
+ def GetRootAsArrayTable(cls, buf, offset=0):
 n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
 x = ArrayTable()
 x.Init(buf, n + offset)
",58,14
"Add vectorNumElements attribute to Builder for simpler vector creation. (#6328)

* Add vectorNumElements attribute to Builder for simpler vector creation.

This adds a default to EndVector which should simplify its use.

* Update tutorial to reflect new default arg in Python EndVector.

* Remove optional argument to Python EndVector.

* Add generated files.

* Unset Builder.vectorNumElems when not in use."," class TypeAliasesT(object):
 TypeAliasesStartV8Vector(builder, len(self.v8))
 for i in reversed(range(len(self.v8))):
 builder.PrependByte(self.v8[i])
- v8 = builder.EndVector(len(self.v8))
+ v8 = builder.EndVector()
 if self.vf64 is not None:
 if np is not None and type(self.vf64) is np.ndarray:
 vf64 = builder.CreateNumpyVector(self.vf64)
 class TypeAliasesT(object):
 TypeAliasesStartVf64Vector(builder, len(self.vf64))
 for i in reversed(range(len(self.vf64))):
 builder.PrependFloat64(self.vf64[i])
- vf64 = builder.EndVector(len(self.vf64))
+ vf64 = builder.EndVector()
 TypeAliasesStart(builder)
 TypeAliasesAddI8(builder, self.i8)
 TypeAliasesAddU8(builder, self.u8)
",209,60
Last public release from Computronix.,"
+""""""Define test environment.""""""
+
+import cx_Oracle
+import os
+import unittest
+
+def GetValue(name, label):
+ value = os.environ.get(""CX_ORACLE_"" + name)
+ if value is None:
+ value = raw_input(label + "": "")
+ return value
+
+USERNAME = GetValue(""USERNAME"", ""user name"")
+PASSWORD = GetValue(""PASSWORD"", ""password"")
+TNSENTRY = GetValue(""TNSENTRY"", ""TNS entry"")
+ARRAY_SIZE = int(GetValue(""ARRAY_SIZE"", ""array size""))
+
",13,2
"When copying the value of a variable, copy the return code as well."," static PyObject *Variable_ExternalCopy(
 if (targetVar->actualLength)
 targetVar->actualLength[targetPos] =
 sourceVar->actualLength[sourcePos];
+ if (targetVar->returnCode)
+ targetVar->returnCode[targetPos] =
+ sourceVar->returnCode[sourcePos];
 memcpy( (char*) targetVar->data + targetPos * targetVar->maxLength,
 (char*) sourceVar->data + sourcePos * sourceVar->maxLength,
 sourceVar->maxLength);
",846,231
Replaced all tabs with spaces.," static udt_VariableType vt_Date;
 // Return a Python date object given an Oracle date.
 //-----------------------------------------------------------------------------
 static PyObject *OracleDateToPythonDate(
- udt_VariableType *varType,// variable type
- OCIDate* value)// value to convert
+ udt_VariableType *varType, // variable type
+ OCIDate* value) // value to convert
 {
 ub1 hour, minute, second, month, day;
 sb2 year;
 static PyObject *OracleDateToPythonDate(
 // Return a Python date object given an Oracle date.
 //-----------------------------------------------------------------------------
 static PyObject *OracleNumberToPythonFloat(
- udt_Environment *environment,// environment
- OCINumber* value)// value to convert
+ udt_Environment *environment, // environment
+ OCINumber* value) // value to convert
 {
 double doubleValue;
 sword status;
",29,5
"Fixed support for native doubles and floats in Oracle 10g; added new type
NATIVE_FLOAT to allow specification of a variable of that specific type where
desired. Thanks to D.R. Boxhoorn for pointing out the fact that this was not
working properly when the arraysize was anything other than 1."," static int Variable_Check(
 object->ob_type == &g_BinaryVarType
 #ifdef ORACLE_9I
 || object->ob_type == &g_TimestampVarType
+#endif
+#ifdef SQLT_BFLOAT
+ || object->ob_type == &g_NativeFloatVarType
 #endif
 );
 }
 static udt_VariableType *Variable_TypeByPythonType(
 #endif
 if (type == (PyObject*) &g_CursorVarType)
 return &vt_Cursor;
+#ifdef SQLT_BFLOAT
+ if (type == (PyObject*) &g_NativeFloatVarType)
+ return &vt_NativeFloat;
+#endif
 
 PyErr_SetString(g_NotSupportedErrorException,
 ""Variable_TypeByPythonType(): unhandled data type"");
",849,235
"Free the row factory when the cursor is being freed; clear the row factory
when a new statement is prepared since it is very likely that the new statement
will not be compatible with the old and having to clear it manually each time
would be rather tedious."," static void Cursor_Free(
 Py_XDECREF(self->bindVariables);
 Py_XDECREF(self->fetchVariables);
 Py_XDECREF(self->connection);
+ Py_XDECREF(self->rowFactory);
 self->ob_type->tp_free((PyObject*) self);
 }
 
 static int Cursor_InternalPrepare(
 self->bindVariables = NULL;
 }
 
+ // clear row factory, if spplicable
+ Py_XDECREF(self->rowFactory);
+ self->rowFactory = NULL;
+
 // determine if statement is a query
 if (Cursor_GetStatementType(self) < 0)
 return -1;
",1381,311
Added support for autocommit mode as requested by Ian Kelly.," typedef struct {
 PyObject *dsn;
 PyObject *version;
 ub4 commitMode;
+ int autocommit;
 } udt_Connection;
 
 
 static PyMemberDef g_ConnectionMembers[] = {
 { ""password"", T_OBJECT, offsetof(udt_Connection, password), READONLY },
 { ""dsn"", T_OBJECT, offsetof(udt_Connection, dsn), READONLY },
 { ""tnsentry"", T_OBJECT, offsetof(udt_Connection, dsn), READONLY },
+ { ""autocommit"", T_INT, offsetof(udt_Connection, autocommit), 0 },
 { NULL }
 };
 
",795,140
"Add global statements simply to make running the setup script within another
setup script (cx_OracleDBATools) happy."," class Distribution(distutils.dist.Distribution):
 class build(distutils.command.build.build):
 
 def finalize_options(self):
+ global distutils
+ global os
+ global sys
+ global oracleVersion
 platSpecifier = "".%s-%s-%s"" % \
 (distutils.util.get_platform(), sys.version[0:3],
 oracleVersion)
",173,6
"Make the search for the lib32 and lib64 directories automatic for all
platforms."," else:
 for i in range(len(includeDirs)):
 includeDirs[i] = os.path.join(oracleHome, includeDirs[i])
 libPath = os.path.join(oracleHome, ""lib"")
- if sys.platform == ""sunos5"" and sys.maxint > 2147483647:
- libPath = os.path.join(oracleHome, ""lib64"")
+ if sys.maxint == 2 ** 31 - 1:
+ alternatePath = os.path.join(oracleHome, ""lib32"")
+ else:
+ alternatePath = os.path.join(oracleHome, ""lib64"")
+ if os.path.exists(alternatePath):
+ libPath = alternatePath
 libDirs = [libPath, oracleHome]
 libs = [""clntsh""]
 
",182,6
"Use qualified wildcards as otherwise Windows includes files from the .svn
directories, for example. Also remove dependency on existing MANIFEST file in
the setup script."," dataFiles = None
 if sys.platform in (""win32"", ""cygwin""):
 baseName = ""cx_Oracle-doc""
 dataFiles = [ (baseName, [ ""LICENSE.TXT"", ""README.TXT"", ""HISTORY.txt""]) ]
- allFiles = []
- for fileName in open(""MANIFEST"").readlines():
- allFiles.append(fileName.strip())
 for dir in (""html"", ""test""):
 files = []
- for name in allFiles:
- if name.startswith(dir):
- files.append(name)
- dataFiles.append( (""%s/%s"" % (baseName, dir), files) )
+ fullDirName = ""%s/%s"" % (baseName,dir)
+ for name in os.listdir(dir):
+ if name.startswith("".""):
+ continue
+ fullName = ""%s/%s"" % (dir, name)
+ files.append(fullName)
+ dataFiles.append((fullDirName, files))
 
 # define the list of files to be included as documentation for bdist_rpm
 docFiles = ""LICENSE.txt README.txt HISTORY.txt html test""
",184,11
The bdist_msi command is only available in Python 2.5 and up.," Unix platforms
 
 import sys
 
-if sys.platform == ""win32"":
+if sys.platform == ""win32"" and sys.version_info[:2] >= (2, 5):
 import distutils.command.bdist_msi
 import distutils.command.bdist_wininst
 import distutils.command.build
 class build(distutils.command.build.build):
 commandClasses = dict(build = build)
 
 # tweak the Windows installer names to include the Oracle version
-if sys.platform == ""win32"":
+if sys.platform == ""win32"" and sys.version_info[:2] >= (2, 5):
 
 class bdist_msi(distutils.command.bdist_msi.bdist_msi):
 
",184,11
"Prevent error ""ORA-24333: zero iteration count"" from taking place as requested
by Andreas Mock."," static PyObject *Cursor_ExecuteMany(
 if (Cursor_PerformBind(self) < 0)
 return NULL;
 
- // execute the statement
- if (Cursor_InternalExecute(self, PyList_GET_SIZE(listOfArguments)) < 0)
- return NULL;
+ // execute the statement, but only if the number of rows is greater than
+ // zero since Oracle raises an error otherwise
+ if (numRows > 0) {
+ if (Cursor_InternalExecute(self, numRows) < 0)
+ return NULL;
+ }
 
 Py_INCREF(Py_None);
 return Py_None;
",1413,316
"Added support for connection.ping() which can be used to test whether or not a
connection is still active or not.","
 #ifdef OCI_ATTR_MODULE
 #define ORACLE_10G
 #endif
+#ifdef OCI_MAJOR_VERSION
+#define ORACLE_10GR2
+#endif
 #if OCI_FNCODE_STMTRELEASE
 #define ORACLE_9I
 #endif
",292,75
"Added support for starting up and shutting down the database using the new
methods available in Oracle 10g Release 2 and higher."," void initcx_Oracle(void)
 ADD_OCI_CONSTANT(SPOOL_ATTRVAL_NOWAIT)
 ADD_OCI_CONSTANT(SPOOL_ATTRVAL_FORCEGET)
 #endif
+#ifdef ORACLE_10GR2
+ ADD_OCI_CONSTANT(PRELIM_AUTH)
+ ADD_OCI_CONSTANT(DBSHUTDOWN_ABORT)
+ ADD_OCI_CONSTANT(DBSHUTDOWN_FINAL)
+ ADD_OCI_CONSTANT(DBSHUTDOWN_IMMEDIATE)
+ ADD_OCI_CONSTANT(DBSHUTDOWN_TRANSACTIONAL)
+ ADD_OCI_CONSTANT(DBSHUTDOWN_TRANSACTIONAL_LOCAL)
+#endif
 }
 
",309,77
Added some samples for more advanced techniques.," dataFiles = None
 if sys.platform in (""win32"", ""cygwin""):
 baseName = ""cx_Oracle-doc""
 dataFiles = [ (baseName, [ ""LICENSE.TXT"", ""README.TXT"", ""HISTORY.txt""]) ]
- for dir in (""html"", ""test""):
+ for dir in (""html"", ""samples"", ""test""):
 files = []
 fullDirName = ""%s/%s"" % (baseName,dir)
 for name in os.listdir(dir):
 if sys.platform in (""win32"", ""cygwin""):
 dataFiles.append((fullDirName, files))
 
 # define the list of files to be included as documentation for bdist_rpm
-docFiles = ""LICENSE.txt README.txt HISTORY.txt html test""
+docFiles = ""LICENSE.txt README.txt HISTORY.txt html samples test""
 
 # try to determine the ORACLE_HOME
 oracleHome = os.environ.get(""ORACLE_HOME"")
",199,12
Add all metadata into the setup configuration script.," if sys.platform == ""win32"" and sys.version_info[:2] >= (2, 5):
 
 commandClasses[""bdist_wininst""] = bdist_wininst
 
+# define classifiers for the package index
+classifiers = [
+ ""Development Status :: 6 - Mature"",
+ ""Intended Audience :: Developers"",
+ ""License :: OSI Approved :: Python Software Foundation License"",
+ ""Natural Language :: English"",
+ ""Operating System :: OS Independent"",
+ ""Programming Language :: C"",
+ ""Programming Language :: Python"",
+ ""Topic :: Database""
+]
 
 # setup the extension
 extension = Extension(
 setup(
 author = ""Anthony Tuininga"",
 author_email = ""anthony.tuininga@gmail.com"",
 url = ""http://cx-oracle.sourceforge.net"",
- ext_modules = [extension])
+ ext_modules = [extension],
+ keywords = ""Oracle"",
+ license = ""Python Software Foundation License"",
+ classifiers = classifiers)
 
",212,12
Remove duplicate keyword argument.," setup(
 version = BUILD_VERSION,
 distclass = Distribution,
 description = ""Python interface to Oracle"",
- license = ""See LICENSE.txt"",
 data_files = dataFiles,
 cmdclass = commandClasses,
 options = dict(bdist_rpm = dict(doc_files = docFiles)),
",211,12
"Use cx_Oracle.InterfaceError rather than the builtin RuntimeError as requested
by Luke Mewburn since the error is specific to Oracle and someone attempting to
catch any exception cannot simply use cx_Oracle.Error."," static udt_Environment *Environment_New(
 NULL, NULL, 0, NULL);
 if (!environment->handle) {
 Py_DECREF(environment);
- PyErr_SetString(PyExc_RuntimeError,
+ PyErr_SetString(g_InterfaceErrorException,
 ""Unable to acquire Oracle environment handle"");
 return NULL;
 }
",129,20
"Allow the password to be overwritten by a new value as requested by Alex
VanderWoude; this value is retained as a convenience to the user and not used
by anything in the module; if changed externally it may be convenient to keep
this copy up to date."," static PyMethodDef g_ConnectionMethods[] = {
 //-----------------------------------------------------------------------------
 static PyMemberDef g_ConnectionMembers[] = {
 { ""username"", T_OBJECT, offsetof(udt_Connection, username), READONLY },
- { ""password"", T_OBJECT, offsetof(udt_Connection, password), READONLY },
+ { ""password"", T_OBJECT, offsetof(udt_Connection, password), 0 },
 { ""dsn"", T_OBJECT, offsetof(udt_Connection, dsn), READONLY },
 { ""tnsentry"", T_OBJECT, offsetof(udt_Connection, dsn), READONLY },
 { ""autocommit"", T_INT, offsetof(udt_Connection, autocommit), 0 },
",920,164
"When dropping a connection from the pool, ignore any errors that occur during
the rollback; unfortunately, Oracle decides to commit data even when dropping
a connection from the pool instead of rolling it back so the attempt still
has to be made."," static PyObject *SessionPool_InternalRelease(
 return NULL;
 }
 
- // release the connection
+ // attempt a rollback but if dropping the connection from the pool
+ // ignore the error
 Py_BEGIN_ALLOW_THREADS
 status = OCITransRollback(connection->handle,
 connection->environment->errorHandle, OCI_DEFAULT);
 Py_END_ALLOW_THREADS
 if (Environment_CheckForError(connection->environment, status,
- ""SessionPool_Release(): rollback"") < 0)
- return NULL;
+ ""SessionPool_Release(): rollback"") < 0) {
+ if (mode != OCI_SESSRLS_DROPSESS)
+ return NULL;
+ PyErr_Clear();
+ }
+
+ // release the connection
 Py_BEGIN_ALLOW_THREADS
 status = OCISessionRelease(connection->handle,
 connection->environment->errorHandle, NULL, 0, mode);
",333,42
"Cygwin is on Windows so should be treated in the same way as noted by Matthew
Cahn."," class Distribution(distutils.dist.Distribution):
 def __init__(self, attrs):
 global oracleHome
 distutils.dist.Distribution.__init__(self, attrs)
- if sys.platform == ""win32"":
+ if sys.platform in (""win32"", ""cygwin""):
 subDir = ""bin""
 filesToCheck = [
 (""11g"", ""oraocci11.dll""),
",235,13
"Translated some error codes to OperationalError as requested by Matthew
Harriger; translated if/elseif/else logic to switch statement to make it more
readable and to allow for additional translation if desired."," static void Environment_RaiseError(
 
 error = Error_New(environment, context);
 if (error) {
- if (error->errorNumber == 1 ||
- (error->errorNumber >= 2290 && error->errorNumber <= 2292))
- exceptionType = g_IntegrityErrorException;
- else exceptionType = g_DatabaseErrorException;
+ switch (error->errorNumber) {
+ case 1:
+ case 2290:
+ case 2291:
+ case 2292:
+ exceptionType = g_IntegrityErrorException;
+ break;
+ case 1012:
+ case 1033:
+ case 1034:
+ case 1089:
+ case 3113:
+ case 3114:
+ case 12203:
+ case 12500:
+ case 12571:
+ exceptionType = g_OperationalErrorException;
+ break;
+ default:
+ exceptionType = g_DatabaseErrorException;
+ break;
+ }
 PyErr_SetObject(exceptionType, (PyObject*) error);
 Py_DECREF(error);
 }
",147,30
"Set the default array size to 50 instead of 1 as the DB API suggests because
the performance difference is so drastic and many people have recommended that
the default be changed."," static int Cursor_Init(
 Py_INCREF(connection);
 self->connection = connection;
 self->environment = connection->environment;
- self->arraySize = 1;
+ self->arraySize = 50;
+ self->fetchArraySize = 50;
 self->bindArraySize = 1;
 self->statementType = -1;
 self->outputSize = -1;
",1433,321
Fix support for packaging documentation after switching to reST format.," dataFiles = None
 if sys.platform in (""win32"", ""cygwin""):
 baseName = ""cx_Oracle-doc""
 dataFiles = [ (baseName, [ ""LICENSE.TXT"", ""README.TXT"", ""HISTORY.txt""]) ]
- for dir in (""html"", ""samples"", ""test""):
+ for dir in (""html"", ""html/_static"", ""samples"", ""test""):
 files = []
- fullDirName = ""%s/%s"" % (baseName,dir)
+ fullDirName = ""%s/%s"" % (baseName, dir)
 for name in os.listdir(dir):
 if name.startswith("".""):
 continue
+ if os.path.isdir(os.path.join(dir, name)):
+ continue
 fullName = ""%s/%s"" % (dir, name)
 files.append(fullName)
 dataFiles.append((fullDirName, files))
",237,13
Added line to make it easier to support setup tools if desired.," from distutils.core import setup
 from distutils.errors import DistutilsSetupError
 from distutils.extension import Extension
 
+# if setuptools is desired, uncomment this line
+#from setuptools import setup, Extension
+
 # define build constants
 BUILD_VERSION = ""4.4a1""
 
",237,13
"Attempt to use setuptools if possible and fall back to normal distutils if
setuptools is not found or installed."," import distutils.util
 import os
 import sys
 
-from distutils.core import setup
 from distutils.errors import DistutilsSetupError
-from distutils.extension import Extension
 
-# if setuptools is desired, uncomment this line
-#from setuptools import setup, Extension
+# if setuptools is detected, use it to add support for eggs
+try:
+ from setuptools import setup, Extension
+except:
+ from distutils.core import setup
+ from distutils.extension import Extension
 
 # define build constants
 BUILD_VERSION = ""4.4a1""
",240,13
"Added support for setting CLIENT_DRIVER in V$SESSION_CONNECT_INFO in Oracle 11g
and higher."," static int Connection_Connect(
 return -1;
 }
 
+#ifdef OCI_ATTR_DRIVER_NAME
+printf(""setting driver name to %s\n"", DRIVER_NAME);
+ status = OCIAttrSet(self->sessionHandle, OCI_HTYPE_SESSION,
+ (text*) DRIVER_NAME, strlen(DRIVER_NAME), OCI_ATTR_DRIVER_NAME,
+ self->environment->errorHandle);
+ if (Environment_CheckForError(self->environment, status,
+ ""Connection_Connect(): set driver name"") < 0)
+ return -1;
+
+#endif
+
 // set the session handle on the service context handle
 status = OCIAttrSet(self->handle, OCI_HTYPE_SVCCTX,
 self->sessionHandle, 0, OCI_ATTR_SESSION,
",927,166
Remove debugging code.," static int Connection_Connect(
 }
 
 #ifdef OCI_ATTR_DRIVER_NAME
-printf(""setting driver name to %s\n"", DRIVER_NAME);
 status = OCIAttrSet(self->sessionHandle, OCI_HTYPE_SESSION,
 (text*) DRIVER_NAME, strlen(DRIVER_NAME), OCI_ATTR_DRIVER_NAME,
 self->environment->errorHandle);
",926,166
Preparing to release 4.4.," except:
 from distutils.extension import Extension
 
 # define build constants
-BUILD_VERSION = ""4.4a1""
+BUILD_VERSION = ""4.4""
 
 # define the list of files to be included as documentation for Windows
 dataFiles = None
",240,13
"Added proper detection for the instant client on Mac OS X as recommended by
Martijn Pieters."," class Distribution(distutils.dist.Distribution):
 (""9i"", ""oraclient9.dll""),
 (""8i"", ""oraclient8.dll"")
 ]
+ elif sys.platform == ""darwin"":
+ subDir = ""lib""
+ filesToCheck = [
+ (""11g"", ""libclntsh.dylib.11.1""),
+ (""10g"", ""libclntsh.dylib.10.1""),
+ (""9i"", ""libclntsh.dylib.9.0""),
+ (""8i"", ""libclient8.a"")
+ ]
 else:
 subDir = ""lib""
 filesToCheck = [
",250,14
"Removed support for Oracle 8i since Oracle support for it was dropped long
ago and adding support for Oracle 11g features would be very difficult
while attempting to retain Oracle 8i support."," static int CursorVar_SetValue(
 Py_INCREF(value);
 PyList_SET_ITEM(var->cursors, pos, value);
 cursor = (udt_Cursor *) value;
-#ifdef ORACLE_9I
 if (!cursor->isOwned) {
 if (Cursor_FreeHandle(cursor, 1) < 0)
 return -1;
 static int CursorVar_SetValue(
 if (Cursor_AllocateHandle(cursor) < 0)
 return -1;
 }
-#endif
 var->data[pos] = cursor->handle;
 cursor->statementType = -1;
 return 0;
",117,12
"Inital cut of support for DRCP and events mode as requested by Christopher
Jones."," static PyTypeObject g_EnvironmentType = {
 // Create a new environment object.
 //-----------------------------------------------------------------------------
 static udt_Environment *Environment_New(
- int threaded) // use threaded mode?
+ int threaded, // use threaded mode?
+ int events) // use events mode?
 {
 udt_Environment *environment;
 sword status;
 static udt_Environment *Environment_New(
 mode = OCI_OBJECT;
 if (threaded)
 mode |= OCI_THREADED;
+#ifdef ORACLE_11G
+ if (events)
+ mode |= OCI_EVENTS;
+#endif
 
 // create the environment handle
 status = OCIEnvCreate(&environment->handle, mode, NULL, NULL,
",150,32
"As requested by Helge Tesdal, allow an output type handler to be specified
at the connection and cursor levels. This handler will be called for each
variable being defined with the parameters cursor, name, defaultType, size,
precision and scale and expects to have a variable of the correct type
returned or None to indicate that default processing should take place."," typedef struct {
 OCISession *sessionHandle;
 udt_Environment *environment;
 udt_SessionPool *sessionPool;
+ PyObject *outputTypeHandler;
 PyObject *username;
 PyObject *password;
 PyObject *dsn;
 static PyMemberDef g_ConnectionMembers[] = {
 { ""dsn"", T_OBJECT, offsetof(udt_Connection, dsn), READONLY },
 { ""tnsentry"", T_OBJECT, offsetof(udt_Connection, dsn), READONLY },
 { ""autocommit"", T_INT, offsetof(udt_Connection, autocommit), 0 },
+ { ""outputtypehandler"", T_OBJECT,
+ offsetof(udt_Connection, outputTypeHandler), 0 },
 { NULL }
 };
 
",1009,183
"Include the ""cannot insert null value"" in the list of errors that are treated
as integrity errors as requested by Matt Boersma."," static void Environment_RaiseError(
 if (error) {
 switch (error->errorNumber) {
 case 1:
+ case 1400:
 case 2290:
 case 2291:
 case 2292:
",151,33
"No need to reset the extraLinkArgs and doing so prevents simple modification
where desired as expressed by Christian Zagrodnick."," if sys.platform == ""aix4"":
 extraCompileArgs.append(""-qcpluscmt"")
 elif sys.platform == ""cygwin"":
 extraCompileArgs.append(""-mno-cygwin"")
-elif sys.platform == ""darwin"":
- extraLinkArgs = None
 
 # force the inclusion of an RPATH linker directive if desired; this will
 # eliminate the need for setting LD_LIBRARY_PATH but it also means that this
",245,14
Added support for fixed char and old style varchar attribute values.," static PyObject *ExternalObjectVar_ConvertToPython(
 }
 
 switch (typeCode) {
+ case OCI_TYPECODE_CHAR:
+ case OCI_TYPECODE_VARCHAR:
 case OCI_TYPECODE_VARCHAR2:
 stringValue = OCIStringPtr(environment->handle,
 * (OCIString**) value);
",205,30
"Merged 9i specific setup into standard setup since Oracle 8i support is no
longer required; change tabs to spaces; add test for fixed char data types."," class TestObjectVar(BaseTestCase):
 [ ('INTCOL', cx_Oracle.NUMBER, 10, 22, 9, 0, 0),
 ('OBJECTCOL', cx_Oracle.OBJECT, -1, 2000, 0, 0, 1),
 ('ARRAYCOL', cx_Oracle.OBJECT, -1, 2000, 0, 0, 1) ])
- self.__TestData(1, (1, 'First row',
+ self.__TestData(1, (1, 'First row', 'First ',
 cx_Oracle.Timestamp(2007, 3, 6, 0, 0, 0)), [5, 10, None, 20])
 self.__TestData(2, None, [3, None, 9, 12, 15])
- self.__TestData(3, (3, 'Third row',
+ self.__TestData(3, (3, 'Third row', 'Third ',
 cx_Oracle.Timestamp(2007, 6, 21, 0, 0, 0)), None)
 
",33,2
Added support for timestamp attributes in objects.," static PyObject *ExternalObjectVar_ConvertToPython(
 return OracleNumberToPythonFloat(environment, (OCINumber*) value);
 case OCI_TYPECODE_DATE:
 return OracleDateToPythonDate(&vt_DateTime, (OCIDate*) value);
+ case OCI_TYPECODE_TIMESTAMP:
+ return OracleTimestampToPythonDate(environment,
+ * (OCIDateTime**) value);
 case OCI_TYPECODE_OBJECT:
 return ExternalObjectVar_New(referencedObject, subType, value,
 indicator, 0);
",208,31
"Use a cx_Oracle.Error instance rather than a string to hold the error as
requested by Helge Tesdal."," static void Environment_RaiseError(
 PyObject *exceptionType;
 udt_Error *error;
 
- error = Error_New(environment, context);
+ error = Error_New(environment, context, 1);
 if (error) {
 switch (error->errorNumber) {
 case 1:
",151,33
"Account for the situation where the directory passed in is the binary diretory
but the libraries are in a parallel directory."," def CheckOracleHome(directoryToCheck):
 oracleLibDir = os.path.join(directoryToCheck, subDir)
 oracleVersion = version
 return True
+ dirName = os.path.dirname(directoryToCheck)
+ fileName = os.path.join(dirName, subDir, baseFileName)
+ if os.path.exists(fileName):
+ oracleHome = dirName
+ oracleLibDir = os.path.join(dirName, subDir)
+ oracleVersion = version
+ return True
 oracleHome = oracleVersion = oracleLibDir = None
 return False
 
",252,15
"Avoid overwriting the Oracle home value with None by the method that determines
if a valid Oracle home has been specified."," def CheckOracleHome(directoryToCheck):
 return False
 
 # try to determine the Oracle home
-oracleHome = os.environ.get(""ORACLE_HOME"")
-if oracleHome is not None:
- if not CheckOracleHome(oracleHome):
+userOracleHome = os.environ.get(""ORACLE_HOME"")
+if userOracleHome is not None:
+ if not CheckOracleHome(userOracleHome):
 messageFormat = ""Oracle home (%s) does not refer to an "" \
 ""9i, 10g or 11g installation.""
- raise DistutilsSetupError, messageFormat % oracleHome
+ raise DistutilsSetupError, messageFormat % userOracleHome
 else:
 for path in os.environ[""PATH""].split(os.pathsep):
 if CheckOracleHome(path):
",252,15
"Added support for returning unicode values for nchar and nvarchar data and
for binding unicode. Thanks to Amaury Forgeot d'Arc for the initial patch."," moduleNames = [
 ""ObjectVar"",
 ""SessionPool"",
 ""StringVar"",
- ""TimestampVar""
+ ""TimestampVar"",
+ ""UnicodeVar""
 ]
 
 class BaseTestCase(unittest.TestCase):
",55,2
Verify that the variable returned can support the fetch.," static udt_Variable *Variable_NewByOutputTypeHandler(
 ub4 maxLength, // maximum length of variable
 unsigned numElements) // number of elements
 {
+ udt_Variable *var;
 PyObject *result;
 ub4 nameLength;
 sb2 precision;
 static udt_Variable *Variable_NewByOutputTypeHandler(
 return Variable_New(cursor, numElements, varType, maxLength);
 }
 
- // otherwise, return the result, ensuring it is a variable first
+ // otherwise, verify that the result is an actual variable
 if (!Variable_Check(result)) {
 Py_DECREF(result);
 PyErr_SetString(PyExc_TypeError,
 ""expecting variable from output type handler"");
 return NULL;
 }
- return (udt_Variable*) result;
+
+ // verify that the array size is sufficient to handle the fetch
+ var = (udt_Variable*) result;
+ if (var->allocatedElements < cursor->fetchArraySize) {
+ Py_DECREF(result);
+ PyErr_SetString(PyExc_TypeError,
+ ""expecting variable with array size large enough for fetch"");
+ return NULL;
+ }
+
+ return var;
 }
 
 
",955,257
Add sample code for returning all strings as unicode strings.,"
+#------------------------------------------------------------------------------
+# ReturnUnicode.py
+# Returns all strings as unicode. This also demonstrates the use of an output
+# type handler to change the way in which data is returned from a cursor.
+#------------------------------------------------------------------------------
+
+import cx_Oracle
+
+def OutputTypeHandler(cursor, name, defaultType, size, precision, scale):
+ if defaultType in (cx_Oracle.STRING, cx_Oracle.FIXED_CHAR):
+ return cursor.var(unicode, size, cursor.arraysize)
+
+connection = cx_Oracle.Connection(""cx_Oracle/password"")
+connection.outputtypehandler = OutputTypeHandler
+cursor = connection.cursor()
+cursor.execute(""select * from teststrings"")
+for row in cursor:
+ print ""Row:"", row
+
",10,2
Properly free the encoded string.," static int StringVar_SetValue(
 var->actualLength[pos] = actualLength;
 if (bufferSize)
 memcpy(var->data + var->maxLength * pos, buffer, bufferSize);
+ Py_XDECREF(encodedString);
 
 return 0;
 }
",348,21
"Use Py_TYPE to determine the type of an object rather than referencing the
attribute directly as suggested by Amauary Forgeot d'Arc."," static void Connection_Free(
 Py_XDECREF(self->password);
 Py_XDECREF(self->dsn);
 Py_XDECREF(self->version);
- self->ob_type->tp_free((PyObject*) self);
+ Py_TYPE(self)->tp_free((PyObject*) self);
 }
 
 
 static PyObject *Connection_Repr(
 {
 PyObject *module, *name, *result;
 
- if (GetModuleAndName(connection->ob_type, &module, &name) < 0)
+ if (GetModuleAndName(Py_TYPE(connection), &module, &name) < 0)
 return NULL;
 if (connection->username && connection->username != Py_None &&
 connection->dsn && connection->dsn != Py_None)
",1019,189
"Use macro PyVarObject_HEAD_INIT as suggested by Amaury Forgeot d'Arc in order
to facilitate migration to Python 3.0."," static PyGetSetDef g_ConnectionCalcMembers[] = {
 // declaration of Python type ""Connection""
 //-----------------------------------------------------------------------------
 static PyTypeObject g_ConnectionType = {
- PyObject_HEAD_INIT(NULL)
- 0, // ob_size
+ PyVarObject_HEAD_INIT(NULL, 0)
 ""cx_Oracle.Connection"", // tp_name
 sizeof(udt_Connection), // tp_basicsize
 0, // tp_itemsize
",1018,189
"Make a base type for all variables so that the attributes and methods are
shared without having to specify such; remove references to methods that get
the attributes and methods dynamically since these are deprecated in Python 2.6
and above. Thanks to Amaury Forgeot d'Arc for the initial patch."," static PyTypeObject g_CursorVarType = {
 ""cx_Oracle.CURSOR"", // tp_name
 sizeof(udt_CursorVar), // tp_basicsize
 0, // tp_itemsize
- (destructor) Variable_Free, // tp_dealloc
+ 0, // tp_dealloc
 0, // tp_print
 0, // tp_getattr
 0, // tp_setattr
 0, // tp_compare
- (reprfunc) Variable_Repr, // tp_repr
+ 0, // tp_repr
 0, // tp_as_number
 0, // tp_as_sequence
 0, // tp_as_mapping
 0, // tp_hash
 0, // tp_call
 0, // tp_str
- (getattrofunc) Variable_GetAttr, // tp_getattro
+ 0, // tp_getattro
 0, // tp_setattro
 0, // tp_as_buffer
 Py_TPFLAGS_DEFAULT, // tp_flags
",116,12
"Make use of struct.calcsize rather than sys.maxint which is dropped in Python
3.0."," Unix platforms
 
 """"""
 
-import sys
-
 import distutils.command
 try:
 import distutils.command.bdist_msi
 import distutils.command.build
 import distutils.dist
 import distutils.util
 import os
+import struct
 import sys
 
 from distutils.errors import DistutilsSetupError
 else:
 if not includeDirs:
 raise DistutilsSetupError(""cannot locate Oracle include files"")
 libPath = os.path.join(oracleHome, ""lib"")
- if sys.maxint == 2 ** 31 - 1:
+ if struct.calcsize(""i"") == 4:
 alternatePath = os.path.join(oracleHome, ""lib32"")
 else:
 alternatePath = os.path.join(oracleHome, ""lib64"")
",257,15
"Added support for specifying an input type handler to control what kind of
variable is created and eliminated the leak when an output type handler would
be specified."," typedef struct {
 OCISession *sessionHandle;
 udt_Environment *environment;
 udt_SessionPool *sessionPool;
+ PyObject *inputTypeHandler;
 PyObject *outputTypeHandler;
 PyObject *username;
 PyObject *password;
 static PyMemberDef g_ConnectionMembers[] = {
 { ""dsn"", T_OBJECT, offsetof(udt_Connection, dsn), READONLY },
 { ""tnsentry"", T_OBJECT, offsetof(udt_Connection, dsn), READONLY },
 { ""autocommit"", T_INT, offsetof(udt_Connection, autocommit), 0 },
+ { ""inputtypehandler"", T_OBJECT,
+ offsetof(udt_Connection, inputTypeHandler), 0 },
 { ""outputtypehandler"", T_OBJECT,
 offsetof(udt_Connection, outputTypeHandler), 0 },
 { NULL }
 static void Connection_Free(
 Py_XDECREF(self->password);
 Py_XDECREF(self->dsn);
 Py_XDECREF(self->version);
+ Py_XDECREF(self->inputTypeHandler);
+ Py_XDECREF(self->outputTypeHandler);
 Py_TYPE(self)->tp_free((PyObject*) self);
 }
 
",1023,189
Fix reference to input type handler.," static udt_Variable *Variable_NewByValue(
 if (cursor->inputTypeHandler && cursor->inputTypeHandler != Py_None)
 return Variable_NewByInputTypeHandler(cursor, cursor->inputTypeHandler,
 value, numElements);
- if (cursor->connection->outputTypeHandler &&
- cursor->connection->outputTypeHandler != Py_None)
+ if (cursor->connection->inputTypeHandler &&
+ cursor->connection->inputTypeHandler != Py_None)
 return Variable_NewByInputTypeHandler(cursor,
 cursor->connection->inputTypeHandler, value, numElements);
 return Variable_DefaultNewByValue(cursor, value, numElements);
",1039,268
"To be consistent with the output converter always call the input converter
even if the value coming is is null."," static int Variable_SetSingleValue(
 }
 
 // convert value, if necessary
- if (value != Py_None && var->inConverter && var->inConverter != Py_None) {
+ if (var->inConverter && var->inConverter != Py_None) {
 convertedValue = PyObject_CallFunctionObjArgs(var->inConverter, value,
 NULL);
 if (!convertedValue)
",1039,267
"Expose the DATETIME variable type properly instead of using the return value
type; thanks to Amaury Forgeot d'Arc for pointing out this discrepancy."," static PyObject *Cursor_ItemDescriptionHelper(
 }
 else displaySize = 127;
 } else if (type == (PyObject*) &g_DateTimeVarType) {
-#ifdef NATIVE_DATETIME
- type = (PyObject*) PyDateTimeAPI->DateTimeType;
-#else
- type = (PyObject*) &g_ExternalDateTimeVarType;
-#endif
 displaySize = 23;
 } else {
 displaySize = -1;
",1444,313
"If the variable creation fails, don't use the result!"," static PyObject *Cursor_Var(
 
 // create the variable
 var = Variable_New(self, arraySize, varType, size);
+ if (!var)
+ return NULL;
 Py_XINCREF(inConverter);
 var->inConverter = inConverter;
 Py_XINCREF(outConverter);
",1446,314
"First cut at adding support for full unicode which is required by Python 3 but
the code is structured so that this can be done with Python 2.x as well if
desired; the only thing currently working is the determination of error
messages."," static udt_Environment *Environment_New(
 #endif
 
 // create the environment handle
- status = OCIEnvCreate(&environment->handle, mode, NULL, NULL,
- NULL, NULL, 0, NULL);
+ status = OCIEnvNlsCreate(&environment->handle, mode, NULL, NULL, NULL,
+ NULL, 0, NULL, CXORA_CHARSETID, CXORA_CHARSETID);
 if (!environment->handle) {
 Py_DECREF(environment);
 PyErr_SetString(g_InterfaceErrorException,
 static void Environment_RaiseError(
 
 error = Error_New(environment, context, 1);
 if (error) {
- switch (error->errorNumber) {
+ switch (error->code) {
 case 1:
 case 1400:
 case 2290:
",150,33
"Explicitly drop support for versions earlier than Python 2.3 with the advent
of Python 2.6."," static int Cursor_Call(
 if (i > 0)
 *ptr++ = ',';
 ptr += sprintf(ptr, "":%d"", i + offset + 1);
-#if (PY_VERSION_HEX >= 0x02030000)
 if (PyBool_Check(PySequence_Fast_GET_ITEM(arguments, i)))
 ptr += sprintf(ptr, "" = 1"");
-#endif
 }
 strcpy(ptr, ""); end;"");
 Py_DECREF(arguments);
",1446,313
"Added support for establishing connections to Oracle using Unicode while
retaining support for establishing connections using ASCII strings."," typedef int Py_ssize_t;
 (type)->tp_base = &g_BaseVarType; \
 MAKE_TYPE_READY(type)
 
-// define macros for handling unicode
-#ifdef WITH_UNICODE
- #define CXORA_CHARSETID OCI_UTF16ID
- #define CXORA_ERROR_TEXT_LENGTH 2048
- #ifdef Py_UNICODE_WIDE
- #define CXORA_TO_STRING_OBJ(buffer, chars) \
- PyUnicode_DecodeUTF16(buffer, (chars) * 2, NULL, NULL)
- #else
- #define CXORA_TO_STRING_OBJ(buffer, chars) \
- PyUnicode_FromUnicode((Py_UNICODE*) (buffer), chars)
- #endif
-#else
- #define CXORA_CHARSETID 0
- #define CXORA_ERROR_TEXT_LENGTH 1024
- #define CXORA_TO_STRING_OBJ(buffer, chars) \
- PyString_FromStringAndSize(buffer, chars)
-#endif
-
 // define macros to get the build version as a string and the driver name
 #define xstr(s) str(s)
 #define str(s) #s
 static int GetModuleAndName(
 }
 
 
+#include ""StringUtils.c""
 #include ""Environment.c""
 #include ""SessionPool.c""
 
",289,47
Further work on supporting Unicode.," static udt_Error *Error_New(
  if (errorText[len] == 0 && errorText[len + 1] == 0)
  break;
  }
- error->message = CXORA_TO_STRING_OBJ(errorText, len / 2);
+ error->message = CXORA_TO_STRING_OBJ(errorText, len);
 #else
 error->message = PyString_FromString(errorText);
 #endif
",105,14
"Continued work on Unicode support; added new test cases for full unicode
support within Python 2.x; move away from character semantics which Oracle is
deprecating anyway to byte semantics which should hopefully eliminate the
problem with a backend character set of UTF-8."," static udt_Environment *Environment_New(
 return NULL;
 environment->handle = NULL;
 environment->errorHandle = NULL;
+#ifdef WITH_UNICODE
+ environment->maxBytesPerCharacter = 2;
+#else
 environment->maxBytesPerCharacter = 1;
+#endif
 environment->fixedWidth = 1;
 environment->maxStringBytes = MAX_STRING_CHARS;
 
 static udt_Environment *Environment_New(
 }
 
 // acquire max bytes per character
-#ifdef OCI_NLS_CHARSET_MAXBYTESZ
+#ifndef WITH_UNICODE
 status = OCINlsNumericInfoGet(environment->handle,
 environment->errorHandle, &environment->maxBytesPerCharacter,
 OCI_NLS_CHARSET_MAXBYTESZ);
",151,33
Rename macros as suggested by Amaury Forgeot d'Arc.," static udt_Error *Error_New(
  if (errorText[len] == 0 && errorText[len + 1] == 0)
  break;
  }
- error->message = CXORA_BUFFER_TO_STRING(errorText, len);
+ error->message = cxString_FromEncodedString(errorText, len);
 #else
 error->message = PyString_FromString(errorText);
 #endif
 static PyObject *Error_Str(
 Py_INCREF(self->message);
 return self->message;
 }
- return CXORA_ASCII_TO_STRING("""");
+ return cxString_FromAscii("""");
 }
 
",104,13
"Fix handling of unicode on narrow build machines now that byte length semantics
are being used in all cases."," static PyObject *StringVar_GetValue(
 #ifdef Py_UNICODE_WIDE
 return PyUnicode_DecodeUTF16(data, var->actualLength[pos], NULL, NULL);
 #else
- return PyUnicode_FromUnicode((Py_UNICODE*) data, var->actualLength[pos]);
+ return PyUnicode_FromUnicode((Py_UNICODE*) data,
+ var->actualLength[pos] / 2);
 #endif
 #endif
 }
",342,23
"Rename additional macro as suggested by Amaury Forgeot d'Arc; added additional
support for full Unicode; in Python 2.x allow for keyword arguments which use
strings and simply convert them to Unicode on the way through."," static int SessionPool_Init(
 if (StringBuffer_Fill(&username, self->username) < 0)
 return -1;
 if (StringBuffer_Fill(&password, self->password) < 0) {
- StringBuffer_CLEAR(&username);
+ StringBuffer_Clear(&username);
 return -1;
 }
 if (StringBuffer_Fill(&dsn, self->dsn) < 0) {
- StringBuffer_CLEAR(&username);
- StringBuffer_CLEAR(&password);
+ StringBuffer_Clear(&username);
+ StringBuffer_Clear(&password);
 return -1;
 }
 Py_BEGIN_ALLOW_THREADS
 static int SessionPool_Init(
 (OraText*) username.ptr, username.size, (OraText*) password.ptr,
 password.size, poolMode);
 Py_END_ALLOW_THREADS
- StringBuffer_CLEAR(&username);
- StringBuffer_CLEAR(&password);
- StringBuffer_CLEAR(&dsn);
+ StringBuffer_Clear(&username);
+ StringBuffer_Clear(&password);
+ StringBuffer_Clear(&dsn);
 if (Environment_CheckForError(self->environment, status,
 ""SessionPool_New(): create pool"") < 0)
 return -1;
",372,51
"Added support for additional test cases for full unicode support in Python 2.x;
added support for specifying on the command line a list of modules to test."," print ""Running tests for cx_Oracle version"", cx_Oracle.version
 
 import TestEnv
 
-if hasattr(cx_Oracle, ""UNICODE"") or sys.version_info[0] >= 3:
+if len(sys.argv) > 1:
+ moduleNames = sys.argv[1:]
+elif hasattr(cx_Oracle, ""UNICODE"") or sys.version_info[0] >= 3:
 moduleNames = [
 ""Connection"",
 ""Cursor"",
 if hasattr(cx_Oracle, ""UNICODE"") or sys.version_info[0] >= 3:
 ""ObjectVar"",
 ""SessionPool"",
 ""StringVar"",
- ""TimestampVar"",
- ""UnicodeVar""
+ ""TimestampVar""
 ]
+ if sys.version_info[0] < 3:
+ moduleNames.append(""UnicodeVar"")
 else:
 moduleNames = [
 ""uConnection"",
- ""uCursor""
+ ""uCursor"",
+ ""uCursorVar"",
+ ""uDateTimeVar""
 ]
 
 class BaseTestCase(unittest.TestCase):
",66,2
"All test cases now run correctly in Unicode mode. There are still additional
things that need to be dealt with but the majority of the code has now been
transformed to use either Unicode or encoded strings with Oracle."," static int Connection_SetOCIAttr(
 if (StringBuffer_Fill(&buffer, value))
 return -1;
 status = OCIAttrSet(self->sessionHandle, OCI_HTYPE_SESSION,
- buffer.ptr, buffer.size, *attribute,
+ (text*) buffer.ptr, buffer.size, *attribute,
 self->environment->errorHandle);
 if (Environment_CheckForError(self->environment, status,
 ""Connection_SetOCIAttr()"") < 0)
",1047,190
Tweaks to make pickier compilers happy and handle wide unicode correctly.," static PyObject *ExternalObjectVar_ConvertToPython(
 * (OCIString**) value);
 stringSize = OCIStringSize(environment->handle,
 * (OCIString**) value);
- return cxString_FromEncodedString(stringValue, stringSize);
+ return cxString_FromEncodedString( (char*) stringValue,
+ stringSize);
 case OCI_TYPECODE_NUMBER:
 return OracleNumberToPythonFloat(environment, (OCINumber*) value);
 case OCI_TYPECODE_DATE:
",217,29
Tweaks to make wide unicode builds work and eliminate potential memory leak.," static int NumberVar_GetFormatAndTextFromDecimal(
 }
 *formatObj = cxString_FromAscii(format);
 PyMem_Free(format);
- if (!*formatObj)
+ if (!*formatObj) {
+ Py_DECREF(*textObj);
 return -1;
+ }
 
 return 0;
 }
 static int NumberVar_SetValueFromDecimal(
 status = OCINumberFromText(var->environment->errorHandle,
 (text*) textBuffer.ptr, textBuffer.size, (text*) formatBuffer.ptr,
 formatBuffer.size, NULL, 0, &var->data[pos]);
- StringBuffer_Clear(textBuffer);
- StringBuffer_Clear(formatBuffer);
+ StringBuffer_Clear(&textBuffer);
+ StringBuffer_Clear(&formatBuffer);
 Py_DECREF(textValue);
 Py_DECREF(format);
 return Environment_CheckForError(var->environment, status,
",418,53
"Convert object type handling to use new cxString functions and add test case
to ensure that it was done correctly."," static PyObject *ExternalObjectVar_GetAttributeValue(
 {
 dvoid *valueIndicator, *value;
 OCIInd scalarValueIndicator;
- ub4 nameLength;
+ udt_StringBuffer buffer;
 sword status;
 OCIType *tdo;
- char *name;
 
 // get the value for the attribute
- name = PyString_AS_STRING(attribute->name);
- nameLength = PyString_GET_SIZE(attribute->name);
+ if (StringBuffer_Fill(&buffer, attribute->name) < 0)
+ return NULL;
 status = OCIObjectGetAttr(self->objectType->environment->handle,
 self->objectType->environment->errorHandle, self->instance,
- self->indicator, self->objectType->tdo, (const OraText**) &name,
- &nameLength, 1, 0, 0, &scalarValueIndicator, &valueIndicator,
- &value, &tdo);
+ self->indicator, self->objectType->tdo,
+ (const OraText**) &buffer.ptr, (ub4*) &buffer.size, 1, 0, 0,
+ &scalarValueIndicator, &valueIndicator, &value, &tdo);
 if (Environment_CheckForError(self->objectType->environment, status,
 ""ExternalObjectVar_GetAttributeValue(): getting value"") < 0)
 return NULL;
",216,30
Restore commented out code.," class TestLobVar(BaseTestCase):
 actualValue = str(lob)
 longString += char * 25000
 self.failUnlessEqual(lob.size(), len(longString))
-# self.failUnlessEqual(lob.read(), longString)
-# self.failUnlessEqual(actualValue, longString)
+ self.failUnlessEqual(lob.read(), longString)
+ self.failUnlessEqual(actualValue, longString)
 self.failUnlessEqual(lob.read(len(longString)), char)
 if integerValue > 1:
 offset = (integerValue - 1) * 25000 - 4
",120,21
"Remove remaining references to PyString_* functions to enable support for full
Unicode mode and eventual support for Python 3.x."," static udt_Error *Error_New(
  }
 error->message = cxString_FromEncodedString(errorText, len);
 #else
- error->message = PyString_FromString(errorText);
+ error->message = PyBytes_FromString(errorText);
 #endif
 if (!error->message) {
 Py_DECREF(error);
",104,13
Dropped support for Python 2.3.," extension = Extension(
 sources = [""cx_Oracle.c""],
 depends = [""Callback.c"", ""Connection.c"", ""Cursor.c"", ""CursorVar.c"",
 ""DateTimeVar.c"", ""Environment.c"", ""Error.c"",
- ""ExternalDateTimeVar.c"", ""ExternalLobVar.c"",
- ""ExternalObjectVar.c"", ""LobVar.c"", ""LongVar.c"", ""NumberVar.c"",
- ""ObjectType.c"", ""ObjectVar.c"", ""SessionPool.c"",
- ""StringUtils.c"", ""StringVar.c"", ""TimestampVar.c"",
- ""Transforms.c"", ""Variable.c""])
+ ""ExternalLobVar.c"", ""ExternalObjectVar.c"", ""LobVar.c"",
+ ""LongVar.c"", ""NumberVar.c"", ""ObjectType.c"", ""ObjectVar.c"",
+ ""SessionPool.c"", ""StringUtils.c"", ""StringVar.c"",
+ ""TimestampVar.c"", ""Transforms.c"", ""Variable.c""])
 
 # perform the setup
 setup(
",259,15
Add macros for backwards compatibility if needed.," typedef int Py_ssize_t;
 PyObject_HEAD_INIT(type) size,
 #endif
 
+// define Py_Int_* macros for Python 3.x
+#ifndef Py_Int_Check
+#define PyInt_Check PyLong_Check
+#define PyInt_FromLong PyLong_FromLong
+#endif
+
 // define simple construct for determining endianness of the platform
 // Oracle uses native encoding with OCI_UTF16 but bails when a BOM is written
 #define IS_LITTLE_ENDIAN (int)*(unsigned char*) &one
",271,42
Use sb4 instead of int in order to handle 64-bit platforms properly.," static udt_VariableType *Variable_TypeByValue(
 return &vt_Float;
 if (PyBuffer_Check(value)) {
 const void *buffer;
- if (PyObject_AsReadBuffer(value, &buffer, (int*) size) < 0)
+ if (PyObject_AsReadBuffer(value, &buffer, (sb4*) size) < 0)
 return NULL;
 if (*size > MAX_BINARY_BYTES)
 return &vt_LongBinary;
",1072,272
Add missing StringBuffer_Clear() method calls.," static int Connection_SetOCIAttr(
 status = OCIAttrSet(self->sessionHandle, OCI_HTYPE_SESSION,
 (text*) buffer.ptr, buffer.size, *attribute,
 self->environment->errorHandle);
+ StringBuffer_Clear(&buffer);
 if (Environment_CheckForError(self->environment, status,
 ""Connection_SetOCIAttr()"") < 0)
 return -1;
",1060,195
Further work toward supporting Python 3.x.," static int LongVar_SetValue(
 if (PyBytes_Check(value)) {
 if (StringBuffer_FromBytes(&buffer, value) < 0)
 return -1;
- } else if (PyBuffer_Check(value)) {
- StringBuffer_Init(&buffer);
- if (PyObject_AsReadBuffer(value, &buffer.ptr, &buffer.size) < 0)
+#if PY_MAJOR_VERSION < 3
+ } else if (cxBinary_Check(value)) {
+ if (StringBuffer_FromBinary(&buffer, value) < 0)
 return -1;
+#endif
 } else {
 PyErr_SetString(PyExc_TypeError,
 ""expecting string or buffer data"");
",140,14
"Replace all occurrences of PyInt_AS_LONG with PyInt_AsLong since Python 3.x
doesn't have a separate integer type."," static int Connection_SplitComponent(
 posObj = PyObject_CallMethod(*sourceObj, ""find"", ""s"", splitString);
 if (!posObj)
 return -1;
- pos = PyInt_AS_LONG(posObj);
+ pos = PyInt_AsLong(posObj);
 Py_DECREF(posObj);
+ if (PyErr_Occurred())
+ return -1;
 if (pos >= 0) {
 size = PySequence_Size(*sourceObj);
 if (PyErr_Occurred())
 static int Connection_SetStmtCacheSize(
 PyErr_SetString(PyExc_TypeError, ""value must be an integer"");
 return -1;
 }
- valueToSet = (ub4) PyInt_AS_LONG(value);
+ valueToSet = (ub4) PyInt_AsLong(value);
+ if (PyErr_Occurred())
+ return -1;
 status = OCIAttrSet(self->handle, OCI_HTYPE_SVCCTX, (dvoid*) &valueToSet,
 0, OCI_ATTR_STMTCACHESIZE, self->environment->errorHandle);
 if (Environment_CheckForError(self->environment, status,
",1064,197
Replace PyBytes_ with cxString to make Python 3.x happy.," static int Cursor_Call(
 Py_DECREF(arguments);
 
 // create the statement object
- format = PyBytes_FromString(statement);
+ format = cxString_FromAscii(statement);
 PyMem_Free(statement);
 if (!format) {
 Py_DECREF(bindVariables);
",1470,321
Set up test cases for Python 3.x.,"
 """"""Module for testing cursor objects.""""""
 
 import cx_Oracle
+import sys
 
 class TestCursor(BaseTestCase):
 
 class TestCursor(BaseTestCase):
 where IntCol between 1 and 3
 order by IntCol"""""")
 testIter = iter(self.cursor)
- value, = testIter.next()
+ if sys.version_info[0] >= 3:
+ value, = next(testIter)
+ else:
+ value, = testIter.next()
 self.cursor.execute(""insert into TestExecuteMany values (1)"")
- self.failUnlessRaises(cx_Oracle.InterfaceError, testIter.next) 
+ if sys.version_info[0] >= 3:
+ self.failUnlessRaises(cx_Oracle.InterfaceError, next, testIter) 
+ else:
+ self.failUnlessRaises(cx_Oracle.InterfaceError, testIter.next) 
 
 def testBindNames(self):
 """"""test that bindnames() works correctly.""""""
",180,33
Reverse the comparison for character data or bad things can happen!," static udt_Variable *Variable_New(
 #ifdef WITH_UNICODE
 var->maxLength = var->maxLength * CXORA_BYTES_PER_CHAR;
 #else
- if (type->charsetForm != SQLCS_IMPLICIT)
+ if (type->charsetForm == SQLCS_IMPLICIT)
 var->maxLength =
 var->maxLength * cursor->environment->maxBytesPerCharacter;
 else var->maxLength = elementLength * 2;
",1079,276
"Make the bind variables and fetch variables accessible although they need to be
treated carefully since they are used internally; return the cursor from
the execute() method as a convenience."," static PyMemberDef g_CursorMembers[] = {
 { ""connection"", T_OBJECT_EX, offsetof(udt_Cursor, connection), READONLY },
 { ""numbersAsStrings"", T_INT, offsetof(udt_Cursor, numbersAsStrings), 0 },
 { ""rowfactory"", T_OBJECT, offsetof(udt_Cursor, rowFactory), 0 },
+ { ""bindvars"", T_OBJECT, offsetof(udt_Cursor, bindVariables), READONLY },
+ { ""fetchvars"", T_OBJECT, offsetof(udt_Cursor, fetchVariables), READONLY },
 { ""inputtypehandler"", T_OBJECT, offsetof(udt_Cursor, inputTypeHandler),
 0 },
 { ""outputtypehandler"", T_OBJECT, offsetof(udt_Cursor, outputTypeHandler),
 static PyObject *Cursor_Execute(
 self->outputSize = -1;
 self->outputSizeColumn = -1;
 
- // for queries, return the defined variables for possible use
+ // for queries, return the cursor for convenience
 if (isQuery) {
- Py_INCREF(self->fetchVariables);
- return self->fetchVariables;
+ Py_INCREF(self);
+ return (PyObject*) self;
 }
 
 // for all other statements, simply return None
",1472,321
"Use row_factory in preference to rowfactory since the builtin sqlite3 module
does it that way and its better to be compatible with such things."," static PyMemberDef g_CursorMembers[] = {
 { ""statement"", T_OBJECT, offsetof(udt_Cursor, statement), READONLY },
 { ""connection"", T_OBJECT_EX, offsetof(udt_Cursor, connection), READONLY },
 { ""numbersAsStrings"", T_INT, offsetof(udt_Cursor, numbersAsStrings), 0 },
- { ""rowfactory"", T_OBJECT, offsetof(udt_Cursor, rowFactory), 0 },
+ { ""row_factory"", T_OBJECT, offsetof(udt_Cursor, rowFactory), 0 },
 { ""bindvars"", T_OBJECT, offsetof(udt_Cursor, bindVariables), READONLY },
 { ""fetchvars"", T_OBJECT, offsetof(udt_Cursor, fetchVariables), READONLY },
 { ""inputtypehandler"", T_OBJECT, offsetof(udt_Cursor, inputTypeHandler),
 0 },
 { ""outputtypehandler"", T_OBJECT, offsetof(udt_Cursor, outputTypeHandler),
 0 },
+ { ""rowfactory"", T_OBJECT, offsetof(udt_Cursor, rowFactory), 0 },
 { NULL }
 };
 
",1473,321
"Never mind using row_factory, the signature of the method is different."," static PyMemberDef g_CursorMembers[] = {
 { ""statement"", T_OBJECT, offsetof(udt_Cursor, statement), READONLY },
 { ""connection"", T_OBJECT_EX, offsetof(udt_Cursor, connection), READONLY },
 { ""numbersAsStrings"", T_INT, offsetof(udt_Cursor, numbersAsStrings), 0 },
- { ""row_factory"", T_OBJECT, offsetof(udt_Cursor, rowFactory), 0 },
+ { ""rowfactory"", T_OBJECT, offsetof(udt_Cursor, rowFactory), 0 },
 { ""bindvars"", T_OBJECT, offsetof(udt_Cursor, bindVariables), READONLY },
 { ""fetchvars"", T_OBJECT, offsetof(udt_Cursor, fetchVariables), READONLY },
 { ""inputtypehandler"", T_OBJECT, offsetof(udt_Cursor, inputTypeHandler),
 0 },
 { ""outputtypehandler"", T_OBJECT, offsetof(udt_Cursor, outputTypeHandler),
 0 },
- { ""rowfactory"", T_OBJECT, offsetof(udt_Cursor, rowFactory), 0 },
 { NULL }
 };
 
",1472,321
"Use struct.calcsize('P') to determine the size of a pointer rather than
depend on the value of sys.maxint which differs on 64-bit platforms."," class TestCursorVar(BaseTestCase):
 cursor(select IntCol + 1 from dual) CursorValue
 from TestNumbers
 order by IntCol"""""")
- size = len(struct.pack(""i"", 1))
+ size = struct.calcsize('P')
 self.failUnlessEqual(self.cursor.description,
 [ ('INTCOL', cx_Oracle.NUMBER, 10, 22, 9, 0, 0),
 ('CURSORVALUE', cx_Oracle.CURSOR, -1, size, 0, 0, 1) ])
",42,4
"Make Visual Studio happy as it doesn't like variables declared after any code
has been executed."," static udt_Error *Error_New(
 ub4 handleType;
 dvoid *handle;
 sword status;
+#ifdef WITH_UNICODE
+ Py_ssize_t len;
+#endif
 
 error = PyObject_NEW(udt_Error, &g_ErrorType);
 if (!error)
 static udt_Error *Error_New(
 return NULL;
 }
 #ifdef WITH_UNICODE
- Py_ssize_t len;
  for (len = 0; len < sizeof(errorText); len += 2) {
  if (errorText[len] == 0 && errorText[len + 1] == 0)
  break;
",104,14
Added additional link arguments for Cygwin as requested by Rob Gillen.," if sys.platform == ""aix4"":
 extraCompileArgs.append(""-qcpluscmt"")
 elif sys.platform == ""cygwin"":
 extraCompileArgs.append(""-mno-cygwin"")
+ extraLinkArgs.append(""-Wl,--enable-runtime-pseudo-reloc"")
 if ""WITH_UNICODE"" in os.environ or sys.version_info[0] >= 3:
 extraCompileArgs.append(""-DWITH_UNICODE"")
 
",260,15
"Added additional test for errors taking place in connections acquired from a
session pool."," class TestConnection(TestCase):
 count, = cursor.fetchone()
 self.failUnlessEqual(count, 10)
 
+ def __ConnectAndGenerateError(self):
+ """"""Connect to the database, perform a query which raises an error""""""
+ connection = self.pool.acquire()
+ cursor = connection.cursor()
+ self.failUnlessRaises(cx_Oracle.DatabaseError, cursor.execute,
+ ""select 1 / 0 from dual"")
+
 def testPool(self):
 """"""test that the pool is created and has the right attributes""""""
 pool = cx_Oracle.SessionPool(USERNAME, PASSWORD, TNSENTRY, 2, 8, 3)
 class TestConnection(TestCase):
 for thread in threads:
 thread.join()
 
+ def testThreadingWithErrors(self):
+ """"""test session pool to database with multiple threads (with errors)""""""
+ self.pool = cx_Oracle.SessionPool(USERNAME, PASSWORD, TNSENTRY, 5, 20,
+ 2, threaded = True)
+ threads = []
+ for i in range(20):
+ thread = threading.Thread(None, self.__ConnectAndGenerateError)
+ threads.append(thread)
+ thread.start()
+ for thread in threads:
+ thread.join()
+
",100,12
"Use the same environment handle in connections acquired from the pool as using
a new environment handle results in strange errors in certain situations."," static int Connection_Init(
 }
 
 // set up the environment
- self->environment = Environment_New(threaded, events);
+ if (pool)
+ self->environment = Environment_Clone(pool->environment);
+ else self->environment = Environment_NewFromScratch(threaded, events);
 if (!self->environment)
 return -1;
 
",1072,199
Ensure memory is freed if the acuisition of the bind names fails entirely.," static int Cursor_GetBindNames(
 indicatorNameLengths, duplicate, bindHandles);
 if (status != OCI_NO_DATA &&
 Environment_CheckForError(self->environment, status,
- ""Cursor_GetBindNames()"") < 0)
+ ""Cursor_GetBindNames()"") < 0) {
+ PyMem_Free(buffer);
 return -1;
+ }
 if (foundElements < 0) {
 *names = NULL;
 PyMem_Free(buffer);
",1474,321
"Added support for interval day to second in Oracle, represented as Python
datetime.timedelta objects."," static PyObject *Module_Initialize(void)
 #ifdef SQLT_BFLOAT
 MAKE_VARIABLE_TYPE_READY(&g_NativeFloatVarType);
 #endif
+ MAKE_VARIABLE_TYPE_READY(&g_IntervalVarType);
 
 // initialize module and retrieve the dictionary
 #if PY_MAJOR_VERSION >= 3
 static PyObject *Module_Initialize(void)
 ADD_TYPE_OBJECT(""UNICODE"", &g_UnicodeVarType)
 ADD_TYPE_OBJECT(""NCLOB"", &g_NCLOBVarType)
 #endif
+ ADD_TYPE_OBJECT(""INTERVAL"", &g_IntervalVarType)
 ADD_TYPE_OBJECT(""LOB"", &g_ExternalLobVarType)
 ADD_TYPE_OBJECT(""LONG_BINARY"", &g_LongBinaryVarType)
 ADD_TYPE_OBJECT(""LONG_STRING"", &g_LongStringVarType)
",294,45
Calculate whether or not a 64-bit platform is in use properly.," else:
 if not includeDirs:
 raise DistutilsSetupError(""cannot locate Oracle include files"")
 libPath = os.path.join(oracleHome, ""lib"")
- if struct.calcsize(""i"") == 4:
+ if struct.calcsize(""P"") == 4:
 alternatePath = os.path.join(oracleHome, ""lib32"")
 else:
 alternatePath = os.path.join(oracleHome, ""lib64"")
",260,15
"Reorganized README.txt and added new file BUILD.txt based on an initial patch
from Corey Gaff."," BUILD_VERSION = ""5.0a1""
 dataFiles = None
 if sys.platform in (""win32"", ""cygwin""):
 baseName = ""cx_Oracle-doc""
- dataFiles = [ (baseName, [ ""LICENSE.TXT"", ""README.TXT"", ""HISTORY.txt""]) ]
+ dataFiles = [ (baseName,
+ [ ""BUILD.txt"", ""LICENSE.TXT"", ""README.TXT"", ""HISTORY.txt""]) ]
 for dir in (""html"", ""html/_static"", ""samples"", ""test""):
 files = []
 fullDirName = ""%s/%s"" % (baseName, dir)
 if sys.platform in (""win32"", ""cygwin""):
 dataFiles.append((fullDirName, files))
 
 # define the list of files to be included as documentation for bdist_rpm
-docFiles = ""LICENSE.txt README.txt HISTORY.txt html samples test""
+docFiles = ""LICENSE.txt README.txt BUILD.txt HISTORY.txt html samples test""
 
 # method for checking a potential Oracle home
 def CheckOracleHome(directoryToCheck):
",261,15
"As requested by Gordon den Otter, return a boolean from connection.prepare()
indicating whether or not a transaction has been prepared for commit so that
the error ORA-24756 (transaction does not exist) can be avoided."," static PyObject *Connection_Prepare(
 if (Environment_CheckForError(self->environment, status,
 ""Connection_Prepare()"") < 0)
 return NULL;
- self->commitMode = OCI_TRANS_TWOPHASE;
 
- Py_INCREF(Py_None);
- return Py_None;
+ // if nothing available to prepare, return False in order to allow for
+ // avoiding the call to commit() which will fail with ORA-24756
+ // (transaction does not exist)
+ if (status == OCI_SUCCESS_WITH_INFO) {
+ Py_INCREF(Py_False);
+ return Py_False;
+ }
+ self->commitMode = OCI_TRANS_TWOPHASE;
+ Py_INCREF(Py_True);
+ return Py_True;
 }
 
 
",1159,213
"Reset commit mode back to default after committing so that local and global
transactions can be mixed on the same connection."," static PyObject *Connection_Commit(
 if (Environment_CheckForError(self->environment, status,
 ""Connection_Commit()"") < 0)
 return NULL;
+ self->commitMode = OCI_DEFAULT;
 
 Py_INCREF(Py_None);
 return Py_None;
",1160,213
Preparing to release version 5.0.," except:
 from distutils.extension import Extension
 
 # define build constants
-BUILD_VERSION = ""5.0a1""
+BUILD_VERSION = ""5.0""
 
 # define the list of files to be included as documentation for Windows
 dataFiles = None
",261,15
"Added additional classifiers to make it clear that cx_Oracle supports version 3
of Python as recommended by Amaury Forgeot d'Arc."," classifiers = [
 ""Operating System :: OS Independent"",
 ""Programming Language :: C"",
 ""Programming Language :: Python"",
+ ""Programming Language :: Python :: 2"",
+ ""Programming Language :: Python :: 3"",
 ""Topic :: Database""
 ]
 
",263,15
"NCLOB variables need to be retained even in Unicode mode as Oracle will not
allow you to read/write those type of LOB values with SQLCS_IMPLICIT for
reasons known only to itself."," static PyTypeObject g_CLOBVarType = {
 };
 
 
-#ifndef WITH_UNICODE
 static PyTypeObject g_NCLOBVarType = {
 PyVarObject_HEAD_INIT(NULL, 0)
 ""cx_Oracle.NCLOB"", // tp_name
 static PyTypeObject g_NCLOBVarType = {
 Py_TPFLAGS_DEFAULT, // tp_flags
 0 // tp_doc
 };
-#endif
 
 
 static PyTypeObject g_BLOBVarType = {
 static udt_VariableType vt_CLOB = {
 };
 
 
-#ifndef WITH_UNICODE
 static udt_VariableType vt_NCLOB = {
 (InitializeProc) LobVar_Initialize,
 (FinalizeProc) LobVar_Finalize,
 static udt_VariableType vt_NCLOB = {
 0, // can be copied
 0 // can be in array
 };
-#endif
 
 
 static udt_VariableType vt_BLOB = {
",308,27
"Call the type's tp_free and tp_alloc methods at all times in order to deal with
inheritance properly; use ""self"" at all times in the constructor and destructor
routines."," static udt_Variable *Callback_NewVariable(
 return NULL;
 
 // attempt to allocate the object
- var = PyObject_NEW(udt_Variable, type->pythonType);
+ var = (udt_Variable*) type->pythonType->tp_alloc(type->pythonType, 0);
 if (!var)
 return NULL;
 
",224,30
"Add new attributes size, bufferSize and numElements to variable objects,
deprecating allocelems (replaced by numElements) and maxlength (replaced by
bufferSize); avoid increasing memory allocation for strings when using variable
width character sets and increasing the number of elements in a variable during
executemany(). Thanks to Don Reid for pointing out this issue.","
 static udt_Variable *Callback_NewVariable(
 udt_Connection *connection, // connection to use
 ub2 oracleType, // Oracle type of data
- ub4 maxLength, // maximum length of elements
+ ub4 bufferSize, // maximum length of elements
 void *data, // data pointer
 void *indicator, // indicator pointer
 ub2 *returnCode, // return code pointer
 static udt_Variable *Callback_NewVariable(
 var->data = data;
 var->actualLength = actualLength;
 var->returnCode = returnCode;
- var->maxLength = type->elementLength;
+ var->size = type->size;
+ var->bufferSize = type->size;
 if (type->isVariableLength)
- var->maxLength = maxLength;
+ var->bufferSize = bufferSize;
 
 return var;
 }
",225,30
Don't lose the Python lock before all possible Python code has been executed.," static int Cursor_InternalPrepare(
 return -1;
 
 // prepare statement
- Py_BEGIN_ALLOW_THREADS
 self->isOwned = 0;
 if (StringBuffer_Fill(&statementBuffer, statement) < 0)
 return -1;
 static int Cursor_InternalPrepare(
 StringBuffer_Clear(&statementBuffer);
 return -1;
 }
+ Py_BEGIN_ALLOW_THREADS
 status = OCIStmtPrepare2(self->connection->handle, &self->handle,
 self->environment->errorHandle, (text*) statementBuffer.ptr,
 statementBuffer.size, (text*) tagBuffer.ptr, tagBuffer.size,
",1474,321
Allow events mode to be set in Oracle 10g as well.," static udt_Environment *Environment_NewFromScratch(
 mode = OCI_OBJECT;
 if (threaded)
 mode |= OCI_THREADED;
-#ifdef ORACLE_11G
+#ifdef OCI_EVENTS
 if (events)
 mode |= OCI_EVENTS;
 #endif
",183,41
Added initial support for database change notification.," static PyObject *Module_Initialize(void)
 MAKE_TYPE_READY(&g_ObjectAttributeType);
 MAKE_TYPE_READY(&g_ExternalLobVarType);
 MAKE_TYPE_READY(&g_ExternalObjectVarType);
+#ifdef ORACLE_10GR2
+ MAKE_TYPE_READY(&g_SubscriptionType);
+#endif
 MAKE_VARIABLE_TYPE_READY(&g_StringVarType);
 MAKE_VARIABLE_TYPE_READY(&g_FixedCharVarType);
 MAKE_VARIABLE_TYPE_READY(&g_RowidVarType);
",295,46
Avoid warning about signedness in argument.," static int Message_Initialize(
 dvoid *descriptor) // descriptor to get information from
 {
 ub4 dbnameLength;
- text *dbname;
+ char *dbname;
 sword status;
 
 // determine type
",432,56
Added tables to the message that is produced.," static PyObject *Module_Initialize(void)
 #ifdef ORACLE_10GR2
 MAKE_TYPE_READY(&g_SubscriptionType);
 MAKE_TYPE_READY(&g_MessageType);
+ MAKE_TYPE_READY(&g_MessageTableType);
 #endif
 MAKE_VARIABLE_TYPE_READY(&g_StringVarType);
 MAKE_VARIABLE_TYPE_READY(&g_FixedCharVarType);
",319,46
Added support for the rows in the change notification message.," static PyObject *Module_Initialize(void)
 MAKE_TYPE_READY(&g_SubscriptionType);
 MAKE_TYPE_READY(&g_MessageType);
 MAKE_TYPE_READY(&g_MessageTableType);
+ MAKE_TYPE_READY(&g_MessageRowType);
 #endif
 MAKE_VARIABLE_TYPE_READY(&g_StringVarType);
 MAKE_VARIABLE_TYPE_READY(&g_FixedCharVarType);
",320,46
"Drop constant DROP_DB which is not very well documented by Oracle and doesn't
appear to serve any particular purpose."," static PyObject *Module_Initialize(void)
 ADD_OCI_CONSTANT(EVENT_STARTUP)
 ADD_OCI_CONSTANT(EVENT_SHUTDOWN)
 ADD_OCI_CONSTANT(EVENT_SHUTDOWN_ANY)
- ADD_OCI_CONSTANT(EVENT_DROP_DB)
 ADD_OCI_CONSTANT(EVENT_DEREG)
 ADD_OCI_CONSTANT(EVENT_OBJCHANGE)
 ADD_OCI_CONSTANT(OPCODE_ALLOPS)
",319,46
"Drop this constant also since it is not part of the standard Oracle
documentation for the database change notification feature."," static PyObject *Module_Initialize(void)
 ADD_OCI_CONSTANT(OPCODE_DELETE)
 ADD_OCI_CONSTANT(OPCODE_ALTER)
 ADD_OCI_CONSTANT(OPCODE_DROP)
- ADD_OCI_CONSTANT(OPCODE_UNKNOWN)
 ADD_OCI_CONSTANT(SUBSCR_NAMESPACE_ANONYMOUS)
 ADD_OCI_CONSTANT(SUBSCR_NAMESPACE_AQ)
 ADD_OCI_CONSTANT(SUBSCR_NAMESPACE_DBCHANGE)
",318,46
"Drop these constants as well since there is no known use for them in cx_Oracle
and very little information in Oracle documentation about their use."," static PyObject *Module_Initialize(void)
 ADD_OCI_CONSTANT(OPCODE_DELETE)
 ADD_OCI_CONSTANT(OPCODE_ALTER)
 ADD_OCI_CONSTANT(OPCODE_DROP)
- ADD_OCI_CONSTANT(SUBSCR_NAMESPACE_ANONYMOUS)
- ADD_OCI_CONSTANT(SUBSCR_NAMESPACE_AQ)
 ADD_OCI_CONSTANT(SUBSCR_NAMESPACE_DBCHANGE)
 ADD_OCI_CONSTANT(SUBSCR_PROTO_OCI)
 ADD_OCI_CONSTANT(SUBSCR_PROTO_MAIL)
",316,46
Preparing to release version 5.0.1.," except:
 from distutils.extension import Extension
 
 # define build constants
-BUILD_VERSION = ""5.0""
+BUILD_VERSION = ""5.0.1""
 
 # define the list of files to be included as documentation for Windows
 dataFiles = None
",264,15
"Use the PyNumber_Long method as required in Python 3.0.1 and higher but the
older version in Python 2.x."," static PyObject *NumberVar_GetValue(
 return NULL;
 if (var->type == &vt_NumberAsString)
 return stringObj;
+#if PY_MAJOR_VERSION >= 3
+ result = PyNumber_Long(stringObj);
+#else
 result = PyNumber_Int(stringObj);
+#endif
 Py_DECREF(stringObj);
 if (result || !PyErr_ExceptionMatches(PyExc_ValueError))
 return result;
",443,43
"Add additional cast as requested by Marco de Paoli in order to support
compiling with Microsoft Visual C++ 2008."," static int Variable_Resize(
 
 // copy the data from the original array to the new array
 for (i = 0; i < self->allocatedElements; i++)
- memcpy(self->data + self->bufferSize * i,
+ memcpy( (char*) self->data + self->bufferSize * i,
 (void*) ( (char*) origData + origBufferSize * i ),
 origBufferSize);
 PyMem_Free(origData);
",1100,281
Included the MSVC library path as requested by Jason Coombs.," else:
 
 # define some variables
 if sys.platform == ""win32"":
- libDirs = [os.path.join(oracleHome, ""bin""), oracleHome]
+ libDirs = [os.path.join(oracleHome, ""bin""), oracleHome,
+ os.path.join(oracleHome, ""sdk"", ""lib"", ""msvc"")]
 possibleIncludeDirs = [""oci/include"", ""rdbms/demo"", ""sdk/include""]
 includeDirs = []
 for dir in possibleIncludeDirs:
",265,15
Re-enable parsing of non select statements as requested by Ray Terrill.," static PyObject *Cursor_Parse(
 {
 PyObject *statement;
 sword status;
+ ub4 mode;
 
 // statement text is expected
 if (!PyArg_ParseTuple(args, ""S"", &statement))
 static PyObject *Cursor_Parse(
 return NULL;
 
 // parse the statement
+ if (self->statementType == OCI_STMT_SELECT)
+ mode = OCI_DESCRIBE_ONLY;
+ else mode = OCI_PARSE_ONLY;
 Py_BEGIN_ALLOW_THREADS
 status = OCIStmtExecute(self->connection->handle, self->handle,
- self->environment->errorHandle, 0, 0, 0, 0, OCI_DESCRIBE_ONLY);
+ self->environment->errorHandle, 0, 0, 0, 0, mode);
 Py_END_ALLOW_THREADS
 if (Environment_CheckForError(self->environment, status,
 ""Cursor_Parse()"") < 0)
",1478,322
"Now that the library path is being calculated exactly there is no need to
include the lib subdirectory as before."," if ""WITH_UNICODE"" in os.environ or sys.version_info[0] >= 3:
 # eliminate the need for setting LD_LIBRARY_PATH but it also means that this
 # location will be the only location searched for the Oracle client library
 if ""FORCE_RPATH"" in os.environ:
- extraLinkArgs.append(""-Wl,-rpath,%s/lib"" % oracleLibDir)
+ extraLinkArgs.append(""-Wl,-rpath,%s"" % oracleLibDir)
 
 # tweak distribution full name to include the Oracle version
 class Distribution(distutils.dist.Distribution):
",265,15
"The actual location of the libraries is in the OCI subdirectory, not SDK."," else:
 # define some variables
 if sys.platform == ""win32"":
 libDirs = [os.path.join(oracleHome, ""bin""), oracleHome,
- os.path.join(oracleHome, ""sdk"", ""lib"", ""msvc"")]
+ os.path.join(oracleHome, ""oci"", ""lib"", ""msvc"")]
 possibleIncludeDirs = [""oci/include"", ""rdbms/demo"", ""sdk/include""]
 includeDirs = []
 for dir in possibleIncludeDirs:
",265,15
Preparing to release version 5.0.2.," except:
 from distutils.extension import Extension
 
 # define build constants
-BUILD_VERSION = ""5.0.1""
+BUILD_VERSION = ""5.0.2""
 
 # define the list of files to be included as documentation for Windows
 dataFiles = None
",265,15
Implemented a parse error offset as requested by Catherine Devlin.,"
 typedef struct {
 PyObject_HEAD
 sb4 code;
+ ub4 offset;
 PyObject *message;
 const char *context;
 } udt_Error;
 static PyObject *Error_Str(udt_Error*);
 //-----------------------------------------------------------------------------
 static PyMemberDef g_ErrorMembers[] = {
 { ""code"", T_INT, offsetof(udt_Error, code), READONLY },
+ { ""offset"", T_INT, offsetof(udt_Error, offset), READONLY },
 { ""message"", T_OBJECT, offsetof(udt_Error, message), READONLY },
 { ""context"", T_STRING, offsetof(udt_Error, context), READONLY },
 { NULL }
",106,14
"The 64-bit Windows instant client uses a different library directory than the
full client does."," else:
 # define some variables
 if sys.platform == ""win32"":
 libDirs = [os.path.join(oracleHome, ""bin""), oracleHome,
- os.path.join(oracleHome, ""oci"", ""lib"", ""msvc"")]
+ os.path.join(oracleHome, ""oci"", ""lib"", ""msvc""),
+ os.path.join(oracleHome, ""sdk"", ""lib"", ""msvc"")]
 possibleIncludeDirs = [""oci/include"", ""rdbms/demo"", ""sdk/include""]
 includeDirs = []
 for dir in possibleIncludeDirs:
",266,15
"Added extra link arguments required for Mac OS X as suggested by Jason
Woodward."," if sys.platform == ""aix4"":
 elif sys.platform == ""cygwin"":
 extraCompileArgs.append(""-mno-cygwin"")
 extraLinkArgs.append(""-Wl,--enable-runtime-pseudo-reloc"")
+elif sys.platform == ""darwin"":
+ extraLinkArgs.append(""-shared-libgcc"")
 if ""WITH_UNICODE"" in os.environ or sys.version_info[0] >= 3:
 extraCompileArgs.append(""-DWITH_UNICODE"")
 
",272,17
"Added ORA-3135 to the list of errors that raise OperationalError instead of
DatabaseError as requested by Zherdev Anatoly."," static int Environment_RaiseError(
 case 1089:
 case 3113:
 case 3114:
+ case 3135:
 case 12203:
 case 12500:
 case 12571:
",184,42
Use the correct type to avoid warnings.," static int MessageTable_Initialize(
 dvoid *descriptor) // descriptor to get information from
 {
 dvoid **rowDescriptor, *indicator;
- ub4 nameLength, i, numRows;
+ ub4 nameLength, i;
 udt_MessageRow *row;
 boolean exists;
 OCIColl *rows;
 sword status;
+ sb4 numRows;
 char *name;
 
 // determine operation
 static int Message_Initialize(
 dvoid *descriptor) // descriptor to get information from
 {
 dvoid **tableDescriptor, *indicator;
- ub4 dbnameLength, numTables, i;
 udt_MessageTable *table;
+ ub4 dbnameLength, i;
 OCIColl *tables;
 boolean exists;
+ sb4 numTables;
 char *dbname;
 sword status;
 
 static int Message_Initialize(
 if (!tables)
 numTables = 0;
 else {
- status = OCICollSize(env->handle, env->errorHandle, tables, &numTables);
+ status = OCICollSize(env->handle, env->errorHandle, tables,
+ &numTables);
 if (Environment_CheckForError(env, status,
 ""Message_Initialize(): get size of collection"") < 0)
 return -1;
",669,82
"Added additional error codes to those treated as operational errors as
suggested by Christopher Jones."," static int Environment_RaiseError(
 case 2292:
 exceptionType = g_IntegrityErrorException;
 break;
+ case 22:
+ case 378:
+ case 602:
+ case 603:
+ case 604:
+ case 609:
 case 1012:
+ case 1013:
 case 1033:
 case 1034:
+ case 1041:
+ case 1043:
 case 1089:
+ case 1090:
+ case 1092:
 case 3113:
 case 3114:
+ case 3122:
 case 3135:
+ case 12153:
 case 12203:
 case 12500:
 case 12571:
+ case 27146:
+ case 28511:
 exceptionType = g_OperationalErrorException;
 break;
 default:
",199,57
"The struct module needs to be defined as a global as well in order to make
building as part of another setup.py possible."," docFiles = ""LICENSE.txt README.txt BUILD.txt HISTORY.txt html samples test""
 
 # method for checking a potential Oracle home
 def CheckOracleHome(directoryToCheck):
- global oracleHome, oracleVersion, oracleLibDir
+ global oracleHome, oracleVersion, oracleLibDir, struct
 if sys.platform in (""win32"", ""cygwin""):
 subDirs = [""bin""]
 filesToCheck = [
",272,17
"Move the resetting of the setinputsizes flag to before the binding takes place
so that if an error takes place and a new statement is prepared subsequently
that spurious errors will not occur."," static int Cursor_PerformBind(
 Py_ssize_t pos;
 ub2 i;
 
+ // ensure that input sizes are reset
+ // this is done before binding is attempted so that if binding fails and
+ // a new statement is prepared, the bind variables will be reset and
+ // spurious errors will not occur
+ self->setInputSizes = 0;
+
 // set values and perform binds for all bind variables
 if (self->bindVariables) {
 if (PyDict_Check(self->bindVariables)) {
 static int Cursor_PerformBind(
 }
 }
 
- // ensure that input sizes are reset
- self->setInputSizes = 0;
-
 return 0;
 }
 
",1492,324
current_schema is only valid for Oracle 10.2 and higher.," typedef struct {
 static ub4 gc_ModuleAttribute = OCI_ATTR_MODULE;
 static ub4 gc_ActionAttribute = OCI_ATTR_ACTION;
 static ub4 gc_ClientInfoAttribute = OCI_ATTR_CLIENT_INFO;
+#endif
+
+#ifdef ORACLE_10GR2
 static ub4 gc_CurrentSchemaAttribute = OCI_ATTR_CURRENT_SCHEMA;
 #endif
 
 static PyGetSetDef g_ConnectionCalcMembers[] = {
 { ""action"", 0, (setter) Connection_SetOCIAttr, 0, &gc_ActionAttribute },
 { ""clientinfo"", 0, (setter) Connection_SetOCIAttr, 0,
 &gc_ClientInfoAttribute },
+#endif
+#ifdef ORACLE_10GR2
 { ""current_schema"", (getter) Connection_GetOCIAttr,
 (setter) Connection_SetOCIAttr, 0, &gc_CurrentSchemaAttribute },
 #endif
",1193,218
Preliminary work in releasing 5.0.3; documentation still needs to be built.," except:
 from distutils.extension import Extension
 
 # define build constants
-BUILD_VERSION = ""5.0.2""
+BUILD_VERSION = ""5.0.3""
 
 # define the list of files to be included as documentation for Windows
 dataFiles = None
",272,17
"The newer versions of the instant client now simply replace ""lib"" with
""include"" in order to determine where the include files are to be found."," else:
 path = os.path.join(os.path.dirname(libPath), ""include"")
 if os.path.isdir(path):
 includeDirs.append(path)
+ if not includeDirs:
+ path = oracleHome.replace(""lib"", ""include"")
+ if os.path.isdir(path):
+ includeDirs.append(path)
 if not includeDirs:
 raise DistutilsSetupError(""cannot locate Oracle include files"")
 
",276,17
Change order of assignment in order to make VC++ happier.," static udt_Variable *Variable_NewByOutputTypeHandler(
 return NULL;
 
 // retrieve scale and precision of the parameter, if applicable
- scale = precision = 0;
+ precision = scale = 0;
 if (varType->pythonType == &g_NumberVarType) {
 status = OCIAttrGet(param, OCI_HTYPE_DESCRIBE, (dvoid*) &scale, 0,
 OCI_ATTR_SCALE, cursor->environment->errorHandle);
",1100,281
"Added support for named arguments in callproc() and callfunc() which make use
of PL/SQL notation for making such calls."," static PyObject *Connection_GetVersion(
 }
 
 // call stored procedure
- if (Cursor_Call(cursor, NULL, procName, listOfArguments) < 0) {
+ if (Cursor_Call(cursor, NULL, procName, listOfArguments, NULL) < 0) {
 Py_DECREF(procName);
 Py_DECREF(listOfArguments);
 Py_DECREF(cursor);
",1193,218
"Eliminate the spurious errors that take place because of the change in how
numbers without any constraints are represented in Oracle 11g."," class TestCursorVar(BaseTestCase):
 self.failUnlessEqual(cursor.description, None)
 self.cursor.execute(""""""
 begin
- open :p_Cursor for select 1 NumberCol from dual;
+ open :p_Cursor for select 'X' StringValue from dual;
 end;"""""",
 p_Cursor = cursor)
 self.failUnlessEqual(cursor.description,
- [ ('NUMBERCOL', cx_Oracle.NUMBER, 127, 2, 0, 0, 1) ])
- self.failUnlessEqual(cursor.fetchall(), [(1.0,)])
+ [ ('STRINGVALUE', cx_Oracle.FIXED_CHAR, 1, 1, 0, 0, 1) ])
+ self.failUnlessEqual(cursor.fetchall(), [('X',)])
 
 def testBindCursorInPackage(self):
 ""test binding in a cursor from a package""
",42,4
"Ensure that Windows installer files also include the unicode designation when
appropriate."," class Distribution(distutils.dist.Distribution):
 
 def get_fullname_with_oracle_version(self):
 name = self.metadata.get_fullname()
- return ""%s-%s"" % (name, oracleVersion)
+ fullName = ""%s-%s"" % (name, oracleVersion)
+ if withUnicode:
+ fullName += ""-unicode""
+ return fullName
 
 
 # tweak the RPM build command to include the Python and Oracle version
",284,20
Added support for running the test suite by running python setup.py test.," print ""Running tests for cx_Oracle version"", cx_Oracle.version
 
 import TestEnv
 
-if len(sys.argv) > 1:
+inSetup = (os.path.basename(sys.argv[0]).lower() == ""setup.py"")
+
+if len(sys.argv) > 1 and not inSetup:
 moduleNames = [os.path.splitext(v)[0] for v in sys.argv[1:]]
 elif hasattr(cx_Oracle, ""UNICODE""):
 moduleNames = [
 else:
 class BaseTestCase(unittest.TestCase):
 
 def setUp(self):
+ global cx_Oracle, TestEnv
 self.connection = cx_Oracle.connect(TestEnv.USERNAME,
 TestEnv.PASSWORD, TestEnv.TNSENTRY)
 self.cursor = self.connection.cursor()
 for name in moduleNames:
 fileName = name + "".py""
 print
 print ""Running tests in"", fileName
+ if inSetup:
+ fileName = os.path.join(""test"", fileName)
 module = imp.new_module(name)
 setattr(module, ""USERNAME"", TestEnv.USERNAME)
 setattr(module, ""PASSWORD"", TestEnv.PASSWORD)
",78,2
"Renamed to client_identifier as that is consistent with current_schema and is
also much more readable anyway."," static PyGetSetDef g_ConnectionCalcMembers[] = {
 { ""clientinfo"", 0, (setter) Connection_SetOCIAttr, 0,
 &gc_ClientInfoAttribute },
 #endif
- { ""clientidentifier"", 0, (setter) Connection_SetOCIAttr, 0,
+ { ""client_identifier"", 0, (setter) Connection_SetOCIAttr, 0,
 &gc_ClientIdentifierAttribute },
 #ifdef ORACLE_10GR2
 { ""current_schema"", (getter) Connection_GetOCIAttr,
",1196,218
Force termination with an error code if some tests fail.," if failures:
 print ""***** Some tests in the following modules failed. *****""
 for name in failures:
 print "" %s"" % name
+ sys.exit(1)
 
",79,2
"Added check for attempts to call executemany() with arrays which are not
supported by the OCI; thanks to Amaury Forgeot d'Arc for the suggestion."," static int Variable_SetValue(
 unsigned arrayPos, // array position
 PyObject *value) // value to set
 {
- if (var->isArray)
+ if (var->isArray) {
+ if (arrayPos > 0) {
+ PyErr_SetString(g_NotSupportedErrorException,
+ ""arrays of arrays are not supported by the OCI"");
+ return -1;
+ }
 return Variable_SetArrayValue(var, value);
+ }
 return Variable_SetSingleValue(var, arrayPos, value);
 }
 
",1106,282
"Fixed bug when converting from decimal would result in OCI-22062 because
the locale decimal point was not a period. Thanks to Amaury Forgeot d'Arc
for the solution to this problem."," static int NumberVar_SetValueFromDecimal(
 }
 status = OCINumberFromText(var->environment->errorHandle,
 (text*) textBuffer.ptr, textBuffer.size, (text*) formatBuffer.ptr,
- formatBuffer.size, NULL, 0, &var->data[pos]);
+ formatBuffer.size, g_NlsNumericCharactersBuffer.ptr,
+ g_NlsNumericCharactersBuffer.size, &var->data[pos]);
 StringBuffer_Clear(&textBuffer);
 StringBuffer_Clear(&formatBuffer);
 Py_DECREF(textValue);
",444,43
"Enable building from within other setup.py scripts like those in
cx_OracleTools, for example."," class bdist_rpm(distutils.command.bdist_rpm.bdist_rpm):
 class build(distutils.command.build.build):
 
 def finalize_options(self):
- global distutils
- global os
- global sys
+ global distutils, os, sys, withUnicode
 platSpecifier = "".%s-%s-%s"" % \
 (distutils.util.get_platform(), sys.version[0:3],
 oracleVersion)
",300,24
Preparing to release version 5.0.3.," var Documentation = {
 * add context elements like header anchor links
 */
 addContextElements : function() {
- $('div[@id] > :header:first').each(function() {
+ $('div[id] > :header:first').each(function() {
 $('<a class=""headerlink"">\u00B6</a>').
 attr('href', '#' + this.id).
 attr('title', _('Permalink to this headline')).
 appendTo(this);
 });
- $('dt[@id]').each(function() {
+ $('dt[id]').each(function() {
 $('<a class=""headerlink"">\u00B6</a>').
 attr('href', '#' + this.id).
 attr('title', _('Permalink to this definition')).
",158,50
Fix compilation under Oracle 9i.," static PyObject *Connection_GetStmtCacheSize(udt_Connection*, void*);
 static int Connection_SetStmtCacheSize(udt_Connection*, PyObject*, void*);
 #ifdef ORACLE_10G
 static PyObject *Connection_GetOCIAttr(udt_Connection*, ub4*);
-static int Connection_SetOCIAttr(udt_Connection*, PyObject*, ub4*);
 #endif
+static int Connection_SetOCIAttr(udt_Connection*, PyObject*, ub4*);
 #ifdef ORACLE_10GR2
 static PyObject *Connection_Ping(udt_Connection*, PyObject*);
 static PyObject *Connection_Shutdown(udt_Connection*, PyObject*, PyObject*);
 static PyObject *Connection_GetOCIAttr(
 
 return cxString_FromEncodedString(buffer.ptr, buffer.size);
 }
+#endif
 
 
 //-----------------------------------------------------------------------------
 static int Connection_SetOCIAttr(
 return -1;
 return 0;
 }
-#endif
 
 
 //-----------------------------------------------------------------------------
",1196,218
"Added support for building with Python 3.x from an independently created
setup.py (as for cx_OracleDBATools, for example)."," docFiles = ""LICENSE.txt README.txt BUILD.txt HISTORY.txt html samples test""
 
 # method for checking a potential Oracle home
 def CheckOracleHome(directoryToCheck):
- global oracleHome, oracleVersion, oracleLibDir, struct
+ global oracleHome, oracleVersion, oracleLibDir
+ import os
+ import struct
+ import sys
 if sys.platform in (""win32"", ""cygwin""):
 subDirs = [""bin""]
 filesToCheck = [
 class bdist_rpm(distutils.command.bdist_rpm.bdist_rpm):
 class build(distutils.command.build.build):
 
 def finalize_options(self):
- global distutils, os, sys, withUnicode
+ global withUnicode
+ import distutils.util
+ import os
+ import sys
 platSpecifier = "".%s-%s-%s"" % \
 (distutils.util.get_platform(), sys.version[0:3],
 oracleVersion)
",306,24
Provide a bit more information in the error message produced.," if sys.platform == ""win32"":
 if os.path.isdir(path):
 includeDirs.append(path)
 if not includeDirs:
- raise DistutilsSetupError(""cannot locate Oracle include files"")
+ message = ""cannot locate Oracle include files in %s"" % oracleHome
+ raise DistutilsSetupError(message)
 libs = [""oci""]
 elif sys.platform == ""cygwin"":
 includeDirs = [""/usr/include"", ""rdbms/demo"", ""rdbms/public"", \
",307,24
Preparing to release version 5.0.4.," var Search = {
 var tmp = query.split(/\s+/);
 var object = (tmp.length == 1) ? tmp[0].toLowerCase() : null;
 for (var i = 0; i < tmp.length; i++) {
+ // ignore leading/trailing whitespace
+ if (tmp[i] == """")
+ continue;
 // stem the word
 var word = stemmer.stemWord(tmp[i]).toLowerCase();
 // select the correct list
 var Search = {
 displayNextItem();
 });
 } else if (DOCUMENTATION_OPTIONS.HAS_SOURCE) {
- $.get('_sources/' + item[0] + '.txt', function(data) {
+ $.get(DOCUMENTATION_OPTIONS.URL_ROOT + '_sources/' +
+ item[0] + '.txt', function(data) {
 listItem.append($.makeSearchSummary(data, searchterms, hlterms));
 Search.output.append(listItem);
 listItem.slideDown(5, function() {
",369,91
"Added support for creating an object variable via a named type -- the first
step on the road to adding full object support."," static int ObjectVar_PreDefine(
 udt_ObjectVar *self, // variable to set up
 OCIParam *param) // parameter being defined
 {
- self->objectType = ObjectType_New(self->connection, param);
+ self->objectType = ObjectType_New(self->connection, param,
+ OCI_ATTR_TYPE_NAME);
 if (!self->objectType)
 return -1;
 return 0;
",152,16
"Account for lib64 used on x86_64 systems. Thanks to Alex Wood for supplying the
patch."," import distutils.core
 import distutils.dist
 import distutils.util
 import os
+import re
 import struct
 import sys
 
 else:
 if os.path.isdir(path):
 includeDirs.append(path)
 if not includeDirs:
- path = oracleHome.replace(""lib"", ""include"")
+ path = re.sub(""lib(64)?"", ""include"", oracleHome)
 if os.path.isdir(path):
 includeDirs.append(path)
 if not includeDirs:
",308,24
"Check the result of freeing the handle if an exception should be raised; in
addition, null the handle so that a second attempt is not made when the cursor
is freed after close() has been called."," static int Cursor_FreeHandle(
 
 if (self->handle) {
 if (self->isOwned) {
- OCIHandleFree(self->handle, OCI_HTYPE_STMT);
+ status = OCIHandleFree(self->handle, OCI_HTYPE_STMT);
+ if (raiseException && Environment_CheckForError(
+ self->environment, status, ""Cursor_FreeHandle()"") < 0)
+ return -1;
 } else if (self->connection->handle != 0) {
 if (!StringBuffer_Fill(&buffer, self->statementTag) < 0)
 return (raiseException) ? -1 : 0;
 static int Cursor_FreeHandle(
 self->environment, status, ""Cursor_FreeHandle()"") < 0)
 return -1;
 }
+ self->handle = NULL;
 }
 return 0;
 }
",1588,353
Remove unnecessary code.," static PyObject *Cursor_Close(
 if (Cursor_FreeHandle(self, 1) < 0)
 return NULL;
 
- self->handle = NULL;
 self->isOpen = 0;
 
 Py_INCREF(Py_None);
",1587,353
"Make AIX5 happy as OCIPing does not appear to be available on that platform
under Oracle 10g Release 2. Thanks to Pierre-Yves Fontaniere for the patch."," extraCompileArgs = [""-DBUILD_VERSION=%s"" % BUILD_VERSION]
 extraLinkArgs = []
 if sys.platform == ""aix4"":
 extraCompileArgs.append(""-qcpluscmt"")
+elif sys.platform == ""aix5"":
+ extraCompileArgs.append(""-DAIX5"")
 elif sys.platform == ""cygwin"":
 extraCompileArgs.append(""-mno-cygwin"")
 extraLinkArgs.append(""-Wl,--enable-runtime-pseudo-reloc"")
",310,24
"Free temporary LOBs prior to each fetch in order to avoid leaking them; thanks
to Uwe Hoffmann for the initial patch."," static int Cursor_InternalFetch(
 PyErr_SetString(g_InterfaceErrorException, ""query not executed"");
 return -1;
 }
+ for (i = 0; i < PyList_GET_SIZE(self->fetchVariables); i++) {
+ var = (udt_Variable*) PyList_GET_ITEM(self->fetchVariables, i);
+ var->internalFetchNum++;
+ if (var->type->preFetchProc) {
+ if ((*var->type->preFetchProc)(var) < 0)
+ return -1;
+ }
+ }
 Py_BEGIN_ALLOW_THREADS
 status = OCIStmtFetch(self->handle, self->environment->errorHandle,
 numRows, OCI_FETCH_NEXT, OCI_DEFAULT);
 static int Cursor_InternalFetch(
 ""Cursor_InternalFetch(): fetch"") < 0)
 return -1;
 }
- for (i = 0; i < PyList_GET_SIZE(self->fetchVariables); i++) {
- var = (udt_Variable*) PyList_GET_ITEM(self->fetchVariables, i);
- var->internalFetchNum++;
- }
 status = OCIAttrGet(self->handle, OCI_HTYPE_STMT, &rowCount, 0,
 OCI_ATTR_ROW_COUNT, self->environment->errorHandle);
 if (Environment_CheckForError(self->environment, status,
",1591,355
"Remove ""unicode"" mode and simply permit unicode to be used everywhere within
cx_Oracle; stop using ""unicode"" mode in the OCI as well since that appears to
have bugs in some places and doesn't really solve any problems anyway."," static udt_Error *Error_New(
 const char *context, // context in which error occurred
 int retrieveError) // retrieve error from OCI?
 {
- char errorText[1024 * CXORA_BYTES_PER_CHAR];
+ char errorText[4096];
 udt_Error *self;
 ub4 handleType;
 dvoid *handle;
 sword status;
-#ifdef WITH_UNICODE
+#if PY_MAJOR_VERSION >= 3
 Py_ssize_t len;
 #endif
 
 static udt_Error *Error_New(
 PyErr_SetString(g_InternalErrorException, ""No Oracle error?"");
 return NULL;
 }
-#ifdef WITH_UNICODE
- for (len = 0; len < sizeof(errorText); len += 2) {
- if (errorText[len] == 0 && errorText[len + 1] == 0)
- break;
- }
- self->message = cxString_FromEncodedString(errorText, len);
-#else
+#if PY_MAJOR_VERSION < 3
 self->message = PyBytes_FromString(errorText);
+#else
+ len = strlen(errorText);
+ self->message = PyUnicode_Decode(errorText, len, environment->encoding,
+ NULL);
 #endif
 if (!self->message) {
 Py_DECREF(self);
",104,11
Remove redundant code used for determining library path.," elif sys.platform == ""cygwin"":
 libDirs[i] = os.path.join(oracleHome, libDirs[i])
 libs = [""oci""]
 else:
- libPath = os.path.join(oracleHome, ""lib"")
- if struct.calcsize(""P"") == 4:
- alternatePath = os.path.join(oracleHome, ""lib32"")
- else:
- alternatePath = os.path.join(oracleHome, ""lib64"")
- if os.path.exists(alternatePath):
- libPath = alternatePath
- libDirs = [libPath, oracleHome]
+ libDirs = [oracleLibDir]
 libs = [""clntsh""]
 possibleIncludeDirs = [""rdbms/demo"", ""rdbms/public"", ""network/public"",
 ""sdk/include""]
 else:
 if os.path.isdir(path):
 includeDirs.append(path)
 if not includeDirs:
- path = os.path.join(os.path.dirname(libPath), ""include"")
+ path = os.path.join(oracleLibDir, ""include"")
 if os.path.isdir(path):
 includeDirs.append(path)
 if not includeDirs:
",292,21
"Force server detach on close so that the connection is completely dead and not
just the session as previously."," static PyObject *Connection_Close(
 OCIHandleFree(self->handle, OCI_HTYPE_SVCCTX);
 }
 self->handle = NULL;
+ if (self->serverHandle) {
+ status = OCIServerDetach(self->serverHandle,
+ self->environment->errorHandle, OCI_DEFAULT);
+ if (Environment_CheckForError(self->environment, status,
+ ""Connection_Close(): server detach"") < 0)
+ return NULL;
+ self->serverHandle = NULL;
+ }
 
 Py_INCREF(Py_None);
 return Py_None;
",1192,216
"Make use of the PyGILState_Ensure() and PyGILState_Release() methods which
are available in Python 2.3 and up and greatly simplify the code surrounding
thread handling in callbacks made by Oracle. The original code must have had
some small issue in it that was tweaked under high load. Thanks to Calvin S.
for noting the issue and supplying the suggested fix."," static sword Callback_Handler(
 va_list args) // arguments
 {
 #ifdef WITH_THREAD
- PyThreadState *threadState;
+ PyGILState_STATE gstate = PyGILState_Ensure();
 #endif
 sword result;
 
- // create new thread state, if necessary
-#ifdef WITH_THREAD
- threadState = PyThreadState_Swap(NULL);
- if (threadState) {
- PyThreadState_Swap(threadState);
- threadState = NULL;
- } else {
- threadState = PyThreadState_New(g_InterpreterState);
- if (!threadState) {
- PyErr_Print();
- return OCI_ERROR;
- }
- PyEval_AcquireThread(threadState);
- }
-#endif
-
 // perform the call
 result = Callback_Call(tuple, functionCode, args);
 if (result != OCI_CONTINUE)
 static sword Callback_Handler(
 
 // restore thread state, if necessary
 #ifdef WITH_THREAD
- if (threadState) {
- PyThreadState_Clear(threadState);
- PyEval_ReleaseThread(threadState);
- PyThreadState_Delete(threadState);
- }
+ PyGILState_Release(gstate);
 #endif
 
 return result;
",209,26
Fix cursor description to take into account the number of bytes per character.," class TestUnicodeVar(BaseTestCase):
 self.cursor.execute(""select * from TestUnicodes"")
 self.failUnlessEqual(self.cursor.description,
 [ ('INTCOL', cx_Oracle.NUMBER, 10, 22, 9, 0, 0),
- ('UNICODECOL', cx_Oracle.UNICODE, 20, 40, 0, 0, 0),
+ ('UNICODECOL', cx_Oracle.UNICODE, 20,
+ self.connection.maxBytesPerCharacter * 20, 0, 0, 0),
 ('FIXEDUNICODECOL',
- cx_Oracle.FIXED_UNICODE, 40, 80, 0, 0, 0),
- ('NULLABLECOL', cx_Oracle.UNICODE, 50, 100, 0, 0, 1) ])
+ cx_Oracle.FIXED_UNICODE, 40,
+ self.connection.maxBytesPerCharacter * 40, 0, 0, 0),
+ ('NULLABLECOL', cx_Oracle.UNICODE, 50,
+ self.connection.maxBytesPerCharacter * 50, 0, 0, 1) ])
 
 def testFetchAll(self):
 ""test that fetching all of the data returns the correct results""
",215,29
"The prefetch routine should only be run during fetches and not when the LOB
variable is being destroyed! Doing so causes strange errors to be raised."," static void LobVar_Finalize(
 {
 ub4 i;
 
- LobVar_PreFetch(var);
 for (i = 0; i < var->allocatedElements; i++) {
 if (var->data[i])
 OCIDescriptorFree(var->data[i], OCI_DTYPE_LOB);
",325,31
Preparing to release 5.1.1.," except:
 from distutils.extension import Extension
 
 # define build constants
-BUILD_VERSION = ""5.1""
+BUILD_VERSION = ""5.1.1""
 
 # define the list of files to be included as documentation for Windows
 dataFiles = None
",292,21
"Ensure that the temporary LOB is freed before freeing the descriptor; it
seems logical that freeing the descriptor should free the temporary LOB as
well but apparently that is NOT the case!"," static int LobVar_PreFetch(
 static void LobVar_Finalize(
 udt_LobVar *var) // variable to free
 {
+ boolean isTemporary;
 ub4 i;
 
 for (i = 0; i < var->allocatedElements; i++) {
- if (var->data[i])
+ if (var->data[i]) {
+ OCILobIsTemporary(var->environment->handle,
+ var->environment->errorHandle, var->data[i], &isTemporary);
+ if (isTemporary) {
+ Py_BEGIN_ALLOW_THREADS
+ OCILobFreeTemporary(var->connection->handle,
+ var->environment->errorHandle, var->data[i]);
+ Py_END_ALLOW_THREADS
+ }
 OCIDescriptorFree(var->data[i], OCI_DTYPE_LOB);
+ }
 }
 Py_DECREF(var->connection);
 }
",335,32
"Added suport for LONG_UNICODE which is a type that is used to handle long
unicode strings. These are not explicitly supported in Oracle but can be used
to bind to NCLOB, for example, without getting the ""unimplemented or
unreasonable conversion requested"" error."," static int Variable_Check(
 #if PY_MAJOR_VERSION < 3
 Py_TYPE(object) == &g_UnicodeVarType ||
 Py_TYPE(object) == &g_FixedUnicodeVarType ||
+ Py_TYPE(object) == &g_LongUnicodeVarType ||
 #endif
 Py_TYPE(object) == &g_RowidVarType ||
 Py_TYPE(object) == &g_BinaryVarType ||
 static udt_VariableType *Variable_TypeByPythonType(
 return &vt_NationalCharString;
 if (type == (PyObject*) &g_FixedUnicodeVarType)
 return &vt_FixedNationalChar;
+ if (type == (PyObject*) &g_LongUnicodeVarType)
+ return &vt_LongNationalCharString;
 #endif
 if (type == (PyObject*) &g_NCLOBVarType)
 return &vt_NCLOB;
 static udt_VariableType *Variable_TypeByValue(
 if (PyUnicode_Check(value)) {
 *size = PyUnicode_GET_SIZE(value);
 if (*size > MAX_STRING_CHARS)
- return &vt_LongString;
+ return &vt_LongNationalCharString;
 return &vt_NationalCharString;
 }
 if (PyInt_Check(value))
",1103,285
Set the row number for PL/SQL blocks as well as requested by Robert Ritchie.," static int Cursor_SetRowCount(
 self->rowNum = 0;
 } else if (self->statementType == OCI_STMT_INSERT ||
 self->statementType == OCI_STMT_UPDATE ||
- self->statementType == OCI_STMT_DELETE) {
+ self->statementType == OCI_STMT_DELETE ||
+ self->statementType == OCI_STMT_BEGIN ||
+ self->statementType == OCI_STMT_DECLARE) {
 status = OCIAttrGet(self->handle, OCI_HTYPE_STMT, &rowCount, 0,
 OCI_ATTR_ROW_COUNT, self->environment->errorHandle);
 if (Environment_CheckForError(self->environment, status,
",1588,355
Preparing to release 5.1.2.," except:
 from distutils.extension import Extension
 
 # define build constants
-BUILD_VERSION = ""5.1.1""
+BUILD_VERSION = ""5.1.2""
 
 # define the list of files to be included as documentation for Windows
 dataFiles = None
",292,21
Updated documentation and bumped copyright into 2012.,"
 * doctools.js
 * ~~~~~~~~~~~
 *
- * Sphinx JavaScript utilties for all documentation.
+ * Sphinx JavaScript utilities for all documentation.
 *
 * :copyright: Copyright 2007-2011 by the Sphinx team, see AUTHORS.
 * :license: BSD, see LICENSE for details.
 var Documentation = {
 body.highlightText(this.toLowerCase(), 'highlighted');
 });
 }, 10);
- $('<li class=""highlight-link""><a href=""javascript:Documentation.' +
- 'hideSearchWords()"">' + _('Hide Search Matches') + '</a></li>')
- .appendTo($('.sidebar .this-page-menu'));
+ $('<p class=""highlight-link""><a href=""javascript:Documentation.' +
+ 'hideSearchWords()"">' + _('Hide Search Matches') + '</a></p>')
+ .appendTo($('#searchbox'));
 }
 },
 
 var Documentation = {
 * helper function to hide the search marks again
 */
 hideSearchWords : function() {
- $('.sidebar .this-page-menu li.highlight-link').fadeOut(300);
+ $('#searchbox .highlight-link').fadeOut(300);
 $('span.highlighted').removeClass('highlighted');
 },
 
",151,49
"Use the actual name of the class, not a manufactured name."," static PyGetSetDef g_CursorCalcMembers[] = {
 //-----------------------------------------------------------------------------
 static PyTypeObject g_CursorType = {
 PyVarObject_HEAD_INIT(NULL, 0)
- ""OracleCursor"", // tp_name
+ ""cx_Oracle.Cursor"", // tp_name
 sizeof(udt_Cursor), // tp_basicsize
 0, // tp_itemsize
 (destructor) Cursor_Free, // tp_dealloc
",1588,355
64-bit fix to stop self.db.current_schema sometimes throwing MemoryError," static PyObject *Connection_GetOCIAttr(
 {
 OCISession *sessionHandle;
 udt_Buffer buffer;
+ ub4 ub4size;
 sword status;
 
 // make sure connection is connected
 static PyObject *Connection_GetOCIAttr(
 
 // get the value from the OCI
 status = OCIAttrGet(sessionHandle, OCI_HTYPE_SESSION,
- (text**) &buffer.ptr, (ub4*) &buffer.size, *attribute,
+ (text**) &buffer.ptr, &ub4size, *attribute,
 self->environment->errorHandle);
 if (Environment_CheckForError(self->environment, status,
 ""Connection_GetOCIAttr()"") < 0)
 return NULL;
 
+ buffer.size = ub4size;
 return cxString_FromEncodedString(buffer.ptr, buffer.size,
 self->environment->encoding);
 }
",1238,226
Use different variable name to be more consistent with other code.," static PyObject *Connection_GetOCIAttr(
 {
 OCISession *sessionHandle;
 udt_Buffer buffer;
- ub4 ub4size;
+ ub4 bufferSize;
 sword status;
 
 // make sure connection is connected
 static PyObject *Connection_GetOCIAttr(
 
 // get the value from the OCI
 status = OCIAttrGet(sessionHandle, OCI_HTYPE_SESSION,
- (text**) &buffer.ptr, &ub4size, *attribute,
+ (text**) &buffer.ptr, &bufferSize, *attribute,
 self->environment->errorHandle);
 if (Environment_CheckForError(self->environment, status,
 ""Connection_GetOCIAttr()"") < 0)
 return NULL;
 
- buffer.size = ub4size;
+ buffer.size = bufferSize;
 return cxString_FromEncodedString(buffer.ptr, buffer.size,
 self->environment->encoding);
 }
",1238,226
"Remove tabs in favor of spaces in order to be consistent with all of the other
files."," static int Message_Initialize(
 #if ORACLE_VERSION_HEX >= ORACLE_VERSION(11, 1)
 dvoid **queryDescriptor;
 udt_MessageQuery *query;
-OCIColl *queries;
-sb4 numQueries;
+ OCIColl *queries;
+ sb4 numQueries;
 #endif
 sword status;
 
",875,115
Fixed two memoty leaks," static int Environment_SetBuffer(
 obj = cxString_FromAscii(value);
 if (!obj)
 return -1;
- return cxBuffer_FromObject(buf, obj, encoding);
+ if (cxBuffer_FromObject(buf, obj, encoding)<0)
+ return -1;
+ Py_CLEAR(obj);
+
+ return 0;
 }
 
 
",293,75
Try reading potentially-long integers as ints before creating strings for performance," static PyObject *NumberVar_GetValue(
 return PyBool_FromLong(integerValue);
 }
 
+ if (var->type == &vt_LongInteger) {
+ // try as int first, as it is faster and usually works
+ status = OCINumberToInt(var->environment->errorHandle, &var->data[pos],
+ sizeof(long), OCI_NUMBER_SIGNED, (dvoid*) &integerValue);
+ if (status == OCI_SUCCESS) {
+ return PyInt_FromLong(integerValue);
+ }
+ }
 if (var->type == &vt_NumberAsString || var->type == &vt_LongInteger) {
 stringLength = sizeof(stringValue);
 status = OCINumberToText(var->environment->errorHandle,
",465,43
Removed unintended change in file header comment,"
 //-----------------------------------------------------------------------------
-// Numbervar.c
+// NumberVar.c
 // Defines the routines for handling numeric variables.
 //-----------------------------------------------------------------------------
 
",471,68
MSVC does not like C99," static int NumberVar_SetValue(
 static int FitsInLong(OCINumber *num)
 {
 static int MAX_LONG_SAFE_DIGITS = sizeof(long) >= 8 ? 18 : 9;
+ int exponent, maxdigits;
 unsigned char exponent_byte = ((unsigned char *)num)[1];
 if (exponent_byte==128) return 1; // 0 gets exponent 128
- int exponent = (int)(exponent_byte >= 128 ? exponent_byte : ~exponent_byte) - (128+65);
- int maxdigits = (exponent + 1) * 2; // exponent is for base 100
+ exponent = (int)(exponent_byte >= 128 ? exponent_byte : ~exponent_byte) - (128+65);
+ maxdigits = (exponent + 1) * 2; // exponent is for base 100
 return (maxdigits <= MAX_LONG_SAFE_DIGITS);
 }
 
",469,66
Avoid spurious error.," class TestUnicodeVar(BaseTestCase):
 self.cursor.execute(""select * from TestUnicodes"")
 self.failUnlessEqual(self.cursor.description,
 [ ('INTCOL', cx_Oracle.NUMBER, 10, 22, 9, 0, 0),
- ('UNICODECOL', cx_Oracle.UNICODE, 20,
- self.connection.maxBytesPerCharacter * 20, 0, 0, 0),
- ('FIXEDUNICODECOL',
- cx_Oracle.FIXED_UNICODE, 40,
- self.connection.maxBytesPerCharacter * 40, 0, 0, 0),
- ('NULLABLECOL', cx_Oracle.UNICODE, 50,
- self.connection.maxBytesPerCharacter * 50, 0, 0, 1) ])
+ ('UNICODECOL', cx_Oracle.UNICODE, 20, 40, 0, 0, 0),
+ ('FIXEDUNICODECOL', cx_Oracle.FIXED_UNICODE,
+ 40, 80, 0, 0, 0),
+ ('NULLABLECOL', cx_Oracle.UNICODE, 50, 100, 0, 0, 1) ])
 
 def testFetchAll(self):
 ""test that fetching all of the data returns the correct results""
",212,29
"OCI_ATTR_PARSE_ERROR_OFFSET should be of type ub2; also handle case when the
exception has been normalized already (and with this change force the exception
to be normalized) as in that case the cx_Oracle.Error object is not directly
accessible as originally assumed (which caused a segfault to take place)."," static int Cursor_SetRowCount(
 static void Cursor_SetErrorOffset(
 udt_Cursor *self) // cursor to get the error offset from
 {
- PyObject *type, *value, *traceback;
+ PyObject *type, *value, *traceback, *args;
 udt_Error *error;
+ ub2 offset = 0;
 
 PyErr_Fetch(&type, &value, &traceback);
 if (type == g_DatabaseErrorException) {
- error = (udt_Error*) value;
- OCIAttrGet(self->handle, OCI_HTYPE_STMT, &error->offset, 0,
+ PyErr_NormalizeException(&type, &value, &traceback);
+ OCIAttrGet(self->handle, OCI_HTYPE_STMT, &offset, 0,
 OCI_ATTR_PARSE_ERROR_OFFSET, self->environment->errorHandle);
+ args = PyObject_GetAttrString(value, ""args"");
+ error = (udt_Error*) PyTuple_GET_ITEM(args, 0);
+ error->offset = offset;
+ Py_DECREF(args);
 }
 PyErr_Restore(type, value, traceback);
 }
",1593,355
"Ensure that in Python 3 NCHAR and NVARCHAR2 and NCLOB columns are retrieved
properly without conversion issues. Thanks to Joakim Andersson for pointing
out the issue and the possible solution."," static udt_VariableType *Variable_TypeByOracleDataType (
 case SQLT_LNG:
 return &vt_LongString;
 case SQLT_AFC:
-#if PY_MAJOR_VERSION < 3
 if (charsetForm == SQLCS_NCHAR)
 return &vt_FixedNationalChar;
-#endif
 return &vt_FixedChar;
 case SQLT_CHR:
-#if PY_MAJOR_VERSION < 3
 if (charsetForm == SQLCS_NCHAR)
 return &vt_NationalCharString;
-#endif
 return &vt_String;
 case SQLT_RDD:
 return &vt_Rowid;
 static int Variable_InternalBind(
 ""Variable_InternalBind()"") < 0)
 return -1;
 
-#if PY_MAJOR_VERSION < 3
 // set the charset form and id if applicable
 if (var->type->charsetForm != SQLCS_IMPLICIT) {
 status = OCIAttrSet(var->bindHandle, OCI_HTYPE_BIND,
 static int Variable_InternalBind(
 ""Variable_InternalBind(): set max data size"") < 0)
 return -1;
 }
-#endif
 
 // set the max data size for strings
 if ((var->type == &vt_String || var->type == &vt_FixedChar)
",1103,282
Remove references to documentation that has been moved to Read the Docs.," if sys.platform in (""win32"", ""cygwin""):
 baseName = ""cx_Oracle-doc""
 dataFiles = [ (baseName,
 [ ""BUILD.txt"", ""LICENSE.TXT"", ""README.TXT"", ""HISTORY.txt""]) ]
- for dir in (""html"", ""html/_static"", ""samples"", ""test""):
+ for dir in (""samples"", ""test""):
 files = []
 fullDirName = ""%s/%s"" % (baseName, dir)
 for name in os.listdir(dir):
 if sys.platform in (""win32"", ""cygwin""):
 dataFiles.append((fullDirName, files))
 
 # define the list of files to be included as documentation for bdist_rpm
-docFiles = ""LICENSE.txt README.txt BUILD.txt HISTORY.txt html samples test""
+docFiles = ""README.txt BUILD.txt samples test""
 
 # method for checking a potential Oracle home
 def CheckOracleHome(directoryToCheck):
",295,21
Preparing to release 4.1.3.," except:
 from distutils.extension import Extension
 
 # define build constants
-BUILD_VERSION = ""5.1.2""
+BUILD_VERSION = ""5.1.3""
 
 # define the list of files to be included as documentation for Windows
 dataFiles = None
",295,21
Remove reference to text files which are no longer being distributed.," dataFiles = None
 if sys.platform in (""win32"", ""cygwin""):
 baseName = ""cx_Oracle-doc""
 dataFiles = [ (baseName,
- [ ""BUILD.txt"", ""LICENSE.TXT"", ""README.TXT"", ""HISTORY.txt""]) ]
+ [ ""BUILD.txt"", ""README.txt""]) ]
 for dir in (""samples"", ""test""):
 files = []
 fullDirName = ""%s/%s"" % (baseName, dir)
",295,21
"Expose the UNICODE, FIXED_UNICODE and LONG_UNICODE types so that in Python 3
one can actually specify the use of the NCHAR type fields when binding or using
setinputsizes()."," static PyObject *Cursor_ItemDescriptionHelper(
 type = (PyObject*) varType->pythonType;
 if (type == (PyObject*) &g_StringVarType)
 displaySize = charSize;
-#if PY_MAJOR_VERSION < 3
 else if (type == (PyObject*) &g_UnicodeVarType)
 displaySize = charSize;
-#endif
 else if (type == (PyObject*) &g_BinaryVarType)
 displaySize = internalSize;
 else if (type == (PyObject*) &g_FixedCharVarType)
 displaySize = charSize;
-#if PY_MAJOR_VERSION < 3
 else if (type == (PyObject*) &g_FixedUnicodeVarType)
 displaySize = charSize;
-#endif
 else if (type == (PyObject*) &g_NumberVarType) {
 if (precision) {
 displaySize = precision + 1;
",1593,353
Add support for connections as SYSASM," static PyObject *Module_Initialize(void)
 ADD_OCI_CONSTANT(SUBSCR_CQ_QOS_QUERY)
 ADD_OCI_CONSTANT(SUBSCR_CQ_QOS_BEST_EFFORT)
 ADD_OCI_CONSTANT(SUBSCR_CQ_QOS_CLQRYCACHE)
+ ADD_OCI_CONSTANT(SYSASM)
 #endif
 #if ORACLE_VERSION_HEX >= ORACLE_VERSION(11, 2)
 ADD_OCI_CONSTANT(SUBSCR_QOS_HAREG)
",329,46
"Booleans are subclassed to integer so ensure that the boolean is checked first;
this wasn't a problem in Python 2.x but has become one in Python 3.x."," static int NumberVar_SetValue(
 if (PyInt_Check(value))
 return NumberVar_SetValueFromInteger(var, pos, value);
 #endif
- if (PyLong_Check(value))
- return NumberVar_SetValueFromLong(var, pos, value);
 if (PyBool_Check(value))
 return NumberVar_SetValueFromBoolean(var, pos, value);
+ if (PyLong_Check(value))
+ return NumberVar_SetValueFromLong(var, pos, value);
 if (PyFloat_Check(value))
 return NumberVar_SetValueFromFloat(var, pos, value);
 if (Py_TYPE(value) == g_DecimalType)
",459,60
"Ensure that sessions are released to the pool when calling connection.close();
this resolves issue 2:
https://bitbucket.org/anthony_tuininga/cx_oracle/issue/2/use-of-cclass-causes-connection-leaks"," static PyObject *SessionPool_InternalRelease(
 Py_DECREF(connection->sessionPool);
 connection->sessionPool = NULL;
 connection->handle = NULL;
+ connection->release = 0;
 
 Py_INCREF(Py_None);
 return Py_None;
",380,52
"Remove code specific to strings being 4000 characters now that Oracle 12c has
the ability to have strings up to 32k characters. This implies that using
setinputsizes() is necessary if a long string type is desired as this will not
occur automatically when the string exceeds 4000 characters. Tests are tidied
up to remove the ""p_"" prefix from all bind variables."," class TestCursorVar(BaseTestCase):
 self.failUnlessEqual(cursor.description, None)
 self.cursor.execute(""""""
 begin
- open :p_Cursor for select 'X' StringValue from dual;
+ open :cursor for select 'X' StringValue from dual;
 end;"""""",
- p_Cursor = cursor)
+ cursor = cursor)
 self.failUnlessEqual(cursor.description,
 [ ('STRINGVALUE', cx_Oracle.FIXED_CHAR, 1, 1, 0, 0, 1) ])
 self.failUnlessEqual(cursor.fetchall(), [('X',)])
",42,4
Use the constant defined by Oracle rather than a hard coded amount.," typedef struct {
 } udt_Error;
 
 
+//-----------------------------------------------------------------------------
+// maximum size of error message string in bytes
+//-----------------------------------------------------------------------------
+#ifdef OCI_ERROR_MAXMSG_SIZE2
+#define ERROR_BUF_SIZE OCI_ERROR_MAXMSG_SIZE2
+#else
+#define ERROR_BUF_SIZE OCI_ERROR_MAXMSG_SIZE
+#endif
+
+
 //-----------------------------------------------------------------------------
 // forward declarations
 //-----------------------------------------------------------------------------
 static udt_Error *Error_New(
 const char *context, // context in which error occurred
 int retrieveError) // retrieve error from OCI?
 {
- char errorText[4096];
+ char errorText[ERROR_BUF_SIZE];
 udt_Error *self;
 ub4 handleType;
 dvoid *handle;
",104,11
Added support for getting array DML row counts (new to Oracle 12c).," static PyObject *Subscription_RegisterQuery(
 }
 
 // execute the query which registers it
- if (Cursor_InternalExecute(cursor, 0) < 0) {
+ if (Cursor_InternalExecute(cursor, 0, 0) < 0) {
 Py_DECREF(cursor);
 return NULL;
 }
",876,115
Made test suite Python3 compatible," import os
 import sys
 import unittest
 
+if sys.version_info[0] < 3:
+ input = raw_input
+
 def GetValue(name, label):
 value = os.environ.get(""CX_ORACLE_"" + name)
 if value is None:
- value = raw_input(label + "": "")
+ value = input(label + "": "")
 if hasattr(cx_Oracle, ""UNICODE"") or sys.version_info[0] >= 3:
 return value
 return unicode(value)
",18,4
"Added a test to expose the problem with intervals, and a fix that makes it pass"," static int IntervalVar_SetValue(
 seconds -= minutes * 60;
 status = OCIIntervalSetDaySecond(var->environment->handle,
 var->environment->errorHandle, delta->days, hours, minutes,
- seconds, delta->microseconds, var->data[pos]);
+ seconds, delta->microseconds*1000, var->data[pos]);
 if (Environment_CheckForError(var->environment, status,
 ""IntervalVar_SetValue()"") < 0)
 return -1;
",105,10
"Display the build time when running tests in order to make clear what version
is actually being tested."," import os
 import sys
 import unittest
 
-print ""Running tests for cx_Oracle version"", cx_Oracle.version
+print ""Running tests for cx_Oracle version"", cx_Oracle.version,
+print cx_Oracle.buildtime
 
 import TestEnv
 
",77,2
"If NLS_LANG is not set, ensure it is set to a value that works."," import os
 import sys
 import unittest
 
+lang = os.environ.get(""NLS_LANG"")
+if lang is None:
+ os.environ[""NLS_LANG""] = "".UTF8""
 if sys.version_info[0] < 3:
 input = raw_input
 
",21,4
"Reorganize the code for handling errors so that the same code can be used for
managing batch errors as well as raising exceptions in the ordinary case."," static int Variable_VerifyFetch(
 
 if (var->type->isVariableLength) {
 if (var->returnCode[arrayPos] != 0) {
- error = Error_New(var->environment, ""Variable_VerifyFetch()"", 0);
+ error = Error_New(var->environment, ""Variable_VerifyFetch()"", 0,
+ NULL);
 error->code = var->returnCode[arrayPos];
 sprintf(messageText, 
 ""column at array pos %d fetched with error: %d"",
",1094,276
Added tests for Array DML and Batch Error features.," if len(sys.argv) > 1 and not inSetup:
 moduleNames = [os.path.splitext(v)[0] for v in sys.argv[1:]]
 else:
 moduleNames = [
+ ""ArrayDMLBatchError"",
+ ""uArrayDMLBatchError"",
 ""Connection"",
 ""uConnection"",
 ""Cursor"",
",79,2
The next release will be named 5.2.," except:
 from distutils.extension import Extension
 
 # define build constants
-BUILD_VERSION = ""5.1.3""
+BUILD_VERSION = ""5.2""
 
 # define the list of files to be included as documentation for Windows
 dataFiles = None
",321,29
Re-enable support for Python 2.4 (used on RHEL/CentOS 5).," def FindInstantClientRPMInclude(libDir):
 # define Linux Instant Client RPM path components
 # Assume 64 bit builds if the platform is 64 bit
 rpmBaseLibDir = ""/usr/lib/oracle""
-rpmClientDir = ""client"" if struct.calcsize(""P"") == 4 else ""client64""
+if struct.calcsize(""P"") == 4:
+ rpmClientDir = ""client""
+else:
+ rpmClientDir = ""client64""
 instantClientRPMLib = None
 
 # try to determine the Oracle home
",324,29
"Remove remaining remnants of support for Oracle 9i (and notes in documentation
at the same time).","
 //-----------------------------------------------------------------------------
 // SessionPool.c
-// Handles session pooling (only available in Oracle 9i and up).
+// Handles session pooling.
 //-----------------------------------------------------------------------------
 
 //-----------------------------------------------------------------------------
",380,52
Correct execution of tests with Oracle 11g client.," static udt_VariableType *Variable_TypeByValue(
 }
 if (cxString_Check(value)) {
 *size = cxString_GetSize(value);
+ if (*size > 32768)
+ return &vt_LongString;
 return &vt_String;
 }
 #if PY_MAJOR_VERSION < 3
 if (PyUnicode_Check(value)) {
 *size = PyUnicode_GET_SIZE(value);
+ if (*size > 32768)
+ return &vt_LongNationalCharString;
 return &vt_NationalCharString;
 }
 if (PyInt_Check(value))
 static udt_Variable *Variable_NewByType(
 size = PyInt_AsLong(value);
 if (PyErr_Occurred())
 return NULL;
- varType = &vt_String;
+ if (size > 32768)
+ varType = &vt_LongString;
+ else varType = &vt_String;
 return Variable_New(cursor, numElements, varType, size);
 }
 
",1100,279
"Remove conditional statements looking for SQLT_BFLOAT since that was
introduced in 10g Release 1 and cx_Oracle does not support anything earlier
than that anyway!"," static int Variable_Check(
 Py_TYPE(object) == &g_RowidVarType ||
 Py_TYPE(object) == &g_BinaryVarType ||
 Py_TYPE(object) == &g_TimestampVarType ||
- Py_TYPE(object) == &g_IntervalVarType
-#ifdef SQLT_BFLOAT
- || Py_TYPE(object) == &g_NativeFloatVarType
-#endif
- );
+ Py_TYPE(object) == &g_IntervalVarType ||
+ Py_TYPE(object) == &g_NativeFloatVarType);
 }
 
 
 static udt_VariableType *Variable_TypeByPythonType(
 return &vt_Timestamp;
 if (type == (PyObject*) &g_CursorVarType)
 return &vt_Cursor;
-#ifdef SQLT_BFLOAT
 if (type == (PyObject*) &g_NativeFloatVarType)
 return &vt_NativeFloat;
-#endif
 if (type == (PyObject*) &g_ObjectVarType)
 return &vt_Object;
 
 static udt_VariableType *Variable_TypeByOracleDataType (
 return &vt_Binary;
 case SQLT_LBI:
 return &vt_LongBinary;
-#ifdef SQLT_BFLOAT
 case SQLT_BFLOAT:
 case SQLT_IBFLOAT:
 case SQLT_BDOUBLE:
 case SQLT_IBDOUBLE:
 return &vt_NativeFloat;
-#endif
 case SQLT_NUM:
 case SQLT_VNU:
 return &vt_Float;
",1099,276
"Remove #ifdef surrounding OCI_EVENTS since it was defined in Oracle 10g, the
minimum release supported by cx_Oracle."," static udt_Environment *Environment_NewFromScratch(
 mode = OCI_OBJECT;
 if (threaded)
 mode |= OCI_THREADED;
-#ifdef OCI_EVENTS
 if (events)
 mode |= OCI_EVENTS;
-#endif
 
 // create the new environment handle
 status = OCIEnvNlsCreate(&handle, mode, NULL, NULL, NULL, NULL, 0, NULL, 0,
",230,38
"Issue #14 Added __version__ attribute

__version__ attribute added to conform with PEP 396."," static PyObject *Module_Initialize(void)
 if (PyModule_AddStringConstant(module, ""version"",
 BUILD_VERSION_STRING) < 0)
 return NULL;
+ if (PyModule_AddStringConstant(module, ""__version__"",
+ BUILD_VERSION_STRING) < 0)
+ return NULL;
 if (PyModule_AddStringConstant(module, ""buildtime"",
 __DATE__ "" "" __TIME__) < 0)
 return NULL;
",332,45
"Added support for NCHAR, FIXED_NCHAR and LONG_NCHAR, which are the same as the
types UNICODE, FIXED_UNICODE and LONG_UNICODE (now deprecated)."," static PyObject *Cursor_ItemDescriptionHelper(
 type = (PyObject*) varType->pythonType;
 if (type == (PyObject*) &g_StringVarType)
 displaySize = charSize;
- else if (type == (PyObject*) &g_UnicodeVarType)
+ else if (type == (PyObject*) &g_NCharVarType)
 displaySize = charSize;
 else if (type == (PyObject*) &g_BinaryVarType)
 displaySize = internalSize;
 else if (type == (PyObject*) &g_FixedCharVarType)
 displaySize = charSize;
- else if (type == (PyObject*) &g_FixedUnicodeVarType)
+ else if (type == (PyObject*) &g_FixedNCharVarType)
 displaySize = charSize;
 else if (type == (PyObject*) &g_NumberVarType) {
 if (precision) {
",1712,373
"No need to check the type since a Unicode object is perfectly acceptable in
Python 2 and the cxBuffer_FromObject() method checks the type anyway."," static int Connection_SetOCIAttr(
 udt_Buffer buffer;
 sword status;
 
- // verify arguments
- if (!cxString_Check(value)) {
- PyErr_SetString(PyExc_TypeError, ""value must be a string"");
- return -1;
- }
-
 // make sure connection is connected
 if (Connection_IsConnected(self) < 0)
 return -1;
",1250,226
"Removed password attribute from connection and session pool objects in order
to promote best security practices (if stored in RAM in cleartext it can be
read in process dumps, for example). For those who would like to retain this
feature, a subclass of Connection could be used to store the password."," class TestConnection(TestCase):
 def verifyArgs(self, connection):
 self.failUnlessEqual(connection.username, self.username,
 ""user name differs"")
- self.failUnlessEqual(connection.password, self.password,
- ""password differs"")
 self.failUnlessEqual(connection.tnsentry, self.tnsentry,
 ""tnsentry differs"")
 
",97,15
"Use the national character set encoding if setting a value with the national
character set needing to be used; otherwise, the wrong encoding could be used
if the environment variable NLS_NCHAR is set."," static int StringVar_SetValue(
 PyObject *value) // value to set
 {
 udt_Buffer buffer;
+ char *encoding;
+
+ // determine which encoding should be used
+ if (var->type->charsetForm == SQLCS_NCHAR)
+ encoding = var->environment->nencoding;
+ else encoding = var->environment->encoding;
 
 // populate the buffer and confirm the maximum size is not exceeded
- if (cxBuffer_FromObject(&buffer, value, var->environment->encoding) < 0)
+ if (cxBuffer_FromObject(&buffer, value, encoding) < 0)
 return -1;
 
 // ensure that the buffer is large enough
",334,17
Eliminate compiler warning.," static int Cursor_FreeHandle(
 self->environment, status, ""Cursor_FreeHandle()"") < 0)
 return -1;
 } else if (self->connection->handle != 0) {
- if (!cxBuffer_FromObject(&buffer, self->statementTag,
+ if (cxBuffer_FromObject(&buffer, self->statementTag,
 self->environment->encoding) < 0)
 return (raiseException) ? -1 : 0;
 status = OCIStmtRelease(self->handle,
",1712,373
"Added support for binding boolean values to PL/SQL booleans -- a feature that
is only available in Oracle 12.1 and higher."," static udt_VariableType vt_NumberAsString = {
 };
 
 
+#if ORACLE_VERSION_HEX < ORACLE_VERSION(12, 1)
 static udt_VariableType vt_Boolean = {
 (InitializeProc) NULL,
 (FinalizeProc) NULL,
 static udt_VariableType vt_Boolean = {
 1, // can be copied
 1 // can be in array
 };
+#endif
 
 
 //-----------------------------------------------------------------------------
",459,60
"Display the file that is being used for the test run (useful when multiple
environments are being used)."," import unittest
 
 print ""Running tests for cx_Oracle version"", cx_Oracle.version,
 print cx_Oracle.buildtime
+print ""File:"", cx_Oracle.__file__
+sys.stdout.flush()
 
 import TestEnv
 
",83,2
Preparing to release 5.2.1.," except:
 from distutils.extension import Extension
 
 # define build constants
-BUILD_VERSION = ""5.2""
+BUILD_VERSION = ""5.2.1""
 
 # define the list of files to be included as documentation for Windows
 dataFiles = None
",321,29
"Added support for setting the instant client version that should be used when
multiple instant clients are installed -- by setting the environment variable
IC_VERSION."," def CheckOracleHome(directoryToCheck):
 # Older Instant Client dirs have the form:
 # /usr/lib/oracle/10.2.0.5/client[64]/lib
 def FindInstantClientRPMLib():
- versions = []
- for path in glob.glob(os.path.join(rpmBaseLibDir, ""[0-9.]*"")):
- versions.append(os.path.basename(path))
- versions.sort(key = lambda x: [int(s) for s in x.split(""."")])
- versions.reverse()
+ version = os.environ.get(""IC_VERSION"")
+ if version is not None:
+ versions = [version]
+ else:
+ versions = []
+ for path in glob.glob(os.path.join(rpmBaseLibDir, ""[0-9.]*"")):
+ versions.append(os.path.basename(path))
+ versions.sort(key = lambda x: [int(s) for s in x.split(""."")])
+ versions.reverse()
 for version in versions:
 path = os.path.join(rpmBaseLibDir, version, rpmClientDir, ""lib"")
 if os.path.exists(path) and CheckOracleHome(path):
",325,30
"Change driver name to match informal driver standard used by Oracle for other
drivers."," typedef int Py_ssize_t;
 #define xstr(s) str(s)
 #define str(s) #s
 #define BUILD_VERSION_STRING xstr(BUILD_VERSION)
-#define DRIVER_NAME ""cx_Oracle-""BUILD_VERSION_STRING
+#define DRIVER_NAME ""cx_Oracle : ""BUILD_VERSION_STRING
 
 #include ""Buffer.c""
 
",337,47
"Added support for pickling/unpickling error objects; this addresses issue 23
(https://bitbucket.org/anthony_tuininga/cx_oracle/issues/23/cx_oracle_error-is-not-un-picklable)"," static int Cursor_GetBatchErrorsHelper(
 return -1;
 
 // determine error object
- errorObj = Error_New(self->environment, ""Batch Error"", OCI_HTYPE_ERROR,
- localErrorHandle);
+ errorObj = Error_InternalNew(self->environment, ""Batch Error"",
+ OCI_HTYPE_ERROR, localErrorHandle);
 if (!errorObj)
 return -1;
 errorObj->offset = rowOffset;
",1712,375
Added test case for pickling/unpickling error objects.,"
+""""""Module for testing error objects.""""""
+
+import cx_Oracle
+import pickle
+
+class TestBooleanVar(BaseTestCase):
+
+ def testPickleError(self):
+ ""test picking/unpickling an error object""
+ errorObj = None
+ try:
+ self.cursor.execute(""""""
+ begin
+ raise_application_error(-20101, 'Test!');
+ end;"""""")
+ except cx_Oracle.Error as e:
+ errorObj, = e.args
+ self.assertEqual(type(errorObj), cx_Oracle._Error)
+ self.assertTrue(""Test!"" in errorObj.message)
+ self.assertEqual(errorObj.code, 20101)
+ self.assertEqual(errorObj.offset, 0)
+ self.assertEqual(errorObj.context, ""Cursor_InternalExecute()"")
+ pickledData = pickle.dumps(errorObj)
+ newErrorObj = pickle.loads(pickledData)
+ self.assertEqual(type(newErrorObj), cx_Oracle._Error)
+ self.assertTrue(newErrorObj.message == errorObj.message)
+ self.assertTrue(newErrorObj.code == errorObj.code)
+ self.assertTrue(newErrorObj.offset == errorObj.offset)
+ self.assertTrue(newErrorObj.context == errorObj.context)
+
",26,2
"Simplify test suite by combining Python 2 and 3 scripts into one script that
runs on both without changes; rename ArrayDMLBatchError to Features12_1 in
preparation for adding additional 12.1 features."," class test(distutils.core.Command):
 buildCommand = self.distribution.get_command_obj(""build"")
 sys.path.insert(0, os.path.abspath(""test""))
 sys.path.insert(0, os.path.abspath(buildCommand.build_lib))
- if sys.version_info[0] < 3:
- execfile(os.path.join(""test"", ""test.py""))
- else:
- fileName = os.path.join(""test"", ""test3k.py"")
- exec(open(fileName).read())
+ fileName = os.path.join(""test"", ""test.py"")
+ exec(open(fileName).read())
 
 commandClasses = dict(build = build, bdist_rpm = bdist_rpm, test = test)
 
",322,29
Update samples to use syntax that works on both Python 2 and 3.,"
 # type handler to change the way in which data is returned from a cursor.
 #------------------------------------------------------------------------------
 
+from __future__ import print_function
+
 import cx_Oracle
 
 def OutputTypeHandler(cursor, name, defaultType, size, precision, scale):
 if defaultType in (cx_Oracle.STRING, cx_Oracle.FIXED_CHAR):
 return cursor.var(unicode, size, cursor.arraysize)
 
-connection = cx_Oracle.Connection(""cx_Oracle/password"")
+connection = cx_Oracle.Connection(""user/pw@tns"")
 connection.outputtypehandler = OutputTypeHandler
 cursor = connection.cursor()
 cursor.execute(""select * from teststrings"")
 for row in cursor:
- print ""Row:"", row
+ print(""Row:"", row)
 
",11,2
"Added support for Transaction Guard by including the attributes
connection.ltxid and error.isrecoverable as well as a sample that indicates
how it could be used."," class TestBooleanVar(BaseTestCase):
 self.assertEqual(errorObj.code, 20101)
 self.assertEqual(errorObj.offset, 0)
 self.assertEqual(errorObj.context, ""Cursor_InternalExecute()"")
+ self.assertTrue(isinstance(errorObj.isrecoverable, bool))
 pickledData = pickle.dumps(errorObj)
 newErrorObj = pickle.loads(pickledData)
 self.assertEqual(type(newErrorObj), cx_Oracle._Error)
 class TestBooleanVar(BaseTestCase):
 self.assertTrue(newErrorObj.code == errorObj.code)
 self.assertTrue(newErrorObj.offset == errorObj.offset)
 self.assertTrue(newErrorObj.context == errorObj.context)
+ self.assertTrue(newErrorObj.isrecoverable == errorObj.isrecoverable)
 
",28,2
"Added support for setting the max lifetime session of pool connections, a
feature added to Oracle Database in 12.1."," static ub4 gc_OpenAttribute = OCI_ATTR_SPOOL_OPEN_COUNT;
 static ub4 gc_BusyAttribute = OCI_ATTR_SPOOL_BUSY_COUNT;
 static ub4 gc_TimeoutAttribute = OCI_ATTR_SPOOL_TIMEOUT;
 static ub4 gc_GetModeAttribute = OCI_ATTR_SPOOL_GETMODE;
+#if ORACLE_VERSION_HEX >= ORACLE_VERSION(12, 1)
+static ub4 gc_MaxLifetimeAttribute = OCI_ATTR_SPOOL_MAX_LIFETIME_SESSION;
+#endif
 
 //-----------------------------------------------------------------------------
 // functions for the Python type ""SessionPool""
 static PyGetSetDef g_SessionPoolCalcMembers[] = {
 (setter) SessionPool_SetOCIAttr, 0, &gc_TimeoutAttribute },
 { ""getmode"", (getter) SessionPool_GetOCIAttr,
 (setter) SessionPool_SetOCIAttr, 0, &gc_GetModeAttribute },
+#if ORACLE_VERSION_HEX >= ORACLE_VERSION(12, 1)
+ { ""max_lifetime_session"", (getter) SessionPool_GetOCIAttr,
+ (setter) SessionPool_SetOCIAttr, 0, &gc_MaxLifetimeAttribute },
+#endif
 { NULL }
 };
 
",390,54
Eliminated potential memory leak.," static int Environment_SetBuffer(
 obj = cxString_FromAscii(value);
 if (!obj)
 return -1;
- if (cxBuffer_FromObject(buf, obj, encoding)<0)
+ if (cxBuffer_FromObject(buf, obj, encoding) < 0) {
+ Py_DECREF(obj);
 return -1;
+ }
 Py_CLEAR(obj);
 
 return 0;
",233,38
Logical transaction id is only available in 12.1.," static PyObject *Connection_Shutdown(udt_Connection*, PyObject*, PyObject*);
 static PyObject *Connection_Startup(udt_Connection*, PyObject*, PyObject*);
 static PyObject *Connection_Subscribe(udt_Connection*, PyObject*, PyObject*);
 #endif
-#if ORACLE_VERSION_HEX >= ORACLE_VERSION(10, 2)
+#if ORACLE_VERSION_HEX >= ORACLE_VERSION(12, 1)
 static PyObject *Connection_GetLTXID(udt_Connection*, void*);
 #endif
 
",1270,229
"Added support for binding native integers which has a slight performance
advantage."," static int Variable_Check(
 #if ORACLE_VERSION_HEX >= ORACLE_VERSION(12,1)
 Py_TYPE(object) == &g_BooleanVarType ||
 #endif
- Py_TYPE(object) == &g_NativeFloatVarType);
+ Py_TYPE(object) == &g_NativeFloatVarType ||
+ Py_TYPE(object) == &g_NativeIntVarType);
 }
 
 
 static udt_VariableType *Variable_TypeByPythonType(
 return &vt_Cursor;
 if (type == (PyObject*) &g_NativeFloatVarType)
 return &vt_NativeFloat;
+ if (type == (PyObject*) &g_NativeIntVarType)
+ return &vt_NativeInteger;
 if (type == (PyObject*) &g_ObjectVarType)
 return &vt_Object;
 
 static udt_VariableType *Variable_TypeByOracleDataType (
 case SQLT_BDOUBLE:
 case SQLT_IBDOUBLE:
 return &vt_NativeFloat;
+ case SQLT_INT:
+ return &vt_NativeInteger;
 case SQLT_NUM:
 case SQLT_VNU:
 return &vt_Float;
",1108,283
"Added support for large row counts (larger than 2 ** 32) and laid the
groundwork for adding support for scrollable cursors."," static int ObjectVar_Initialize(
 udt_ObjectVar *self, // variable to initialize
 udt_Cursor *cursor) // cursor to use
 {
- int i;
+ ub4 i;
 
 Py_INCREF(cursor->connection);
 self->connection = cursor->connection;
 static int ObjectVar_Initialize(
 static void ObjectVar_Finalize(
 udt_ObjectVar *self) // variable to free
 {
- int i;
+ ub4 i;
 
 for (i = 0; i < self->allocatedElements; i++) {
 if (self->data[i])
",153,16
Added support for scrollable cursors.," static int CursorVar_Initialize(
 if (!var->cursors)
 return -1;
 for (i = 0; i < var->allocatedElements; i++) {
- tempCursor = (udt_Cursor*) Connection_NewCursor(var->connection, NULL);
+ tempCursor = (udt_Cursor*) Connection_NewCursor(var->connection, NULL,
+ NULL);
 if (!tempCursor) {
 Py_DECREF(var);
 return -1;
",120,12
Remove code for supporting Python versions earlier than 2.6.,"
 #error Unsupported version of OCI.
 #endif
 
-// PY_LONG_LONG was called LONG_LONG before Python 2.3
-#ifndef PY_LONG_LONG
-#define PY_LONG_LONG LONG_LONG
-#endif
-
-// define Py_ssize_t for versions before Python 2.5
-#if PY_VERSION_HEX < 0x02050000
-typedef int Py_ssize_t;
-#define PY_SSIZE_T_MAX INT_MAX
-#define PY_SSIZE_T_MIN INT_MIN
-#endif
-
-// define T_BOOL for versions before Python 2.5
-#ifndef T_BOOL
-#define T_BOOL T_INT
-#endif
-
-// define Py_TYPE for versions before Python 2.6
-#ifndef Py_TYPE
-#define Py_TYPE(ob) (((PyObject*)(ob))->ob_type)
-#endif
-
-// define PyVarObject_HEAD_INIT for versions before Python 2.6
-#ifndef PyVarObject_HEAD_INIT
-#define PyVarObject_HEAD_INIT(type, size) \
- PyObject_HEAD_INIT(type) size,
-#endif
-
 // define PyInt_* macros for Python 3.x
 #ifndef PyInt_Check
 #define PyInt_Check PyLong_Check
",338,47
Correct variable references.," static PyMemberDef g_ErrorMembers[] = {
 { ""offset"", T_INT, offsetof(udt_Error, offset), READONLY },
 { ""message"", T_OBJECT, offsetof(udt_Error, message), READONLY },
 { ""context"", T_STRING, offsetof(udt_Error, context), READONLY },
- { ""isrecoverable"", T_BOOL, offsetof(udt_Error, context), READONLY },
+ { ""isrecoverable"", T_BOOL, offsetof(udt_Error, isRecoverable), READONLY },
 { NULL }
 };
 
",227,54
Update names of objects to be more consistent.," static PyMemberDef g_ExternalObjectVarMembers[] = {
 //-----------------------------------------------------------------------------
 static PyTypeObject g_ExternalObjectVarType = {
 PyVarObject_HEAD_INIT(NULL, 0)
- ""cx_Oracle.OBJECT"", // tp_name
+ ""cx_Oracle.Object"", // tp_name
 sizeof(udt_ExternalObjectVar), // tp_basicsize
 0, // tp_itemsize
 (destructor) ExternalObjectVar_Free,
",219,30
Eliminate unnecessary initialization code.," static PyObject* Connection_New(
 if (!self)
 return NULL;
 self->commitMode = OCI_DEFAULT;
- self->environment = NULL;
 
 return (PyObject*) self;
 }
",1297,236
"Renamed ExternalObjectVar to Object since it will be independent of variables;
removed limitation for retrieving the object from the variable only once."," static PyObject *Module_Initialize(void)
 MAKE_TYPE_READY(&g_ObjectTypeType);
 MAKE_TYPE_READY(&g_ObjectAttributeType);
 MAKE_TYPE_READY(&g_ExternalLobVarType);
- MAKE_TYPE_READY(&g_ExternalObjectVarType);
+ MAKE_TYPE_READY(&g_ObjectType);
 #if ORACLE_VERSION_HEX >= ORACLE_VERSION(10, 2)
 MAKE_TYPE_READY(&g_SubscriptionType);
 MAKE_TYPE_READY(&g_MessageType);
",338,47
"Added support for binding objects and setting attributes on objects of numbers,
strings and dates."," static udt_VariableType vt_Boolean = {
 (FinalizeProc) NULL,
 (PreDefineProc) NULL,
 (PostDefineProc) NULL,
+ (PostBindProc) NULL,
 (PreFetchProc) NULL,
 (IsNullProc) NULL,
 (SetValueProc) BooleanVar_SetValue,
",68,3
Remove deprecated variable attributes maxlength and allocelems.," static PyMemberDef g_VariableMembers[] = {
 READONLY },
 { ""outconverter"", T_OBJECT, offsetof(udt_Variable, outConverter), 0 },
 { ""size"", T_INT, offsetof(udt_Variable, size), READONLY },
- { ""maxlength"", T_INT, offsetof(udt_Variable, bufferSize), READONLY },
- { ""allocelems"", T_INT, offsetof(udt_Variable, allocatedElements),
- READONLY },
 { NULL }
 };
 
",1102,288
"Added support for binding objects with sub objects attached to them; ensured
that instances are created when an empty object variable is created; enhanced
test cases for binding objects."," static PyObject *Cursor_Var(
 // define the object type if needed
 if (type == (PyObject*) &g_ObjectVarType) {
 objectVar = (udt_ObjectVar*) var;
- objectVar->objectType = ObjectType_NewByName(self->connection,
- typeNameObj);
- if (!objectVar->objectType) {
+ if (ObjectVar_SetType(objectVar, typeNameObj) < 0) {
 Py_DECREF(var);
 return NULL;
 }
",1877,411
"Added preliminary support for binding collections (both SQL typed and PL/SQL
typed in Oracle 12.1)."," static PyObject *ObjectVar_GetValue(
 // create the object, if needed; for collections, return a list, not the
 // object itself
 if (!self->objects[pos]) {
- if (self->objectType->isCollection)
- obj = Object_ConvertCollection(self->environment, self->data[pos],
- self->objectType);
- else obj = Object_New(self->objectType, self->data[pos],
+ obj = Object_New(self->objectType, self->data[pos],
 self->objectIndicator[pos], 1);
 if (!obj)
 return NULL;
",248,33
Added support for PL/SQL collections of booleans (available only in 12.1).," static PyTypeObject g_BaseVarType = {
 };
 
 
+#include ""Transforms.c""
 #if ORACLE_VERSION_HEX >= ORACLE_VERSION(12, 1)
 #include ""BooleanVar.c""
 #endif
-#include ""Transforms.c""
 #include ""StringVar.c""
 #include ""LongVar.c""
 #include ""NumberVar.c""
",1102,288
"Pass the type code associated with the object type, as it might be something
other than OCI_TYPECODE_OBJECT."," static int ObjectVar_SetType(
 // create the object instance
 status = OCIObjectNew(self->connection->environment->handle,
 self->connection->environment->errorHandle,
- self->connection->handle, OCI_TYPECODE_OBJECT,
+ self->connection->handle, self->objectType->typeCode,
 self->objectType->tdo, NULL, OCI_DURATION_SESSION, TRUE,
 &instance);
 if (Environment_CheckForError(self->connection->environment, status,
",248,33
Added example for creating SDO_GEOMETRY.," static int Object_ConvertFromPython(
 return -1;
 *ociValue = oracleValue->timestampValue;
 break;
+ case OCI_TYPECODE_NAMEDCOLLECTION:
 case OCI_TYPECODE_OBJECT:
 if (Py_TYPE(pythonValue) != &g_ObjectType) {
 PyErr_SetString(PyExc_TypeError,
",727,129
"Return value is not an integer -- some versions of the Oracle client use
native integers and others will use regular numbers so specify that the return
value is in fact a regular number so that the test works correctly in all
cases."," class TestFeatures12_1(BaseTestCase):
 obj.setelement(1, datetime.datetime(2016, 2, 5))
 obj.append(datetime.datetime(2016, 2, 8, 12, 15, 30))
 obj.append(datetime.datetime(2016, 2, 12, 5, 44, 30))
- result = self.cursor.callfunc(""pkg_TestDateArrays.TestInArrays"", int,
- (2, datetime.datetime(2016, 2, 1), obj))
+ result = self.cursor.callfunc(""pkg_TestDateArrays.TestInArrays"",
+ cx_Oracle.NUMBER, (2, datetime.datetime(2016, 2, 1), obj))
 self.assertEqual(result, 24.75)
 
 def testBindPLSQLDateCollectionInOut(self):
",347,29
Remove debugging lines.," static PyObject *NativeIntVar_GetValue(
 udt_NativeIntVar *var, // variable to determine value for
 unsigned pos) // array position
 {
-//printf(""Getting native integer (value %ld)\n"", var->data[pos]);
 return PyInt_FromLong(var->data[pos]);
 }
 
 static int NativeIntVar_SetValue(
 return -1;
 }
 var->data[pos] = PyInt_AsLong(value);
-//printf(""Setting native integer to value %ld:\n"", var->data[pos]);
 if (PyErr_Occurred())
 return -1;
 return 0;
",348,32
"Added support for initializing a collection upon creation; provided a synonym
for newobject() in simply calling the type directly (as a convenience)."," class TestObjectVar(BaseTestCase):
 ""udt_Object(null, 'Test With Dates', null, null, null, "" \
 ""udt_SubObject(15, 'Sub String'), null)"")
 
+ def testCopyObject(self):
+ ""test copying an object""
+ typeObj = self.connection.gettype(""UDT_OBJECT"")
+ obj = typeObj()
+ obj.NUMBERVALUE = 5124
+ obj.STRINGVALUE = ""A test string""
+ obj.DATEVALUE = datetime.datetime(2016, 2, 24)
+ obj.TIMESTAMPVALUE = datetime.datetime(2016, 2, 24, 13, 39, 10)
+ copiedObj = obj.copy()
+ self.assertEqual(obj.NUMBERVALUE, copiedObj.NUMBERVALUE)
+ self.assertEqual(obj.STRINGVALUE, copiedObj.STRINGVALUE)
+ self.assertEqual(obj.DATEVALUE, copiedObj.DATEVALUE)
+ self.assertEqual(obj.TIMESTAMPVALUE, copiedObj.TIMESTAMPVALUE)
+
 def testFetchData(self):
 ""test fetching objects""
 self.cursor.execute(""""""
",135,14
Added support for using the C API for advanced queuing.," extension = Extension(
 extra_compile_args = extraCompileArgs,
 extra_link_args = extraLinkArgs,
 sources = [""cx_Oracle.c""],
- depends = [""Buffer.c"", ""Callback.c"", ""Connection.c"", ""Cursor.c"",
+ depends = [""AQ.c"", ""Buffer.c"", ""Callback.c"", ""Connection.c"", ""Cursor.c"",
 ""CursorVar.c"", ""DateTimeVar.c"", ""Environment.c"", ""Error.c"",
 ""ExternalLobVar.c"", ""IntervalVar.c"", ""LobVar.c"", ""LongVar.c"",
 ""NumberVar.c"", ""Object.c"", ""ObjectType.c"", ""ObjectVar.c"",
",321,29
Fix setting of raw values on AQ descriptors.," static int DeqOptions_SetOCIAttr(
 if (Environment_CheckForError(self->environment, status,
 ""DeqOptions_SetOCIAttr(): assign raw value"") < 0)
 return -1;
- ociValue = (dvoid*) rawValue;
+ ociValue = (dvoid*) &rawValue;
+ valueLength = OCIRawSize(self->environment->handle, rawValue);
 break;
 };
 status = OCIAttrSet(self->handle, OCI_DTYPE_AQDEQ_OPTIONS,
 static int MessageProperties_SetOCIAttr(
 if (Environment_CheckForError(self->environment, status,
 ""MessageProperties_SetOCIAttr(): assign raw value"") < 0)
 return -1;
- ociValue = (dvoid*) rawValue;
+ ociValue = (dvoid*) &rawValue;
+ valueLength = OCIRawSize(self->environment->handle, rawValue);
 break;
 };
 status = OCIAttrSet(self->handle, OCI_DTYPE_AQMSG_PROPERTIES,
",619,100
"Fixed support for integers. OCI_TYPECODE_INTEGER is stored as a OCINumber, not
as a native integer."," static int Object_ConvertFromPython(
 *ociValue = oracleValue->stringValue;
 break;
 case OCI_TYPECODE_INTEGER:
- oracleValue->integerValue = PyInt_AsLong(pythonValue);
- if (PyErr_Occurred())
- return -1;
- *ociValue = &oracleValue->integerValue;
- break;
 case OCI_TYPECODE_NUMBER:
 if (PythonNumberToOracleNumber(environment,
 pythonValue, &oracleValue->numberValue) < 0)
 static PyObject *Object_ConvertToPython(
 return cxString_FromEncodedString( (char*) stringValue,
 stringSize, environment->encoding);
 case OCI_TYPECODE_INTEGER:
- return PyInt_FromLong(* (int*) value);
+ return OracleNumberToPythonInteger(environment,
+ (OCINumber*) value);
 case OCI_TYPECODE_NUMBER:
 return OracleNumberToPythonFloat(environment, (OCINumber*) value);
 case OCI_TYPECODE_DATE:
",787,142
"Retain the hex address of the object since there may be many objects of the
same type available in a program."," static PyObject *Object_Repr(
 
 if (GetModuleAndName(Py_TYPE(self), &module, &name) < 0)
 return NULL;
- format = cxString_FromAscii(""<%s.%s %s.%s>"");
+ format = cxString_FromAscii(""<%s.%s %s.%s at %#x>"");
 if (!format) {
 Py_DECREF(module);
 Py_DECREF(name);
 return NULL;
 }
- formatArgs = PyTuple_Pack(4, module, name, self->objectType->schema,
- self->objectType->name);
+ formatArgs = Py_BuildValue(""(OOOOl)"", module, name,
+ self->objectType->schema, self->objectType->name, self);
 Py_DECREF(module);
 Py_DECREF(name);
 if (!formatArgs) {
",813,146
"The -mno-cygwin compile time flag is deprecated and now causes an error in
newer versions of the gcc compiler for cygwin."," if sys.platform == ""aix4"":
 elif sys.platform == ""aix5"":
 extraCompileArgs.append(""-DAIX5"")
 elif sys.platform == ""cygwin"":
- extraCompileArgs.append(""-mno-cygwin"")
 extraLinkArgs.append(""-Wl,--enable-runtime-pseudo-reloc"")
 elif sys.platform == ""darwin"":
 extraLinkArgs.append(""-shared-libgcc"")
",320,29
"Clear the object prior to fetching; otherwise, OCI will try to do something
with it and potentially crash the application!"," static int ObjectVar_PreFetch(
 ub4 i;
 
 for (i = 0; i < var->allocatedElements; i++) {
- Py_CLEAR(var->objects[i]);
- if (var->data[i])
+ if (var->objects[i])
+ Py_CLEAR(var->objects[i]);
+ else if (var->data[i])
 OCIObjectFree(var->environment->handle,
 var->environment->errorHandle, var->data[i], OCI_DEFAULT);
+ var->data[i] = NULL;
+ var->objectIndicator[i] = NULL;
 }
 
 return 0;
",251,34
Enable statement caching to improve performance.," static int Connection_Init(
 // parse arguments
 pool = NULL;
 handle = NULL;
- connectMode = OCI_DEFAULT;
+ connectMode = OCI_STMT_CACHE;
 threadedObj = twophaseObj = eventsObj = newPasswordObj = NULL;
 usernameObj = passwordObj = dsnObj = cclassObj = editionObj = NULL;
 moduleObj = actionObj = clientinfoObj = NULL;
",1425,251
Change version to 5.3 (proposed version to be released).," except:
 from distutils.extension import Extension
 
 # define build constants
-BUILD_VERSION = ""5.2.1""
+BUILD_VERSION = ""5.3""
 
 # define the list of files to be included as documentation for Windows
 dataFiles = None
",320,29
"The current position does not need to be checked upon execute (since we are
always moving forward) and especially not since its value is always zero in
any case!"," static int Cursor_InternalFetch(
 udt_Cursor *self, // cursor to fetch from
 int numRows) // number of rows to fetch
 {
- ub4 currentPosition;
 udt_Variable *var;
 sword status;
 int i;
 static int Cursor_InternalFetch(
 ""Cursor_InternalFetch(): get rows fetched"") < 0)
 return -1;
 
- // determine the current position in the cursor
- status = OCIAttrGet(self->handle, OCI_HTYPE_STMT, &currentPosition, 0,
- OCI_ATTR_CURRENT_POSITION, self->environment->errorHandle);
- if (Environment_CheckForError(self->environment, status,
- ""Cursor_InternalFetch(): get current position"") < 0)
- return -1;
-
- // reset buffer row index and row count
- self->rowCount = currentPosition - self->bufferRowCount;
+ // reset buffer row index
 self->bufferRowIndex = 0;
 
 return 0;
",1876,411
Remove memory leak when function call raises an exception.," static PyObject *Cursor_CallFunc(
 return NULL;
 
 // call the function
- if (Cursor_Call(self, var, name, listOfArguments, keywordArguments) < 0)
+ if (Cursor_Call(self, var, name, listOfArguments, keywordArguments) < 0) {
+ Py_DECREF(var);
 return NULL;
+ }
 
 // determine the results
 results = Variable_GetValue(var, 0);
",1878,411
"Adjusted samples to be clearer and to match the tables used in the test suite;
added new samples for DRCP and input/output type handlers."," def OutputTypeHandler(cursor, name, defaultType, size, precision, scale):
 if defaultType == cx_Oracle.BLOB:
 return cursor.var(cx_Oracle.LONG_BINARY, 100004, cursor.arraysize)
 
-connection = cx_Oracle.Connection(""user/pw@tns"")
+connection = cx_Oracle.Connection(""cx_Oracle/dev@localhost/orcl"")
 connection.outputtypehandler = OutputTypeHandler
 cursor = connection.cursor()
 print(""CLOBS returned as longs"")
",31,3
Remove unnecessary section of TNS naming string (ADDRESS_LIST).," static PyObject* MakeDSN(
 return NULL;
 if (sidObj) {
 connectDataObj = sidObj;
- format = cxString_FromAscii(""(DESCRIPTION=(ADDRESS_LIST=(ADDRESS=""
- ""(PROTOCOL=TCP)(HOST=%s)(PORT=%s)))(CONNECT_DATA=(SID=%s)))"");
+ format = cxString_FromAscii(""(DESCRIPTION=(ADDRESS=""
+ ""(PROTOCOL=TCP)(HOST=%s)(PORT=%s))(CONNECT_DATA=(SID=%s)))"");
 } else {
 connectDataObj = serviceNameObj;
- format = cxString_FromAscii(""(DESCRIPTION=(ADDRESS_LIST=(ADDRESS=""
- ""(PROTOCOL=TCP)(HOST=%s)(PORT=%s)))(CONNECT_DATA=""
+ format = cxString_FromAscii(""(DESCRIPTION=(ADDRESS=""
+ ""(PROTOCOL=TCP)(HOST=%s)(PORT=%s))(CONNECT_DATA=""
 ""(SERVICE_NAME=%s)))"");
 }
 if (!format)
",368,47
"Adjusted test cases to make use of encoding and nencoding parameters to both
standalone connection and session pool creation; added test cases for binding
and fetching supplemental characters as well as fetching temporary LOBs; tidied
up a few test cases as well."," class TestCursor(BaseTestCase):
 value, = testIter.next()
 self.cursor.execute(""insert into TestTempTable (IntCol) values (1)"")
 if sys.version_info[0] >= 3:
- self.assertRaises(cx_Oracle.InterfaceError, next, testIter) 
+ self.assertRaises(cx_Oracle.InterfaceError, next, testIter)
 else:
- self.assertRaises(cx_Oracle.InterfaceError, testIter.next) 
+ self.assertRaises(cx_Oracle.InterfaceError, testIter.next)
 
 def testBindNames(self):
 """"""test that bindnames() works correctly.""""""
- self.assertRaises(cx_Oracle.ProgrammingError,
- self.cursor.bindnames)
+ self.assertRaises(cx_Oracle.ProgrammingError, self.cursor.bindnames)
 self.cursor.prepare(""begin null; end;"")
 self.assertEqual(self.cursor.bindnames(), [])
 self.cursor.prepare(""begin :retval := :inval + 5; end;"")
",355,50
Eliminate compiler warnings about signed vs unsigned variables.," static int MessageTable_Initialize(
 dvoid *descriptor) // descriptor to get information from
 {
 dvoid **rowDescriptor, *indicator;
- ub4 nameLength, i;
 udt_MessageRow *row;
+ ub4 nameLength;
 boolean exists;
+ sb4 numRows, i;
 OCIColl *rows;
 sword status;
- sb4 numRows;
 char *name;
 
 // determine operation
 static int MessageQuery_Initialize(
 {
 dvoid **tableDescriptor, *indicator;
 udt_MessageTable *table;
- ub4 i;
+ sb4 numTables, i;
 OCIColl *tables;
 boolean exists;
- sb4 numTables;
 sword status;
 
 // determine query id
 static int Message_Initialize(
 dvoid *descriptor) // descriptor to get information from
 {
 dvoid **tableDescriptor, *indicator, **queryDescriptor;
+ sb4 numTables, numQueries, i;
 OCIColl *tables, *queries;
- sb4 numTables, numQueries;
 udt_MessageTable *table;
 udt_MessageQuery *query;
- ub4 dbnameLength, i;
+ ub4 dbnameLength;
 boolean exists;
 char *dbname;
 sword status;
",870,108
"Correct execution of test suite on Windows which doesn't support UTF-8 by
default.","
+# -*- coding: utf-8 -*-
 """"""Module for testing string variables.""""""
 
 class TestStringVar(BaseTestCase):
",260,34
Eliminate warnings with Microsoft compiler.," static int EnqOptions_SetOCIAttr(
 self->environment->encoding) < 0)
 return -1;
 ociValue = (dvoid*) buffer.ptr;
- valueLength = buffer.size;
+ valueLength = (ub4) buffer.size;
 break;
 };
 status = OCIAttrSet(self->handle, OCI_DTYPE_AQENQ_OPTIONS,
 static int DeqOptions_SetOCIAttr(
 self->environment->encoding) < 0)
 return -1;
 ociValue = (dvoid*) buffer.ptr;
- valueLength = buffer.size;
+ valueLength = (ub4) buffer.size;
 break;
 case OCI_ATTR_DEQ_MSGID:
 if (PyBytes_AsStringAndSize(value, &rawValuePtr,
 static int MessageProperties_SetOCIAttr(
 self->environment->encoding) < 0)
 return -1;
 ociValue = (dvoid*) buffer.ptr;
- valueLength = buffer.size;
+ valueLength = (ub4) buffer.size;
 break;
 case OCI_ATTR_DEQ_MSGID:
 if (PyBytes_AsStringAndSize(value, &rawValuePtr,
",619,100
Eliminated further compiler warnings for the Microsoft compiler.," static int Cursor_CallBuildStatement(
 for (i = 0; i < numPositionalArgs; i++) {
 if (i > 0)
 *ptr++ = ',';
- ptr += sprintf(ptr, "":%ld"", argNum++);
+ ptr += sprintf(ptr, "":%ld"", (long) argNum++);
 #if ORACLE_VERSION_HEX < ORACLE_VERSION(12, 1)
 if (PyBool_Check(PySequence_Fast_GET_ITEM(positionalArgs, i)))
 ptr += sprintf(ptr, "" = 1"");
 static int Cursor_CallBuildStatement(
 }
 if ((argNum > 1 && !returnValue) || (argNum > 2 && returnValue))
 *ptr++ = ',';
- ptr += sprintf(ptr, ""%%s => :%ld"", argNum++);
+ ptr += sprintf(ptr, ""%%s => :%ld"", (long) argNum++);
 #if ORACLE_VERSION_HEX < ORACLE_VERSION(12, 1)
 if (PyBool_Check(value))
 ptr += sprintf(ptr, "" = 1"");
",1875,411
Eliminated final compiler warnings for Microsoft compiler for Oracle 11g.," static udt_ObjectType *ObjectType_NewByName(
 #else
 status = OCIDescribeAny(connection->handle,
 connection->environment->errorHandle, (dvoid*) buffer.ptr,
- buffer.size, OCI_OTYPE_NAME, 0, OCI_PTYPE_TYPE, describeHandle);
+ (ub4) buffer.size, OCI_OTYPE_NAME, 0, OCI_PTYPE_TYPE,
+ describeHandle);
 cxBuffer_Clear(&buffer);
 if (Environment_CheckForError(connection->environment, status,
 ""ObjectType_NewByName(): describe type"") < 0) {
",498,68
"Use None instead of 0 for items in the cursor.description attribute that do not
have any validity."," class TestDateTimeVar(BaseTestCase):
 ""test cursor description is accurate""
 self.cursor.execute(""select * from TestDates"")
 self.assertEqual(self.cursor.description,
- [ ('INTCOL', cx_Oracle.NUMBER, 10, 22, 9, 0, 0),
- ('DATECOL', cx_Oracle.DATETIME, 23, 7, 0, 0, 0),
- ('NULLABLECOL', cx_Oracle.DATETIME, 23, 7, 0, 0, 1) ])
+ [ ('INTCOL', cx_Oracle.NUMBER, 10, None, 9, 0, 0),
+ ('DATECOL', cx_Oracle.DATETIME, 23, None, None, None, 0),
+ ('NULLABLECOL', cx_Oracle.DATETIME, 23, None, None, None,
+ 1) ])
 
 def testFetchAll(self):
 ""test that fetching all of the data returns the correct results""
",208,24
"Raise cx_Oracle.DatabaseError, not IndexError for a scroll operation that
would position the cursor outside of the result set."," static PyObject *Cursor_Scroll(
 // handle the case when no rows have been retrieved
 if (self->bufferRowCount == 0) {
 if (fetchMode != OCI_FETCH_FIRST && fetchMode != OCI_FETCH_LAST) {
- PyErr_SetString(PyExc_IndexError,
+ PyErr_SetString(g_DatabaseErrorException,
 ""requested scroll operation would leave result set"");
 return NULL;
 }
",1900,419
"Adjusted license description to be clear that the BSD 3-clause license is in
use."," if distutils.command.bdist_wininst is not None:
 classifiers = [
 ""Development Status :: 6 - Mature"",
 ""Intended Audience :: Developers"",
- ""License :: OSI Approved :: Python Software Foundation License"",
+ ""License :: OSI Approved :: BSD License"",
 ""Natural Language :: English"",
 ""Operating System :: OS Independent"",
 ""Programming Language :: C"",
 setup(
 url = ""http://cx-oracle.sourceforge.net"",
 ext_modules = [extension],
 keywords = ""Oracle"",
- license = ""Python Software Foundation License"",
+ license = ""BSD License"",
 classifiers = classifiers)
 
",322,29
Dropped support for callbacks on OCI functions.," static PyObject *Module_Initialize(void)
 __DATE__ "" "" __TIME__) < 0)
 return NULL;
 
- // add constants for registering callbacks
+ // add constants for various OCI constants
 ADD_OCI_CONSTANT(SYSDBA)
 ADD_OCI_CONSTANT(SYSOPER)
- ADD_OCI_CONSTANT(FNCODE_BINDBYNAME)
- ADD_OCI_CONSTANT(FNCODE_BINDBYPOS)
- ADD_OCI_CONSTANT(FNCODE_DEFINEBYPOS)
- ADD_OCI_CONSTANT(FNCODE_STMTEXECUTE)
- ADD_OCI_CONSTANT(FNCODE_STMTFETCH)
- ADD_OCI_CONSTANT(FNCODE_STMTPREPARE)
- ADD_OCI_CONSTANT(UCBTYPE_ENTRY)
- ADD_OCI_CONSTANT(UCBTYPE_EXIT)
- ADD_OCI_CONSTANT(UCBTYPE_REPLACE)
 ADD_OCI_CONSTANT(SPOOL_ATTRVAL_WAIT)
 ADD_OCI_CONSTANT(SPOOL_ATTRVAL_NOWAIT)
 ADD_OCI_CONSTANT(SPOOL_ATTRVAL_FORCEGET)
",359,42
"Removed deprecated types UNICODE, FIXED_UNICODE and LONG_UNICODE."," static PyObject *Module_Initialize(void)
 ADD_TYPE_OBJECT(""DATETIME"", &g_DateTimeVarType)
 ADD_TYPE_OBJECT(""FIXED_CHAR"", &g_FixedCharVarType)
 ADD_TYPE_OBJECT(""FIXED_NCHAR"", &g_FixedNCharVarType)
- ADD_TYPE_OBJECT(""FIXED_UNICODE"", &g_FixedNCharVarType)
- ADD_TYPE_OBJECT(""UNICODE"", &g_NCharVarType)
- ADD_TYPE_OBJECT(""LONG_UNICODE"", &g_LongNCharVarType)
 ADD_TYPE_OBJECT(""NCHAR"", &g_NCharVarType)
 ADD_TYPE_OBJECT(""LONG_NCHAR"", &g_LongNCharVarType)
 ADD_TYPE_OBJECT(""INTERVAL"", &g_IntervalVarType)
",356,42
Increased default array size to 100 (from 50) to match other drivers.," static int Cursor_Init(
 Py_INCREF(connection);
 self->connection = connection;
 self->environment = connection->environment;
- self->arraySize = 50;
- self->fetchArraySize = 50;
+ self->arraySize = 100;
+ self->fetchArraySize = 100;
 self->bindArraySize = 1;
 self->statementType = -1;
 self->outputSize = -1;
",1900,419
"Reworked database change notification and continuous query notification to
more closely align with the PL/SQL implementation and prepare for sending
notifications for AQ messages."," def callback(message):
 
 connection = cx_Oracle.Connection(""cx_Oracle/dev@localhost/orcl"",
 events = True)
-sub = connection.subscribe(callback = callback, timeout = 1800, rowids = True)
+sub = connection.subscribe(callback = callback, timeout = 1800,
+ qos = cx_Oracle.SUBSCR_QOS_ROWIDS)
 print(""Subscription:"", sub)
 print(""--> Connection:"", sub.connection)
 print(""--> Callback:"", sub.callback)
 print(""--> Namespace:"", sub.namespace)
 print(""--> Protocol:"", sub.protocol)
 print(""--> Timeout:"", sub.timeout)
 print(""--> Operations:"", sub.operations)
-print(""--> Rowids?:"", sub.rowids)
+print(""--> Rowids?:"", bool(sub.qos & cx_Oracle.SUBSCR_QOS_ROWIDS))
 sub.registerquery(""select * from TestTempTable"")
 
 while True:
",34,4
"Final changes to license and copyright notices as requested; addition of
separate license file and copyright notices to all source files."," dataFiles = None
 if sys.platform in (""win32"", ""cygwin""):
 baseName = ""cx_Oracle-doc""
 dataFiles = [ (baseName,
- [ ""BUILD.txt"", ""README.txt""]) ]
+ [ ""BUILD.txt"", ""LICENSE.txt"", ""README.txt""]) ]
 for dir in (""samples"", ""test""):
 files = []
 fullDirName = ""%s/%s"" % (baseName, dir)
 if sys.platform in (""win32"", ""cygwin""):
 dataFiles.append((fullDirName, files))
 
 # define the list of files to be included as documentation for bdist_rpm
-docFiles = ""README.txt BUILD.txt samples test""
+docFiles = ""README.txt LICENSE.txt BUILD.txt samples test""
 
 # method for checking a potential Oracle home
 def CheckOracleHome(directoryToCheck):
",322,29
Rework to use the ODPI-C library instead of direct OCI calls.," class TestConnection(TestCase):
 connection = cx_Oracle.connect(self.username, self.password,
 self.tnsentry)
 connection.close()
- self.assertRaises(cx_Oracle.InterfaceError, connection.rollback)
+ self.assertRaises(cx_Oracle.DatabaseError, connection.rollback)
 
 def testMakeDSN(self):
 ""test making a data source name from host, port and sid""
",97,15
"Create README.md with contents of README.txt in Markdown syntax for better
presentation on GitHub; replace contents of README.txt with simple description
and a link to the home page."," setup(
 cmdclass = commandClasses,
 options = dict(bdist_rpm = dict(doc_files = docFiles)),
 long_description = \
- ""Python interface to Oracle conforming to the Python DB API 2.0 ""
- ""specification.\n""
+ ""Python interface to Oracle Database conforming to the Python DB ""
+ ""API 2.0 specification.\n""
 ""See http://www.python.org/topics/database/DatabaseAPI-2.0.html."",
 author = ""Anthony Tuininga"",
 author_email = ""anthony.tuininga@gmail.com"",
",324,29
Added copyright notices to the top of all tests and samples as requested.,"
+#------------------------------------------------------------------------------
+# Copyright 2016, 2017, Oracle and/or its affiliates. All rights reserved.
+#
+# Portions Copyright 2007-2015, Anthony Tuininga. All rights reserved.
+#
+# Portions Copyright 2001-2007, Computronix (Canada) Ltd., Edmonton, Alberta,
+# Canada. All rights reserved.
+#------------------------------------------------------------------------------
+
 #------------------------------------------------------------------------------
 # DatabaseChangeNotification.py
 # This script demonstrates using database change notification in Python, a
",34,4
Changed URL to point to new home page.," setup(
 ""See http://www.python.org/topics/database/DatabaseAPI-2.0.html."",
 author = ""Anthony Tuininga"",
 author_email = ""anthony.tuininga@gmail.com"",
- url = ""http://cx-oracle.sourceforge.net"",
+ url = ""https://oracle.github.io/python-cx_Oracle"",
 ext_modules = [extension],
 keywords = ""Oracle"",
 license = ""BSD License"",
",324,29
"Include the ODPI source code as dependencies so changes trigger a rebuild of
the module."," extension = Extension(
 ""src/LongVar.c"", ""src/MsgProps.c"", ""src/NumberVar.c"",
 ""src/Object.c"", ""src/ObjectType.c"", ""src/ObjectVar.c"",
 ""src/SessionPool.c"", ""src/StringVar.c"", ""src/Subscription.c"",
- ""src/Variable.c""])
+ ""src/Variable.c"", ""odpi/include/dpi.h"", ""odpi/src/dpiImpl.h"",
+ ""odpi/src/dpiConn.c"", ""odpi/src/dpiContext.c"",
+ ""odpi/src/dpiData.c"", ""odpi/src/dpiDeqOptions.c"",
+ ""odpi/src/dpiEnqOptions.c"", ""odpi/src/dpiEnv.c"",
+ ""odpi/src/dpiError.c"", ""odpi/src/dpiGen.c"",
+ ""odpi/src/dpiGlobal.c"", ""odpi/src/dpiLob.c"",
+ ""odpi/src/dpiMsgProps.c"", ""odpi/src/dpiObject.c"",
+ ""odpi/src/dpiObjectAttr.c"", ""odpi/src/dpiObjectType.c"",
+ ""odpi/src/dpiOracleType.c"", ""odpi/src/dpiPool.c"",
+ ""odpi/src/dpiRowid.c"", ""odpi/src/dpiStmt.c"",
+ ""odpi/src/dpiSubscr.c"", ""odpi/src/dpiUtils.c"",
+ ""odpi/src/dpiVar.c""])
 
 # perform the setup
 setup(
",335,29
"Add comment to each sample indicating minimum version of cx_Oracle that is
required in order to run it.","
 # feature that is available in Oracle 10g Release 2. Once this script is
 # running, use another session to insert, update or delete rows from the table
 # cx_Oracle.TestTempTable and you will see the notification of that change.
+#
+# This script requires cx_Oracle 5.3 and higher.
 #------------------------------------------------------------------------------
 
 from __future__ import print_function
",34,4
"Implement ODPI-C update which significantly simplifies building cx_Oracle and
enables building a single module to support all versions of Oracle Client
libraries."," void initcx_Oracle(void)
 #include ""dpiObject.c""
 #include ""dpiObjectAttr.c""
 #include ""dpiObjectType.c""
+#include ""dpiOci.c""
 #include ""dpiOracleType.c""
 #include ""dpiPool.c""
 #include ""dpiRowid.c""
",420,57
Eliminate compiler warnings with Visual Studio 2015.," static int ConnectionParams_ProcessContext(udt_ConnectionParams *params,
 ""appcontext should be a list of 3-tuples"");
 return -1;
 }
- numEntries = PyList_GET_SIZE(context);
+ numEntries = (uint32_t) PyList_GET_SIZE(context);
 if (numEntries == 0)
 return 0;
 
 static int Connection_Init(udt_Connection *self, PyObject *args,
 if (dpiContext_initCommonCreateParams(g_DpiContext, &dpiCommonParams) < 0)
 return Error_RaiseAndReturnInt();
 dpiCommonParams.driverName = DRIVER_NAME;
- dpiCommonParams.driverNameLength = strlen(dpiCommonParams.driverName);
+ dpiCommonParams.driverNameLength =
+ (uint32_t) strlen(dpiCommonParams.driverName);
 if (dpiContext_initConnCreateParams(g_DpiContext, &dpiCreateParams) < 0)
 return Error_RaiseAndReturnInt();
 if (!PyArg_ParseTupleAndKeywords(args, keywordArgs,
",962,186
Formatting improvements.,"
 
 // define integer macros/methods for Python 3.x
 #ifndef PyInt_Check
-#define PyInt_Check PyLong_Check
-#define PyInt_FromLong PyLong_FromLong
-#define PyInt_FromUnsignedLong PyLong_FromUnsignedLong
-#define PyInt_AsLong PyLong_AsLong
-#define PyInt_AsUnsignedLong PyLong_AsUnsignedLong
-#define PyInt_Type PyLong_Type
-#define PyNumber_Int PyNumber_Long
+#define PyInt_Check PyLong_Check
+#define PyInt_FromLong PyLong_FromLong
+#define PyInt_FromUnsignedLong PyLong_FromUnsignedLong
+#define PyInt_AsLong PyLong_AsLong
+#define PyInt_AsUnsignedLong PyLong_AsUnsignedLong
+#define PyInt_Type PyLong_Type
+#define PyNumber_Int PyNumber_Long
 #endif
 
 // use the bytes methods in cx_Oracle and define them as the equivalent string
",420,57
"With building cx_Oracle only requiring a compiler and the Python development
headers and libraries, a separate BUILD.txt is now obsolete; mention the use of
ODPI-C and include a link."," BUILD_VERSION = ""6.0""
 dataFiles = None
 if sys.platform in (""win32"", ""cygwin""):
 baseName = ""cx_Oracle-doc""
- dataFiles = [ (baseName,
- [ ""BUILD.txt"", ""LICENSE.txt"", ""README.txt""]) ]
+ dataFiles = [ (baseName, [ ""LICENSE.txt"", ""README.txt""]) ]
 for dir in (""samples"", ""test""):
 files = []
 fullDirName = ""%s/%s"" % (baseName, dir)
 if sys.platform in (""win32"", ""cygwin""):
 dataFiles.append((fullDirName, files))
 
 # define the list of files to be included as documentation for bdist_rpm
-docFiles = ""README.txt LICENSE.txt BUILD.txt samples test""
+docFiles = ""README.txt LICENSE.txt samples test""
 
 # NOTE: on HP-UX Itanium with Oracle 10g you need to add the library ""ttsh10""
 # to the list of libraries along with ""clntsh""; since I am unable to test, I'll
",113,3
"Added support for getting the number of actual elements in a variable as well
as getting all of the values corresponding to the number of actual elements in
a variable -- primarily to improve the use of DML returning of multiple rows.","
 0, /* tp_iter */ \
 0, /* tp_iternext */ \
 g_VariableMethods, /* tp_methods */ \
- g_VariableMembers /* tp_members */ \
+ g_VariableMembers, /* tp_members */ \
+ g_VariableCalcMembers /* tp_getset */ \
 };
 
 #define MAKE_TYPE_READY(type) \
",420,57
"Create a new variable, rather than call dpiVar_resize(), so that the variable
will be bound properly when the variable needs to be resized."," class TestStringVar(BaseTestCase):
 value, = self.cursor.fetchone()
 self.assertEqual(value, supplementalChars)
 
+ def testBindTwiceWithLargeStringSecond(self):
+ ""test binding twice with a larger string the second time""
+ self.cursor.execute(""truncate table TestTempTable"")
+ self.cursor.execute(""insert into TestTempTable values (:1, :2)"",
+ (1, ""short string""))
+ self.cursor.execute(""insert into TestTempTable values (:1, :2)"",
+ (2, ""long string "" * 30))
+ self.connection.commit()
+
",269,35
"Added support for smallint and float data types in Oracle objects, as requested
(https://github.com/oracle/python-cx_Oracle/issues/4)."," class TestObjectVar(BaseTestCase):
 [ (u'INTCOL', cx_Oracle.NUMBER, 10, None, 9, 0, 0),
 (u'OBJECTCOL', cx_Oracle.OBJECT, None, None, None, None, 1),
 (u'ARRAYCOL', cx_Oracle.OBJECT, None, None, None, None, 1) ])
- self.__TestData(1, (1, u'First row', u'First ',
+ self.__TestData(1, (1, u'First row', u'First ', 2, 5, 12.5,
 cx_Oracle.Timestamp(2007, 3, 6, 0, 0, 0),
 cx_Oracle.Timestamp(2008, 9, 12, 16, 40),
 (11, 'Sub object 1'),
 [(5, 'first element'), (6, 'second element')]),
 [5, 10, None, 20])
 self.__TestData(2, None, [3, None, 9, 12, 15])
- self.__TestData(3, (3, u'Third row', u'Third ',
+ self.__TestData(3, (3, u'Third row', u'Third ', 4, 10, 43.25,
 cx_Oracle.Timestamp(2007, 6, 21, 0, 0, 0),
 cx_Oracle.Timestamp(2007, 12, 13, 7, 30, 45),
 (13, 'Sub object 3'),
",67,9
"Update release notes and adjust release name in preparation for release of
cx_Oracle 6.0 beta 1."," except:
 from distutils.extension import Extension
 
 # define build constants
-BUILD_VERSION = ""6.0""
+BUILD_VERSION = ""6.0b1""
 
 # define the list of files to be included as documentation for Windows
 dataFiles = None
",113,3
Adjust to modified ODPI-C API.," static PyObject* MakeDSN(PyObject* self, PyObject* args, PyObject* keywordArgs)
 //-----------------------------------------------------------------------------
 static PyObject* ClientVersion(PyObject* self, PyObject* args)
 {
- int versionNum, releaseNum, updateNum, portReleaseNum, portUpdateNum;
+ dpiVersionInfo versionInfo;
 
- if (dpiContext_getClientVersion(g_DpiContext, &versionNum, &releaseNum,
- &updateNum, &portReleaseNum, &portUpdateNum) < 0)
+ if (dpiContext_getClientVersion(g_DpiContext, &versionInfo) < 0)
 return Error_RaiseAndReturnNull();
- return Py_BuildValue(""(iiiii)"", versionNum, releaseNum, updateNum,
- portReleaseNum, portUpdateNum);
+ return Py_BuildValue(""(iiiii)"", versionInfo.versionNum,
+ versionInfo.releaseNum, versionInfo.updateNum,
+ versionInfo.portReleaseNum, versionInfo.portUpdateNum);
 }
 
 
",420,57
"Add support for getting an empty list from an empty collection instead of the
error ""OCI-22166: collection is empty""."," class TestObjectVar(BaseTestCase):
 self.assertEqual(obj.DATEVALUE, copiedObj.DATEVALUE)
 self.assertEqual(obj.TIMESTAMPVALUE, copiedObj.TIMESTAMPVALUE)
 
+ def testEmptyCollectionAsList(self):
+ ""test getting an empty collection as a list""
+ typeName = ""PKG_TESTNUMBERARRAYS.UDT_NUMBERLIST""
+ typeObj = self.connection.gettype(typeName)
+ obj = typeObj.newobject()
+ self.assertEqual(obj.aslist(), [])
+
 def testFetchData(self):
 ""test fetching objects""
 self.cursor.execute(""""""
",142,15
Eliminate compiler warnings.," static int cxBuffer_Init(udt_Buffer *buf)
 static int cxBuffer_FromObject(udt_Buffer *buf, PyObject *obj,
 const char *encoding)
 {
+ cxBuffer_Init(buf);
 if (!obj)
- return cxBuffer_Init(buf);
+ return 0;
 if (PyUnicode_Check(obj)) {
 buf->obj = PyUnicode_AsEncodedString(obj, encoding, NULL);
 if (!buf->obj)
",46,10
Use an object type that is supported in both 11.2 and 12.1.," class TestObjectVar(BaseTestCase):
 
 def testEmptyCollectionAsList(self):
 ""test getting an empty collection as a list""
- typeName = ""PKG_TESTNUMBERARRAYS.UDT_NUMBERLIST""
+ typeName = ""UDT_ARRAY""
 typeObj = self.connection.gettype(typeName)
 obj = typeObj.newobject()
 self.assertEqual(obj.aslist(), [])
",142,15
Remove obsolete comment.," if sys.platform in (""win32"", ""cygwin""):
 # define the list of files to be included as documentation for bdist_rpm
 docFiles = ""README.txt LICENSE.txt samples test""
 
-# NOTE: on HP-UX Itanium with Oracle 10g you need to add the library ""ttsh10""
-# to the list of libraries along with ""clntsh""; since I am unable to test, I'll
-# leave this as a comment until someone can verify when this is required
-# without making other cases where sys.platform == ""hp-ux11"" stop working
-
 # setup extra link and compile args
 extraLinkArgs = []
 extraCompileArgs = [""-DBUILD_VERSION=%s"" % BUILD_VERSION]
",113,3
"Correct support for executemany() when strings that are found later in the
array are larger than strings found earlier in the array."," class TestCursor(BaseTestCase):
 ( 4, ""Fourth"" ),
 ( 5, ""Fifth"" ),
 ( 6, ""Sixth"" ),
- ( 7, ""Seventh"" ) ]
- self.cursor.bindarraysize = 5
- self.cursor.setinputsizes(int, 100)
+ ( 7, ""Seventh and the longest one"" ) ]
 sql = ""insert into TestTempTable (IntCol, StringCol) values (:1, :2)""
 self.cursor.executemany(sql, rows)
- var = self.cursor.bindvars[1]
- self.cursor.execute(""select count(*) from TestTempTable"")
- count, = self.cursor.fetchone()
- self.assertEqual(count, len(rows))
- self.assertEqual(var.bufferSize,
- 100 * self.connection.maxBytesPerCharacter)
+ self.cursor.execute(""""""
+ select IntCol, StringCol
+ from TestTempTable
+ order by IntCol"""""")
+ fetchedRows = self.cursor.fetchall()
+ self.assertEqual(fetchedRows, rows)
 
 def testExecuteManyWithExecption(self):
 """"""test executing a statement multiple times (with exception)""""""
",355,50
"Correct handling of long Python integers that cannot fit inside a 64-bit C
integer (https://github.com/oracle/python-cx_Oracle/issues/18)."," static udt_VariableType *VarType_FromQueryInfo(dpiQueryInfo *info)
 case DPI_ORACLE_TYPE_NATIVE_DOUBLE:
 return &vt_NativeFloat;
 case DPI_ORACLE_TYPE_NUMBER:
- if (info->scale == 0 && info->precision > 0) {
- if (info->precision <= DPI_MAX_INT64_PRECISION)
+ if (info->scale == 0) {
+ if (info->precision > 0 &&
+ info->precision <= DPI_MAX_INT64_PRECISION)
 return &vt_NumberAsInteger;
 return &vt_NumberAsLongInteger;
 }
 static udt_VariableType *Variable_TypeByValue(PyObject* value, uint32_t* size,
 }
 #endif
 if (PyLong_Check(value))
- return &vt_NumberAsInteger;
+ return &vt_NumberAsLongInteger;
 if (PyFloat_Check(value))
 return &vt_NumberAsFloat;
 if (cxBinary_Check(value)) {
",686,199
Correct size as well as buffer size when variable is resized.," static int Variable_SetValueBytes(udt_Variable *var, uint32_t pos,
 dpiVar_release(var->handle);
 var->handle = tempVarHandle;
 var->data = tempVarData;
+ var->size = buffer.numCharacters;
 var->bufferSize = buffer.size;
 }
 status = dpiVar_setFromBytes(var->handle, pos, buffer.ptr, buffer.size);
",687,199
"Added support for getting/setting attributes of objects or element values in
collections that contain LOBs, BINARY_FLOAT values, BINARY_DOUBLE values and
NCHAR and NVARCHAR2 values; improve error message for any other types that are
not supported."," static PyObject *Connection_ChangePassword(udt_Connection *self,
 }
 
 
+#include ""LOB.c""
 #include ""Cursor.c""
 #include ""Subscription.c""
 #include ""DeqOptions.c""
",963,186
Check for an error while creating the error!," static int Error_RaiseFromInfo(dpiErrorInfo *errorInfo)
 udt_Error *self;
 
 self = Error_InternalNew(errorInfo);
+ if (!self)
+ return -1;
 switch (errorInfo->code) {
 case 1:
 case 1400:
",216,48
Set the fetch array size on a REF cursor prior to it being used by Python.," static int Cursor_VerifyFetch(udt_Cursor *self)
 
 // fixup REF cursor, if applicable
 if (self->fixupRefCursor) {
+ self->fetchArraySize = self->arraySize;
+ if (dpiStmt_setFetchArraySize(self->handle, self->fetchArraySize) < 0)
+ return Error_RaiseAndReturnInt();
 if (dpiStmt_getNumQueryColumns(self->handle, &numQueryColumns) < 0)
 return Error_RaiseAndReturnInt();
 if (Cursor_PerformDefine(self, numQueryColumns) < 0)
",1523,368
Prevent attempts from binding the cursor being executed to itself.," class TestCursorVar(BaseTestCase):
 self.assertEqual(cursor.fetchall(),
 [ (1, 'String 1'), (2, 'String 2') ])
 
+ def testBindSelf(self):
+ ""test that binding the cursor itself is not supported""
+ cursor = self.connection.cursor()
+ sql = """"""
+ begin
+ open :pcursor for
+ select 1 from dual;
+ end;""""""
+ self.assertRaises(cx_Oracle.DatabaseError, cursor.execute, sql,
+ pcursor = cursor)
+
 def testFetchCursor(self):
 ""test fetching a cursor""
 self.cursor.execute(""""""
",51,5
Ensure reference count of parameters remains the same after call completes!," static PyObject *Connection_Rollback(udt_Connection *self, PyObject *args)
 static PyObject *Connection_NewCursor(udt_Connection *self, PyObject *args,
 PyObject *keywordArgs)
 {
- PyObject *createArgs, *result;
+ PyObject *createArgs, *result, *arg;
 Py_ssize_t numArgs = 0, i;
 
 if (args)
 static PyObject *Connection_NewCursor(udt_Connection *self, PyObject *args,
 return NULL;
 Py_INCREF(self);
 PyTuple_SET_ITEM(createArgs, 0, (PyObject*) self);
- for (i = 0; i < numArgs; i++)
- PyTuple_SET_ITEM(createArgs, i + 1, PyTuple_GET_ITEM(args, i));
+ for (i = 0; i < numArgs; i++) {
+ arg = PyTuple_GET_ITEM(args, i);
+ Py_INCREF(arg);
+ PyTuple_SET_ITEM(createArgs, i + 1, arg);
+ }
 result = PyObject_Call( (PyObject*) &g_CursorType, createArgs,
 keywordArgs);
 Py_DECREF(createArgs);
",966,186
"Added support for setting the debug level in ODPI-C, if desirable, by setting
an environment variable prior to building cx_Oracle."," elif sys.platform == ""cygwin"":
 elif sys.platform == ""darwin"":
 extraLinkArgs.append(""-shared-libgcc"")
 
+# setup ODPI-C debugging, if desirable
+defines = []
+debugLevelName = ""DPI_DEBUG_LEVEL""
+if debugLevelName in os.environ:
+ defines = [(debugLevelName, os.environ[debugLevelName])]
+
 class test(distutils.core.Command):
 description = ""run the test suite for the extension""
 user_options = []
 extension = Extension(
 include_dirs = [""odpi/include"", ""odpi/src""],
 extra_compile_args = extraCompileArgs,
 extra_link_args = extraLinkArgs,
+ define_macros = defines,
 sources = [""src/cx_Oracle.c""],
 depends = [""src/BooleanVar.c"", ""src/Buffer.c"", ""src/Connection.c"",
 ""src/Cursor.c"", ""src/CursorVar.c"", ""src/DateTimeVar.c"",
",118,3
"Correct determination of the names of the bind variables in prepared SQL
tatements (which behaves a little differently from PL/SQL statements)."," static PyObject *Cursor_BindNames(udt_Cursor *self, PyObject *args)
 }
 
 // get the bind names
- if (dpiStmt_getBindNames(self->handle, numBinds, names, nameLengths) < 0) {
+ if (dpiStmt_getBindNames(self->handle, &numBinds, names,
+ nameLengths) < 0) {
 PyMem_Free((void*) names);
 PyMem_Free(nameLengths);
 return Error_RaiseAndReturnNull();
",1524,368
Preparing to release cx_Oracle 6.0b2.," except:
 from distutils.extension import Extension
 
 # define build constants
-BUILD_VERSION = ""6.0b1""
+BUILD_VERSION = ""6.0b2""
 
 # define the list of files to be included as documentation for Windows
 dataFiles = None
",118,3
"Handle case when both precision and scale are zero, as occurs when retrieving
numeric expressions (https://github.com/oracle/python-cx_Oracle/issues/34)."," static PyObject *NumberVar_GetValueLongInteger(udt_Variable *var,
 if (!stringObj)
 return NULL;
 result = PyNumber_Int(stringObj);
+ if (!result && PyErr_ExceptionMatches(PyExc_ValueError)) {
+ PyErr_Clear();
+ result = PyNumber_Float(stringObj);
+ }
 Py_DECREF(stringObj);
 return result;
 }
",160,18
Add tests for specifying only the encoding or only the nencoding.," class TestConnection(TestCase):
 self.assertRaises(cx_Oracle.DatabaseError, cx_Oracle.connect,
 self.username, self.password + ""X"", self.tnsentry)
 
+ def testEncodings(self):
+ ""connection with only encoding or nencoding specified should work""
+ connection = cx_Oracle.connect(self.username, self.password,
+ self.tnsentry)
+ encoding = connection.encoding
+ nencoding = connection.nencoding
+ connection = cx_Oracle.connect(self.username, self.password,
+ self.tnsentry, encoding = ""UTF-8"")
+ self.assertEqual(connection.encoding, ""UTF-8"")
+ self.assertEqual(connection.nencoding, nencoding)
+ connection = cx_Oracle.connect(self.username, self.password,
+ self.tnsentry, nencoding = ""UTF-8"")
+ self.assertEqual(connection.encoding, encoding)
+ self.assertEqual(connection.nencoding, ""UTF-8"")
+
 def testExceptionOnClose(self):
 ""confirm an exception is raised after closing a connection""
 connection = cx_Oracle.connect(self.username, self.password,
",111,16
"Permit use of both string and unicode for Python 2.7 for creating session pools
and for changing passwords
(https://github.com/oracle/python-cx_Oracle/issues/23)."," static PyObject *Connection_ChangePassword(udt_Connection *self,
 int status;
 
 // parse the arguments
- if (!PyArg_ParseTuple(args, ""O!O!"", cxString_Type, &oldPasswordObj,
- cxString_Type, &newPasswordObj))
+ if (!PyArg_ParseTuple(args, ""OO"", &oldPasswordObj, &newPasswordObj))
 return NULL;
 
 // populate buffers
",965,186
"Update ODPI-C which has added an optimization to reduce buffer size when both
the client and server character sets are identical and corrected support for
BFILE LOBs."," class TestCursorVar(BaseTestCase):
 end;"""""",
 cursor = cursor)
 self.assertEqual(cursor.description,
- [ ('STRINGVALUE', cx_Oracle.FIXED_CHAR, 1, 4, None, None, 1) ])
+ [ ('STRINGVALUE', cx_Oracle.FIXED_CHAR, 1, CS_RATIO, None,
+ None, 1) ])
 self.assertEqual(cursor.fetchall(), [('X',)])
 
 def testBindCursorInPackage(self):
 class TestCursorVar(BaseTestCase):
 self.cursor.callproc(""pkg_TestOutCursors.TestOutCursor"", (2, cursor))
 self.assertEqual(cursor.description,
 [ ('INTCOL', cx_Oracle.NUMBER, 10, None, 9, 0, 0),
- ('STRINGCOL', cx_Oracle.STRING, 20, 80, None, None, 0) ])
+ ('STRINGCOL', cx_Oracle.STRING, 20, 20 * CS_RATIO, None,
+ None, 0) ])
 self.assertEqual(cursor.fetchall(),
 [ (1, 'String 1'), (2, 'String 2') ])
 
",53,5
"The method cursor.setoutputsize() no longer needs to do anything (since ODPI-C
automatically manages buffer sizes of LONG and LONG RAW columns)."," class TestLongVar(BaseTestCase):
 ('LONGRAWCOL', cx_Oracle.LONG_BINARY, None, None, None, None,
 0) ])
 
- def testSetOutputSizesAll(self):
- ""test setoutputsizes is valid (all)""
- self.cursor.setoutputsize(25000)
- self.cursor.execute(""select * from TestLongRaws"")
- longVar = self.cursor.fetchvars[1]
- self.assertEqual(longVar.size, 25000)
-
- def testSetOutputSizesWrongColumn(self):
- ""test setoutputsizes is valid (wrong column)""
- self.cursor.setoutputsize(25000, 1)
- self.cursor.execute(""select * from TestLongs"")
- longVar = self.cursor.fetchvars[1]
- self.assertEqual(longVar.size, 131072)
-
- def testSetOutputSizesRightColumn(self):
- ""test setoutputsizes is valid (right column)""
- self.cursor.setoutputsize(35000, 2)
- self.cursor.execute(""select * from TestLongRaws"")
- longVar = self.cursor.fetchvars[1]
- self.assertEqual(longVar.size, 35000)
-
 def testArraySizeTooLarge(self):
 ""test array size too large generates an exception""
 self.cursor.arraysize = 268435456
",68,13
Preparing to release cx_Oracle 6 rc 1.," except:
 from distutils.extension import Extension
 
 # define build constants
-BUILD_VERSION = ""6.0b2""
+BUILD_VERSION = ""6.0rc1""
 
 # define the list of files to be included as documentation for Windows
 dataFiles = None
",118,3
Add support for Python 3 in DB API test suite stub.,"
 """"""Driver specific portion of the DB API test suite provided by Stuart Bishop
 available at http://stuartbishop.net/Software/DBAPI20TestSuite/""""""
 
+from __future__ import print_function
+
 import cx_Oracle
 import dbapi20
 import unittest
 class TestSuite(dbapi20.DatabaseAPI20Test):
 
 
 if __name__ == ""__main__"":
- print ""Testing cx_Oracle version"", cx_Oracle.version
+ print(""Testing cx_Oracle version"", cx_Oracle.version)
 unittest.main()
 
",23,5
"Corrected support for binding decimal values in object attribute values and
collection element values.","
 
 import cx_Oracle
 import datetime
+import decimal
 
 class TestObjectVar(BaseTestCase):
 
 class TestObjectVar(BaseTestCase):
 obj.TIMESTAMPVALUE = None
 subTypeObj = self.connection.gettype(""UDT_SUBOBJECT"")
 subObj = subTypeObj.newobject()
- subObj.SUBNUMBERVALUE = 15
+ subObj.SUBNUMBERVALUE = decimal.Decimal(""18.25"")
 subObj.SUBSTRINGVALUE = ""Sub String""
 obj.SUBOBJECTVALUE = subObj
 result = self.cursor.callfunc(""pkg_TestBindObject.GetStringRep"", str,
 (obj,))
 self.assertEqual(result,
 ""udt_Object(null, 'Test With Dates', null, null, null, "" \
- ""udt_SubObject(15, 'Sub String'), null)"")
+ ""udt_SubObject(18.25, 'Sub String'), null)"")
 
 def testCopyObject(self):
 ""test copying an object""
",205,17
Ensure the correct encoding is used for setting variable values.," static int Variable_SetValueBytes(udt_Variable *var, uint32_t pos,
 {
 dpiData *tempVarData, *sourceData;
 dpiVar *tempVarHandle;
+ const char *encoding;
 udt_Buffer buffer;
 uint32_t i;
 int status;
 
- if (cxBuffer_FromObject(&buffer, value,
- var->connection->encodingInfo.encoding) < 0)
+ if (var->type == &vt_FixedNationalChar ||
+ var->type == &vt_NationalCharString)
+ encoding = var->connection->encodingInfo.nencoding;
+ else encoding = var->connection->encodingInfo.encoding;
+ if (cxBuffer_FromObject(&buffer, value, encoding) < 0)
 return -1;
 if (var->type->size > 0 && buffer.size > var->bufferSize) {
 if (dpiConn_newVar(var->connection->handle, var->type->oracleTypeNum,
",692,203
"Python 2.7 requires the ""u"" prefix."," class TestConnection(TestCase):
 def testDifferentEncodings(self):
 connection = cx_Oracle.connect(self.username, self.password,
 self.tnsentry, encoding = ""UTF-8"", nencoding = ""UTF-16"")
- value = ""\u03b4\u4e2a""
+ value = u""\u03b4\u4e2a""
 cursor = connection.cursor()
 ncharVar = cursor.var(cx_Oracle.NCHAR, 100)
 ncharVar.setvalue(0, value)
",121,17
"Added test cases for AQ enqueue/dequeue options and message properties
(https://github.com/oracle/odpi/issues/16)."," else:
 ""ObjectVar"",
 ""SessionPool"",
 ""StringVar"",
- ""TimestampVar""
+ ""TimestampVar"",
+ ""AQ""
 ]
 if sys.version_info[0] < 3:
 moduleNames.extend([
",105,2
Corrected support for binding boolean values with Oracle client 11.2.," static int NumberVar_SetValueInteger(udt_Variable *var, uint32_t pos,
 return 0;
 }
 #endif
+ if (PyBool_Check(value)) {
+ data->value.asInt64 = (value == Py_True);
+ return 0;
+ }
 if (!PyLong_Check(value)) {
 PyErr_SetString(PyExc_TypeError, ""expecting integer"");
 return -1;
",164,19
"Rework test suite and samples so that they are independent of each other and
so that the SQL scripts used to create/drop schemas are easily adjusted to
use different schema names, if desired. Improve documentation for test suite
and samples.","
 from __future__ import print_function
 
 import cx_Oracle
+import SampleEnv
 import threading
 import time
 
 def callback(message):
 print(""-"" * 60)
 print(""="" * 60)
 
-connection = cx_Oracle.Connection(""cx_Oracle/dev@localhost/orcl"",
- events = True)
+connection = cx_Oracle.Connection(SampleEnv.MAIN_CONNECT_STRING, events = True)
 sub = connection.subscribe(callback = callback, timeout = 1800,
 qos = cx_Oracle.SUBSCR_QOS_ROWIDS)
 print(""Subscription:"", sub)
",34,4
"Remove unnecessary Unicode specific tests for Python 2.7 since Python 3 now
also supports the ""u"" prefix; merge them instead into the main tests."," class TestObjectVar(BaseTestCase):
 objValue, = self.cursor.fetchone()
 self.assertEqual(objValue.type.schema,
 self.connection.username.upper())
- self.assertEqual(objValue.type.name, ""UDT_OBJECT"")
+ self.assertEqual(objValue.type.name, u""UDT_OBJECT"")
 self.assertEqual(objValue.type.attributes[0].name, ""NUMBERVALUE"")
 
 def testRoundTripObject(self):
 class TestObjectVar(BaseTestCase):
 nclob, = self.cursor.fetchone()
 self.cursor.execute(""select BLOBCol from TestBlobs"")
 blob, = self.cursor.fetchone()
- typeObj = self.connection.gettype(""UDT_OBJECT"")
+ typeObj = self.connection.gettype(u""UDT_OBJECT"")
 obj = typeObj.newobject()
 obj.NUMBERVALUE = 5
 obj.STRINGVALUE = ""A string""
",205,17
Correct handling of CLOB/NCLOB when using different encodings.," static PyObject *LOB_InternalRead(udt_LOB *self, uint64_t offset,
 }
 
 // return the result
- if (self->oracleTypeNum == DPI_ORACLE_TYPE_CLOB)
+ if (self->oracleTypeNum == DPI_ORACLE_TYPE_NCLOB)
 result = PyUnicode_Decode(buffer, bufferSize,
- self->connection->encodingInfo.encoding, NULL);
- else if (self->oracleTypeNum == DPI_ORACLE_TYPE_NCLOB)
+ self->connection->encodingInfo.nencoding, NULL);
+ else if (self->oracleTypeNum == DPI_ORACLE_TYPE_CLOB)
 result = cxString_FromEncodedString(buffer, bufferSize,
- self->connection->encodingInfo.nencoding);
+ self->connection->encodingInfo.encoding);
 else result = PyBytes_FromStringAndSize(buffer, bufferSize);
 PyMem_Free(buffer);
 return result;
",328,52
"Ensure that the array position passed to var.getvalue() does not exceed the
number of elements allocated in the array!"," static PyObject *Variable_GetSingleValue(udt_Variable *var, uint32_t arrayPos)
 PyObject *value, *result;
 dpiData *data;
 
+ // ensure we do not exceed the number of allocated elements
+ if (arrayPos >= var->allocatedElements) {
+ PyErr_SetString(PyExc_IndexError,
+ ""Variable_GetSingleValue: array size exceeded"");
+ return NULL;
+ }
+
+ // return the value
 data = &var->data[arrayPos];
 if (data->isNull)
 Py_RETURN_NONE;
",700,205
Preparing to release cx_Oracle 6 rc 2.," except:
 from distutils.extension import Extension
 
 # define build constants
-BUILD_VERSION = ""6.0rc1""
+BUILD_VERSION = ""6.0rc2""
 
 # define the list of files to be included as documentation for Windows
 dataFiles = None
",118,3
"In certain cases where non-long values follow LOB values in the list of bind
variables, the error ""ORA-24816: Expanded non LONG bind data supplied after
actual LONG or LOB column"" is raised; this occurs if the length of the supplied
value, when expanded, might exceed 4000 bytes
(https://github.com/oracle/python-cx_Oracle/issues/50)."," static udt_VariableType *Variable_TypeByValue(PyObject* value, uint32_t* size,
 }
 if (cxString_Check(value)) {
 *size = (uint32_t) cxString_GetSize(value);
+ if (*size == 0)
+ *size = 1;
 return &vt_String;
 }
 if (PyBool_Check(value)) {
 static udt_VariableType *Variable_TypeByValue(PyObject* value, uint32_t* size,
 #if PY_MAJOR_VERSION < 3
 if (PyUnicode_Check(value)) {
 *size = (uint32_t) PyUnicode_GET_SIZE(value);
+ if (*size == 0)
+ *size = 1;
 return &vt_NationalCharString;
 }
 if (PyInt_Check(value))
",704,207
"ODPI-C debugging is now controlled at runtime by the environment variable
DPI_DEBUG_LEVEL, rather than at compile time."," elif sys.platform == ""cygwin"":
 elif sys.platform == ""darwin"":
 extraLinkArgs.append(""-shared-libgcc"")
 
-# setup ODPI-C debugging, if desirable
-defines = []
-debugLevelName = ""DPI_DEBUG_LEVEL""
-if debugLevelName in os.environ:
- defines = [(debugLevelName, os.environ[debugLevelName])]
-
 class test(distutils.core.Command):
 description = ""run the test suite for the extension""
 user_options = []
 extension = Extension(
 include_dirs = [""odpi/include"", ""odpi/src""],
 extra_compile_args = extraCompileArgs,
 extra_link_args = extraLinkArgs,
- define_macros = defines,
 sources = [""src/cx_Oracle.c""],
 depends = [""src/BooleanVar.c"", ""src/Buffer.c"", ""src/Connection.c"",
 ""src/Cursor.c"", ""src/CursorVar.c"", ""src/DateTimeVar.c"",
",113,3
"All cursors and LOBs must be closed before a connection can be closed
explicitly."," class TestConnection(TestCase):
 self.tnsentry)
 otherCursor = otherConnection.cursor()
 otherCursor.execute(""insert into TestTempTable (IntCol) values (1)"")
+ otherCursor.close()
 otherConnection.close()
 cursor.execute(""select count(*) from TestTempTable"")
 count, = cursor.fetchone()
",125,17
"Delay initialization of the ODPI-C library until the first standalone
connection or session pool is created so that manipulation of the environment
variable NLS_LANG can be performed after the module has been imported
(https://github.com/oracle/python-cx_Oracle/issues/36); this also has the added
benefit of reducing the number of errors that can take place when the module is
imported."," static int Connection_Init(udt_Connection *self, PyObject *args,
 threadedObj = eventsObj = newPasswordObj = usernameObj = NULL;
 passwordObj = dsnObj = cclassObj = editionObj = tagObj = NULL;
 matchAnyTagObj = contextObj = NULL;
+ if (InitializeDPI() < 0)
+ return -1;
 if (dpiContext_initCommonCreateParams(g_DpiContext, &dpiCommonParams) < 0)
 return Error_RaiseAndReturnInt();
 dpiCommonParams.driverName = DRIVER_NAME;
",994,188
Preparing to release cx_Oracle 6.0.," except:
 from distutils.extension import Extension
 
 # define build constants
-BUILD_VERSION = ""6.0rc2""
+BUILD_VERSION = ""6.0""
 
 # define the list of files to be included as documentation for Windows
 dataFiles = None
",113,3
Include the README.txt and LICENSE.txt files in the wheels that are produced.," except:
 from distutils.extension import Extension
 
 # define build constants
-BUILD_VERSION = ""6.0""
+BUILD_VERSION = ""6.0.1""
 
 # setup extra link and compile args
 extraLinkArgs = []
 setup(
 version = BUILD_VERSION,
 description = ""Python interface to Oracle"",
 cmdclass = dict(test = test),
+ data_files = [ (""cx_Oracle-doc"", [""LICENSE.txt"", ""README.txt""]) ],
 long_description = \
 ""Python interface to Oracle Database conforming to the Python DB ""
 ""API 2.0 specification.\n""
",96,3
Update ODPI-C to 2.0.1.," typedef struct {
 uint32_t timeout;
 uint32_t operations;
 uint32_t qos;
- uint32_t id;
+ uint64_t id;
 } udt_Subscription;
 
 typedef struct {
 static PyMemberDef g_SubscriptionTypeMembers[] = {
 { ""timeout"", T_INT, offsetof(udt_Subscription, timeout), READONLY },
 { ""operations"", T_INT, offsetof(udt_Subscription, operations), READONLY },
 { ""qos"", T_INT, offsetof(udt_Subscription, qos), READONLY },
- { ""id"", T_INT, offsetof(udt_Subscription, id), READONLY },
+ { ""id"", T_ULONG, offsetof(udt_Subscription, id), READONLY },
 { NULL }
 };
 
",615,64
"Added missing type check to prevent coercion of decimal to float
(https://github.com/oracle/python-cx_Oracle/issues/68)."," static int NumberVar_SetValueDecimal(udt_Variable *var, uint32_t pos,
 static int NumberVar_SetValueFloat(udt_Variable *var, uint32_t pos,
 dpiData *data, PyObject *value)
 {
+ if (!PyFloat_Check(value) &&
+#if PY_MAJOR_VERSION < 3
+ !PyInt_Check(value) &&
+#endif
+ !PyLong_Check(value)) {
+ PyErr_SetString(PyExc_TypeError, ""expecting float"");
+ return -1;
+ }
 data->value.asDouble = PyFloat_AsDouble(value);
 if (PyErr_Occurred())
 return -1;
",170,23
"Don't prevent connection from being explicitly closed when a fatal error has
taken place (https://github.com/oracle/python-cx_Oracle/issues/67)."," except:
 from distutils.extension import Extension
 
 # define build constants
-BUILD_VERSION = ""6.0.1""
+BUILD_VERSION = ""6.0.2""
 
 # setup extra link and compile args
 extraLinkArgs = []
",96,3
Eliminate memory leak when repeatedly executing the same query.," static PyObject *Cursor_Execute(udt_Cursor *self, PyObject *args,
 return Error_RaiseAndReturnNull();
 
 // perform defines, if necessary
- if (numQueryColumns > 0) {
+ if (numQueryColumns > 0 && !self->fetchVariables) {
 if (Cursor_PerformDefine(self, numQueryColumns) < 0) {
 Py_CLEAR(self->fetchVariables);
 return NULL;
",1514,366
"On Windows, sizeof(long) = 4 which means that integers between 10 and 18 digits
were not converted to Python correctly
(https://github.com/oracle/python-cx_Oracle/issues/70)."," static PyMethodDef g_VariableMethods[] = {
 //-----------------------------------------------------------------------------
 static udt_VariableType *VarType_FromDataTypeInfo(dpiDataTypeInfo *info)
 {
+ static int maxLongSafeDigits = sizeof(long) >= 8 ? 18 : 9;
 char message[120];
 
 switch (info->oracleTypeNum) {
 static udt_VariableType *VarType_FromDataTypeInfo(dpiDataTypeInfo *info)
 if (info->scale == 0 ||
 (info->scale == -127 && info->precision == 0)) {
 if (info->precision > 0 &&
- info->precision <= DPI_MAX_INT64_PRECISION)
+ info->precision <= maxLongSafeDigits)
 return &vt_NumberAsInteger;
 return &vt_NumberAsLongInteger;
 }
",705,208
"Update ODPI-C (improve performance, correct handling of objects when dynamic
binding is being used)."," void initcx_Oracle(void)
 #include ""dpiConn.c""
 #include ""dpiContext.c""
 #include ""dpiData.c""
+#include ""dpiDebug.c""
 #include ""dpiDeqOptions.c""
 #include ""dpiEnqOptions.c""
 #include ""dpiEnv.c""
",431,60
Eliminate segfault when attempting to reuse a REF cursor that has been closed.," class TestCursorVar(BaseTestCase):
 self.assertRaises(cx_Oracle.DatabaseError, cursor.execute, sql,
 pcursor = cursor)
 
+ def testExecuteAfterClose(self):
+ ""test executing a statement returning a ref cursor after closing it""
+ outCursor = self.connection.cursor()
+ sql = """"""
+ begin
+ open :pcursor for
+ select IntCol
+ from TestNumbers
+ order by IntCol;
+ end;""""""
+ self.cursor.execute(sql, pcursor = outCursor)
+ rows = outCursor.fetchall()
+ outCursor.close()
+ outCursor = self.connection.cursor()
+ self.cursor.execute(sql, pcursor = outCursor)
+ rows2 = outCursor.fetchall()
+ self.assertEqual(rows, rows2)
+
 def testFetchCursor(self):
 ""test fetching a cursor""
 self.cursor.execute(""""""
",70,6
Adjust samples to handle the deregistration event without an exception.," import SampleEnv
 import threading
 import time
 
+registered = True
+
 def callback(message):
+ global registered
 print(""Message type:"", message.type)
+ if message.type == cx_Oracle.EVENT_DEREG:
+ print(""Deregistration has taken place..."")
+ registered = False
+ return
 print(""Message database name:"", message.dbname)
 print(""Message tables:"")
 for table in message.tables:
 print(""--> Operations:"", sub.operations)
 print(""--> Rowids?:"", bool(sub.qos & cx_Oracle.SUBSCR_QOS_ROWIDS))
 sub.registerquery(""select * from TestTempTable"")
 
-while True:
+while registered:
 print(""Waiting for notifications...."")
 time.sleep(5)
 
",40,5
"Ensure that a call to setinputsizes() with an invalid type prior to a call to
executemany() does not result in a type error, but instead gracefully ignores
the call to setinputsizes() as required by the DB API
(https://github.com/oracle/python-cx_Oracle/issues/75).","
 """"""Module for testing cursor objects.""""""
 
 import cx_Oracle
+import decimal
 import sys
 
 class TestCursor(BaseTestCase):
 class TestCursor(BaseTestCase):
 count, = self.cursor.fetchone()
 self.assertEqual(count, len(rows))
 
+ def testExecuteManyWithInputSizesWrong(self):
+ cursor = self.connection.cursor()
+ cursor.setinputsizes(cx_Oracle.NUMBER)
+ data = [[decimal.Decimal(""25.8"")], [decimal.Decimal(""30.0"")]]
+ cursor.executemany(""declare t number; begin t := :1; end;"", data)
+
 def testExecuteManyWithResize(self):
 """"""test executing a statement multiple times (with resize)""""""
 self.cursor.execute(""truncate table TestTempTable"")
",367,51
"Added additional LOB function tests; skip supplemental characters test if
database character set is not AL32UTF8."," class TestStringVar(BaseTestCase):
 
 def testSupplementalCharacters(self):
 ""test that binding and fetching supplemental charcters works correctly""
+ self.cursor.execute(""""""
+ select value
+ from nls_database_parameters
+ where parameter = 'NLS_CHARACTERSET'"""""")
+ charset, = self.cursor.fetchone()
+ if charset != ""AL32UTF8"":
+ self.skipTest(""Database character set must be AL32UTF8"")
 supplementalChars = ""               "" \
 ""                   "" \
 ""                   "" \
",338,43
Add Oracle Open World 2017 Hands-on Lab (tutorial).,"
+#------------------------------------------------------------------------------
+# type_converter.py (Section 6.2)
+#------------------------------------------------------------------------------
+
+#------------------------------------------------------------------------------
+# Copyright 2017, Oracle and/or its affiliates. All rights reserved.
+#------------------------------------------------------------------------------
+
+import cx_Oracle
+import decimal
+
+con = cx_Oracle.connect(""pythonhol"", ""welcome"", ""localhost/orclpdb"")
+cur = con.cursor()
+
+def ReturnNumbersAsDecimal(cursor, name, defaultType, size, precision, scale):
+ if defaultType == cx_Oracle.NUMBER:
+ return cursor.var(str, 9, cursor.arraysize, outconverter = decimal.Decimal)
+
+cur.outputtypehandler = ReturnNumbersAsDecimal
+
+for value, in cur.execute(""select 0.1 from dual""):
+ print(""Value:"", value, ""* 3 ="", value * 3)
",10,2
Added test cases for rowids.," else:
 ""SessionPool"",
 ""StringVar"",
 ""TimestampVar"",
- ""AQ""
+ ""AQ"",
+ ""Rowid""
 ]
 clientVersion = cx_Oracle.clientversion()
 if clientVersion[:2] >= (12, 1):
",95,2
Simplify sample for returning numbers as decimal objects.," import SampleEnv
 
 def OutputTypeHandler(cursor, name, defaultType, size, precision, scale):
 if defaultType == cx_Oracle.NUMBER:
- return cursor.var(str, size = 200, arraysize = cursor.arraysize,
- outconverter = decimal.Decimal)
+ return cursor.var(decimal.Decimal, arraysize = cursor.arraysize)
 
 connection = cx_Oracle.Connection(SampleEnv.MAIN_CONNECT_STRING)
 connection.outputtypehandler = OutputTypeHandler
",13,2
Update ODPI-C (replace usage of OCI thread key with thread-safe handle pool).," extension = Extension(
 ""odpi/src/dpiDeqOptions.c"", ""odpi/src/dpiEnqOptions.c"",
 ""odpi/src/dpiEnv.c"", ""odpi/src/dpiError.c"",
 ""odpi/src/dpiGen.c"", ""odpi/src/dpiGlobal.c"",
- ""odpi/src/dpiLob.c"", ""odpi/src/dpiMsgProps.c"",
- ""odpi/src/dpiObject.c"", ""odpi/src/dpiObjectAttr.c"",
- ""odpi/src/dpiObjectType.c"", ""odpi/src/dpiOci.c"",
- ""odpi/src/dpiOracleType.c"", ""odpi/src/dpiPool.c"",
- ""odpi/src/dpiRowid.c"", ""odpi/src/dpiStmt.c"",
- ""odpi/src/dpiSubscr.c"", ""odpi/src/dpiUtils.c"",
- ""odpi/src/dpiVar.c""])
+ ""odpi/src/dpiHandlePool.c"", ""odpi/src/dpiLob.c"",
+ ""odpi/src/dpiMsgProps.c"", ""odpi/src/dpiObject.c"",
+ ""odpi/src/dpiObjectAttr.c"", ""odpi/src/dpiObjectType.c"",
+ ""odpi/src/dpiOci.c"", ""odpi/src/dpiOracleType.c"",
+ ""odpi/src/dpiPool.c"", ""odpi/src/dpiRowid.c"",
+ ""odpi/src/dpiStmt.c"", ""odpi/src/dpiSubscr.c"",
+ ""odpi/src/dpiUtils.c"", ""odpi/src/dpiVar.c""])
 
 # perform the setup
 setup(
",97,3
"Check variable array size when setting variable values and raise IndexError, as
is already done for getting variable values."," static int Variable_SetSingleValue(udt_Variable *var, uint32_t arrayPos,
 int result = 0;
 dpiData *data;
 
+ // ensure we do not exceed the number of allocated elements
+ if (arrayPos >= var->allocatedElements) {
+ PyErr_SetString(PyExc_IndexError,
+ ""Variable_SetSingleValue: array size exceeded"");
+ return -1;
+ }
+
 // convert value, if necessary
 if (var->inConverter && var->inConverter != Py_None) {
 convertedValue = PyObject_CallFunctionObjArgs(var->inConverter, value,
",710,209
"Add support for identifying the id of the transaction which spawned the
message, as requested (https://github.com/oracle/odpi/issues/32)."," def callback(message):
 registered = False
 return
 print(""Message database name:"", message.dbname)
+ print(""Message tranasction id:"", message.txid)
 print(""Message queries:"")
 for query in message.queries:
 print(""--> Query ID:"", query.id)
",45,6
Correct test suite when CHAR encoding is not capable of handling unicode data.," class TestLobVar(BaseTestCase):
 value = u""\u03b4\u4e2a""
 cursor = connection.cursor()
 cursor.execute(""truncate table TestNCLOBs"")
+ cursor.setinputsizes(val = cx_Oracle.NCHAR)
 cursor.execute(""insert into TestNCLOBs values (1, :val)"", val = value)
 cursor.execute(""select NCLOBCol from TestNCLOBs"")
 nclob, = cursor.fetchone()
+ cursor.setinputsizes(val = cx_Oracle.NCHAR)
 cursor.execute(""update TestNCLOBs set NCLOBCol = :val"",
 val = nclob.read() + value)
 cursor.execute(""select NCLOBCol from TestNCLOBs"")
",198,36
"Added test cases for validating object types and for preventing an attempt to
set a LOB variable at an array position that doesn't exist."," class TestLobVar(BaseTestCase):
 self.__TestLobOperations(""NCLOB"")
 
 def testTemporaryLobs(self):
+ ""test temporary LOBs""
 cursor = self.connection.cursor()
 cursor.arraysize = self.cursor.arraysize
 cursor.execute(""""""
 class TestLobVar(BaseTestCase):
 tempLobs = self.__GetTempLobs(sid)
 self.assertEqual(tempLobs, 0)
 
+ def testAssignStringBeyondArraySize(self):
+ ""test assign string to NCLOB beyond array size""
+ nclobVar = self.cursor.var(cx_Oracle.NCLOB)
+ self.assertRaises(IndexError, nclobVar.setvalue, 1, ""test char"")
+
",203,37
Remove unnecessary lines.," static udt_VariableType vt_Interval = {
 };
 
 
-// PyPy compatibility {
-
+// PyPy compatibility
 #ifndef PyDateTime_DELTA_GET_DAYS
 #define PyDateTime_DELTA_GET_DAYS(x) ((x)->days)
 #endif
 static udt_VariableType vt_Interval = {
 #define PyDateTime_DELTA_GET_MICROSECONDS(x) ((x)->microseconds)
 #endif
 
-// }
 
 //-----------------------------------------------------------------------------
 // IntervalVar_SetValue()
",41,3
"Ensure that the edition is passed through to ODPI-C when a session pool is
created."," static int SessionPool_Init(udt_SessionPool *self, PyObject *args,
 dpiCreateParams.minSessions = minSessions;
 dpiCreateParams.maxSessions = maxSessions;
 dpiCreateParams.sessionIncrement = sessionIncrement;
+ dpiCommonParams.edition = editionBuffer.ptr;
+ dpiCommonParams.editionLength = editionBuffer.size;
 
 // create pool
 Py_BEGIN_ALLOW_THREADS
",406,60
"Added test cases for autocommit, changing passwords and the end-to-end tracing
attributes."," class TestConnection(TestCase):
 encoding = ENCODING, nencoding = NENCODING)
 self.assertEqual(pool.username, USERNAME, ""user name differs"")
 self.assertEqual(pool.tnsentry, TNSENTRY, ""tnsentry differs"")
+ self.assertEqual(pool.dsn, TNSENTRY, ""dsn differs"")
 self.assertEqual(pool.max, 8, ""max differs"")
 self.assertEqual(pool.min, 2, ""min differs"")
 self.assertEqual(pool.increment, 3, ""increment differs"")
",107,12
"Update ODPI-C (adjust OCI prefetch; added options for authentication with
SYSBACKUP, SYSDG, SYSKM and SYSRAC, as requested
(https://github.com/oracle/python-cx_Oracle/issues/101)."," static PyObject *Module_Initialize(void)
 
 // add constants for authorization modes
 ADD_INT_CONSTANT(""SYSASM"", DPI_MODE_AUTH_SYSASM)
+ ADD_INT_CONSTANT(""SYSBKP"", DPI_MODE_AUTH_SYSBKP)
 ADD_INT_CONSTANT(""SYSDBA"", DPI_MODE_AUTH_SYSDBA)
+ ADD_INT_CONSTANT(""SYSDGD"", DPI_MODE_AUTH_SYSDGD)
+ ADD_INT_CONSTANT(""SYSKMT"", DPI_MODE_AUTH_SYSKMT)
 ADD_INT_CONSTANT(""SYSOPER"", DPI_MODE_AUTH_SYSOPER)
+ ADD_INT_CONSTANT(""SYSRAC"", DPI_MODE_AUTH_SYSRAC)
 ADD_INT_CONSTANT(""PRELIM_AUTH"", DPI_MODE_AUTH_PRELIM)
 
 // add constants for session pool get modes
",436,60
Added preliminary test cases for subscriptions.," else:
 ""StringVar"",
 ""TimestampVar"",
 ""AQ"",
- ""Rowid""
+ ""Rowid"",
+ ""Subscription""
 ]
 clientVersion = cx_Oracle.clientversion()
 if clientVersion[:2] >= (12, 1):
",96,2
Eliminate compiler warnings on 32-bit Windows.," static int Cursor_SetBindVariables(udt_Cursor *self, PyObject *parameters,
 deferTypeAssignment) < 0)
 return -1;
 if (newVar) {
- if (i < PyList_GET_SIZE(self->bindVariables)) {
+ if (i < (uint32_t) PyList_GET_SIZE(self->bindVariables)) {
 if (PyList_SetItem(self->bindVariables, i,
 (PyObject*) newVar) < 0) {
 Py_DECREF(newVar);
",1517,364
Use the correct designation for the external handle parameter.," static int Connection_Init(udt_Connection *self, PyObject *args,
 if (dpiContext_initConnCreateParams(g_DpiContext, &dpiCreateParams) < 0)
 return Error_RaiseAndReturnInt();
 if (!PyArg_ParseTupleAndKeywords(args, keywordArgs,
- ""|OOOikO!OOOiOssOOOOOO"", keywordList, &usernameObj, &passwordObj,
+ ""|OOOiKO!OOOiOssOOOOOO"", keywordList, &usernameObj, &passwordObj,
 &dsnObj, &dpiCreateParams.authMode, &externalHandle,
 &g_SessionPoolType, &pool, &threadedObj, &eventsObj, &cclassObj,
 &dpiCreateParams.purity, &newPasswordObj,
",1156,225
Preparing to release 6.1.," except:
 from distutils.extension import Extension
 
 # define build constants
-BUILD_VERSION = ""6.1.0-dev""
+BUILD_VERSION = ""6.1""
 
 # setup extra link and compile args
 extraLinkArgs = []
",97,3
"Remove unnecessary type checks since PyFloat_AsDouble() will convert the value
to floating point if possible anyway, and if not, will raise an appropriate
exception."," static int NumberVar_SetValueDecimal(udt_Variable *var, uint32_t pos,
 static int NumberVar_SetValueFloat(udt_Variable *var, uint32_t pos,
 dpiData *data, PyObject *value)
 {
- if (!PyFloat_Check(value) &&
-#if PY_MAJOR_VERSION < 3
- !PyInt_Check(value) &&
-#endif
- !PyLong_Check(value)) {
- PyErr_SetString(PyExc_TypeError, ""expecting float"");
- return -1;
- }
 data->value.asDouble = PyFloat_AsDouble(value);
 if (PyErr_Occurred())
 return -1;
",164,19
Revert last change (restriction is deliberate).," static int NumberVar_SetValueDecimal(udt_Variable *var, uint32_t pos,
 static int NumberVar_SetValueFloat(udt_Variable *var, uint32_t pos,
 dpiData *data, PyObject *value)
 {
+ if (!PyFloat_Check(value) &&
+#if PY_MAJOR_VERSION < 3
+ !PyInt_Check(value) &&
+#endif
+ !PyLong_Check(value)) {
+ PyErr_SetString(PyExc_TypeError, ""expecting float"");
+ return -1;
+ }
 data->value.asDouble = PyFloat_AsDouble(value);
 if (PyErr_Occurred())
 return -1;
",170,23
Correct support in Python 3.x for cursor.parse().," except:
 from distutils.extension import Extension
 
 # define build constants
-BUILD_VERSION = ""6.1""
+BUILD_VERSION = ""6.2-dev""
 
 # setup extra link and compile args
 extraLinkArgs = []
",97,3
Additional test cases to improve code coverage.," class TestConnection(TestCase):
 for thread in threads:
 thread.join()
 
+ def testStringFormat(self):
+ ""test string format of connection""
+ connection = cx_Oracle.connect(self.username, self.password,
+ self.tnsentry)
+ expectedValue = ""<cx_Oracle.Connection to %s@%s>"" % \
+ (self.username, self.tnsentry)
+ self.assertEqual(str(connection), expectedValue)
+
",205,23
The attribute connection.dbop is only valid with Oracle 12.1 and higher.," class TestConnection(TestCase):
 def testAttributes(self):
 ""test connection end-to-end tracing attributes""
 connection = cx_Oracle.connect(USERNAME, PASSWORD, TNSENTRY)
- self.__VerifyAttributes(connection, ""dbop"", ""cx_OracleTest_DBOP"",
- ""select dbop_name from v$sql_monitor ""
- ""where sid = sys_context('userenv', 'sid')"")
+ if CLIENT_VERSION >= (12, 1):
+ self.__VerifyAttributes(connection, ""dbop"", ""cx_OracleTest_DBOP"",
+ ""select dbop_name from v$sql_monitor ""
+ ""where sid = sys_context('userenv', 'sid')"")
 self.__VerifyAttributes(connection, ""action"", ""cx_OracleTest_Action"",
 ""select sys_context('userenv', 'action') from dual"")
 self.__VerifyAttributes(connection, ""module"", ""cx_OracleTest_Module"",
",206,24
"Update ODPI-C; remove error ""DPI-1054: connection cannot be closed when open
statements or LOBs exist""
(https://github.com/oracle/python-cx_Oracle/issues/138)."," extension = Extension(
 ""odpi/src/dpiDeqOptions.c"", ""odpi/src/dpiEnqOptions.c"",
 ""odpi/src/dpiEnv.c"", ""odpi/src/dpiError.c"",
 ""odpi/src/dpiGen.c"", ""odpi/src/dpiGlobal.c"",
- ""odpi/src/dpiHandlePool.c"", ""odpi/src/dpiLob.c"",
- ""odpi/src/dpiMsgProps.c"", ""odpi/src/dpiObject.c"",
- ""odpi/src/dpiObjectAttr.c"", ""odpi/src/dpiObjectType.c"",
- ""odpi/src/dpiOci.c"", ""odpi/src/dpiOracleType.c"",
- ""odpi/src/dpiPool.c"", ""odpi/src/dpiRowid.c"",
- ""odpi/src/dpiStmt.c"", ""odpi/src/dpiSubscr.c"",
- ""odpi/src/dpiUtils.c"", ""odpi/src/dpiVar.c""])
+ ""odpi/src/dpiHandleList.c"", ""odpi/src/dpiHandlePool.c"",
+ ""odpi/src/dpiLob.c"", ""odpi/src/dpiMsgProps.c"",
+ ""odpi/src/dpiObject.c"", ""odpi/src/dpiObjectAttr.c"",
+ ""odpi/src/dpiObjectType.c"", ""odpi/src/dpiOci.c"",
+ ""odpi/src/dpiOracleType.c"", ""odpi/src/dpiPool.c"",
+ ""odpi/src/dpiRowid.c"", ""odpi/src/dpiStmt.c"",
+ ""odpi/src/dpiSubscr.c"", ""odpi/src/dpiUtils.c"",
+ ""odpi/src/dpiVar.c""])
 
 # perform the setup
 setup(
",98,3
Added test cases for AQ visibility and delivery modes.," else:
 
 class BaseTestCase(unittest.TestCase):
 
- def setUp(self):
+ def getConnection(self, **kwargs):
 import cx_Oracle
 import TestEnv
- self.connection = cx_Oracle.Connection(TestEnv.MAIN_USER,
- TestEnv.MAIN_PASSWORD, TestEnv.CONNECT_STRING,
- encoding = TestEnv.ENCODING, nencoding = TestEnv.NENCODING)
+ return cx_Oracle.Connection(TestEnv.MAIN_USER, TestEnv.MAIN_PASSWORD,
+ TestEnv.CONNECT_STRING, encoding = TestEnv.ENCODING,
+ nencoding = TestEnv.NENCODING, **kwargs)
+
+ def setUp(self):
+ import TestEnv
+ self.connection = self.getConnection()
 self.cursor = self.connection.cursor()
 self.cursor.arraysize = TestEnv.ARRAY_SIZE
 
",100,3
"Correct handling of Oracle objects after consolidation of transformations
to/from Python objects."," static PyObject *cxoObjectType_newObject(cxoObjectType *objType,
 return cxoError_raiseAndReturnNull();
 
 // create the object
- obj = (cxoObject*) cxoObject_new(objType, handle, 0);
- if (!obj)
+ obj = (cxoObject*) cxoObject_new(objType, handle);
+ if (!obj) {
+ dpiObject_release(handle);
 return NULL;
+ }
 
 // populate collection, if applicable
 if (initialValue) {
",210,30
Restore support for binding a date value to datetime variable.," class TestDateTimeVar(BaseTestCase):
 value = datetime.datetime(2002, 12, 13, 9, 36, 0))
 self.assertEqual(self.cursor.fetchall(), [self.dataByKey[4]])
 
+ def testBindDateInDateTimeVar(self):
+ ""test binding date in a datetime variable""
+ var = self.cursor.var(cx_Oracle.DATETIME)
+ dateVal = datetime.date.today()
+ var.setvalue(0, dateVal)
+ self.assertEqual(var.getvalue().date(), dateVal)
+
 def testBindDateAfterString(self):
 ""test binding in a date after setting input sizes to a string""
 self.cursor.setinputsizes(value = 15)
",214,25
"Eliminate reference leak with LOB values acquired from attributes of objects or
elements of collections."," PyObject *cxoLob_new(cxoConnection *connection, dpiOracleTypeNum oracleTypeNum,
 lob = (cxoLob*) cxoPyTypeLob.tp_alloc(&cxoPyTypeLob, 0);
 if (!lob)
 return NULL;
- if (dpiLob_addRef(handle) < 0) {
- Py_DECREF(lob);
- return NULL;
- }
 lob->handle = handle;
 lob->oracleTypeNum = oracleTypeNum;
 Py_INCREF(connection);
",321,51
Added test cases for recent ODPI-C bug fixes.," class TestNumberVar(BaseTestCase):
 self.assertEqual(result, 148)
 self.assertTrue(isinstance(result, int), ""integer not returned"")
 
+ def testBoundaryNumbers(self):
+ ""test that boundary numbers are handled properly""
+ inValues = [float('inf'), 0.0, float('-inf'), 1e126, -1e126]
+ outValues = [10**126, 0, -10**126, 10**126, -10**126]
+ for inValue, outValue in zip(inValues, outValues):
+ self.cursor.execute(""select :1 from dual"", (inValue,))
+ result, = self.cursor.fetchone()
+ self.assertEqual(result, outValue)
+
 def testReturnFloatFromDivision(self):
 ""test that fetching the result of division returns a float""
 self.cursor.execute(""""""
",303,41
Correct binding of LOB values.," int cxoTransform_fromPython(cxoTransformNum transformNum, PyObject *pyValue,
 case CXO_TRANSFORM_NCLOB:
 if (Py_TYPE(pyValue) == &cxoPyTypeLob) {
 lob = (cxoLob*) pyValue;
- dbValue->asLOB = lob->handle;
+ if (var) {
+ if (dpiVar_setFromLob(var->handle, arrayPos,
+ lob->handle) < 0)
+ return cxoError_raiseAndReturnInt();
+ } else dbValue->asLOB = lob->handle;
 return 0;
 }
 if (transformNum == CXO_TRANSFORM_NCLOB)
",635,182
Import print_function for Python 2 compatibility.,"
 #------------------------------------------------------------------------------
 
 #------------------------------------------------------------------------------
-# Copyright 2017, Oracle and/or its affiliates. All rights reserved.
+# Copyright 2017, 2018, Oracle and/or its affiliates. All rights reserved.
 #------------------------------------------------------------------------------
 
+from __future__ import print_function
+
 import cx_Oracle
 
 con = cx_Oracle.connect(""pythonhol"", ""welcome"", ""localhost/orclpdb"")
",23,2
"Ensure that the number of elements in the array is not lost when the buffer
size is increased to accommodate larger strings."," class TestStringVar(BaseTestCase):
 self.rawData.append(dataTuple)
 self.dataByKey[i] = dataTuple
 
+ def testArrayWithIncreasedSize(self):
+ ""test creating an array var and then increasing the internal size""
+ val = [""12345678901234567890""] * 3
+ arrayVar = self.cursor.arrayvar(str, len(val), 4)
+ arrayVar.setvalue(0, val)
+ self.assertEqual(arrayVar.getvalue(), val)
+
 def testBindString(self):
 ""test binding in a string""
 self.cursor.execute(""""""
",349,45
Add additional test cases.," class TestAQ(BaseTestCase):
 self.__verifyAttribute(props, ""expiration"", 30)
 self.assertEqual(props.attempts, 0)
 self.__verifyAttribute(props, ""priority"", 1)
+ self.__verifyAttribute(props, ""msgid"", b'mID')
 self.assertEqual(props.state, cx_Oracle.MSG_READY)
+ self.assertEqual(props.deliverymode, 0)
 
 def testVisibilityModeCommit(self):
 ""test enqueue visibility option - ENQ_ON_COMMIT""
",263,19
"Added support for closing the connection when reaching the end of a code block
controlled by the connection as a context manager, but in a backwards
compatible way (https://github.com/oracle/python-cx_Oracle/issues/113)."," static PyObject *cxoConnection_contextManagerExit(cxoConnection *conn,
 PyObject* args)
 {
 PyObject *excType, *excValue, *excTraceback, *result;
- char *methodName;
 
 if (!PyArg_ParseTuple(args, ""OOO"", &excType, &excValue, &excTraceback))
 return NULL;
- if (excType == Py_None && excValue == Py_None && excTraceback == Py_None)
- methodName = ""commit"";
- else methodName = ""rollback"";
- result = PyObject_CallMethod((PyObject*) conn, methodName, """");
+ if (cxoFutureObj && cxoFutureObj->contextManagerClose)
+ result = cxoConnection_close(conn, NULL);
+ else if (excType == Py_None && excValue == Py_None &&
+ excTraceback == Py_None)
+ result = cxoConnection_commit(conn, NULL);
+ else result = cxoConnection_rollback(conn, NULL);
 if (!result)
 return NULL;
 Py_DECREF(result);
",1108,211
Eliminate memory leak when extending a collection.," int cxoObject_internalExtend(cxoObject *obj, PyObject *sequence)
 PyObject *fastSequence, *element;
 Py_ssize_t size, i;
 
- // append each of the items in the sequence to the collection
 fastSequence = PySequence_Fast(sequence, ""expecting sequence"");
 if (!fastSequence)
 return -1;
 size = PySequence_Fast_GET_SIZE(fastSequence);
 for (i = 0; i < size; i++) {
 element = PySequence_Fast_GET_ITEM(fastSequence, i);
- if (cxoObject_internalAppend(obj, element) < 0)
+ if (cxoObject_internalAppend(obj, element) < 0) {
+ Py_DECREF(fastSequence);
 return -1;
+ }
 }
+ Py_DECREF(fastSequence);
 
 return 0;
 }
",407,77
"Ensure that error ORA-24816: Expanded non LONG bind data supplied after actual
LONG or LOB column"" is not raised by ensuring an empty string does not use a
size of zero (which triggers this situation in Oracle 12.1)."," cxoVarType *cxoVarType_fromPythonType(PyTypeObject *type)
 static Py_ssize_t cxoVarType_calculateSize(PyObject *value,
 cxoTransformNum transformNum)
 {
+ Py_ssize_t size = 0;
 #if PY_MAJOR_VERSION < 3
 const void *ptr;
- Py_ssize_t size = 0;
 #endif
 
 switch (transformNum) {
 static Py_ssize_t cxoVarType_calculateSize(PyObject *value,
 return size;
 #endif
 case CXO_TRANSFORM_NSTRING:
- return PyUnicode_GET_SIZE(value);
+ size = PyUnicode_GET_SIZE(value);
+ return (size == 0) ? 1 : size;
 case CXO_TRANSFORM_STRING:
 #if PY_MAJOR_VERSION >= 3
- return PyUnicode_GET_SIZE(value);
+ size = PyUnicode_GET_SIZE(value);
 #else
- return PyString_GET_SIZE(value);
+ size = PyString_GET_SIZE(value);
 #endif
+ return (size == 0) ? 1 : size;
 default:
 break;
 }
",241,22
Preparing to release cx_Oracle 6.2.," except:
 from distutils.extension import Extension
 
 # define build constants
-BUILD_VERSION = ""6.2-dev""
+BUILD_VERSION = ""6.2""
 
 # setup extra link and compile args
 extraLinkArgs = []
",86,3
Preparing to release cx_Oracle 6.2.1.," except:
 from distutils.extension import Extension
 
 # define build constants
-BUILD_VERSION = ""6.2""
+BUILD_VERSION = ""6.2.1""
 
 # setup extra link and compile args
 extraLinkArgs = []
",86,3
Bump version to 6.3-dev in anticipation of new features landing.," except:
 from distutils.extension import Extension
 
 # define build constants
-BUILD_VERSION = ""6.2.1""
+BUILD_VERSION = ""6.3-dev""
 
 # setup extra link and compile args
 extraLinkArgs = []
",86,3
"There is no need to set the fetch array size for statements that are not
queries."," static int cxoCursor_internalPrepare(cxoCursor *cursor, PyObject *statement,
 if (dpiStmt_getInfo(cursor->handle, &cursor->stmtInfo) < 0)
 return cxoError_raiseAndReturnInt();
 
- // set the fetch array size
- if (dpiStmt_setFetchArraySize(cursor->handle, cursor->arraySize) < 0)
- return cxoError_raiseAndReturnInt();
+ // set the fetch array size, if applicable
+ if (cursor->stmtInfo.statementType == DPI_STMT_TYPE_SELECT) {
+ if (dpiStmt_setFetchArraySize(cursor->handle, cursor->arraySize) < 0)
+ return cxoError_raiseAndReturnInt();
+ }
 
 // clear row factory, if applicable
 Py_CLEAR(cursor->rowFactory);
",1478,360
Add support for binding integers and floats as cx_Oracle.NATIVE_FLOAT.," int cxoTransform_fromPython(cxoTransformNum transformNum, PyObject *pyValue,
 dbValue->asBytes.length = buffer->size;
 return 0;
 case CXO_TRANSFORM_FLOAT:
+ case CXO_TRANSFORM_NATIVE_DOUBLE:
+ case CXO_TRANSFORM_NATIVE_FLOAT:
 if (!PyFloat_Check(pyValue) &&
 #if PY_MAJOR_VERSION < 3
 !PyInt_Check(pyValue) &&
 int cxoTransform_fromPython(cxoTransformNum transformNum, PyObject *pyValue,
 PyErr_SetString(PyExc_TypeError, ""expecting float"");
 return -1;
 }
- dbValue->asDouble = PyFloat_AsDouble(pyValue);
+ if (transformNum == CXO_TRANSFORM_NATIVE_FLOAT)
+ dbValue->asFloat = (float) PyFloat_AsDouble(pyValue);
+ else dbValue->asDouble = PyFloat_AsDouble(pyValue);
 if (PyErr_Occurred())
 return -1;
 return 0;
",639,185
"Add test demonstrating that binding of long data using cursor.executemany()
works as expected."," class TestLongVar(BaseTestCase):
 ""test binding and fetching long data""
 self.__PerformTest(""Long"", cx_Oracle.LONG_STRING)
 
+ def testLongWithExecuteMany(self):
+ ""test binding long data with executemany()""
+ data = []
+ self.cursor.execute(""truncate table TestLongs"")
+ for i in range(5):
+ char = chr(ord('A') + i)
+ longStr = char * (32768 * (i + 1))
+ data.append((i + 1, longStr))
+ self.cursor.executemany(""insert into TestLongs values (:1, :2)"", data)
+ self.connection.commit()
+ self.cursor.execute(""select * from TestLongs order by IntCol"")
+ fetchedData = self.cursor.fetchall()
+ self.assertEqual(fetchedData, data)
+
 def testLongRaws(self):
 ""test binding and fetching long raw data""
 self.__PerformTest(""LongRaw"", cx_Oracle.LONG_BINARY)
",81,15
"Ensure that a reasonable error message can be provided when an unsupported
Oracle type is encountered."," static int cxoObjectAttr_initialize(cxoObjectAttr *attr,
 if (dpiObjectAttr_getInfo(attr->handle, &info) < 0)
 return cxoError_raiseAndReturnInt();
 attr->transformNum = cxoTransform_getNumFromDataTypeInfo(&info.typeInfo);
+ attr->oracleTypeNum = info.typeInfo.oracleTypeNum;
 attr->name = cxoPyString_fromEncodedString(info.name, info.nameLength,
 connection->encodingInfo.encoding);
 if (!attr->name)
",108,12
"Ensure that round trip is performed without holding the Python GIL
(https://github.com/oracle/python-cx_Oracle/issues/158)."," static PyObject *cxoConnection_getVersion(cxoConnection *conn, void *unused)
 dpiVersionInfo versionInfo;
 const char *releaseString;
 char buffer[25];
+ int status;
 
- if (dpiConn_getServerVersion(conn->handle, &releaseString,
- &releaseStringLength, &versionInfo) < 0)
+ Py_BEGIN_ALLOW_THREADS
+ status = dpiConn_getServerVersion(conn->handle, &releaseString,
+ &releaseStringLength, &versionInfo);
+ Py_END_ALLOW_THREADS
+ if (status < 0)
 return cxoError_raiseAndReturnNull();
 snprintf(buffer, sizeof(buffer), ""%d.%d.%d.%d.%d"", versionInfo.versionNum,
 versionInfo.releaseNum, versionInfo.updateNum,
",1112,211
Added support for DML returning of multiple rows using cursor.executemany().," static PyObject *cxoFuture_getAttr(cxoFuture *obj, PyObject *nameObject)
 return NULL;
 if (strncmp(buffer.ptr, ""ctx_mgr_close"", buffer.size) == 0)
 result = PyBool_FromLong(obj->contextManagerClose);
+ else if (strncmp(buffer.ptr, ""dml_ret_array_val"", buffer.size) == 0)
+ result = PyBool_FromLong(obj->dmlReturningArray);
 else {
 Py_INCREF(Py_None);
 result = Py_None;
 static int cxoFuture_setAttr(cxoFuture *obj, PyObject *nameObject,
 return -1;
 if (strncmp(buffer.ptr, ""ctx_mgr_close"", buffer.size) == 0)
 result = cxoUtils_getBooleanValue(value, 0, &obj->contextManagerClose);
+ else if (strncmp(buffer.ptr, ""dml_ret_array_val"", buffer.size) == 0)
+ result = cxoUtils_getBooleanValue(value, 0, &obj->dmlReturningArray);
 cxoBuffer_clear(&buffer);
 return result;
 }
",62,9
"Check validity of year for Python 2.x since it doesn't do that itself like
Python 3.x does (https://github.com/oracle/python-cx_Oracle/issues/166)."," PyObject *cxoTransform_toPython(cxoTransformNum transformNum,
 case CXO_TRANSFORM_TIMESTAMP:
 case CXO_TRANSFORM_TIMESTAMP_LTZ:
 timestamp = &dbValue->asTimestamp;
+#if PY_MAJOR_VERSION < 3
+ if (timestamp->year < 1 || timestamp->year > 9999)
+ return PyErr_Format(PyExc_ValueError,
+ ""year %d is out of range"", timestamp->year);
+#endif
 return PyDateTime_FromDateAndTime(timestamp->year,
 timestamp->month, timestamp->day, timestamp->hour,
 timestamp->minute, timestamp->second,
",642,188
"Use a cx_Oracle._Error object (not a string) for all cx_Oracle exception types,
as suggested (https://github.com/oracle/python-cx_Oracle/issues/51)."," static int cxoConnectionParams_finalize(cxoConnectionParams *params)
 int cxoConnection_isConnected(cxoConnection *conn)
 {
 if (!conn->handle) {
- PyErr_SetString(cxoInterfaceErrorException, ""not connected"");
+ cxoError_raiseFromString(cxoInterfaceErrorException, ""not connected"");
 return -1;
 }
 return 0;
",1112,211
"Ensure that decreasing number of rows returned from a DML returning statement
is detected properly."," class TestDMLReturning(BaseTestCase):
 cx_Oracle.__future__.dml_ret_array_val = False
 self.connection.rollback()
 
+ def testDeleteReturningDecreasingRowsReturned(self):
+ ""test delete returning multiple times with decreasing number of rows""
+ data = [(i, ""Test String %d"" % i) for i in range(1, 11)]
+ self.cursor.execute(""truncate table TestTempTable"")
+ self.cursor.executemany(""insert into TestTempTable values (:1, :2)"",
+ data)
+ results = []
+ intVar = self.cursor.var(int)
+ self.cursor.setinputsizes(None, intVar)
+ for intVal in (5, 8, 10):
+ self.cursor.execute(""""""
+ delete from TestTempTable
+ where IntCol < :1
+ returning IntCol into :2"""""", [intVal])
+ results.append(intVar.values)
+ self.assertEqual(results, [ [1, 2, 3, 4], [5, 6, 7], [8, 9] ])
+
",224,22
Use default values for all parameters when creating a session pool.,"
 int cxoBuffer_fromObject(cxoBuffer *buf, PyObject *obj, const char *encoding)
 {
 cxoBuffer_init(buf);
- if (!obj)
+ if (!obj || obj == Py_None)
 return 0;
 if (PyUnicode_Check(obj)) {
 buf->obj = PyUnicode_AsEncodedString(obj, encoding, NULL);
",42,12
"Modified the HoL for Collaborate (#169)

Modified samples and instructions to import common connection information from db_config.py or db_config.sql in order to make setup a bit more generic.","
 from __future__ import print_function
 
 import cx_Oracle
+import db_config
 
-con = cx_Oracle.connect(""pythonhol"", ""welcome"", ""localhost/orclpdb"")
+con = cx_Oracle.connect(db_config.user, db_config.pw, db_config.dsn)
 cur = con.cursor()
 
 print(""Inserting data..."")
",24,2
"Modified the solutions of the HoL for Collaborate (#170)

added db_config and made changes to solutions to use db_config values","
 from __future__ import print_function
 
 import cx_Oracle
+import db_config
 
-con = cx_Oracle.connect(""pythonhol"", ""welcome"", ""localhost/orclpdb"")
+con = cx_Oracle.connect(db_config.user, db_config.pw, db_config.dsn)
 cur = con.cursor()
 
 # Create table
",57,6
Preparing to release cx_Oracle 6.3.," except:
 from distutils.extension import Extension
 
 # define build constants
-BUILD_VERSION = ""6.3-dev""
+BUILD_VERSION = ""6.3""
 
 # setup extra link and compile args
 extraLinkArgs = []
",101,3
Add a more explicit note about the dependency on GeoPandas.,"
 # is being used to combine and work with geospatial data from numerous
 # additional sources such as files and web services.
 #
-# This script requires cx_Oracle 5.3 and higher.
+# This script requires cx_Oracle (5.3 and higher) as well as GeoPandas and its
+# dependencies (see http://geopandas.org/install.html).
 #------------------------------------------------------------------------------
 
 from __future__ import print_function
",124,3
"Ensure that the behavior in cx_Oracle 6.3 with __future__.dml_ret_array_val not
set or False is the same as the behavior in cx_Oracle 6.2
(https://github.com/oracle/python-cx_Oracle/issues/176)."," PyObject *cxoVar_getSingleValue(cxoVar *var, dpiData *data, uint32_t arrayPos)
 if (dpiVar_getReturnedData(var->handle, 0, &numReturnedRows,
 &data) < 0)
 return cxoError_raiseAndReturnNull();
- if (arrayPos >= numReturnedRows) {
+ if (arrayPos >= var->allocatedElements &&
+ arrayPos >= numReturnedRows) {
 PyErr_SetString(PyExc_IndexError,
 ""cxoVar_getSingleValue: array size exceeded"");
 return NULL;
 }
+ if (arrayPos >= numReturnedRows)
+ data = var->data;
 }
 
 // in all other cases, just get the value stored at specified position
 PyObject *cxoVar_getValue(cxoVar *var, uint32_t arrayPos)
 return cxoError_raiseAndReturnNull();
 return cxoVar_getArrayValue(var, numElements, var->data);
 }
- if (arrayPos >= var->allocatedElements) {
+ if (arrayPos >= var->allocatedElements && !var->getReturnedData) {
 PyErr_SetString(PyExc_IndexError,
 ""cxoVar_getSingleValue: array size exceeded"");
 return NULL;
",547,147
"Include transaction id in information printed to stdout, just like for query
change notification."," def callback(message):
 registered = False
 return
 print(""Message database name:"", message.dbname)
+ print(""Message tranasction id:"", message.txid)
 print(""Message tables:"")
 for table in message.tables:
 print(""--> Table Name:"", table.name)
",41,5
Added test cases for AQ transformations and trimming collections.," class TestObjectVar(BaseTestCase):
 self.assertEqual(str(objType.attributes[0]),
 ""<cx_Oracle.ObjectAttribute NUMBERVALUE>"")
 
+ def testTrimCollectionList(self):
+ ""test Trim number of elements from collection""
+ subObjType = self.connection.gettype(""UDT_SUBOBJECT"")
+ arrayType = self.connection.gettype(""UDT_OBJECTARRAY"")
+ data = [(1, ""AB""), (2, ""CDE""), (3, ""FGH""), (4, ""IJK"")]
+ arrayObj = arrayType()
+ for numVal, strVal in data:
+ subObj = subObjType()
+ subObj.SUBNUMBERVALUE = numVal
+ subObj.SUBSTRINGVALUE = strVal
+ arrayObj.append(subObj)
+ self.assertEqual(self.__GetObjectAsTuple(arrayObj), data)
+ arrayObj.trim(2)
+ self.assertEqual(self.__GetObjectAsTuple(arrayObj), data[:2])
+ arrayObj.trim(1)
+ self.assertEqual(self.__GetObjectAsTuple(arrayObj), data[:1])
+ arrayObj.trim(0)
+ self.assertEqual(self.__GetObjectAsTuple(arrayObj), data[:1])
+ arrayObj.trim(1)
+ self.assertEqual(self.__GetObjectAsTuple(arrayObj), [])
+
",297,27
"Added additional test cases and corrected test case for ltxid when
using 11.2 client."," class TestCursor(BaseTestCase):
 self.assertEqual(self.cursor.description,
 [ ('LONGINTCOL', cx_Oracle.NUMBER, 17, None, 16, 0, 0) ])
 
+ def testSetOutputSize(self):
+ ""test cursor.setoutputsize() does not fail (but does nothing)""
+ self.cursor.setoutputsize(100, 2)
+
 def testVarNegative(self):
 ""test cursor.var() with invalid parameters""
 self.assertRaises(TypeError, self.cursor.var, 5)
",452,61
Added support for grouping notifications from subscriptions.," static PyObject *cxoModule_initialize(void)
 CXO_ADD_INT_CONSTANT(""SUBSCR_NAMESPACE_DBCHANGE"",
 DPI_SUBSCR_NAMESPACE_DBCHANGE)
 
+ // add constants for subscription grouping classes
+ CXO_ADD_INT_CONSTANT(""SUBSCR_GROUPING_CLASS_TIME"",
+ DPI_SUBSCR_GROUPING_CLASS_TIME)
+
+ // add constants for subscription grouping types
+ CXO_ADD_INT_CONSTANT(""SUBSCR_GROUPING_TYPE_SUMMARY"",
+ DPI_SUBSCR_GROUPING_TYPE_SUMMARY)
+ CXO_ADD_INT_CONSTANT(""SUBSCR_GROUPING_TYPE_LAST"",
+ DPI_SUBSCR_GROUPING_TYPE_LAST)
+
 // add constants for event types
 CXO_ADD_INT_CONSTANT(""EVENT_NONE"", DPI_EVENT_NONE)
 CXO_ADD_INT_CONSTANT(""EVENT_STARTUP"", DPI_EVENT_STARTUP)
",342,43
"Added support for timed waits when acquiring a session from a session pool and
added support for specifying the timeout and maximum lifetime session of
sessions in the pool when the pool is being created."," static PyObject *cxoModule_initialize(void)
 CXO_ADD_INT_CONSTANT(""SPOOL_ATTRVAL_WAIT"", DPI_MODE_POOL_GET_WAIT)
 CXO_ADD_INT_CONSTANT(""SPOOL_ATTRVAL_NOWAIT"", DPI_MODE_POOL_GET_NOWAIT)
 CXO_ADD_INT_CONSTANT(""SPOOL_ATTRVAL_FORCEGET"", DPI_MODE_POOL_GET_FORCEGET)
+ CXO_ADD_INT_CONSTANT(""SPOOL_ATTRVAL_TIMEDWAIT"",
+ DPI_MODE_POOL_GET_TIMEDWAIT)
 
 // add constants for database shutdown modes
 CXO_ADD_INT_CONSTANT(""DBSHUTDOWN_ABORT"", DPI_MODE_SHUTDOWN_ABORT)
",344,43
"Adjust data values to clarify distinction between ""parent"" and ""child"" values.","
 #------------------------------------------------------------------------------
-# Copyright 2016, 2017, Oracle and/or its affiliates. All rights reserved.
+# Copyright 2016, 2018, Oracle and/or its affiliates. All rights reserved.
 #------------------------------------------------------------------------------
 
 #------------------------------------------------------------------------------
 connection = Connection()
 cursor = connection.cursor()
 
 # demonstrate that the subclassed connection and cursor are being used
-cursor.execute(""select count(*) from ChildTable where ParentId = :1"", (3,))
+cursor.execute(""select count(*) from ChildTable where ParentId = :1"", (30,))
 count, = cursor.fetchone()
 print(""COUNT:"", int(count))
 
",25,5
"Ensure that binding a boolean value outside of PL/SQL simply binds the integer
0 or 1 (https://github.com/oracle/python-cx_Oracle/issues/181)."," static int cxoConnectionParams_processShardingKeyValue(
 {
 cxoTransformNum transformNum;
 
- transformNum = cxoTransform_getNumFromValue(value);
+ transformNum = cxoTransform_getNumFromValue(value, 0);
 if (cxoTransform_fromPython(transformNum, value, &column->value, buffer,
 params->encoding, params->nencoding, NULL, 0) < 0)
 return -1;
",1119,211
"Added support for binding decimal.Decimal values to cx_Oracle.NATIVE_FLOAT as
requested in issue 184
(https://github.com/oracle/python-cx_Oracle/issues/184)."," int cxoTransform_fromPython(cxoTransformNum transformNum, PyObject *pyValue,
 dbValue->asBytes.length = buffer->size;
 return 0;
 case CXO_TRANSFORM_FLOAT:
+ if (!PyFloat_Check(pyValue) &&
+#if PY_MAJOR_VERSION < 3
+ !PyInt_Check(pyValue) &&
+#endif
+ !PyLong_Check(pyValue)) {
+ PyErr_SetString(PyExc_TypeError, ""expecting float"");
+ return -1;
+ }
+ dbValue->asDouble = PyFloat_AsDouble(pyValue);
+ if (PyErr_Occurred())
+ return -1;
+ return 0;
 case CXO_TRANSFORM_NATIVE_DOUBLE:
 case CXO_TRANSFORM_NATIVE_FLOAT:
 if (!PyFloat_Check(pyValue) &&
 #if PY_MAJOR_VERSION < 3
 !PyInt_Check(pyValue) &&
 #endif
+ !PyObject_TypeCheck(pyValue, cxoPyTypeDecimal) &&
 !PyLong_Check(pyValue)) {
 PyErr_SetString(PyExc_TypeError, ""expecting float"");
 return -1;
",652,195
"Added support for receiving notifications when AQ messages are available to be
dequeued."," static PyObject *cxoModule_initialize(void)
 CXO_ADD_INT_CONSTANT(""SUBSCR_QOS_BEST_EFFORT"", DPI_SUBSCR_QOS_BEST_EFFORT)
 
 // add constants for subscription namespaces
+ CXO_ADD_INT_CONSTANT(""SUBSCR_NAMESPACE_AQ"", DPI_SUBSCR_NAMESPACE_AQ)
 CXO_ADD_INT_CONSTANT(""SUBSCR_NAMESPACE_DBCHANGE"",
 DPI_SUBSCR_NAMESPACE_DBCHANGE)
 
 static PyObject *cxoModule_initialize(void)
 CXO_ADD_INT_CONSTANT(""EVENT_DEREG"", DPI_EVENT_DEREG)
 CXO_ADD_INT_CONSTANT(""EVENT_OBJCHANGE"", DPI_EVENT_OBJCHANGE)
 CXO_ADD_INT_CONSTANT(""EVENT_QUERYCHANGE"", DPI_EVENT_QUERYCHANGE)
+ CXO_ADD_INT_CONSTANT(""EVENT_AQ"", DPI_EVENT_AQ)
 
 // add constants for opcodes
 CXO_ADD_INT_CONSTANT(""OPCODE_ALLOPS"", DPI_OPCODE_ALL_OPS)
",346,43
Correct handling of statements and rowids in DML returning statements.," class TestCursorVar(BaseTestCase):
 ""test binding in a cursor from a package""
 cursor = self.connection.cursor()
 self.assertEqual(cursor.description, None)
- self.cursor.callproc(""pkg_TestOutCursors.TestOutCursor"", (2, cursor))
+ self.cursor.callproc(""pkg_TestRefCursors.TestOutCursor"", (2, cursor))
 self.assertEqual(cursor.description,
 [ ('INTCOL', cx_Oracle.NUMBER, 10, None, 9, 0, 0),
 ('STRINGCOL', cx_Oracle.STRING, 20, 20 * CS_RATIO, None,
",70,6
"Added support for indicating if the subscription is still registered with the
database when a notification is received."," registered = True
 def callback(message):
 global registered
 print(""Message type:"", message.type)
- if message.type == cx_Oracle.EVENT_DEREG:
+ if not message.registered:
 print(""Deregistration has taken place..."")
 registered = False
 return
",45,6
Use unsigned integers instead of signed integers where it makes sense to do so.," static PyObject *cxoConnection_subscribe(cxoConnection *conn, PyObject* args,
 
 // validate parameters
 callback = name = ipAddress = NULL;
- if (!PyArg_ParseTupleAndKeywords(args, keywordArgs, ""|iiOiiiiObibO"",
+ if (!PyArg_ParseTupleAndKeywords(args, keywordArgs, ""|IIOIIIIObIbO"",
 keywordList, &params.subscrNamespace, &params.protocol, &callback,
 &params.timeout, &params.operations, &params.portNumber,
 &params.qos, &ipAddress, &params.groupingClass,
",1169,219
"Use the non-deprecated function for subscribing to events in the database and
note that the subscription ID will always be zero and will be removed in
cx_Oracle 7."," static PyObject *cxoConnection_subscribe(cxoConnection *conn, PyObject* args,
 }
 
 // create ODPI-C subscription
- if (dpiConn_newSubscription(conn->handle, &params, &subscr->handle,
- &subscr->id) < 0) {
+ if (dpiConn_subscribe(conn->handle, &params, &subscr->handle) < 0) {
 cxoError_raiseAndReturnNull();
 cxoBuffer_clear(&ipAddressBuffer);
 cxoBuffer_clear(&nameBuffer);
",1168,219
Added additional test cases for heterogeneous pools.," for name in moduleNames:
 setattr(module, ""USERNAME"", TestEnv.MAIN_USER)
 setattr(module, ""PASSWORD"", TestEnv.MAIN_PASSWORD)
 setattr(module, ""PROXY_USERNAME"", TestEnv.PROXY_USER)
+ setattr(module, ""PROXY_PASSWORD"", TestEnv.PROXY_PASSWORD)
 setattr(module, ""TNSENTRY"", TestEnv.CONNECT_STRING)
 setattr(module, ""ENCODING"", TestEnv.ENCODING)
 setattr(module, ""NENCODING"", TestEnv.NENCODING)
",102,3
"Add support for specifying the ""errors"" parameter to the decode() that takes
place internally when fetching strings from the database
(https://github.com/oracle/python-cx_Oracle/issues/162)."," static PyObject *cxoConnection_getAttrText(cxoConnection *conn,
 if (!value)
 Py_RETURN_NONE;
 return cxoPyString_fromEncodedString(value, valueLength,
- conn->encodingInfo.encoding);
+ conn->encodingInfo.encoding, NULL);
 }
 
 
",1191,222
"Added support for using the cursor as a context manager
(https://github.com/oracle/python-cx_Oracle/issues/190)."," class TestCursor(BaseTestCase):
 self.assertEqual(self.cursor.fetchall(),
 [ (0, ""Value should be 0""), (1, ""Value should be 1"") ])
 
+ def testAsContextManager(self):
+ ""test using a cursor as a context manager""
+ with self.cursor as cursor:
+ cursor.execute(""truncate table TestTempTable"")
+ cursor.execute(""select count(*) from TestTempTable"")
+ count, = cursor.fetchone()
+ self.assertEqual(count, 0)
+ self.assertRaises(cx_Oracle.InterfaceError, self.cursor.close)
+
",470,63
"Ensure that the row count for queries is reset to zero when the statement is
executed (https://github.com/oracle/python-cx_Oracle/issues/193)."," class TestCursor(BaseTestCase):
 self.assertEqual(count, 0)
 self.assertRaises(cx_Oracle.InterfaceError, self.cursor.close)
 
+ def testQueryRowCount(self):
+ ""test that the rowcount attribute is reset to zero on query execute""
+ sql = ""select * from dual where 1 = :s""
+ self.cursor.execute(sql, [0])
+ self.cursor.fetchone()
+ self.assertEqual(self.cursor.rowcount, 0)
+ self.cursor.execute(sql, [1])
+ self.cursor.fetchone()
+ self.assertEqual(self.cursor.rowcount, 1)
+ self.cursor.execute(sql, [1])
+ self.cursor.fetchone()
+ self.assertEqual(self.cursor.rowcount, 1)
+ self.cursor.execute(sql, [0])
+ self.cursor.fetchone()
+ self.assertEqual(self.cursor.rowcount, 0)
+
",485,64
"If cursor.setinputsizes() is called without any parameters, do not set the flag
indicating that bind variables should be returned since otherwise binding with
named arguments will raise the error ""cx_Oracle.ProgrammingError: positional
and named binds cannot be intermixed""
(https://github.com/oracle/python-cx_Oracle/issues/199)."," static PyObject *cxoCursor_setInputSizes(cxoCursor *cursor, PyObject *args,
 else cursor->bindVariables = PyList_New(numPositionalArgs);
 if (!cursor->bindVariables)
 return NULL;
- cursor->setInputSizes = 1;
+
+ // retain bind variables if any were set
+ if (numKeywordArgs > 0 || numPositionalArgs > 0)
+ cursor->setInputSizes = 1;
 
 // process each input
 if (numKeywordArgs > 0) {
",1485,363
Preparing to release cx_Oracle 6.4.1.," except:
 from distutils.extension import Extension
 
 # define build constants
-BUILD_VERSION = ""6.4""
+BUILD_VERSION = ""6.4.1""
 
 # setup extra link and compile args
 extraLinkArgs = []
",101,3
Bump version to 7.0 and use ODPI-C master branch (3.0).," except:
 from distutils.extension import Extension
 
 # define build constants
-BUILD_VERSION = ""6.4.1""
+BUILD_VERSION = ""7.0.0-dev""
 
 # setup extra link and compile args
 extraLinkArgs = []
",101,3
"Remove __future__ attributes for functionality which is now enabled permanently
in cx_Oracle 7: connections as context managers now close the connection and
variables in DML returning statements now return an array."," static PyObject *cxoConnection_contextManagerExit(cxoConnection *conn,
 
 if (!PyArg_ParseTuple(args, ""OOO"", &excType, &excValue, &excTraceback))
 return NULL;
- if (cxoFutureObj && cxoFutureObj->contextManagerClose)
- result = cxoConnection_close(conn, NULL);
- else if (excType == Py_None && excValue == Py_None &&
- excTraceback == Py_None)
- result = cxoConnection_commit(conn, NULL);
- else result = cxoConnection_rollback(conn, NULL);
+ result = cxoConnection_close(conn, NULL);
 if (!result)
 return NULL;
 Py_DECREF(result);
",1186,217
"Add support for getting the contents of a collection as a dictionary where the
keys are the indexes of the collection and the values are elements of the
collection."," class TestFeatures12_1(BaseTestCase):
 self.assertEqual(obj.aslist(),
 [""First element"", ""Second element"", ""Third element"",
 ""Fourth element""])
+ self.assertEqual(obj.asdict(),
+ { -1048576 : 'First element',
+ -576 : 'Second element',
+ 284 : 'Third element',
+ 8388608: 'Fourth element' })
 obj.delete(-576)
 obj.delete(284)
 self.assertEqual(obj.aslist(), [""First element"", ""Fourth element""])
+ self.assertEqual(obj.asdict(),
+ { -1048576 : 'First element',
+ 8388608: 'Fourth element' })
 
 def testExceptionInIteration(self):
 ""test executing with arraydmlrowcounts with exception""
",383,31
Add support (as preview) for SODA.," else:
 if clientVersion[:2] >= (12, 1):
 moduleNames.append(""BooleanVar"")
 moduleNames.append(""Features12_1"")
+ if clientVersion[:2] >= (18, 3):
+ moduleNames.append(""SodaDatabase"")
+ moduleNames.append(""SodaCollection"")
 
 class BaseTestCase(unittest.TestCase):
 
",105,3
Adjust copyright notices to match requirements of Oracle Legal.,"
 #------------------------------------------------------------------------------
-# Copyright 2018, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
 #------------------------------------------------------------------------------
 
 #------------------------------------------------------------------------------
",27,2
"Updates for cx_Oracle 7 and Oracle Client 18.3 as well as some miscellaneous
tweaks."," print(""Adding row to table..."")
 cur.execute(""insert into testgeometry values (1, :objbv)"", objbv = obj)
 print(""Row added!"")
 
+# (Change below here)
+
 # Define a function to dump the contents of an Oracle object
 def dumpobject(obj, prefix = "" ""):
 if obj.type.iscollection:
",57,6
Preparing to release cx_Oracle 7.0.," except:
 from distutils.extension import Extension
 
 # define build constants
-BUILD_VERSION = ""7.0.0-dev""
+BUILD_VERSION = ""7.0.0""
 
 # setup extra link and compile args
 extraLinkArgs = []
",101,3
"Use cx_Oracle.connect() in preference to cx_Oracle.Connection() in samples and
tests. Although the two are aliases of one another, it makes sense to be
consistent and to use the one that the DB API prefers as well."," def callback(message):
 print(""Queue name:"", message.queueName)
 print(""Consumer name:"", message.consumerName)
 
-connection = cx_Oracle.Connection(SampleEnv.MAIN_CONNECT_STRING, events = True)
+connection = cx_Oracle.connect(SampleEnv.MAIN_CONNECT_STRING, events = True)
 sub = connection.subscribe(namespace = cx_Oracle.SUBSCR_NAMESPACE_AQ,
 name = ""BOOKS"", callback = callback, timeout = 300)
 print(""Subscription:"", sub)
",27,2
"Allow the type name to be None, as requested
(https://github.com/oracle/python-cx_Oracle/issues/231)."," static PyObject *cxoCursor_var(cxoCursor *cursor, PyObject *args,
 return NULL;
 if (size == 0)
 size = varType->size;
- if (typeNameObj) {
+ if (typeNameObj && typeNameObj != Py_None) {
 objType = cxoObjectType_newByName(cursor->connection, typeNameObj);
 if (!objType)
 return NULL;
",1485,364
"Add support for passing an object type (such as those created by the method
connection.gettype()) as the first parameter to cursor.var(), as requested
(https://github.com/oracle/python-cx_Oracle/issues/231)."," class TestCursor(BaseTestCase):
 self.assertEqual(self.cursor.rowcount, 0)
 
 def testVarTypeNameNone(self):
+ ""test that the typename attribute can be passed a value of None""
 valueToSet = 5
 var = self.cursor.var(int, typename=None)
 var.setvalue(0, valueToSet)
 self.assertEqual(var.getvalue(), valueToSet)
 
+ def testVarTypeWithObjectType(self):
+ ""test that an object type can be used as type in cursor.var()""
+ objType = self.connection.gettype(""UDT_OBJECT"")
+ var = self.cursor.var(objType)
+ self.cursor.callproc(""pkg_TestBindObject.BindObjectOut"",
+ (28, ""Bind obj out"", var))
+ obj = var.getvalue()
+ result = self.cursor.callfunc(""pkg_TestBindObject.GetStringRep"", str,
+ (obj,))
+ self.assertEqual(result,
+ ""udt_Object(28, 'Bind obj out', null, null, null, null, null)"")
+
",507,67
Bump version to 7.1-dev now that changes have been made from version 7.0.," except:
 from distutils.extension import Extension
 
 # define build constants
-BUILD_VERSION = ""7.0.0""
+BUILD_VERSION = ""7.1.0-dev""
 
 # setup extra link and compile args
 extraLinkArgs = []
",101,3
"Entries can remain in v$sql_monitor for a period of time so only look at the
executing one."," class TestConnection(TestCase):
 if CLIENT_VERSION >= (12, 1):
 self.__VerifyAttributes(connection, ""dbop"", ""cx_OracleTest_DBOP"",
 ""select dbop_name from v$sql_monitor ""
- ""where sid = sys_context('userenv', 'sid')"")
+ ""where sid = sys_context('userenv', 'sid')""
+ ""and status = 'EXECUTING'"")
 self.__VerifyAttributes(connection, ""action"", ""cx_OracleTest_Action"",
 ""select sys_context('userenv', 'action') from dual"")
 self.__VerifyAttributes(connection, ""module"", ""cx_OracleTest_Module"",
",309,36
Add comment which is displayed during the test run.," class TestCursor(BaseTestCase):
 self.assertEqual(count, len(rows))
 
 def testExecuteManyWithInputSizesWrong(self):
+ ""test executing a statement multiple times (with input sizes wrong)""
 cursor = self.connection.cursor()
 cursor.setinputsizes(cx_Oracle.NUMBER)
 data = [[decimal.Decimal(""25.8"")], [decimal.Decimal(""30.0"")]]
",508,67
"Handle case when first call to cursor.executemany() has one or more columns
that are always null and a subsequent call to cursor.executemany() has a value
other than None in the same column
(https://github.com/oracle/python-cx_Oracle/issues/236)."," class TestCursor(BaseTestCase):
 data = [[decimal.Decimal(""25.8"")], [decimal.Decimal(""30.0"")]]
 cursor.executemany(""declare t number; begin t := :1; end;"", data)
 
+ def testExecuteManyMultipleBatches(self):
+ ""test executing a statement multiple times (with multiple batches)""
+ self.cursor.execute(""truncate table TestTempTable"")
+ sql = ""insert into TestTempTable values (:1, :2)""
+ self.cursor.executemany(sql, [(1, None), (2, None)])
+ self.cursor.executemany(sql, [(3, None), (4, ""Testing"")])
+
 def testExecuteManyWithResize(self):
 """"""test executing a statement multiple times (with resize)""""""
 self.cursor.execute(""truncate table TestTempTable"")
",514,68
"Ensure that all references to TestTempTable use the column names instead of
assuming the number of columns (in preparation for adding additional nullable
columns for other tests)."," class Subscription(BaseTestCase):
 cursor = connection.cursor()
 
 # insert statement
- cursor.execute(""insert into TestTempTable values (1, 'test')"")
+ cursor.execute(""""""
+ insert into TestTempTable (IntCol, StringCol)
+ values (1, 'test')"""""")
 cursor.execute(""select rowid from TestTempTable where IntCol = 1"")
 rowids.extend(r for r, in cursor)
 
 class Subscription(BaseTestCase):
 rowids.extend(r for r, in cursor)
 
 # second insert statement
- cursor.execute(""insert into TestTempTable values (2, 'test2')"")
+ cursor.execute(""""""
+ insert into TestTempTable (IntCol, StringCol)
+ values (2, 'test2')"""""")
 cursor.execute(""select rowid from TestTempTable where IntCol = 2"")
 rowids.extend(r for r, in cursor)
 
",68,10
"Update ODPI-C to support fetching XMLType as strings
(https://github.com/oracle/python-cx_Oracle/issues/14)."," class TestCursor(BaseTestCase):
 self.assertEqual(result,
 ""udt_Object(28, 'Bind obj out', null, null, null, null, null)"")
 
+ def testFetchXMLType(self):
+ ""test that fetching an XMLType returns a string contains its contents""
+ intVal = 5
+ label = ""IntCol""
+ expectedResult = ""<%s>%s</%s>"" % (label, intVal, label)
+ self.cursor.execute(""""""
+ select XMLElement(""%s"", IntCol)
+ from TestStrings
+ where IntCol = :intVal"""""" % label,
+ intVal = intVal)
+ result, = self.cursor.fetchone()
+ self.assertEqual(result, expectedResult)
+
",530,69
"Rework handling of numbers so that, unless using the NATIVE_INT,
NATIVE_FLOAT or NATIVE_DOUBLE types, all numbers are converted to strings and
passed through to ODPI-C in all Python versions; improved error message when
a value cannot be represented by an Oracle number value; improved test suite to
verify that calling executemany() with integers, floats and decimal values
intermixed with each other works as expected
(https://github.com/oracle/python-cx_Oracle/issues/241)."," static cxoVarType cxoAllVarTypes[] = {
 {
 CXO_TRANSFORM_FLOAT,
 &cxoPyTypeNumberVar,
- 0
+ 1000
 },
 {
 CXO_TRANSFORM_INT,
 &cxoPyTypeNumberVar,
- 0
+ 1000
 },
 {
 CXO_TRANSFORM_LONG_BINARY,
 &cxoPyTypeLongBinaryVar,
 128 * 1024
 },
- {
- CXO_TRANSFORM_LONG_INT,
- &cxoPyTypeNumberVar,
- 250,
- },
 {
 CXO_TRANSFORM_LONG_STRING,
 &cxoPyTypeLongStringVar,
",249,24
"Add additional check for calling setinputsizes() with an empty dictionary in
order to avoid the error ""cx_Oracle.ProgrammingError: positional and named
binds cannot be intermixed""
(https://github.com/oracle/python-cx_Oracle/issues/199)."," static PyObject *cxoCursor_setInputSizes(cxoCursor *cursor, PyObject *args,
 
 // eliminate existing bind variables
 Py_CLEAR(cursor->bindVariables);
+
+ // if no values passed, do nothing further, but return an empty list or
+ // dictionary as appropriate
+ if (numKeywordArgs == 0 && numPositionalArgs == 0) {
+ if (keywordArgs)
+ return PyDict_New();
+ return PyList_New(0);
+ }
+
+ // retain bind variables
+ cursor->setInputSizes = 1;
 if (numKeywordArgs > 0)
 cursor->bindVariables = PyDict_New();
 else cursor->bindVariables = PyList_New(numPositionalArgs);
 if (!cursor->bindVariables)
 return NULL;
 
- // retain bind variables if any were set
- if (numKeywordArgs > 0 || numPositionalArgs > 0)
- cursor->setInputSizes = 1;
-
 // process each input
 if (numKeywordArgs > 0) {
 i = 0;
",1495,369
"Ensure that values that exceed sizeof(long) for Python 2 on Windows when using
the Oracle type NATIVE_INT are not silently truncated
(https://github.com/oracle/python-cx_Oracle/issues/257)."," PyObject *cxoTransform_toPython(cxoTransformNum transformNum,
 case CXO_TRANSFORM_NATIVE_FLOAT:
 return PyFloat_FromDouble(dbValue->asFloat);
 case CXO_TRANSFORM_NATIVE_INT:
- return PyInt_FromLong((long) dbValue->asInt64);
+#if PY_MAJOR_VERSION < 3
+ if (sizeof(long) == 8 || (dbValue->asInt64 <= INT_MAX &&
+ dbValue->asInt64 >= -INT_MAX))
+ return PyInt_FromLong((long) dbValue->asInt64);
+#endif
+ return PyLong_FromLongLong(dbValue->asInt64);
 case CXO_TRANSFORM_DECIMAL:
 case CXO_TRANSFORM_INT:
 case CXO_TRANSFORM_FLOAT:
",639,193
"Timed waits for acquiring a session from a session pool is only available in
Oracle 12.2 and higher."," class TestConnection(TestCase):
 self.assertEqual(pool.busy, 1, ""busy not 1 after del"")
 pool.getmode = cx_Oracle.SPOOL_ATTRVAL_NOWAIT
 self.assertEqual(pool.getmode, cx_Oracle.SPOOL_ATTRVAL_NOWAIT)
- pool.getmode = cx_Oracle.SPOOL_ATTRVAL_TIMEDWAIT
- self.assertEqual(pool.getmode, cx_Oracle.SPOOL_ATTRVAL_TIMEDWAIT)
+ if CLIENT_VERSION >= (12, 2):
+ pool.getmode = cx_Oracle.SPOOL_ATTRVAL_TIMEDWAIT
+ self.assertEqual(pool.getmode, cx_Oracle.SPOOL_ATTRVAL_TIMEDWAIT)
 pool.stmtcachesize = 50
 self.assertEqual(pool.stmtcachesize, 50)
 pool.timeout = 10
",197,20
Bump copyright notice into 2019 for changed files.,"
 //-----------------------------------------------------------------------------
-// Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.
+// Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
 //
 // Portions Copyright 2007-2015, Anthony Tuininga. All rights reserved.
 //
",1265,243
Eliminated memory leak introduced by session tagging changes.," static void cxoConnection_free(cxoConnection *conn)
 Py_CLEAR(conn->version);
 Py_CLEAR(conn->inputTypeHandler);
 Py_CLEAR(conn->outputTypeHandler);
+ Py_CLEAR(conn->tag);
 Py_TYPE(conn)->tp_free((PyObject*) conn);
 }
 
 static PyObject *cxoConnection_close(cxoConnection *conn, PyObject *args)
 status = dpiConn_close(conn->handle, mode, (char*) tagBuffer.ptr,
 tagBuffer.size);
 Py_END_ALLOW_THREADS
+ cxoBuffer_clear(&tagBuffer);
 if (status < 0)
 return cxoError_raiseAndReturnNull();
 
",1267,243
"Reworked samples so that no default passwords are defined anywhere; added
Python script to create sample schemas and drop them in addition to having a
SQL*Plus script.","
 #------------------------------------------------------------------------------
-# Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
 #------------------------------------------------------------------------------
 
 #------------------------------------------------------------------------------
 def callback(message):
 print(""Queue name:"", message.queueName)
 print(""Consumer name:"", message.consumerName)
 
-connection = cx_Oracle.connect(SampleEnv.MAIN_CONNECT_STRING, events = True)
+connection = cx_Oracle.connect(SampleEnv.GetMainConnectString(), events = True)
 sub = connection.subscribe(namespace = cx_Oracle.SUBSCR_NAMESPACE_AQ,
 name = ""BOOKS"", callback = callback, timeout = 300)
 print(""Subscription:"", sub)
",27,2
"Reworked test suite to eliminate the use of default passwords and to make the
individual test modules directly runnable (instead of using execfile() within
test.py).","
 #------------------------------------------------------------------------------
-# Copyright (c) 2016, 2017, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
 #
 # Portions Copyright 2007-2015, Anthony Tuininga. All rights reserved.
 #

 
 """"""Module for testing boolean variables.""""""
 
-class TestBooleanVar(BaseTestCase):
+import TestEnv
+
+import cx_Oracle
+
+class TestCase(TestEnv.BaseTestCase):
 
 def testBindFalse(self):
 ""test binding in a False value""
 class TestBooleanVar(BaseTestCase):
 (True,))
 self.assertEqual(result, ""TRUE"")
 
+if __name__ == ""__main__"":
+ TestEnv.RunTestCases()
+
",32,5
Use random password instead of hard coded password as a security measure.," import TestEnv
 
 import cx_Oracle
 import random
+import string
 import threading
 
 class TestCase(TestEnv.BaseTestCase):
 class TestCase(TestEnv.BaseTestCase):
 
 def testChangePassword(self):
 ""test changing password""
- newPassword = ""NEW_PASSWORD""
+ sysRandom = random.SystemRandom()
+ newPassword = """".join(sysRandom.choice(string.ascii_letters) \
+ for i in range(20))
 connection = TestEnv.GetConnection()
 connection.changepassword(TestEnv.GetMainPassword(), newPassword)
 cconnection = cx_Oracle.connect(TestEnv.GetMainUser(), newPassword,
",305,38
The call to cursor.setinputsizes() is not needed for cx_Oracle 6 and higher.," longString = """"
 for i in range(10):
 char = chr(ord('A') + i)
 longString += char * 25000
- cursor.setinputsizes(None, cx_Oracle.LONG_STRING)
+ # uncomment the line below for cx_Oracle 5.3 and earlier
+ # cursor.setinputsizes(None, cx_Oracle.LONG_STRING)
 cursor.execute(""insert into TestClobs values (:1, :2)"",
 (i + 1, ""STRING "" + longString))
- cursor.setinputsizes(None, cx_Oracle.LONG_BINARY)
+ # uncomment the line below for cx_Oracle 5.3 and earlier
+ # cursor.setinputsizes(None, cx_Oracle.LONG_BINARY)
 cursor.execute(""insert into TestBlobs values (:1, :2)"",
 (i + 1, longString.encode(""ascii"")))
 connection.commit()
",42,3
Remove -dev designation in preparation for release of cx_Oracle 7.1.," except:
 from distutils.extension import Extension
 
 # define build constants
-BUILD_VERSION = ""7.1.0-dev""
+BUILD_VERSION = ""7.1.0""
 
 # setup extra link and compile args
 extraLinkArgs = []
",101,3
Preparing to release cx_Oracle 7.1.1.," except:
 from distutils.extension import Extension
 
 # define build constants
-BUILD_VERSION = ""7.1.0""
+BUILD_VERSION = ""7.1.1""
 
 # setup extra link and compile args
 extraLinkArgs = []
",101,3
Update ODPI-C; bump version in preparation for a new patch release.," except:
 from distutils.extension import Extension
 
 # define build constants
-BUILD_VERSION = ""7.1.1""
+BUILD_VERSION = ""7.1.2""
 
 # setup extra link and compile args
 extraLinkArgs = []
",101,3
"Revert changes to return decimal numbers when the numeric precision was too
great to be returned accurately as a floating point number. This change had too
great an impact on existing functionality and an output type handler can be
used to return decimal numbers where that is desirable
(https://github.com/oracle/python-cx_Oracle/issues/279)."," PyObject *cxoTransform_toPython(cxoTransformNum transformNum,
 #endif
 Py_DECREF(stringObj);
 return result;
- } else if (transformNum != CXO_TRANSFORM_DECIMAL &&
- bytes->length <= 15) {
+ } else if (transformNum == CXO_TRANSFORM_DECIMAL) {
+ result = PyObject_CallFunctionObjArgs(
+ (PyObject*) cxoPyTypeDecimal, stringObj, NULL);
+ } else {
 result = PyNumber_Float(stringObj);
- Py_DECREF(stringObj);
- return result;
 }
- result = PyObject_CallFunctionObjArgs(
- (PyObject*) cxoPyTypeDecimal, stringObj, NULL);
 Py_DECREF(stringObj);
 return result;
 case CXO_TRANSFORM_OBJECT:
",637,192
"Enable cursor.setinputsizes() and cursor.callfunc() to support specifying an
object type where a type is required, not just when a variable is being
created."," cxoVar *cxoVar_newByType(cxoCursor *cursor, PyObject *value,
 return (cxoVar*) value;
 }
 
- // everything else ought to be a Python type
- if (PyType_Check(value)) {
- varType = cxoVarType_fromPythonType(value, &objType);
- if (!varType)
- return NULL;
- return cxoVar_new(cursor, numElements, varType, varType->size, 0,
- objType);
- }
-
- PyErr_SetString(PyExc_TypeError, ""expecting type"");
- return NULL;
+ // everything else ought to be a Python type or object type
+ varType = cxoVarType_fromPythonType(value, &objType);
+ if (!varType)
+ return NULL;
+ return cxoVar_new(cursor, numElements, varType, varType->size, 0, objType);
 }
 
 
",538,138
Bump version in preparation for changes to be included in next version.," except:
 from distutils.extension import Extension
 
 # define build constants
-BUILD_VERSION = ""7.1.2""
+BUILD_VERSION = ""7.2.0-dev""
 
 # setup extra link and compile args
 extraLinkArgs = []
",101,3
"Correct parsing of connect string so that the last @ symbol is searched for
instead of the first @ symbol; otherwise, passwords containing an @ symbol will
result in the incorrect DSN being extracted
(https://github.com/oracle/python-cx_Oracle/issues/290)."," class TestCase(TestEnv.BaseTestCase):
 self.assertRaises(cx_Oracle.DatabaseError, connection.changepassword,
 TestEnv.GetMainPassword(), newPassword)
 
+ def testParsePassword(self):
+ ""test connecting with password containing / and @ symbols""
+ sysRandom = random.SystemRandom()
+ chars = list(sysRandom.choice(string.ascii_letters) for i in range(20))
+ chars[4] = ""/""
+ chars[8] = ""@""
+ newPassword = """".join(chars)
+ connection = TestEnv.GetConnection()
+ connection.changepassword(TestEnv.GetMainPassword(), newPassword)
+ try:
+ arg = ""%s/%s@%s"" % (TestEnv.GetMainUser(), newPassword,
+ TestEnv.GetConnectString())
+ cx_Oracle.connect(arg)
+ finally:
+ connection.changepassword(newPassword, TestEnv.GetMainPassword())
+
 def testEncodings(self):
 ""connection with only encoding or nencoding specified should work""
 connection = cx_Oracle.connect(TestEnv.GetMainUser(),
",320,41
"Cursor.callproc method changed with respect to doc (#287)

Signed-off-by: Andrey Petukhov <APetukhov@bellintegrator.com>"," static PyObject *cxoCursor_callProc(cxoCursor *cursor, PyObject *args,
 return NULL;
 
 // create the return value
- numArgs = PyList_GET_SIZE(cursor->bindVariables);
+ numArgs = 0;
+ if (listOfArguments) {
+ //check already made in cxoCursor_call
+ numArgs = PySequence_Size(listOfArguments);
+ }
 results = PyList_New(numArgs);
 if (!results)
 return NULL;
",1498,370
Adjust formatting of PR #287.," static PyObject *cxoCursor_callProc(cxoCursor *cursor, PyObject *args,
 keywordArguments) < 0)
 return NULL;
 
- // create the return value
- numArgs = 0;
- if (listOfArguments) {
- //check already made in cxoCursor_call
- numArgs = PySequence_Size(listOfArguments);
- }
+ // create the return value (only positional arguments are returned)
+ numArgs = (listOfArguments) ? PySequence_Size(listOfArguments) : 0;
 results = PyList_New(numArgs);
 if (!results)
 return NULL;
",1495,370
"For Python 2.7, raw_input is needed to request input; also ensure that
sample parameters are saved once requested."," import getpass
 import os
 import sys
 
+# for Python 2.7 we need raw_input
+try:
+ input = raw_input
+except NameError:
+ pass
+
 # default values
 DEFAULT_MAIN_USER = ""pythondemo""
 DEFAULT_EDITION_USER = ""pythoneditions""
 def GetValue(name, label, defaultValue=""""):
 value = getpass.getpass(label)
 if not value:
 value = defaultValue
+ PARAMETERS[name] = value
 return value
 
 def GetMainUser():
",87,27
"Raise an exception when an error takes place
(https://github.com/oracle/python-cx_Oracle/issues/299)."," int cxoTransform_fromPython(cxoTransformNum transformNum, PyObject *pyValue,
 status = dpiLob_setFromBytes(dbValue->asLOB, buffer->ptr,
 buffer->size);
 Py_END_ALLOW_THREADS
- return status;
+ if (status < 0)
+ return cxoError_raiseAndReturnInt();
+ return 0;
 case CXO_TRANSFORM_NATIVE_INT:
 #if PY_MAJOR_VERSION < 3
 if (PyInt_Check(pyValue)) {
",639,193
"Add support for setting a CLOB attribute on a SQL object, as requested
(https://github.com/oracle/python-cx_Oracle/issues/299)."," static int cxoConnectionParams_processShardingKeyValue(
 cxoConnectionParams *params, PyObject *value,
 dpiShardingKeyColumn *column, cxoBuffer *buffer)
 {
+ dpiNativeTypeNum nativeTypeNum;
 cxoTransformNum transformNum;
 
 transformNum = cxoTransform_getNumFromValue(value, 0);
- if (cxoTransform_fromPython(transformNum, value, &column->value, buffer,
- params->encoding, params->nencoding, NULL, 0) < 0)
+ if (cxoTransform_fromPython(transformNum, &nativeTypeNum, value,
+ &column->value, buffer, params->encoding, params->nencoding, NULL,
+ 0) < 0)
 return -1;
 cxoTransform_getTypeInfo(transformNum, &column->oracleTypeNum,
 &column->nativeTypeNum);
",1271,244
"Added mode cx_Oracle.DEFAULT_AUTH as requested
(https://github.com/oracle/python-cx_Oracle/issues/293) and adjusted
documentation for other cases that specified None where None is not actually
a valid value."," static PyObject *cxoModule_initialize(void)
 return NULL;
 
 // add constants for authorization modes
+ CXO_ADD_INT_CONSTANT(""DEFAULT_AUTH"", DPI_MODE_AUTH_DEFAULT)
 CXO_ADD_INT_CONSTANT(""SYSASM"", DPI_MODE_AUTH_SYSASM)
 CXO_ADD_INT_CONSTANT(""SYSBKP"", DPI_MODE_AUTH_SYSBKP)
 CXO_ADD_INT_CONSTANT(""SYSDBA"", DPI_MODE_AUTH_SYSDBA)
",359,43
Added support for Advanced Queueing RAW queues and bulk enqueue/dequeue.," PyTypeObject cxoPyTypeDeqOptions = {
 // cxoDeqOptions_new()
 // Create a new dequeue options object.
 //-----------------------------------------------------------------------------
-cxoDeqOptions *cxoDeqOptions_new(cxoConnection *connection)
+cxoDeqOptions *cxoDeqOptions_new(cxoConnection *connection,
+ dpiDeqOptions *handle)
 {
 cxoDeqOptions *options;
+ int status;
 
 options = (cxoDeqOptions*)
 cxoPyTypeDeqOptions.tp_alloc(&cxoPyTypeDeqOptions, 0);
 if (!options)
 return NULL;
- if (dpiConn_newDeqOptions(connection->handle, &options->handle) < 0) {
- Py_DECREF(options);
+ if (handle) {
+ status = dpiDeqOptions_addRef(handle);
+ } else {
+ status = dpiConn_newDeqOptions(connection->handle, &handle);
+ }
+ if (status < 0) {
 cxoError_raiseAndReturnNull();
+ Py_DECREF(options);
 return NULL;
 }
+ options->handle = handle;
 options->encoding = connection->encodingInfo.encoding;
 
 return options;
",293,49
"Enable PY_SSIZE_T_CLEAN in order to avoid deprecation warning and/or segfault
under Python 3.8.0b1 (https://github.com/oracle/python-cx_Oracle/issues/317)."," static PyObject *cxoConnection_commit(cxoConnection *conn, PyObject *args)
 //-----------------------------------------------------------------------------
 static PyObject *cxoConnection_begin(cxoConnection *conn, PyObject *args)
 {
- uint32_t transactionIdLength, branchIdLength;
+ Py_ssize_t transactionIdLength, branchIdLength;
 const char *transactionId, *branchId;
 int formatId, status;
 
",1378,265
Release the Python GIL while enqueuing and dequeuing messages!," static PyObject *cxoConnection_dequeue(cxoConnection *conn, PyObject* args,
 return NULL;
 
 // dequeue payload
+ Py_BEGIN_ALLOW_THREADS
 status = dpiConn_deqObject(conn->handle, nameBuffer.ptr, nameBuffer.size,
 optionsObj->handle, propertiesObj->handle, payloadObj->handle,
 &messageIdValue, &messageIdLength);
+ Py_END_ALLOW_THREADS
 cxoBuffer_clear(&nameBuffer);
 if (status < 0)
 return cxoError_raiseAndReturnNull();
 static PyObject *cxoConnection_enqueue(cxoConnection *conn, PyObject* args,
 return NULL;
 
 // enqueue payload
+ Py_BEGIN_ALLOW_THREADS
 status = dpiConn_enqObject(conn->handle, nameBuffer.ptr, nameBuffer.size,
 optionsObj->handle, propertiesObj->handle, payloadObj->handle,
 &messageIdValue, &messageIdLength);
+ Py_END_ALLOW_THREADS
 cxoBuffer_clear(&nameBuffer);
 if (status < 0)
 return cxoError_raiseAndReturnNull();
",1382,265
Change name of parameter to match documentation.," static PyObject *cxoConnection_enqueue(cxoConnection *conn, PyObject* args,
 static PyObject *cxoConnection_queue(cxoConnection *conn, PyObject* args,
 PyObject* keywordArgs)
 {
- static char *keywordList[] = { ""name"", ""type"", NULL };
+ static char *keywordList[] = { ""name"", ""payloadType"", NULL };
 cxoObjectType *typeObj;
 cxoBuffer nameBuffer;
 PyObject *nameObj;
",1382,265
"Eliminated deprecation of attribute ""id"" on subscriptions. It is now populated
with the value of REGID found in the database view
USER_CHANGE_NOTIFICATION_REGS or the value of REG_ID found in the database
view USER_SUBSCR_REGISTRATIONS. For AQ subscriptions, the value is 0."," sub = connection.subscribe(callback = callback, timeout = 1800,
 qos = cx_Oracle.SUBSCR_QOS_ROWIDS)
 print(""Subscription:"", sub)
 print(""--> Connection:"", sub.connection)
+print(""--> ID:"", sub.id)
 print(""--> Callback:"", sub.callback)
 print(""--> Namespace:"", sub.namespace)
 print(""--> Protocol:"", sub.protocol)
",42,5
Adjusted documentation to follow new API.," static PyObject *cxoConnection_newMessageProperties(cxoConnection *conn,
 PyObject *args, PyObject *keywordArgs)
 {
 static char *keywordList[] = { ""payload"", ""correlation"", ""delay"",
- ""exceptionQ"", ""expiration"", ""priority"", NULL };
+ ""exceptionq"", ""expiration"", ""priority"", NULL };
 PyObject *payloadObj, *correlationObj, *exceptionQObj;
 int delay, expiration, priority, status;
 cxoMsgProps *props;
",1383,265
Remove -dev designation in preparation for release of 7.2.," except:
 from distutils.extension import Extension
 
 # define build constants
-BUILD_VERSION = ""7.2.0-dev""
+BUILD_VERSION = ""7.2.0""
 
 # setup extra link and compile args
 extraLinkArgs = []
",101,3
"Added test cases, particularly for bulk AQ operations."," class TestCase(TestEnv.BaseTestCase):
 insert into TestTempTable (IntCol, StringCol)
 values (t_Id, 'Test String ' || t_Id);
 end;"""""", numRows)
+ self.assertEqual(self.cursor.rowcount, numRows)
 self.cursor.execute(""select count(*) from TestTempTable"")
 count, = self.cursor.fetchone()
 self.assertEqual(count, numRows)
 class TestCase(TestEnv.BaseTestCase):
 select sum(IntCol) into :1
 from TestTempTable;
 end;"""""", numRows)
+ self.assertEqual(self.cursor.rowcount, numRows)
 expectedData = [1, 3, 6, 10, 15, 21, 28, 36, 45]
 self.assertEqual(var.values, expectedData)
 
 class TestCase(TestEnv.BaseTestCase):
 
 if __name__ == ""__main__"":
 TestEnv.RunTestCases()
-
",583,75
Use most recent default connect string in tutorial.,"
 # [//]host_name[:port][/service_name][:server_type][/instance_name]
 #
 # Commonly just the host_name and service_name are needed
-# e.g. ""localhost/orclpdb"" or ""localhost/XE""
+# e.g. ""localhost/orclpdb1"" or ""localhost/XE""
 #
 # If using a tnsnames.ora file, the file can be in a default
 # location such as $ORACLE_HOME/network/admin/tnsnames.ora or
 except NameError:
 DEFAULT_MAIN_USER = ""pythondemo""
 DEFAULT_EDITION_USER = ""pythoneditions""
 DEFAULT_EDITION_NAME = ""python_e1""
-DEFAULT_CONNECT_STRING = ""localhost/orclpdb""
+DEFAULT_CONNECT_STRING = ""localhost/orclpdb1""
 
 # dictionary containing all parameters; these are acquired as needed by the
 # methods below (which should be used instead of consulting this dictionary
",87,27
"Resolve MemoryError exception on Windows when using an output type handler
(https://github.com/oracle/python-cx_Oracle/issues/330)."," except:
 from distutils.extension import Extension
 
 # define build constants
-BUILD_VERSION = ""7.2.0""
+BUILD_VERSION = ""7.2.1""
 
 # setup extra link and compile args
 extraLinkArgs = []
",101,3
Update to new default PDB service name.,"
 # [//]host_name[:port][/service_name][:server_type][/instance_name]
 #
 # Commonly just the host_name and service_name are needed
-# e.g. ""localhost/orclpdb1"" or ""localhost/XE""
+# e.g. ""localhost/orclpdb1"" or ""localhost/XEPDB1""
 #
 # If using a tnsnames.ora file, the file can be in a default
 # location such as $ORACLE_HOME/network/admin/tnsnames.ora or
",87,27
Restore support for setting numeric bind variables with boolean values.," class TestCase(TestEnv.BaseTestCase):
 (True,))
 self.assertEqual(result, ""TRUE"")
 
+ def testBindBooleanAsNumber(self):
+ ""test binding in a boolean as a number""
+ var = self.cursor.var(cx_Oracle.NUMBER)
+ var.setvalue(0, True)
+ self.cursor.execute(""select :1 from dual"", [var])
+ result, = self.cursor.fetchone()
+ self.assertEqual(result, 1)
+ var.setvalue(0, False)
+ self.cursor.execute(""select :1 from dual"", [var])
+ result, = self.cursor.fetchone()
+ self.assertEqual(result, 0)
+
 def testBindDecimal(self):
 ""test binding in a decimal.Decimal""
 self.cursor.execute(""""""
",352,48
Update ODPI-C and simplify call to get server version.," static PyObject *cxoConnection_createLob(cxoConnection *conn,
 //-----------------------------------------------------------------------------
 static PyObject *cxoConnection_getVersion(cxoConnection *conn, void *unused)
 {
- uint32_t releaseStringLength;
 dpiVersionInfo versionInfo;
- const char *releaseString;
 char buffer[25];
 int status;
 
 Py_BEGIN_ALLOW_THREADS
- status = dpiConn_getServerVersion(conn->handle, &releaseString,
- &releaseStringLength, &versionInfo);
+ status = dpiConn_getServerVersion(conn->handle, NULL, NULL, &versionInfo);
 Py_END_ALLOW_THREADS
 if (status < 0)
 return cxoError_raiseAndReturnNull();
",1380,265
"Adjust samples so that they run unchanged against Oracle Cloud databases:
- administrative user is ADMIN on the Oracle Cloud databases and SYSTEM on
 local databases (SYSDBA is not available on the Oracle Cloud database)
- use dbms_session.sleep() instead of dbms_lock.sleep() where possible
- environment variables CX_ORACLE_SAMPLES_SYSDBA_USER and
 CX_ORACLE_SAMPLES_SYSDBA_PASSWORD are replaced with
 CX_ORACLE_SAMPLES_ADMIN_USER and CX_ORACLE_SAMPLES_ADMIN_PASSWORD
- new environment variable CX_ORACLE_SAMPLES_DRCP_CONNECT_STRING used for
 specifying the connect string to use for DRCP usage"," def DropSamples(conn):
 edition_name = SampleEnv.GetEditionName())
 
 if __name__ == ""__main__"":
- conn = cx_Oracle.connect(SampleEnv.GetSysdbaConnectString(),
- mode = cx_Oracle.SYSDBA)
+ conn = cx_Oracle.connect(SampleEnv.GetAdminConnectString())
 DropSamples(conn)
 print(""Done."")
-
",13,1
"Adjust test suite so that it runs unchanged against Oracle Cloud databases:
- administrative user is ADMIN on the Oracle Cloud databases and SYSTEM on
 local databases (SYSDBA is not available on the Oracle Cloud database)
- environment variables CX_ORACLE_TEST_SYSDBA_USER and
 CX_ORACLE_TEST_SYSDBA_PASSWORD are replaced with CX_ORACLE_TEST_ADMIN_USER
 and CX_ORACLE_TEST_ADMIN_PASSWORD
- skip tests that change passwords as passwords on Oracle Cloud database are
 strictly controlled
- skip tests that check subscriptions as these are not currently supported on
 Oracle Cloud database"," def DropTests(conn):
 proxy_user = TestEnv.GetProxyUser())
 
 if __name__ == ""__main__"":
- conn = cx_Oracle.connect(TestEnv.GetSysdbaConnectString(),
- mode = cx_Oracle.SYSDBA)
+ conn = cx_Oracle.connect(TestEnv.GetAdminConnectString())
 DropTests(conn)
 print(""Done."")
 
",12,1
Eliminate unnecessary check (ODPI-C performs this check already).," static PyObject *cxoSessionPool_acquire(cxoSessionPool *pool, PyObject *args,
 PyObject *matchAnyTagObj;
 
 // parse arguments
- username = NULL;
 if (!PyArg_ParseTupleAndKeywords(args, keywordArgs, ""|s#s#OOOOOO"",
 keywordList, &username, &usernameLength, &password,
 &passwordLength, &cclassObj, &purityObj, &tagObj, &matchAnyTagObj,
 &shardingKeyObj, &superShardingKeyObj))
 return NULL;
- if (pool->homogeneous && username)
- return cxoError_raiseFromString(cxoProgrammingErrorException,
- ""pool is homogeneous. Proxy authentication is not possible."");
 
 // create arguments
 if (keywordArgs)
",445,69
"DatabaseError, not ProgrammingError is now returned as this check is performed
at the ODPI-C level."," class TestCase(TestEnv.BaseTestCase):
 getmode=cx_Oracle.SPOOL_ATTRVAL_WAIT)
 self.assertEqual(pool.homogeneous, 1,
 ""homogeneous should be 1 by default"")
- self.assertRaises(cx_Oracle.ProgrammingError, pool.acquire,
+ self.assertRaises(cx_Oracle.DatabaseError, pool.acquire,
 user = u""missing_proxyuser"")
 pool = TestEnv.GetPool(min=2, max=8, increment=3,
 getmode=cx_Oracle.SPOOL_ATTRVAL_WAIT, homogeneous=False)
",254,28
"A value of T_BOOL must be represented as char and should be treated as such
consistently in order to avoid issues on big-endian architectures."," static int cxoCursor_init(cxoCursor *cursor, PyObject *args,
 static char *keywordList[] = { ""connection"", ""scrollable"", NULL };
 cxoConnection *connection;
 PyObject *scrollableObj;
+ int isScrollable;
 
 // parse arguments
 scrollableObj = NULL;
 if (!PyArg_ParseTupleAndKeywords(args, keywordArgs, ""O!|O"", keywordList,
 &cxoPyTypeConnection, &connection, &scrollableObj))
 return -1;
- if (cxoUtils_getBooleanValue(scrollableObj, 0, &cursor->isScrollable) < 0)
+ if (cxoUtils_getBooleanValue(scrollableObj, 0, &isScrollable) < 0)
 return -1;
+ cursor->isScrollable = (char) isScrollable;
 
 // initialize members
 Py_INCREF(connection);
",1497,370
"Eliminate reference leak and ensure that memory is properly initialized in case
of error when using sharding keys."," static int cxoConnectionParams_processShardingKey(cxoConnectionParams *params,
 return 0;
 
 // allocate memory for the sharding key values
- columns = PyMem_Malloc(numColumns * sizeof(dpiShardingKeyColumn));
- buffers = PyMem_Malloc(numColumns * sizeof(cxoBuffer));
+ columns = PyMem_Calloc(numColumns, sizeof(dpiShardingKeyColumn));
+ buffers = PyMem_Calloc(numColumns, sizeof(cxoBuffer));
 if (isSuperShardingKey) {
 params->superShardingKeyColumns = columns;
 params->superShardingKeyBuffers = buffers;
 static int cxoConnectionParams_processShardingKey(cxoConnectionParams *params,
 
 // process each value
 for (i = 0; i < numColumns; i++) {
- cxoBuffer_init(&buffers[i]);
 value = PySequence_GetItem(shardingKeyObj, i);
 if (!value)
 return -1;
 if (cxoConnectionParams_processShardingKeyValue(params, value,
 &columns[i], &buffers[i]) < 0)
 return -1;
+ Py_DECREF(value);
 }
 
 return 0;
",1385,266
"Ensure that the session time zone is UTC so that values can be compared without
concern for the time zones of the client and database server."," class TestCase(TestEnv.BaseTestCase):
 
 def testFetchData(self):
 ""test fetching objects""
+ self.cursor.execute(""alter session set time_zone = 'UTC'"")
 self.cursor.execute(""""""
 select
 IntCol,
 class TestCase(TestEnv.BaseTestCase):
 
 def testRoundTripObject(self):
 ""test inserting and then querying object with all data types""
+ self.cursor.execute(""alter session set time_zone = 'UTC'"")
 self.cursor.execute(""truncate table TestClobs"")
 self.cursor.execute(""truncate table TestNClobs"")
 self.cursor.execute(""truncate table TestBlobs"")
",322,27
Eliminate reference leak when message properties object is destroyed.," static void cxoMsgProps_free(cxoMsgProps *props)
 dpiMsgProps_release(props->handle);
 props->handle = NULL;
 }
+ Py_CLEAR(props->payload);
 Py_TYPE(props)->tp_free((PyObject*) props);
 }
 
",254,43
Preparing to release cx_Oracle 7.3.," except:
 from distutils.extension import Extension
 
 # define build constants
-BUILD_VERSION = ""7.3.0-dev""
+BUILD_VERSION = ""7.3.0""
 
 # setup extra link and compile args
 extraLinkArgs = []
",101,3
cx_Oracle 8 when it is released will not support Python 2.7.,"
 # This script requires cx_Oracle 6.4 and higher.
 #------------------------------------------------------------------------------
 
-from __future__ import print_function
-
 import cx_Oracle
 import SampleEnv
 import threading
",26,2
"Check the minimum supported Python version and raise an exception if an older
Python version is being used."," import distutils.core
 import os
 import sys
 
+# check minimum supported Python version
+if sys.version_info[:2] < (3, 5):
+ raise Exception(""Python 3.5 or higher is required."")
+
 # if setuptools is detected, use it to add support for eggs
 try:
 from setuptools import setup, Extension
",103,3
Remove commented out code," import TestEnv
 
 import cx_Oracle
 import datetime
-# import sys
-
-# if sys.version_info > (3,):
-# long = int
 
 class TestCase(TestEnv.BaseTestCase):
 
",391,31
Remove unnecessary imports.,"
 
 import cx_Oracle
 import SampleEnv
-import threading
 import time
 
 registered = True
",43,6
"Use named field structure initialization in order to clarify code and reduce
clutter.","
 //-----------------------------------------------------------------------------
-// Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.
+// Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.
 //
 // Portions Copyright 2007-2015, Anthony Tuininga. All rights reserved.
 //
 int cxoBuffer_init(cxoBuffer *buf)
 buf->obj = NULL;
 return 0;
 }
-
",32,7
"Reworked type management to clarify and simplify code (see release notes for
details)."," static PyObject *cxoObject_getAttributeValue(cxoObject *obj,
 nativeTypeNum, &data) < 0)
 return cxoError_raiseAndReturnNull();
 return cxoObject_convertToPython(obj, attribute->transformNum, &data,
- attribute->type);
+ attribute->objectType);
 }
 
 
 static PyObject *cxoObject_internalGetElementByIndex(cxoObject *obj,
 &data) < 0)
 return cxoError_raiseAndReturnNull();
 return cxoObject_convertToPython(obj, obj->objectType->elementTransformNum,
- &data, (cxoObjectType*) obj->objectType->elementType);
+ &data, obj->objectType->elementObjectType);
 }
 
 
",447,89
"Use with clause when acquiring connections from a pool so that they are
returned automatically at the end of the block."," def callback(message):
 pool = cx_Oracle.SessionPool(SampleEnv.GetMainUser(),
 SampleEnv.GetMainPassword(), SampleEnv.GetConnectString(), min=2,
 max=5, increment=1, events=True, threaded=True)
-connection = pool.acquire()
-sub = connection.subscribe(callback=callback, timeout=1800,
- qos=cx_Oracle.SUBSCR_QOS_QUERY | cx_Oracle.SUBSCR_QOS_ROWIDS)
-print(""Subscription created with ID:"", sub.id)
-queryId = sub.registerquery(""select * from TestTempTable"")
-print(""Registered query with ID:"", queryId)
-connection.close()
+with pool.acquire() as connection:
+ sub = connection.subscribe(callback=callback, timeout=1800,
+ qos=cx_Oracle.SUBSCR_QOS_QUERY | cx_Oracle.SUBSCR_QOS_ROWIDS)
+ print(""Subscription created with ID:"", sub.id)
+ queryId = sub.registerquery(""select * from TestTempTable"")
+ print(""Registered query with ID:"", queryId)
 
 while registered:
 print(""Waiting for notifications...."")
",50,10
"Consolidate string handling in cxoTransform_toPython (#419)

Signed-off-by: Alex Henrie <alexhenrie24@gmail.com>"," PyObject *cxoTransform_toPython(cxoTransformNum transformNum,
 timestamp->month, timestamp->day, timestamp->hour,
 timestamp->minute, timestamp->second,
 timestamp->fsecond / 1000);
+ case CXO_TRANSFORM_FIXED_CHAR:
 case CXO_TRANSFORM_FIXED_NCHAR:
+ case CXO_TRANSFORM_LONG_STRING:
 case CXO_TRANSFORM_NSTRING:
+ case CXO_TRANSFORM_STRING:
 bytes = &dbValue->asBytes;
 return PyUnicode_Decode(bytes->ptr, bytes->length, bytes->encoding,
 encodingErrors);
 PyObject *cxoTransform_toPython(cxoTransformNum transformNum,
 return cxoError_raiseAndReturnNull();
 return PyUnicode_Decode(rowid, rowidLength,
 connection->encodingInfo.encoding, NULL);
- case CXO_TRANSFORM_FIXED_CHAR:
- case CXO_TRANSFORM_STRING:
- case CXO_TRANSFORM_LONG_STRING:
- bytes = &dbValue->asBytes;
- return PyUnicode_Decode(bytes->ptr, bytes->length,
- bytes->encoding, encodingErrors);
 case CXO_TRANSFORM_TIMEDELTA:
 intervalDS = &dbValue->asIntervalDS; 
 seconds = intervalDS->hours * 60 * 60 + intervalDS->minutes * 60 +
",720,183
"Use return value of snprintf instead of calling strlen unnecessarily (#420)

Signed-off-by: Alex Henrie <alexhenrie24@gmail.com>"," static PyObject *cxoConnection_getVersion(cxoConnection *conn, void *unused)
 {
 dpiVersionInfo versionInfo;
 char buffer[25];
- int status;
+ int status, len;
 
 if (cxoConnection_isConnected(conn) < 0)
 return NULL;
 static PyObject *cxoConnection_getVersion(cxoConnection *conn, void *unused)
 Py_END_ALLOW_THREADS
 if (status < 0)
 return cxoError_raiseAndReturnNull();
- snprintf(buffer, sizeof(buffer), ""%d.%d.%d.%d.%d"", versionInfo.versionNum,
- versionInfo.releaseNum, versionInfo.updateNum,
- versionInfo.portReleaseNum, versionInfo.portUpdateNum);
- return PyUnicode_DecodeASCII(buffer, strlen(buffer), NULL);
+ len = snprintf(buffer, sizeof(buffer), ""%d.%d.%d.%d.%d"",
+ versionInfo.versionNum, versionInfo.releaseNum,
+ versionInfo.updateNum, versionInfo.portReleaseNum,
+ versionInfo.portUpdateNum);
+ return PyUnicode_DecodeASCII(buffer, len, NULL);
 }
 
 
",1413,283
"Fix memory leak on error path in cxoObjectType_initialize (#422)

Signed-off-by: Alex Henrie <alexhenrie24@gmail.com>"," static int cxoObjectType_initialize(cxoObjectType *objType,
 }
 PyList_SET_ITEM(objType->attributes, i, (PyObject*) attr);
 if (PyDict_SetItem(objType->attributesByName, attr->name,
- (PyObject*) attr) < 0)
+ (PyObject*) attr) < 0) {
+ PyMem_Free(attributes);
 return -1;
+ }
 }
 PyMem_Free(attributes);
 return 0;
",242,49
"Remove redundant assignment from cxoCursor_setBindVariables (#421)

Signed-off-by: Alex Henrie <alexhenrie24@gmail.com>"," int cxoCursor_setBindVariables(cxoCursor *cursor, PyObject *parameters,
 else cursor->bindVariables = PyDict_New();
 if (!cursor->bindVariables)
 return -1;
- origNumParams = 0;
 }
 
 // handle positional binds
",1494,375
"Remove redundant decrement and return from cxoTransform_toPython (#423)

Signed-off-by: Alex Henrie <alexhenrie24@gmail.com>"," PyObject *cxoTransform_toPython(cxoTransformNum transformNum,
 if (transformNum == CXO_TRANSFORM_INT &&
 memchr(bytes->ptr, '.', bytes->length) == NULL) {
 result = PyNumber_Long(stringObj);
- Py_DECREF(stringObj);
- return result;
 } else if (transformNum == CXO_TRANSFORM_DECIMAL) {
 result = PyObject_CallFunctionObjArgs(
 (PyObject*) cxoPyTypeDecimal, stringObj, NULL);
",718,183
"Convert Python objects to booleans based on their Python truth value (#435)

Signed-off-by: Alex Henrie <alexhenrie24@gmail.com>"," int cxoTransform_fromPython(cxoTransformNum transformNum,
 
 switch (transformNum) {
 case CXO_TRANSFORM_BOOLEAN:
- dbValue->asBoolean = (pyValue == Py_True);
+ dbValue->asBoolean = PyObject_IsTrue(pyValue);
 return 0;
 case CXO_TRANSFORM_BINARY:
 case CXO_TRANSFORM_FIXED_CHAR:
",718,183
"Tweaks to boolean variable improvements patch supplied by Alex Henrie
(https://github.com/oracle/python-cx_Oracle/pull/435)."," int cxoTransform_fromPython(cxoTransformNum transformNum,
 switch (transformNum) {
 case CXO_TRANSFORM_BOOLEAN:
 dbValue->asBoolean = PyObject_IsTrue(pyValue);
+ if (PyErr_Occurred())
+ return -1;
 return 0;
 case CXO_TRANSFORM_BINARY:
 case CXO_TRANSFORM_FIXED_CHAR:
",720,184
"Added test cases for cursor.lastrowid and SODA collection truncation (and added
code to check for situation where SODA support is lacking and stop running the
test suite for SODA in that case)."," def GetClientVersion():
 
 class BaseTestCase(unittest.TestCase):
 
+ def getSodaDatabase(self, minclient=(18, 3), minserver=(18, 0),
+ message=""not supported with this client/server combination""):
+ client = cx_Oracle.clientversion()[:2]
+ if client < minclient:
+ self.skipTest(message)
+ server = tuple(int(s) for s in self.connection.version.split("".""))[:2]
+ if server < minserver:
+ self.skipTest(message)
+ if server > (20, 1) and client < (20, 1):
+ self.skipTest(message)
+ return self.connection.getSodaDatabase()
+
 def isOnOracleCloud(self, connection=None):
 if connection is None:
 connection = self.connection
",127,36
Return error if one occurs!," static PyObject *cxoSodaCollection_truncate(cxoSodaCollection *coll,
 status = dpiSodaColl_truncate(coll->handle);
 Py_END_ALLOW_THREADS
 if (status < 0)
- cxoError_raiseAndReturnNull();
+ return cxoError_raiseAndReturnNull();
 Py_RETURN_NONE;
 }
",408,78
Remove unneeded code (and a deprecation warning with Python 3.9b1).," static PyObject *cxoModule_initialize(void)
 {
 PyObject *module;
 
-#ifdef WITH_THREAD
- PyEval_InitThreads();
-#endif
-
 // initialize transforms
 if (cxoTransform_init() < 0)
 return NULL;
",474,46
Remove remaining references to Python 2 syntax.,"
 #------------------------------------------------------------------------------
 
 #------------------------------------------------------------------------------
-# Copyright (c) 2017, 2018, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.
 #------------------------------------------------------------------------------
 
-from __future__ import print_function
-
 import cx_Oracle
 import db_config
 
",23,2
Adjust test name to remove reference to very old version of Python.," class TestCase(TestEnv.BaseTestCase):
 self.assertEqual(self.cursor.fetchall(), [self.dataByKey[4]])
 
 def testBindDateTime(self):
- ""test binding in a Python 2.3 and higher date time""
+ ""test binding in a datetime.datetime value""
 self.cursor.execute(""""""
 select * from TestDates
 where DateCol = :value"""""",
",218,25
"Add cx_Oracle.init_oracle_client() for Oracle Client library initialization;
change default encoding to UTF-8."," static int cxoConnection_init(cxoConnection *conn, PyObject *args,
 passwordObj = dsnObj = cclassObj = editionObj = NULL;
 threadedObj = eventsObj = newPasswordObj = usernameObj = NULL;
 matchAnyTagObj = contextObj = shardingKeyObj = superShardingKeyObj = NULL;
- if (cxoUtils_initializeDPI() < 0)
+ if (cxoUtils_initializeDPI(NULL) < 0)
 return -1;
 if (dpiContext_initCommonCreateParams(cxoDpiContext, &dpiCommonParams) < 0)
 return cxoError_raiseAndReturnInt();
- dpiCommonParams.driverName = CXO_DRIVER_NAME;
- dpiCommonParams.driverNameLength =
- (uint32_t) strlen(dpiCommonParams.driverName);
 if (dpiContext_initConnCreateParams(cxoDpiContext, &dpiCreateParams) < 0)
 return cxoError_raiseAndReturnInt();
 if (!PyArg_ParseTupleAndKeywords(args, keywordArgs,
",1410,283
Various documentation and tutorial improvements.," def OutputTypeHandler(cursor, name, defaultType, size, precision, scale):
 con.outputtypehandler = OutputTypeHandler
 
 print(""Querying data..."")
-cur.prepare(""select * from testclobs where id = :id"")
-cur.execute(None, {'id': 1})
+cur.execute(""select * from testclobs where id = :id"", {'id': 1})
 (id, clobdata) = cur.fetchone()
 print(""CLOB length:"", len(clobdata))
 print(""CLOB data:"", clobdata)
",22,2
Preparing to release cx_Oracle 8.0.0.," except:
 from distutils.extension import Extension
 
 # define build constants
-BUILD_VERSION = ""8.0.0-dev""
+BUILD_VERSION = ""8.0.0""
 
 # setup extra link and compile args
 extraLinkArgs = []
 classifiers = [
 ""Natural Language :: English"",
 ""Operating System :: OS Independent"",
 ""Programming Language :: C"",
- ""Programming Language :: Python"",
- ""Programming Language :: Python :: 2"",
- ""Programming Language :: Python :: 3"",
+ ""Programming Language :: Python :: 3 :: Only"",
 ""Topic :: Database""
 ]
 
",101,3
"Update to ODPI-C 4.0.1 and add test to ensure that the offset is returned
correctly when a parse error is encountered."," import pickle
 
 class TestCase(TestEnv.BaseTestCase):
 
+ def testParseError(self):
+ ""test parse error returns offset correctly""
+ with self.assertRaises(cx_Oracle.Error) as cm:
+ self.cursor.execute(""begin t_Missing := 5; end;"")
+ errorObj, = cm.exception.args
+ self.assertEqual(errorObj.offset, 6)
+
 def testPickleError(self):
 ""test picking/unpickling an error object""
- errorObj = None
- try:
+ with self.assertRaises(cx_Oracle.Error) as cm:
 self.cursor.execute(""""""
 begin
 raise_application_error(-20101, 'Test!');
 end;"""""")
- except cx_Oracle.Error as e:
- errorObj, = e.args
+ errorObj, = cm.exception.args
 self.assertEqual(type(errorObj), cx_Oracle._Error)
 self.assertTrue(""Test!"" in errorObj.message)
 self.assertEqual(errorObj.code, 20101)
 class TestCase(TestEnv.BaseTestCase):
 
 if __name__ == ""__main__"":
 TestEnv.RunTestCases()
-
",34,2
"Update ODPI-C to development version to include patch for issue #459; bump
version to 8.1 for further development."," except:
 from distutils.extension import Extension
 
 # define build constants
-BUILD_VERSION = ""8.0.0""
+BUILD_VERSION = ""8.1.0-dev""
 
 # setup extra link and compile args
 extraLinkArgs = []
",101,3
"dd a note about Python 2 support to the error message raised when an
unsupported version is detected."," import sys
 
 # check minimum supported Python version
 if sys.version_info[:2] < (3, 5):
- raise Exception(""Python 3.5 or higher is required."")
+ raise Exception(""Python 3.5 or higher is required. "" +
+ ""For python 2, use 'pip install cx_Oracle==7.3'"")
 
 # if setuptools is detected, use it to add support for eggs
 try:
",102,3
Fix function header comments.," static PyObject *cxoConnection_unsubscribe(cxoConnection *conn, PyObject* args,
 
 
 //-----------------------------------------------------------------------------
-// cxoConnection_commit()
-// Commit the transaction on the connection.
+// cxoConnection_getSodaDatabase()
+// Create and return a new SODA database object associated with the
+// connection.
 //-----------------------------------------------------------------------------
 static PyObject *cxoConnection_getSodaDatabase(cxoConnection *conn,
 PyObject *args)
",1357,283
Add metadata specifying that Python 3.5 and higher is required (#456).," setup(
 author = ""Anthony Tuininga"",
 author_email = ""anthony.tuininga@gmail.com"",
 url = ""https://oracle.github.io/python-cx_Oracle"",
+ python_requires = "">=3.5"",
 ext_modules = [extension],
 keywords = ""Oracle"",
 license = ""BSD License"",
",103,3
"Make numConnectDataArgs const (#472)

Signed-off-by: Alex Henrie <alexhenrie24@gmail.com>"," static int cxoModule_setException(PyObject *module, PyObject **exception,
 static PyObject* cxoModule_makeDSN(PyObject* self, PyObject* args,
 PyObject* keywordArgs)
 {
- static unsigned int numConnectDataArgs = 5;
+ static const unsigned int numConnectDataArgs = 5;
 static char *keywordList[] = { ""host"", ""port"", ""sid"", ""service_name"",
 ""region"", ""sharding_key"", ""super_sharding_key"", NULL };
 PyObject *result, *connectData, *hostObj, *portObj;
",503,53
"Rework build to use setuptools exclusively and enable use of pyproject.toml;
rework test suite to use tox and simplify test suite (also added a test number
to each test case for easier reference).","
 #------------------------------------------------------------------------------
-# Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.
 #------------------------------------------------------------------------------
 
-""""""Module for testing subscriptions.""""""
+""""""
+3000 - Module for testing subscriptions
+""""""
 
 import TestEnv
 
 class SubscriptionData(object):
 
 class TestCase(TestEnv.BaseTestCase):
 
- def testSubscription(self):
- ""test Subscription for insert, update, delete and truncate""
+ def test_3000_Subscription(self):
+ ""3000 - test Subscription for insert, update, delete and truncate""
 
 # skip if running on the Oracle Cloud, which does not support
 # subscriptions currently
 class TestCase(TestEnv.BaseTestCase):
 
 if __name__ == ""__main__"":
 TestEnv.RunTestCases()
-
",77,11
"The value of prefetchrows for REF CURSOR variables is now honored
(https://github.com/oracle/python-cx_Oracle/issues/482)."," static int cxoVar_setValueCursor(cxoVar *var, uint32_t pos, dpiData *data,
 cursor->handle = data->value.asStmt;
 dpiStmt_addRef(cursor->handle);
 }
+
+ if (dpiStmt_setPrefetchRows(cursor->handle, cursor->prefetchRows) < 0)
+ return cxoError_raiseAndReturnInt();
+
 cursor->fixupRefCursor = 1;
 return 0;
 }
",524,122
Change to use PEP 8 format guidelines.,"
 #------------------------------------------------------------------------------
 
 import cx_Oracle
-import TestEnv
+import base
 
-def DropTests(conn):
+def drop_tests(conn):
 print(""Dropping test schemas..."")
- TestEnv.RunSqlScript(conn, ""DropTest"",
- main_user = TestEnv.GetMainUser(),
- proxy_user = TestEnv.GetProxyUser())
+ base.run_sql_script(conn, ""DropTest"",
+ main_user=base.get_main_user(),
+ proxy_user=base.get_proxy_user())
 
 if __name__ == ""__main__"":
- conn = cx_Oracle.connect(TestEnv.GetAdminConnectString())
- DropTests(conn)
+ conn = cx_Oracle.connect(base.get_admin_connect_string())
+ drop_tests(conn)
 print(""Done."")
",11,1
Eliminate use of deprecated function (which generates a warning in Python 3.9).," static Py_ssize_t cxoTransform_calculateSize(PyObject *value,
 return PyBytes_GET_SIZE(value);
 case CXO_TRANSFORM_NSTRING:
 case CXO_TRANSFORM_STRING:
- return PyUnicode_GET_SIZE(value);
+ return PyUnicode_GET_LENGTH(value);
 default:
 break;
 }
",720,184
"Added support for new JSON data type available in Oracle Client and Database 21
and higher."," cxoDbType *cxoDbType_fromTransformNum(cxoTransformNum transformNum)
 return cxoDbTypeTimestampLTZ;
 case CXO_TRANSFORM_TIMESTAMP_TZ:
 return cxoDbTypeTimestampTZ;
+ case CXO_TRANSFORM_JSON:
+ return cxoDbTypeJson;
 default:
 break;
 }
",208,74
"Rename ""base"" to ""test_env"" to be clearer as to the purpose of the module.","
 #------------------------------------------------------------------------------
 
 import cx_Oracle
-import base
+import test_env
 
 def drop_tests(conn):
 print(""Dropping test schemas..."")
- base.run_sql_script(conn, ""DropTest"",
- main_user=base.get_main_user(),
- proxy_user=base.get_proxy_user())
+ test_env.run_sql_script(conn, ""DropTest"",
+ main_user=test_env.get_main_user(),
+ proxy_user=test_env.get_proxy_user())
 
 if __name__ == ""__main__"":
- conn = cx_Oracle.connect(base.get_admin_connect_string())
+ conn = cx_Oracle.connect(test_env.get_admin_connect_string())
 drop_tests(conn)
 print(""Done."")
",11,1
Modify samples to follow the PEP 8 style guide.,"
 #------------------------------------------------------------------------------
-# Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.
 #
 # Portions Copyright 2007-2015, Anthony Tuininga. All rights reserved.
 #

 #------------------------------------------------------------------------------
 
 import cx_Oracle
-import SampleEnv
+import sample_env
 import time
 
 registered = True
 def callback(message):
 print(""-"" * 60)
 print(""="" * 60)
 
-connection = cx_Oracle.connect(SampleEnv.GetMainConnectString(), events = True)
+connection = cx_Oracle.connect(sample_env.get_main_connect_string(),
+ events=True)
 sub = connection.subscribe(callback = callback, timeout = 1800,
 qos = cx_Oracle.SUBSCR_QOS_QUERY | cx_Oracle.SUBSCR_QOS_ROWIDS)
 print(""Subscription:"", sub)
 print(""Registered query:"", queryId)
 while registered:
 print(""Waiting for notifications...."")
 time.sleep(5)
-
",44,6
"The connection created by using an external handle should never be used after
the external handle has been closed or destroyed (since otherwise the memory
used may have already been freed and reused by other parts of the application)."," class TestCase(test_env.BaseTestCase):
 cursor.close()
 self.assertRaises(oracledb.DatabaseError, connection2.close)
 connection.close()
- cursor = connection2.cursor()
- self.assertRaises(oracledb.DatabaseError, cursor.execute,
- ""select count(*) from TestTempTable"")
 
 def test_1114_make_dsn(self):
 ""1114 - test making a data source name from host, port and sid""
",334,43
Add support for older versions of Microsoft Visual Studio (2008 and higher).,"
 #include <stdio.h>
 #include <stdlib.h>
 
+#ifdef _MSC_VER
+#if _MSC_VER < 1900
+#define PRId64 ""I64d""
+#define PRIu64 ""I64u""
+#endif
+#endif
+
+#ifndef PRIu64
+#include <inttypes.h>
+#endif
+
 #define CONN_USERNAME ""dpic""
 #define CONN_PASSWORD ""dev""
 #define CONN_CONNECT_STRING """"
",52,10
"Adjusted documentation to be clearer; parameterized test suite; renamed built
library to ODPIC to more closely match the project name; improved support for
building on macOS.","
 //-----------------------------------------------------------------------------
 // Test.h
 // Common code used in all tests.
+//
+// The constants CONN_USERNAME, CONN_PASSWORD and CONN_CONNECT_STRING
+// are defined in the Makefile.
+//
 //-----------------------------------------------------------------------------
 
 #include <dpi.h>

 #include <inttypes.h>
 #endif
 
-#define CONN_USERNAME ""dpic""
-#define CONN_PASSWORD ""dev""
-#define CONN_CONNECT_STRING """"
-
 static dpiContext *gContext = NULL;
 
 //-----------------------------------------------------------------------------
",52,10
Adjusted code to pass pedantic code checker.," int dpiData__toOracleTimestamp(dpiData *data, dpiEnv *env, dpiError *error,
 uword valid;
 
 if (withTZ) {
- sprintf(tzOffsetBuffer, ""%+.2d:%.2d"", timestamp->tzHourOffset,
+ (void) sprintf(tzOffsetBuffer, ""%+.2d:%.2d"", timestamp->tzHourOffset,
 timestamp->tzMinuteOffset);
 tzOffset = tzOffsetBuffer;
 tzOffsetLength = strlen(tzOffset);
",450,85
"Check pool and connection are open, not just that the pool or connection handle
is valid."," int dpiConn_getEncodingInfo(dpiConn *conn, dpiEncodingInfo *info)
 {
 dpiError error;
 
- if (dpiGen__startPublicFn(conn, DPI_HTYPE_CONN, __func__, &error) < 0)
+ if (dpiConn__checkConnected(conn, __func__, &error) < 0)
 return DPI_FAILURE;
 return dpiEnv__getEncodingInfo(conn->env, info);
 }
",1075,266
"Correct support for acquiring a connection from the pool using the
dpiConn_create() method."," int dpiConn_create(const dpiContext *context, const char *userName,
 return dpiError__set(&error, ""check mixed credentials"",
 DPI_ERR_EXT_AUTH_WITH_CREDENTIALS);
 
+ // handle case where pool is specified
+ if (createParams->pool) {
+ if (dpiGen__checkHandle(createParams->pool, DPI_HTYPE_POOL,
+ ""verify pool"", &error) < 0)
+ return DPI_FAILURE;
+ if (!createParams->pool->handle)
+ return dpiError__set(&error, ""check pool"", DPI_ERR_NOT_CONNECTED);
+ if (dpiEnv__initError(createParams->pool->env, &error) < 0)
+ return DPI_FAILURE;
+ return dpiPool__acquireConnection(createParams->pool, userName,
+ userNameLength, password, passwordLength, createParams, conn,
+ &error);
+ }
+
 // allocate connection
 if (dpiGen__allocate(DPI_HTYPE_CONN, NULL, (void**) &tempConn, &error) < 0)
 return DPI_FAILURE;
",1098,273
Add handle type to invalid handle error.," int dpiError__check(dpiError *error, sword status, dpiConn *conn,
 
 // special error cases
 if (status == OCI_INVALID_HANDLE)
- return dpiError__set(error, action, DPI_ERR_INVALID_HANDLE);
+ return dpiError__set(error, action, DPI_ERR_INVALID_HANDLE, ""OCI"");
 else if (!error->handle)
 return dpiError__set(error, action, DPI_ERR_ERR_NOT_INITIALIZED);
 
",137,66
Update book details to less well-known values.,"
 //-----------------------------------------------------------------------------
-// Copyright (c) 2016 Oracle and/or its affiliates. All rights reserved.
+// Copyright (c) 2016, 2017 Oracle and/or its affiliates. All rights reserved.
 // This program is free software: you can modify it and/or redistribute it
 // under the terms of:
 //
 struct bookType {
 };
 
 struct bookType books[NUM_BOOKS] = {
- { ""The Fellowship of the Ring"", ""Tolkien, J.R.R."", 10.99 },
- { ""Harry Potter and the Philospher's Stone"", ""Rowling, J.K."", 7.99 }
+ { ""Oracle Call Interface Programmers Guide"", ""Oracle"", 0 },
+ { ""Selecting Employees"", ""Scott Tiger"", 7.99 }
 };
 
 //-----------------------------------------------------------------------------
",86,20
"Adjust handling of dynamic binding and DML returning to work correctly against
Oracle 11.2 databases."," int32_t dpiVar__inBindCallback(dpiVar *var, OCIBind *bindp, uint32_t iter,
 }
 } else {
 dpiVar__assignCallbackBuffer(var, index, bufpp);
- *alenp = (var->actualLength) ? var->actualLength[index] : 0;
+ *alenp = (var->actualLength) ? var->actualLength[index] :
+ var->type->sizeInBytes;
 }
 *piecep = OCI_ONE_PIECE;
 *indpp = &var->indicator[index];
 int32_t dpiVar__outBindCallback(dpiVar *var, OCIBind *bindp, uint32_t iter,
 var->actualLength[index] = var->sizeInBytes;
 *alenpp = &(var->actualLength[index]);
 #endif
- }
+ } else if (*alenpp && var->type->sizeInBytes)
+ **alenpp = var->type->sizeInBytes;
 *indpp = &(var->indicator[index]);
 if (var->returnCode)
 *rcodepp = &var->returnCode[index];
",1185,342
Remove unnecessary include.,"
 //-----------------------------------------------------------------------------
 
 #include ""dpiImpl.h""
-#include ""dpiErrorMessages.h""
 
 // a global OCI environment is used for managing errors in a thread-safe
 // manner; each thread is given its own error state; OCI error handles, though,
",135,27
"Ensure that zeroing the check integer on DPI handles is not optimised away by
the compiler."," int dpiContext_destroy(dpiContext *context)
 
 if (dpiContext__startPublicFn(context, __func__, &error) < 0)
 return DPI_FAILURE;
- context->checkInt = 0;
+ dpiUtils__clearMemory(&context->checkInt, sizeof(context->checkInt));
 free(context);
 return DPI_SUCCESS;
 }
",146,31
Restore support for simple reference count tracing by use of DPI_TRACE_REFS.," int dpiGen__allocate(dpiHandleTypeNum typeNum, dpiEnv *env, void **handle,
 }
 }
 value->env = env;
-#if 0
+#if DPI_TRACE_REFS
 fprintf(stderr, ""REF: %p (%s) -> 1 [NEW]\n"", value, typeDef->name);
 #endif
 
 int dpiGen__setRefCount(void *ptr, dpiError *error, int increment)
 localRefCount = value->refCount;
 }
 
-#if 0
+#if DPI_TRACE_REFS
 fprintf(stderr, ""REF: %p (%s) -> %d\n"", ptr, value->typeDef->name,
 localRefCount);
 #endif
",172,23
"Corrected support for handling unsigned integers that are larger than the
maximum size that can be represented by a signed integer. This corrects issue
3 (https://github.com/oracle/odpi/issues/3)."," static const dpiOracleType
 0, // is character data
 0, // can be in array
 0 // requires pre-fetch
+ },
+ {
+ DPI_ORACLE_TYPE_NATIVE_UINT, // public Oracle type
+ DPI_NATIVE_TYPE_UINT64, // default native type
+ SQLT_UIN, // internal Oracle type
+ SQLCS_IMPLICIT, // charset form
+ sizeof(uint64_t), // buffer size
+ 0, // is character data
+ 1, // can be in array
+ 0 // requires pre-fetch
 }
 };
 
",388,49
Silence compiler warnings from the Microsoft C++ compiler.," int dpiConn__setAttributesFromCommonCreateParams(const dpiContext *context,
 driverNameLength = params->driverNameLength;
 } else {
 driverName = DPI_DEFAULT_DRIVER_NAME;
- driverNameLength = strlen(driverName);
+ driverNameLength = (uint32_t) strlen(driverName);
 }
 if (dpiConn__setAttributeHelper(handle, handleType, OCI_ATTR_DRIVER_NAME,
 ""set driver name"", driverName, driverNameLength, error) < 0)
 int dpiConn_getServerVersion(dpiConn *conn, const char **releaseString,
 &serverRelease);
 if (dpiError__check(&error, status, conn, ""get server version"") < 0)
 return DPI_FAILURE;
- conn->releaseStringLength = strlen(buffer);
+ conn->releaseStringLength = (uint32_t) strlen(buffer);
 conn->releaseString = malloc(conn->releaseStringLength);
 if (!conn->releaseString)
 return dpiError__set(&error, ""allocate release string"",
",1098,273
"Increased size of string which can be generated from an OCI number. This
corrects issue #6 (https://github.com/oracle/odpi/issues/6)."," static const char *numbersToConvert[] = {
 ""-9e125"",
 ""9e-130"",
 ""-9e-130"",
+ ""9.99999999999999999999999999999999999999E-130"",
+ ""-9.99999999999999999999999999999999999999E-130"",
 NULL
 };
 
",83,15
"Remove type DPI_ORACLE_TYPE_LONG_NVARCHAR which is not needed
(https://github.com/oracle/odpi/issues/5)."," static const dpiOracleType
 0, // can be in array
 0 // requires pre-fetch
 },
- {
- DPI_ORACLE_TYPE_LONG_NVARCHAR, // public Oracle type
- DPI_NATIVE_TYPE_BYTES, // default native type
- SQLT_CHR, // internal Oracle type
- SQLCS_IMPLICIT, // charset form
- DPI_MAX_BASIC_BUFFER_SIZE + 1, // buffer size
- 1, // is character data
- 0, // can be in array
- 0 // requires pre-fetch
- },
 {
 DPI_ORACLE_TYPE_LONG_RAW, // public Oracle type
 DPI_NATIVE_TYPE_BYTES, // default native type
 const dpiOracleType *dpiOracleType__getFromQueryInfo(uint16_t oracleDataType,
 case SQLT_RDD:
 return dpiOracleType__getFromNum(DPI_ORACLE_TYPE_ROWID, error);
 case SQLT_LNG:
- if (charsetForm == SQLCS_NCHAR)
- return dpiOracleType__getFromNum(DPI_ORACLE_TYPE_LONG_NVARCHAR,
- error);
 return dpiOracleType__getFromNum(DPI_ORACLE_TYPE_LONG_VARCHAR,
 error);
 case SQLT_LBI:
",375,48
Remove extraneous copyright symbol and word from copyright string.," master_doc = 'index'
 
 # general information about the project
 project = 'ODPI-C'
-copyright = 'Copyright (c) 2016, 2017 Oracle and/or its affiliates. All rights reserved.'
+copyright = '2016, 2017 Oracle and/or its affiliates. All rights reserved.'
 author = 'Oracle'
 
 # the version info for the project, acts as replacement for |version| and
",25,3
"Add additional error (ORA-56600: an illegal OCI function call was issued) to
the list of errors that cause the session to be dropped from the session pool."," int dpiError__check(dpiError *error, sword status, dpiConn *conn,
 case 12583: // TNS:no reader
 case 27146: // post/wait initialization failed
 case 28511: // lost RPC connection
+ case 56600: // an illegal OCI function call was issued
 conn->dropSession = 1;
 break;
 }
",139,67
"Remove requirement for OCI header files at compilation and load OCI libraries
dynamically at run-time. This makes building drivers that depend on ODPI-C
much easier to build. It also means that only one driver is needed for all
versions of the Oracle Client libraries."," int dpiGen__setRefCount(void *ptr, dpiError *error, int increment)
 {
 dpiBaseType *value = (dpiBaseType*) ptr;
 unsigned localRefCount;
- sword status;
 
 // if threaded need to protect modification of the refCount with a mutex
 if (value->env->threaded) {
- status = OCIThreadMutexAcquire(value->env->handle,
- error->handle, value->env->mutex);
- if (dpiError__check(error, status, NULL, ""acquire mutex"") < 0)
+ if (dpiOci__threadMutexAcquire(value->env, error) < 0)
 return DPI_FAILURE;
 value->refCount += increment;
 localRefCount = value->refCount;
- status = OCIThreadMutexRelease(value->env->handle,
- error->handle, value->env->mutex);
- if (dpiError__check(error, status, NULL, ""release mutex"") < 0)
+ if (dpiOci__threadMutexRelease(value->env, error) < 0)
 return DPI_FAILURE;
 
 // otherwise the count can be incremented normally
",167,23
Add a favicon to all documentation pages.," html_title = 'ODPI-C v' + release
 # them
 html_static_path = ['_static']
 
+# the location of the favicon to use for all pages
+html_favicon = ""_themes/oracle/static/favicon.ico""
+
 # the location of any extra paths that contain custom files (such as robots.txt
 # or .htaccess), relative to this directory; these files are copied directdly
 # to the root of the documentation
",26,3
Releasing ODPI-C 2.0.0-beta.2.," author = 'Oracle'
 version = '2.0'
 
 # the full version, including alpha/beta/rc tags
-release = '2.0.0-beta.1'
+release = '2.0.0-beta.2'
 
 # the theme to use for HTML pages
 html_theme = 'oracle'
",26,3
Ensure output is flushed immediately to the log file.," int dpiTestCase_setFailed(dpiTestCase *testCase, const char *message)
 {
 fprintf(gTestSuite.logFile, "" [FAILED]\n"");
 fprintf(gTestSuite.logFile, "" %s\n"", message);
+ fflush(gTestSuite.logFile);
 return DPI_FAILURE;
 }
 
 int dpiTestCase_setFailedFromErrorInfo(dpiTestCase *testCase,
 fprintf(gTestSuite.logFile, "" ACTION: %s\n"", info->action);
 fprintf(gTestSuite.logFile, "" MSG: %.*s\n"", info->messageLength,
 info->message);
+ fflush(gTestSuite.logFile);
 return DPI_FAILURE;
 }
 
 int dpiTestSuite_run()
 fprintf(gTestSuite.logFile, ""%d. %s"", gTestSuite.minTestCaseId + i,
 testCase->description);
 fflush(gTestSuite.logFile);
+ fflush(gTestSuite.logFile);
 result = (*testCase->func)(testCase, &gTestSuite.params);
 if (result == 0) {
 numPassed++;
 fprintf(gTestSuite.logFile, "" [OK]\n"");
+ fflush(gTestSuite.logFile);
 }
 dpiTestCase__cleanUp(testCase);
 }
",165,29
Remove trailing spaces.," int dpiTest_707_getQueryInfo(dpiTestCase *testCase, dpiTestParams *params)
 return dpiTestCase_setFailedFromError(testCase);
 if (dpiStmt_getQueryInfo(stmt, 1, &info) < 0)
 return dpiTestCase_setFailedFromError(testCase);
- if (dpiTestCase_expectUintEqual(testCase, 
+ if (dpiTestCase_expectUintEqual(testCase,
 info.defaultNativeTypeNum, DPI_NATIVE_TYPE_DOUBLE) < 0)
 return DPI_FAILURE;
 dpiStmt_release(stmt);
",400,102
"Use the actual array size to indicate the number of rows returned in a DML
returning statement."," static int dpiStmt__bind(dpiStmt *stmt, dpiVar *var, int addReference,
 if (var->objectIndicator && dpiOci__bindObject(var, bindHandle, error) < 0)
 return DPI_FAILURE;
 
- // setup dynamic bind, if applicable
- if (dynamicBind && dpiOci__bindDynamic(var, bindHandle, error) < 0)
- return DPI_FAILURE;
+ // setup dynamic bind, if applicable; reset actual array size to 0 as
+ // dynamic bind doesn't get called if there are no rows returned in a DML
+ // returning statement
+ if (dynamicBind) {
+ if (stmt->isReturning)
+ var->actualArraySize = 0;
+ if (dpiOci__bindDynamic(var, bindHandle, error) < 0)
+ return DPI_FAILURE;
+ }
 
 return DPI_SUCCESS;
 }
",1105,328
"Remove unneeded function dpiVar_resize(). A new variable can be created instead
of resizing an existing one. If this function is considered desirable in the
future, a rebind would be necessary after the resize."," int dpiVar_release(dpiVar *var)
 }
 
 
-//-----------------------------------------------------------------------------
-// dpiVar_resize() [PUBLIC]
-// Resize the buffer allocated for the variable to the given size.
-//-----------------------------------------------------------------------------
-int dpiVar_resize(dpiVar *var, uint32_t sizeInBytes)
-{
- dpiError error;
-
- if (dpiGen__startPublicFn(var, DPI_HTYPE_VAR, __func__, &error) < 0)
- return DPI_FAILURE;
- if (var->nativeTypeNum != DPI_NATIVE_TYPE_BYTES)
- return dpiError__set(&error, ""resize"", DPI_ERR_NOT_SUPPORTED);
- if (var->dynamicBytes)
- return DPI_SUCCESS;
- free(var->data.asRaw);
- var->data.asRaw = NULL;
- var->sizeInBytes = sizeInBytes;
- return dpiVar__allocateBuffers(var, &error);
-}
-
-
 //-----------------------------------------------------------------------------
 // dpiVar_setFromBytes() [PUBLIC]
 // Set the value of the variable at the given array position from a byte
",1175,343
Ensure the invalid query position is included in the error message.," int dpiStmt_define(dpiStmt *stmt, uint32_t pos, dpiVar *var)
 return DPI_FAILURE;
 if (pos == 0 || pos > stmt->numQueryVars)
 return dpiError__set(&error, ""check query position"",
- DPI_ERR_QUERY_POSITION_INVALID);
+ DPI_ERR_QUERY_POSITION_INVALID, pos);
 if (dpiGen__checkHandle(var, DPI_HTYPE_VAR, ""check variable"", &error) < 0)
 return DPI_FAILURE;
 
 int dpiStmt_getQueryInfo(dpiStmt *stmt, uint32_t pos, dpiQueryInfo *info)
 // validate query position
 if (pos == 0 || pos > stmt->numQueryVars)
 return dpiError__set(&error, ""check query position"",
- DPI_ERR_QUERY_POSITION_INVALID);
+ DPI_ERR_QUERY_POSITION_INVALID, pos);
 
 // copy query information from internal cache
 memcpy(info, &stmt->queryInfo[pos - 1], sizeof(dpiQueryInfo));
",1105,328
Add more functional test cases.,"
 #include <limits.h>
 #endif
 
-#define NUM_EXECUTABLES 8
+#define NUM_EXECUTABLES 10
 
 static const char *dpiTestNames[NUM_EXECUTABLES] = {
 ""TestContext"",
 static const char *dpiTestNames[NUM_EXECUTABLES] = {
 ""TestPool"",
 ""TestPoolProperties"",
 ""TestQueries"",
- ""TestTransactions""
+ ""TestTransactions"",
+ ""TestMiscCases"",
+ ""TestVariables""
 };
 
 
",72,13
"Use structure to pass version information instead of separate parameters; also
include the full version hex value which can be compared using the macro
DPI_ORACLE_VERSION_TO_HEX."," int dpiContext_destroy(dpiContext *context)
 // dpiContext_getClientVersion() [PUBLIC]
 // Return the version of the Oracle client that is in use.
 //-----------------------------------------------------------------------------
-int dpiContext_getClientVersion(const dpiContext *context, int *versionNum,
- int *releaseNum, int *updateNum, int *portReleaseNum,
- int *portUpdateNum)
+int dpiContext_getClientVersion(const dpiContext *context,
+ dpiVersionInfo *versionInfo)
 {
 dpiError error;
 
 if (dpiContext__startPublicFn(context, __func__, &error) < 0)
 return DPI_FAILURE;
- *versionNum = context->versionInfo->versionNum;
- *releaseNum = context->versionInfo->releaseNum;
- *updateNum = context->versionInfo->updateNum;
- *portReleaseNum = context->versionInfo->portReleaseNum;
- *portUpdateNum = context->versionInfo->portUpdateNum;
+ memcpy(versionInfo, context->versionInfo, sizeof(dpiVersionInfo));
 return DPI_SUCCESS;
 }
 
",131,29
"Use decimal notation for full version rather than a form of hex notation as
this is easier for human beings to read."," int dpiConn__getServerVersion(dpiConn *conn, dpiError *error)
 conn->versionInfo.updateNum = (int)((serverRelease >> 12) & 0xFF);
 conn->versionInfo.portReleaseNum = (int)((serverRelease >> 8) & 0x0F);
 conn->versionInfo.portUpdateNum = (int)((serverRelease) & 0xFF);
- conn->versionInfo.fullVersionHex =
- DPI_ORACLE_VERSION_TO_HEX(conn->versionInfo.versionNum,
+ conn->versionInfo.fullVersionNum =
+ DPI_ORACLE_VERSION_TO_NUMBER(conn->versionInfo.versionNum,
 conn->versionInfo.releaseNum,
 conn->versionInfo.updateNum,
 conn->versionInfo.portReleaseNum,
",1013,271
Preparation for release of ODPI-C 2.0 beta 3.," author = 'Oracle'
 version = '2.0'
 
 # the full version, including alpha/beta/rc tags
-release = '2.0.0-beta.2'
+release = '2.0.0-beta.3'
 
 # the theme to use for HTML pages
 html_theme = 'oracle'
",26,3
Change name of type to be one supported by Oracle 11g as well as Oracle 12c.," int dpiTest_1009_setFromLobPositionTooLarge(dpiTestCase *testCase,
 int dpiTest_1010_setFromObjectUnsupportedType(dpiTestCase *testCase,
 dpiTestParams *params)
 {
- const char *objStr = ""PKG_TESTSTRINGARRAYS.UDT_STRINGLIST"";
+ const char *objStr = ""UDT_OBJECT"";
 dpiObjectType *objType;
 dpiObject *obj;
 dpiConn *conn;
 int dpiTest_1010_setFromObjectUnsupportedType(dpiTestCase *testCase,
 int dpiTest_1011_setFromObjectPositionTooLarge(dpiTestCase *testCase,
 dpiTestParams *params)
 {
- const char *objStr = ""PKG_TESTSTRINGARRAYS.UDT_STRINGLIST"";
+ const char *objStr = ""UDT_OBJECT"";
 uint32_t maxArrSize = 1;
 dpiObjectType *objType;
 dpiData *objectValue;
",510,97
"Enable temporary LOB caching in order to avoid disk I/O as suggested
(https://github.com/oracle/odpi/issues/10)."," int dpiOci__lobCreateTemporary(dpiLob *lob, dpiError *error)
 else lobType = DPI_OCI_TEMP_CLOB;
 status = (*dpiOciSymbols.fnLobCreateTemporary)(lob->conn->handle,
 error->handle, lob->locator, DPI_OCI_DEFAULT,
- lob->type->charsetForm, lobType, 0, DPI_OCI_DURATION_SESSION);
+ lob->type->charsetForm, lobType, 1, DPI_OCI_DURATION_SESSION);
 return dpiError__check(error, status, lob->conn, ""create temporary LOB"");
 }
 
",1805,232
"An empty string is just as acceptable as a NULL pointer when enabling external
authentication."," static int dpiPool__create(dpiPool *pool, const char *userName,
 void *authInfo;
 
 // validate parameters
- if (createParams->externalAuth && (userName || password))
+ if (createParams->externalAuth &&
+ ((userName && userNameLength > 0) ||
+ (password && passwordLength > 0)))
 return dpiError__set(error, ""check mixed credentials"",
 DPI_ERR_EXT_AUTH_WITH_CREDENTIALS);
 
",283,71
"Do not change the actual length for fixed length types or error
""ORA-01458: invalid length inside variable character string"" can occur."," static int dpiVar__setFromBytes(dpiVar *var, uint32_t pos, const char *value,
 bytes->length = valueLength;
 if (valueLength > 0)
 memcpy(bytes->ptr, value, valueLength);
- if (var->actualLength32)
- var->actualLength32[pos] = valueLength;
- else if (var->actualLength16)
- var->actualLength16[pos] = (uint16_t) valueLength;
+ if (var->type->sizeInBytes == 0) {
+ if (var->actualLength32)
+ var->actualLength32[pos] = valueLength;
+ else if (var->actualLength16)
+ var->actualLength16[pos] = (uint16_t) valueLength;
+ }
 if (var->returnCode)
 var->returnCode[pos] = 0;
 }
",1177,344
"Ensure that the length set in the dpiBytes structure is passed through to the
actual length buffers used by OCI."," int dpiVar__setValue(dpiVar *var, uint32_t pos, dpiData *data,
 if (oracleTypeNum == DPI_ORACLE_TYPE_NUMBER)
 return dpiData__toOracleNumberFromText(data, var->env,
 error, &var->data.asNumber[pos]);
+ if (var->actualLength32)
+ var->actualLength32[pos] = data->value.asBytes.length;
+ else if (var->actualLength16)
+ var->actualLength16[pos] =
+ (uint16_t) data->value.asBytes.length;
 if (var->returnCode)
 var->returnCode[pos] = 0;
 break;
",1182,346
"Handle edge case when an odd number of zeroes trail the decimal point in a
value that is effectively zero
(https://github.com/oracle/python-cx_Oracle/issues/22)."," int dpiData__toOracleNumberFromText(dpiData *data, dpiEnv *env,
 // if the exponent is odd, prepend a zero
 prependZero = (decimalPointIndex > 0 && decimalPointIndex % 2 == 1) ||
 (decimalPointIndex < 0 && decimalPointIndex % 2 == -1);
- if (prependZero) {
+ if (prependZero && numDigits != 0) {
 numDigits++;
 decimalPointIndex++;
 }
",431,85
"Use dpiVar_setFromBytes() instead of manipulating the byte structure directly
as the method provides greater safety and is easier to follow."," int main(int argc, char **argv)
 for (i = 0; i < NUM_ROWS; i++) {
 intColValue[i].isNull = 0;
 intColValue[i].value.asInt64 = gc_IntColValues[i];
- stringColValue[i].isNull = 0;
- strcpy(stringColValue[i].value.asBytes.ptr, gc_StringColValues[i]);
- stringColValue[i].value.asBytes.length = strlen(gc_StringColValues[i]);
+ if (dpiVar_setFromBytes(stringColVar, i, gc_StringColValues[i],
+ strlen(gc_StringColValues[i])) < 0)
+ return ShowError();
 }
 if (dpiStmt_executeMany(stmt, DPI_MODE_EXEC_DEFAULT, NUM_ROWS) < 0)
 return ShowError();
",59,15
Eliminate memory leaks when test cases run correctly.," int dpiTest_400_setCurrentSchema(dpiTestCase *testCase, dpiTestParams *params)
 &stmt) < 0)
 return dpiTestCase_setFailedFromError(testCase);
 dpiStmt_execute(stmt, 0, &numQueryColumns);
- return dpiTestCase_expectError(testCase, ""ORA-01435: user does not exist"");
+ if (dpiTestCase_expectError(testCase,
+ ""ORA-01435: user does not exist"") < 0)
+ return DPI_FAILURE;
+ if (dpiStmt_release(stmt) < 0)
+ return dpiTestCase_setFailedFromError(testCase);
+ return DPI_SUCCESS;
 }
 
 
",152,36
Correct resource leak.," void dpiEnv__free(dpiEnv *env, dpiError *error)
 env->mutex = NULL;
 }
 if (env->handle) {
- dpiOci__handleFree(error->handle, DPI_OCI_HTYPE_ENV);
+ dpiOci__handleFree(env->handle, DPI_OCI_HTYPE_ENV);
 env->handle = NULL;
 }
 free(env);
",118,34
"Change default native type to DPI_ORACLE_TYPE_INT64 if the column metadata
indicates that the values are able to fit inside a 64-bit integer."," int main(int argc, char **argv)
 return ShowError();
 if (dpiLob_getSize(blobColValue->value.asLOB, &blobSize) < 0)
 return ShowError();
- printf(""Row: IntCol = %g, BlobCol = BLOB(%"" PRIu64 "")\n"",
- intColValue->value.asDouble, blobSize);
+ printf(""Row: IntCol = %"" PRId64 "", BlobCol = BLOB(%"" PRIu64 "")\n"",
+ intColValue->value.asInt64, blobSize);
 }
 
 // display description of each variable
",85,26
"Add function dpiStmt_defineValue() which gives the application the opportunity
to specify the data type to use for fetching without having to create a
variable."," int main(int argc, char **argv)
 return ShowError();
 if (dpiStmt_execute(stmt, 0, &numQueryColumns) < 0)
 return ShowError();
+ if (dpiStmt_defineValue(stmt, 1, DPI_ORACLE_TYPE_NUMBER,
+ DPI_NATIVE_TYPE_BYTES, 0, 0, NULL) < 0)
+ return ShowError();
 
 // fetch rows
 printf(""Fetch rows with IntCol > %"" PRId64 ""\n"", bindValue.value.asInt64);
 int main(int argc, char **argv)
 if (dpiRowid_getStringValue(rowidValue->value.asRowid,
 &rowidAsString, &rowidAsStringLength) < 0)
 return ShowError();
- printf(""Row: Int = %"" PRId64 "", String = '%.*s', Raw = '%.*s', ""
- ""Rowid = '%.*s'\n"", intColValue->value.asInt64,
+ printf(""Row: Int = %.*s, String = '%.*s', Raw = '%.*s', ""
+ ""Rowid = '%.*s'\n"", intColValue->value.asBytes.length,
+ intColValue->value.asBytes.ptr,
 stringColValue->value.asBytes.length,
 stringColValue->value.asBytes.ptr,
 rawColValue->value.asBytes.length,
",96,25
"Added DPI_DEBUG_LEVEL and three bit flags DPI_DEBUG_LEVEL_FREES (reports on
invalid free), DPI_DEBUG_LEVEL_REFS (reports on reference count changes),
DPI_DEBUG_LEVEL_FNS (reports on public function calls)."," int dpiContext__initSubscrCreateParams(const dpiContext *context,
 int dpiContext__startPublicFn(const dpiContext *context, const char *fnName,
 dpiError *error)
 {
+#if DPI_DEBUG_LEVEL & DPI_DEBUG_LEVEL_FNS
+ fprintf(stderr, ""FN: %s(%p)\n"", fnName, context);
+#endif
 if (dpiGlobal__initError(fnName, error) < 0)
 return DPI_FAILURE;
 if (!context || context->checkInt != DPI_CONTEXT_CHECK_INT)
",132,30
Added test cases for public functions for dpiStmt.,"
 #include <limits.h>
 #endif
 
-#define NUM_EXECUTABLES 10
+#define NUM_EXECUTABLES 11
 
 static const char *dpiTestNames[NUM_EXECUTABLES] = {
 ""TestContext"",
 static const char *dpiTestNames[NUM_EXECUTABLES] = {
 ""TestQueries"",
 ""TestTransactions"",
 ""TestMiscCases"",
- ""TestVariables""
+ ""TestVariables"",
+ ""TestStatements""
 };
 
 
",73,13
"Only use 64-bit integers for Oracle numbers, not for other types like
intervals."," static int dpiStmt__getQueryInfoFromParam(dpiStmt *stmt, void *param,
 return DPI_FAILURE;
 info->oracleTypeNum = oracleType->oracleTypeNum;
 info->defaultNativeTypeNum = oracleType->defaultNativeTypeNum;
- if (info->scale == 0 && info->precision > 0 &&
- info->precision <= DPI_MAX_INT64_PRECISION)
+ if (info->oracleTypeNum == DPI_ORACLE_TYPE_NUMBER && info->scale == 0 &&
+ info->precision > 0 && info->precision <= DPI_MAX_INT64_PRECISION)
 info->defaultNativeTypeNum = DPI_NATIVE_TYPE_INT64;
 
 // aquire name of item
",1138,341
"Add check for Cygwin, as suggested (https://github.com/oracle/odpi/issues/11)."," static void *dpiOciLibHandle = NULL;
 
 // library names to search
 static const char *dpiOciLibNames[] = {
-#ifdef _WIN32
+#if defined _WIN32 || defined __CYGWIN__
 ""oci.dll"",
 #elif __APPLE__
 ""libclntsh.dylib"",
",1816,238
Remove improper call to OCIArrayDescriptorFree().," static void dpiVar__finalizeBuffers(dpiVar *var, dpiError *error)
 dpiOci__arrayDescriptorFree(&var->data.asInterval[0],
 DPI_OCI_DTYPE_INTERVAL_YM);
 break;
- case DPI_ORACLE_TYPE_ROWID:
- dpiOci__arrayDescriptorFree(&var->data.asRowid[0],
- DPI_OCI_DTYPE_ROWID);
- break;
 default:
 break;
 }
",1178,345
Preparing to release ODPI-C 2.0 beta 4.," author = 'Oracle'
 version = '2.0'
 
 # the full version, including alpha/beta/rc tags
-release = '2.0.0-beta.3'
+release = '2.0.0-beta.4'
 
 # the theme to use for HTML pages
 html_theme = 'oracle'
",26,3
Eliminate issues with AIX compiler.," int dpiError__getInfo(dpiError *error, dpiErrorInfo *info)
 info->sqlState = ""01002"";
 break;
 default:
- if (error->buffer->code == 0 && error->buffer->dpiErrorNum == 0)
+ if (error->buffer->code == 0 && error->buffer->errorNum == 0)
 info->sqlState = ""00000"";
 else info->sqlState = ""HY000"";
 break;
 int dpiError__set(dpiError *error, const char *action, dpiErrorNum errorNum,
 error->buffer->offset = 0;
 strcpy(error->buffer->encoding, DPI_CHARSET_NAME_UTF8);
 error->buffer->action = action;
- error->buffer->dpiErrorNum = errorNum;
+ error->buffer->errorNum = errorNum;
 va_start(varArgs, errorNum);
 error->buffer->messageLength = vsnprintf(error->buffer->message,
 sizeof(error->buffer->message),
",139,68
"OCI requires that both encoding and nencoding have values or that both encoding
and encoding do not have values. Look up missing value, if neeeded, in order to
avoid the error when creating the OCI environment
(https://github.com/oracle/python-cx_Oracle/issues/36)."," int dpiEnv__init(dpiEnv *env, const dpiContext *context,
 &env->ncharsetId, error) < 0)
 return DPI_FAILURE;
 
+ // both charsetId and ncharsetId must be zero or both must be non-zero
+ // use NLS routine to look up missing value, if needed
+ if (env->charsetId && !env->ncharsetId) {
+ if (dpiOci__nlsEnvironmentVariableGet(DPI_OCI_NLS_NCHARSET_ID,
+ &env->ncharsetId, error) < 0)
+ return DPI_FAILURE;
+ } else if (!env->charsetId && env->ncharsetId) {
+ if (dpiOci__nlsEnvironmentVariableGet(DPI_OCI_NLS_CHARSET_ID,
+ &env->charsetId, error) < 0)
+ return DPI_FAILURE;
+ }
+
 // create the new environment handle
 env->context = context;
 env->versionInfo = context->versionInfo;
",122,39
Eliminate deprecation warnings due to changes in Sphinx.," html_extra_path = []
 # do not generate an index
 html_use_index = False
 
-# do not use SmartyPants to convert quotes and dashes
-html_use_smartypants = False
+# do not use ""smart"" quotes
+smart_quotes = False
 
 # Grouping the document tree into LaTeX files. List of tuples
 # (source start file, target name, title,
 def setup(app):
 # define method to override the HTML builder to prevent the search page from
 # being generated
 def on_builder_inited(app):
- if app.buildername == ""html"":
+ if app.builder.name == ""html"":
 app.builder.search = False
 app.builder.script_files.clear()
 
",26,3
Eliminate trailing spaces.," int dpiOci__sessionEnd(dpiConn *conn, int checkError, dpiError *error)
 //-----------------------------------------------------------------------------
 int dpiOci__sessionGet(dpiEnv *env, void **handle, void *authInfo,
 const char *connectString, uint32_t connectStringLength,
- const char *tag, uint32_t tagLength, const char **outTag, 
+ const char *tag, uint32_t tagLength, const char **outTag,
 uint32_t *outTagLength, int *found, uint32_t mode, dpiError *error)
 {
 int status;
",1833,240
"Add optimisation when client and server character sets are identical; in that
case the size in bytes reported by the server is sufficient to hold the data
that will be transferred from the server."," int dpiEnv__init(dpiEnv *env, const dpiContext *context,
 }
 
 // determine encodings in use
- if (dpiEnv__getCharacterSetIdAndName(env, DPI_OCI_ATTR_ENV_CHARSET_ID,
+ if (dpiEnv__getCharacterSetIdAndName(env, DPI_OCI_ATTR_CHARSET_ID,
 &env->charsetId, env->encoding, error) < 0)
 return DPI_FAILURE;
 error->encoding = env->encoding;
 error->charsetId = env->charsetId;
- if (dpiEnv__getCharacterSetIdAndName(env, DPI_OCI_ATTR_ENV_NCHARSET_ID,
+ if (dpiEnv__getCharacterSetIdAndName(env, DPI_OCI_ATTR_NCHARSET_ID,
 &env->ncharsetId, env->nencoding, error) < 0)
 return DPI_FAILURE;
 
",122,39
Preparing to release ODPI-C 2 release candidate 1.," author = 'Oracle'
 version = '2.0'
 
 # the full version, including alpha/beta/rc tags
-release = '2.0.0-beta.4'
+release = '2.0.0-rc.1'
 
 # the theme to use for HTML pages
 html_theme = 'oracle'
",26,3
Added tests for various data types.," int dpiTestCase_expectDoubleEqual(dpiTestCase *testCase, double actualValue,
 }
 
 
+//-----------------------------------------------------------------------------
+// dpiTestCase_expectIntEqual() [PUBLIC]
+// Check to see that the signed integers are equal and if not, report a
+// failure and set the test case as failed.
+//-----------------------------------------------------------------------------
+int dpiTestCase_expectIntEqual(dpiTestCase *testCase, int64_t actualValue,
+ int64_t expectedValue)
+{
+ char message[512];
+
+ if (actualValue == expectedValue)
+ return DPI_SUCCESS;
+ snprintf(message, sizeof(message),
+ ""Value %"" PRId64 "" does not match expected value %"" PRId64 "".\n"",
+ actualValue, expectedValue);
+ return dpiTestCase_setFailed(testCase, message);
+}
+
+
 //-----------------------------------------------------------------------------
 // dpiTestCase_expectStringEqual() [PUBLIC]
 // Check to see that the strings are equal and if not, report a failure and
",187,33
Provide information on why initial DPI context could not be created.," void dpiTestSuite_initialize(uint32_t minTestCaseId)
 gTestSuite.params.dirName = DIR_NAME;
 gTestSuite.params.dirNameLength = strlen(DIR_NAME);
 if (dpiContext_create(DPI_MAJOR_VERSION, DPI_MINOR_VERSION, &gContext,
- &errorInfo) < 0)
+ &errorInfo) < 0) {
+ fprintf(stderr, ""FN: %s\n"", errorInfo.fnName);
+ fprintf(stderr, ""ACTION: %s\n"", errorInfo.action);
+ fprintf(stderr, ""MSG: %.*s\n"", errorInfo.messageLength,
+ errorInfo.message);
 dpiTestSuite__fatalError(""Unable to create initial DPI context."");
+ }
 }
 
 
",192,33
Additional test cases for object types and the handling of encodings.," void dpiTestSuite_getErrorInfo(dpiErrorInfo *errorInfo)
 //-----------------------------------------------------------------------------
 void dpiTestSuite_initialize(uint32_t minTestCaseId)
 {
+ char *ptr;
+
 dpiErrorInfo errorInfo;
 gTestSuite.numTestCases = 0;
 gTestSuite.allocatedTestCases = 0;
 gTestSuite.testCases = NULL;
 gTestSuite.logFile = stderr;
 gTestSuite.minTestCaseId = minTestCaseId;
- gTestSuite.params.userName = CONN_USERNAME;
 gTestSuite.params.userNameLength = strlen(CONN_USERNAME);
+ ptr = malloc(gTestSuite.params.userNameLength + 1);
+ if (!ptr)
+ dpiTestSuite__fatalError(""Out of memory!"");
+ gTestSuite.params.userName = ptr;
+ strcpy(ptr, CONN_USERNAME);
+ while (*ptr) {
+ *ptr = toupper(*ptr);
+ ptr++;
+ }
 gTestSuite.params.password = CONN_PASSWORD;
 gTestSuite.params.passwordLength = strlen(CONN_PASSWORD);
 gTestSuite.params.connectString = CONN_CONNECT_STRING;
",201,35
Some tests are only possible in Oracle Client 12.1 and higher.," int dpiTest_604_checkMaxLifetimeSession(dpiTestCase *testCase,
 {
 uint32_t value, sessMaxTime = 10;
 dpiPoolCreateParams createParams;
- dpiVersionInfo versionInfo;
+ dpiVersionInfo *versionInfo;
 dpiContext *context;
 dpiPool *pool;
 
 // only supported in 12.1 and higher
- dpiTestSuite_getContext(&context);
- dpiContext_getClientVersion(context, &versionInfo);
- if (versionInfo.versionNum < 12)
+ dpiTestSuite_getClientVersionInfo(&versionInfo);
+ if (versionInfo->versionNum < 12)
 return DPI_SUCCESS;
 
 // create a pool
+ dpiTestSuite_getContext(&context);
 if (dpiContext_initPoolCreateParams(context, &createParams) < 0)
 return dpiTestCase_setFailedFromError(testCase);
 createParams.minSessions = MINSESSIONS;
",229,54
"Added support for converting from text to number in object attributes and
collection element values."," static int dpiObject__toOracleValue(dpiObject *obj, dpiError *error,
 if (nativeTypeNum == DPI_NATIVE_TYPE_DOUBLE)
 return dpiData__toOracleNumberFromDouble(data, obj->env,
 error, &buffer->asNumber);
+ if (nativeTypeNum == DPI_NATIVE_TYPE_BYTES)
+ return dpiData__toOracleNumberFromText(data, obj->env,
+ error, &buffer->asNumber);
 break;
 case DPI_ORACLE_TYPE_NATIVE_FLOAT:
 if (nativeTypeNum == DPI_NATIVE_TYPE_FLOAT) {
",519,145
"Add checks on all pointers to ensure they are not NULL; add checks on all
pointer/length combinations to ensure that the pointer is not NULL and the
length non-zero at the same time."," int dpiError__check(dpiError *error, int status, dpiConn *conn,
 //-----------------------------------------------------------------------------
 int dpiError__getInfo(dpiError *error, dpiErrorInfo *info)
 {
+ if (!info)
+ return DPI_FAILURE;
 info->code = error->buffer->code;
 info->offset = error->buffer->offset;
 info->message = error->buffer->message;
",121,62
"Allow the parameter numQueryColumns to be NULL in dpiStmt_execute() as a
convenience to those who do not require that information."," int dpiStmt_execute(dpiStmt *stmt, dpiExecMode mode, uint32_t *numQueryColumns)
 numIters = (stmt->statementType == DPI_STMT_TYPE_SELECT) ? 0 : 1;
 if (dpiStmt__execute(stmt, numIters, mode, 1, &error) < 0)
 return DPI_FAILURE;
- *numQueryColumns = stmt->numQueryVars;
+ if (numQueryColumns)
+ *numQueryColumns = stmt->numQueryVars;
 return DPI_SUCCESS;
 }
 
",1171,345
"With 11.2 client, the thread key destructor does run at process exit even if
the thread key itself has been destroyed, so ensure that the same code that
runs on Windows, runs on platforms other than Windows as well."," void dpiEnv__free(dpiEnv *env, dpiError *error)
 if (env->errorsForThread[i]) {
 env->errorsForThread[i]->env = NULL;
 #ifndef _WIN32
- free(env->errorsForThread[i]);
+ if (env->versionInfo->versionNum >= 12)
+ free(env->errorsForThread[i]);
 #endif
 env->errorsForThread[i] = NULL;
 }
",214,58
Added additional test cases for objects and object types.,"
 #include <limits.h>
 #endif
 
-#define NUM_EXECUTABLES 13
+#define NUM_EXECUTABLES 14
 
 static const char *dpiTestNames[NUM_EXECUTABLES] = {
 ""TestContext"",
 static const char *dpiTestNames[NUM_EXECUTABLES] = {
 ""TestVariables"",
 ""TestStatements"",
 ""TestDataTypes"",
+ ""TestObjectTypes"",
 ""TestObjects""
 };
 
",76,13
"Correct null pointer checks for getting numeric attributes
(https://github.com/oracle/odpi/issues/16)."," int dpiDeqOptions_getVisibility(dpiDeqOptions *options, dpiVisibility *value)
 //-----------------------------------------------------------------------------
 int dpiDeqOptions_getWait(dpiDeqOptions *options, uint32_t *value)
 {
+ uint32_t valueLength = sizeof(uint32_t);
+
 return dpiDeqOptions__getAttrValue(options, DPI_OCI_ATTR_WAIT, __func__,
- value, NULL);
+ value, &valueLength);
 }
 
 
",223,40
Added missing break statement.," static int dpiObject__fromOracleValue(dpiObject *obj, dpiError *error,
 data->value.asBoolean = *(value->asBoolean);
 return DPI_SUCCESS;
 }
+ break;
 case DPI_ORACLE_TYPE_CLOB:
 case DPI_ORACLE_TYPE_NCLOB:
 case DPI_ORACLE_TYPE_BLOB:
",536,145
"Boolean values are not supported until 12.1 so raise an unsupported error if
an attempt is made to use them in 11.2."," int dpiVar__allocate(dpiConn *conn, dpiOracleTypeNum oracleTypeNum,
 if (isArray && !type->canBeInArray)
 return dpiError__set(error, ""check can be in array"",
 DPI_ERR_NOT_SUPPORTED);
+ if (oracleTypeNum == DPI_ORACLE_TYPE_BOOLEAN &&
+ conn->env->versionInfo->versionNum < 12)
+ return dpiError__set(error, ""check boolean"", DPI_ERR_NOT_SUPPORTED);
 if (nativeTypeNum != type->defaultNativeTypeNum) {
 if (dpiVar__validateTypes(type, nativeTypeNum, error) < 0)
 return DPI_FAILURE;
",1186,347
"Ensure the encoding is specified in the error buffer, just in case the first
OCIEnvNlsCreate() fails due to a configuration error like ""ORA-24296: error in
processing the XML configuration file""."," int dpiGlobal__initError(const char *fnName, dpiError *error)
 // the value that is used if an error takes place before the thread local
 // error structure can be returned
 error->buffer = &dpiGlobalErrorBuffer;
+ strcpy(error->buffer->encoding, DPI_CHARSET_NAME_UTF8);
 
 // initialize global environment, if necessary
 // this should only ever be done once by the first thread to execute this
",118,29
Correct handling of connections using DRCP.," int dpiConn_create(const dpiContext *context, const char *userName,
 status = dpiConn__get(tempConn, userName, userNameLength, password,
 passwordLength, connectString, connectStringLength,
 createParams, NULL, &error);
- status = dpiConn__create(tempConn, userName, userNameLength, password,
+ else status = dpiConn__create(tempConn, userName, userNameLength, password,
 passwordLength, connectString, connectStringLength, commonParams,
 createParams, &error);
 if (status < 0) {
",1009,258
"Corrected issue where error getting a pooled connection was masked by error
""DPI-1002: invalid OCI handle""."," static int dpiConn__close(dpiConn *conn, int mode, const char *tag,
 }
 
 // check server status; if not connected, ensure session is dropped
- if (dpiOci__attrGet(conn->serverHandle, DPI_OCI_HTYPE_SERVER,
- &serverStatus, NULL, DPI_OCI_ATTR_SERVER_STATUS,
- ""get server status"", error) < 0 ||
- serverStatus != DPI_OCI_SERVER_NORMAL)
- conn->dropSession = 1;
+ if (conn->serverHandle) {
+ if (dpiOci__attrGet(conn->serverHandle, DPI_OCI_HTYPE_SERVER,
+ &serverStatus, NULL, DPI_OCI_ATTR_SERVER_STATUS,
+ ""get server status"", error) < 0 ||
+ serverStatus != DPI_OCI_SERVER_NORMAL)
+ conn->dropSession = 1;
+ }
 
 // release session
 if (conn->dropSession)
",1011,259
"Added url fragment and whether a 32-bit or 64-bit library is expected to error
""DPI-1047: Oracle Client library cannot be loaded"" in order to improve the help
provided."," static const char *dpiOciLibNames[] = {
 NULL
 };
 
+// URL fragment to use in load library exception
+#if defined _WIN32 || defined __CYGWIN__
+ #define DPI_ERR_LOAD_URL_FRAGMENT ""windows""
+#elif __APPLE__
+ #define DPI_ERR_LOAD_URL_FRAGMENT ""macos""
+#else
+ #define DPI_ERR_LOAD_URL_FRAGMENT ""linux""
+#endif
+
 // version information for loaded OCI library
 static dpiVersionInfo dpiOciLibVersionInfo;
 
 static int dpiOci__loadLib(dpiError *error)
 #endif
 
 }
- if (!dpiOciLibHandle)
+ if (!dpiOciLibHandle) {
+ const char *bits = (sizeof(void*) == 8) ? ""64"" : ""32"";
 return dpiError__set(error, ""load library"", DPI_ERR_LOAD_LIBRARY,
- loadError);
+ bits, loadError, DPI_ERR_LOAD_URL_FRAGMENT);
+ }
 
 // validate library
 if (dpiOci__loadLibValidate(error) < 0) {
",1868,250
"Added prefix ""ODPI: "" to start of all debug messages to aid in differentiating
between them and other messages in log files."," int dpiContext__startPublicFn(const dpiContext *context, const char *fnName,
 dpiError *error)
 {
 #if DPI_DEBUG_LEVEL & DPI_DEBUG_LEVEL_FNS
- fprintf(stderr, ""FN: %s(%p)\n"", fnName, context);
+ fprintf(stderr, ""ODPI: fn %s(%p)\n"", fnName, context);
 #endif
 if (dpiGlobal__initError(fnName, error) < 0)
 return DPI_FAILURE;
",137,30
Preparing to release ODPI-C 2.0.0-rc.2.," author = 'Oracle'
 version = '2.0'
 
 # the full version, including alpha/beta/rc tags
-release = '2.0.0-rc.1'
+release = '2.0.0-rc.2'
 
 # the theme to use for HTML pages
 html_theme = 'oracle'
",26,3
Ensure that driver name and edition are set at all times.," int dpiPool__acquireConnection(dpiPool *pool, const char *userName,
 
 // create the connection
 if (dpiConn__get(tempConn, userName, userNameLength, password,
- passwordLength, pool->name, pool->nameLength, params, pool,
+ passwordLength, pool->name, pool->nameLength, NULL, params, pool,
 error) < 0) {
 dpiConn__free(tempConn, error);
 return DPI_FAILURE;
",277,67
"Rename internal method dpiConn__setAttributesFromCommonCreateParams() to
dpiUtils__setAttributesFromCommonCreateParams() as suggested. It is not
connection specific so makes more sense in a generic file."," static int dpiPool__create(dpiPool *pool, const char *userName,
 return DPI_FAILURE;
 
 // set context attributes
- if (dpiConn__setAttributesFromCommonCreateParams(authInfo,
+ if (dpiUtils__setAttributesFromCommonCreateParams(authInfo,
 DPI_OCI_HTYPE_AUTHINFO, commonParams, error) < 0)
 return DPI_FAILURE;
 
",277,67
"Prevent closing the connection when there are any open statements or LOBs and
add new error ""DPI-1054: connection cannot be closed when open statements or
LOBs exist"" when this situation is detected; this is needed to prevent crashes
under certain conditions when statements or LOBs are being acted upon while at
the same time (in another thread) a connection is being closed; it also
prevents leaks of statements and LOBs when a connection is returned to a
session pool."," static int dpiStmt__checkOpen(dpiStmt *stmt, const char *fnName,
 return DPI_FAILURE;
 if (!stmt->handle)
 return dpiError__set(error, ""check closed"", DPI_ERR_STMT_CLOSED);
- if (!stmt->conn->handle)
+ if (!stmt->conn->handle || stmt->conn->closing)
 return dpiError__set(error, ""check connection"", DPI_ERR_NOT_CONNECTED);
 if (stmt->statementType == 0 && dpiStmt__init(stmt, error) < 0)
 return DPI_FAILURE;
 static int dpiStmt__close(dpiStmt *stmt, const char *tag,
 error) < 0)
 return DPI_FAILURE;
 stmt->handle = NULL;
+ dpiConn__decrementOpenChildCount(stmt->conn, error);
 }
 if (stmt->conn) {
 dpiGen__setRefCount(stmt->conn, error, -1);
",1172,346
"Added new test cases for advanced queuing, LOBs and implicit results.","
 #include <limits.h>
 #endif
 
-#define NUM_EXECUTABLES 14
+#define NUM_EXECUTABLES 20
 
 static const char *dpiTestNames[NUM_EXECUTABLES] = {
 ""TestContext"",
 static const char *dpiTestNames[NUM_EXECUTABLES] = {
 ""TestStatements"",
 ""TestDataTypes"",
 ""TestObjectTypes"",
- ""TestObjects""
+ ""TestObjects"",
+ ""TestEnqOptions"",
+ ""TestDeqOptions"",
+ ""TestMsgProps"",
+ ""TestAQ"",
+ ""TestLOBs"",
+ ""TestImplicitResults""
 };
 
 
",82,13
Handle case properly when queue is empty (ensure msgId is NULL).," int dpiConn_deqObject(dpiConn *conn, const char *queueName,
 // dequeue message
 if (dpiOci__aqDeq(conn, queueName, options->handle, props->handle,
 payload->type->tdo, &payload->instance, &payload->indicator,
- &ociMsgId, &error) < 0)
- return (error.buffer->code == 25228) ? DPI_SUCCESS : DPI_FAILURE;
+ &ociMsgId, &error) < 0) {
+ if (error.buffer->code == 25228) {
+ *msgId = NULL;
+ *msgIdLength = 0;
+ return DPI_SUCCESS;
+ }
+ return DPI_FAILURE;
+ }
 dpiOci__rawPtr(conn->env, ociMsgId, (void**) msgId);
 dpiOci__rawSize(conn->env, ociMsgId, msgIdLength);
 return DPI_SUCCESS;
",1064,280
"Make DPI_DEBUG_LEVEL a runtime check, not a compile time check."," int dpiContext__initSubscrCreateParams(const dpiContext *context,
 int dpiContext__startPublicFn(const dpiContext *context, const char *fnName,
 dpiError *error)
 {
-#if DPI_DEBUG_LEVEL & DPI_DEBUG_LEVEL_FNS
- fprintf(stderr, ""ODPI: fn %s(%p)\n"", fnName, context);
-#endif
+ if (dpiDebugLevel & DPI_DEBUG_LEVEL_FNS)
+ fprintf(stderr, ""ODPI: fn %s(%p)\n"", fnName, context);
 if (dpiGlobal__initError(fnName, error) < 0)
 return DPI_FAILURE;
 if (!context || context->checkInt != DPI_CONTEXT_CHECK_INT)
",138,30
"Provide means of disabling thread cleanup for situations where threads are
created at startup and never terminated (such as takes place with Node.js)."," int dpiEnv__init(dpiEnv *env, const dpiContext *context,
 if (dpiOci__threadMutexInit(env, &env->mutex, error) < 0)
 return DPI_FAILURE;
 if (dpiOci__threadKeyInit(env, &env->threadKey,
- dpiEnv__freeErrorForThread, error) < 0)
+#ifdef DPI_DISABLE_THREAD_CLEANUP
+ NULL,
+#else
+ dpiEnv__freeErrorForThread,
+#endif
+ error) < 0)
 return DPI_FAILURE;
 }
 
",216,59
"Revert setting driver name and edition when connection class is set as this
prevents DRCP from being used."," int dpiPool__acquireConnection(dpiPool *pool, const char *userName,
 
 // create the connection
 if (dpiConn__get(tempConn, userName, userNameLength, password,
- passwordLength, pool->name, pool->nameLength, NULL, params, pool,
+ passwordLength, pool->name, pool->nameLength, params, pool,
 error) < 0) {
 dpiConn__free(tempConn, error);
 return DPI_FAILURE;
",277,67
"Added additional test cases for batch errors, rowids, scrollable cursors and
subscriptions.","
 #include <limits.h>
 #endif
 
-#define NUM_EXECUTABLES 20
+#define NUM_EXECUTABLES 24
 
 static const char *dpiTestNames[NUM_EXECUTABLES] = {
 ""TestContext"",
 static const char *dpiTestNames[NUM_EXECUTABLES] = {
 ""TestMsgProps"",
 ""TestAQ"",
 ""TestLOBs"",
- ""TestImplicitResults""
+ ""TestImplicitResults"",
+ ""TestRowIds"",
+ ""TestScrollCursors"",
+ ""TestSubscriptions"",
+ ""TestBatchErrors""
 };
 
 
",86,13
"Ensure that any prefetch activities are performed prior to performing the fetch
in dpiStmt_scroll()."," int dpiStmt_scroll(dpiStmt *stmt, dpiFetchMode mode, int32_t offset,
 return DPI_SUCCESS;
 }
 
+ // perform any pre-fetch activities required
+ if (dpiStmt__preFetch(stmt, &error) < 0)
+ return DPI_FAILURE;
+
 // perform fetch; when fetching the last row, only fetch a single row
 numRows = (mode == DPI_MODE_FETCH_LAST) ? 1 : stmt->fetchArraySize;
 if (dpiOci__stmtFetch2(stmt, numRows, mode, offset, &error) < 0)
",1174,347
Added support for binding by value for rowids.," static int dpiStmt__createBindVar(dpiStmt *stmt,
 if (data->value.asObject)
 objType = data->value.asObject->type;
 break;
+ case DPI_NATIVE_TYPE_ROWID:
+ oracleTypeNum = DPI_ORACLE_TYPE_ROWID;
+ break;
 case DPI_NATIVE_TYPE_BOOLEAN:
 oracleTypeNum = DPI_ORACLE_TYPE_BOOLEAN;
 break;
",1177,348
"Add script sql/TestEnv.sql and read environment variables during test execution
in order to simplify the running of tests. This also provides a framework for
adding additional parameters, if needed."," int dpiTest_2300_callExeManyWithArrDataAndVerifyErrAsExp(dpiTestCase *testCase,
 return DPI_FAILURE;
 snprintf(expectedError, sizeof(expectedError),
 ""ORA-00001: unique constraint (%s.TESTTEMPTABLE_PK) violated"",
- params->userName);
+ params->mainUserName);
 dpiStmt_executeMany(stmt, DPI_MODE_EXEC_DEFAULT, NUM_ROWS);
 if (dpiTestCase_expectError(testCase, expectedError) < 0)
 return DPI_FAILURE;
 int dpiTest_2301_verifyBatchErrsAndOffsetAsExpected(dpiTestCase *testCase,
 return DPI_FAILURE;
 snprintf(expectedError, sizeof(expectedError),
 ""ORA-00001: unique constraint (%s.TESTTEMPTABLE_PK) violated"",
- params->userName);
+ params->mainUserName);
 if (dpiTestCase_expectStringEqual(testCase, errorInfo[1].message,
 errorInfo[1].messageLength, expectedError,
 strlen(expectedError)) < 0)
",140,39
"On platforms other than Windows, if the regular method for loading the Oracle
client fails, try using $ORACLE_HOME/lib/libclntsh.so
(https://github.com/oracle/odpi/issues/20)."," static int dpiOci__loadLib(dpiError *error)
 #ifdef _WIN32
 DWORD length, errorNum;
 wchar_t wLoadError[512];
+#else
+ char *oracleHome, *oracleHomeLibName;
+ size_t oracleHomeLibNameLength;
 #endif
 
 // dynamically load the OCI library
 static int dpiOci__loadLib(dpiError *error)
 #endif
 
 }
+
+#ifndef _WIN32
+ // on platforms other than Windows, attempt to use
+ // $ORACLE_HOME/lib/libclntsh.so
+ if (!dpiOciLibHandle) {
+ oracleHome = getenv(""ORACLE_HOME"");
+ if (oracleHome) {
+ oracleHomeLibNameLength = strlen(oracleHome) + 5 +
+ strlen(dpiOciLibNames[0]);
+ oracleHomeLibName = malloc(oracleHomeLibNameLength);
+ if (oracleHomeLibName) {
+ sprintf(oracleHomeLibName, ""%s/lib/%s"", oracleHome,
+ dpiOciLibNames[0]);
+ dpiOciLibHandle = dlopen(oracleHomeLibName, RTLD_LAZY);
+ free(oracleHomeLibName);
+ }
+ }
+ }
+#endif
+
 if (!dpiOciLibHandle) {
 const char *bits = (sizeof(void*) == 8) ? ""64"" : ""32"";
 return dpiError__set(error, ""load library"", DPI_ERR_LOAD_LIBRARY,
",1889,253
"Change default connectstring to localhost/orclpdb to be consistent with the
default value used in the Oracle Database installer."," dpiSampleParams *dpiSamples_getParams(void)
 &gParams.proxyUserName, &gParams.proxyUserNameLength, 1);
 dpiSamples__getEnvValue(""ODPIC_SAMPLES_PROXY_PASSWORD"", ""welcome"",
 &gParams.proxyPassword, &gParams.proxyPasswordLength, 0);
- dpiSamples__getEnvValue(""ODPIC_SAMPLES_CONNECT_STRING"", ""localhost/orcl"",
+ dpiSamples__getEnvValue(""ODPIC_SAMPLES_CONNECT_STRING"", ""localhost/orclpdb"",
 &gParams.connectString, &gParams.connectStringLength, 0);
 dpiSamples__getEnvValue(""ODPIC_SAMPLES_DIR_NAME"", ""odpicdemo_dir"",
 &gParams.dirName, &gParams.dirNameLength, 1);
",92,15
"Added support for DPI_DEBUG_LEVEL_ERRORS and DPI_DEBUG_LEVEL_SQL in order to
further improve the ability to debug issues."," int dpiError__check(dpiError *error, int status, dpiConn *conn,
 if (dpiOci__errorGet(error->handle, DPI_OCI_HTYPE_ERROR, action,
 error) < 0)
 return DPI_FAILURE;
+ if (dpiDebugLevel & DPI_DEBUG_LEVEL_ERRORS)
+ fprintf(stderr, ""ODPI: OCI error %.*s (%s / %s)\n"",
+ error->buffer->messageLength, error->buffer->message,
+ error->buffer->fnName, action);
 
 // determine if error is recoverable (Transaction Guard)
 // if the attribute cannot be read properly, simply leave it as false;
 int dpiError__set(dpiError *error, const char *action, dpiErrorNum errorNum,
 sizeof(error->buffer->message),
 dpiErrorMessages[errorNum - DPI_ERR_NO_ERR], varArgs);
 va_end(varArgs);
+ if (dpiDebugLevel & DPI_DEBUG_LEVEL_ERRORS)
+ fprintf(stderr, ""ODPI: internal error %.*s (%s / %s)\n"",
+ error->buffer->messageLength, error->buffer->message,
+ error->buffer->fnName, action);
 }
 return DPI_FAILURE;
 }
",129,64
"Add support for fractional seconds precision on timestamps and interval day to
second values (https://github.com/oracle/odpi/issues/22) and for additional
metadata on object types and attributes
(https://github.com/oracle/odpi/issues/23)."," int main(int argc, char **argv)
 if (dpiStmt_getQueryInfo(stmt, i + 1, &queryInfo) < 0)
 return dpiSamples_showError();
 printf(""('%.*s', %d, %d, %d, %d, %d, %d)\n"", queryInfo.nameLength,
- queryInfo.name, queryInfo.oracleTypeNum, queryInfo.sizeInChars,
- queryInfo.clientSizeInBytes, queryInfo.precision,
- queryInfo.scale, queryInfo.nullOk);
+ queryInfo.name, queryInfo.typeInfo.oracleTypeNum,
+ queryInfo.typeInfo.sizeInChars,
+ queryInfo.typeInfo.clientSizeInBytes,
+ queryInfo.typeInfo.precision, queryInfo.typeInfo.scale,
+ queryInfo.typeInfo.nullOk);
 }
 
 // clean up
",125,28
Added initial page to document debugging levels.," author = 'Oracle'
 version = '2.0'
 
 # the full version, including alpha/beta/rc tags
-release = '2.0.0-rc.2'
+release = '2.0'
 
 # the theme to use for HTML pages
 html_theme = 'oracle'
",26,3
"Move nullOk back to dpiQueryInfo since it is specific to queries and is
explicitly forbidden in the documentation on object types."," int main(int argc, char **argv)
 queryInfo.typeInfo.sizeInChars,
 queryInfo.typeInfo.clientSizeInBytes,
 queryInfo.typeInfo.precision, queryInfo.typeInfo.scale,
- queryInfo.typeInfo.nullOk);
+ queryInfo.nullOk);
 }
 
 // clean up
",125,28
Preparing to release 2.0.0.," author = 'Oracle'
 version = '2.0'
 
 # the full version, including alpha/beta/rc tags
-release = '2.0'
+release = '2.0.0'
 
 # the theme to use for HTML pages
 html_theme = 'oracle'
",26,3
"Ensure that any allocated statement increments the open child count
(https://github.com/oracle/odpi/issues/27)."," int dpiConn_prepareStmt(dpiConn *conn, int scrollable, const char *sql,
 DPI_CHECK_PTR_NOT_NULL(stmt)
 if (dpiStmt__allocate(conn, scrollable, &tempStmt, &error) < 0)
 return DPI_FAILURE;
- if (dpiConn__incrementOpenChildCount(conn, &error) < 0)
- return DPI_FAILURE;
 if (dpiStmt__prepare(tempStmt, sql, sqlLength, tag, tagLength,
 &error) < 0) {
 dpiStmt__free(tempStmt, &error);
",1056,277
Safer method of converting to uppercase.," static void dpiTestSuite__getEnvValue(const char *envName,
 int convertToUpper)
 {
 const char *source;
+ uint32_t i;
 char *ptr;
 
 source = getenv(envName);
 static void dpiTestSuite__getEnvValue(const char *envName,
 strncpy((char*) *value, source, *valueLength);
 if (convertToUpper) {
 ptr = (char*) *value;
- while (*ptr) {
- *ptr = toupper(*ptr);
- ptr++;
- }
+ for (i = 0; i < *valueLength; i++)
+ ptr[i] = toupper(ptr[i]);
 }
 }
 
",252,42
Destroy the context once the test suite has been run.," int dpiTestSuite_run()
 }
 dpiTestCase__cleanUp(testCase);
 }
+ dpiContext_destroy(gContext);
 fprintf(gTestSuite.logFile, ""%d / %d tests passed\n"", numPassed,
 gTestSuite.numTestCases);
 return gTestSuite.numTestCases - numPassed;
",253,42
"Add one more byte for the null terminator, as suggested by Kubo in issue #29."," static int dpiOci__loadLib(dpiError *error)
 if (!dpiOciLibHandle) {
 oracleHome = getenv(""ORACLE_HOME"");
 if (oracleHome) {
- oracleHomeLibNameLength = strlen(oracleHome) + 5 +
+ oracleHomeLibNameLength = strlen(oracleHome) + 6 +
 strlen(dpiOciLibNames[0]);
 oracleHomeLibName = malloc(oracleHomeLibNameLength);
 if (oracleHomeLibName) {
",1889,253
Correct issues discovered by running valgrind on all test cases.," int dpiTest_309_createReleaseTwice(dpiTestCase *testCase,
 return DPI_FAILURE;
 if (dpiConn_release(conn) < 0)
 return dpiTestCase_setFailedFromError(testCase);
+ testCase->conn = NULL;
 dpiConn_release(conn);
 return dpiTestCase_expectError(testCase,
 ""DPI-1002: invalid dpiConn handle"");
",510,109
"Correct parameter to dpiConn_newSubscription() as noted in issue #28. There is
no OCI documentation for the registration id attribute and it should not be
exposed. The parameter is also deprecated and will be removed in version 2.1
of the ODPI-C API."," void TestCallback(void *context, dpiSubscrMessage *message)
 //-----------------------------------------------------------------------------
 int main(int argc, char **argv)
 {
- uint32_t subscrId, numQueryColumns, i;
 dpiCommonCreateParams commonParams;
 dpiSubscrCreateParams createParams;
+ uint32_t numQueryColumns, i;
 dpiSampleParams *params;
 dpiSubscr *subscr;
 uint64_t queryId;
 int main(int argc, char **argv)
 return dpiSamples_showError();
 createParams.qos = DPI_SUBSCR_QOS_QUERY | DPI_SUBSCR_QOS_ROWIDS;
 createParams.callback = TestCallback;
- if (dpiConn_newSubscription(conn, &createParams, &subscr, &subscrId) < 0)
+ if (dpiConn_newSubscription(conn, &createParams, &subscr, NULL) < 0)
 return dpiSamples_showError();
 
 // register query
",80,14
Preparing to release 2.0.1.," author = 'Oracle'
 version = '2.0'
 
 # the full version, including alpha/beta/rc tags
-release = '2.0.0'
+release = '2.0.1'
 
 # the theme to use for HTML pages
 html_theme = 'oracle'
",26,3
"Ensure that initialization of ODPI-C executes on all platforms before any other
ODPI-C code is executed; introduce a mutex to ensure that extended
initialization can only take place in one thread (eliminate race condition);
add finalization code to cleanup the global OCI environment on normal process
exit.","
 // of all versions of OCI from one driver.
 //-----------------------------------------------------------------------------
 
-#ifdef _WIN32
-#include <windows.h>
-#else
-#include <dlfcn.h>
-#endif
 #include ""dpiImpl.h""
 
 // forward declarations of internal functions only used in this file
",1887,253
"Added support for including the identifier of the thread writing the debugging
message and the date/time that the debugging message was printed; include a new
environment variable DPI_DEBUG_PREFIX that controls what is printed but include
a default (""ODPI [%i] %d %t: "") that is reasonably useful."," int dpiConn__decrementOpenChildCount(dpiConn *conn, dpiError *error)
 return DPI_FAILURE;
 conn->openChildCount--;
 if (dpiDebugLevel & DPI_DEBUG_LEVEL_REFS)
- fprintf(stderr, ""ODPI: open child on conn %p -> %d\n"", conn,
+ dpiDebug__print(""open child on conn %p -> %d\n"", conn,
 conn->openChildCount);
 if (conn->env->threaded &&
 dpiOci__threadMutexRelease(conn->env, error) < 0)
 int dpiConn__incrementOpenChildCount(dpiConn *conn, dpiError *error)
 if (!closing) {
 conn->openChildCount++;
 if (dpiDebugLevel & DPI_DEBUG_LEVEL_REFS)
- fprintf(stderr, ""ODPI: open child on conn %p -> %d\n"", conn,
+ dpiDebug__print(""open child on conn %p -> %d\n"", conn,
 conn->openChildCount);
 }
 if (conn->env->threaded &&
",1055,279
Eliminate pedantic warnings about unchecked results.," void dpiDebug__print(const char *format, ...)
 dpiDebug__getFormatWithPrefix(format, formatWithPrefix,
 sizeof(formatWithPrefix));
 va_start(varArgs, format);
- vfprintf(dpiDebugStream, formatWithPrefix, varArgs);
+ (void) vfprintf(dpiDebugStream, formatWithPrefix, varArgs);
 va_end(varArgs);
 }
 
",90,20
"Eliminate use of OCI wrappers for use of mutexes, which improves performance."," int dpiGen__setRefCount(void *ptr, dpiError *error, int increment)
 
 // if threaded need to protect modification of the refCount with a mutex
 if (value->env->threaded) {
- if (dpiOci__threadMutexAcquire(value->env, error) < 0)
- return DPI_FAILURE;
+ dpiMutex__acquire(value->env->mutex);
 value->refCount += increment;
 localRefCount = value->refCount;
- if (dpiOci__threadMutexRelease(value->env, error) < 0)
- return DPI_FAILURE;
+ dpiMutex__release(value->env->mutex);
 
 // otherwise the count can be incremented normally
 } else {
",169,22
Correct handling of objects when dynamic binding is performed.," int32_t dpiVar__inBindCallback(dpiVar *var, void *bindp, uint32_t iter,
 else *alenp = var->type->sizeInBytes;
 }
 *piecep = DPI_OCI_ONE_PIECE;
- *indpp = &var->indicator[index];
+ if (var->objectIndicator)
+ *indpp = var->objectIndicator[index];
+ else *indpp = &var->indicator[index];
 return DPI_OCI_CONTINUE;
 }
 
 int32_t dpiVar__outBindCallback(dpiVar *var, void *bindp, uint32_t iter,
 *alenpp = &(var->actualLength32[index]);
 } else if (*alenpp && var->type->sizeInBytes)
 **alenpp = var->type->sizeInBytes;
- *indpp = &(var->indicator[index]);
+ if (var->objectIndicator)
+ *indpp = var->objectIndicator[index];
+ else *indpp = &(var->indicator[index]);
 if (var->returnCode)
 *rcodepp = &var->returnCode[index];
 
",1219,355
Bump version now that development has diverged from 2.0.," author = 'Oracle'
 # |release|, also used in various other places throughout the built documents
 #
 # the short X.Y version
-version = '2.0'
+version = '2.1'
 
 # the full version, including alpha/beta/rc tags
-release = '2.0.1'
+release = '2.1.0-dev'
 
 # the theme to use for HTML pages
 html_theme = 'oracle'
",26,3
Process deregistration events without an error.," static int dpiSubscr__populateMessage(dpiSubscr *subscr,
 case DPI_EVENT_QUERYCHANGE:
 return dpiSubscr__populateQueryChangeMessage(subscr, message,
 descriptor, error);
+ case DPI_EVENT_DEREG:
+ subscr->handle = NULL;
+ break;
 default:
 return dpiError__set(error, ""event type"", DPI_ERR_NOT_SUPPORTED);
 }
",358,101
Eliminate memory leak when calling dpiObjectType_createObject().," int dpiObjectType_createObject(dpiObjectType *objType, dpiObject **obj)
 dpiGen__setRefCount(tempObj, &error, -1);
 return DPI_FAILURE;
 }
+ tempObj->isIndependent = 1;
 
 // get the null indicator structure
 if (dpiOci__objectGetInd(tempObj, &error) < 0) {
",197,44
"Remove function dpiLob_flushBuffer() since it will always result in failure
without the call to enable LOB buffering (which is not exposed)."," int dpiLob_copy(dpiLob *lob, dpiLob **copiedLob)
 }
 
 
-//-----------------------------------------------------------------------------
-// dpiLob_flushBuffer() [PUBLIC]
-// Flush the buffers.
-//-----------------------------------------------------------------------------
-int dpiLob_flushBuffer(dpiLob *lob)
-{
- dpiError error;
-
- if (dpiLob__check(lob, __func__, &error) < 0)
- return DPI_FAILURE;
- return dpiOci__lobFlushBuffer(lob, &error);
-}
-
-
 //-----------------------------------------------------------------------------
 // dpiLob_getBufferSize() [PUBLIC]
 // Get the required size of a buffer given the number of characters. If the
",270,70
"Prevent use of unitialized data in certain cases
(https://github.com/oracle/python-cx_Oracle/issues/77)."," int dpiData__toOracleNumberFromText(dpiData *data, dpiEnv *env,
 prependZero = (decimalPointIndex > 0 && decimalPointIndex % 2 == 1) ||
 (decimalPointIndex < 0 && decimalPointIndex % 2 == -1);
 if (prependZero && numDigits != 0) {
- numDigits++;
+ digits[numDigits++] = 0;
 decimalPointIndex++;
 }
 
",431,85
"Added support for accessing sharding databases by the use of sharding keys
(new in Oracle 12.2)."," int dpiPool_acquireConnection(dpiPool *pool, const char *userName,
 dpiConnCreateParams *params, dpiConn **conn)
 {
 dpiConnCreateParams localParams;
+ size_t structSize;
 dpiError error;
 
 // validate parameters
 int dpiPool_acquireConnection(dpiPool *pool, const char *userName,
 DPI_CHECK_PTR_NOT_NULL(conn)
 
 // use default parameters if none provided
- if (!params) {
+ if (!params || pool->env->context->dpiMinorVersion == 0) {
 if (dpiContext__initConnCreateParams(pool->env->context, &localParams,
- &error) < 0)
+ &structSize, &error) < 0)
 return DPI_FAILURE;
+ if (params)
+ memcpy(&localParams, params, structSize);
 params = &localParams;
 }
 
",280,69
"Add support for converting numeric values in an object type attribute to
integer and text (https://github.com/oracle/odpi/issues/35)."," static int dpiObject__fromOracleValue(dpiObject *obj, dpiError *error,
 if (nativeTypeNum == DPI_NATIVE_TYPE_DOUBLE)
 return dpiDataBuffer__fromOracleNumberAsDouble(&data->value,
 obj->env, error, value->asNumber);
+ else if (nativeTypeNum == DPI_NATIVE_TYPE_INT64)
+ return dpiDataBuffer__fromOracleNumberAsInteger(&data->value,
+ obj->env, error, value->asNumber);
+ else if (nativeTypeNum == DPI_NATIVE_TYPE_UINT64)
+ return dpiDataBuffer__fromOracleNumberAsUnsignedInteger(
+ &data->value, obj->env, error, value->asNumber);
+ else if (nativeTypeNum == DPI_NATIVE_TYPE_BYTES)
+ return dpiDataBuffer__fromOracleNumberAsText(&data->value,
+ obj->env, error, value->asNumber);
 break;
 case DPI_ORACLE_TYPE_DATE:
 if (nativeTypeNum == DPI_NATIVE_TYPE_TIMESTAMP)
",544,147
"Added debugging initialization message, as suggested."," void dpiDebug__initialize(void)
 
 // messages are written to stderr
 dpiDebugStream = stderr;
+
+ // for any debugging level > 0 print a message indicating that tracing
+ // has started
+ if (dpiDebugLevel)
+ dpiDebug__print(""debugging messages initialized at level %lu\n"",
+ dpiDebugLevel);
 }
 
 
",96,23
Added some more test cases to the test suite.," int dpiTest_1800_verifyEnqAndDeqWorksAsExp(dpiTestCase *testCase,
 attrValue.value.asBytes.length, books[i].title,
 strlen(books[i].title)) < 0)
 return dpiTestCase_setFailedFromError(testCase);
- if (dpiObject_getAttributeValue(deqBook, attrs[1], 
+ if (dpiObject_getAttributeValue(deqBook, attrs[1],
 DPI_NATIVE_TYPE_BYTES, &attrValue) < 0)
 return dpiTestCase_setFailedFromError(testCase);
 if (dpiTestCase_expectStringEqual(testCase,
",368,121
"Print the ODPI-C version for all trace output. Mention binds are not
displayed."," void dpiDebug__initialize(void)
 
 // for any debugging level > 0 print a message indicating that tracing
 // has started
- if (dpiDebugLevel)
+ if (dpiDebugLevel) {
+ dpiDebug__print(""ODPI-C %s\n"", DPI_VERSION_STRING);
 dpiDebug__print(""debugging messages initialized at level %lu\n"",
 dpiDebugLevel);
+}
 }
 
 
",98,23
"Attempting to ping a database earlier than 10g results in ORA-1010: invalid OCI
operation, but that implies a response from the database and therefore a
successful ping, so treat it that way!
(see https://github.com/rana/ora/issues/224 for additional information)"," int dpiOci__ping(dpiConn *conn, dpiError *error)
 DPI_OCI_LOAD_SYMBOL(""OCIPing"", dpiOciSymbols.fnPing)
 status = (*dpiOciSymbols.fnPing)(conn->handle, error->handle,
 DPI_OCI_DEFAULT);
- return dpiError__check(error, status, conn, ""ping"");
+ status = dpiError__check(error, status, conn, ""ping"");
+
+ // attempting to ping a database earlier than 10g will result in error
+ // ORA-1010: invalid OCI operation, but that implies a successful ping
+ // so ignore that error and treat it as a successful operation
+ if (status < 0 && error->buffer->code == 1010)
+ return DPI_SUCCESS;
+
+ return status;
 }
 
 
",1844,251
"Some values represented as double do not convert perfectly to float; use
FLT_EPSILON to check the difference between the two after conversion, rather
than expect the values to convert perfectly."," static int dpiObject__toOracleValue(dpiObject *obj, dpiError *error,
 dpiOracleTypeNum valueOracleTypeNum;
 uint32_t handleType;
 dpiObject *otherObj;
+ float floatDiff;
 dpiBytes *bytes;
 
 // nulls are handled easily
 static int dpiObject__toOracleValue(dpiObject *obj, dpiError *error,
 return DPI_SUCCESS;
 } else if (nativeTypeNum == DPI_NATIVE_TYPE_DOUBLE) {
 buffer->asFloat = (float) data->value.asDouble;
- if (buffer->asFloat != data->value.asDouble)
+ floatDiff = data->value.asDouble - buffer->asFloat;
+ if ((floatDiff > 0 && floatDiff > FLT_EPSILON) ||
+ (floatDiff < 0 && -floatDiff > FLT_EPSILON))
 return dpiError__set(error, ""to Oracle value"",
 DPI_ERR_OVERFLOW, ""float"");
 *ociValue = &buffer->asFloat;
",547,150
"Prevent use of NaN with Oracle numbers since it produces corrupt data
(https://github.com/oracle/python-cx_Oracle/issues/91)."," int dpiDataBuffer__toOracleIntervalYM(dpiDataBuffer *data, dpiEnv *env,
 int dpiDataBuffer__toOracleNumberFromDouble(dpiDataBuffer *data, dpiEnv *env,
 dpiError *error, void *oracleValue)
 {
- return dpiOci__numberFromReal(env, data->asDouble, oracleValue,
- error);
+ if (isnan(data->asDouble))
+ return dpiError__set(error, ""convert double to Oracle number"",
+ DPI_ERR_NAN);
+ return dpiOci__numberFromReal(env, data->asDouble, oracleValue, error);
 }
 
 
",434,92
Remove trailing lines; replace tabs with spaces.," static void dpiSamples__getEnvValue(const char *envName,
 char *ptr;
 
 source = getenv(envName);
- if (!source) 
+ if (!source)
 source = defaultValue;
 *valueLength = strlen(source);
 *value = malloc(*valueLength);
",91,15
"Remove unused parameters and add __atribute((unused)) for mandatory parameters
in callbacks which are unused (for the gcc compiler), as requested
(https://github.com/oracle/odpi/issues/39)."," static int dpiLob__close(dpiLob *lob, int propagateErrors, dpiError *error)
 }
 dpiOci__descriptorFree(lob->locator, DPI_OCI_DTYPE_LOB);
 lob->locator = NULL;
- dpiConn__decrementOpenChildCount(lob->conn, error);
+ dpiConn__decrementOpenChildCount(lob->conn);
 }
 if (lob->conn) {
 dpiGen__setRefCount(lob->conn, error, -1);
",270,70
"A connection created using an external handle should not have any OCI calls
made against it to close the session with the database."," static int dpiConn__close(dpiConn *conn, int mode, const char *tag,
 if (dpiOci__transRollback(conn, propagateErrors, error) < 0)
 return DPI_FAILURE;
 
+ // handle connections created with an external handle
+ if (conn->externalHandle) {
+ conn->sessionHandle = NULL;
+
 // handle standalone connections
- if (conn->standalone) {
+ } else if (conn->standalone) {
 
 // end session and free session handle
 if (dpiOci__sessionEnd(conn, propagateErrors, error) < 0)
",1162,307
"Added function that gets calls any time a public function ends, corresponding
to the function that gets called any time a public function starts. Besides
permitting logging of both entry and exit of public functions, it also allows
for the replacement of OCI thread key code with a thread-safe error handle
pool. This is needed due to bugs in the OCI library."," int dpiError__check(dpiError *error, int status, dpiConn *conn,
 
 // fetch OCI error
 error->buffer->action = action;
- strcpy(error->buffer->encoding, error->encoding);
- if (dpiOci__errorGet(error->handle, DPI_OCI_HTYPE_ERROR, action,
- error) < 0)
+ strcpy(error->buffer->encoding, error->env->encoding);
+ if (dpiOci__errorGet(error->handle, DPI_OCI_HTYPE_ERROR,
+ error->env->charsetId, action, error) < 0)
 return DPI_FAILURE;
 if (dpiDebugLevel & DPI_DEBUG_LEVEL_ERRORS)
 dpiDebug__print(""OCI error %.*s (%s / %s)\n"",
",129,64
"Even though the values are identical, use DPI_OCI_ERROR to be consistent."," int32_t dpiVar__defineCallback(dpiVar *var, UNUSED void *defnp, uint32_t iter,
 bytes = &var->dynamicBytes[iter];
 if (bytes->numChunks == bytes->allocatedChunks &&
 dpiVar__allocateChunks(bytes, var->error) < 0)
- return DPI_FAILURE;
+ return DPI_OCI_ERROR;
 
 // allocate memory for the chunk, if needed
 chunk = &bytes->chunks[bytes->numChunks];
",1254,356
"Added suport for MERGE statements, as requested
(https://github.com/oracle/odpi/issues/40)."," int dpiStmt_getInfo(dpiStmt *stmt, dpiStmtInfo *info)
 stmt->statementType == DPI_STMT_TYPE_ALTER);
 info->isDML = (stmt->statementType == DPI_STMT_TYPE_INSERT ||
 stmt->statementType == DPI_STMT_TYPE_UPDATE ||
- stmt->statementType == DPI_STMT_TYPE_DELETE);
+ stmt->statementType == DPI_STMT_TYPE_DELETE ||
+ stmt->statementType == DPI_STMT_TYPE_MERGE);
 info->statementType = stmt->statementType;
 info->isReturning = stmt->isReturning;
 return dpiGen__endPublicFn(stmt, DPI_SUCCESS, &error);
",1176,334
"Added support for the case when the time zone minute offset is negative
(https://github.com/oracle/odpi/issues/38)."," int main(int argc, char **argv)
 dpiQueryInfo queryInfo;
 dpiStmt *stmt;
 dpiConn *conn;
+ char sign;
 int found;
 
 // connect to database
 int main(int argc, char **argv)
 timestamp->hour, timestamp->minute, timestamp->second,
 timestamp->fsecond);
 if (queryInfo.typeInfo.oracleTypeNum ==
- DPI_ORACLE_TYPE_TIMESTAMP_TZ)
- printf("" %+.2d:%.2d"", timestamp->tzHourOffset,
- timestamp->tzMinuteOffset);
+ DPI_ORACLE_TYPE_TIMESTAMP_TZ) {
+ sign = (timestamp->tzHourOffset < 0 ||
+ timestamp->tzMinuteOffset < 0) ? '-' : '+';
+ printf("" %c%.2d:%.2d"", sign, abs(timestamp->tzHourOffset),
+ abs(timestamp->tzMinuteOffset));
+ }
 printf(""\n"");
 }
 }
",67,16
"Verify that objects bound to cursors or set in object attributes or appended to
collection objects are of the correct type."," static int dpiObject__toOracleValue(dpiObject *obj, dpiError *error,
 case DPI_ORACLE_TYPE_OBJECT:
 otherObj = data->value.asObject;
 if (nativeTypeNum == DPI_NATIVE_TYPE_OBJECT) {
+ if (otherObj->type->tdo != dataTypeInfo->objectType->tdo)
+ return dpiError__set(error, ""check type"",
+ DPI_ERR_WRONG_TYPE, otherObj->type->schemaLength,
+ otherObj->type->schema, otherObj->type->nameLength,
+ otherObj->type->name,
+ dataTypeInfo->objectType->schemaLength,
+ dataTypeInfo->objectType->schema,
+ dataTypeInfo->objectType->nameLength,
+ dataTypeInfo->objectType->name);
 *ociValue = otherObj->instance;
 *objectIndicator = otherObj->indicator;
 return DPI_SUCCESS;
",589,151
"Added support for memory allocation debugging for ODPI-C functions and the OCI
functions that they use."," void dpiConn__free(dpiConn *conn, dpiError *error)
 conn->env = NULL;
 }
 if (conn->releaseString) {
- free((void*) conn->releaseString);
+ dpiUtils__freeMemory((void*) conn->releaseString);
 conn->releaseString = NULL;
 }
- free(conn);
+ dpiUtils__freeMemory(conn);
 }
 
 
 int dpiConn__getServerVersion(dpiConn *conn, dpiError *error)
 error) < 0)
 return DPI_FAILURE;
 conn->releaseStringLength = (uint32_t) strlen(buffer);
- conn->releaseString = (const char*) malloc(conn->releaseStringLength);
- if (!conn->releaseString)
- return dpiError__set(error, ""allocate release string"",
- DPI_ERR_NO_MEMORY);
+ if (dpiUtils__allocateMemory(1, conn->releaseStringLength, 0,
+ ""allocate release string"", (void**) &conn->releaseString,
+ error) < 0)
+ return DPI_FAILURE;
 strncpy( (char*) conn->releaseString, buffer, conn->releaseStringLength);
 conn->versionInfo.versionNum = (int)((serverRelease >> 24) & 0xFF);
 conn->versionInfo.releaseNum = (int)((serverRelease >> 20) & 0x0F);
",1214,307
"Object attributes use type DPI_SQLT_VCS instead of DPI_SQLT_CHR, so ensure that
type is also examined for the charset form (aka NVARCHAR2)
(https://github.com/oracle/odpi/issues/45)."," int dpiOracleType__populateTypeInfo(dpiConn *conn, void *handle,
 // acquire character set form
 if (info->ociTypeCode != DPI_SQLT_CHR &&
 info->ociTypeCode != DPI_SQLT_AFC &&
+ info->ociTypeCode != DPI_SQLT_VCS &&
 info->ociTypeCode != DPI_SQLT_CLOB)
 charsetForm = DPI_SQLCS_IMPLICIT;
 else if (dpiOci__attrGet(handle, handleType, (void*) &charsetForm, 0,
",435,75
"Move logging statement to before the free so that there are no spurious cases
where the logging suggests that memory has been allocated before it is freed!"," void dpiUtils__clearMemory(void *ptr, size_t length)
 //-----------------------------------------------------------------------------
 void dpiUtils__freeMemory(void *ptr)
 {
- free(ptr);
 if (dpiDebugLevel & DPI_DEBUG_LEVEL_MEM)
 dpiDebug__print(""freed ptr at %p\n"", ptr);
+ free(ptr);
 }
 
 
",220,78
"Adjustments to test suite to:
- ensure that the ""expected"" value is where it should be in all ""expect""
 functions
- ensure that all output is written to stderr and flushed to avoid ordering
 issues due to buffering
- add concept of ""skipped"" tests and make use of it to skip tests which require
 a particular version (or higher) of the client or database"," int dpiTest_303_createExternal(dpiTestCase *testCase, dpiTestParams *params)
 return dpiTestCase_setFailedFromError(testCase);
 if (dpiStmt_getQueryValue(stmt, 1, &nativeTypeNum, &data) < 0)
 return dpiTestCase_setFailedFromError(testCase);
- if (dpiTestCase_expectUintEqual(testCase, count, data->value.asUint64) < 0)
+ if (dpiTestCase_expectUintEqual(testCase, data->value.asUint64, count) < 0)
 return DPI_FAILURE;
 
 dpiStmt_release(stmt);
",509,109
"Ensure context is freed in samples and ODPI-C error buffer is cleared upon
process exit."," static void dpiSamples__fatalError(const char *message)
 }
 
 
+//-----------------------------------------------------------------------------
+// dpiSamples__finalize() [INTERNAL]
+// Destroy context upon process exit.
+//-----------------------------------------------------------------------------
+static void dpiSamples__finalize(void)
+{
+ dpiContext_destroy(gContext);
+}
+
+
 //-----------------------------------------------------------------------------
 // dpiSamples__getEnvValue()
 // Get parameter value from the environment or use supplied default value if
 dpiSampleParams *dpiSamples_getParams(void)
 errorInfo.message, errorInfo.fnName, errorInfo.action);
 dpiSamples__fatalError(""Cannot create DPI context."");
 }
+ atexit(dpiSamples__finalize);
 }
 
 dpiSamples__getEnvValue(""ODPIC_SAMPLES_MAIN_USER"", ""odpicdemo"",
",96,16
"Restrict variables of type DPI_NATIVE_TYPE_BYTES to 2 bytes less than 1 GB
(1,073,741,822 bytes) since OCI cannot handle more than that currently."," int dpiVar_setFromBytes(dpiVar *var, uint32_t pos, const char *value,
 dpiError__set(&error, ""native type"", DPI_ERR_NOT_SUPPORTED);
 return dpiGen__endPublicFn(var, DPI_FAILURE, &error);
 }
+ if (valueLength > DPI_MAX_VAR_BUFFER_SIZE) {
+ dpiError__set(&error, ""check buffer"", DPI_ERR_BUFFER_SIZE_TOO_LARGE,
+ valueLength, DPI_MAX_VAR_BUFFER_SIZE);
+ return dpiGen__endPublicFn(var, DPI_FAILURE, &error);
+ }
 status = dpiVar__setFromBytes(var, pos, value, valueLength, &error);
 return dpiGen__endPublicFn(var, status, &error);
 }
",1259,360
Correct setting of message id properties.," int dpiDeqOptions_setMsgId(dpiDeqOptions *options, const char *value,
 &rawValue, &error) < 0)
 return dpiGen__endPublicFn(options, DPI_FAILURE, &error);
 status = dpiOci__attrSet(options->handle, DPI_OCI_DTYPE_AQDEQ_OPTIONS,
- (void*) rawValue, valueLength, DPI_OCI_ATTR_DEQ_MSGID, ""set value"",
- &error);
+ (void*) &rawValue, valueLength, DPI_OCI_ATTR_DEQ_MSGID,
+ ""set value"", &error);
 dpiOci__rawResize(options->env->handle, &rawValue, 0, &error);
 return dpiGen__endPublicFn(options, status, &error);
 }
",227,40
"Remove overflow check. It wasn't working correctly anyway and is a well-known
issue that cannot be prevented without removing desired functionality. The
developer should ensure that the source value falls within the limits of
floats, understand the consequent precision loss, or use a different data type."," static int dpiObject__toOracleValue(dpiObject *obj, dpiError *error,
 dpiOracleTypeNum valueOracleTypeNum;
 uint32_t handleType;
 dpiObject *otherObj;
- float floatDiff;
 dpiBytes *bytes;
 
 // nulls are handled easily
 static int dpiObject__toOracleValue(dpiObject *obj, dpiError *error,
 return DPI_SUCCESS;
 } else if (nativeTypeNum == DPI_NATIVE_TYPE_DOUBLE) {
 buffer->asFloat = (float) data->value.asDouble;
- floatDiff = data->value.asDouble - buffer->asFloat;
- if ((floatDiff > 0 && floatDiff > FLT_EPSILON) ||
- (floatDiff < 0 && -floatDiff > FLT_EPSILON))
- return dpiError__set(error, ""to Oracle value"",
- DPI_ERR_OVERFLOW, ""float"");
 *ociValue = &buffer->asFloat;
 return DPI_SUCCESS;
 }
",583,147
Eliminate warnings raised by Parfait (static source code analyzer).," static void dpiDebug__getFormatWithPrefix(const char *format,
 char *formatWithPrefix, size_t maxFormatWithPrefixSize)
 {
 char *sourcePtr, *targetPtr;
- size_t size, tempSize;
+ int gotTime, tempSize;
 uint64_t threadId;
- int gotTime;
+ size_t size;
 #ifdef _WIN32
 SYSTEMTIME time;
 #else
 void dpiDebug__initialize(void)
 // valid integer, it is ignored
 envValue = getenv(""DPI_DEBUG_LEVEL"");
 if (envValue)
- dpiDebugLevel = strtol(envValue, NULL, 10);
+ dpiDebugLevel = (unsigned long) strtol(envValue, NULL, 10);
 
 // determine the value of the environment variable DPI_DEBUG_PREFIX and
 // store it in the static buffer available for it; a static buffer is used
",98,23
"Add error message for case when an edition is specified and so is a connection
class, rather than simply allow OCI to silently ignore the combination."," int dpiConn_create(const dpiContext *context, const char *userName,
 return dpiGen__endPublicFn(context, DPI_FAILURE, &error);
 }
 
+ // connectionClass and edition cannot be specified at the same time
+ if (createParams->connectionClass &&
+ createParams->connectionClassLength > 0 &&
+ commonParams->edition && commonParams->editionLength > 0) {
+ dpiError__set(&error, ""check edition/conn class"",
+ DPI_ERR_NO_EDITION_WITH_CONN_CLASS);
+ return dpiGen__endPublicFn(context, DPI_FAILURE, &error);
+ }
+
 // handle case where pool is specified
 if (createParams->pool) {
 if (dpiGen__checkHandle(createParams->pool, DPI_HTYPE_POOL,
",1221,311
"Ensure that no attempts are made to release statements or free LOBs if the
connection has already been closed, as for example when a session has been
killed."," static int dpiLob__close(dpiLob *lob, int propagateErrors, dpiError *error)
 int isTemporary;
 
 if (lob->locator) {
- if (dpiOci__lobIsTemporary(lob, &isTemporary, propagateErrors,
- error) < 0)
- return DPI_FAILURE;
- if (isTemporary) {
- if (dpiOci__lobFreeTemporary(lob, propagateErrors, error) < 0)
+ if (!lob->conn->dropSession && lob->conn->handle &&
+ !lob->conn->closing) {
+ if (dpiOci__lobIsTemporary(lob, &isTemporary, propagateErrors,
+ error) < 0)
 return DPI_FAILURE;
+ if (isTemporary) {
+ if (dpiOci__lobFreeTemporary(lob, propagateErrors, error) < 0)
+ return DPI_FAILURE;
+ }
 }
 dpiOci__descriptorFree(lob->locator, DPI_OCI_DTYPE_LOB);
 lob->locator = NULL;
",300,73
Restore dpiLob_flushBuffer() in order to avoid breaking semantic versioning.," int dpiLob_copy(dpiLob *lob, dpiLob **copiedLob)
 }
 
 
+//-----------------------------------------------------------------------------
+// dpiLob_flushBuffer() [PUBLIC]
+// No longer supported. Will be dropped in version 3. Should not be called.
+//-----------------------------------------------------------------------------
+int dpiLob_flushBuffer(dpiLob *lob)
+{
+ dpiError error;
+
+ if (dpiLob__check(lob, __func__, 0, &error) < 0)
+ return DPI_FAILURE;
+ dpiError__set(&error, ""not supported"", DPI_ERR_NOT_SUPPORTED);
+ return dpiGen__endPublicFn(lob, DPI_FAILURE, &error);
+}
+
+
 //-----------------------------------------------------------------------------
 // dpiLob_getBufferSize() [PUBLIC]
 // Get the required size of a buffer given the number of characters. If the
",308,75
Added additional test cases for connection properties.," void dpiTestSuite_initialize(uint32_t minTestCaseId)
 &params->proxyUserName, &params->proxyUserNameLength, 1);
 dpiTestSuite__getEnvValue(""ODPIC_TEST_PROXY_PASSWORD"", ""welcome"",
 &params->proxyPassword, &params->proxyPasswordLength, 0);
+ dpiTestSuite__getEnvValue(""ODPIC_TEST_EDITION_USER"", ""odpic_edition"",
+ &params->editionUserName, &params->editionUserNameLength, 1);
+ dpiTestSuite__getEnvValue(""ODPIC_TEST_EDITION_PASSWORD"", ""welcome"",
+ &params->editionPassword, &params->editionPasswordLength, 0);
 dpiTestSuite__getEnvValue(""ODPIC_TEST_CONNECT_STRING"", ""localhost/orclpdb"",
 &params->connectString, &params->connectStringLength, 0);
 dpiTestSuite__getEnvValue(""ODPIC_TEST_DIR_NAME"", ""odpic_dir"",
 &params->dirName, &params->dirNameLength, 1);
+ dpiTestSuite__getEnvValue(""ODPIC_TEST_EDITION_NAME"", ""odpic_e1"",
+ &params->editionName, &params->editionNameLength, 1);
 
 if (dpiContext_create(DPI_MAJOR_VERSION, DPI_MINOR_VERSION, &gContext,
 &errorInfo) < 0) {
",349,60
Correct logic for stripping trailing carriage return and period.," static void dpiOci__getLoadErrorOnWindows(const char *dllName,
 length = wcslen(wLoadError);
 while (length > 0) {
 if (wLoadError[length - 1] > 127 ||
- wLoadError[length - 1] != L'.' ||
- !isspace(wLoadError[length - 1]))
+ (wLoadError[length - 1] != L'.' &&
+ !isspace(wLoadError[length - 1])))
 break;
 length--;
 }
",1973,287
"Do not free the sharding key descriptor when using a standalone connection in
order to avoid a bug in the OCI libraries."," int dpiConn__get(dpiConn *conn, const char *userName, uint32_t userNameLength,
 // get a session from the pool
 status = dpiConn__getSession(conn, mode, connectString,
 connectStringLength, createParams, authInfo, error);
- if (status == DPI_SUCCESS) {
+ if (status == DPI_SUCCESS && pool) {
 if (shardingKey)
 dpiOci__descriptorFree(shardingKey, DPI_OCI_DTYPE_SHARDING_KEY);
 if (superShardingKey)
",1247,321
"Subscription port number is found on the environment handle, not on the
subscription handle (https://github.com/oracle/python-cx_Oracle/issues/115)."," int dpiSubscr__create(dpiSubscr *subscr, dpiConn *conn,
 return DPI_FAILURE;
 
 // set the port number used on the client to listen for events
- if (params->portNumber > 0 && dpiOci__attrSet(subscr->handle,
- DPI_OCI_HTYPE_SUBSCRIPTION, (void*) &params->portNumber, 0,
+ if (params->portNumber > 0 && dpiOci__attrSet(subscr->env->handle,
+ DPI_OCI_HTYPE_ENV, (void*) &params->portNumber, 0,
 DPI_OCI_ATTR_SUBSCR_PORTNO, ""set port number"", error) < 0)
 return DPI_FAILURE;
 
",369,102
Preparing to release ODPI-C 2.1.," author = 'Oracle'
 version = '2.1'
 
 # the full version, including alpha/beta/rc tags
-release = '2.1.0-dev'
+release = '2.1.0'
 
 # the theme to use for HTML pages
 html_theme = 'oracle'
",26,3
"Since rowid is returned as a handle, the size in bytes and characters was
simply being returned as the size of a pointer; set these values to 0 instead
as is done with other handles that are returned; also add test for urowid
columns."," author = 'Oracle'
 version = '2.1'
 
 # the full version, including alpha/beta/rc tags
-release = '2.1.0'
+release = '2.1.1'
 
 # the theme to use for HTML pages
 html_theme = 'oracle'
",26,3
Silence uninitialization warnings from some compilers.," static int dpiConn__setShardingKeyValue(dpiConn *conn, void *shardingKey,
 const dpiOracleType *oracleType;
 dpiOciNumber numberValue;
 dpiOciDate dateValue;
+ uint32_t colLen = 0;
+ void *col = NULL;
 uint16_t colType;
- uint32_t colLen;
 int convertOk;
- void *col;
 
 oracleType = dpiOracleType__getFromNum(column->oracleTypeNum, error);
 if (!oracleType)
",1247,321
"Eliminate ""dead store"" (unnecessary code)."," int dpiUtils__parseNumberString(const char *value, uint32_t valueLength,
 }
 
 // handle exponent, if applicable
- exponent = 0;
 if (value < endValue && (*value == 'e' || *value == 'E')) {
 value++;
 exponentIsNegative = 0;
",219,78
"Introduce simplified embedding of ODPI-C source; bump version to 2.2.0-dev as
this begins the introduction of new features."," author = 'Oracle'
 # |release|, also used in various other places throughout the built documents
 #
 # the short X.Y version
-version = '2.1'
+version = '2.2'
 
 # the full version, including alpha/beta/rc tags
-release = '2.1.1'
+release = '2.2.0-dev'
 
 # the theme to use for HTML pages
 html_theme = 'oracle'
",26,3
"Use cast to avoid assertions with isspace() when using debug libraries on
Windows (https://github.com/oracle/odpi/issues/52).","
 //-----------------------------------------------------------------------------
-// Copyright (c) 2017 Oracle and/or its affiliates. All rights reserved.
+// Copyright (c) 2017-2018 Oracle and/or its affiliates. All rights reserved.
 // This program is free software: you can modify it and/or redistribute it
 // under the terms of:
 //
 int dpiOci__errorGet(void *handle, uint32_t handleType, uint16_t charsetId,
 error->buffer->messageLength =
 (uint32_t) strlen(error->buffer->message);
 ptr = error->buffer->message + error->buffer->messageLength - 1;
- while (ptr > error->buffer->message && isspace(*ptr--))
+ while (ptr > error->buffer->message && isspace((uint8_t) *ptr--))
 error->buffer->messageLength--;
 }
 
",1974,287
"Keep track of open statements and LOBs and automatically close them when the
connection is closed, which eliminates the need for users of the driver from
doing so and removes the error ""DPI-1054: connection cannot be closed when open
statements or LOBs exist""."," int dpiPool__acquireConnection(dpiPool *pool, const char *userName,
 return DPI_FAILURE;
 
 // create the connection
- if (dpiConn__get(tempConn, userName, userNameLength, password,
- passwordLength, pool->name, pool->nameLength, params, pool,
- error) < 0) {
+ if (dpiConn__create(tempConn, pool->env->context, userName, userNameLength,
+ password, passwordLength, pool->name, pool->nameLength, pool,
+ NULL, params, error) < 0) {
 dpiConn__free(tempConn, error);
 return DPI_FAILURE;
 }
",290,66
"The reference to the connection on statements and LOBs must reamin valid even
after the statements and LOBs have been closed, as the connection holds the
reference to the OCI environment handle (used for OCI error handles); ensure
that attempts to close statements and LOBs independently cannot take place
simultaneously; validate the statement and LOB handles stored on the connection
before attempting to close them, since otherwise the statement or LOB might
actually be freed under certain circumstances."," int dpiVar__extendedPreFetch(dpiVar *var, dpiError *error)
 dpiStmt__free(stmt, error);
 return DPI_FAILURE;
 }
+ if (dpiHandleList__addHandle(var->conn->openStmts, stmt,
+ &stmt->openSlotNum, error) < 0) {
+ dpiOci__handleFree(stmt->handle, DPI_OCI_HTYPE_STMT);
+ stmt->handle = NULL;
+ dpiStmt__free(stmt, error);
+ return DPI_FAILURE;
+ }
 var->references[i].asStmt = stmt;
 stmt->isOwned = 1;
 var->data.asStmt[i] = stmt->handle;
",1269,362
"Ignore failures that occur during rollback, but if an error does occur, ensure
that it is dropped from the pool. Such failures are generally due to an
inability to communicate with the server (such as when your session has been
killed)."," static int dpiConn__close(dpiConn *conn, uint32_t mode, const char *tag,
 dpiLob *lob;
 int status;
 
- // rollback any outstanding transaction
+ // rollback any outstanding transaction, set dropSession flag if any errors
 if (dpiOci__transRollback(conn, propagateErrors, error) < 0)
- return DPI_FAILURE;
+ conn->dropSession = 1;
 
 // close all open statements; note that no references are retained by the
 // handle list (otherwise all statements would be left open until an
",1282,329
"Eliminate a race condition with reference counts and simplify the code for
managing reference counts."," static int dpiConn__get(dpiConn *conn, const char *userName,
 
 // set things up for the call to acquire a session
 if (pool) {
- if (dpiGen__setRefCount(pool, error, 1) < 0)
- return DPI_FAILURE;
+ dpiGen__setRefCount(pool, error, 1);
 conn->pool = pool;
 mode = DPI_OCI_SESSGET_SPOOL;
 externalAuth = pool->externalAuth;
",1281,328
"When closing statements and LOBs due to a connection being closed, ignore any
invalid handle errors."," static int dpiConn__close(dpiConn *conn, uint32_t mode, const char *tag,
 continue;
 if (conn->env->threaded) {
 dpiMutex__acquire(conn->env->mutex);
- status = dpiGen__checkHandle(stmt, DPI_HTYPE_STMT,
- ""close stmt by conn"", error);
+ status = dpiGen__checkHandle(stmt, DPI_HTYPE_STMT, NULL, NULL);
 if (status == DPI_SUCCESS)
 stmt->refCount += 1;
 dpiMutex__release(conn->env->mutex);
 static int dpiConn__close(dpiConn *conn, uint32_t mode, const char *tag,
 continue;
 if (conn->env->threaded) {
 dpiMutex__acquire(conn->env->mutex);
- status = dpiGen__checkHandle(lob, DPI_HTYPE_LOB,
- ""close LOB by conn"", error);
+ status = dpiGen__checkHandle(lob, DPI_HTYPE_LOB, NULL, NULL);
 if (status == DPI_SUCCESS)
 lob->refCount += 1;
 dpiMutex__release(conn->env->mutex);
",1279,328
"No need to store context values for 12.2 and higher (which doesn't require the
pool ping logic due to improvmeents in Oracle Client)."," static int dpiConn__close(dpiConn *conn, uint32_t mode, const char *tag,
 
 // if the session isn't marked as needing to be dropped, update the
 // last time used (this is checked when the session is acquired)
- if (!conn->dropSession && conn->sessionHandle) {
+ // NOTE: this is only needed for clients earlier than 12.2
+ if (!conn->dropSession && conn->sessionHandle &&
+ (conn->env->versionInfo->versionNum < 12 ||
+ (conn->env->versionInfo->versionNum == 12 &&
+ conn->env->versionInfo->releaseNum < 2))) {
 
 // get the pointer from the context
 lastTimeUsed = NULL;
",1282,331
"Avoid printing the result of a pointer after it is freed (to make static
analysis tools happy)."," int dpiOci__rawSize(void *envHandle, void *handle, uint32_t *size)
 //-----------------------------------------------------------------------------
 static void *dpiOci__reallocMem(void *unused, void *ptr, size_t newSize)
 {
+ char message[80];
 void *newPtr;
 
+ (void) sprintf(message, ""OCI reallocated ptr at %p"", ptr);
 newPtr = realloc(ptr, newSize);
- dpiDebug__print(""OCI reallocated ptr at %p to %u bytes at %p\n"", ptr,
- newSize, newPtr);
+ dpiDebug__print(""%s to %u bytes at %p\n"", message, newSize, newPtr);
 return newPtr;
 }
 
",1975,287
Add casts to satisfy pickier compilers.," static int dpiConn__close(dpiConn *conn, uint32_t mode, const char *tag,
 // close all open LOBs; the same comments apply as for statements
 if (conn->openLobs) {
 for (i = 0; i < conn->openLobs->numSlots; i++) {
- lob = conn->openLobs->handles[i];
+ lob = (dpiLob*) conn->openLobs->handles[i];
 if (!lob)
 continue;
 if (conn->env->threaded) {
",1291,335
"Rename ""dropSession"" to ""deadSession"" to eliminate potential confusion."," int dpiError__check(dpiError *error, int status, dpiConn *conn,
 
 // check for certain errors which indicate that the session is dead and
 // should be dropped from the session pool (if a session pool was used)
- if (conn && !conn->dropSession) {
+ if (conn && !conn->deadSession) {
 switch (error->buffer->code) {
 case 22: // invalid session ID; access denied
 case 28: // your session has been killed
 int dpiError__check(dpiError *error, int status, dpiConn *conn,
 case 27146: // post/wait initialization failed
 case 28511: // lost RPC connection
 case 56600: // an illegal OCI function call was issued
- conn->dropSession = 1;
+ conn->deadSession = 1;
 break;
 }
 }
",130,64
"Ensure that the LOB locator returned from the attribute or element is not used
directly as freeing it will result in unexpected behavior when the object
containing it is itself freed."," static int dpiObject__fromOracleValue(dpiObject *obj, dpiError *error,
 case DPI_ORACLE_TYPE_BLOB:
 case DPI_ORACLE_TYPE_BFILE:
 if (nativeTypeNum == DPI_NATIVE_TYPE_LOB) {
+ const dpiOracleType *lobType;
+ void *tempLocator;
 dpiLob *tempLob;
- if (dpiGen__allocate(DPI_HTYPE_LOB, obj->env,
- (void**) &tempLob, error) < 0)
+ lobType = dpiOracleType__getFromNum(typeInfo->oracleTypeNum,
+ error);
+ if (dpiLob__allocate(obj->type->conn, lobType, &tempLob,
+ error) < 0)
 return DPI_FAILURE;
- dpiGen__setRefCount(obj->type->conn, error, 1);
- tempLob->conn = obj->type->conn;
- tempLob->type = dpiOracleType__getFromNum(
- typeInfo->oracleTypeNum, error);
+ tempLocator = tempLob->locator;
 tempLob->locator = *(value->asLobLocator);
+ if (dpiOci__lobLocatorAssign(tempLob, &tempLocator,
+ error) < 0) {
+ tempLob->locator = tempLocator;
+ dpiLob__free(tempLob, error);
+ return DPI_FAILURE;
+ }
+ tempLob->locator = tempLocator;
 data->value.asLOB = tempLob;
 return DPI_SUCCESS;
 }
",585,146
"Protect global variables on destruction as well since dpiGlobal__finalize() may
not be the last method that is called if other methods are registered with
atexit()."," static void dpiGlobal__finalize(void)
 void *errorBuffer = NULL;
 dpiError error;
 
+ dpiMutex__acquire(dpiGlobalMutex);
+ dpiGlobalInitialized = 0;
 error.buffer = &dpiGlobalErrorBuffer;
 if (dpiGlobalThreadKey) {
 dpiOci__threadKeyGet(dpiGlobalEnvHandle, dpiGlobalErrorHandle,
 static void dpiGlobal__finalize(void)
 dpiOci__handleFree(dpiGlobalEnvHandle, DPI_OCI_HTYPE_ENV);
 dpiGlobalEnvHandle = NULL;
 }
- dpiMutex__destroy(dpiGlobalMutex);
- dpiGlobalInitialized = 0;
+ dpiMutex__release(dpiGlobalMutex);
 }
 
 
",155,34
"Make a copy of any objects that are acquired from other objects (either as
attributes or elements of collections) in order to prevent possible use of the
object acquired in such a fashion after the object it came from has been freed."," int dpiOci__numberToReal(double *value, void *number, dpiError *error)
 // dpiOci__objectCopy() [INTERNAL]
 // Wrapper for OCIObjectCopy().
 //-----------------------------------------------------------------------------
-int dpiOci__objectCopy(dpiObject *obj, dpiObject *copiedObj, dpiError *error)
+int dpiOci__objectCopy(dpiObject *obj, void *sourceInstance,
+ void *sourceIndicator, dpiError *error)
 {
 int status;
 
 DPI_OCI_LOAD_SYMBOL(""OCIObjectCopy"", dpiOciSymbols.fnObjectCopy)
 status = (*dpiOciSymbols.fnObjectCopy)(obj->env->handle, error->handle,
- obj->type->conn->handle, obj->instance, obj->indicator,
- copiedObj->instance, copiedObj->indicator, obj->type->tdo,
+ obj->type->conn->handle, sourceInstance, sourceIndicator,
+ obj->instance, obj->indicator, obj->type->tdo,
 DPI_OCI_DURATION_SESSION, DPI_OCI_DEFAULT);
 return dpiError__check(error, status, obj->type->conn, ""copy object"");
 }
",1979,287
Ensure that the number of used slots is decremented when a handle is removed.," void dpiHandleList__removeHandle(dpiHandleList *list, uint32_t slotNum)
 {
 dpiMutex__acquire(list->mutex);
 list->handles[slotNum] = NULL;
+ list->numUsedSlots--;
 dpiMutex__release(list->mutex);
 }
 
",72,13
Preparing to release ODPI-C 2.2.," author = 'Oracle'
 version = '2.2'
 
 # the full version, including alpha/beta/rc tags
-release = '2.2.0-dev'
+release = '2.2.0'
 
 # the theme to use for HTML pages
 html_theme = 'oracle'
",26,3
"Maintain a reference to the ""parent"" object and use the actual object instance
instead of a copy, so that ""child"" objects can be manipulated in-place instead
of having to be created externally and then set (attributes) or appended (for
collections).","
 # -*- coding: utf-8 -*-
 
 #------------------------------------------------------------------------------
-# Copyright (c) 2016, 2017 Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2016-2018 Oracle and/or its affiliates. All rights reserved.
 # This program is free software: you can modify it and/or redistribute it
 # under the terms of:
 #
 master_doc = 'index'
 
 # general information about the project
 project = 'ODPI-C'
-copyright = '2016, 2017 Oracle and/or its affiliates. All rights reserved.'
+copyright = '2016-2018 Oracle and/or its affiliates. All rights reserved.'
 author = 'Oracle'
 
 # the version info for the project, acts as replacement for |version| and
 author = 'Oracle'
 version = '2.2'
 
 # the full version, including alpha/beta/rc tags
-release = '2.2.0'
+release = '2.2.1'
 
 # the theme to use for HTML pages
 html_theme = 'oracle'
",26,3
Eliminate memory leak when calling dpiConn_deqObject() and dpiConn_enqObject().," int dpiConn_deqObject(dpiConn *conn, const char *queueName,
 }
 return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
 }
- dpiOci__rawPtr(conn->env->handle, ociMsgId, (void**) msgId);
- dpiOci__rawSize(conn->env->handle, ociMsgId, msgIdLength);
+ if (dpiMsgProps__extractMsgId(props, ociMsgId, msgId, msgIdLength,
+ &error) < 0)
+ return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
 return dpiGen__endPublicFn(conn, DPI_SUCCESS, &error);
 }
 
 int dpiConn_enqObject(dpiConn *conn, const char *queueName,
 payload->type->tdo, &payload->instance, &payload->indicator,
 &ociMsgId, &error) < 0)
 return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
- dpiOci__rawPtr(conn->env->handle, ociMsgId, (void**) msgId);
- dpiOci__rawSize(conn->env->handle, ociMsgId, msgIdLength);
+ if (dpiMsgProps__extractMsgId(props, ociMsgId, msgId, msgIdLength,
+ &error) < 0)
+ return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
 return dpiGen__endPublicFn(conn, DPI_SUCCESS, &error);
 }
 
",1293,337
"Ensure that NCHAR and NVARCHAR2 values are cleared as well as regular CHAR and
VARCHAR2 values."," static void dpiObject__clearOracleValue(dpiEnv *env, dpiError *error,
 {
 switch (oracleTypeNum) {
 case DPI_ORACLE_TYPE_CHAR:
+ case DPI_ORACLE_TYPE_NCHAR:
 case DPI_ORACLE_TYPE_VARCHAR:
+ case DPI_ORACLE_TYPE_NVARCHAR:
 if (buffer->asString)
 dpiOci__stringResize(env->handle, &buffer->asString, 0, error);
 break;
",610,155
"Collections use out-of-line indicators when they are fetched from the database,
so make sure they are freed as well as the instance itself."," int dpiOci__objectFree(dpiObject *obj, dpiError *error)
 DPI_OCI_LOAD_SYMBOL(""OCIObjectFree"", dpiOciSymbols.fnObjectFree)
 (*dpiOciSymbols.fnObjectFree)(obj->env->handle, error->handle,
 obj->instance, DPI_OCI_DEFAULT);
+ if (obj->freeIndicator)
+ (*dpiOciSymbols.fnObjectFree)(obj->env->handle, error->handle,
+ obj->indicator, DPI_OCI_DEFAULT);
 return DPI_SUCCESS;
 }
 
",1982,288
"Prevent internal re-execution of statement from duplicating itself in the list
of open statements maintained on the connection."," static int dpiStmt__reExecute(dpiStmt *stmt, uint32_t numIters,
 // so that it does not return with the invalid metadata; again, if this
 // cannot be done, let the original error propagate
 origHandle = stmt->handle;
- status = dpiStmt__prepare(stmt, sql, sqlLength, NULL, 0, &localError);
+ status = dpiOci__stmtPrepare2(stmt, sql, sqlLength, NULL, 0, &localError);
 newHandle = stmt->handle;
 stmt->handle = origHandle;
 stmt->deleteFromCache = 1;
",1197,342
erify that the subscription is open before permitting it to be used.," author = 'Oracle'
 version = '2.2'
 
 # the full version, including alpha/beta/rc tags
-release = '2.2.1'
+release = '2.2.2'
 
 # the theme to use for HTML pages
 html_theme = 'oracle'
",26,3
"Edition is not supported (effectively the edition value is ignored) when
specifying a new password, so add a specific error for that situation to avoid
potential confusion."," int dpiConn_create(const dpiContext *context, const char *userName,
 return dpiGen__endPublicFn(context, DPI_FAILURE, &error);
 }
 
+ // newPassword and edition cannot be specified at the same time
+ if (createParams->newPassword && createParams->newPasswordLength > 0 &&
+ commonParams->edition && commonParams->editionLength > 0) {
+ dpiError__set(&error, ""check edition/new password"",
+ DPI_ERR_NO_EDITION_WITH_NEW_PASSWORD);
+ return dpiGen__endPublicFn(context, DPI_FAILURE, &error);
+ }
+
 // handle case where pool is specified
 if (createParams->pool) {
 if (dpiGen__checkHandle(createParams->pool, DPI_HTYPE_POOL,
",1299,341
Avoid getting query metadata if only parsing the SQL.," static int dpiStmt__execute(dpiStmt *stmt, uint32_t numIters,
 
 // create query variables (if applicable)
 if (stmt->statementType == DPI_STMT_TYPE_SELECT &&
+ !(mode & DPI_MODE_EXEC_PARSE_ONLY) &&
 dpiStmt__createQueryVars(stmt, error) < 0)
 return DPI_FAILURE;
 
",1198,343
"The ""iter"" parameter is the one that identifies the iteration being executed,
not the ""index"" parameter -- this corrects binding long data (> 32KB) when
calling dpiStmt_executeMany()."," int32_t dpiVar__inBindCallback(dpiVar *var, UNUSED void *bindp,
 dpiDynamicBytes *dynBytes;
 
 if (var->isDynamic) {
- dynBytes = &var->dynamicBytes[index];
+ dynBytes = &var->dynamicBytes[iter];
 if (dynBytes->allocatedChunks == 0) {
 *bufpp = NULL;
 *alenp = 0;
 int32_t dpiVar__inBindCallback(dpiVar *var, UNUSED void *bindp,
 *alenp = dynBytes->chunks->length;
 }
 } else {
- dpiVar__assignCallbackBuffer(var, index, bufpp);
+ dpiVar__assignCallbackBuffer(var, iter, bufpp);
 if (var->actualLength16)
- *alenp = var->actualLength16[index];
+ *alenp = var->actualLength16[iter];
 else if (var->actualLength32)
- *alenp = var->actualLength32[index];
+ *alenp = var->actualLength32[iter];
 else *alenp = var->type->sizeInBytes;
 }
 *piecep = DPI_OCI_ONE_PIECE;
 if (var->objectIndicator)
- *indpp = var->objectIndicator[index];
- else *indpp = &var->indicator[index];
+ *indpp = var->objectIndicator[iter];
+ else *indpp = &var->indicator[iter];
 return DPI_OCI_CONTINUE;
 }
 
",1266,362
"Improve error message when older OCI client libraries are being used that don't
have the method OCIClientVersion()."," static int dpiOci__loadLib(dpiError *error)
 static int dpiOci__loadLibValidate(dpiError *error)
 {
 // determine the OCI client version information
- DPI_OCI_LOAD_SYMBOL(""OCIClientVersion"", dpiOciSymbols.fnClientVersion)
+ if (dpiOci__loadSymbol(""OCIClientVersion"",
+ (void**) &dpiOciSymbols.fnClientVersion, NULL) < 0)
+ return dpiError__set(error, ""get client version"",
+ DPI_ERR_LIBRARY_TOO_OLD);
 (*dpiOciSymbols.fnClientVersion)(&dpiOciLibVersionInfo.versionNum,
 &dpiOciLibVersionInfo.releaseNum,
 &dpiOciLibVersionInfo.updateNum,
",1985,289
"Correct the handling of ANSI types REAL and DOUBLE PRECISION as implemented by
Oracle. These types are just subtypes of NUMBER and are not actually stored as
native floating point numbers. Native floating point numbers are used with
Oracle types BINARY_FLOAT and BINARY_DOUBLE
(https://github.com/oracle/python-cx_Oracle/issues/163)."," static dpiOracleTypeNum dpiOracleType__convertFromOracle(uint16_t typeCode,
 case DPI_SQLT_FLT:
 case DPI_SQLT_NUM:
 case DPI_SQLT_VNU:
+ case DPI_SQLT_BFLOAT:
+ case DPI_SQLT_BDOUBLE:
 return DPI_ORACLE_TYPE_NUMBER;
 case DPI_SQLT_DAT:
 case DPI_SQLT_ODT:
 static dpiOracleTypeNum dpiOracleType__convertFromOracle(uint16_t typeCode,
 case DPI_SQLT_INT:
 case DPI_OCI_TYPECODE_SMALLINT:
 return DPI_ORACLE_TYPE_NATIVE_INT;
- case DPI_SQLT_BFLOAT:
 case DPI_SQLT_IBFLOAT:
 return DPI_ORACLE_TYPE_NATIVE_FLOAT;
- case DPI_SQLT_BDOUBLE:
 case DPI_SQLT_IBDOUBLE:
 return DPI_ORACLE_TYPE_NATIVE_DOUBLE;
 case DPI_SQLT_DATE:
",431,74
"Corrected suport for getting the OUT values of bind variables bound to a DML
returning statement when calling dpiStmt_executeMany()."," author = 'Oracle'
 # |release|, also used in various other places throughout the built documents
 #
 # the short X.Y version
-version = '2.2'
+version = '2.3'
 
 # the full version, including alpha/beta/rc tags
-release = '2.2.2'
+release = '2.3.0-dev'
 
 # the theme to use for HTML pages
 html_theme = 'oracle'
",26,3
"Check that the return value from OCI functions matches the expected value of
OCI_ERROR or OCI_NO_DATA, and if not, raise an error including the value that
was actually returned."," int dpiError__check(dpiError *error, int status, dpiConn *conn,
 return DPI_FAILURE;
 else if (!error->handle)
 return dpiError__set(error, action, DPI_ERR_ERR_NOT_INITIALIZED);
+ else if (status != DPI_OCI_ERROR && status != DPI_OCI_NO_DATA)
+ return dpiError__set(error, action,
+ DPI_ERR_UNEXPECTED_OCI_RETURN_VALUE, status,
+ error->buffer->fnName);
 
 // fetch OCI error
 error->buffer->action = action;
",134,66
Preparing to release ODPI-C 2.3.," author = 'Oracle'
 version = '2.3'
 
 # the full version, including alpha/beta/rc tags
-release = '2.3.0-dev'
+release = '2.3.0'
 
 # the theme to use for HTML pages
 html_theme = 'oracle'
",26,3
"Add error message indicating that modes DPI_MODE_EXEC_BATCH_ERRORS and
DPI_MODE_EXEC_ARRAY_DML_ROWCOUNTS are only supported with insert, update,
delete and merge statements."," author = 'Oracle'
 version = '2.3'
 
 # the full version, including alpha/beta/rc tags
-release = '2.3.0'
+release = '2.3.1'
 
 # the theme to use for HTML pages
 html_theme = 'oracle'
",26,3
Correct comment (https://github.com/oracle/odpi/issues/61).," static int dpiStmt__execute(dpiStmt *stmt, uint32_t numIters,
 var->error = error;
 }
 
- // for queries, set the prefetch rows to the fetch array size in order to
- // avoid the network round trip for the first fetch
+ // for queries, set the OCI prefetch to a fixed value; this prevents an
+ // additional round trip for single row fetches while avoiding the overhead
+ // of copying from the OCI prefetch buffer to our own buffers for larger
+ // fetches
 if (stmt->statementType == DPI_STMT_TYPE_SELECT) {
 prefetchSize = DPI_PREFETCH_ROWS_DEFAULT;
 if (dpiOci__attrSet(stmt->handle, DPI_OCI_HTYPE_STMT, &prefetchSize,
",1204,348
"Return the actual array size, not the maximum array size, since the maximum
array size can increase on subsequent executions of a DML returning statement."," int dpiVar_getReturnedData(dpiVar *var, uint32_t pos, uint32_t *numElements,
 DPI_CHECK_PTR_NOT_NULL(var, numElements)
 DPI_CHECK_PTR_NOT_NULL(var, data)
 if (var->dynBindBuffers) {
- *numElements = var->dynBindBuffers[pos].maxArraySize;
+ *numElements = var->dynBindBuffers[pos].actualArraySize;
 *data = var->dynBindBuffers[pos].externalData;
 } else {
 *numElements = 0;
",1324,374
"Do not attempt to unregister a subscription until after it has been registered;
otherwise, any errors encountered in registration are masked by the error that
the subscription has not been registered! In addition, free the handle."," int dpiSubscr__create(dpiSubscr *subscr, dpiConn *conn,
 // register the subscription
 if (dpiOci__subscriptionRegister(conn, &subscr->handle, error) < 0)
 return DPI_FAILURE;
+ subscr->registered = 1;
 
 // get the registration id, if applicable
 if (subscrId && dpiOci__attrGet(subscr->handle, DPI_OCI_HTYPE_SUBSCRIPTION,
 int dpiSubscr__create(dpiSubscr *subscr, dpiConn *conn,
 void dpiSubscr__free(dpiSubscr *subscr, dpiError *error)
 {
 if (subscr->handle) {
- dpiOci__subscriptionUnRegister(subscr, error);
+ if (subscr->registered)
+ dpiOci__subscriptionUnRegister(subscr, error);
+ dpiOci__handleFree(subscr->handle, DPI_OCI_HTYPE_SUBSCRIPTION);
 subscr->handle = NULL;
 }
 if (subscr->conn) {
",380,107
Add support for true heterogeneous session pools.," static int dpiConn__get(dpiConn *conn, const char *userName,
 externalAuth = pool->externalAuth;
 if (userName && pool->homogeneous)
 return dpiError__set(error, ""check proxy"", DPI_ERR_INVALID_PROXY);
- if (userName)
+
+ // if the userName is provided but no password is provided and external
+ // authentication is not being used, proxy authentication is taking
+ // place
+ if (userName && !password && !externalAuth)
 mode |= DPI_OCI_SESSGET_CREDPROXY;
 if (createParams->matchAnyTag)
 mode |= DPI_OCI_SESSGET_SPOOL_MATCHANY;
",1299,343
Use proper error message now that it is no longer masked.," int dpiTest_2200_verifyNewSubscriptionWithCallBkNULL(dpiTestCase *testCase,
 dpiTestParams *params)
 {
 const char *expectedError =
- ""ORA-29970: Specified registration id does not exist"";
+ ""ORA-24904: invalid callback attribute passed into OCI call"";
 dpiCommonCreateParams commonParams;
 dpiSubscrCreateParams subParams;
 dpiContext *context;
",57,11
"Ensure that a call to unregister a subscription only occurs if the subscription
is still registered."," author = 'Oracle'
 # |release|, also used in various other places throughout the built documents
 #
 # the short X.Y version
-version = '2.3'
+version = '2.4'
 
 # the full version, including alpha/beta/rc tags
-release = '2.3.1'
+release = '2.4.0'
 
 # the theme to use for HTML pages
 html_theme = 'oracle'
",26,3
Added test cases for executing DML returning statements.,"
 extern char **environ;
 #endif
 
-#define NUM_EXECUTABLES 24
+#define NUM_EXECUTABLES 25
 
 static const char *dpiTestNames[NUM_EXECUTABLES] = {
 ""TestContext"",
 static const char *dpiTestNames[NUM_EXECUTABLES] = {
 ""TestRowIds"",
 ""TestScrollCursors"",
 ""TestSubscriptions"",
- ""TestBatchErrors""
+ ""TestBatchErrors"",
+ ""TestDMLReturning""
 };
 
 
",100,15
Silence warning about missing space for a trailing NULL which is not used.," static void dpiTestSuite__getEnvValue(const char *envName,
 *value = malloc(*valueLength);
 if (!*value)
 dpiTestSuite__fatalError(""Out of memory!"");
- strncpy((char*) *value, source, *valueLength);
+ memcpy((void*) *value, source, *valueLength);
 if (convertToUpper) {
 ptr = (char*) *value;
 for (i = 0; i < *valueLength; i++)
",349,60
"Ensure that before each execution dynamic buffers for DML returning are set to
zero since the out bind callback is not called if no rows are returned!"," static int dpiStmt__execute(dpiStmt *stmt, uint32_t numIters,
 DPI_ERR_NOT_SUPPORTED);
 if (dpiVar__setValue(var, &var->buffer, j, data, error) < 0)
 return DPI_FAILURE;
+ if (var->dynBindBuffers)
+ var->dynBindBuffers[j].actualArraySize = 0;
 }
 if (stmt->isReturning || var->isDynamic)
 var->error = error;
",1206,349
Added support for grouping events for subscriptions.," int dpiConn_create(const dpiContext *context, const char *userName,
 dpiCommonCreateParams localCommonParams;
 dpiConnCreateParams localCreateParams;
 dpiConn *tempConn;
- size_t structSize;
 dpiError error;
 int status;
 
 int dpiConn_create(const dpiContext *context, const char *userName,
 commonParams = &localCommonParams;
 }
 if (!createParams || context->dpiMinorVersion == 0) {
- dpiContext__initConnCreateParams(context, &localCreateParams,
- &structSize);
+ dpiContext__initConnCreateParams(&localCreateParams);
 if (createParams)
- memcpy(&localCreateParams, createParams, structSize);
+ memcpy(&localCreateParams, createParams,
+ sizeof(dpiConnCreateParams__v20));
 createParams = &localCreateParams;
 }
 
",1298,343
"Added support for specifying the IP address the subscription should use instead
of having the Oracle Client libraries determine the IP address on its own."," int dpiSubscr__create(dpiSubscr *subscr, dpiConn *conn,
 DPI_OCI_ATTR_SUBSCR_TIMEOUT, ""set timeout"", error) < 0)
 return DPI_FAILURE;
 
+ // set the IP address used on the client to listen for events
+ if (params->ipAddress && params->ipAddressLength > 0 &&
+ dpiOci__attrSet(subscr->env->handle, DPI_OCI_HTYPE_ENV,
+ (void*) params->ipAddress, params->ipAddressLength,
+ DPI_OCI_ATTR_SUBSCR_IPADDR, ""set IP address"", error) < 0)
+ return DPI_FAILURE;
+
 // set the port number used on the client to listen for events
 if (params->portNumber > 0 && dpiOci__attrSet(subscr->env->handle,
 DPI_OCI_HTYPE_ENV, (void*) &params->portNumber, 0,
",409,115
"Added support for the pool ""get"" mode of timed wait; added support for setting
the maximum lifetime session and timeout parameters when creating the pool."," int dpiContext_initConnCreateParams(const dpiContext *context,
 int dpiContext_initPoolCreateParams(const dpiContext *context,
 dpiPoolCreateParams *params)
 {
+ dpiPoolCreateParams localParams;
 dpiError error;
 
 if (dpiGen__startPublicFn(context, DPI_HTYPE_CONTEXT, __func__, 0,
 &error) < 0)
 return dpiGen__endPublicFn(context, DPI_FAILURE, &error);
 DPI_CHECK_PTR_NOT_NULL(context, params)
- dpiContext__initPoolCreateParams(params);
+ if (context->dpiMinorVersion > 3)
+ dpiContext__initPoolCreateParams(params);
+ else {
+ dpiContext__initPoolCreateParams(&localParams);
+ memcpy(params, &localParams, sizeof(dpiPoolCreateParams__v23));
+ }
 return dpiGen__endPublicFn(context, DPI_SUCCESS, &error);
 }
 
",162,33
"Correct handling of other descriptors (rowids and statements) when used in DML
returning statements."," static void dpiVar__assignCallbackBuffer(dpiVar *var, dpiVarBuffer *buffer,
 case DPI_ORACLE_TYPE_BFILE:
 *bufpp = buffer->data.asLobLocator[index];
 break;
+ case DPI_ORACLE_TYPE_ROWID:
+ *bufpp = buffer->data.asRowid[index];
+ break;
+ case DPI_ORACLE_TYPE_STMT:
+ *bufpp = buffer->data.asStmt[index];
+ break;
 default:
 *bufpp = buffer->data.asBytes + index * var->sizeInBytes;
 break;
",1330,376
"Added support for subscriptions to AQ queues and reworked methods for creating
and destroying subscriptions in order to make the API clearer in light of the
fact that a different connection can be used to unsubscribe from events than
was used for subscribing to the events in the first place."," int dpiOci__subscriptionRegister(dpiConn *conn, void **handle, dpiError *error)
 // dpiOci__subscriptionUnRegister() [INTERNAL]
 // Wrapper for OCISubscriptionUnRegister().
 //-----------------------------------------------------------------------------
-int dpiOci__subscriptionUnRegister(dpiSubscr *subscr, dpiError *error)
+int dpiOci__subscriptionUnRegister(dpiConn *conn, dpiSubscr *subscr,
+ dpiError *error)
 {
 int status;
 
 DPI_OCI_LOAD_SYMBOL(""OCISubscriptionUnRegister"",
 dpiOciSymbols.fnSubscriptionUnRegister)
- status = (*dpiOciSymbols.fnSubscriptionUnRegister)(subscr->conn->handle,
+ status = (*dpiOciSymbols.fnSubscriptionUnRegister)(conn->handle,
 subscr->handle, error->handle, DPI_OCI_DEFAULT);
- return dpiError__check(error, status, subscr->conn, ""unregister"");
+ return dpiError__check(error, status, conn, ""unregister"");
 }
 
 
",1994,289
Prevent attempts to bind PL/SQL array variables with dpiStmt_executeMany().," static int dpiStmt__execute(dpiStmt *stmt, uint32_t numIters,
 // buffer structures
 for (i = 0; i < stmt->numBindVars; i++) {
 var = stmt->bindVars[i].var;
+ if (var->isArray && numIters > 1)
+ return dpiError__set(error, ""bind array var"",
+ DPI_ERR_ARRAY_VAR_NOT_SUPPORTED);
 for (j = 0; j < var->buffer.maxArraySize; j++) {
 data = &var->buffer.externalData[j];
 if (var->type->oracleTypeNum == DPI_ORACLE_TYPE_STMT &&
",1214,355
"Provide better error message when events mode is not enabled in the database
and an attempt is made to create a subscription."," int dpiConn_subscribe(dpiConn *conn, dpiSubscrCreateParams *params,
 return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
 DPI_CHECK_PTR_NOT_NULL(conn, params)
 DPI_CHECK_PTR_NOT_NULL(conn, subscr)
+ if (!conn->env->events) {
+ dpiError__set(&error, ""subscribe"", DPI_ERR_EVENTS_MODE_REQUIRED);
+ return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
+ }
 if (dpiGen__allocate(DPI_HTYPE_SUBSCR, conn->env, (void**) &tempSubscr,
 &error) < 0)
 return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
",1337,353
Bump version to 3.0 and remove deprecated functions.," author = 'Oracle'
 # |release|, also used in various other places throughout the built documents
 #
 # the short X.Y version
-version = '2.4'
+version = '3.0'
 
 # the full version, including alpha/beta/rc tags
-release = '2.4.0'
+release = '3.0.0-dev'
 
 # the theme to use for HTML pages
 html_theme = 'oracle'
",26,3
"Even when dequeue fails OCI still provides a message id so make sure it is
deallocated to avoid a memory leak."," int dpiConn_deqObject(dpiConn *conn, const char *queueName,
 payload->type->tdo, &payload->instance, &payload->indicator,
 &ociMsgId, &error) < 0) {
 if (error.buffer->code == 25228) {
+ if (ociMsgId)
+ dpiOci__rawResize(conn->env->handle, &ociMsgId, 0, &error);
 *msgId = NULL;
 *msgIdLength = 0;
 return dpiGen__endPublicFn(conn, DPI_SUCCESS, &error);
",1317,348
"If the statement should be deleted from the cache, first check to see that
there is a cache currently being used; otherwise, the error ""ORA-24300: bad
value for mode"" will be raised."," int dpiOci__stmtPrepare2(dpiStmt *stmt, const char *sql, uint32_t sqlLength,
 int dpiOci__stmtRelease(dpiStmt *stmt, const char *tag, uint32_t tagLength,
 int checkError, dpiError *error)
 {
- uint32_t mode;
- int status;
+ uint32_t mode = DPI_OCI_DEFAULT;
+ uint32_t cacheSize = 0;
+ int status;
+
+ // if the statement should be deleted from the cache, first check to see
+ // that there actually is a cache currently being used; otherwise, the
+ // error ""ORA-24300: bad value for mode"" will be raised
+ if (stmt->deleteFromCache) {
+ dpiOci__attrGet(stmt->conn->handle, DPI_OCI_HTYPE_SVCCTX,
+ &cacheSize, NULL, DPI_OCI_ATTR_STMTCACHESIZE, NULL, error);
+ if (cacheSize > 0)
+ mode = DPI_OCI_STRLS_CACHE_DELETE;
+ }
 
 DPI_OCI_LOAD_SYMBOL(""OCIStmtRelease"", dpiOciSymbols.fnStmtRelease)
- mode = (stmt->deleteFromCache) ? DPI_OCI_STRLS_CACHE_DELETE :
- DPI_OCI_DEFAULT;
 status = (*dpiOciSymbols.fnStmtRelease)(stmt->handle, error->handle, tag,
 tagLength, mode);
 if (checkError)
",1999,290
"Avoid buffer overrun due to improper calculation of length
(https://github.com/oracle/odpi/issues/67)."," int dpiDataBuffer__toOracleNumberFromText(dpiDataBuffer *data, dpiEnv *env,
 decimalPointIndex++;
 }
 
- // append a sentinel 102 byte for negative numbers if there is room
- appendSentinel = (isNegative && numDigits < DPI_NUMBER_MAX_DIGITS);
-
 // determine the number of digit pairs; if the number of digits is odd,
 // append a zero to make the number of digits even
 if (numDigits % 2 == 1)
 digits[numDigits++] = 0;
 numPairs = numDigits / 2;
 
+ // append a sentinel 102 byte for negative numbers if there is room
+ appendSentinel = (isNegative && numDigits < DPI_NUMBER_MAX_DIGITS);
+
 // initialize the OCINumber value
 // the length is the number of pairs, plus one for the exponent
 // include an extra byte for the sentinel if applicable
",435,94
"Use plain integers instead of enumerations in order to simplify code and reduce
the requirement for casts."," int dpiPool_getEncodingInfo(dpiPool *pool, dpiEncodingInfo *info)
 //-----------------------------------------------------------------------------
 int dpiPool_getGetMode(dpiPool *pool, dpiPoolGetMode *value)
 {
- uint8_t ociValue;
 dpiError error;
 
 if (dpiPool__checkConnected(pool, __func__, &error) < 0)
 return dpiGen__endPublicFn(pool, DPI_FAILURE, &error);
 DPI_CHECK_PTR_NOT_NULL(pool, value)
- if (dpiOci__attrGet(pool->handle, DPI_OCI_HTYPE_SPOOL, &ociValue, NULL,
+ if (dpiOci__attrGet(pool->handle, DPI_OCI_HTYPE_SPOOL, value, NULL,
 DPI_OCI_ATTR_SPOOL_GETMODE, ""get attribute value"", &error) < 0)
 return dpiGen__endPublicFn(pool, DPI_FAILURE, &error);
- *value = (dpiPoolGetMode) ociValue;
 return dpiGen__endPublicFn(pool, DPI_SUCCESS, &error);
 }
 
",335,85
"Added support for verifying that the client and database versions are at a
minimum version."," int dpiVar__allocate(dpiConn *conn, dpiOracleTypeNum oracleTypeNum,
 return dpiError__set(error, ""check can be in array"",
 DPI_ERR_NOT_SUPPORTED);
 if (oracleTypeNum == DPI_ORACLE_TYPE_BOOLEAN &&
- conn->env->versionInfo->versionNum < 12)
- return dpiError__set(error, ""check boolean"", DPI_ERR_NOT_SUPPORTED);
+ dpiUtils__checkClientVersion(conn->env->versionInfo, 12, 1,
+ error) < 0)
+ return DPI_FAILURE;
 if (nativeTypeNum != type->defaultNativeTypeNum) {
 if (dpiVar__validateTypes(type, nativeTypeNum, error) < 0)
 return DPI_FAILURE;
",1315,373
"Check for the version 18 client library now that they are available and add a
check for the version 19 client libraries as well in preparation for the
version 19 release."," static const char *dpiOciLibNames[] = {
 ""oci.dll"",
 #elif __APPLE__
 ""libclntsh.dylib"",
+ ""libclntsh.dylib.18.1"",
 ""libclntsh.dylib.12.1"",
 ""libclntsh.dylib.11.1"",
+ ""libclntsh.dylib.19.1"",
 #else
 ""libclntsh.so"",
+ ""libclntsh.so.18.1"",
 ""libclntsh.so.12.1"",
 ""libclntsh.so.11.1"",
+ ""libclntsh.so.19.1"",
 #endif
 NULL
 };
",2019,293
"Add support for getting the full version from Oracle Database 18+ since the
means of doing so changed in version 18."," int dpiTest_416_verifygetLTXIDWorksAsExp(dpiTestCase *testCase,
 int dpiTest_417_verifyGetServerVersionWorksAsExp(dpiTestCase *testCase,
 dpiTestParams *params)
 {
- const char *sql = ""select version from product_component_version ""
+ const char *sql = ""select version_full from product_component_version ""
+ ""where product like 'Oracle Database%'"";
+ const char *sqlPre18 = ""select version from product_component_version ""
 ""where product like 'Oracle Database%'"";
 uint32_t bufferRowIndex, releaseStringLength;
 dpiNativeTypeNum nativeTypeNum;
 int dpiTest_417_verifyGetServerVersionWorksAsExp(dpiTestCase *testCase,
 versionInfo.versionNum, versionInfo.releaseNum,
 versionInfo.updateNum, versionInfo.portReleaseNum,
 versionInfo.portUpdateNum);
+ if (versionInfo.versionNum < 18)
+ sql = sqlPre18;
 if (dpiConn_prepareStmt(conn, 0, sql, strlen(sql), NULL, 0, &stmt) < 0)
 return dpiTestCase_setFailedFromError(testCase);
 if (dpiStmt_execute(stmt, DPI_MODE_EXEC_DEFAULT, NULL) < 0)
",441,104
"Added support for the packed decimal type, used by object attributes with
historical types DECIMAL and NUMERIC
(https://github.com/oracle/python-cx_Oracle/issues/212)."," static dpiOracleTypeNum dpiOracleType__convertFromOracle(uint16_t typeCode,
 return DPI_ORACLE_TYPE_VARCHAR;
 case DPI_SQLT_FLT:
 case DPI_SQLT_NUM:
+ case DPI_SQLT_PDN:
 case DPI_SQLT_VNU:
 case DPI_SQLT_BFLOAT:
 case DPI_SQLT_BDOUBLE:
",432,75
"In addition to checking if the connection is closed, also check to see if the
pool that the connection was acquired from has been closed, if applicable.
This improves the error message that is returned."," static int dpiConn__checkConnected(dpiConn *conn, const char *fnName,
 {
 if (dpiGen__startPublicFn(conn, DPI_HTYPE_CONN, fnName, 1, error) < 0)
 return DPI_FAILURE;
- if (!conn->handle || conn->closing)
+ if (!conn->handle || conn->closing || (conn->pool && !conn->pool->handle))
 return dpiError__set(error, ""check connected"", DPI_ERR_NOT_CONNECTED);
 return DPI_SUCCESS;
 }
",1346,352
"Clear the pool handle immediately so that no further attempts are made to use
the pool while the pool is being closed; if the pool close fails, restore the
pool handle afterwards."," int dpiOci__sessionPoolCreate(dpiPool *pool, const char *connectString,
 int dpiOci__sessionPoolDestroy(dpiPool *pool, uint32_t mode, int checkError,
 dpiError *error)
 {
+ void *handle;
 int status;
 
 DPI_OCI_LOAD_SYMBOL(""OCISessionPoolDestroy"",
 dpiOciSymbols.fnSessionPoolDestroy)
- status = (*dpiOciSymbols.fnSessionPoolDestroy)(pool->handle, error->handle,
+
+ // clear the pool handle immediately so that no further attempts are made
+ // to use the pool while the pool is being closed; if the pool close fails,
+ // restore the pool handle afterwards
+ handle = pool->handle;
+ pool->handle = NULL;
+ status = (*dpiOciSymbols.fnSessionPoolDestroy)(handle, error->handle,
 mode);
- if (checkError)
- return dpiError__check(error, status, NULL, ""destroy pool"");
+ if (checkError &&
+ dpiError__check(error, status, NULL, ""destroy pool"") < 0) {
+ pool->handle = handle;
+ return DPI_FAILURE;
+ }
+ dpiOci__handleFree(handle, DPI_OCI_HTYPE_SPOOL);
 return DPI_SUCCESS;
 }
 
",2040,295
"Ensure that the connection is open for object types and objects in addition to
LOBs, statements and subscriptions."," static int dpiLob__check(dpiLob *lob, const char *fnName, int needErrorHandle,
 return DPI_FAILURE;
 if (!lob->locator)
 return dpiError__set(error, ""check closed"", DPI_ERR_LOB_CLOSED);
- if (!lob->conn->handle || lob->conn->closing ||
- (lob->conn->pool && !lob->conn->pool->handle))
- return dpiError__set(error, ""check connection"", DPI_ERR_NOT_CONNECTED);
- return DPI_SUCCESS;
+ return dpiConn__checkConnected(lob->conn, error);
 }
 
 
",308,75
Bump copyright notices into year of modification.,"
 //-----------------------------------------------------------------------------
-// Copyright (c) 2016, 2017 Oracle and/or its affiliates. All rights reserved.
+// Copyright (c) 2016-2018 Oracle and/or its affiliates. All rights reserved.
 // This program is free software: you can modify it and/or redistribute it
 // under the terms of:
 //
",144,30
Add support for setting a LOB attribute of an object using string/bytes.," int dpiLob__close(dpiLob *lob, int propagateErrors, dpiError *error)
 status = dpiOci__lobIsTemporary(lob, &isTemporary, propagateErrors,
 error);
 if (isTemporary && status == DPI_SUCCESS)
- status = dpiOci__lobFreeTemporary(lob, propagateErrors, error);
+ status = dpiOci__lobFreeTemporary(lob->conn,
+ lob->locator, propagateErrors, error);
 }
 dpiOci__descriptorFree(lob->locator, DPI_OCI_DTYPE_LOB);
 if (!lob->conn->closing)
",309,75
Further adjustments to copyright notices to match requirements of Oracle Legal.," master_doc = 'index'
 
 # general information about the project
 project = 'ODPI-C'
-copyright = '2016, 2018 Oracle and/or its affiliates. All rights reserved.'
+copyright = '2016, 2018, Oracle and/or its affiliates. All rights reserved.'
 author = 'Oracle'
 
 # the version info for the project, acts as replacement for |version| and
",26,3
Eliminate warnings from static analysis tool.," int dpiError__getInfo(dpiError *error, dpiErrorInfo *info)
 info->sqlState = ""01002"";
 break;
 default:
- if (error->buffer->code == 0 && error->buffer->errorNum == 0)
+ if (error->buffer->code == 0 &&
+ error->buffer->errorNum == (dpiErrorNum) 0)
 info->sqlState = ""00000"";
 else info->sqlState = ""HY000"";
 break;
",149,70
Preparing to release ODPI-C 3.0.," author = 'Oracle'
 version = '3.0'
 
 # the full version, including alpha/beta/rc tags
-release = '3.0.0-dev'
+release = '3.0.0'
 
 # the theme to use for HTML pages
 html_theme = 'oracle'
",26,3
Bump version to 3.1 (development).," author = 'Oracle'
 # |release|, also used in various other places throughout the built documents
 #
 # the short X.Y version
-version = '3.0'
+version = '3.1'
 
 # the full version, including alpha/beta/rc tags
-release = '3.0.0'
+release = '3.1.0-dev'
 
 # the theme to use for HTML pages
 html_theme = 'oracle'
",26,3
Improve error message when using an older shared library.," static int dpiContext__create(const char *fnName, unsigned int majorVersion,
 // verify that the supplied version is supported by the library
 if (dpiMajorVersion != majorVersion || minorVersion > dpiMinorVersion)
 return dpiError__set(error, ""check version"",
- DPI_ERR_VERSION_NOT_SUPPORTED, majorVersion, minorVersion,
- dpiMajorVersion, dpiMinorVersion);
+ DPI_ERR_VERSION_NOT_SUPPORTED, majorVersion, majorVersion,
+ minorVersion, dpiMajorVersion, dpiMinorVersion);
 
 // allocate context and initialize it
 if (dpiGen__allocate(DPI_HTYPE_CONTEXT, NULL, (void**) &tempContext,
",159,33
"Add support for getting/setting raw attributes of objects, as requested
(https://github.com/oracle/odpi/issues/72)."," static dpiOracleTypeNum dpiOracleType__convertFromOracle(uint16_t typeCode,
 case DPI_SQLT_ODT:
 return DPI_ORACLE_TYPE_DATE;
 case DPI_SQLT_BIN:
+ case DPI_SQLT_LVB:
 return DPI_ORACLE_TYPE_RAW;
 case DPI_SQLT_AFC:
 if (charsetForm == DPI_SQLCS_NCHAR)
",433,76
"Free handles before releasing references in order to avoid potential segfaults
when a connection is closed before the handle is freed."," static int dpiSodaColl__find(dpiSodaColl *coll,
 
 //-----------------------------------------------------------------------------
 // dpiSodaColl__free() [INTERNAL]
-// Free the memory for a SODA collection.
+// Free the memory for a SODA collection. Note that the reference to the
+// database must remain until after the handle is freed; otherwise, a segfault
+// can take place.
 //-----------------------------------------------------------------------------
 void dpiSodaColl__free(dpiSodaColl *coll, dpiError *error)
 {
- if (coll->db) {
- dpiGen__setRefCount(coll->db, error, -1);
- coll->db = NULL;
- }
 if (coll->handle) {
 dpiOci__handleFree(coll->handle, DPI_OCI_HTYPE_SODA_COLLECTION);
 coll->handle = NULL;
 }
+ if (coll->db) {
+ dpiGen__setRefCount(coll->db, error, -1);
+ coll->db = NULL;
+ }
 dpiUtils__freeMemory(coll);
 }
 
",412,96
"Added support for performing external authentication with proxy for standalone
connections; added error message when external authentication with proxy is
attempted without placing the user name in [] (proxy authentication is
otherwise silently ignored)."," int dpiPool_acquireConnection(dpiPool *pool, const char *userName,
 params = &localParams;
 }
 
+ // the username must be enclosed within [] if external authentication
+ // with proxy is desired
+ if (pool->externalAuth && userName && userNameLength > 0 &&
+ (userName[0] != '[' || userName[userNameLength - 1] != ']')) {
+ dpiError__set(&error, ""verify proxy user name with external auth"",
+ DPI_ERR_EXT_AUTH_INVALID_PROXY);
+ return dpiGen__endPublicFn(pool, DPI_FAILURE, &error );
+ }
+
 status = dpiPool__acquireConnection(pool, userName, userNameLength,
 password, passwordLength, params, conn, &error);
 return dpiGen__endPublicFn(pool, status, &error);
",339,90
"Added support for fetching SYS.XMLTYPE by modifying the type information to
return (LONG) VARCHAR2 when SYS.XMLTYPE is detected
(https://github.com/oracle/python-cx_Oracle/issues/14)."," static int dpiObjectType__init(dpiObjectType *objType, void *param,
 }
 
 
+//-----------------------------------------------------------------------------
+// dpiObjectType__isXmlType() [INTERNAL]
+// Returns a boolean indicating if the object type in question refers to the
+// type SYS.XMLTYPE.
+//-----------------------------------------------------------------------------
+int dpiObjectType__isXmlType(dpiObjectType *objType)
+{
+ static const char *schema = ""SYS"", *name = ""XMLTYPE"";
+ size_t schemaLength, nameLength;
+
+ schemaLength = strlen(schema);
+ nameLength = strlen(name);
+ return (objType->schemaLength == schemaLength &&
+ strncmp(objType->schema, schema, schemaLength) == 0 &&
+ objType->nameLength == nameLength &&
+ strncmp(objType->name, name, nameLength) == 0);
+}
+
+
 //-----------------------------------------------------------------------------
 // dpiObjectType_addRef() [PUBLIC]
 // Add a reference to the object type.
",202,46
"Tighten up handling of numeric values converted from string representations:
only 38 digits of precision should be permitted (maximum precision of Oracle
numbers) and the maximum (+125/-130) exponents should also be respected in
order to ensure that the value provided in the string can be safely transformed into an Oracle number. The error message ""DPI-1044: number too large"" was
changed to ""DPI-1044: value cannot be represented as an Oracle number"" in order
to improve clarity."," int dpiUtils__parseNumberString(const char *value, uint32_t valueLength,
 while (*numDigits > 0 && *digits-- == 0)
 (*numDigits)--;
 
- // only 40 digits are allowed in an OCI number
- if (*numDigits > DPI_NUMBER_MAX_DIGITS)
- return dpiError__set(error, ""check number of digits > 40"",
- DPI_ERR_NOT_SUPPORTED);
-
- // values must be less than 1e126
- if (*decimalPointIndex > 126)
- return dpiError__set(error, ""check size of value"",
- DPI_ERR_NUMBER_TOO_LARGE);
-
- // values smaller than 1e-130 are simply returned as zero
- if (*decimalPointIndex < -129) {
- *numDigits = 0;
- *isNegative = 0;
+ // values must be less than 1e126 and greater than 1e-129; the number of
+ // digits also cannot exceed the maximum precision of Oracle numbers
+ if (*numDigits > DPI_NUMBER_MAX_DIGITS || *decimalPointIndex > 126 ||
+ *decimalPointIndex < -129) {
+ return dpiError__set(error, ""check value can be represented"",
+ DPI_ERR_NUMBER_NO_REPR);
 }
 
 return DPI_SUCCESS;
",249,89
"Pool pinging functionality was enabled for 12.2+ clients but the last time
used was not being set, so it was only partially working; this corrects that
issue."," static int dpiConn__close(dpiConn *conn, uint32_t mode, const char *tag,
 
 // if the session isn't marked as needing to be dropped, update the
 // last time used (this is checked when the session is acquired)
- // NOTE: this is only needed for clients earlier than 12.2
- if (!conn->deadSession && conn->sessionHandle &&
- (conn->env->versionInfo->versionNum < 12 ||
- (conn->env->versionInfo->versionNum == 12 &&
- conn->env->versionInfo->releaseNum < 2))) {
+ if (!conn->deadSession && conn->sessionHandle) {
 
 // get the pointer from the context
 lastTimeUsed = NULL;
",1396,368
"If the ping failed because of a fatal error (such as a killed session), ensure
that the dead session flag is cleared before attemping to get a new session;
otherwise, the new session will also be dropped from the pool when it is
released back to the pool."," static int dpiConn__getSession(dpiConn *conn, uint32_t mode,
 conn->handle = NULL;
 conn->serverHandle = NULL;
 conn->sessionHandle = NULL;
+ conn->deadSession = 0;
 
 }
 
",1397,368
"Add support for multiproperty tags and the PL/SQL fixup session state callback
available in 12.2+.","
 # -*- coding: utf-8 -*-
 
 #------------------------------------------------------------------------------
-# Copyright (c) 2016, 2018 Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2016, 2019 Oracle and/or its affiliates. All rights reserved.
 # This program is free software: you can modify it and/or redistribute it
 # under the terms of:
 #
 master_doc = 'index'
 
 # general information about the project
 project = 'ODPI-C'
-copyright = '2016, 2018, Oracle and/or its affiliates. All rights reserved.'
+copyright = '2016, 2019, Oracle and/or its affiliates. All rights reserved.'
 author = 'Oracle'
 
 # the version info for the project, acts as replacement for |version| and
",26,3
"Eliminate memory leak when calling dpiConn_close() with fetched collections
(that require the indicator to be freed)."," int dpiOci__objectFree(dpiObject *obj, int checkError, dpiError *error)
 DPI_OCI_LOAD_SYMBOL(""OCIObjectFree"", dpiOciSymbols.fnObjectFree)
 status = (*dpiOciSymbols.fnObjectFree)(obj->env->handle, error->handle,
 obj->instance, DPI_OCI_DEFAULT);
- if (checkError)
- return dpiError__check(error, status, obj->type->conn,
- ""free instance"");
+ if (checkError && dpiError__check(error, status, obj->type->conn,
+ ""free instance"") < 0)
+ return DPI_FAILURE;
 if (obj->freeIndicator) {
 status = (*dpiOciSymbols.fnObjectFree)(obj->env->handle, error->handle,
 obj->indicator, DPI_OCI_DEFAULT);
- if (checkError)
- return dpiError__check(error, status, obj->type->conn,
- ""free indicator"");
+ if (checkError && dpiError__check(error, status, obj->type->conn,
+ ""free indicator"") < 0)
+ return DPI_FAILURE;
 }
 return DPI_SUCCESS;
 }
",2311,323
"Eliminate unnecessary call (which is being doing in the call to destroy the
session pool)."," void dpiPool__free(dpiPool *pool, dpiError *error)
 {
 if (pool->handle) {
 dpiOci__sessionPoolDestroy(pool, DPI_OCI_SPD_FORCE, 0, error);
- dpiOci__handleFree(pool->handle, DPI_OCI_HTYPE_SPOOL);
 pool->handle = NULL;
 }
 if (pool->env) {
",353,96
"Eliminate memory leak by eliminating unneeded statement (which could clear
valid data when errors aren't being checked, such as during the automatic
release of a pooled session that takes place when the last reference to a
connection is closed)."," int dpiOci__contextGetValue(dpiConn *conn, const char *key, uint32_t keyLength,
 error->handle, key, (uint8_t) keyLength, value);
 if (checkError)
 return dpiError__check(error, status, conn, ""get context value"");
- *value = NULL;
 return DPI_SUCCESS;
 }
 
",2310,323
Bump copyright into 2019 for changed files.,"
 //-----------------------------------------------------------------------------
-// Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.
+// Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
 // This program is free software: you can modify it and/or redistribute it
 // under the terms of:
 //
",443,96
Preparing to release ODPI-C 3.1.," author = 'Oracle'
 version = '3.1'
 
 # the full version, including alpha/beta/rc tags
-release = '3.1.0-dev'
+release = '3.1.0'
 
 # the theme to use for HTML pages
 html_theme = 'oracle'
",26,3
Bump version now that 3.1 has been released.," author = 'Oracle'
 # |release|, also used in various other places throughout the built documents
 #
 # the short X.Y version
-version = '3.1'
+version = '3.2'
 
 # the full version, including alpha/beta/rc tags
-release = '3.1.0'
+release = '3.2.0-dev'
 
 # the theme to use for HTML pages
 html_theme = 'oracle'
",26,3
"Use error prefixes in test suite instead of full error messages to allow for
possible globalization in the future; add method dpiTestCase_expectAnyError()
to allow for multiple possible error messages (depending on version or database
configuration); removed method dpiTestCase_expectErrorCode() now that prefixes
are being used."," int dpiTest_400_setCurrentSchema(dpiTestCase *testCase, dpiTestParams *params)
 &stmt) < 0)
 return dpiTestCase_setFailedFromError(testCase);
 dpiStmt_execute(stmt, 0, &numQueryColumns);
- if (dpiTestCase_expectError(testCase,
- ""ORA-01435: user does not exist"") < 0)
+ if (dpiTestCase_expectError(testCase, ""ORA-01435:"") < 0)
 return DPI_FAILURE;
 if (dpiStmt_release(stmt) < 0)
 return dpiTestCase_setFailedFromError(testCase);
 int dpiTest_403_withInvalidEncoding(dpiTestCase *testCase,
 params->mainPassword, params->mainPasswordLength,
 params->connectString, params->connectStringLength, &commonParams,
 NULL, &conn);
- return dpiTestCase_expectError(testCase,
- ""DPI-1026: invalid character set xx"");
+ return dpiTestCase_expectError(testCase, ""DPI-1026:"");
 }
 
 
",441,105
Improve code preventing a statement from binding itself.," static int dpiVar__setFromStmt(dpiVar *var, uint32_t pos, dpiStmt *stmt,
 dpiError *error)
 {
 dpiData *data;
+ uint32_t i;
 
 // validate the statement
 if (dpiGen__checkHandle(stmt, DPI_HTYPE_STMT, ""check stmt"", error) < 0)
 return DPI_FAILURE;
 
+ // prevent attempts to bind a statement to itself
+ for (i = 0; i < stmt->numBindVars; i++) {
+ if (stmt->bindVars[i].var == var)
+ return dpiError__set(error, ""bind to self"", DPI_ERR_NOT_SUPPORTED);
+ }
+
 // mark the value as not null
 data = &var->buffer.externalData[pos];
 data->isNull = 0;
",1320,375
"During the attempt to free, PL/SQL records fail with error ""ORA-21602:
operation does not support the specified typecode"", but a subsequent attempt
will yield error ""OCI-21500: internal error code"" and crash the process, so
pretend like the free was successful!"," int dpiOci__objectFree(dpiObject *obj, int checkError, dpiError *error)
 status = (*dpiOciSymbols.fnObjectFree)(obj->env->handle, error->handle,
 obj->instance, DPI_OCI_DEFAULT);
 if (checkError && dpiError__check(error, status, obj->type->conn,
- ""free instance"") < 0)
+ ""free instance"") < 0) {
+ // during the attempt to free, PL/SQL records fail with error
+ // ""ORA-21602: operation does not support the specified typecode"", but
+ // a subsequent attempt will yield error ""OCI-21500: internal error
+ // code"" and crash the process, so pretend like the free was
+ // successful!
+ if (error->buffer->code == 21602)
+ return DPI_SUCCESS;
 return DPI_FAILURE;
+ }
 if (obj->freeIndicator) {
 status = (*dpiOciSymbols.fnObjectFree)(obj->env->handle, error->handle,
 obj->indicator, DPI_OCI_DEFAULT);
",2313,324
Bump copyright into 2019 as file has changed.,"
 //-----------------------------------------------------------------------------
-// Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.
+// Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
 // This program is free software: you can modify it and/or redistribute it
 // under the terms of:
 //
",1320,375
"Ensure that the outNewSession flag is always reset when acquiring a connection
from the pool."," static int dpiConn__getSession(dpiConn *conn, uint32_t mode,
 while (1) {
 
 // acquire the new session
+ params->outNewSession = 0;
 if (dpiOci__sessionGet(conn->env->handle, &conn->handle, authInfo,
 connectString, connectStringLength, params->tag,
 params->tagLength, &params->outTag, &params->outTagLength,
",1421,380
"Correct code for freeing CQN message objects
(https://github.com/oracle/odpi/issues/96)."," static void dpiSubscr__freeMessage(dpiSubscrMessage *message)
 query = &message->queries[i];
 if (query->numTables > 0) {
 for (j = 0; j < query->numTables; j++) {
- if (query->tables[i].numRows > 0)
- dpiUtils__freeMemory(query->tables[i].rows);
+ if (query->tables[j].numRows > 0)
+ dpiUtils__freeMemory(query->tables[j].rows);
 }
 dpiUtils__freeMemory(query->tables);
 }
",420,115
Correct ordering of arguments for message.," static int dpiOci__loadLibValidate(dpiError *error)
 if (dpiOci__loadSymbol(""OCIClientVersion"",
 (void**) &dpiOciSymbols.fnClientVersion, NULL) < 0)
 return dpiError__set(error, ""check Oracle Client version"",
- DPI_ERR_ORACLE_CLIENT_TOO_OLD, 11, 2, 0, 0);
+ DPI_ERR_ORACLE_CLIENT_TOO_OLD, 0, 0, 11, 2);
 (*dpiOciSymbols.fnClientVersion)(&dpiOciLibVersionInfo.versionNum,
 &dpiOciLibVersionInfo.releaseNum,
 &dpiOciLibVersionInfo.updateNum,
",2313,324
Bump copyright into 2019.,"
 //-----------------------------------------------------------------------------
-// Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.
+// Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
 // This program is free software: you can modify it and/or redistribute it
 // under the terms of:
 //
",420,115
Remove invalid call to dpiError__check().," int dpiDataBuffer__toOracleTimestampFromDouble(dpiDataBuffer *data,
 status = dpiOci__dateTimeIntervalAdd(env->handle, env->baseDate, interval,
 oracleValue, error);
 dpiOci__descriptorFree(interval, DPI_OCI_DTYPE_INTERVAL_DS);
- return dpiError__check(error, status, NULL, ""add date"");
+ return status;
 }
 
 
",443,96
"Ensure that the strings ""-0"" and ""-0.0"" are correctly handled as zero values
(https://github.com/oracle/python-cx_Oracle/issues/274)."," int dpiDataBuffer__toOracleNumberFromText(dpiDataBuffer *data, dpiEnv *env,
 numPairs = numDigits / 2;
 
 // append a sentinel 102 byte for negative numbers if there is room
- appendSentinel = (isNegative && numDigits < DPI_NUMBER_MAX_DIGITS);
+ appendSentinel = (isNegative && numDigits > 0 &&
+ numDigits < DPI_NUMBER_MAX_DIGITS);
 
 // initialize the OCINumber value
 // the length is the number of pairs, plus one for the exponent
",444,97
Improve logging message.," void TestCallback(void *context, dpiSubscrMessage *message)
 
 // display contents of message
 printf(""===========================================================\n"");
- printf(""NOTIFICATION RECEIVED from database %.*s (SUBSCR ID %d)\n"",
+ printf(""NOTIFICATION RECEIVED from database %.*s (EVENT TYPE %d)\n"",
 message->dbNameLength, message->dbName, message->eventType);
 printf(""===========================================================\n"");
 for (i = 0; i < message->numQueries; i++) {
",80,14
"Added support for the startup and shutdown events, as requested
(https://github.com/oracle/odpi/issues/102)."," static int dpiSubscr__populateMessage(dpiSubscr *subscr,
 case DPI_EVENT_DEREG:
 subscr->registered = 0;
 break;
+ case DPI_EVENT_STARTUP:
+ case DPI_EVENT_SHUTDOWN:
+ case DPI_EVENT_SHUTDOWN_ANY:
+ break;
 default:
 return dpiError__set(error, ""event type"", DPI_ERR_NOT_SUPPORTED);
 }
",424,118
"Avoid making calls to a function to check status; instead create macros which
check the status and only call a function if an error has occurred."," static int dpiStmt__getBatchErrors(dpiStmt *stmt, dpiError *error)
 // get error message
 localError.buffer = &stmt->batchErrors[i];
 localError.handle = batchErrorHandle;
- dpiError__check(&localError, DPI_OCI_ERROR, stmt->conn,
+ dpiError__setFromOCI(&localError, DPI_OCI_ERROR, stmt->conn,
 ""get batch error"");
 if (error->buffer->errorNum) {
 overallStatus = DPI_FAILURE;
",1229,362
Added test cases for session tagging; simplified test cases for session pools.,"
 extern char **environ;
 #endif
 
-#define NUM_EXECUTABLES 30
+#define NUM_EXECUTABLES 31
 
 static const char *dpiTestNames[NUM_EXECUTABLES] = {
 ""TestContext"",
 static const char *dpiTestNames[NUM_EXECUTABLES] = {
 ""TestSodaColl"",
 ""TestSodaCollCursor"",
 ""TestSodaDoc"",
- ""TestSodaDocCursor""
+ ""TestSodaDocCursor"",
+ ""TestSessTags""
 };
 
 
",106,15
Enable additional warnings and eliminate the new warnings found.," int dpiConn_create(const dpiContext *context, const char *userName,
 }
 
 *conn = tempConn;
- dpiHandlePool__release(tempConn->env->errorHandles, error.handle, &error);
- error.handle = NULL;
+ dpiHandlePool__release(tempConn->env->errorHandles, &error.handle);
 return dpiGen__endPublicFn(context, DPI_SUCCESS, &error);
 }
 
",1445,390
"Remove blank lines at the end of all files in order to match whitespace
standard."," def on_builder_inited(app):
 if app.builder.name == ""html"":
 app.builder.search = False
 app.builder.script_files.clear()
-
",26,3
"Replace prefix ""Test"" with ""Demo"" on all file names to make it clear these
examples are not for testing but for demo purposes.","
 //-----------------------------------------------------------------------------
 
 //-----------------------------------------------------------------------------
-// TestAQ.c
-// Tests enqueuing and dequeuing objects using advanced queuing.
+// DemoAQ.c
+// Demos enqueuing and dequeuing objects using advanced queuing.
 //-----------------------------------------------------------------------------
 
 #include ""SampleLib.h""
",84,19
Added support for SODA bulk insert available in Oracle Client 18.5 and higher.," int dpiSamples_showError(void)
 dpiErrorInfo info;
 
 dpiContext_getError(gContext, &info);
- fprintf(stderr, ""ERROR: %.*s (%s: %s)\n"", info.messageLength, info.message,
- info.fnName, info.action);
+ fprintf(stderr, ""ERROR: %.*s (%s: %s), offset: %u\n"", info.messageLength,
+ info.message, info.fnName, info.action, info.offset);
 return -1;
 }
",108,18
"Add support for getting the row count for PL/SQL statements
(https://github.com/oracle/python-cx_Oracle/issues/285)."," int dpiStmt_getRowCount(dpiStmt *stmt, uint64_t *count)
 else if (stmt->statementType != DPI_STMT_TYPE_INSERT &&
 stmt->statementType != DPI_STMT_TYPE_UPDATE &&
 stmt->statementType != DPI_STMT_TYPE_DELETE &&
- stmt->statementType != DPI_STMT_TYPE_MERGE) {
+ stmt->statementType != DPI_STMT_TYPE_MERGE &&
+ stmt->statementType != DPI_STMT_TYPE_CALL &&
+ stmt->statementType != DPI_STMT_TYPE_BEGIN &&
+ stmt->statementType != DPI_STMT_TYPE_DECLARE) {
 *count = 0;
 } else if (stmt->env->versionInfo->versionNum < 12) {
 if (dpiOci__attrGet(stmt->handle, DPI_OCI_HTYPE_STMT, &rowCount32, 0,
",1232,365
"Prevent segfault when a subscription is unregistered while callbacks are
ongoing."," int dpiConn_subscribe(dpiConn *conn, dpiSubscrCreateParams *params,
 int dpiConn_unsubscribe(dpiConn *conn, dpiSubscr *subscr)
 {
 dpiError error;
+ int status;
 
 if (dpiConn__check(conn, __func__, &error) < 0)
 return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
 int dpiConn_unsubscribe(dpiConn *conn, dpiSubscr *subscr)
 &error) < 0)
 return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
 if (subscr->registered) {
- if (dpiOci__subscriptionUnRegister(conn, subscr, &error) < 0)
+ dpiMutex__acquire(subscr->mutex);
+ status = dpiOci__subscriptionUnRegister(conn, subscr, &error);
+ if (status == DPI_SUCCESS)
+ subscr->registered = 0;
+ dpiMutex__release(subscr->mutex);
+ if (status < 0)
 return dpiGen__endPublicFn(subscr, DPI_FAILURE, &error);
- subscr->registered = 0;
 }
 
 dpiGen__setRefCount(subscr, &error, -1);
",1450,391
"Eliminate memory leak when fetching objects that are null
(https://github.com/oracle/python-cx_Oracle/issues/298)."," int dpiVar__getValue(dpiVar *var, dpiVarBuffer *buffer, uint32_t pos,
 return DPI_SUCCESS;
 }
 
-
 // check for a NULL value; for objects the indicator is elsewhere
 data = &buffer->externalData[pos];
 if (!buffer->objectIndicator)
 int dpiVar__getValue(dpiVar *var, dpiVarBuffer *buffer, uint32_t pos,
 data->isNull = (*((int16_t*) buffer->objectIndicator[pos]) ==
 DPI_OCI_IND_NULL);
 else data->isNull = 1;
- if (data->isNull)
+ if (data->isNull) {
+ if (var->objectType) {
+ if (dpiOci__objectFree(var->env->handle,
+ buffer->data.asObject[pos], 1, error) < 0)
+ return DPI_FAILURE;
+ if (inFetch && var->objectType->isCollection) {
+ if (dpiOci__objectFree(var->env->handle,
+ buffer->objectIndicator[pos], 1, error) < 0)
+ return DPI_FAILURE;
+ }
+ }
 return DPI_SUCCESS;
+ }
 
 // check return code for variable length data
 if (buffer->returnCode) {
",1331,380
"Only collections that are fetched should be freed; otherwise, unusual OCI
errors may take place
(https://github.com/oracle/python-cx_Oracle/issues/298)."," int dpiVar__getValue(dpiVar *var, dpiVarBuffer *buffer, uint32_t pos,
 DPI_OCI_IND_NULL);
 else data->isNull = 1;
 if (data->isNull) {
- if (var->objectType) {
+ if (inFetch && var->objectType && var->objectType->isCollection) {
 if (dpiOci__objectFree(var->env->handle,
 buffer->data.asObject[pos], 1, error) < 0)
 return DPI_FAILURE;
- if (inFetch && var->objectType->isCollection) {
- if (dpiOci__objectFree(var->env->handle,
- buffer->objectIndicator[pos], 1, error) < 0)
- return DPI_FAILURE;
- }
+ if (dpiOci__objectFree(var->env->handle,
+ buffer->objectIndicator[pos], 1, error) < 0)
+ return DPI_FAILURE;
 }
 return DPI_SUCCESS;
 }
",1329,380
Defer creation of error handle until it is needed.," static int dpiEnqOptions__getAttrValue(dpiEnqOptions *options,
 dpiError error;
 int status;
 
- if (dpiGen__startPublicFn(options, DPI_HTYPE_ENQ_OPTIONS, fnName, 1,
+ if (dpiGen__startPublicFn(options, DPI_HTYPE_ENQ_OPTIONS, fnName,
 &error) < 0)
 return dpiGen__endPublicFn(options, DPI_FAILURE, &error);
 DPI_CHECK_PTR_NOT_NULL(options, value)
 static int dpiEnqOptions__setAttrValue(dpiEnqOptions *options,
 dpiError error;
 int status;
 
- if (dpiGen__startPublicFn(options, DPI_HTYPE_ENQ_OPTIONS, fnName, 1,
+ if (dpiGen__startPublicFn(options, DPI_HTYPE_ENQ_OPTIONS, fnName,
 &error) < 0)
 return dpiGen__endPublicFn(options, DPI_FAILURE, &error);
 DPI_CHECK_PTR_NOT_NULL(options, value)
",88,15
"Added support for array enqueue/dequeue of Advanced Queuing
(https://github.com/oracle/odpi/issues/58); added support for enqueue/dequeue
of RAW payloads; deprecated functions dpiConn_deqObject() and
dpiConn_enqObject() in favor of new queue object created by calling
dpiConn_newQueue() (https://github.com/oracle/odpi/issues/104)."," static const dpiTypeDef dpiAllTypeDefs[DPI_HTYPE_MAX - DPI_HTYPE_NONE - 1] = {
 sizeof(dpiSodaDocCursor), // size of structure
 0x80ceb83b, // check integer
 (dpiTypeFreeProc) dpiSodaDocCursor__free
+ },
+ {
+ ""dpiQueue"", // name
+ sizeof(dpiQueue), // size of structure
+ 0x54904ba2, // check integer
+ (dpiTypeFreeProc) dpiQueue__free
 }
 };
 
",216,27
"The strtol() method with a base of 0 treats leading zeroes as an octal number,
which leads to corruption of numbers like 1e-08 and 1e-09
(https://github.com/oracle/python-cx_Oracle/issues/300)."," int dpiUtils__parseNumberString(const char *value, uint32_t valueLength,
 return dpiError__set(error, ""no digits in exponent"",
 DPI_ERR_INVALID_NUMBER);
 exponentDigits[numExponentDigits] = '\0';
- exponent = (int16_t) strtol(exponentDigits, NULL, 0);
+ exponent = (int16_t) strtol(exponentDigits, NULL, 10);
 if (exponentIsNegative)
 exponent = -exponent;
 *decimalPointIndex += exponent;
",249,89
"Avoid doing anything with the date last used (used for pool ping functionality)
if the pool is being closed."," static int dpiConn__close(dpiConn *conn, uint32_t mode, const char *tag,
 
 // update last time used (if the session isn't going to be dropped)
 // clear last time used (if the session is going to be dropped)
- if (conn->sessionHandle) {
+ // do nothing, however, if pool is being closed
+ if (conn->sessionHandle && conn->pool->handle) {
 
 // get the pointer from the context associated with the session
 lastTimeUsed = NULL;
",1446,388
"The RAW TDO is cached on the connection and only acquired during enqueue and
dequeue in order to reduce the number of round trips required as well as ensure
that no round trips occur during dpiConn_newQueue()."," static int dpiConn__getHandles(dpiConn *conn, dpiError *error)
 }
 
 
+//-----------------------------------------------------------------------------
+// dpiConn__getRawTDO() [INTERNAL]
+// Internal method used for ensuring that the RAW TDO has been cached on the
+//connection.
+//-----------------------------------------------------------------------------
+int dpiConn__getRawTDO(dpiConn *conn, dpiError *error)
+{
+ if (conn->rawTDO)
+ return DPI_SUCCESS;
+ return dpiOci__typeByName(conn, ""SYS"", 3, ""RAW"", 3, &conn->rawTDO, error);
+}
+
+
 //-----------------------------------------------------------------------------
 // dpiConn__getServerCharset() [INTERNAL]
 // Internal method used for retrieving the server character set. This is used
",1452,390
"Bump 19 to the top of the list now that it is officially released and add 20
in preparation for its planned release next year."," static const char *dpiOciLibNames[] = {
 ""oci.dll"",
 #elif __APPLE__
 ""libclntsh.dylib"",
+ ""libclntsh.dylib.19.1"",
 ""libclntsh.dylib.18.1"",
 ""libclntsh.dylib.12.1"",
 ""libclntsh.dylib.11.1"",
- ""libclntsh.dylib.19.1"",
+ ""libclntsh.dylib.20.1"",
 #else
 ""libclntsh.so"",
+ ""libclntsh.so.19.1"",
 ""libclntsh.so.18.1"",
 ""libclntsh.so.12.1"",
 ""libclntsh.so.11.1"",
- ""libclntsh.so.19.1"",
+ ""libclntsh.so.20.1"",
 #endif
 NULL
 };
",2526,326
"Added support for getting the registration id for a CQN subscription, as
requested (https://github.com/oracle/node-oracledb/issues/1075)."," int main(int argc, char **argv)
 createParams.callback = DemoCallback;
 if (dpiConn_subscribe(conn, &createParams, &subscr) < 0)
 return dpiSamples_showError();
+ printf(""Created subscription with registration id %"" PRIu64 ""\n"",
+ createParams.outRegId);
 
 // register query
 if (dpiSubscr_prepareStmt(subscr, SQL_TEXT, strlen(SQL_TEXT), &stmt) < 0)
",82,14
"Set the LOB prefetch length attribute in order to reduce the number of round
trips to determine the length and chunk size of the LOB."," static int dpiStmt__define(dpiStmt *stmt, uint32_t pos, dpiVar *var,
 {
 void *defineHandle = NULL;
 dpiQueryInfo *queryInfo;
+ int tempBool;
 
 // no need to perform define if variable is unchanged
 if (stmt->queryVars[pos - 1] == var)
 static int dpiStmt__define(dpiStmt *stmt, uint32_t pos, dpiVar *var,
 return DPI_FAILURE;
 }
 
+ // specify that the LOB length should be prefetched
+ if (var->nativeTypeNum == DPI_NATIVE_TYPE_LOB) {
+ tempBool = 1;
+ if (dpiOci__attrSet(defineHandle, DPI_OCI_HTYPE_DEFINE,
+ (void*) &tempBool, 0, DPI_OCI_ATTR_LOBPREFETCH_LENGTH,
+ ""set lob prefetch length"", error) < 0)
+ return DPI_FAILURE;
+ }
+
 // define objects, if applicable
 if (var->buffer.objectIndicator && dpiOci__defineObject(var, defineHandle,
 error) < 0)
",1240,367
"Added test cases for bulk enqueue of objects, binding of PL/SQL arrays;
switched test suite to use UTF-8 encoding for most tests.","
 
 #include ""TestLib.h""
 
-#define QUEUE_NAME ""BOOKS""
+#define QUEUE_NAME ""BOOK_QUEUE""
 #define QUEUE_OBJECT_TYPE ""UDT_BOOK""
 #define MAX_ATTEMPTS 10
 #define NUM_BOOKS 1
",700,237
Rename queues and queue tables to be more clear as to which is which.,"
 //-----------------------------------------------------------------------------
 
 #include ""SampleLib.h""
-#define QUEUE_NAME ""DEMORAW""
+#define QUEUE_NAME ""DEMO_RAW_QUEUE""
 #define NUM_MESSAGES 12
 #define NUM_BATCH_ENQ 6
 #define NUM_BATCH_DEQ 8
",71,17
"Added support for converting date attribute values to doubles (number of
milliseconds since January 1, 1970) used by environments like Node.js."," static int dpiObject__fromOracleValue(dpiObject *obj, dpiError *error,
 if (nativeTypeNum == DPI_NATIVE_TYPE_TIMESTAMP)
 return dpiDataBuffer__fromOracleDate(&data->value,
 value->asDate);
+ if (nativeTypeNum == DPI_NATIVE_TYPE_DOUBLE)
+ return dpiDataBuffer__fromOracleDateAsDouble(&data->value,
+ obj->env, error, value->asDate);
 break;
 case DPI_ORACLE_TYPE_TIMESTAMP:
 if (nativeTypeNum == DPI_NATIVE_TYPE_TIMESTAMP)
 static int dpiObject__toOracleValue(dpiObject *obj, dpiError *error,
 if (nativeTypeNum == DPI_NATIVE_TYPE_TIMESTAMP)
 return dpiDataBuffer__toOracleDate(&data->value,
 &buffer->asDate);
+ if (nativeTypeNum == DPI_NATIVE_TYPE_DOUBLE)
+ return dpiDataBuffer__toOracleDateFromDouble(&data->value,
+ obj->env, error, &buffer->asDate);
 break;
 case DPI_ORACLE_TYPE_TIMESTAMP:
 case DPI_ORACLE_TYPE_TIMESTAMP_TZ:
",730,194
"Add support for additional data types that can be used in PL/SQL and aliases
of types when used in PL/SQL."," static dpiOracleTypeNum dpiOracleType__convertFromOracle(uint16_t typeCode,
 return DPI_ORACLE_TYPE_CHAR;
 case DPI_SQLT_INT:
 case DPI_OCI_TYPECODE_SMALLINT:
+ case DPI_OCI_TYPECODE_BINARY_INTEGER:
+ case DPI_OCI_TYPECODE_PLS_INTEGER:
 return DPI_ORACLE_TYPE_NATIVE_INT;
 case DPI_SQLT_IBFLOAT:
 return DPI_ORACLE_TYPE_NATIVE_FLOAT;
 static dpiOracleTypeNum dpiOracleType__convertFromOracle(uint16_t typeCode,
 case DPI_SQLT_BFILE:
 return DPI_ORACLE_TYPE_BFILE;
 case DPI_SQLT_RDD:
+ case DPI_OCI_TYPECODE_ROWID:
 return DPI_ORACLE_TYPE_ROWID;
 case DPI_SQLT_RSET:
 return DPI_ORACLE_TYPE_STMT;
 static dpiOracleTypeNum dpiOracleType__convertFromOracle(uint16_t typeCode,
 case DPI_SQLT_INTERVAL_YM:
 return DPI_ORACLE_TYPE_INTERVAL_YM;
 case DPI_SQLT_LNG:
+ case DPI_OCI_TYPECODE_LONG:
 return DPI_ORACLE_TYPE_LONG_VARCHAR;
 case DPI_SQLT_LBI:
+ case DPI_OCI_TYPECODE_LONG_RAW:
 return DPI_ORACLE_TYPE_LONG_RAW;
 }
 return (dpiOracleTypeNum) 0;
",445,82
Add static keyword to avoid compiler warning.," static int dpiSodaColl__getDocCount(dpiSodaColl *coll,
 // Insert multiple documents into the collection and return handles to the
 // newly created documents, if desired.
 //-----------------------------------------------------------------------------
-int dpiSodaColl__insertMany(dpiSodaColl *coll, uint32_t numDocs,
+static int dpiSodaColl__insertMany(dpiSodaColl *coll, uint32_t numDocs,
 void **docHandles, uint32_t flags, dpiSodaDoc **insertedDocs,
 dpiError *error)
 {
",497,118
Removing -dev designation in preparation for release of ODPI-C 3.2.0.," author = 'Oracle'
 version = '3.2'
 
 # the full version, including alpha/beta/rc tags
-release = '3.2.0-dev'
+release = '3.2.0'
 
 # the theme to use for HTML pages
 html_theme = 'oracle'
",26,3
"Add support for converting Oracle DATE to native DOUBLE, as commonly used by
environments like Node.js."," author = 'Oracle'
 # |release|, also used in various other places throughout the built documents
 #
 # the short X.Y version
-version = '3.2'
+version = '3.3'
 
 # the full version, including alpha/beta/rc tags
-release = '3.2.0'
+release = '3.3.0-dev'
 
 # the theme to use for HTML pages
 html_theme = 'oracle'
",26,3
Added test cases for binding PL/SQL records and array of PL/SQL records.," int dpiTest_1204_verifyInOutBindVariables(dpiTestCase *testCase,
 // compare results
 if (dpiTestCase_expectUintEqual(testCase,
 dpiData_getBool(inOutData[0]), 1) < 0)
- return dpiTestCase_setFailedFromError(testCase);
+ return DPI_FAILURE;
 if (dpiVar_release(inOutVar[0]) < 0)
 return dpiTestCase_setFailedFromError(testCase);
 if (dpiStmt_release(stmt) < 0)
",1278,343
"Eliminate potentially confusing error when calling dpiSodaColl_insertMany()
with an empty array."," int dpiSodaColl_insertMany(dpiSodaColl *coll, uint32_t numDocs,
 if (dpiSodaColl__check(coll, __func__, &error) < 0)
 return dpiGen__endPublicFn(coll, DPI_FAILURE, &error);
 DPI_CHECK_PTR_NOT_NULL(coll, docs)
+ if (numDocs == 0) {
+ dpiError__set(&error, ""check num documents"", DPI_ERR_ARRAY_SIZE_ZERO);
+ return dpiGen__endPublicFn(coll, DPI_FAILURE, &error);
+ }
 for (i = 0; i < numDocs; i++) {
 if (dpiGen__checkHandle(docs[i], DPI_HTYPE_SODA_DOC, ""check document"",
 &error) < 0)
",501,119
Remove unintentional unused slot.," int dpiHandleList__addHandle(dpiHandleList *list, void *handle,
 list->handles = tempHandles;
 list->numSlots = numSlots;
 *slotNum = list->numUsedSlots++;
- list->currentPos = list->numUsedSlots + 1;
+ list->currentPos = list->numUsedSlots;
 } else {
 for (i = 0; i < list->numSlots; i++) {
 if (!list->handles[list->currentPos])
",72,13
"Only SELECT statements can be used for subscriptions, so verify that the
statement type is in fact a SELECT statement in order to avoid the error
""ORA-3137: malformed TTC packet from client rejected""."," static int dpiSubscr__populateQueryChangeMessage(dpiSubscr *subscr,
 static int dpiSubscr__prepareStmt(dpiSubscr *subscr, dpiStmt *stmt,
 const char *sql, uint32_t sqlLength, dpiError *error)
 {
- // prepare statement for execution
+ // prepare statement for execution; only SELECT statements are supported
 if (dpiStmt__prepare(stmt, sql, sqlLength, NULL, 0, error) < 0)
 return DPI_FAILURE;
+ if (stmt->statementType != DPI_STMT_TYPE_SELECT)
+ return dpiError__set(error, ""subscr prepare statement"",
+ DPI_ERR_NOT_SUPPORTED);
 
 // fetch array size is set to 1 in order to avoid over allocation since
 // the query is not really going to be used for fetching rows, just for
",446,121
"Eliminate assumption that connections created with the OCISessionGet() API are
all created using a pool; the use of a connection class or sharding columns all
require the OCISessionGet() API as well."," static int dpiConn__close(dpiConn *conn, uint32_t mode, const char *tag,
 
 // update last time used (if the session isn't going to be dropped)
 // clear last time used (if the session is going to be dropped)
- // do nothing, however, if pool is being closed
- if (conn->sessionHandle && conn->pool->handle) {
+ // do nothing, however, if not using a pool or the pool is being closed
+ if (conn->sessionHandle && conn->pool && conn->pool->handle) {
 
 // get the pointer from the context associated with the session
 lastTimeUsed = NULL;
",1452,391
"Correct support for PLS_INTEGER and BINARY_INTEGER types when used in PL/SQL
records (https://github.com/oracle/odpi/issues/112)."," static int dpiObject__fromOracleValue(dpiObject *obj, dpiError *error,
 }
 break;
 case DPI_ORACLE_TYPE_NATIVE_INT:
- if (nativeTypeNum == DPI_NATIVE_TYPE_INT64)
- return dpiDataBuffer__fromOracleNumberAsInteger(&data->value,
- error, value->asNumber);
+ if (nativeTypeNum == DPI_NATIVE_TYPE_INT64) {
+ data->value.asInt64 = *value->asInt32;
+ return DPI_SUCCESS;
+ }
 break;
 case DPI_ORACLE_TYPE_NATIVE_FLOAT:
 if (nativeTypeNum == DPI_NATIVE_TYPE_FLOAT) {
 static int dpiObject__toOracleValue(dpiObject *obj, dpiError *error,
 }
 break;
 case DPI_ORACLE_TYPE_NATIVE_INT:
+ if (nativeTypeNum == DPI_NATIVE_TYPE_INT64) {
+ buffer->asInt32 = (int32_t) data->value.asInt64;
+ *ociValue = &buffer->asInt32;
+ return DPI_SUCCESS;
+ }
+ break;
 case DPI_ORACLE_TYPE_NUMBER:
 *ociValue = &buffer->asNumber;
 if (nativeTypeNum == DPI_NATIVE_TYPE_INT64)
",737,195
Fetched native integers support 64-bit (revert part of previous change).," static const dpiOracleType
 DPI_NATIVE_TYPE_INT64, // default native type
 DPI_SQLT_INT, // internal Oracle type
 DPI_SQLCS_IMPLICIT, // charset form
- sizeof(int32_t), // buffer size
+ sizeof(int64_t), // buffer size
 0, // is character data
 1, // can be in array
 0 // requires pre-fetch
",445,82
"Make the release string and release string length parameters optional in the
call to dpiConn_getServerVersion() since they are frequently not used."," int dpiConn_getServerVersion(dpiConn *conn, const char **releaseString,
 // validate parameters
 if (dpiConn__check(conn, __func__, &error) < 0)
 return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
- DPI_CHECK_PTR_NOT_NULL(conn, releaseString)
- DPI_CHECK_PTR_NOT_NULL(conn, releaseStringLength)
 DPI_CHECK_PTR_NOT_NULL(conn, versionInfo)
 
 // get server version
 if (dpiConn__getServerVersion(conn, &error) < 0)
 return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
- *releaseString = conn->releaseString;
- *releaseStringLength = conn->releaseStringLength;
+ if (releaseString)
+ *releaseString = conn->releaseString;
+ if (releaseStringLength)
+ *releaseStringLength = conn->releaseStringLength;
 memcpy(versionInfo, &conn->versionInfo, sizeof(dpiVersionInfo));
 return dpiGen__endPublicFn(conn, DPI_SUCCESS, &error);
 }
",1450,391
"Add ORA-3156: OCI call timed out to the list of error messages that result in
error DPI-1067."," int dpiError__setFromOCI(dpiError *error, int status, dpiConn *conn,
 conn->deadSession = 1;
 break;
 case 3136: // inbound connection timed out
+ case 3156: // OCI call timed out
 case 12161: // TNS:internal error: partial data received
 callTimeout = 0;
 if (conn->env->versionInfo->versionNum >= 18)
",160,73
"When provided an external service context handle, use that service context
handle and its associated environment handle rather than create new ones that
borrow the server and session handles of the external service context handle.
Creating new ones is unsupported and causes undesirable behavior. A connection
created in this way must have all of its references released before the
external service context and environment handles are destroyed."," int dpiPool_create(const dpiContext *context, const char *userName,
 return dpiGen__endPublicFn(context, DPI_FAILURE, &error);
 
 // initialize environment
- if (dpiEnv__init(tempPool->env, context, commonParams, &error) < 0) {
+ if (dpiEnv__init(tempPool->env, context, commonParams, NULL, &error) < 0) {
 dpiPool__free(tempPool, &error);
 return dpiGen__endPublicFn(context, DPI_FAILURE, &error);
 }
",353,96
Correct test numbering (eliminate duplicate test numbers).," static const char *dpiTestNames[NUM_EXECUTABLES] = {
 ""TestAQ"",
 ""TestLOBs"",
 ""TestImplicitResults"",
- ""TestRowIds"",
 ""TestScrollCursors"",
 ""TestSubscriptions"",
 ""TestBatchErrors"",
 static const char *dpiTestNames[NUM_EXECUTABLES] = {
 ""TestSodaDocCursor"",
 ""TestSessTags"",
 ""TestQueue"",
- ""TestBinds""
+ ""TestBinds"",
+ ""TestRowIds""
 };
 
 
",108,15
"Clear pointers if length is 0 -- as this is effectively the same as not passing
a pointer at all and is easier to check for."," static int dpiConn__get(dpiConn *conn, const char *userName,
 void *authInfo;
 uint32_t mode;
 
+ // clear pointers if length is 0
+ if (userNameLength == 0)
+ userName = NULL;
+ if (passwordLength == 0)
+ password = NULL;
+
 // set things up for the call to acquire a session
 if (pool) {
 dpiGen__setRefCount(pool, error, 1);
",1490,403
"Add support for providing double input for date sharding keys, as required by
environments like Node.js."," static int dpiConn__setShardingKeyValue(dpiConn *conn, void *shardingKey,
 &dateValue) < 0)
 return DPI_FAILURE;
 convertOk = 1;
+ } else if (column->nativeTypeNum == DPI_NATIVE_TYPE_DOUBLE) {
+ if (dpiDataBuffer__toOracleDateFromDouble(&column->value,
+ conn->env, error, &dateValue) < 0)
+ return DPI_FAILURE;
+ convertOk = 1;
 }
 break;
 case DPI_ORACLE_TYPE_TIMESTAMP:
",1495,405
Add support for setting maxSessionsPerShard attribute for session pools.," int dpiContext_initPoolCreateParams(const dpiContext *context,
 return dpiGen__endPublicFn(context, DPI_FAILURE, &error);
 DPI_CHECK_PTR_NOT_NULL(context, params)
 
- // size changed in version 3.1; can be dropped once version 4 released
- if (context->dpiMinorVersion > 0)
+ // size changed in versions 3.1 and 3.3
+ // changes can be dropped once version 4 released
+ if (context->dpiMinorVersion > 2) {
 dpiContext__initPoolCreateParams(params);
- else {
+ } else {
 dpiContext__initPoolCreateParams(&localParams);
- memcpy(params, &localParams, sizeof(dpiPoolCreateParams__v30));
+ if (context->dpiMinorVersion > 0) {
+ memcpy(params, &localParams, sizeof(dpiPoolCreateParams__v32));
+ } else {
+ memcpy(params, &localParams, sizeof(dpiPoolCreateParams__v30));
+ }
 }
 return dpiGen__endPublicFn(context, DPI_SUCCESS, &error);
 }
",181,37
"Improve error message when the library is loaded successfully but the ability
to detect the version of the library is impaired -- either due to the fact that
the library is too old (and didn't have the method to report its version) or
due to the fact that the method failed for some reason (such as 19.3 client on
Windows 7)."," static int dpiOci__loadLibValidate(dpiError *error)
 // determine the OCI client version information
 if (dpiOci__loadSymbol(""OCIClientVersion"",
 (void**) &dpiOciSymbols.fnClientVersion, NULL) < 0)
- return dpiError__set(error, ""check Oracle Client version"",
- DPI_ERR_ORACLE_CLIENT_TOO_OLD, 0, 0, 11, 2);
+ return dpiError__set(error, ""load symbol OCIClientVersion"",
+ DPI_ERR_ORACLE_CLIENT_UNSUPPORTED);
+ memset(&dpiOciLibVersionInfo, 0, sizeof(dpiOciLibVersionInfo));
 (*dpiOciSymbols.fnClientVersion)(&dpiOciLibVersionInfo.versionNum,
 &dpiOciLibVersionInfo.releaseNum,
 &dpiOciLibVersionInfo.updateNum,
 &dpiOciLibVersionInfo.portReleaseNum,
 &dpiOciLibVersionInfo.portUpdateNum);
+ if (dpiOciLibVersionInfo.versionNum == 0)
+ return dpiError__set(error, ""get OCI client version"",
+ DPI_ERR_ORACLE_CLIENT_UNSUPPORTED);
 dpiOciLibVersionInfo.fullVersionNum = (uint32_t)
 DPI_ORACLE_VERSION_TO_NUMBER(dpiOciLibVersionInfo.versionNum,
 dpiOciLibVersionInfo.releaseNum,
",2543,328
Add check for sharding key when super sharding key is specified.," static int dpiConn__setAttributesFromCreateParams(dpiConn *conn, void *handle,
 }
 if (params->superShardingKeyColumns &&
 params->numSuperShardingKeyColumns > 0) {
+ if (params->numShardingKeyColumns == 0)
+ return dpiError__set(error, ""ensure sharding key"",
+ DPI_ERR_MISSING_SHARDING_KEY);
 if (dpiConn__setShardingKey(conn, &conn->superShardingKey, handle,
 handleType, DPI_OCI_ATTR_SUPER_SHARDING_KEY,
 ""set super sharding key"", params->superShardingKeyColumns,
",1498,406
Added static declaration to make pedantic error checker happy.," static int dpiStmt__getBatchErrors(dpiStmt *stmt, dpiError *error)
 // update, delete and merge) or the number of rows fetched (for queries). In
 // all other cases, 0 is returned.
 //-----------------------------------------------------------------------------
-int dpiStmt__getRowCount(dpiStmt *stmt, uint64_t *count, dpiError *error)
+static int dpiStmt__getRowCount(dpiStmt *stmt, uint64_t *count,
+ dpiError *error)
 {
 uint32_t rowCount32;
 
",1288,385
Added support for client initiated connections for subscriptions.," int dpiContext_initSubscrCreateParams(const dpiContext *context,
 return dpiGen__endPublicFn(context, DPI_FAILURE, &error);
 DPI_CHECK_PTR_NOT_NULL(context, params)
 
- // size changed in version 3.2; can be dropped once version 4 released
- if (context->dpiMinorVersion > 1) {
+ // size changed in versions 3.2 and 3.3
+ // changes can be dropped once version 4 released
+ if (context->dpiMinorVersion > 3) {
 dpiContext__initSubscrCreateParams(params);
 } else {
 dpiContext__initSubscrCreateParams(&localParams);
- memcpy(params, &localParams, sizeof(dpiSubscrCreateParams__v30));
+ if (context->dpiMinorVersion > 1) {
+ memcpy(params, &localParams, sizeof(dpiSubscrCreateParams__v32));
+ } else {
+ memcpy(params, &localParams, sizeof(dpiSubscrCreateParams__v30));
+ }
 }
 return dpiGen__endPublicFn(context, DPI_SUCCESS, &error);
 }
",185,38
Correct minor version check.," int dpiContext_initSubscrCreateParams(const dpiContext *context,
 
 // size changed in versions 3.2 and 3.3
 // changes can be dropped once version 4 released
- if (context->dpiMinorVersion > 3) {
+ if (context->dpiMinorVersion > 2) {
 dpiContext__initSubscrCreateParams(params);
 } else {
 dpiContext__initSubscrCreateParams(&localParams);
",185,38
Minor tweaks to test suite.," int dpiTest_1310_verifyTypeInfoOfRecordType(dpiTestCase *testCase,
 return dpiTestCase_setFailedFromError(testCase);
 if (dpiTest__verifyObjectTypeInfo(testCase, &typeInfo,
 params->mainUserName, params->mainUserNameLength, ""UDT_RECORD"", 0,
- 0, 0, NULL, 5) < 0)
+ 0, 0, NULL, 7) < 0)
 return DPI_FAILURE;
 if (dpiObjectType_release(objType) < 0)
 return dpiTestCase_setFailedFromError(testCase);
",348,95
Ensure that the correct mode is used then a subscription is unregistered.," int dpiOci__subscriptionRegister(dpiConn *conn, void **handle, uint32_t mode,
 int dpiOci__subscriptionUnRegister(dpiConn *conn, dpiSubscr *subscr,
 dpiError *error)
 {
+ uint32_t mode;
 int status;
 
 DPI_OCI_LOAD_SYMBOL(""OCISubscriptionUnRegister"",
 dpiOciSymbols.fnSubscriptionUnRegister)
 DPI_OCI_ENSURE_ERROR_HANDLE(error)
+ mode = (subscr->clientInitiated) ? DPI_OCI_SECURE_NOTIFICATION :
+ DPI_OCI_DEFAULT;
 status = (*dpiOciSymbols.fnSubscriptionUnRegister)(conn->handle,
- subscr->handle, error->handle, DPI_OCI_DEFAULT);
+ subscr->handle, error->handle, mode);
 DPI_OCI_CHECK_AND_RETURN(error, status, conn, ""unregister"");
 }
 
",2547,329
"Only check the pointer if the length is greater than zero, and ensure that the
pointer is only examined if the length if greater than zero."," static int dpiVar__setFromBytes(dpiVar *var, uint32_t pos, const char *value,
 dynBytes = &var->buffer.dynamicBytes[pos];
 if (dpiVar__allocateDynamicBytes(dynBytes, valueLength, error) < 0)
 return DPI_FAILURE;
- memcpy(dynBytes->chunks->ptr, value, valueLength);
+ if (valueLength > 0)
+ memcpy(dynBytes->chunks->ptr, value, valueLength);
 dynBytes->numChunks = 1;
 dynBytes->chunks->length = valueLength;
 bytes->ptr = dynBytes->chunks->ptr;
 int dpiVar_setFromBytes(dpiVar *var, uint32_t pos, const char *value,
 
 if (dpiVar__checkArraySize(var, pos, __func__, &error) < 0)
 return dpiGen__endPublicFn(var, DPI_FAILURE, &error);
- DPI_CHECK_PTR_NOT_NULL(var, value)
+ DPI_CHECK_PTR_AND_LENGTH(var, value)
 if (var->nativeTypeNum != DPI_NATIVE_TYPE_BYTES &&
 var->nativeTypeNum != DPI_NATIVE_TYPE_LOB) {
 dpiError__set(&error, ""native type"", DPI_ERR_NOT_SUPPORTED);
",1334,383
"Allow the value parameter to be NULL in the call to dpiLob_setFromBytes() if
the length is zero."," int dpiLob_setFromBytes(dpiLob *lob, const char *value, uint64_t valueLength)
 
 if (dpiLob__check(lob, __func__, &error) < 0)
 return dpiGen__endPublicFn(lob, DPI_FAILURE, &error);
- DPI_CHECK_PTR_NOT_NULL(lob, value)
+ DPI_CHECK_PTR_AND_LENGTH(lob, value)
 status = dpiLob__setFromBytes(lob, value, valueLength, &error);
 return dpiGen__endPublicFn(lob, status, &error);
 }
",308,75
Preparing to release ODPI-C 3.3.," author = 'Oracle'
 version = '3.3'
 
 # the full version, including alpha/beta/rc tags
-release = '3.3.0-dev'
+release = '3.3.0'
 
 # the theme to use for HTML pages
 html_theme = 'oracle'
",26,3
"Add method dpiConn_startupDatabaseWithPfile() in order to support starting up a
database with a parameter file (PFILE), as requested
(https://github.com/oracle/odpi/issues/41)."," author = 'Oracle'
 # |release|, also used in various other places throughout the built documents
 #
 # the short X.Y version
-version = '3.3'
+version = '3.4'
 
 # the full version, including alpha/beta/rc tags
-release = '3.3.0'
+release = '3.4.0-dev'
 
 # the theme to use for HTML pages
 html_theme = 'oracle'
",26,3
Mark function as static since it is only used in this file.," static int dpiConn__setShardingKeyValue(dpiConn *conn, void *shardingKey,
 // Internal method for starting up a database. This is equivalent to
 // ""startup nomount"" in SQL*Plus.
 //-----------------------------------------------------------------------------
-int dpiConn__startupDatabase(dpiConn *conn, const char *pfile,
+static int dpiConn__startupDatabase(dpiConn *conn, const char *pfile,
 uint32_t pfileLength, dpiStartupMode mode, dpiError *error)
 {
 void *adminHandle = NULL;
",1541,414
"Acquire message code and text for informational errors (warnings), such as when
connecting to a database using an account that has a password that is about to
expire; member isWarning has been added to the dpiErrorInfo structure to
identify these."," int dpiGlobal__initError(const char *fnName, dpiError *error)
 tempErrorBuffer->messageLength = 0;
 tempErrorBuffer->fnName = fnName;
 tempErrorBuffer->action = ""start"";
+ tempErrorBuffer->isWarning = 0;
 strcpy(tempErrorBuffer->encoding, DPI_CHARSET_NAME_UTF8);
 }
 
",156,34
"When an INSERT ALL statement is executed, return NULL in the rowid parameter to
:func:`dpiStmt_getLastRowid()` instead of the error ""DPI-1004: unable to get
error message""."," int dpiOci__attrGet(const void *handle, uint32_t handleType, void *ptr,
 DPI_OCI_ENSURE_ERROR_HANDLE(error)
 status = (*dpiOciSymbols.fnAttrGet)(handle, handleType, ptr, size,
 attribute, error->handle);
- if (!action)
+ if (status == DPI_OCI_NO_DATA && size) {
+ *size = 0;
+ return DPI_SUCCESS;
+ } else if (!action) {
 return DPI_SUCCESS;
+ }
 DPI_OCI_CHECK_AND_RETURN(error, status, NULL, action);
 }
 
",2552,331
"Added support for converting all three timestamp types to/from double values
(number of milliseconds since January 1, 1970) as used by frameworks such as
Node.js."," static int dpiConn__setShardingKeyValue(dpiConn *conn, void *shardingKey,
 ""alloc LTZ timestamp"", error) < 0)
 return DPI_FAILURE;
 if (dpiDataBuffer__toOracleTimestampFromDouble(&column->value,
- conn->env, error, col) < 0) {
+ DPI_ORACLE_TYPE_TIMESTAMP_LTZ, conn->env, error,
+ col) < 0) {
 dpiOci__descriptorFree(col, descType);
 return DPI_FAILURE;
 }
",1542,414
"Modified offset member of structure dpiErrorInfo to be 32-bit instead of 16-bit
in order to allow for row offsets that exceed 65536. The original member has
been renamed to offset16 in order to retain backwards compatibility
(https://github.com/oracle/node-oracledb/issues/1157)."," int dpiError__getInfo(dpiError *error, dpiErrorInfo *info)
 return DPI_FAILURE;
 info->code = error->buffer->code;
 info->offset = error->buffer->offset;
+ info->offset16 = (uint16_t) error->buffer->offset;
 info->message = error->buffer->message;
 info->messageLength = error->buffer->messageLength;
 info->fnName = error->buffer->fnName;
",168,75
"Internally make use of new mode available in Oracle Client 20 and higher in
order to avoid a round-trip when calling dpiConn_getServerVersion() for the
first time with a NULL value for the releaseString parameter."," int dpiOci__serverDetach(dpiConn *conn, int checkError, dpiError *error)
 // Wrapper for OCIServerRelease().
 //-----------------------------------------------------------------------------
 int dpiOci__serverRelease(dpiConn *conn, char *buffer, uint32_t bufferSize,
- uint32_t *version, dpiError *error)
+ uint32_t *version, uint32_t mode, dpiError *error)
 {
 int status;
 
 int dpiOci__serverRelease(dpiConn *conn, char *buffer, uint32_t bufferSize,
 DPI_OCI_LOAD_SYMBOL(""OCIServerRelease2"",
 dpiOciSymbols.fnServerRelease2)
 status = (*dpiOciSymbols.fnServerRelease2)(conn->handle, error->handle,
- buffer, bufferSize, DPI_OCI_HTYPE_SVCCTX, version,
- DPI_OCI_DEFAULT);
+ buffer, bufferSize, DPI_OCI_HTYPE_SVCCTX, version, mode);
 }
 DPI_OCI_CHECK_AND_RETURN(error, status, conn, ""get server version"");
 }
",2579,333
"Added support for SODA collection truncate, available in Oracle Client 20 and
higher."," int dpiSodaColl_save(dpiSodaColl *coll, dpiSodaDoc *doc, uint32_t flags,
 status = dpiSodaColl__save(coll, doc, flags, savedDoc, &error);
 return dpiGen__endPublicFn(coll, status, &error);
 }
+
+
+//-----------------------------------------------------------------------------
+// dpiSodaColl_truncate() [PUBLIC]
+// Remove all of the documents in the collection.
+//-----------------------------------------------------------------------------
+int dpiSodaColl_truncate(dpiSodaColl *coll)
+{
+ dpiError error;
+ int status;
+
+ // validate parameters
+ if (dpiSodaColl__check(coll, __func__, &error) < 0)
+ return dpiGen__endPublicFn(coll, DPI_FAILURE, &error);
+
+ // truncate is only supported with Oracle Client 20+
+ if (dpiUtils__checkClientVersion(coll->env->versionInfo, 20, 1,
+ &error) < 0)
+ return dpiGen__endPublicFn(coll, DPI_FAILURE, &error);
+
+ // perform truncate
+ status = dpiOci__sodaCollTruncate(coll, &error);
+ return dpiGen__endPublicFn(coll, status, &error);
+}
",553,132
"Added support for specifying the fetch array size to use when fetching
documents from a SODA collection (available in Oracle Client 19.5 and higher)."," static int dpiSodaColl__createOperOptions(dpiSodaColl *coll,
 }
 }
 
+ // set fetch array size, if applicable (only available in 19.5+ client)
+ if (options->fetchArraySize > 0) {
+ if (dpiUtils__checkClientVersion(coll->env->versionInfo, 19, 5,
+ error) < 0)
+ return DPI_FAILURE;
+ if (dpiOci__attrSet(*handle, DPI_OCI_HTYPE_SODA_OPER_OPTIONS,
+ (void*) &options->fetchArraySize, 0,
+ DPI_OCI_ATTR_SODA_FETCH_ARRAY_SIZE, ""set fetch array size"",
+ error) < 0) {
+ dpiOci__handleFree(*handle, DPI_OCI_HTYPE_SODA_OPER_OPTIONS);
+ return DPI_FAILURE;
+ }
+ }
+
 return DPI_SUCCESS;
 }
 
",565,135
"Added support for returning a DATE value as a native double (number of
milliseconds since January 1, 1970) as used by environments like Node.js."," int dpiVar__getValue(dpiVar *var, dpiVarBuffer *buffer, uint32_t pos,
 case DPI_ORACLE_TYPE_NATIVE_DOUBLE:
 data->value.asDouble = buffer->data.asDouble[pos];
 return DPI_SUCCESS;
+ case DPI_ORACLE_TYPE_DATE:
+ return dpiDataBuffer__fromOracleDateAsDouble(&data->value,
+ var->env, error, &buffer->data.asDate[pos]);
 case DPI_ORACLE_TYPE_TIMESTAMP:
 case DPI_ORACLE_TYPE_TIMESTAMP_TZ:
 case DPI_ORACLE_TYPE_TIMESTAMP_LTZ:
",1337,384
Use permanent URL for Oracle Sharding manual.,"
 // provided does not include suppoort for running this demo. A sharded database
 // must first be created. Information on how to create a sharded database can
 // be found in the documentation:
-// https://docs.oracle.com/en/database/oracle/oracle-database/19/shard/index.html
+// https://www.oracle.com/pls/topic/lookup?ctx=dblatest&id=SHARD
 //-----------------------------------------------------------------------------
 
 #include ""SampleLib.h""
",52,11
"Add comment specifying that open LOBs are closed with Oracle Client 20 and
higher."," static int dpiConn__close(dpiConn *conn, uint32_t mode, const char *tag,
 }
 
 // close all open LOBs; the same comments apply as for statements
+ // NOTE: Oracle Client 20 automatically closes all open LOBs which makes
+ // this code redundant; as such, it can be removed once the minimum version
+ // supported by ODPI-C is 20
 if (conn->openLobs && !conn->externalHandle) {
 for (i = 0; i < conn->openLobs->numSlots; i++) {
 lob = (dpiLob*) conn->openLobs->handles[i];
",1559,421
"The default encoding for all character data is now UTF-8; version has been
bumped to 4.0.0; support added for controlling (and debugging) how the Oracle
Client library is loaded (https://github.com/oracle/odpi/issues/132)."," author = 'Oracle'
 # |release|, also used in various other places throughout the built documents
 #
 # the short X.Y version
-version = '3.4'
+version = '4.0'
 
 # the full version, including alpha/beta/rc tags
-release = '3.4.0-dev'
+release = '4.0.0-dev'
 
 # the theme to use for HTML pages
 html_theme = 'oracle'
",26,3
Simplify check for GNU libc variant of strerror_r().," int dpiError__setFromOS(dpiError *error, const char *action)
 
 char buffer[512];
 int err = errno;
-#if defined _GNU_SOURCE && !defined __APPLE__
+#if defined(__GLIBC__)
 message = strerror_r(err, buffer, sizeof(buffer));
 #else
 message = (strerror_r(err, buffer, sizeof(buffer)) == 0) ? buffer : NULL;
",189,81
Preparing to release ODPI-C 4.0.0.," author = 'Oracle'
 version = '4.0'
 
 # the full version, including alpha/beta/rc tags
-release = '4.0.0-dev'
+release = '4.0.0'
 
 # the theme to use for HTML pages
 html_theme = 'oracle'
",26,3
"Ensure that all members of the dpiErrorInfo structure parameter are set
properly during a call to dpiContext_getError()."," author = 'Oracle'
 version = '4.0'
 
 # the full version, including alpha/beta/rc tags
-release = '4.0.0'
+release = '4.0.1'
 
 # the theme to use for HTML pages
 html_theme = 'oracle'
",26,3
"Adjusted check for GNU version of strerror_r() on Cygwin as suggested
(https://github.com/oracle/odpi/issues/138)."," author = 'Oracle'
 # |release|, also used in various other places throughout the built documents
 #
 # the short X.Y version
-version = '4.0'
+version = '4.1'
 
 # the full version, including alpha/beta/rc tags
-release = '4.0.1'
+release = '4.1.0-dev'
 
 # the theme to use for HTML pages
 html_theme = 'oracle'
",26,3
Bump copyright into 2020.,"
 # -*- coding: utf-8 -*-
 
 #------------------------------------------------------------------------------
-# Copyright (c) 2016, 2019 Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2016, 2020 Oracle and/or its affiliates. All rights reserved.
 # This program is free software: you can modify it and/or redistribute it
 # under the terms of:
 #
 master_doc = 'index'
 
 # general information about the project
 project = 'ODPI-C'
-copyright = '2016, 2019, Oracle and/or its affiliates. All rights reserved.'
+copyright = '2016, 2020, Oracle and/or its affiliates. All rights reserved.'
 author = 'Oracle'
 
 # the version info for the project, acts as replacement for |version| and
",26,3
Documentation tweaks.," templates_path = ['_templates']
 # the suffix used for all source files
 source_suffix = '.rst'
 
-# the name of the master document
+# the name of the main document
 master_doc = 'index'
 
 # general information about the project
",26,3
Search for 21c libraries as well now that 21c is nearing release.," static const char *dpiOciLibNames[] = {
 ""libclntsh.dylib.12.1"",
 ""libclntsh.dylib.11.1"",
 ""libclntsh.dylib.20.1"",
+ ""libclntsh.dylib.21.1"",
 #else
 ""libclntsh.so"",
 ""libclntsh.so.19.1"",
 static const char *dpiOciLibNames[] = {
 ""libclntsh.so.12.1"",
 ""libclntsh.so.11.1"",
 ""libclntsh.so.20.1"",
+ ""libclntsh.so.21.1"",
 #endif
 NULL
 };
",2755,180
"The default encodings are now UTF-8, not NULL, so ensure that the default
values are used by calling the initialization routine instead of simply
overwriting to NULL."," int dpiTest_606_encodingInfo(dpiTestCase *testCase, dpiTestParams *params)
 return dpiTestCase_setFailedFromError(testCase);
 
 // create pool with just the encoding specified
+ if (dpiContext_initCommonCreateParams(context, &commonParams) < 0)
+ return dpiTestCase_setFailedFromError(testCase);
 commonParams.encoding = charSet;
- commonParams.nencoding = NULL;
 if (dpiPool_create(context, params->mainUserName,
 params->mainUserNameLength, params->mainPassword,
 params->mainPasswordLength, params->connectString,
 int dpiTest_606_encodingInfo(dpiTestCase *testCase, dpiTestParams *params)
 return dpiTestCase_setFailedFromError(testCase);
 
 // create pool with just the nencoding specified
- commonParams.encoding = NULL;
+ if (dpiContext_initCommonCreateParams(context, &commonParams) < 0)
+ return dpiTestCase_setFailedFromError(testCase);
 commonParams.nencoding = charSet;
 if (dpiPool_create(context, params->mainUserName,
 params->mainUserNameLength, params->mainPassword,
",230,68
"Newer versions of the Oracle Client have more specific error messages so
account for those."," int dpiTest_2609_verifyFind(dpiTestCase *testCase, dpiTestParams *params)
 //-----------------------------------------------------------------------------
 int dpiTest_2610_testInvalidJson(dpiTestCase *testCase, dpiTestParams *params)
 {
- const char *expectedErrors[] = { ""ORA-02290:"", ""ORA-40479:"", NULL };
+ const char *expectedErrors[] = { ""ORA-02290:"", ""ORA-40479:"", ""ORA-40780:"",
+ NULL };
 const char *content = ""{\""test : 2610 content\""}"";
 const char *collName = ""ODPIC_COLL_2610"";
 dpiSodaColl *coll;
 int dpiTest_2614_verifyInsertManyWorksAsExpected(dpiTestCase *testCase,
 int dpiTest_2615_testInsertManyWithInvalidJson(dpiTestCase *testCase,
 dpiTestParams *params)
 {
- const char *expectedErrors[] = { ""ORA-02290:"", ""ORA-40479:"", NULL };
+ const char *expectedErrors[] = { ""ORA-02290:"", ""ORA-40479:"", ""ORA-40780:"",
+ NULL };
 const char *contents[5] = {
 ""{\""test1\"" : \""2615 content1\""}"",
 ""{\""test2\"" : \""2615 content2\""}"",
",998,294
"Workaround unexpected error when calling dpiLob_readBytes() with a very small
value in the valueLength parameter (#146)."," int dpiOci__lobRead2(dpiLob *lob, uint64_t offset, uint64_t *amountInBytes,
 lob->locator, amountInBytes, amountInChars, offset, buffer,
 bufferLength, DPI_OCI_ONE_PIECE, NULL, NULL, charsetId,
 lob->type->charsetForm);
+ if (status == DPI_OCI_NEED_DATA) {
+ *amountInChars = 0;
+ *amountInBytes = 0;
+ return DPI_SUCCESS;
+ }
 DPI_OCI_CHECK_AND_RETURN(error, status, lob->conn, ""read from LOB"");
 }
 
",2760,180
"Ensure that calls to dpiStmt_setPrefetchRows() are honored when binding as a
REF cursor."," int dpiVar__setValue(dpiVar *var, dpiVarBuffer *buffer, uint32_t pos,
 case DPI_NATIVE_TYPE_BOOLEAN:
 buffer->data.asBoolean[pos] = data->value.asBoolean;
 return DPI_SUCCESS;
+ case DPI_NATIVE_TYPE_STMT:
+ return dpiOci__attrSet(data->value.asStmt->handle,
+ DPI_OCI_HTYPE_STMT, &data->value.asStmt->prefetchRows,
+ sizeof(data->value.asStmt->prefetchRows),
+ DPI_OCI_ATTR_PREFETCH_ROWS,
+ ""set prefetch rows for REF cursor"", error);
 default:
 break;
 }
",1343,385
"Added support for the new JSON data type available in Oracle Client and
Database 21 and higher."," static const dpiTypeDef dpiAllTypeDefs[DPI_HTYPE_MAX - DPI_HTYPE_NONE - 1] = {
 sizeof(dpiQueue), // size of structure
 0x54904ba2, // check integer
 (dpiTypeFreeProc) dpiQueue__free
+ },
+ {
+ ""dpiJson"", // name
+ sizeof(dpiJson), // size of structure
+ 0xf6712bec, // check integer
+ (dpiTypeFreeProc) dpiJson__free
 }
 };
 
",222,27
Preparing to release ODPI-C 4.1.," author = 'Oracle'
 version = '4.1'
 
 # the full version, including alpha/beta/rc tags
-release = '4.1.0-dev'
+release = '4.1.0'
 
 # the theme to use for HTML pages
 html_theme = 'oracle'
",26,3
"First check-in of the skeleton kernel module code. Provides the module
loading, module dependency, and device file support basics. With the right
modprobe aliases, on-demand loading of the modules is possible.","
+/*
+ * FILE:dtrace_mod.c
+ * DESCRIPTION:Dynamic Tracing: module handling
+ *
+ * Copyright (C) 2010 Oracle Corporation
+ */
+
+#include <linux/module.h>
+
+#include ""dtrace_dev.h""
+
+MODULE_AUTHOR(""Kris Van Hees (kris.van.hees@oracle.com)"");
+MODULE_DESCRIPTION(""Dynamic Tracing"");
+MODULE_VERSION(""v0.1"");
+MODULE_LICENSE(""Proprietary"");
+
+static int __init dtrace_init(void)
+{
+return 0;
+}
+
+static void __exit dtrace_exit(void)
+{
+}
+
+module_init(dtrace_init);
+module_exit(dtrace_exit);
",15,2
"Continuation of the initial import of the DTrace port for Linux. The code is
currently still requiring various fixes (as indicated by FIXME).","
+/*
+ * FILE:dtrace_predicate.c
+ * DESCRIPTION:Dynamic Tracing: predicate functions
+ *
+ * Copyright (C) 2010 Oracle Corporation
+ */
+
+#include <linux/slab.h>
+
+#include ""dtrace.h""
+
+void dtrace_predicate_hold(dtrace_predicate_t *pred)
+{
+BUG_ON(pred->dtp_difo == NULL || pred->dtp_difo->dtdo_refcnt == 0);
+BUG_ON(pred->dtp_refcnt <= 0);
+
+pred->dtp_refcnt++;
+}
+
+void dtrace_predicate_release(dtrace_predicate_t *pred,
+ dtrace_vstate_t *vstate)
+{
+dtrace_difo_t *dp = pred->dtp_difo;
+
+BUG_ON(dp == NULL || dp->dtdo_refcnt == 0);
+BUG_ON(pred->dtp_refcnt <= 0);
+
+if (--pred->dtp_refcnt == 0) {
+dtrace_difo_release(pred->dtp_difo, vstate);
+kfree(pred);
+}
+}
",19,5
"More work on the provider registration, unregistration, and dtrace device file
handling (dtrace_open)."," success:
  * to use kmalloc to aovid the vmalloc overhead (since vmalloc aligns
  * all allocations on a page boundary).
  */
-aggid = (dtrace_aggid_t)kmalloc(1, GFP_KERNEL);
+aggid = (dtrace_aggid_t)(uintptr_t)kmalloc(1, GFP_KERNEL);
 
 if (aggid - 1 >= state->dts_naggregations) {
 dtrace_aggregation_t**oaggs = state->dts_aggregations;
 static dtrace_ecb_t *dtrace_ecb_add(dtrace_state_t *state,
 if (oecbs != NULL)
 memcpy(oecbs, ecbs, state->dts_necbs * sizeof (*ecbs));
 
-#ifdef FIXME
 dtrace_membar_producer();
-#endif
 
 state->dts_ecbs = ecbs;
 
 static dtrace_ecb_t *dtrace_ecb_add(dtrace_state_t *state,
 kfree(oecbs);
 }
 
-#ifdef FIXME
 dtrace_membar_producer();
-#endif
 
 state->dts_necbs = necbs;
 }
 static dtrace_ecb_t *dtrace_ecb_add(dtrace_state_t *state,
 
 BUG_ON(state->dts_ecbs[epid - 1] != NULL);
 
-#ifdef FIXME
 dtrace_membar_producer();
-#endif
 
 state->dts_ecbs[(ecb->dte_epid = epid) - 1] = ecb;
 
",459,130
"Add ChangeLog.
Remove include/processor.h.
Modify the files at diretory libproc.","
 //#include <atomic.h>
 #include <sys/types.h>
 #include <sys/uio.h>
-#include <sys/stat.h>
 #include <sys/resource.h>
 #include <sys/param.h>
 //#include <sys/stack.h>
+#include <sys/stat.h>
 #include <sys/fault.h>
 #include <sys/syscall.h>
 #include <sys/sysmacros.h>

 #include ""Putil.h""
 #include ""P32ton.h""
 
+
 int_libproc_debug;/* set non-zero to enable debugging printfs */
 int_libproc_no_qsort;/* set non-zero to inhibit sorting */
 /* of symbol tables */
",2604,660
"2010-09-08 Shujing Zhao <pearly.zhao@oracle.com>

 * Define __USE_ATFILE before include <fcntl.h> when use AT_*
 constants.
 * Add makefile for libproc and libdtrace.
 * Adjust the header files.","
 #include <libgen.h>
 #include <limits.h>
 
-#include <processor.h>
+#include <sys/processor.h>
 
 #include <dt_impl.h>
 
",632,157
"2010-09-10 Shujing Zhao <pearly.zhao@oracle.com>

 * libport: Add compat functions support at libport.
 * libdtrace/makefile: Handle the dt_lex.l and add it to the lib.
 * libdtrace/dt_impl.h: Define different yytext at Linux.","
+#include <types_time.h>
+#include <time.h>
+hrtime_t
+gethrtime()
+{
+ struct timespec sp;
+ int ret;
+ long long v;
+
+ ret = clock_gettime(CLOCK_REALTIME, &sp);
+ if (ret)
+ return 0;
+
+ v = 1000000000LL;
+ v *= sp.tv_sec;
+ v += sp.tv_nsec;
+
+ return v;
+}
+
",16,2
"2010-09-16 Shujing Zhao <pearly.zhao@oracle.com>

 * include/mutex.h, libdtrace, libproc, librtld: Fix the mutex
 problems.
 * libport/proc_name.c, libport/strlcat.c: Added.
 * include/port.h, uts/common/sys/mnttab.h, include/sys/bitmap.h,
 include/sys/elftypes.h: Added.","
 #pragma ident""%Z%%M%%I%%E% SMI""
 
 #include <sys/types.h>
+#include <sys/bitmap.h>
 #include <strings.h>
 #include <stdlib.h>
 #include <assert.h>
",331,78
"2010-09-17 Shujing Zhao <pearly.zhao@oracle.com>

 * libport/gmatch.c: Added.
 * librtld/makefile, libctf/makefile: Added.
 * include/types_various.h, include/types_off.h: Update.","
+#ifndef _GMATCH_H
+#define _GMATCH_H
+#include <fnmatch.h>
+
+int
+gmatch(const char *s, const char *p)
+{
+ return (fnmatch (s, p, 0) == 0);
+}
+
+#endif
",6,1
"2010-09-21 Shujing Zhao <pearly.zhao@oracle.com>

 * include/objfs.h: Move to uts/common/sys/.
 * libdtrace/makefile: Export correct format to dt_errtags.c.
 * libdtrace/dt_impl.h, dt_open.c, dt_parser.c, dt_dof.c: Fixed include
 header files.
 * librtld/makefile: Fix the compile options.
 * include/types_various.h: Add ABS macro and and move OBJFS_ROOT to
 objfs.h.","
 
 #include <sys/types.h>
 #include <sys/sysmacros.h>
+#include <sys/bitmap.h>
 
 #include <string.h>
 #include <alloca.h>
",632,92
"2010-09-27 Shujing Zhao <pearly.zhao@oracle.com>

 * include/rtld_db.h, include/types_off.h: Adjust definition.
 * libctf/makefile: Use /usr/bin/gcc.
 * libport/makefile, libport/p_online.c, libport/tasksys.c: New.
 * libproc/common/makefile: Use -D_LARGEFILE64_SOURCE=1 to make the
 off64_t available.
 * libproc/common/Pzone.c: Comment some functions now be compiled.
 * librtld/rd_elf.c: New.
 * librtld/makefile: Added rd_elf.o to LIB.
 * librtld/rtld_db.c (rd_loadobj_iter, rd_event_addr, rd_event_enable,
 rd_event_getmsg): Change.
 (rd_plt_resolution, rd_objpad_enable): Remove.","
+#include <sys/processor.h>
+int
+p_online (processorid_t cpun, int new_status)
+{
+ return 2;
+}
",6,1
"Added more functionality along the device close path. Stub for the cyclic
implementation.","
+/*
+ * FILE:dtrace_state.c
+ * DESCRIPTION:Dynamic Tracing: consumer state functions
+ *
+ * Copyright (C) 2010 Oracle Corporation
+ */
+
+#include ""cyclic.h""
+
+/*
+ * Remove the specific cyclic from the system.
+ */
+void cyclic_remove(cyclic_id_t id)
+{
+}
",4,1
"2010-10-15 Shujing Zhao <pearly.zhao@oracle.com>

 * librtld/rtld_db.c: Comment some functions.
 * cmd/common/makefile: New.
 * include/mutex.h: Declare mutex_init.
 * include/procs_service.h: include elf.h.
 * include/rtld_db.h: Update declaration.
 * include/type_posix.h: Define off64_t.
 * libdtrace/dt_cc.c: Define yylineno.
 * libdtrace/dt_lex.l: Define unput.
 * libdtrace/makefile: Fix compile option.
 * libport/proc_name.c: Define fork1.
 * libport/time.c: Define pthread_cond_reltimedwait_np, mutex_init and
 _lwp_kill.
 * libproc/common/makefile: Fix.
 * libproc/common/Pcontrol.c, libproc/common/Pexecname.c,
 libproc/common/Pzone.c: Comment some lines that are not supported by
 Linux.","
 #include <dt_string.h>
 #include <dt_impl.h>
 
+int yylineno;
+
 static const dtrace_diftype_t dt_void_rtype = {
 DIF_TYPE_CTF, CTF_K_INTEGER, 0, 0, 0
 };
",1609,380
"2010-10-25 Paolo Carlini <paolo.carlini@oracle.com>

	* libdtrace/drti.c (dprintf): Remove."," static int gen;/* DOF helper generation */
 extern dof_hdr_t __SUNW_dof;/* DOF defined in the .SUNW_dof section */
 static boolean_t dof_init_debug = B_FALSE;/* From DTRACE_DOF_INIT_DEBUG */
 
-static void
-dprintf(int debug, const char *fmt, ...)
-{
-va_list ap;
-
-if (debug && !dof_init_debug)
-return;
-
-va_start(ap, fmt);
-
-if (modname == NULL)
-(void) fprintf(stderr, ""dtrace DOF: "");
-else
-(void) fprintf(stderr, ""dtrace DOF %s: "", modname);
-
-(void) vfprintf(stderr, fmt, ap);
-
-if (fmt[strlen(fmt) - 1] != '\n')
-(void) fprintf(stderr, "": %s\n"", strerror(errno));
-
-va_end(ap);
-}
-
 #pragma init(dtrace_dof_init)
 static void
 dtrace_dof_init(void)
",94,23
"2010-11-04 Shujing Zhao <pearly.zhao@oracle.com>

	* include/types_various.h (SYS_getpeername, SYS_getsockname and
	SYS_getsockopt): New.
	* include/sys/old_procfs.h: Make old_procfs.h can be included even
	_LP64 is not defined.
	* libdtrace/dt_module.c: Use elf_getshstrndx instead of
	elf_getshdrstrndx.
	* libport/elf.c: Removed.
	* libport/makefile: Remove elf.o and fix the compile option.
	* libproc/common/Psymtab.c: Use elf_getshstrndx and elf_getshnum
	instead of elf_getshdrstrndx and elf_getshdrnum."," dt_module_load_sect(dtrace_hdl_t *dtp, dt_module_t *dmp, ctf_sect_t *ctsp)
 Elf_Data *dp;
 Elf_Scn *sp;
 
-if (elf_getshdrstrndx(dmp->dm_elf, &shstrs) == -1)
+/*if (elf_getshdrstrndx(dmp->dm_elf, &shstrs) == -1) */
+if (elf_getshstrndx(dmp->dm_elf, &shstrs) != 1)
 return (dt_set_errno(dtp, EDT_NOTLOADED));
 
 for (sp = NULL; (sp = elf_nextscn(dmp->dm_elf, sp)) != NULL; ) {
 dt_module_update(dtrace_hdl_t *dtp, const char *name)
 (void) close(fd);
 
 if (dmp->dm_elf == NULL || err == -1 ||
- elf_getshdrstrndx(dmp->dm_elf, &shstrs) == -1) {
+/* elf_getshdrstrndx(dmp->dm_elf, &shstrs) == -1) { */
+ elf_getshstrndx(dmp->dm_elf, &shstrs) != 1) {
 dt_dprintf(""failed to load %s: %s\n"",
  fname, elf_errmsg(elf_errno()));
 dt_module_destroy(dtp, dmp);
",922,236
"Updated kernel/dtrace subtree for the Linux 2.6.34 kernel.
WARNING: This will not compile correctly - merely a WorkInProgress commit.","
 /*
- * FILE:dtrace_state.c
- * DESCRIPTION:Dynamic Tracing: consumer state functions
+ * FILE:cyclic.c
+ * DESCRIPTION:Cyclic implementation
 *
 * Copyright (C) 2010 Oracle Corporation
 */
 
 #include ""cyclic.h""
 
+/*
+ * Add a new cyclic to the system.
+ */
+cyclic_id_t cyclic_add(cyc_handler_t *hdlr, cyc_time_t *when)
+{
+return 0;
+}
+
 /*
 * Remove the specific cyclic from the system.
 */
",8,2
"* libdtrace/dt_proc.c (dt_proc_control): Set dpr->dpr_quit to 1
 instead of write ctl file.
 * libproc/common/Pcontrol.c (Pxcreate): Don't detach to the child
 process.
 (Psetrun): Restarts the stopped child process by ptrace instead of
 write to the ctl file.
 * libproc/common/Psymtab.c (Pupdate_maps): Use fclose instead of close
 to close the file."," dt_proc_control(void *arg)
  */
 while (!dpr->dpr_quit) {
 const lwpstatus_t *psp;
-
+#if 0
 if (write(pfd, &wstop, sizeof (wstop)) == -1 && errno == EINTR)
 continue; /* check dpr_quit and continue waiting */
-
+#endif
+dpr->dpr_quit = 1;
 (void) pthread_mutex_lock(&dpr->dpr_lock);
 pwait_locked:
 if (Pstopstatus(P, PCNULL, 0) == -1 && errno == EINTR) {
",653,141
"* cmd/common/dtrace.c: set environment variable POSIXLY_CORRECT to
 make getopt works on Linux."," main(int argc, char *argv[])
 struct ps_prochandle *P;
 pid_t pid;
 
+setenv(""POSIXLY_CORRECT"", ""true"", 1);
+
 g_pname = basename(argv[0]);
 
 if (argc == 1)
",1291,321
"Commit of the latest snapshot of the DTrace core changes to the Linux 2.6.34
kernel. Implementation of the emulator/interpreter completed. Finishing up
the dtrace_probe execution path through implementation of actions and some
remaining speculation handling."," static void dtrace_toxrange_add(uintptr_t base, uintptr_t limit)
 dtrace_toxranges++;
 }
 
+/*
+ * Check if an address falls within a toxic region.
+ */
+int dtrace_istoxic(uintptr_t kaddr, size_t size)
+{
+uintptr_ttaddr, tsize;
+inti;
+
+for (i = 0; i < dtrace_toxranges; i++) {
+taddr = dtrace_toxrange[i].dtt_base;
+tsize = dtrace_toxrange[i].dtt_limit - taddr;
+
+if (kaddr - taddr < tsize) {
+DTRACE_CPUFLAG_SET(CPU_DTRACE_BADADDR);
+cpu_core[smp_processor_id()].cpuc_dtrace_illval = kaddr;
+return 1;
+}
+
+if (taddr - kaddr < size) {
+DTRACE_CPUFLAG_SET(CPU_DTRACE_BADADDR);
+cpu_core[smp_processor_id()].cpuc_dtrace_illval = taddr;
+return 1;
+}
+}
+
+return 0;
+}
+
 /*
 * Initialize the DTrace core.
 *
",540,93
"* librtld/rtld_db.c: Move rd_loadobj_iter to ...
 * libproc/common/Psymtab.c: here and remove the first parameter rap
 and adjust the callers.
 * include/rtld_db.h (rd_loadobj_iter): Remove.
 * libproc/common/Pcontrol.h (rd_loadobj_iter): Declare."," Pfgrab_core(int core_fd, const char *aout_path, int *perr)
 rd_log(_libproc_debug);
 
 if ((P->rap = rd_new(P)) != NULL) {
-(void) rd_loadobj_iter(P->rap, (rl_iter_f *)
- core_iter_mapping, P);
+(void) rd_loadobj_iter((rl_iter_f *)core_iter_mapping, P);
 
 if (P->core->core_errno != 0) {
 errno = P->core->core_errno;
",1404,327
Latest checkpoint commit - compiles but does not link correctly (yet).," next:
 *end-- = '.';
 }
 ASSERT(end + 1 >= base);
-
+#ifdef CONFIG_IPV6
 } else if (af == AF_INET6) {
 struct in6_addr ip6;
 int firstzero, tryzero, numzero, v6end;
 next:
 }
 }
 ASSERT(end + 1 >= base);
-
+#endif
 } else {
 /*
  * The user didn't use AH_INET or AH_INET6.
",2812,843
* libproc/common/Psymtab.c (get_saddrs): Initial addrs to NULL.," addr_cmp(const void *aa, const void *bb)
 static uintptr_t *
 get_saddrs(struct ps_prochandle *P, uintptr_t ehdr_start, uint_t *n)
 {
-uintptr_t a, addr, *addrs, last = 0;
+uintptr_t a, addr, *addrs = NULL, last = 0;
 uint_t i, naddrs = 0, unordered = 0;
 
 if (P->status.pr_dmodel == PR_MODEL_ILP32) {
",2207,652
"* libdtrace/dt_open.c: Fix the directory of _dtrace_defcpp.
 * libdtrace/io.sed.in, ip.sed.in, net.sed.in, procfs.sed.in,
 sysevent.sed.in, tcp.sed.in, udp.sed.in, i386/regs.sed.in: Remove the
 header files that are not existed.
 * libdtrace/makefile: Compile the D library and install to
 /usr/lib/dtrace."," const dtrace_pattr_t _dtrace_prvdesc = {
 const char *_dtrace_defcpp = ""/usr/ccs/lib/cpp""; /* default cpp(1) to invoke */
 const char *_dtrace_defld = ""/usr/ccs/bin/ld""; /* default ld(1) to invoke */
 #endif
-const char *_dtrace_defcpp = ""/usr/lib/cpp""; /* default cpp(1) to invoke */
+const char *_dtrace_defcpp = ""/usr/bin/cpp""; /* default cpp(1) to invoke */
 const char *_dtrace_defld = ""/usr/bin/ld""; /* default ld(1) to invoke */
 
 const char *_dtrace_libdir = ""/usr/lib/dtrace""; /* default library directory */
",982,128
"Latest version of the Dtrace core code. Both as extracted files and patch
against 2.6.34 vanilla kernel sources. Everything compiles (there is a single
warning about an unused variable, pending implementation of an API to run
through the list of loaded modules), but there are still some functions left to
be implemented."," struct sched_param {
 #include <linux/latencytop.h>
 #include <linux/cred.h>
 
-#include <linux/clocksource.h>
-
 #include <asm/processor.h>
 
 struct exec_domain;
",1236,133
"* cmd/common/dtrace.c: Assigned g_ofp to stdout in main function for
 stdout is a macro and not be address constants at compile time.
 * demo/*: Add more test cases.
 * runtest.sh: Added.
 * libdtrace/makefile: Adjust regs.d.
 * makefile: Adjust."," static int g_mode = DMODE_EXEC;
 static int g_status = E_SUCCESS;
 static int g_grabanon = 0;
 static const char *g_ofile = NULL;
-static FILE *g_ofp;
+static FILE *g_ofp = NULL;
 static dtrace_hdl_t *g_dtp;
 static char *g_etcfile = ""/etc/system"";
 static const char *g_etcbegin = ""* vvvv Added by DTrace"";
 main(int argc, char *argv[])
 struct ps_prochandle *P;
 pid_t pid;
 
+g_ofp = stdout;
+
 setenv(""POSIXLY_CORRECT"", ""true"", 1);
 
 g_pname = basename(argv[0]);
",1292,321
"* libproc/common/Putil.c: Change dprintf to _dprintf.
 * libproc/common/Putil.h: Adjust.
 * libproc/common/Pcontrol.c, libproc/common/Pexecname.c,
 libproc/common/Psymtab_machelf32.c, libproc/common/Pzone.c,
 libproc/common/Pidle.c, libproc/common/pr_meminfo.c,
 libproc/common/Pscantext.c, common/Pstack.c, libproc/common/Psymtab.c,
 libproc/common/Pcore.c, libproc/common/Pservice.c: Adjust caller."," try_exec(struct ps_prochandle *P, const char *cwd, const char *path, char *buf,
 else
 (void) strcpy(buf, path);
 
-dprintf(""try_exec \""%s\""\n"", buf);
+_dprintf(""try_exec \""%s\""\n"", buf);
 
 (void) Pfindobj(P, buf, buf, PATH_MAX);
 /* FIX ME */
 Pfindexec(struct ps_prochandle *P, const char *aout,
 uintptr_t addr;
 char *p = path, *q;
 
-dprintf(""Pfindexec '%s'\n"", aout);
+_dprintf(""Pfindexec '%s'\n"", aout);
 
 if (P->execname)
 return (P->execname); /* Already found */
 Pfindexec(struct ps_prochandle *P, const char *aout,
 
 found:
 if ((P->execname = strdup(buf)) == NULL)
-dprintf(""failed to malloc; executable name is \""%s\"""", buf);
+_dprintf(""failed to malloc; executable name is \""%s\"""", buf);
 
 return (P->execname);
 }
",146,54
"Fix incorrect datatypes in the task structure, and add initializer values to
surpress warnings."," struct task_struct {
 #endif
 #ifdef CONFIG_DTRACE
 uint32_t predcache;
-cycle_t dtrace_vtime;
-cycle_t dtrace_start;
-cycle_t dtrace_stop;
-cycle_t dtrace_sig;
+ktime_t dtrace_vtime;
+ktime_t dtrace_start;
+uint8_t dtrace_stop;
+uint8_t dtrace_sig;
 
 void *dtrace_helpers;
 #endif
",1236,133
Latest changes to implement arch and OS specific functions for the DTrace core.," void dtrace_anon_property(void)
 charc[32]; /* enough for ""dof-data-"" + digits */
 
 ASSERT(mutex_is_locked(&dtrace_lock));
-/* FIXME: ASSERT(mutex_is_locked(&cpu_lock)); */
+ASSERT(mutex_is_locked(&cpu_lock));
 
 for (i = 0; ; i++) {
 snprintf(c, sizeof (c), ""dof-data-%d"", i);
",70,12
"* libdtrace/dt_impl.h (dt_module_t): Remove memeber dm_modid since
 there is no module id at Linux.
 * libdtrace/dtrace.h (dtrace_objinfo_t): Remove memeber dto_id.
 * libdtrace/dt_module.c, libdtrace/dt_open.c: Remove the reference to
 dm_modid and dto_id.
 * libdtrace/*, common/ctf/*, libproc/common/*: Remove inclusion header
 file sysmacros.h.
 * runtest.sh: Update.","
 
 #pragma ident""%Z%%M%%I%%E% SMI""
 
-#include <sys/sysmacros.h>
 #include <sys/param.h>
 #include <sys/mman.h>
 #include <gelf.h>
",945,236
"mplementation of arch/OS specific functions to handle stacktrace from both
kernel and user perspective. Also functions to determine stack depth. This
Concludes the implementation of the DTrace core up to the point of compiling
and linking. There is *NO* implication that the code works correctly, and
in fact I would expect it to crash the OS when the module is loaded. At this
point debugging and testing will commence.

One outstanding issue is that there is code yet to run through the list of
loaded modules to query them for probe points. This depends on completion of
the static probe point generation code. Initial debugging of the core does
not depend on this."," dtrace_actdesc_t *dtrace_actdesc_create(dtrace_actkind_t kind, uint32_t ntuple,
 {
 dtrace_actdesc_t*act;
 
+#ifdef FIXME
 ASSERT(!DTRACEACT_ISPRINTFLIKE(kind) ||
  (arg != 0 && (uintptr_t)arg >= KERNELBASE) ||
  (arg == 0 && kind == DTRACEACT_PRINTA));
+#else
+ASSERT(!DTRACEACT_ISPRINTFLIKE(kind) ||
+ (arg != 0) ||
+ (arg == 0 && kind == DTRACEACT_PRINTA));
+#endif
 
 act = kzalloc(sizeof (dtrace_actdesc_t), GFP_KERNEL);
 act->dtad_kind = kind;
 void dtrace_actdesc_release(dtrace_actdesc_t *act, dtrace_vstate_t *vstate)
 if (DTRACEACT_ISPRINTFLIKE(kind)) {
 char*str = (char *)(uintptr_t)act->dtad_arg;
 
+#ifdef FIXME
 ASSERT((str != NULL && (uintptr_t)str >= KERNELBASE) ||
  (str == NULL && act->dtad_kind == DTRACEACT_PRINTA));
+#else
+ASSERT((str != NULL) ||
+ (str == NULL && act->dtad_kind == DTRACEACT_PRINTA));
+#endif
 
 if (str != NULL)
 kfree(str);
",45,21
"* cmd/common/dtrace.c: Uncomment function dtrace_handle_proc.
 * include/types_various.h: Remove SIGCANCEL and SYS_forksys.
 * libdtrace/dt_proc.c (dt_proc_control): Trace SYS_fork instead of
 SYS_forksys. Use SIGUSR1 instead of SIGCANCEL. Use pthread_kill
 instead of _lwp_kill.
 (dt_proc_creat): Pass DT_PROC_STOP_IDLE to dt_proc_create_thread.
 * libport/time.c: Remove _lwp_kill.
 * runtest.sh: Update"," compile_str(dtrace_cmd_t *dcp)
 dcp->dc_name = dcp->dc_arg;
 }
 
-#if 0
 /*ARGSUSED*/
 static void
 prochandler(struct ps_prochandle *P, const char *msg, void *arg)
 prochandler(struct ps_prochandle *P, const char *msg, void *arg)
 break;
 }
 }
-#endif
 
 /*ARGSUSED*/
 static int
 main(int argc, char *argv[])
 if (dtrace_handle_drop(g_dtp, &drophandler, NULL) == -1)
 dfatal(""failed to establish drop handler"");
 
-/*if (dtrace_handle_proc(g_dtp, &prochandler, NULL) == -1)
-dfatal(""failed to establish proc handler"");*/
+if (dtrace_handle_proc(g_dtp, &prochandler, NULL) == -1)
+dfatal(""failed to establish proc handler"");
 
 if (dtrace_handle_setopt(g_dtp, &setopthandler, NULL) == -1)
 dfatal(""failed to establish setopt handler"");
",1294,322
"Changes to avoid needing GPL-only exported symbols. Note that this is largely
done by using wrappers that are exported without requiring GPL-only. Also
note that the handling of modules is (for now) disabled due to the fact that
we cannot depend on GPL-only symbols, and because the mechanism for recording
static trace points in modules is not 100% implemented yet.

Removed the nused dtrace_asm.s file (the one that is relevant is dtrace_asm.S)."," static long dtrace_ioctl(struct file *file,
 return -EINVAL;
 
 mutex_lock(&dtrace_provider_lock);
-mutex_lock(&module_mutex);
+//mutex_lock(&module_mutex); /* FIXME */
 mutex_lock(&dtrace_lock);
 
 probe = dtrace_probe_lookup_id(desc.dtargd_id);
 if (probe == NULL) {
 mutex_unlock(&dtrace_lock);
-mutex_unlock(&module_mutex);
+//mutex_unlock(&module_mutex); /* FIXME */
 mutex_unlock(&dtrace_provider_lock);
 
 return -EINVAL;
 static long dtrace_ioctl(struct file *file,
 probe->dtpr_arg, &desc);
 }
 
-mutex_unlock(&module_mutex);
+//mutex_unlock(&module_mutex); /* FIXME */
 mutex_unlock(&dtrace_provider_lock);
 
 if (copy_to_user(argp, &desc, sizeof(desc)) != 0)
 static long dtrace_ioctl(struct file *file,
  */
 state->dts_laststatus = ns_to_ktime(INT64_MAX);
 dtrace_membar_producer();
-state->dts_laststatus = ktime_get();
+state->dts_laststatus = ktime_get_nongpl();
 
 memset(&stat, 0, sizeof(stat));
 
",733,129
"Remove pr_*.c files from libpro/common/.
 * libproc/common/makefile: Remove the pr_*.o from libproc.
 * libproc/common/libproc.h: Remove the declarations for the functions
 definied at pr_*.c files.
 * libdtrace/dt_pid.c: Don't use pr_open and pr_close.
 * libproc/common/Psyscall.c: Don't use pr_lwp_exit.
 * include/types_various.h: Clean the definitions.

 * libdtrace/makefile: Fix."," dt_pid_usdt_mapping(void *data, const prmap_t *pmp, const char *oname)
 
 dt_pid_objname(dh.dofhp_mod, sizeof (dh.dofhp_mod),
  sip.prs_lmid, mname);
-
+#if 0
 if (fd == -1 &&
  (fd = pr_open(P, ""/dev/dtrace/helper"", O_RDWR, 0)) < 0) {
 dt_dprintf(""pr_open of helper device failed: %s\n"",
 dt_pid_usdt_mapping(void *data, const prmap_t *pmp, const char *oname)
 
 if (pr_ioctl(P, fd, DTRACEHIOC_ADDDOF, &dh, sizeof (dh)) < 0)
 dt_dprintf(""DOF was rejected for %s\n"", dh.dofhp_mod);
+#endif
 }
-
+#if 0
 if (fd != -1)
 (void) pr_close(P, fd);
+#endif
 
 return (0);
 }
",525,122
Clean the header files.,"
 #include <sys/stat.h>
 #include <sys/wait.h>
 
-#include <types_various.h>
 
 #include <dtrace.h>
 #include <stdlib.h>
",1293,322
"* include/sys/link.h: Include system link.h and remove the conflict
 definitions.
 * librtld/rd_elf.c, rtld.h: Fixed."," _rd_reset32(struct rd_agent *rap)
 */
 typedef ps_err_e (*ps_pbrandname_fp_t)(struct ps_prochandle *,
 char *, size_t);
-
+#if 0
 rd_err_e
 validate_rdebug32(struct rd_agent *rap)
 {
 validate_rdebug32(struct rd_agent *rap)
  rap->rd_flags & RDF_FL_COREFILE));
 return (RD_OK);
 }
+#endif
 #if 0
 rd_err_e
 find_dynamic_ent32(struct rd_agent *rap, psaddr_t dynaddr,
",583,117
"* cmd/dtrace.c: clear function prochandler.
 * include/sys/regset.h: Don't include privregs.h.
 * libdtrace/dt_proc.c: Remove to get infor from Ppsinfo.
 libproc/common
 * P32ton.c: Remove the functions about lwp.
 * Pcontrol.c: Remove the functions about lwp-specific operation.
 * Pservice.c: Likewise.
 * Pstack.c: Likewise.
 * Plwpregs.c: Delete.
 * proc_arg.c: Delete.
 * proc_get_info.c: Delete.
 * proc_names.c: Delete.
 * proc_set.c: Delete.
 * proc_stdio.c: Delete.
 * libproc.h: Delete.
 * makefile: Fixed."," compile_str(dtrace_cmd_t *dcp)
 static void
 prochandler(struct ps_prochandle *P, const char *msg, void *arg)
 {
+/* FIXME */
+#if 0
 const psinfo_t *prp = Ppsinfo(P);
 int pid = Pstatus(P)->pr_pid;
 char name[SIG2STR_MAX];
 prochandler(struct ps_prochandle *P, const char *msg, void *arg)
 g_pslive--;
 break;
 }
+#endif
 }
 
 /*ARGSUSED*/
",1293,323
"Remove librtld.
 * makefile: Adjust.
 * libdtrace/dt_open.c, dt_proc.c: Fix.
 * libproc/common/Psymtab.c, Psymtab_machelf32.c: Fix."," int _dtrace_argmax = 32;/* default maximum number of probe arguments */
 
 int _dtrace_debug = 0;/* debug messages enabled (off) */
 const char *const _dtrace_version = DT_VERS_STRING; /* API version string */
+#if defined(sun)
 int _dtrace_rdvers = RD_VERSION; /* rtld_db feature version */
+#endif
 
 typedef struct dt_fdlist {
 int *df_fds;/* array of provider driver file descriptors */
 void
 _dtrace_init(void)
 {
 _dtrace_debug = getenv(""DTRACE_DEBUG"") != NULL;
-
+#if 0
 for (; _dtrace_rdvers > 0; _dtrace_rdvers--) {
 if (rd_init(_dtrace_rdvers) == RD_OK)
 break;
 }
+#endif
 }
 
 static dtrace_hdl_t *
",979,129
"* cmd/dtrace.c: Don't include libproc.h.
 * makefile: Fix.
 * libdtrace/dt_proc.c: Rmove dt_proc_bpmatch.
 * libproc/common/Pcore.c: Remove note_lwpstatus, note_lwpsinfo and
 lwpid2info.
 * libproc/common/Pcontrol.c: Remove the part about agentcnt.
 * libproc/common/Pidle.c, Pscantext.c, Psyscall.c: Removed.
 * libproc/common/makefile: Fix.
 * uts/common/sys/ccompile.h, time_std_impl.h: Removed.","
 #include <signal.h>
 #include <alloca.h>
 #include <libgen.h>
-#include <libproc.h>
 
 typedef struct dtrace_cmd {
 void (*dc_func)(struct dtrace_cmd *);/* function to compile arg */
",1292,323
"Adding exploded kernel source code for UEK kernel (2.6.32 based), including the
dtrace patch work.","
+/*
+ * FILE:cyclic.c
+ * DESCRIPTION:Cyclic implementation
+ *
+ * Copyright (C) 2010 Oracle Corporation
+ */
+
+#include ""cyclic.h""
+
+/*
+ * Add a new cyclic to the system.
+ */
+cyclic_id_t cyclic_add(cyc_handler_t *hdlr, cyc_time_t *when)
+{
+return 0;
+}
+
+/*
+ * Remove the specific cyclic from the system.
+ */
+void cyclic_remove(cyclic_id_t id)
+{
+}
",8,2
"* libproc/common/Pcore.c, Pexecname.c, Pisadep.h, Pservice.c,
 Pstack.c, Pstack.h: Removed.
 * libproc/common/makefile: Remove Pcore.o, Pexecname.o, Pservice and
 Pstack.o.
 * libproc/common/Pzone.c (Pfindmap): Don't handle a.out segment.
 * libproc/common/Pcontrol.c (Psetrun): Pass the sig argument to ptrace.
 * libproc/amd64/Pisadep.c: Remove the functions that would never be
 called."," Pfindmap(struct ps_prochandle *P, map_info_t *mptr, char *s, size_t n)
 (void) strlcpy(s, fptr->file_rname, n);
 return (s);
 }
-
+#if defined (sun)
 /* If it's the a.out segment, defer to the magical Pexecname() */
 if ((P->map_exec == mptr) ||
  (strcmp(mptr->map_pmap.pr_mapname, ""a.out"") == 0) ||
 Pfindmap(struct ps_prochandle *P, map_info_t *mptr, char *s, size_t n)
 (void) strlcpy(s, buf, n);
 return (s);
 }
+#endif
 
 /* Try /proc first to get the real object name */
 if ((Pstate(P) != PS_DEAD) && (mptr->map_pmap.pr_mapname[0] != '\0')) {
",310,73
"2011-05-09 Nick Alcock <nick.alcock@oracle.com>

	* libproc/common/Psymtab.c (Penv_iter): Remove bogus check on length of
	argument lists: recent Linux kernels have no limit, and programs should
	never assume a limit.
	* libdtrace/procfs.sed.in: Remove nonexistent headers."," again:
 nameval = NULL;
 } else if (ret == buflen - 1) {
 free(buf);
-/*
- * Bail if we have a corrupted environment
- */
-if (buflen >= ARG_MAX)
-return (-1);
 buflen *= 2;
 buf = malloc(buflen);
 goto again;
",2203,653
"* libproc/common/P32ton.c, P32ton.h: Remove.
 * libproc/common/Pcontrol.c: Clean headers.
 * libproc/common/makefile: Remove P32ton.o from libproc.","
 #include ""Pcontrol.h""
 #include ""libproc.h""
 #include ""Putil.h""
-#include ""P32ton.h""
-
 
 int_libproc_debug;/* set non-zero to enable debugging printfs */
 int_libproc_no_qsort;/* set non-zero to inhibit sorting */
",1250,299
"2011-05-12 Nick Alcock <nick.alcock@oracle.com>

	Purge zlib indirection machinery.

	* libctf/ctf_lib.c (_libctf_zlib): Remove.
	(struct zlib): Likewise.
	(_libctf_init): Drop its initialization, and LIBCTF_DECOMPRESSOR.
	Make static.
	(ctf_zopen): Remove.
	(z_uncompress): Likewise.
	(z_strerror): Likewise.

	* common/ctf/ctf_impl.h: Remove from header.
	(ECTF_ZMISSING): Remove.
	(ECTF_ZINIT): Likewise.

	* common/ctf/ctf_open.c: Include zlib.h.
	* common/ctf/ctf_open.c (ctf_bufopen): Call the zlib functions
	directly.","
 #include <gelf.h>
 #include <ctf_impl.h>
 #include <sys/mman.h>
-
+#include <zlib.h>
 
 static const ctf_dmodel_t _libctf_models[] = {
 { ""ILP32"", CTF_MODEL_ILP32, 4, 1, 2, 4, 4 },
 ctf_bufopen(const ctf_sect_t *ctfsect, const ctf_sect_t *symsect,
 const void *src;
 int rc = Z_OK;
 
-if (ctf_zopen(errp) == NULL)
-return (NULL); /* errp is set for us */
-
 if ((base = ctf_data_alloc(size + hdrsz)) == MAP_FAILED)
 return (ctf_set_open_errno(errp, ECTF_ZALLOC));
 
 ctf_bufopen(const ctf_sect_t *ctfsect, const ctf_sect_t *symsect,
 srclen = ctfsect->cts_size - hdrsz;
 dstlen = size;
 
-if ((rc = z_uncompress(buf, &dstlen, src, srclen)) != Z_OK) {
-ctf_dprintf(""zlib inflate err: %s\n"", z_strerror(rc));
+if ((rc = uncompress(buf, &dstlen, src, srclen)) != Z_OK) {
+ctf_dprintf(""zlib inflate err: %s\n"", zError(rc));
 ctf_data_free(base, size + hdrsz);
 return (ctf_set_open_errno(errp, ECTF_DECOMPRESS));
 }
",640,190
"2011-05-13 Shujing Zhao <pearly.zhao@oracle.com>

	* libproc/common/Psymtab.c (Pbuild_file_symtab): Replace
	/proc//object/a.out with /proc//exe.
	* libproc/common/Pzone.c (Pfindmap): Replace /proc//path/a.out with
	/proc//exe.
 	(Pbrandname): Remove.
	* libproc/common/makefile: Remove Pcore.o."," Pbuild_file_symtab(struct ps_prochandle *P, file_info_t *fptr)
 name = fptr->file_pname;
 (void) strlcpy(objectfile, name, sizeof (objectfile));
 } else {
+#if defined (sun)
 (void) snprintf(objectfile, sizeof (objectfile),
  ""%s/%d/object/%s"",
  procfs_path, (int)P->pid, fptr->file_pname);
+#else
+(void) snprintf(objectfile, sizeof (objectfile),
+ ""%s/%d/exe"", procfs_path, (int)P->pid);
+#endif
 }
 
 /*
",2205,654
"Warning fixes and a CTF bugfix.

* libctf/ctf_lib.c: Include missing header.
* libctf/ctf_subr.c: Likewise.
* common/ctf/ctf_types.c: Likewise.
* common/ctf/ctf_labels.c: Likewise.

* common/ctf/ctf_labels.c (ctf_label_topmost): Convince GCC that
these variables are initialized when used.
* common/ctf/ctf_labels.c (ctf_label_iter): Likewise.

* common/ctf/ctf_create.c (ctf_discard): Do not assign to
uninitialized variables or infloop when skipping committed types."," ctf_discard(ctf_file_t *fp)
 return (0); /* no update required */
 
 for (dtd = ctf_list_next(&fp->ctf_dtdefs); dtd != NULL; dtd = ntd) {
+ntd = ctf_list_next(dtd);
+
 if (dtd->dtd_type <= fp->ctf_dtoldid)
 continue; /* skip types that have been committed */
 
-ntd = ctf_list_next(dtd);
 ctf_dtd_delete(fp, dtd);
 }
 
",944,236
"2011-05-18 Shujing Zhao <pearly.zhao@oracle.com>

 * libdtrace/dt_proc.c: Remove dt_proc_bpcreate from Linux.
 (dt_proc_bpenable): It can set bkpt by Psetbkpt. Remove it.
 * libproc/common/Pcontrol.c (restore_tracing_flags): Remove the part
 of writing ctl file.
 (Pclearsig): Remove.
 (Pclearfault): Remove.
 (Psetbkpt): Remove.
 (execute_bkpt): Remove.
 (Pxecbkpt): Remove.
 (Psetwapt): Remove.
 (Pdelwapt): Remove.
 (execute_wapt): Remove.
 (Pxecwapt): Remove.
 (Psignal): Remove.
 (Padd_mapping): Remove.
 (map_sort): Remove.
 (Psort_mappings): Remove.
 * libproc/common/libproc.h: Clear declarations.
 * libproc/common/Pcontrol.h: Clear.","
 #include <dt_pid.h>
 #include <dt_impl.h>
 
+#if defined(sun)
 static dt_bkpt_t *
 dt_proc_bpcreate(dt_proc_t *dpr, uintptr_t addr, dt_bkpt_f *func, void *data)
 {
 dt_proc_bpcreate(dt_proc_t *dpr, uintptr_t addr, dt_bkpt_f *func, void *data)
 
 return (dbp);
 }
+#endif
 
 static void
 dt_proc_bpdestroy(dt_proc_t *dpr, int delbkpts)
 dt_proc_bpenable(dt_proc_t *dpr)
 
 for (dbp = dt_list_next(&dpr->dpr_bps);
  dbp != NULL; dbp = dt_list_next(dbp)) {
+#if defined(sun)
 if (!dbp->dbp_active && Psetbkpt(dpr->dpr_proc,
  dbp->dbp_addr, &dbp->dbp_instr) == 0)
 dbp->dbp_active = B_TRUE;
+#endif
 }
 
 dt_dprintf(""breakpoints enabled\n"");
",623,140
Remove needless support for the back-compatibility device.,"
 */
 
 static const char *devname = ""/dev/dtrace/helper"";
-static const char *olddevname = ""/devices/pseudo/dtrace@0:helper"";
 
 static const char *modname;/* Name of this load object */
 static int gen;/* DOF helper generation */
 dtrace_dof_init(void)
 
 if ((fd = open64(devname, O_RDWR)) < 0) {
 dprintf(1, ""failed to open helper device %s"", devname);
-
-/*
- * If the device path wasn't explicitly set, try again with
- * the old device path.
- */
-if (p != NULL)
-return;
-
-devname = olddevname;
-
-if ((fd = open64(devname, O_RDWR)) < 0) {
-dprintf(1, ""failed to open helper device %s"", devname);
-return;
-}
+return;
 }
 
 if ((gen = ioctl(fd, DTRACEHIOC_ADDDOF, &dh)) == -1)
",89,21
"Make -G option work.

This involves pushing drti.o out of the library into a new file under
/usr/lib/dtrace, and adding a symbol version file in there which declares all
symbols to be local: then link against that using --symbol-version.

This also rips out the 32/64-bit-specific library locations (if we ever support
32/64-bit dual-mode operation, we should adjust _dtrace_libdir on the fly
instead).

Note: if testing -G without installing, you currently must add
DTRACE_LIBDIR=$(pwd)/build-$(uname -r) to your make line, and copy drti-vers
into that directory."," const dtrace_pattr_t _dtrace_prvdesc = {
 { DTRACE_STABILITY_UNSTABLE, DTRACE_STABILITY_UNSTABLE, DTRACE_CLASS_COMMON },
 { DTRACE_STABILITY_UNSTABLE, DTRACE_STABILITY_UNSTABLE, DTRACE_CLASS_COMMON },
 };
-#if 0
-const char *_dtrace_defcpp = ""/usr/ccs/lib/cpp""; /* default cpp(1) to invoke */
-const char *_dtrace_defld = ""/usr/ccs/bin/ld""; /* default ld(1) to invoke */
-#endif
+
 const char *_dtrace_defcpp = ""/usr/bin/cpp""; /* default cpp(1) to invoke */
 const char *_dtrace_defld = ""/usr/bin/ld""; /* default ld(1) to invoke */
 
-const char *_dtrace_libdir = ""/usr/lib/dtrace""; /* default library directory */
+const char *_dtrace_libdir = DTRACE_LIBDIR; /* default library directory */
 const char *_dtrace_provdir = ""/dev/dtrace/provider""; /* provider directory */
 
 int _dtrace_strbuckets = 211;/* default number of hash buckets (prime) */
",966,125
"Turn runtest.sh into a crude regression tester.

If you have multiple build-* directories in place, runtest will now run all
tests against each of them, and print any differences in output or in
intermediate representation (picking a random one to compare against).
(This is unashamedly GNU diff-dependent.)

Differences in pointer addresses or anything else looking hexadecimal
are filtered out.

Also made slightly more bash-idiomatic.

Finally, add a .gitignore which filters out some (but not yet all) of the build
debris."," dt_dis(const dtrace_difo_t *dp, FILE *fp)
 ulong_t i = 0;
 char type[DT_TYPE_NAMELEN];
 
-(void) fprintf(fp, ""\nDIFO 0x%p returns %s\n"", (void *)dp,
+(void) fprintf(fp, ""\nDIFO %p returns %s\n"", (void *)dp,
  dt_dis_typestr(&dp->dtdo_rtype, type, sizeof (type)));
 
 (void) fprintf(fp, ""%-3s %-8s %s\n"",
",410,70
"Use -D_GNU_SOURCE option to provide the standard GNU system interface.

Many GNU system interface macros have been used when compiling, such
as _LARGEFILE64_SOURCE, _FILE_OFFSET_BITS=64. On the other hand, the
_XOPEN_SOURCE is needed by pread/pwrite. Using -D_GNU_SOURCE includes
all the above macros and reduces the CPPFLAGS.

Clean the conflicting definitions with the standard GNU system interface.

Rewrite the regs.sed.in and regs.d.in according to glibc register
definitions. Fix the runtest.sh since the case statement can't be
run by bash 3.0x or below.","
 
 #include <dt_string.h>
 
-/*
- * Create a copy of string s, but only duplicate the first n bytes.
- */
-char *
-strndup(const char *s, size_t n)
-{
-char *s2 = malloc(n + 1);
-
-(void) strncpy(s2, s, n);
-s2[n] = '\0';
-return (s2);
-}
-
 /*
 * Transform string s inline, converting each embedded C escape sequence string
 * to the corresponding character. For example, the substring ""\n"" is replaced
",222,84
"Remove unused Psetflags(), overlooked in last commit."," Pdelbkpt(struct ps_prochandle *P, uintptr_t address, ulong_t saved)
 return (0);
 }
 
-int
-Psetflags(struct ps_prochandle *P, long flags)
-{
-int rc;
-/* Only change P->status but not write to file at Linux. */
-/*long ctl[2];
-
-ctl[0] = PCSET;
-ctl[1] = flags;
-
-if (write(P->ctlfd, ctl, 2*sizeof (long)) != 2*sizeof (long)) {
-rc = -1;
-} else { */
-P->status.pr_flags |= flags;
-rc = 0;
-/*} */
-
-return (rc);
-}
-
 core_content_t
 Pcontent(struct ps_prochandle *P)
 {
",655,164
"Drop some Solaris-specific coredump stuff.

Much work remains to be done on coredumps, but this at least lets us drop some
very Solaris-specific aspects that were interfering with other work.","
 
 #include <sys/ptrace.h>
 #include <sys/types.h>
-#include <sys/uio.h>
 #include <sys/resource.h>
 #include <sys/param.h>
 #include <sys/stat.h>
 #include <sys/fault.h>
 #include <sys/wait.h>
 
-#include <sys/priv.h>
-#include <sys/corectl.h>
 #include <mutex.h>
 
 #include ""Pcontrol.h""
 Pfree(struct ps_prochandle *P)
 uint_t i;
 
 if (P->core != NULL) {
-extern void __priv_free_info(void *);
 lwp_info_t *nlwp, *lwp = list_next(&P->core->core_lwp_head);
 
 for (i = 0; i < P->core->core_nlwp; i++, lwp = nlwp) {
 Pfree(struct ps_prochandle *P)
 free(P->core->core_uts);
 if (P->core->core_cred != NULL)
 free(P->core->core_cred);
-if (P->core->core_priv != NULL)
-free(P->core->core_priv);
-/* NEED FIX */ 
-/*if (P->core->core_privinfo != NULL)
-__priv_free_info(P->core->core_privinfo); */
-if (P->core->core_ppii != NULL)
-free(P->core->core_ppii);
 #if defined(__i386) || defined(__amd64)
 if (P->core->core_ldt != NULL)
 free(P->core->core_ldt);
",647,162
"Rewrite Pwait() to use waitid(), rather than Solaris procfs.

This does *not* handle ptrace() traps on the grounds that ptrace() is about to
get torn out."," dt_proc_control(void *arg)
 break;
 
 case PS_UNDEAD:
+case PS_DEAD:
 dt_dprintf(""pid %d: proc died\n"", pid);
 dpr->dpr_quit = B_TRUE;
 notify = B_TRUE;
 break;
 }
 
-if (Pstate(P) != PS_UNDEAD && Psetrun(P, 0, 0) == -1) {
-dt_dprintf(""pid %d: failed to set running: %s\n"",
- (int)dpr->dpr_pid, strerror(errno));
-}
-
 (void) pthread_mutex_unlock(&dpr->dpr_lock);
 }
 
 /*
- * If the control thread detected PS_UNDEAD or PS_LOST, then enqueue
- * the dt_proc_t structure on the dt_proc_hash_t notification list.
+ * If the control thread detected PS_UNDEAD or PS_DEAD, then enqueue the
+ * dt_proc_t structure on the dt_proc_hash_t notification list.
  */
 if (notify)
 dt_proc_notify(dtp, dph, dpr, NULL);
",527,119
"Delete breakpoint handling.

We don't need to drop breakpoints anywhere anymore: we can get away with static
tracepoints in glibc. So remove the libproc-dependent support code for this."," Pwrite(struct ps_prochandle *P,
 return (P->ops->p_pwrite(P, buf, nbyte, address));
 }
 
-/*
- * Restore original instruction where a breakpoint was set.
- */
-int
-Pdelbkpt(struct ps_prochandle *P, uintptr_t address, ulong_t saved)
-{
-instr_t old = (instr_t)saved;
-instr_t cur;
-
-if (P->state == PS_DEAD) {
-errno = ENOENT;
-return (-1);
-}
-
-/*
- * If the breakpoint instruction we had placed has been overwritten
- * with a new instruction, then don't try to replace it with the
- * old instruction. Doing do can cause problems with self-modifying
- * code -- PLTs for example. If the Pread() fails, we assume that we
- * should proceed though most likely the Pwrite() will also fail.
- */
-if (Pread(P, &cur, sizeof (cur), address) == sizeof (cur) &&
- cur != BPT)
-return (0);
-
-if (Pwrite(P, &old, sizeof (old), address) != sizeof (old))
-return (-1);
-
-return (0);
-}
-
 core_content_t
 Pcontent(struct ps_prochandle *P)
 {
",535,117
"Yet another round of code removal, from Psymtab.c and Pcontrol.h this time.

The focus here is to make audits easier by removing unused functions with names
similar to those that may be called with the process grabbed. These are almost
all in Psymtab.c. Also, we discard a bunch of ps_prochandle_t structure members
which are never used, which lets us ditch the code that maintains them."," Pxcreate(
  * Initialize the process structure.
  */
 (void) memset(P, 0, sizeof (*P));
-(void) mutex_init(&P->proc_lock, USYNC_THREAD, NULL);
-P->flags |= CREATED;
 P->state = PS_RUN;
 P->pid = pid;
 P->memfd = -1;
 Pfree(struct ps_prochandle *P)
 free(P->core);
 }
 
-if (P->ucaddrs != NULL) {
-free(P->ucaddrs);
-P->ucaddrs = NULL;
-P->ucnelems = 0;
-}
-
-(void) mutex_lock(&P->proc_lock);
-(void) mutex_unlock(&P->proc_lock);
-(void) mutex_destroy(&P->proc_lock);
-
 if (P->memfd >= 0)
 (void) close(P->memfd);
 Preset_maps(P);
 Psetrun(struct ps_prochandle *P,
 int flags)/* PRSTEP|PRSABORT|PRSTOP|PRCSIG|PRCFAULT */
 {
 P->info_valid = 0;/* will need to update map and file info */
-/*
- * If we've cached ucontext-list information while we were stopped,
- * free it now.
- */
-if (P->ucaddrs != NULL) {
-free(P->ucaddrs);
-P->ucaddrs = NULL;
-P->ucnelems = 0;
-}
 
 if (ptrace (PTRACE_CONT, P->pid, NULL, sig) != 0) {
 _dprintf(""Psetrun: %s\n"", strerror(errno));
",431,92
"Remove the structures corresponding to Solaris proc files.

These are all either unnecessary on Linux, or incorrect."," dt_pid_per_sym(dt_pid_probe_t *pp, const GElf_Sym *symp, const char *func)
 int isdash = strcmp(""-"", func) == 0;
 pid_t pid;
 
-pid = Pstatus(pp->dpp_pr)->pr_pid;
+pid = ps_getpid(pp->dpp_pr);
 
 dt_dprintf(""creating probe pid%d:%s:%s:%s\n"", (int)pid, pp->dpp_obj,
  func, pp->dpp_name);
 dt_pid_per_mod(void *arg, const prmap_t *pmp, const char *obj)
  GELF_ST_INFO(STB_LOCAL, STT_FUNC);
 sym.st_other = 0;
 sym.st_value = 0;
+#ifdef USERSPACE_TRACEPOINTS
 sym.st_size = Pstatus(pp->dpp_pr)->pr_dmodel ==
  PR_MODEL_ILP32 ? -1U : -1ULL;
-
+#else
+sym.st_size = ~((Elf64_Xword) 0);
+#endif
 } else if (!strisglob(pp->dpp_mod)) {
 return (dt_pid_error(dtp, pcb, dpr, NULL,
  D_PROC_FUNC,
 dt_pid_create_usdt_probes(dtrace_probedesc_t *pdp, dtrace_hdl_t *dtp,
 ret = -1;
 (void) dt_pid_error(dtp, pcb, dpr, NULL, D_PROC_USDT,
  ""failed to instantiate probes for pid %d: %s"",
- (int)Pstatus(P)->pr_pid, strerror(errno));
+ (int)ps_getpid(P), strerror(errno));
 }
 
 /*
",526,123
"* libdtrace/dt_aggregate.c: Replace use of _SC_NPROCESSORS_MAX and
 _SC_CPUID_MAX with nr_cpu_ids (much lower limit). Get it from
 dt_conf.dtc_maxbufs.
 * uts/common/sys/dtrace.h: Add dtc_maxbufs field to dtrace_conf_t."," dt_aggregate_go(dtrace_hdl_t *dtp)
 assert(agp->dtat_ncpu == 0);
 assert(agp->dtat_cpus == NULL);
 
-agp->dtat_maxcpu = dt_sysconf(dtp, _SC_CPUID_MAX) + 1;
-agp->dtat_ncpu = dt_sysconf(dtp, _SC_NPROCESSORS_MAX);
+agp->dtat_maxcpu = dtp->dt_conf.dtc_maxbufs;
+agp->dtat_ncpu = dtp->dt_conf.dtc_maxbufs;
 agp->dtat_cpus = malloc(agp->dtat_ncpu * sizeof (processorid_t));
 
 if (agp->dtat_cpus == NULL)
",1202,288
"CFLAGS fixes, and things arising from them.

CFLAGS contained things like -D_GNU_SOURCE which affected the semantics of the
program, so when I overrode it for debugging the program changed, and I
unwittingly reintroduced an identifier exposed by -D_GNU_SOURCE while trying to
make the program compile. Migrating these options into CC fixes that.

Also dropped all the *64() file I/O functions: they were only ever transitional,
and the expected thing to do in newer code is to define -D_FILE_OFFSET_BITS=64
and just use open() et al as before. (This has no effect on 64-bit platforms
anyway.)"," main(int argc, char *argv[])
 GElf_Ehdr ehdr;
 
 for (i = 1; i < g_argc; i++) {
-if ((fd = open64(g_argv[i], O_RDONLY)) == -1)
+if ((fd = open(g_argv[i], O_RDONLY)) == -1)
 break;
 
 if ((elf = elf_begin(fd, ELF_C_READ, NULL)) == NULL) {
",1299,323
"Improve intermediate format printing.

-S output had numerous problems, all now fixed:

- The output was being generated in the wrong place, so those actions which
 didn't use dt_as() for intermediate code generation had their intermediate
 code skipped.

- The output printed *only* the intermediate code: things like printf() format
 strings, the name of the action, and the name of the probe it came from were
 simply skipped. This made it very hard to tell which piece of intermediate
 code was which."," dt_as(dt_pcb_t *pcb)
 pcb->pcb_difo = NULL;
 pcb->pcb_dret = NULL;
 
-if (pcb->pcb_cflags & DTRACE_C_DIFV)
-dt_dis(dp, stderr);
-
 return (dp);
 }
",329,77
Do not dump intermediate state when compilation has failed.," dtrace_program_strcompile(dtrace_hdl_t *dtp, const char *s,
 {
 dtrace_prog_t *rv;
 
-rv = dt_compile(dtp, DT_CTX_DPROG,
- spec, NULL, cflags, argc, argv, NULL, s);
-
-if (cflags & DTRACE_C_DIFV)
-dt_dis_program(dtp, rv, stderr);
+if ((rv = dt_compile(dtp, DT_CTX_DPROG,
+ spec, NULL, cflags, argc, argv, NULL, s)) != NULL) {
+if (cflags & DTRACE_C_DIFV)
+dt_dis_program(dtp, rv, stderr);
+}
 return (rv);
 }
 
 dtrace_program_fcompile(dtrace_hdl_t *dtp, FILE *fp,
 {
 dtrace_prog_t *rv;
 
-rv = dt_compile(dtp, DT_CTX_DPROG,
- DTRACE_PROBESPEC_NAME, NULL, cflags, argc, argv, fp, NULL);
-
-if (cflags & DTRACE_C_DIFV)
-dt_dis_program(dtp, rv, stderr);
+if ((rv = dt_compile(dtp, DT_CTX_DPROG,
+ DTRACE_PROBESPEC_NAME, NULL, cflags, argc, argv, fp, NULL)) != NULL) {
+if (cflags & DTRACE_C_DIFV)
+dt_dis_program(dtp, rv, stderr);
+}
 return (rv);
 }
 
",1619,384
"Fix the size problem of return type.

Add a new member to dtrace_difo_t to track the original return type.
Synchronize up the dtrace_difo_t type in the kernel too."," dt_as(dt_pcb_t *pcb)
 pcb->pcb_difo = NULL;
 pcb->pcb_dret = NULL;
 
+/* Track the orignal type. */
+dp->orig_dtdo_rtype = dp->dtdo_rtype;
+
 return (dp);
 }
",330,77
"Changed the use of _SC_CPUID_MAX to refer to dtp->dt_conf.dtc_maxbufs since
that is passed by the kernel in response to the CONFIG ioctl, and accurately
defines the number of available CPU buffers, i.e. the number of CPUs to query
buffers for."," dt_consume_begin(dtrace_hdl_t *dtp, FILE *fp, dtrace_bufdesc_t *buf,
 return (dt_set_errno(dtp, EDT_NOMEM));
 
 if (max_ncpus == 0)
-max_ncpus = dt_sysconf(dtp, _SC_CPUID_MAX) + 1;
+max_ncpus = dtp->dt_conf.dtc_maxbufs;
 
 for (i = 0; i < max_ncpus; i++) {
 nbuf.dtbd_cpu = i;
 dtrace_consume(dtrace_hdl_t *dtp, FILE *fp,
 return (dt_set_errno(dtp, EINVAL));
 
 if (max_ncpus == 0)
-max_ncpus = dt_sysconf(dtp, _SC_CPUID_MAX) + 1;
+max_ncpus = dtp->dt_conf.dtc_maxbufs;
 
 if (pf == NULL)
 pf = (dtrace_consume_probe_f *)dt_nullprobe;
",1504,401
"Hook up the dt_test trigger.

This provides a trigger to fire that probe, hooks it into the dt_test/fired.d
test, and adds expected results for a successful test.","
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/ioctl.h>
+#include <fcntl.h>
+#include <stdlib.h>
+#include <stdio.h>
+
+int main(int argc, char *argv[]) {
+ int fd, i;
+
+ if ((fd = open(""/dev/dtrace/provider/dt_test"", O_RDONLY)) == -1) {
+ perror(""open"");
+ exit(1);
+ }
+
+ for (i = 0; i < 20; i++) {
+ int arg = i;
+
+ if (ioctl(fd, 128, arg) < 0)
+ perror(""Req"");
+ }
+
+ close(fd);
+}
",19,4
"Do not loop over the actions list in statement disassembly.

Even though statements point within a list of actions, that list is *not* a list
of actions belonging to that statement: statements appear to contain at most one
action (though this is hard to prove, the code relies on it in other places),
and the list exists purely to assist statement destruction and ECB building.
So do not iterate over both the statement and action list, only the statement
list, to avoid catching actions that do not belong to the statement under
consideration."," dt_dis_stmts(dtrace_hdl_t *dtp, dtrace_prog_t *pgp, dtrace_stmtdesc_t *sdp,
 fmt = pfv->pfv_format;
 }
 
-for (; ap != NULL; ap = ap->dtad_next) {
-dt_dis_action(ap, d->fp, fmt);
-}
+dt_dis_action(ap, d->fp, fmt);
 return 0;
 }
 
",521,87
"Avoid /tmp race in test/triggers/mmap.c.

This trigger was writing to a fixed filename in /tmp: very bad, given that the
dtrace testsuite is generally run as root. Use tmpfile() instead. Reindent it
into the bargain (its indentation was non-K&R).","
 #include <stdlib.h>
 #include <stdio.h>
 
-int main(int argc, char *argv[]) {
+int main(int argc, char *argv[])
+{
 int fd, i;
 
 if ((fd = open(""/dev/dtrace/provider/dt_test"", O_RDONLY)) == -1) {
",20,4
"More preprocessor fixes.

If we specify -std=gnu89, or do not specifically undefine __GNUC__, the system
headers end up defining __attribute__s galore, which dtrace doesn't understand."," dt_preproc(dtrace_hdl_t *dtp, FILE *ifp)
 
 switch (dtp->dt_stdcmode) {
 case DT_STDC_XA:
-argv[argc++] = ""-std=gnu99"";
+argv[argc++] = ""-std=c99"";
 break;
 case DT_STDC_XS:
 argv[argc++] = ""-traditional-cpp"";
",1618,383
"Find working D libraries while testing.

This arranges to copy those D libraries that work into a subdirectory 'dlibs',
and for the -t switch passed by the testsuite to add that subdirectory to the D
compiler's system library path (so it takes precedence over /usr/lib/dtrace).

Without this, we'll either fail to find the libraries at all, or fall over when
we try to compile a library .d file that doesn't yet work."," usage(FILE *fp)
  ""\t-q set quiet mode (only output explicitly traced data)\n""
  ""\t-s enable or list probes according to the specified D script\n""
  ""\t-S print D compiler intermediate code\n""
- ""\t-t eliminate variable output, for reproducible testsuite runs\n""
+ ""\t-t various changes needed for reproducible testsuite runs\n""
  ""\t-U undefine symbol when invoking preprocessor\n""
  ""\t-v set verbose mode (report stability attributes, arguments)\n""
  ""\t-V report DTrace API version\n""
 main(int argc, char *argv[])
 
 case 't':
 g_testing = 1;
+if (dtrace_setopt(g_dtp, ""syslibdir"", ""libdtrace/dlibs"") != 0)
+dfatal(""failed to set syslibdir to libdtrace/dlibs"");
 break;
 
 case 'U':
",1321,329
"Add missing CDDL headers. Fix a broken copyright date.

I know when I wrote test/triggers/readwholedir.c and it wasn't six years ago.","
 * CDDL HEADER END
 */
 /*
- * Copyright 2005, 2011 Oracle, Inc. All rights reserved.
+ * Copyright 2011 Oracle, Inc. All rights reserved.
 * Use is subject to license terms.
 */
 
",101,17
"Clean the codes.

Remove the unused functions, declarations and definitions.","
 #include <dt_printf.h>
 #include <dt_string.h>
 #include <dt_provider.h>
-#include <rtld_db.h>
 
 /*
 * Stability and versioning definitions. These #defines are used in the tables
",964,126
"Fix linking.

Force the default to be as if -64 were specified: otherwise, dtrace tries to
guess the bitness and often gets it wrong.

Fix the ELF generation tests: -a is not reliable in older bash, -e always works."," static int g_impatient;
 static int g_newline;
 static int g_total;
 static int g_cflags;
-static int g_oflags;
+static int g_oflags = DTRACE_O_LP64;
 static int g_verbose;
 static int g_exec = 1;
 static int g_mode = DMODE_EXEC;
",1321,329
"Don't emit output on stderr from the testprobe trigger.

This output would go to stderr, messing up the printed test output."," int main(int argc, char *argv[])
 
 for (i = 0; i < 20; i++) {
 int arg = i;
-
- if (ioctl(fd, 128, arg) < 0)
- perror(""Req"");
+ ioctl(fd, 128, arg);
 }
 
 close(fd);
",19,3
"Function renaming for clarity.

The file libproc/proc.c had no stated license and contained only one one-line
function, ps_getpid(). This function's name was pointlessly different from the
convention used elsewhere in libproc (under which it should be Pgetpid()). So
this change migrates it into Pcontrol.c, changes its name, and fixes all
callers."," dt_pid_per_sym(dt_pid_probe_t *pp, const GElf_Sym *symp, const char *func)
 int isdash = strcmp(""-"", func) == 0;
 pid_t pid;
 
-pid = ps_getpid(pp->dpp_pr);
+pid = Pgetpid(pp->dpp_pr);
 
 dt_dprintf(""creating probe pid%d:%s:%s:%s\n"", (int)pid, pp->dpp_obj,
  func, pp->dpp_name);
 dt_pid_create_usdt_probes(dtrace_probedesc_t *pdp, dtrace_hdl_t *dtp,
 ret = -1;
 (void) dt_pid_error(dtp, pcb, dpr, NULL, D_PROC_USDT,
  ""failed to instantiate probes for pid %d: %s"",
- (int)ps_getpid(P), strerror(errno));
+ (int)Pgetpid(P), strerror(errno));
 }
 
 /*
",525,123
"Add missing CDDL copyright headers.

Everything in the tree which is long enough to be copyrightable and contains
original work (i.e. is not captured autogenerated results) now has a CDDL
header.","
-#ifndef _GMATCH_H
-#define _GMATCH_H
 #include <fnmatch.h>
 
 int
 gmatch(const char *s, const char *p)
 {
 return (fnmatch (s, p, 0) == 0);
 }
-
-#endif
",6,1
"Add missing copyright headers.

Also skip mib/tst.tcp.sh as not yet ported.","
 */
 
 /*
- * Copyright 2006 Sun Microsystems, Inc. All rights reserved.
+ * Copyright 2006 Oracle, Inc. All rights reserved.
 * Use is subject to license terms.
 */
 
",1321,329
"Remove include/sys/link.h.

Most of declarations of include/sys/link.h are useless. Move Link_map to
drti.c and Adjust the related files to include link.h.","
 
 #include <unistd.h>
 #include <fcntl.h>
-#include <sys/link.h>
+#include <link.h>
 #include <sys/dtrace.h>
 #include <sys/compiler.h>
 #include <sys/ioctl.h>
 static int gen;/* DOF helper generation */
 extern dof_hdr_t __SUNW_dof;/* DOF defined in the .SUNW_dof section */
 static boolean_t dof_init_debug = B_FALSE;/* From DTRACE_DOF_INIT_DEBUG */
 
+typedef struct link_map Link_map;
+
 _dt_constructor_(dtrace_dof_init)
 static void
 dtrace_dof_init(void)
",90,21
"Numerous testsuite cleanups. Document known-buggy comamnd-line options.

Make tests consistent where possible: fix expected results where provably
incorrect. Fix a few tests which could be made to pass easily.","
 #include <unistd.h>
 #include <fcntl.h>
 #include <sys/mman.h>
+#include <sys/swap.h>
 
 #define NUMINTS (1000)
 #define FILESIZE (NUMINTS * sizeof(int))
 int main(int argc, char *argv[])
 int fd;
 int *map;
 
+/* First, tell the script to start monitoring. */
+
+swapoff(""/non/existent/path"");
+
 foo = tmpfile();
 if (foo == NULL) {
 exit(1);
",37,6
"Don't emit the inter-loop blank line when testing.

Because this happens between the dtrace_work() loops, it appears after a line
which is pretty much random depending on how much work the kernel module has
done. This is less than ideal for testsuite runs, and introduces spurious
failures across the board.

Some test results rely on the appearance of this blank line: fix them up."," main(int argc, char *argv[])
 if (!g_intr && !done)
 dtrace_sleep(g_dtp);
 
-if (g_newline) {
+if ((g_newline) && (!g_testing)) {
 /*
  * Output a newline just to make the output look
  * slightly cleaner. Note that we do this even in
- * ""quiet"" mode...
+ * ""quiet"" mode... We don't do it when testing, as the
+ * newline appears at an essentially random position in
+ * the output.
  */
 oprintf(""\n"");
 g_newline = 0;
",1321,330
"Do not change the library search path when testing an installed dtrace.

Change cf0cca5 arranged to search libdtrace/libs instead of /usr/lib/dtrace for
the DTrace standard library when testing. This is normally a good idea, but
when testing an installed DTrace, this means you're testing a D library that
does not correspond to your DTrace, and (if make(1) has not been run) means
that finding a D library will fail, leading to spurious test failures.

So introduce a new argument to the -t option, which if 'installed' means to
bypass the library directory change, and use it when testing an installed
DTrace."," typedef struct dtrace_cmd {
 #defineE_USAGE2
 
 static const char DTRACE_OPTSTR[] =
-""+3:6:aAb:Bc:CD:ef:FGhHi:I:lL:m:n:o:p:P:qs:tSU:vVwx:X:Z"";
+""+3:6:aAb:Bc:CD:ef:FGhHi:I:lL:m:n:o:p:P:qs:t:SU:vVwx:X:Z"";
 
 static char **g_argv;
 static int g_argc;
 main(int argc, char *argv[])
 
 case 't':
 g_testing = 1;
-if (dtrace_setopt(g_dtp, ""syslibdir"", ""libdtrace/dlibs"") != 0)
-dfatal(""failed to set syslibdir to libdtrace/dlibs"");
+/*
+ * Adjust the library search path only if not
+ * running a check of an installed dtrace.
+ */
+if (strcmp(optarg, ""installed"") != 0) {
+if (dtrace_setopt(g_dtp, ""syslibdir"", ""libdtrace/dlibs"") != 0)
+dfatal(""failed to set syslibdir to libdtrace/dlibs"");
+}
 break;
 
 case 'U':
",1323,331
"Drop a BSD-specific define.

POSIX calls it PATH_MAX, not MAXPATHLEN, and does not guarantee its existence.
(Though all current Linux systems define it.)"," dt_lib_depend_add(dtrace_hdl_t *dtp, dt_list_t *dlp, const char *arg)
 if ((dld = dt_zalloc(dtp, sizeof (dt_lib_depend_t))) == NULL)
 return (-1);
 
-if ((dld->dtld_libpath = dt_alloc(dtp, MAXPATHLEN)) == NULL) {
+if ((dld->dtld_libpath = dt_alloc(dtp, PATH_MAX)) == NULL) {
 dt_free(dtp, dld);
 return (-1);
 }
",1618,383
"Quash spurious buffer-size-reduction messages while the testsuite is running.

We do this via a new DTrace option, 'quietresize', corresponding to
DTRACEOPT_QUIETRESIZE, automatically activated when testing, and deactivated by
those tests that validate the behaviour of DTrace with large buffers."," static void
 go(void)
 {
 int i;
+dtrace_optval_t quiet;
 
 struct {
 char *name;
 go(void)
 if (dtrace_go(g_dtp) == -1)
 dfatal(""could not enable tracing"");
 
+(void) dtrace_getopt(g_dtp, ""quietresize"", &quiet);
+
+if (quiet != DTRACEOPT_UNSET)
+return;
+
 for (i = 0; bufs[i].name != NULL; i++) {
 dtrace_optval_t j = 0, mul = 10;
 dtrace_optval_t nsize;
 main(int argc, char *argv[])
 if (dtrace_setopt(g_dtp, ""syslibdir"", optarg) != 0)
 dfatal(""failed to set syslibdir to %s"", optarg);
 }
+/*
+ * By default, quieten buffer-resize messages.
+ */
+dtrace_setopt(g_dtp, ""quietresize"", 0);
 break;
 
 case 'U':
",1328,332
"Add ctf_gzwrite().

Without this function, libctf can read in compressed CTF files, but cannot
write them out."," ctf_open(const char *filename, int *errp)
 return (fp);
 }
 
+/*
+ * Write the compressed CTF data stream to the specified gzFile descriptor.
+ * This is useful for saving the results of dynamic CTF containers.
+ */
+int
+ctf_gzwrite(ctf_file_t *fp, gzFile fd)
+{
+const uchar_t *buf = fp->ctf_base;
+ssize_t resid = fp->ctf_size;
+ssize_t len;
+
+while (resid != 0) {
+if ((len = gzwrite(fd, buf, resid)) <= 0)
+return (ctf_set_errno(fp, errno));
+resid -= len;
+buf += len;
+}
+
+return (0);
+}
+
 /*
 * Write the uncompressed CTF data stream to the specified file descriptor.
 * This is useful for saving the results of dynamic CTF containers.
",280,57
"Trivial warning fixes in triggers.

Missing headers and missing prototypes.","
 #pragma ident""%Z%%M%%I%%E% SMI""
 
 #include <stdlib.h>
-#include <spawn.h>
+#include <unistd.h>
 #include <signal.h>
 
 void
",27,4
Purge the last remaining signs of dm_modid and dto_id.," dt_module_update(dtrace_hdl_t *dtp, const char *name)
 }
 
 dmp->dm_flags |= DT_DM_KERNEL;
-/*dmp->dm_modid = (int)OBJFS_MODID(st.st_ino); */
 
 if (dmp->dm_info.objfs_info_primary)
 dmp->dm_flags |= DT_DM_PRIMARY;
 
-/*dt_dprintf(""opened %d-bit module %s (%s) [%d]\n"",
- bits, dmp->dm_name, dmp->dm_file, dmp->dm_modid); */
 dt_dprintf(""opened %d-bit module %s (%s)\n"",
  bits, dmp->dm_name, dmp->dm_file);
 }
 dt_module_info(const dt_module_t *dmp, dtrace_objinfo_t *dto)
 {
 dto->dto_name = dmp->dm_name;
 dto->dto_file = dmp->dm_file;
-/*dto->dto_id = dmp->dm_modid; */
 dto->dto_flags = 0;
 
 if (dmp->dm_flags & DT_DM_KERNEL)
",683,161
"Eliminate the concept of 'primary objects'.

This Solaris concept has no meaning in Linux. Dropping it means we lose a bunch
of complexity from dt_module.c as well as libdtrace API to track it, and even a
linkmode option.

While we're at it, drop most mentions of the kernel's runtime loader (which has
no API in the same sense in Linux) and yet more references to tasks, zones,
projects, and contracts.

Finally, update INCOMPATIBILITIES to note some of this. (Just because trying
to do anything with tasks, projects, zones, contracts, and primary objects
would never have worked before this change doesn't mean their absence is not
an incompatibility.)"," dt_as_undef(const dt_ident_t *idp, uint_t offset)
 
 if (idp->di_flags & DT_IDFLG_USER)
 kind = ""user"";
-else if (idp->di_flags & DT_IDFLG_PRIM)
-kind = ""primary kernel"";
 else
-kind = ""loadable kernel"";
+kind = ""kernel"";
 
 yylineno = idp->di_lineno;
 
 dt_as(dt_pcb_t *pcb)
  * symbol should have a relocation entry generated in the loop below.
  *
  * DT_LINK_KERNEL = kernel symbols static, user symbols dynamic
- * DT_LINK_PRIMARY = primary kernel symbols static, others dynamic
  * DT_LINK_DYNAMIC = all symbols dynamic
  * DT_LINK_STATIC = all symbols static
  *
 dt_as(dt_pcb_t *pcb)
 umask = DT_IDFLG_USER;
 ubits = DT_IDFLG_USER;
 break;
-case DT_LINK_PRIMARY:
-kmask = DT_IDFLG_USER | DT_IDFLG_PRIM;
-kbits = 0;
-umask = DT_IDFLG_USER;
-ubits = DT_IDFLG_USER;
-break;
 case DT_LINK_DYNAMIC:
 kmask = DT_IDFLG_USER;
 kbits = 0;
",322,75
"Adapt to the absence of elf_getshdrstrndx() and elf_getshdrnum().

These symbols were introduced in elfutils 0.142 as aliases for the deprecated
elf_getshstrndx() and elf_getshnum(). Unfortunately our snapshot build system
has an older elfutils than that, and we have repeatedly fallen victim to the
absence of these symbols on that system.

So use the new autoconf-like symbol-checking machinery to #define the new names
to the old ones where necessary, and use the new names everywhere, rather than
trying to use the old symbols and frequently forgetting a few, leading to
snapshot build failures later on."," dt_module_update(dtrace_hdl_t *dtp, const char *name)
 (void) close(fd);
 
 if (dmp->dm_elf == NULL || err == -1 ||
- elf_getshstrndx(dmp->dm_elf, &shstrs) != 1) {
+ elf_getshdrstrndx(dmp->dm_elf, &shstrs) != 1) {
 dt_dprintf(""failed to load %s: %s\n"",
  fname, elf_errmsg(elf_errno()));
 dt_module_destroy(dtp, dmp);
",667,156
"Permit changing of path to /proc filesystem.

This is done via the new -xprocfspath option.

libproc has always supported this, but dtrace provided no way to set it, and
libdtrace's own use of /proc was hardwired.

Diagnostics if the path is incorrectly set are currently unpleasant, but at
least there *is* a diagnostic.","
 */
 
 #include <sys/types.h>
-//#include <sys/modctl.h>
 #include <sys/utsname.h>
 #include <sys/resource.h>
 

 #include <dirent.h>
 #undef_POSIX_PTHREAD_SEMANTICS
 
+#include <libproc.h>
+
 #include <dt_impl.h>
 #include <dt_program.h>
 #include <dt_module.h>
 const dtrace_pattr_t _dtrace_prvdesc = {
 
 static const char *_dtrace_defcpp = ""/usr/bin/cpp""; /* default cpp(1) to invoke */
 static const char *_dtrace_defld = ""/usr/bin/ld""; /* default ld(1) to invoke */
+static const char *_dtrace_defproc = ""/proc""; /* default /proc path */
 
 static const char *_dtrace_libdir = DTRACE_LIBDIR; /* default library directory */
 static const char *_dtrace_provdir = ""/dev/dtrace/provider""; /* provider directory */
 alloc:
 dtp->dt_cpp_argc = 1;
 dtp->dt_cpp_args = 1;
 dtp->dt_ld_path = strdup(_dtrace_defld);
+dtp->dt_procfs_path = strdup(_dtrace_defproc);
+Pset_procfs_path(dtp->dt_procfs_path);
 dtp->dt_provmod = provmod;
 dtp->dt_vector = vector;
 dtp->dt_varg = arg;
",966,126
"Fix crash after dt_module_destroy().

dt_module_destroy() does not unlink the module being destroyed from the hash
chain in the dtrace_hdl, following which walks of that chain will point into
freed memory (at best)."," dt_module_unload(dtrace_hdl_t *dtp, dt_module_t *dmp)
 void
 dt_module_destroy(dtrace_hdl_t *dtp, dt_module_t *dmp)
 {
+uint_t h = dt_strtab_hash(dmp->dm_name, NULL) % dtp->dt_modbuckets;
+dt_module_t *scan_dmp;
+dt_module_t *prev_dmp = NULL;
+
 dt_list_delete(&dtp->dt_modlist, dmp);
 assert(dtp->dt_nmods != 0);
 dtp->dt_nmods--;
 
+for (scan_dmp = dtp->dt_mods[h]; (scan_dmp != NULL) && (scan_dmp != dmp);
+ scan_dmp = scan_dmp->dm_next) {
+prev_dmp = scan_dmp;
+}
+if (prev_dmp == NULL)
+dtp->dt_mods[h] = dmp->dm_next;
+else
+prev_dmp->dm_next = dmp->dm_next;
+
 dt_module_unload(dtp, dmp);
 free(dmp);
 }
",678,159
"Provide an implementation of strrstr().

This is like strstr() only finds the last match of the needle in the haystack,
rather than the first.

Implement in terms of strstr() on the grounds that this is probably optimized by
the libc.

I have seen Unix-like OSes that already implement strrstr() before (though Linux
does not), so we use the new symbol-checking machinery to provide it only if the
OS does not already implement it.","
 * CDDL HEADER END
 */
 /*
- * Copyright 2005 Oracle, Inc. All rights reserved.
+ * Copyright 2005, 2012 Oracle, Inc. All rights reserved.
 * Use is subject to license terms.
 */
 
 strhyphenate(char *s)
 
 return (s);
 }
+
+/*
+ * Search for the last occurrence of the given needle in the given haystack.
+ */
+char *strrstr(const char *haystack, const char *needle)
+{
+const char *s = haystack - 1;
+const char *prev_s = NULL;
+
+while ((s = strstr(s + 1, needle)) != NULL)
+prev_s = s;
+
+return (char *)prev_s;
+}
",230,86
"dt_idhash_destroy(), dt_strtab_destroy(): act like free().

That is to say, accept a NULL argument and do nothing, rather than dumping core.
(This is good practice for all freeing functions.)"," dt_idhash_destroy(dt_idhash_t *dhp)
 dt_ident_t *idp, *next;
 ulong_t i;
 
+if (!dhp)
+return;
+
 for (i = 0; i < dhp->dh_hashsz; i++) {
 for (idp = dhp->dh_hash[i]; idp != NULL; idp = next) {
 next = idp->di_next;
",759,182
"Track the path to kernel modules in the dtrace_hdl.

This is defaulted to the correct value for the running kernel, assuming a normal
'make install' from the kernel source tree (without overriding the module path).

The user can override the defaulted path via the new -xmodpath option.

A later commit will use this information."," dt_vopen(int version, int flags, int *errp,
 dt_module_t *dmp;
 dt_provmod_t *provmod = NULL;
 int i, err;
+char modpath[PATH_MAX];
 struct rlimit rl;
 
 const dt_intrinsic_t *dinp;
 alloc:
 dt_dof_init(dtp);
 (void) uname(&dtp->dt_uts);
 
+/*
+ * The default module path is derived in part from the utsname release
+ * string.
+ */
+strcpy(modpath, ""/lib/modules/"");
+strcat(modpath, dtp->dt_uts.release);
+dtp->dt_module_path = strdup(modpath);
+
 if (dtp->dt_mods == NULL || dtp->dt_provs == NULL ||
  dtp->dt_procs == NULL || dtp->dt_ld_path == NULL ||
  dtp->dt_cpp_path == NULL || dtp->dt_cpp_argv == NULL)
",970,126
"Quash a compiler warning.

The second argument to dt_ioctl() is an unsigned long, not an int."," dtrace_probe_iter(dtrace_hdl_t *dtp,
 
 dtrace_probedesc_t pd;
 dt_probe_iter_t pit;
-int cmd, rv;
+int rv;
+unsigned long int cmd;
 
 bzero(&pit, sizeof (pit));
 pit.pit_hdl = dtp;
",605,143
"Allow modules with no CTF data to have a one-byte dummy CTF section.

On Solaris, such modules often have a zero-byte dummy .SUNW_ctf section. I
wanted that to be true on Linux too, only to find tha thte oldish binutils in
OL6 has an objcopy that silently fails to do anything when asked to add a
section based on an empty file. So we use a one-byte \0 file instead, and
must cater to that."," dt_module_load(dtrace_hdl_t *dtp, dt_module_t *dmp)
 /*
  * Attempt to load the module's CTF section. Note that modules might
  * not contain CTF data: this will result in a successful load_sect but
- * data of size zero. We will then fail if dt_module_getctf() is
- * called, as shown below.
+ * data of size zero (or, alas, 1, thanks to a workaround for a bug in
+ * objcopy in binutils 2.20). We will then fail if dt_module_getctf()
+ * is called, as shown below.
  */
 
 if (dt_module_load_sect(dtp, dmp, &dmp->dm_ctdata) == -1) {
 dt_module_getctf(dtrace_hdl_t *dtp, dt_module_t *dmp)
 return (NULL);
 }
 
-if (dmp->dm_ctdata.cts_size == 0) {
+if ((dmp->dm_ctdata.cts_size == 0) ||
+ (dmp->dm_ctdata.cts_size == 1)) {
 dt_set_errno(dtp, EDT_NOCTF);
 return (NULL);
 }
",1069,255
"Module-loading-state fixes.

dt_module_init_elf() returns 0 for success, so we should check for failure
to load the ELF sections with != 0, not with !.

dt_module_getctf() was checking the presence or absence of a CTF section before
ensuring the module was loaded, rather than afterwards, breaking things for
modules with no CTF section."," dt_module_load(dtrace_hdl_t *dtp, dt_module_t *dmp)
  * varies per-module: all other modules have a constant name.
  */
 
-if ((dmp->dm_elf == NULL) && (!dt_module_init_elf(dtp, dmp)))
+if ((dmp->dm_elf == NULL) && (dt_module_init_elf(dtp, dmp) != 0))
 return -1; /* dt_errno is set for us */
 
 if (dmp->dm_flags & DT_DM_BUILTIN) {
 dt_module_getctf(dtrace_hdl_t *dtp, dt_module_t *dmp)
 ctf_file_t *pfp;
 int model;
 
-if (dmp->dm_ctfp != NULL || dt_module_load(dtp, dmp) != 0)
+if (!(dmp->dm_flags & DT_DM_LOADED))
+if (dt_module_load(dtp, dmp) != 0)
+return (NULL);
+
+if (dmp->dm_ctfp != NULL)
 return (dmp->dm_ctfp);
 
 if ((dmp->dm_ops == &dt_modops_64) || (dmp->dm_ops == NULL))
",1155,273
Tiny up some comment typos and historic ChangeLog mistakes.," Pstate(struct ps_prochandle *P)
 * Return the open memory file descriptor for the process, reopening it if
 * needed.
 *
- * Clients must not close this file descriptor, not use it after the process is
+ * Clients must not close this file descriptor, nor use it after the process is
 * freed or Pclose()d.
 */
 int
",398,83
"Tiny code police changes and a leak fix.

The leak is almost entirely insignificant except for users of libdtrace other
than dtrace, who may potentially call dtrace_close() more than once."," dt_module_getctf(dtrace_hdl_t *dtp, dt_module_t *dmp)
 return (NULL);
 }
 
-if (dmp->dm_flags & DT_DM_KERNEL) {
+if (dmp->dm_flags & DT_DM_KERNEL)
 dmp->dm_ctfp = ctf_bufopen(&dmp->dm_ctdata, NULL, NULL,
  &dtp->dt_ctferr);
-} else {
+else
 dmp->dm_ctfp = ctf_bufopen(&dmp->dm_ctdata,
  &dmp->dm_symtab, &dmp->dm_strtab, &dtp->dt_ctferr);
-}
 
 if (dmp->dm_ctfp == NULL) {
 dt_dprintf(""ctfp for module %s; error: %s\n"", dmp->dm_name,
",1164,274
"Drop CTF parent-name-of-PARENT kludge.

Drop the hardwiring of dtrace_ctf as the parent of all modules now that libctf
and dwarf2ctf are fixed to get the parent name right."," dt_module_getctf(dtrace_hdl_t *dtp, dt_module_t *dmp)
 ctf_setspecific(dmp->dm_ctfp, dmp);
 
 if ((parent = ctf_parent_name(dmp->dm_ctfp)) != NULL) {
-
-/*
- * Kernel modules currently use the dynamic CTF writing
- * infrastructure, which does not write out a parent name.
- * Thankfully we don't need one: we know what it must be.
- */
-
-if ((dmp->dm_flags & DT_DM_KERNEL) &&
- (strcmp(parent, ""PARENT"") == 0))
-parent = ""dtrace_ctf"";
-
 if ((pmp = dt_module_create(dtp, parent)) == NULL ||
  (pfp = dt_module_getctf(dtp, pmp)) == NULL) {
 if (pmp == NULL)
",1161,272
"Miscellanous changes without functional effect.

Some sched tests now work: enable them. (sched tests which require porting,
because they look at process states, are not yet enabled.)

Mention working CTF in the README (but not yet new providers until we know which
providers will be released).

... and a tiny coding style fix."," Pbuild_file_symtab(struct ps_prochandle *P, file_info_t *fptr)
 plt = cp;
 } else if ((strcmp(cp->c_name, "".dtrace_ctf"") == 0) ||
  (strncmp(cp->c_name, "".dtrace_ctf."",
- strlen ("".dtrace_ctf."")) == 0))
-{
+ strlen("".dtrace_ctf."")) == 0)) {
 /*
  * Skip over bogus CTF sections so they don't come back
  * to haunt us later.
",1790,3
"Small compiler warning fixes.

Only one of these might cause trouble, where an uninitialized variable might
have been used if Pupdate_maps() wer eever called for a process with no maps at
all."," dt_proc_bpmain(dtrace_hdl_t *dtp, dt_proc_t *dpr, const char *fname)
 static void
 dt_proc_attach(dt_proc_t *dpr, int exec)
 {
-GElf_Sym sym;
-
 assert(MUTEX_HELD(&dpr->dpr_lock));
 
 if (exec) {
",452,90
"Provide translators for io, sched, and proc SDT probes, and addtional info.

This commit adds a d_path() subroutine to DIF that converts a 'struct path *'
into a pathname string. It is used in the io xlator. It also provides a more
accurate regs.d script, specifying identifiers for processor registers.

The commit also adds the required xlators for io, proc, and sched probes,
making it possible to ensure that the arguments to the SDT probes are
consistent with the DTrace documentation."," static const dt_ident_t _dtrace_globals[] = {
 &dt_idops_func, ""void(char *, uintptr_t, size_t)"" },
 { ""count"", DT_IDENT_AGGFUNC, 0, DTRACEAGG_COUNT, DT_ATTR_STABCMN, DT_VERS_1_0,
 &dt_idops_func, ""void()"" },
+{ ""curcpu"", DT_IDENT_SCALAR, 0, DIF_VAR_CURCPU, DT_ATTR_STABCMN, DT_VERS_1_0,
+&dt_idops_type, ""vmlinux`cpuinfo_t *"" },
 { ""curthread"", DT_IDENT_SCALAR, 0, DIF_VAR_CURTHREAD,
 { DTRACE_STABILITY_STABLE, DTRACE_STABILITY_PRIVATE,
 DTRACE_CLASS_COMMON }, DT_VERS_1_0,
 &dt_idops_type, ""vmlinux`struct task_struct *"" },
+{ ""d_path"", DT_IDENT_FUNC, 0, DIF_SUBR_D_PATH, DT_ATTR_EVOLCMN,
+DT_VERS_1_0, &dt_idops_func, ""string(struct path *)"" },
 { ""ddi_pathname"", DT_IDENT_FUNC, 0, DIF_SUBR_DDI_PATHNAME,
 DT_ATTR_EVOLCMN, DT_VERS_1_0,
 &dt_idops_func, ""string(void *, int64_t)"" },
",983,128
"Minor changes to triggers to improve test execution.

proc-tst-sigwait.c: Increased the time value to be 5s instead of 1s to account
 for possible delays in DTrace userspace startup.

ustack-tst-bigstack.c: More complex implementation to ensure that GCC does not
 optimize the code such that it no longer results in an
 exceptionally big stack."," main(int argc, char **argv)
 (void) sigaddset(&set, SIGUSR1);
 (void) sigprocmask(SIG_BLOCK, &set, NULL);
 
-ts.it_value.tv_sec = 1;
+ts.it_value.tv_sec = 5;
 ts.it_value.tv_nsec = 0;
 ts.it_interval.tv_sec = 0;
 ts.it_interval.tv_nsec = NANOSEC / 2;
",40,4
"Enable tests that use the raise() action.

Now that the DTrace core (at the kernel level) supports the raise() action,
tests that depend o nit can be enabled. Triggers that were used for these
tests tended to use getpid() in a loop as a syscall to probe for, but Linux
tends to cache the result of a getpid() call and therefore does not actually
execute the syscall at every invocation. The triggers have been reworked to
use an ioctl() instead.

This commit also enables the io/tst.fds.d test, which exercises both the raise
action, and io xlator for file structures (accessed through the fds global
variable)."," interrupt(int sig)
 int
 main(void)
 {
-const char *file = ""/dev/null"";
+const char *file = ""/proc/self/mem"";
 int i, n, fds[10];
 struct sigaction act;
 struct rlimit rl;
",47,6
"Comment niggles.

One comment in dt_proc_control_cleanup() was accidentally removed, and the
changelog used an old name for @@quiet."," dt_proc_control_cleanup(void *arg)
  * Set dpr_done and clear dpr_tid to indicate that the control thread
  * has exited, and notify any waiting thread in dt_proc_destroy() that
  * we have successfully exited.
+ *
+ * If we were cancelled while already holding the mutex, don't lock it
+ * again.
  */
 if(!dpr->dpr_tid_locked) {
 pthread_mutex_lock(&dpr->dpr_lock);
",456,90
"Fix dtrace_lookup_by_addr() crashes.

The sip and symp parameters can both be NULL. The userspace symbol lookup code
was allowing for this, but the kernel symbol lookup code was not."," dtrace_lookup_by_addr(dtrace_hdl_t *dtp, GElf_Addr addr,
 if (!dt_symp)
 return (dt_set_errno(dtp, EDT_NOSYMADDR));
 
-sip->dts_object = dmp->dm_name;
-sip->dts_name = dt_symbol_name(dmp->dm_kernsyms, dt_symp);
-sip->dts_id = 0;/* undefined */
-dt_symbol_to_elfsym(dtp, dt_symp, symp);
+if (sip != NULL) {
+ sip->dts_object = dmp->dm_name;
+ sip->dts_name = dt_symbol_name(dmp->dm_kernsyms, dt_symp);
+ sip->dts_id = 0;/* undefined */
+}
+
+if (symp != NULL)
+ dt_symbol_to_elfsym(dtp, dt_symp, symp);
 
 return (0);
 } else {
",1218,296
"Warning police.

Missing headers, a few outright bugs which are almost impossible to hit unless
other things are buggy (e.g. dt_aggregate_valcmp() being called with zero-length
aggregate buffers). Nothing serious.

""May be used uninitialized"" warnings which are actually erroneous have been left
untouched."," dt_aggregate_valcmp(const void *lhs, const void *rhs)
 if (lagg->dtagd_nrecs < ragg->dtagd_nrecs)
 return (DT_LESSTHAN);
 
-/* FIXME: what if lagg->dtagd_nrecs == 0? */
+if (lagg->dtagd_nrecs == 0)
+ return 0;
 
 for (i = 0; i < lagg->dtagd_nrecs; i++) {
 lrec = &lagg->dtagd_rec[i];
",1208,289
"Set options from environment variables.

Introduce a set of environment variables named DTRACE_OPT_* which can be used to
specify default values for DTrace options. Both -X on the command line and
setopt in .d files overrides options set this way.

Also, document known-useful environment variables used by DTrace. (Some
environment variables are set but used for parts of DTrace not yet ported: these
are not documented.)"," main(int argc, char *argv[])
 (void) dtrace_setopt(g_dtp, ""bufsize"", ""4m"");
 (void) dtrace_setopt(g_dtp, ""aggsize"", ""4m"");
 
+/*
+ * The very first thing we do after buffer-size sanitization is run
+ * through the environment and set DTrace options based on environment
+ * variables.
+ */
+dtrace_setoptenv(g_dtp, ""DTRACE_OPT_"");
+
 /*
  * If -G is specified, enable -xlink=dynamic and -xunodefs to permit
  * references to undefined symbols to remain as unresolved relocations.
",1308,326
"Drop relocation constants with nonstandard names.

include/sys/elf_amd64.h contains redeclarations of a lot of standard AMD64
relocation constants, duplicative of declarations in <elf.h> but with slightly
different names.

Removing them is easy.","
 #include <assert.h>
 #include <errno.h>
 #include <ctype.h>
-#include <sys/procfs_isa.h>
 #include <limits.h>
 
 #include <dt_ident.h>
",758,182
"Add ps_prochandle.ptraced to track the ptrace state of processes.

As of commit 4fcb15b1, whether we PTRACE_DETACH from a process once it is set
running depends on the value of a command-line parameter to Psetrun(). This
means that we could not tell if further ptrace()s required a reattachment or
not, but this was not a problem since we never needed to do any further
ptrace()s.

As of a forthcoming commit this will no longer be true, so add a ptraced flag to
indicate whether we are PTRACE_ATTACHed to this process at present."," Pcreate(
  */
 (void) memset(P, 0, sizeof (*P));
 P->state = PS_TRACESTOP;
+P->ptraced = TRUE;
 P->pid = pid;
 Pinitsym(P);
 (void) Pmemfd(P);/* populate ->memfd */
 Prelease(struct ps_prochandle *P, boolean_t kill_it)
 kill(P->pid, SIGKILL);
 else
 ptrace(PTRACE_DETACH, (int)P->pid, 0, 0);
+P->ptraced = FALSE;
 
 Pfree(P);
 }
 Psetrun(struct ps_prochandle *P, boolean_t detach_it)
 if (ptrace(ptrace_req, P->pid, 0, 0) < 0)
 return (-1);
 P->state = PS_RUN;
+P->ptraced = !detach_it;
 }
 
 return (0);
",413,88
"Make dtrace -G work.

The drti.c code has been reworked to use /proc/<PID>/maps to determine the
full path of the executable and the base address. It will now correctly
pass the embedded DOF object to the DTrace helper interface at executable
startup (constructor), and call the remove function at (normal) termination
(destructor).

Small change to dt_link.c to ensure that rewritten USDT probe locations are
not relocated later in the executable link process. Mark them as type 0
(universal NONE type), which ensures they are ignored. On OpenSolaris this
was handled through DTrace-aware code in the linker which is entirely
unnecessary."," process_obj(dtrace_hdl_t *dtp, const char *obj, int *eprobesp)
 rsym.st_shndx = SHN_SUNW_IGNORE;
 (void) gelf_update_sym(data_sym, ndx, &rsym);
 }
+
+/*
+ * This relocation is no longer needed.
+ */
+if (shdr_rel.sh_type == SHT_RELA) {
+rela.r_info = GELF_R_INFO(ndx, 0);
+(void) gelf_update_rela(data_rel, i, &rela);
+} else {
+GElf_Rel rel;
+
+rel.r_offset = rela.r_offset;
+rel.r_info = GELF_R_INFO(ndx, 0);
+(void) gelf_update_rel(data_rel, i, &rel);
+}
 }
 }
 
",1059,223
"Make test/utils compile.

test/utils wasn't being compiled due to a missing line in test/Build,
and used had portability problems which stopped them compiling in any case.

Fix trivial.","
 */
 
 /*
- * Copyright 2007, 2011 Oracle, Inc. All rights reserved.
+ * Copyright 2007, 2011, 2013 Oracle, Inc. All rights reserved.
 * Use is subject to license terms.
 */
 
-#pragma ident""%Z%%M%%I%%E% SMI""
-
+#include <sys/types.h>
 #include <sys/stat.h>
+#include <sys/ioctl.h>
 #include <stdio.h>
 #include <stdlib.h>
+#include <stdarg.h>
 #include <fcntl.h>
-#include <sys/varargs.h>
 #include <errno.h>
 #include <math.h>
+#include <string.h>
 #include <dtrace.h>
 
 void
 main(int argc, char **argv)
 fatal(""could not allocate copy of %d bytes"", len);
 
 for (;;) {
-bcopy(dof, copy, len);
+memcpy(copy, dof, len);
 /*
  * Open another instance of the dtrace device.
  */
",110,21
"Cater for rtld_db-iterated entities with no name.

Some of the things rtld_db iterates over are not normal shared libraries, and
have no SONAME, hence no name in ld.so's link maps. (These include the
executable itself, and the vdso.)

Armour the map iterator in Psymtab againt this case. (A later commit will
add a mechanism to tell which is which.)"," map_iter(const rd_loadobj_t *lop, void *prochandle)
 
 if (Pread_string(P, buf, sizeof (buf), lop->rl_nameaddr) > 0) {
 if ((fptr->file_lname == NULL) ||
- (strcmp(fptr->file_lname, buf) != 0)) {
+ (strcmp(fptr->file_lname, buf) != 0) ||
+ (buf[0] != '\0')) {
 
 free(fptr->file_lname);
 fptr->file_lbase = NULL;
",1094,291
"Add a missing Pupdate_lmids() call.

Pbuild_file_symtab() depends on both Pupdate_maps() and Pupdate_lmids() having
been called before it is. In one case (Pupdate_syms()) we were not doing that."," Pupdate_syms(struct ps_prochandle *P)
 
 P->info_valid = 0;
 Pupdate_maps(P);
+ Pupdate_lmids(P);
 
 for (i = 0, fptr = dt_list_next(&P->file_list);
  i < P->num_files; i++, fptr = dt_list_next(fptr))
",1133,299
"Rename rd_loadobj_t.rl_base to rl_diff_addr.

rl_base is a bad name for this field, as it is not the base of anything: it is
the difference between the addresses in the ELF file and the addresses in
memory. So rename it accordingly (and all its uses)."," Pbuild_file_symtab(struct ps_prochandle *P, file_info_t *fptr)
  * for relocatable objects.
  *
  * ld.so has a special kludge to work this out, since it relocates
- * itself without setting its rl_base correspondingly. We look up the
- * address of the _r_debug symbol in ld.so, and subtract that from the
- * address given in DT_DEBUG.
+ * itself without setting its rl_diff_addr correspondingly. We look up
+ * the address of the _r_debug symbol in ld.so, and subtract that from
+ * the address given in DT_DEBUG.
  */
 if(fptr->file_map == P->map_ldso) {
 GElf_Sym r_debug_sym = {0};
 Pbuild_file_symtab(struct ps_prochandle *P, file_info_t *fptr)
 */
 if (fptr->file_etype == ET_DYN &&
  fptr->file_lo != NULL) {
- fptr->file_dyn_base = fptr->file_lo->rl_base;
+ fptr->file_dyn_base = fptr->file_lo->rl_diff_addr;
  _dprintf(""reset file_dyn_base for %s to %lx\n"",
  fptr->file_pname, fptr->file_dyn_base);
 }
",1179,309
"Remove some initialization code rendered obsolete by the rtld_db rewrite.

Solaris rtld_db has an elaborate protocol-versioning scheme and requires early
initialization. Our rtld_db has none of these, so all such code is obsolete."," int _dtrace_argmax = 32;/* default maximum number of probe arguments */
 
 int _dtrace_debug = 0;/* debug messages enabled (off) */
 const char *const _dtrace_version = DT_VERS_STRING; /* API version string */
-#if defined(sun)
-int _dtrace_rdvers = RD_VERSION; /* rtld_db feature version */
-#endif
 
 typedef struct dt_fdlist {
 int *df_fds;/* array of provider driver file descriptors */
 void
 _dtrace_init(void)
 {
 _dtrace_debug = getenv(""DTRACE_DEBUG"") != NULL;
-#if 0
-for (; _dtrace_rdvers > 0; _dtrace_rdvers--) {
-if (rd_init(_dtrace_rdvers) == RD_OK)
-break;
-}
-#endif
 }
 
 static dtrace_hdl_t *
",978,125
"Add a ustack() test.

This test tries to ustack() readwholedir on its first read() call. We have to
add LDFLAGS to readwholedir to ensure it is built with a dynamic symbol table,
so the symbol lookups have a chance of success. We also have to pause
readwholedir a bit before quitting, or there is a race window where readwholedir
can exit before dtrace userspace gets its buffers back, which also makes symbol
lookups impossible."," main (void)
 rw_files(path, dir, writefile);
 fclose(tmp);
 
+/*
+ * Let dtrace catch up, for ustack() tests that need a running process.
+ */
+sleep(2);
+
 return 0;
 }
 
",102,17
"Fix crashes on victim process death.

If the victim process dies just before a Pxlookup_by_name() call, DTrace dumps
core when it tries to dereference a NULL mappings pointer. Code in Psymtab.c
must always check P->info_valid whenever doing a Pupdate_maps() to detect
process death (or exec() by a setuid process, or similar now-we-can't-
ptrace()-you changes in state), and a couple of places were failing to do that."," Pxlookup_by_name_internal(
 Pupdate_maps(P);
 Pupdate_lmids(P);
 
+if (!P->info_valid)
+ return (-1);
+
 /*
  * Start from the executable mapping, if known.
  */
 Pobject_iter(struct ps_prochandle *P, proc_map_f *func, void *cd)
 Pupdate_maps(P);
 Pupdate_lmids(P);
 
+if (!P->info_valid)
+ return (-1);
+
 for (cnt = P->num_files, fptr = dt_list_next(&P->file_list);
  cnt; cnt--, fptr = dt_list_next(fptr)) {
 const char *lname;
",1295,337
"Initialize the rtld_db agent when Prd_agent() is called.

As of d722700, the rtld_db agent is initialized by Pupdate_lmids(), not
Pupdate_maps(); so Prd_agent() had better call Pupdate_lmids(), or it'll
be unnecessarily returning NULL much of the time."," Pupdate_syms(struct ps_prochandle *P)
 rd_agent_t *
 Prd_agent(struct ps_prochandle *P)
 {
- if (P->rap == NULL && P->state != PS_DEAD)
- Pupdate_maps(P);
+if (P->rap == NULL && P->state != PS_DEAD) {
+Pupdate_maps(P);
+Pupdate_lmids(P);
+}
 return (P->rap);
 }
 
",1297,337
"Remove spurious return.

A return after a goto crept in. Remove it."," add_bkpt(struct ps_prochandle *P, uintptr_t addr, int after_singlestep,
 mask_bkpt(bkpt->orig_insn)) < 0) {
 free(bkpt);
 goto err;
-return errno;
 }
 
 bkpt->bkpt_next = P->bkpts[h];
",1049,228
"Do not crash on PR_OBJ_EVERY name lookup if rtld_db cannot be initialized.

Pupdate_symsearch() was using the rtld_db map-iteration pointer (fptr->file_lo)
without checking if it was NULL, which it could legitimately be if it was too
early in process execution to initialize rtld_db. This caused crashes if you
did a symbol lookup with PR_OBJ_EVERY that early on. (Such a symbol lookup
could not follow symbol scopes, but should still be able to do a linear scan.
It should certainly not crash.)"," Pupdate_symsearch(struct ps_prochandle *P, struct file_info *fptr)
 rd_loadobj_t scope_lo = {0};
 size_t i = 0;
 
-if (fptr->file_symsearch)
+if (fptr->file_symsearch != NULL ||
+ fptr->file_lo == NULL)
 return;
 
 fptr->file_symsearch = calloc(fptr->file_lo->rl_nscopes,
",1298,338
"A couple of symbol search scope bugfixes.

Firstly, an unfortunate typo led to the ld.so-scoped part of the symbol search
often (but not always) being skipped: it fell through to the linear search
Solaris always used to do, so most things still worked. Another unfortunate
typo, spotted by valgrind, led to an off-by-one bug in the ld.so-scoped symbol
search code and could easily have led to crashes (once the first bug was fixed)."," sym_search_next(struct ps_prochandle *P, file_info_t *fptr,
 }
 
 /*
- * Start: first hit is always ourself.
+ * Start: first hit is always ourself. Subsequently, use the path
+ * search, if possible, or a linear search otherwise.
  */
 if (state->ssi_state == SSI_START) {
 state->fptr = fptr;
 state->path_index = 0;
 
-if (fptr->file_nsymsearch == 0)
+if (fptr->file_nsymsearch != 0)
 state->ssi_state = SSI_PATH;
 else
 state->ssi_state = SSI_START_LINEAR;
 sym_search_next(struct ps_prochandle *P, file_info_t *fptr,
 case SSI_PATH: {
 file_info_t *ret = fptr->file_symsearch[state->path_index++];
 
-if (state->fptr->file_nsymsearch < state->path_index) {
+if (state->path_index >= state->fptr->file_nsymsearch) {
 state->ssi_state = SSI_START_LINEAR;
 }
 return ret;
",1298,338
"Don't bother stashing rtld_db info for mappings with no dynamic section.

In DTRACE_DEBUG mode, we got the message

map_iter: base address doesn't match any mapping

on every invocation, because not every link map rtld_db returns necessarily has
a dynamic section. We don't care about mappings with no dynamic section, but we
should skip them silently rather than complaining."," map_iter(const rd_loadobj_t *lop, size_t num, void *prochandle)
 else if (num == 1) {
 _dprintf(""map_iter: skipping vdso\n"");
  return (1);
-} else if ((mptr = Paddr2mptr(P, lop->rl_dyn)) == NULL) {
-_dprintf(""map_iter: base address doesn't match any mapping\n"");
+} else if (lop->rl_dyn == 0)
+/*
+ * No dynamic section: this cannot be anything we are interested
+ * in.
+ */
+return (1);
+else if ((mptr = Paddr2mptr(P, lop->rl_dyn)) == NULL) {
+_dprintf(""map_iter: base address of %lu doesn't match any mapping\n"", lop->rl_dyn);
 return (1);
 }
 
",1300,339
"Close the DTrace handle on fatal errors.

If DTrace exits with breakpoints outstanding on a child process, the child
process will die with a SIGTRAP when it hits them. Prelease() cleans them up,
which is (eventually) called by dtrace_close(), so all exit paths from DTrace
should call this. At least one was not: fatal(), in cmd/dtrace.c. This appears
to be because fatal() is called at some points before DTrace is initialized, so
the DTrace handle can be NULL; the right thing to do is to make a dtrace_close()
of NULL harmless, and then call it unconditionally from fatal()."," fatal(const char *fmt, ...)
 verror(fmt, ap);
 va_end(ap);
 
+/*
+ * Close the DTrace handle to ensure that any controlled processes are
+ * correctly restored and continued.
+ */
+dtrace_close(g_dtp);
+
 exit(E_ERROR);
 }
 
",1304,324
"Add a missing process lock.

The dpr_lock must be taken, and dpr_tid_locked set, around all calls to
dt_proc_stop(). dt_proc_rdevent() was neglecting to do that."," dt_proc_rdevent(rd_agent_t *rd, rd_event_msg_t *msg, void *state)
 dt_dprintf(""pid %d: rtld event, type=%d state %d\n"",
  (int)dpr->dpr_pid, msg->type, msg->state);
 
+pthread_mutex_lock(&dpr->dpr_lock);
+dpr->dpr_tid_locked = B_TRUE;
+
 switch (msg->type) {
 case RD_DLACTIVITY:
 if (msg->state != RD_CONSISTENT)
 dt_proc_rdevent(rd_agent_t *rd, rd_event_msg_t *msg, void *state)
 /* cannot happen, but do nothing anyway */
 break;
 }
+dpr->dpr_tid_locked = B_FALSE;
+pthread_mutex_unlock(&dpr->dpr_lock);
 }
 
 /*
",546,109
"Don't dt_free() the process at the end of dt_proc_control().

This leads to a double-free() if the process is calling dtrace_close() (and thus
dt_proc_destroy()) at the same time. (This is temporarily diked out because we
have a better solution coming up in the waitfd-revamp change.)"," dt_proc_control(void *arg)
 
 dt_list_delete(&dph->dph_lrulist, dpr);
 dt_proc_remove(dtp, pid);
-dt_free(dtp, dpr);
+/* dt_free(dtp, dpr); -- XXX temporarily diked out */
 
 pthread_mutex_unlock(&dph->dph_destroy_lock);
 
",545,109
"Ensure correct prototype declarations are generated for pn(void).

[DTRACE-74] Ensure that a pn(void) probe in a provider definition processed
with dtrace -h results in a valid prototype rather than pn(void, )."," dt_header_decl(dt_idhash_t *dhp, dt_ident_t *idp, void *data)
  buf, sizeof (buf))) < 0)
 return (dt_set_errno(dtp, errno));
 
-if (i + 1 != prp->pr_nargc &&
+if (i + 1 < prp->pr_nargc &&
  fprintf(infop->dthi_out, "", "") < 0)
 return (dt_set_errno(dtp, errno));
 }
",447,112
"Remove trailing newline in module name passed with DOF.

The code retrieving the executable name (to be used as probe module name) from
the /proc/<PID>/maps file was not removing the trailing newline, causing the
module name to include that newline and failing to match against the actual
executable name."," dtrace_dof_init(void)
 }
 while (fgets(str, sizeof(str), fp) != NULL) {
 uintptr_tstart, end;
-char*p = str;
+char*p = str, *q;
 
 start = strtol(p, &p, 16);
 if (*p != '-')
 dtrace_dof_init(void)
 
 if ((p = strrchr(str, ' ')) == NULL)
 continue;
+if ((q = strchr(p, '\n')) != NULL)
+*q = '\0';
 
 fmap.l_addr = start;
 fmap.l_name = p + 1;
",123,29
"Emit missing #include in dtrace -h.

The header emitted by dtrace -h refers to the C names of D types. Those types
include what dt_open.c describes as ""typical <sys/types.h> names"". In a
post-C99 world, these are <inttypes.h> names, yet no suitable #include was being
emitted, leading to compilation errors.

Fix trivial."," dtrace_program_header(dtrace_hdl_t *dtp, FILE *out, const char *fname)
 return (dt_set_errno(dtp, errno));
 }
 
-if (fprintf(out, ""#include <unistd.h>\n\n"") < 0)
+if (fprintf(out, ""#include <unistd.h>\n""
+""#include <inttypes.h>\n\n"") < 0)
 return (-1);
 
 if (fprintf(out, ""#ifdef\t__cplusplus\nextern \""C\"" {\n#endif\n\n"") < 0)
",448,112
"Drop RD_{PRE,POST}INIT rtld_db events.

Solaris has RD_PREINIT and RD_POSTINIT events in its rtld_db library
to stop victim execution at points appropriate for the evaltime=preinit
and postinit calls.

We implement this a different way, and don't generate these events.
So drop them."," dt_proc_rdevent(rd_agent_t *rd, rd_event_msg_t *msg, void *state)
 dt_proc_notify(dtp, dtp->dt_procs, dpr,
  dpr->dpr_errmsg);
 
-break;
-case RD_PREINIT:
-Pupdate_syms(dpr->dpr_proc);
-dt_proc_stop(dpr, DT_PROC_STOP_PREINIT);
-break;
-case RD_POSTINIT:
-Pupdate_syms(dpr->dpr_proc);
-dt_proc_stop(dpr, DT_PROC_STOP_POSTINIT);
 break;
 case RD_NONE:
 /* cannot happen, but do nothing anyway */
",537,107
"Fix Ptrace()/Puntrace() imbalance.

It is crucial that every Ptrace() call be accompanied by exactly one Puntrace().

Pbuild_file_symtab() was failing to do this in one case, if its first Ptrace()
led to a breakpoint hit and a recursive call to Pbuild_file_symtab() such that
the outermost call to Pbuild_file_symtab() didn't need to do anything any more."," Pbuild_file_symtab(struct ps_prochandle *P, file_info_t *fptr)
  * same is true of the Puntrace().
  */
 fptr->file_init = 0;
-p_state = Ptrace(P, 0);
-if (fptr->file_init == 1)
+p_state = Ptrace(P, 1);
+if (fptr->file_init == 1) {
+Puntrace(P, p_state);
 return;
+}
 fptr->file_init = 1;
 
 if ((p_state < 0) || (wrapped_ptrace(P, PTRACE_GETMAPFD, P->pid,
",1302,339
"If PTRACE_GETMAPFD doesn't work, say why.

The errno is useful: we should be printing it."," Pbuild_file_symtab(struct ps_prochandle *P, file_info_t *fptr)
 if ((p_state < 0) || (wrapped_ptrace(P, PTRACE_GETMAPFD, P->pid,
  P->mappings[fptr->file_map].map_pmap.pr_vaddr, &fd) < 0)) {
 _dprintf(""cannot acquire file descriptor for mapping at %lx ""
- ""named %s\n"", P->mappings[fptr->file_map].map_pmap.pr_vaddr,
-fptr->file_pname);
+ ""named %s: %s\n"", P->mappings[fptr->file_map].map_pmap.pr_vaddr,
+ fptr->file_pname, strerror(errno));
 Puntrace(P, p_state);
 goto bad;
 }
",1302,339
"A bit of stylistic consistency with function pointer typedefs.

libproc was using a different style for one or two function pointer
typedefs than the rest of DTrace."," Pset_procfs_path(const char *path)
 * Set a handler for exec()s.
 */
 void
-set_exec_handler(struct ps_prochandle *P, exec_handler_fun handler)
+set_exec_handler(struct ps_prochandle *P, exec_handler_fun *handler)
 {
 P->exec_handler = handler;
 }
",1087,242
"Add support for mutex debugging to DTrace.

This adds a new undocumented debugging option, debugassert, which currently
takes a single value, 'mutexes', which flips on the DT_DEBUG_MUTEXES bit in the
new _dtrace_debug_assert variable. This is then used by dt_proc_create() and
dt_proc_grab() to use error-checking mutexes for the dpr_lock process locks.","
 */
 
 int _dtrace_debug = 0;/* debug messages enabled (off) */
+int _dtrace_debug_assert = 0;/* expensive debug assertions enabled (off) */
 
 static char *ring;/* ring buffer, if non-NULL */
 static size_t ring_size;/* ring size */
",120,25
"Do not repeatedly re-drop the r_brk dynamic debugging breakpoint.

Commit 16ac9e044f26083ed9ef3de3aecae3dd4062a900 arranged to repeatedly call
dt_proc_rdagent() on every loop through the DTrace process control thread,
because ""it is basically free after the first call"". Or it should have been.
Unfortunately we forgot to set the rd_monitoring flag in this case, so on every
call we were deleting the rd_brk breakpoint and re-dropping it again *just in
case*. Fix by setting the flag."," rd_ldso_nonzero_lmid_consistent_begin(rd_agent_t *rd)
 rd->lmid_bkpted = TRUE;
 else {
 rd->lmid_halted = 1;
-rd->lmid_halt_prev_state = Ptrace(rd->P, TRUE);
+rd->lmid_halt_prev_state = Ptrace(rd->P, 1);
 }
 
 return 0;
 rd_event_enable(rd_agent_t *rd, rd_event_fun fun, void *data)
 if (Pbkpt(rd->P, rd->r_brk_addr, FALSE, rd_brk_trap, NULL, rd) != 0)
 return RD_ERR;
 
+rd->rd_monitoring = TRUE;
 _dprintf(""%i: enabled rtld activity monitoring.\n"", rd->P->pid);
 
 return RD_OK;
",724,202
"dt_pid: don't Pupdate_maps() before Pobject_iter().

It's useless: Pobject_iter() does that itself."," dt_pid_create_usdt_probes(dtrace_probedesc_t *pdp, dtrace_hdl_t *dtp,
 
 assert(MUTEX_HELD(&dpr->dpr_lock));
 
-(void) Pupdate_maps(P);
 if (Pobject_iter(P, dt_pid_usdt_mapping, P) != 0) {
 ret = -1;
 (void) dt_pid_error(dtp, pcb, dpr, NULL, D_PROC_USDT,
",525,124
"Prohibit self-grabs.

If a ustack() or similar operation is done from a BEGIN probe, the effective
process is the DTrace process itself. But you can't ptrace() yourself! In
theory we could reimplement (almost) everything we've done with ptrace() using
direct memory access, but doing that for this one case is pointless.

It's easier just to ban self-grabs: DTrace then falls back to reporting pure
addresses in ustack() et al. (Once we have noninvasive grabs, we'll be able to
improve on this a bit.)"," Pgrab(pid_t pid, void *wrap_arg, int *perr)
 return (NULL);
 }
 
+if (pid == getpid()) {
+_dprintf(""Self-grabs are not supported.\n"");
+*perr = ESRCH;
+return (NULL);
+}
+
 if ((P = malloc(sizeof (struct ps_prochandle))) == NULL) {
 *perr = ENOMEM;
 return (NULL);
",1110,246
"Detect removal of nonexistent breakpoints in the right place.

We were checking too late, after we'd deferenced a null breakpointer and
crashed."," Punbkpt(struct ps_prochandle *P, uintptr_t addr)
  * lookup-with-unchain if this is not so.
  */
 bkpt = bkpt_by_addr(P, addr, FALSE);
+if (!bkpt) {
+_dprintf(""%i: Punbkpt() called with %lx, which is not a known ""
+ ""breakpoint.\n"", P->pid, addr);
+Puntrace(P, orig_state);
+return;
+}
+
 if (bkpt->in_handler) {
 bkpt->pending_removal = 1;
 Puntrace(P, orig_state);
 Punbkpt(struct ps_prochandle *P, uintptr_t addr)
 
 Pwait(P, 0);
 bkpt = bkpt_by_addr(P, addr, TRUE);
-if (!bkpt) {
-_dprintf(""%i: Punbkpt() called with %lx, which is not a known ""
- ""breakpoint.\n"", P->pid, addr);
-return;
-}
 
 P->num_bkpts--;
 
",1115,247
"Don't spam stdout from the pid-tst-gcc trigger.

This trigger uses posix_spawn(), which means we have to actually close and
reopen from /dev/null our *own* stdin/stdout/stderr.

Also, don't pass a NULL argv in -- this causes noisy warnings on the screen
during testsuite runs.","
 */
 
 /*
- * Copyright 2006, 2012 Oracle, Inc. All rights reserved.
+ * Copyright 2006, 2012, 2013 Oracle, Inc. All rights reserved.
 * Use is subject to license terms.
 */
 
 #include <stdlib.h>
 #include <sys/types.h>
+#include <sys/stat.h>
 #include <sys/wait.h>
+#include <fcntl.h>
 #include <signal.h>
+#include <unistd.h>
 #include <spawn.h>
 
 void
 go(void)
 {
+char *argv[] = { ""/bin/ls"", NULL };
 pid_t pid;
+int null = open(""/dev/null"", O_RDWR);
 
-(void) posix_spawn(&pid, ""/bin/ls"", NULL, NULL, NULL, NULL);
+/*
+ * Don't spam the screen with ls output.
+ */
+dup2(null, 0);
+dup2(null, 1);
+dup2(null, 2);
+close(null);
+
+(void) posix_spawn(&pid, ""/bin/ls"", NULL, NULL, argv, NULL);
 
 (void) waitpid(pid, NULL, 0);
 }
",38,4
"Ensure multiple passes through dtrace -G work.

Due to how relocations for USDT probe locations were handled, doing a second
pass through 'dtrace -G' would cause probes to no longer be recognized. This
commit ensures that we recognize relocations of type NONE as probe locations
that were already processed rather than ignoring them.

Also add an explicit define for _DTRACE__VERSION in the generated header file
from 'dtrace -h' invocations. This seems silly, but it is there to give people
a skeleton to work with if they want to pre-generate header files and select
whether to actually compile on the probes at a later time."," dt_header_provider(dtrace_hdl_t *dtp, dt_provider_t *pvp, FILE *out)
 info.dthi_pfname = alloca(strlen(pvp->pv_desc.dtvd_name) + 1 + i);
 dt_header_fmt_func(info.dthi_pfname, pvp->pv_desc.dtvd_name);
 
-if (fprintf(out, ""#if _DTRACE_VERSION\n\n"") < 0)
+if (fprintf(out, ""#define _DTRACE_VERSION 1\n\n""
+ ""#if _DTRACE_VERSION\n\n"") < 0)
 return (dt_set_errno(dtp, errno));
 
 if (dt_idhash_iter(pvp->pv_probes, dt_header_probe, &info) != 0)
 int
 dtrace_program_header(dtrace_hdl_t *dtp, FILE *out, const char *fname)
 {
 dt_provider_t *pvp;
-char *mfname, *p;
+char *mfname = NULL, *p;
 
 if (fname != NULL) {
 if ((p = strrchr(fname, '/')) != NULL)
",449,112
"Fix rd_event callbacks of exec()ing processes.

If a process exec()ed and had the rd_event callback enabled, the callback should
be called when the rd_start_trap is hit, since that is the first time the
complete set of DT_NEEDED libraries is visible: the dynamic linker has, in
effect, dlopen()ed them. We were not triggering the callback in this particular
case."," rd_start_trap(uintptr_t addr, void *rd_data)
 /*
  * Reactivate the rd_monitoring breakpoint, if it should be active (e.g.
  * if it was active before an exec()). Silently disable monitoring if
- * we cannot reactivate the breakpoint.
+ * we cannot reactivate the breakpoint. Automatically trigger a
+ * dlopen() callback.
  */
-if (rd->rd_monitoring)
+if (rd->rd_monitoring) {
 if (Pbkpt(rd->P, rd->r_brk_addr, FALSE, rd_brk_trap,
 NULL, rd) != 0)
 rd->rd_monitoring = FALSE;
+else {
+rd_event_msg_t msg;
+msg.type = RD_DLACTIVITY;
+msg.state = RD_CONSISTENT;
+
+_dprintf(""%i: initial rtld activity event fired.\n"",
+ rd->P->pid);
+rd->rd_event_fun(rd, &msg, rd->rd_event_data);
+}
+}
 
 rd->maps_ready = 1;
 
",745,206
"Temporarily disable use of dtrace_ioctl_sizes().

Due to the need to remove the function definition for dtrace_ioctl_sizes() from
ioctl.h to ensure that the header file (and dtrace.h) can be used in other
code, this call had to be disabled. If/when a new location for the function
is provided, this can be re-enabled."," alloc:
  dt_cpp_add_arg(dtp, utsdef) == NULL)
 return (set_open_errno(dtp, errp, EDT_NOMEM));
 
+#if 0
 dtrace_ioctl_sizes();
+#endif
 
 if (flags & DTRACE_O_NODEV)
 bcopy(&_dtrace_conf, &dtp->dt_conf, sizeof (_dtrace_conf));
",980,127
"Handle 32-vs-64 bit correctly for dtrace -G, build 32-bit drti.o, cleanup, better tmp dir names

The dtrace command will now correctly (when possible) determine whether the
user is trying to invoke dtrace -G on 32-bit or 64-bit objects. and generate
the DOF ELF object accordingly, and use the appropriate DRTI object.

Added cleanup for provider .h files for triggers.

Changes the tst.provregex?.sh tests to use a more clear directory name for its
temporary directory (useful when a tests fails and we need to look at the
temporary files in there)."," static int g_impatient;
 static int g_newline;
 static int g_total;
 static int g_cflags;
-static int g_oflags = DTRACE_O_LP64;
+static int g_oflags = 0;
 static int g_verbose;
 static int g_exec = 1;
 static int g_mode = DMODE_EXEC;
",1304,324
"Fix symbol lookup where the first symbol found is undefined.

In this situation, Pxlookup_by_name() is meant to return the defined symbol, but
instead it is returning the first symbol found, even if that was an undefined one.

We should overwrite the output symbol not only if no overwrite has ever happened
before but also if the last time we overwrite it we overwrite it with an
undefined symbol."," Pxlookup_by_name_internal(
 if (sym.st_shndx != SHN_UNDEF)
 return (0);
 
-if (rv != 0) {
+if (rv != 0 ||
+ sym.st_shndx == SHN_UNDEF) {
 if (sip != NULL)
 si = *sip;
 sym = *symp;
",1307,341
"Demote some strange-ELF-file stderr fprintfs to debugging output.

If the auxvec is missing some fields or the process died before we tried to look
up its r_debug, we were spraying output onto stderr. These are both things the
user cannot reasonably do anything about, and we proceed without much trouble in
any case (losing only symbol resolution and evaltime support), so demote both to
debugging output."," BITIZE(r_debug)(struct ps_prochandle *P)
 uint64_t i;
 
 if ((phaddr == -1) || (phent == -1) || (phnum == -1)) {
-fprintf(stderr, ""%i: no phaddr, phent or phnum auxvec ""
- ""entry.\n"", P->pid);
+_dprintf(""%i: no phaddr, phent or phnum auxvec entry.\n"",
+ P->pid);
 return -1;
 }
 
 if (P->state == PS_DEAD) {
-fprintf(stderr, ""%i: process is dead."", P->pid);
+_dprintf(""%i: process is dead."", P->pid);
 return -1;
 }
 
",82,17
"Fix spurious invalid option error when running the testsuite.

The sense of the comparison in the debugassert option initialization code was
inverted, leading to a spurious error whenever it was turned on (which only the
testsuite does)."," dt_opt_debug_assert(dtrace_hdl_t *dtp, const char *arg, uintptr_t option)
 if (arg == NULL)
 return (dt_set_errno(dtp, EDT_BADOPTVAL));
 
-if (!strcmp(arg, ""mutexes"") == 0)
+if (strcmp(arg, ""mutexes"") == 0)
 _dtrace_debug_assert |= DT_DEBUG_MUTEXES;
 else
 return (dt_set_errno(dtp, EDT_BADOPTVAL));
",834,203
"Add Pdynamically_linked().

This libproc function returns true if the process is dynamically linked.
(libproc has tracked this for some time, but had no way to tell the rest of
DTrace about it.)"," Pmemfd(struct ps_prochandle *P)
 return (P->memfd);
 }
 
+/*
+ * Return 1 if the process is dynamically linked.
+ */
+int
+Pdynamically_linked(struct ps_prochandle *P)
+{
+/*
+ * This is populated by the r_debug computation code, so call it now,
+ * and fail if it fails.
+ */
+if (r_debug(P) < 0)
+return -1;
+
+return !P->no_dyn;
+}
+
 /*
 * Release the process. If kill_it is set, kill the process instead.
 *
",1125,250
"Set the default value of the evaltime option to postinit.

USDT depends on constructor execution, which must happen before DTrace
rendezvouses and starts tracing. In Solaris, the default evaltime of preinit
suffices for this, becuase preinit on Solaris runs after constructors, but
before #pragma init. On Linux, preinit runs *before* constructors (but after
dynamic linker initialization). So we must set the default to postinit or main,
which is now practical since these should now work fairly reliably for the
majority of processes."," alloc:
 
 bzero(dtp, sizeof (dtrace_hdl_t));
 dtp->dt_oflags = flags;
-dtp->dt_prcmode = DT_PROC_STOP_PREINIT;
+dtp->dt_prcmode = DT_PROC_STOP_POSTINIT;
 dtp->dt_linkmode = DT_LINK_KERNEL;
 dtp->dt_linktype = DT_LTYP_ELF;
 dtp->dt_xlatemode = DT_XL_STATIC;
",980,127
"Fix spurious double-breakpoint-removal bug.

rd_event_disable removes the r_brk breakpoint but does not reset the
rd_monitoring flag which indicates that this breakpoint is active. If this
happens on process shutdown, a spurious removal can happen, leading to
a (harmless) warning. If it were to happen at other times, a subsequent event
which needed to enable that breakpoint would fail to do so,
thinking (incorrectly) that it is already active.

Fix by resetting the flag."," rd_event_disable(rd_agent_t *rd)
 
 rd->rd_event_fun = NULL;
 rd->rd_event_data = NULL;
-if (rd->rd_monitoring && rd->no_inconsistent == 0)
+if (rd->rd_monitoring && rd->no_inconsistent == 0) {
 Punbkpt(rd->P, rd->r_brk_addr);
+rd->rd_monitoring = 0;
+}
 
 _dprintf(""%i: disabled rtld activity monitoring.\n"", rd->P->pid);
 }
",755,210
"Revert ""Temporarily disable use of dtrace_ioctl_sizes().""

This reverts commit b5b0d74b4ed49a5e146eeef044e68dc28cc04eca, and updates it to
the current <linux/dtrace/ioctl_debug.h> header.","
 #include <dt_string.h>
 #include <dt_provider.h>
 
+#include <linux/dtrace/ioctl_debug.h>
+
 /*
 * Stability and versioning definitions. These #defines are used in the tables
 * of identifiers below to fill in the attribute and version fields associated
 alloc:
  dt_cpp_add_arg(dtp, utsdef) == NULL)
 return (set_open_errno(dtp, errp, EDT_NOMEM));
 
-#if 0
 dtrace_ioctl_sizes();
-#endif
 
 if (flags & DTRACE_O_NODEV)
 bcopy(&_dtrace_conf, &dtp->dt_conf, sizeof (_dtrace_conf));
",981,126
"Do not print out any complaints about /dev/dtrace/helper unless debugging.

Messages are surpressed unless we're debugging DRTI. This seems prudent
because otherwise executables with DOF embedded will complain about not
being able to open /dev/dtrace/helper when started when DTrace is not loaded,
when started on systems without DTrace altogether, and when executed as
non-root on systems with DTrace enabled.

Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>"," dtrace_dof_init(void)
 devname = p;
 
 if ((fd = open(devname, O_RDWR)) < 0) {
-dprintf(1, ""DRTI: Failed to open helper device %s\n"", devname);
+if (dof_init_debug)
+dprintf(1, ""DRTI: Failed to open helper device %s\n"",
+devname);
 return;
 }
 
 dtrace_dof_fini(void)
 int fd;
 
 if ((fd = open(devname, O_RDWR)) < 0) {
-dprintf(1, ""DRTI: Failed to open helper device %s\n"", devname);
+if (dof_init_debug)
+dprintf(1, ""DRTI: Failed to open helper device %s\n"",
+devname);
 return;
 }
 
",127,33
"Mark relocations for function entry addresses in DOF correctly.

The code generating the DOF ELF object was marking relocations for function
entry addresses using the R_X86_64_64 type, which works fine for executables,
but not for shared libraries. Setting the type to R_X86_64_GLOB_DAT works for
both because it ensures that the relocation is resolved in both cases as the
absolute offset from the load address. The DTrace core handles further
relocation based on the load address of the executable and/or library when the
DOF is loaded through the helper interface.

Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>"," prepare_elf64(dtrace_hdl_t *dtp, const dof_hdr_t *dof, dof_elf64_t *dep)
 rel->r_offset = s->dofs_offset +
  dofr[j].dofr_offset;
 rel->r_info = ELF64_R_INFO(count + dep->de_global,
- R_X86_64_64);
+ R_X86_64_GLOB_DAT);
 #elif defined(__sparc)
 rel->r_offset = s->dofs_offset +
  dofr[j].dofr_offset;
",1067,225
"New tests to verify retrieval of arg5 through arg9.

Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>","
 
 #pragma ident""%Z%%M%%I%%E% SMI""
 
-#include <sys/sdt.h>
+#include ""usdt-tst-args-prov.h""
 
 int
 main(int argc, char **argv)
 {
 for (;;) {
-DTRACE_PROBE2(test_prov, place, 10, 4);
+TEST_PROV_PLACE(10, 4, 20, 30, 40, 50, 60, 70, 80, 90);
 }
 
 return (0);
",9,2
"Avoid directly locking the dpr_lock.

The dpr_lock must only be locked by dt_proc_*lock(), and unlocked by
dt_proc_*unlock(), so that the lock count and ownership can be properly
maintained. dt_pid.c was violating this rule, leading to a recursive-lock-
induced hang immediately afterwards.

Orabug: 17442388
Signed-off-by: Nick Alcock <nick.alcock@oracle.com>"," dt_pid_create_probes(dtrace_probedesc_t *pdp, dtrace_hdl_t *dtp, dt_pcb_t *pcb)
 
 dpr = dt_proc_lookup(dtp, P, 0);
 assert(dpr != NULL);
-(void) pthread_mutex_lock(&dpr->dpr_lock);
+dt_proc_lock(dtp, dpr->dpr_proc);
 
 if ((err = dt_pid_create_pid_probes(pdp, dtp, pcb, dpr)) == 0) {
 /*
 dt_pid_create_probes(dtrace_probedesc_t *pdp, dtrace_hdl_t *dtp, dt_pcb_t *pcb)
 (void) dt_ioctl(dtp, DTRACEIOC_ENABLE, NULL);
 }
 
-(void) pthread_mutex_unlock(&dpr->dpr_lock);
+dt_proc_unlock(dtp, dpr->dpr_proc);
 dt_proc_release(dtp, P);
 }
 
 dt_pid_create_probes(dtrace_probedesc_t *pdp, dtrace_hdl_t *dtp, dt_pcb_t *pcb)
 
 dpr = dt_proc_lookup(dtp, P, 0);
 assert(dpr != NULL);
-(void) pthread_mutex_lock(&dpr->dpr_lock);
+dt_proc_lock(dtp, dpr->dpr_proc);
 
 if (!dpr->dpr_usdt) {
 err = dt_pid_create_usdt_probes(pdp, dtp, pcb, dpr);
 dpr->dpr_usdt = B_TRUE;
 }
 
-(void) pthread_mutex_unlock(&dpr->dpr_lock);
+dt_proc_unlock(dtp, dpr->dpr_proc);
 dt_proc_release(dtp, P);
 }
 
",525,124
"Ensure .SUNW_dof has visiblity hidden.

Orabug: 17476663

Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>"," prepare_elf32(dtrace_hdl_t *dtp, const dof_hdr_t *dof, dof_elf32_t *dep)
 sym->st_value = 0;
 sym->st_size = dof->dofh_filesz;
 sym->st_info = ELF32_ST_INFO(STB_GLOBAL, STT_OBJECT);
-sym->st_other = 0;
+sym->st_other = ELF32_ST_VISIBILITY(STV_HIDDEN);
 sym->st_shndx = ESHDR_DOF;
 sym++;
 
 prepare_elf64(dtrace_hdl_t *dtp, const dof_hdr_t *dof, dof_elf64_t *dep)
 sym->st_value = 0;
 sym->st_size = dof->dofh_filesz;
 sym->st_info = GELF_ST_INFO(STB_GLOBAL, STT_OBJECT);
-sym->st_other = 0;
+sym->st_other = ELF64_ST_VISIBILITY(STV_HIDDEN);
 sym->st_shndx = ESHDR_DOF;
 sym++;
 
",1067,225
"Do not leak the path to /proc.

We were strdup()ping this path, then never freeing it again. Since we were
doing nothing with it other than passing it immediately down to libproc, it is
simpler just to not bother to store it outside /proc at all, removing the
strdup()s and the associated memory leak."," alloc:
 dtp->dt_cpp_argc = 1;
 dtp->dt_cpp_args = 1;
 dtp->dt_ld_path = strdup(_dtrace_defld);
-dtp->dt_procfs_path = strdup(_dtrace_defproc);
-Pset_procfs_path(dtp->dt_procfs_path);
+Pset_procfs_path(_dtrace_defproc);
 dtp->dt_provmod = provmod;
 dtp->dt_vector = vector;
 dtp->dt_varg = arg;
",980,126
"Free the dt_module_path on dtrace_close().

We were leaking it."," dtrace_close(dtrace_hdl_t *dtp)
 
 elf_end(dtp->dt_ctf_elf);
 free(dtp->dt_mods);
+free(dtp->dt_module_path);
 free(dtp->dt_kernpaths);
 free(dtp->dt_provs);
 free(dtp);
",981,126
"Close the kernel-module-locating fts handle on non-error return.

We were carefully closing it on all error paths, then leaking it on success."," dt_kern_path_update(dtrace_hdl_t *dtp)
 return error;
 }
 
+fts_close(ftp);
 return 0;
 }
 
",1263,304
"Do not leak the libelf handle to ctf.ko.

This module is shared between dt_module instances, so we have to
refcount it so that it's only freed when the last instance goes
away. (But libelf stores a *lot* of state, hundreds of KiB per ELF
object if mmap is turned off, as it currently must be due to libelf bugs
fixed upstream: so this is very much worthwhile.)"," dt_module_init_elf(dtrace_hdl_t *dtp, dt_module_t *dmp)
  (dtp->dt_ctf_elf != NULL)) {
 dmp->dm_elf = dtp->dt_ctf_elf;
 dmp->dm_ops = dtp->dt_ctf_ops;
+dtp->dt_ctf_elf_ref++;
 return 0;
 }
 
 dt_module_init_elf(dtrace_hdl_t *dtp, dt_module_t *dmp)
 if (dmp->dm_flags & DT_DM_BUILTIN) {
 dtp->dt_ctf_elf = dmp->dm_elf;
 dtp->dt_ctf_ops = dmp->dm_ops;
+dtp->dt_ctf_elf_ref++;
 }
 
 return 0;
 dt_module_unload(dtrace_hdl_t *dtp, dt_module_t *dmp)
 
 /*
  * Built-in modules may be sharing their libelf handle with other
- * modules, so should not close it.
+ * modules, so should not close it until its refcount falls to zero.
  */
-if (!(dmp->dm_flags | DT_DM_BUILTIN))
+if (dmp->dm_flags & DT_DM_BUILTIN) {
+if (--dtp->dt_ctf_elf_ref == 0) {
+elf_end(dtp->dt_ctf_elf);
+dtp->dt_ctf_elf = NULL;
+}
+} else
 elf_end(dmp->dm_elf);
 dmp->dm_elf = NULL;
 
",1270,305
"Assign the compressed CTF data to the right place.

When I introduced transparent CTF uncompression, I added a field in the
dt_module to hold the uncompressed content of the CTF... and then assigned the
uncompressed CTF to the *other* field, holding the CTF's name, leaking it.

This only went unnoticed because no use is made of that field after this point."," dt_module_load(dtrace_hdl_t *dtp, dt_module_t *dmp)
  * The CTF section is often gzip-compressed. Uncompress it.
  */
 if (dmp->dm_ctdata.cts_size > 1)
-dmp->dm_ctdata_name = dt_ctf_uncompress(dmp, &dmp->dm_ctdata);
+dmp->dm_ctdata_data = dt_ctf_uncompress(dmp, &dmp->dm_ctdata);
 
 /*
  * Nothing more to do for loaded kernel modules: we already have their
",1270,305
"Fix use-after-free on Pcreate() error path.

When we fail to create a process, we must free it only after unlocking it,
not before."," bad_untrace:
 Puntrace(P, 0);
 bad:
 (void) kill(pid, SIGKILL);
-Pfree_internal(P);
 *perr = rc;
 if (ptrace_lock_hook)
 ptrace_lock_hook(P, P->wrap_arg, 0);
+Pfree_internal(P);
 return (NULL);
 }
 
",1140,260
"Check the right variable to detect stack read failure on x86-32.

On x86-32, we must read the stack to find the address of main(). We were
checking the wrong variable to check if that read had failed (which is highly
unlikely, but still). This could have led to spurious failure if the random
garbage in this variable happened to look like a negative number."," Pread_first_arg_x86(struct ps_prochandle *P)
 stackaddr = wrapped_ptrace(P, PTRACE_PEEKUSER, P->pid,
  RSP * sizeof (long));
 
-if ((errno == ESRCH) || (addr < 0))
+if ((errno == ESRCH) || (stackaddr < 0))
 return (uintptr_t) -1;
-
+
 stackaddr += 4; /* 32-bit Linux x86's sizeof (long), stack grows down */
 if (Pread_scalar(P, &addr, 4, sizeof(addr), stackaddr) < 0)
 return (uintptr_t) -1;
",34,11
"Initialize the number of PID probe symbol matches to zero.

This is checked whether or not any symbols are necessarily found, but only
initialized when some are found. (The check is an equality comparison, so this
will only cause misbehaviour if you are very unlucky.)"," dt_pid_create_pid_probes(dtrace_probedesc_t *pdp, dtrace_hdl_t *dtp,
 pp.dpp_dpr = dpr;
 pp.dpp_pr = dpr->dpr_proc;
 pp.dpp_pcb = pcb;
+pp.dpp_nmatches = 0;
 
 /*
  * We can only trace dynamically-linked executables (since we've
",526,124
"Do not leak a dt_decl on prototype check failure.

dt_decl_func() allocates a declarator, checks the function's prototype, then
pushes the declarator onto the declarator stack. It is the only place in DTrace
that does not push a newly-allocated declarator immediately onto the declarator
stack, and it gets it wrong: the prototype checking can fail, longjmp()ing out
and leaking the declarator.

Since the newly-allocated declarator is not used by the prototype check, do the
prototype checking first, before allocating the declarator, then allocate and
chain it immediately."," dt_decl_array(dt_node_t *dnp)
 dt_decl_t *
 dt_decl_func(dt_decl_t *pdp, dt_node_t *dnp)
 {
-dt_decl_t *ddp = dt_decl_alloc(CTF_K_FUNCTION, NULL);
-
-ddp->dd_node = dnp;
+dt_decl_t *ddp;
 
 (void) dt_decl_prototype(dnp, dnp, ""function"",
  DT_DP_VARARGS | DT_DP_VOID | DT_DP_ANON);
 
+ddp = dt_decl_alloc(CTF_K_FUNCTION, NULL);
+ddp->dd_node = dnp;
+
 if (pdp == NULL || pdp->dd_kind != CTF_K_POINTER)
 return (dt_decl_push(ddp));
 
",758,216
"Do not leak the newly-allocated argv on error.

Since the error is fatal and we terminate anyway, this is not an important leak
at all, but it gets in the way of the zero-leak goal (and eventual automatic
verification of that state)."," main(int argc, char *argv[])
 fatal(""failed to allocate memory"");
 
 P = dtrace_proc_create(g_dtp, v[0], v, 0);
-if (P == NULL)
+if (P == NULL) {
+free(v);
 dfatal(NULL); /* dtrace_errmsg() only */
+}
 
 g_psv[g_psc++] = P;
 free(v);
",1306,324
"Free the scopes array after constructing symbol search list.

The comments at the top of rd_get_scope() and rd_get_loadobj_link_map() both say
that the scopes array is dynamically allocated and persists across calls. What
does its only caller do? That's right, it leaks it.

(Also fix said comments to get the name of the element to free right.)"," Pupdate_symsearch(struct ps_prochandle *P, struct file_info *fptr)
 
 fptr->file_symsearch[fptr->file_nsymsearch++] = mptr->map_file;
 }
+
+free(scope_lo.rl_scope);
 }
 
 /*
",1308,341
"Do not leak the dt_sprintf_buf.

This buffer in the dtrace_hdl is maintained by dtrace_sprintf(), but is
not freed by dtrace_close(), so the entire buffer is leaked whenever a
consumer exits."," dtrace_close(dtrace_hdl_t *dtp)
 free(dtp->dt_cpp_path);
 free(dtp->dt_ld_path);
 
+free(dtp->dt_sprintf_buf);
+
 elf_end(dtp->dt_ctf_elf);
 free(dtp->dt_mods);
 free(dtp->dt_module_path);
",982,126
"Avoid leaking a lot of file_info structures on every purge.

purge_file_info() walks through the file_info list attached to the
ps_prochandle, deleting each in turn. Unfortunately as a list counter it was
using P->num_files, which is decremented by the process of deletion, leading
to a number of file_infos not getting deleted at dtrace_close() time.

Fix trivial."," file_info_del(struct ps_prochandle *P, file_info_t *fptr)
 static void
 file_info_purge(struct ps_prochandle *P)
 {
-uint_t i;
+uint_t i, num_files = P->num_files;
 file_info_t *fptr;
 file_info_t *old_fptr = NULL;
 
 for (i = 0, fptr = dt_list_next(&P->file_list);
- i < P->num_files; i++, old_fptr = fptr,
+ i < num_files; i++, old_fptr = fptr,
  fptr = dt_list_next(fptr)) {
 if (old_fptr && old_fptr->file_ref == 0)
 file_info_del(P, old_fptr);
",1308,341
"Use O_CLOEXEC in drti's open of /proc/$pid/maps.

We do this via the nonstandard glibc fopen() mode 'e', which is present in all
glibc's we care about (introduced in glibc 2.7).

This makes our /proc/$pid/maps fopen() safe in the presence of additional
concurrently-executing threads calling exec(), which is unlikely given our
constructor's priority but may still happen if this object is linked into a
shared library that is dlopen()ed later in a process's lifetime.

Jira: DTRACE-109"," dtrace_dof_init(void)
 lmid = 0;/* We need a way to determine this. */
 
 snprintf(mfn, sizeof(mfn), ""/proc/%d/maps"", getpid());
-if ((fp = fopen(mfn, ""r"")) == NULL) {
+if ((fp = fopen(mfn, ""re"")) == NULL) {
 dprintf(1, ""DRTI: Failed to open maps file.\n"");
 goto out;
 }
 dtrace_dof_fini(void)
 {
 int fd;
 
-if ((fd = open(devname, O_RDWR)) < 0) {
+if ((fd = open(devname, O_RDWR | O_CLOEXEC)) < 0) {
 if (dof_init_debug)
 dprintf(1, ""DRTI: Failed to open helper device %s\n"",
 devname);
",128,33
"Fix fd leaks.

We were leaking the executable file descriptor in two cases:

 - in the fairly rare case that a recursive Pbuild_file_symtab() triggered
 initialization of the file_info object, we were re-fetching (and re-dupping)
 the mapfd, then returning without closing it

 - much more seriously, whenever we read in the ELF class from the executable
 (to figure out whether to use 32- or 64-bit libc data structures when doing
 rtld_db monitoring), we were failing to close the fd to the executable again.
 So every single ustack(), usym() or umod() of a new process leaked one fd.

Fix a bit of misindentation at the same time."," Pbuild_file_symtab(struct ps_prochandle *P, file_info_t *fptr)
 
 fptr->file_init = 0;
 Puntrace(P, p_state);
-if (fptr->file_init == 1)
+if (fptr->file_init == 1) {
+close(fd);
 return;
+}
 fptr->file_init = 1;
 } else {
 struct stat s;
",1326,349
"Use the tgid, not the pid, when grabbing processes for ustack() et al.

Our libproc implementation does not know how to grab non-thread-group-leaders:
the kernel has just been taught to pass down the thread group ID to us, so
use it.

This affects ustack, usym, umod, and uaddr on the kernel and userspace side, and
ucaller on the kernel side only.

Orabug: 18412802"," dt_aggregate_quantizedcmp(int64_t *lhs, int64_t *rhs)
 static void
 dt_aggregate_usym(dtrace_hdl_t *dtp, uint64_t *data)
 {
-uint64_t pid = data[0];
-uint64_t *pc = &data[1];
+uint64_t tgid = data[1];
+uint64_t *pc = &data[2];
 struct ps_prochandle *P;
 GElf_Sym sym;
 
 if (dtp->dt_vector != NULL)
 return;
 
-if ((P = dt_proc_grab(dtp, pid, DTRACE_PROC_WAITING |
+if ((P = dt_proc_grab(dtp, tgid, DTRACE_PROC_WAITING |
  DTRACE_PROC_NONINVASIVE)) == NULL)
 return;
 
 dt_aggregate_usym(dtrace_hdl_t *dtp, uint64_t *data)
 static void
 dt_aggregate_umod(dtrace_hdl_t *dtp, uint64_t *data)
 {
-uint64_t pid = data[0];
-uint64_t *pc = &data[1];
+uint64_t tgid = data[1];
+uint64_t *pc = &data[2];
 struct ps_prochandle *P;
 const prmap_t *map;
 
 if (dtp->dt_vector != NULL)
 return;
 
-if ((P = dt_proc_grab(dtp, pid, DTRACE_PROC_WAITING |
+if ((P = dt_proc_grab(dtp, tgid, DTRACE_PROC_WAITING |
  DTRACE_PROC_NONINVASIVE)) == NULL)
 return;
 
",1210,289
"Rename DTRACE_PROC_NONINVASIVE to DTRACE_PROC_SHORTLIVED.

This flag is badly-named. It's not a signal that 'this is to be a noninvasive
grab': that's merely the effect it currently has. It's a signal that 'this grab
is short-lived: sacrifice accuracy if you wish'. i.e., it's the grab you can
use if you know that the process won't be grabbed long enough for anyone to care
about the fact that you can't pick up dlopen()s as they happen.

This will be important soon, when this flag will also mean 'this process can
lose its ptrace(), if any, as it ages in the cache after release.'"," dt_aggregate_usym(dtrace_hdl_t *dtp, uint64_t *data)
 return;
 
 if ((P = dt_proc_grab(dtp, tgid, DTRACE_PROC_WAITING |
- DTRACE_PROC_NONINVASIVE)) == NULL)
+ DTRACE_PROC_SHORTLIVED)) == NULL)
 return;
 
 dt_proc_lock(dtp, P);
 dt_aggregate_umod(dtrace_hdl_t *dtp, uint64_t *data)
 return;
 
 if ((P = dt_proc_grab(dtp, tgid, DTRACE_PROC_WAITING |
- DTRACE_PROC_NONINVASIVE)) == NULL)
+ DTRACE_PROC_SHORTLIVED)) == NULL)
 return;
 
 dt_proc_lock(dtp, P);
",1210,289
"Fix pointlessly worrying debug message.

The debug message emitted when dtrace attempts to Pgrab() a process that
vanishes before it can be grabbed is unnecessarily disturbing. DTrace is not
exiting, only the Pgrab() function is."," dt_proc_grab(dtrace_hdl_t *dtp, pid_t pid, int flags)
  * threads to check the same process time and again.
  */
 if (!Pexists(pid)) {
-dt_dprintf(""Pgrab(%d): Process does not exist, early exit\n"",
+dt_dprintf(""Pgrab(%d): Process does not exist, cannot grab\n"",
  pid);
 return NULL;
 }
",898,179
"No longer reference an uninitialized variable in an error message.

The code motion in 9d52138995c4e6e8df958d91f7a8321b6e0e3a8b moved an
error message in rd_new() that used rd->P above the point where rd
was allocated. It should use P directly.

Orabug: 18550863"," rd_new(struct ps_prochandle *P)
 r_debug_addr = r_debug(P);
 if (r_debug_addr == -1) {
 _dprintf(""%i: Cannot initialize rd_agent: no ""
- ""r_debug.\n"", rd->P->pid);
+ ""r_debug.\n"", P->pid);
 return (NULL);
 }
 
",885,239
"Improve error checking for undocumented _DTRACE_TESTING testing argument.

This sets the quietresize option without reporting if it fails."," main(int argc, char *argv[])
  */
 if (getenv(""_DTRACE_TESTING"") != NULL) {
 g_testing = 1;
-dtrace_setopt(g_dtp, ""quietresize"", 0);
+if (dtrace_setopt(g_dtp, ""quietresize"", 0) != 0)
+(void) fprintf(stderr, ""%s: cannot set quietresize for ""
+ ""testing"", g_pname);
 }
 
 /*
",1314,327
"Introduce Pelf64(); use it in userspace tracepointing code.

The dt_pid code attempts to differentiate between 64-bit and 32-bit
processes vai Pstatus()->pr_dmodel. This has not worked for a long
time and was only missed because it was wrapped in

Remove that #define and rewire to use the new Pelf64() instead, which consults
the internal elf64 flag, ultimately extracted from the ELF class in the ELF
header.

No visible effect (yet), since the pid provider is not yet ported."," dt_pid_per_mod(void *arg, const prmap_t *pmp, const char *obj)
  GELF_ST_INFO(STB_LOCAL, STT_FUNC);
 sym.st_other = 0;
 sym.st_value = 0;
-#ifdef USERSPACE_TRACEPOINTS
-sym.st_size = Pstatus(pp->dpp_pr.P)->pr_dmodel ==
- PR_MODEL_ILP32 ? -1U : -1ULL;
-#else
-sym.st_size = ~((Elf64_Xword) 0);
-#endif
+sym.st_size = Pelf64(pp->dpp_pr.P) ? -1ULL : -1U;
 } else if (!strisglob(pp->dpp_mod)) {
 return (dt_pid_error(dtp, pcb, dpr, NULL,
  D_PROC_FUNC,
",530,123
"Fix unbalanced Ptrace()/Puntrace()-detection code.

We maintain a count of Ptrace() calls not reversed by Puntrace() so that we can
avoid excess Puntrace() calls causing trouble, but Puntrace() never checks it."," Puntrace(struct ps_prochandle *P, int state)
 /*
  * Protect against unbalanced Ptrace()/Puntrace().
  */
-if ((!P->ptraced) || (state < 0))
+if ((!P->ptraced) || (P->ptrace_count == 0) || (state < 0))
 return;
 
 P->ptrace_count--;
",1298,292
"Fix sign-extension bug in breakpoint instruction poking.

We were using the wrong type for the original instruction, so poking it back
often set the upper word to all-bits-on, causing a later crash.

Orabug: 18674244"," static int
 bkpt_handle_post_singlestep(struct ps_prochandle *P, bkpt_t *bkpt)
 {
 int state = PS_RUN;
-int orig_insn;
+unsigned long orig_insn;
 
 if (bkpt->after_singlestep) {
 bkpt_handler_t *notifier = dt_list_next(&bkpt->bkpt_notifiers);
",1307,292
"Fix a place where rtld_db was taken by surprise if a process died.

This is a very narrow race and is highly unlikely ever to be hit in practice.

Identified by code inspection."," rd_ldso_nonzero_lmid_consistent_begin(rd_agent_t *rd)
 
 /*
  * Stop the process while we check the state of the load lock.
+ * If it dies before this, fail.
  */
 rd->lmid_halt_prev_state = Ptrace(rd->P, 1);
+if (rd->lmid_halt_prev_state == PS_DEAD)
+return -1;
 
 if ((lock_count = load_lock(rd)) < 0) {
 _dprintf(""%i: Cannot read load lock count\n"",
",875,238
"Stop reporting rd_loadobj_iter() errors in the libproc-consistency test.

There are an uncertain and possibly very large number of them depending on the
degree of synchronization between dtrace and the victim process. Don't flood the
log."," int main(int argc, char *argv[])
  * breakpoint handlers. Bugs relating to a failure to latch a
  * consistent state tend to be signalled by a hang inside
  * rd_ldso_consistent_begin(), which is exposed as rd_loadobj_iter()
- * taking far too long.
+ * taking far too long. Ignore simple rd_loadobj_iter() errors -- these
+ * are probably just a sign of lag synchronizing a dying tracee with
+ * this testcase: dtrace will have no problem with that.
  */
 while (Pstate(P) != PS_DEAD) {
 struct timeval a, b;
 gettimeofday(&a, NULL);
-if (rd_loadobj_iter(rd, print_ldd, P) == RD_ERR)
-fprintf(stderr, ""rd_loadobj_iter() returned error\n"");
+rd_loadobj_iter(rd, print_ldd, P);
 gettimeofday(&b, NULL);
 if (b.tv_sec - 2 > a.tv_sec) {
 fprintf(stderr, ""rd_loadobj_iter took implausibly ""
",141,33
"Add epoch counter (in seconds) to DTRACE_DEBUG output.

If dtrace has paused for ages during its run, this lets you tell what it was
doing when that happened.","
 #include <string.h>
 #include <signal.h>
 #include <dt_impl.h>
+#include <time.h>
 
 /*
 * These things do not go into the dtrace_hdl both because dt_dprintf doesn't
 dt_debug_printf(const char *subsys, const char *format, va_list alist)
 return;
 
 if (!ring) {
-fprintf(stderr, ""%s DEBUG: "", subsys);
+fprintf(stderr, ""%s DEBUG %i: "", subsys, time(NULL));
 vfprintf(stderr, format, alist);
 } else {
 va_list on_err;
 size_t new_ring_end;
 
 errno = 0;
-fprintf(ring_fd, ""%s DEBUG: "", subsys);
+fprintf(ring_fd, ""%s DEBUG: %i: "", subsys, time(NULL));
 if (errno == ENOSPC) {
 rewind(ring_fd);
-fprintf(ring_fd, ""%s DEBUG: "", subsys);
+fprintf(ring_fd, ""%s DEBUG: %i: "", subsys, time(NULL));
 }
 
 va_copy(on_err, alist);
",121,25
"Warning police and drop some expensive and redundant debugging output.

This is detritus from the recent proxying changes. Fix trivial."," dt_debug_printf(const char *subsys, const char *format, va_list alist)
 return;
 
 if (!ring) {
-fprintf(stderr, ""%s DEBUG %i: "", subsys, time(NULL));
+fprintf(stderr, ""%s DEBUG %li: "", subsys, time(NULL));
 vfprintf(stderr, format, alist);
 } else {
 va_list on_err;
 size_t new_ring_end;
 
 errno = 0;
-fprintf(ring_fd, ""%s DEBUG: %i: "", subsys, time(NULL));
+fprintf(ring_fd, ""%s DEBUG: %li: "", subsys, time(NULL));
 if (errno == ENOSPC) {
 rewind(ring_fd);
-fprintf(ring_fd, ""%s DEBUG: %i: "", subsys, time(NULL));
+fprintf(ring_fd, ""%s DEBUG: %li: "", subsys, time(NULL));
 }
 
 va_copy(on_err, alist);
",121,25
"Prevent Pstate(NULL) from dumping core.

Pstate() should be like free(): if it's called on something which is clearly
dead, it should say so. A null pointer, being freed, is clearly dead."," Phasfds(struct ps_prochandle *P)
 int
 Pstate(struct ps_prochandle *P)
 {
+/*
+ * Act like free() with respect to null pointers: a null pointer is dead,
+ * by definition.
+ */
+if (P == NULL)
+return PS_DEAD;
+
 return (P->state);
 }
 
",1313,295
"Fix a missing assignment causing double-free().

If an exec() is detected after doing a rd_loadobj_iter() while removing the
dynamic linker consistency-enforcement breakpoints, we will already have
free()d the primary_scope and rl_scope arrays -- but upon a detected exec()
will will free() them again, causing a double-free(). The fix is to annul
them on freeing them the first time.

Orabug: 19046684"," rd_loadobj_iter(rd_agent_t *rd, rl_iter_f *fun, void *state)
 unsigned int nloaded = 0;
 unsigned int n = 0;
 
-primary_scope = NULL;
-
 if (!nonzero_consistent && nns > 1) {
 nonzero_consistent = TRUE;
 if (rd_ldso_nonzero_lmid_consistent_begin(rd) < 0)
 rd_loadobj_iter(rd_agent_t *rd, rl_iter_f *fun, void *state)
 loadobj = (uintptr_t) map.l_next;
 }
 
+/*
+ * The assignments to NULL below are crucial -- we could spot an
+ * exec() after this point, and longjmp() into spotted_exec:,
+ * which free()s them again.
+ */
+
 free(primary_scope);
+primary_scope = NULL;
 }
 
 free(obj.rl_scope);
+obj.rl_scope = NULL;
+
 if (nonzero_consistent)
 rd_ldso_nonzero_lmid_consistent_end(rd);
 rd_ldso_consistent_end(rd);
",876,238
"Temporarily drop all non-breakpoint SIGTRAPs from victim processes.

Handling intentional SIGTRAPs requires libproc to do multithreaded tracing to
recognize breakpoint hits in other threads. This change reverts to the
hack used in prior releases, which dropped such SIGTRAPs instead.

XFAIL tests/unittest/proc/tst.signals.sh, which tests for proper handling of
all signals, including SIGTRAP."," Pwait_handle_waitpid(struct ps_prochandle *P, int status)
 
 if ((ip < 0) || (!bkpt)) {
 /*
- * This is not a known breakpoint. Pass it on.
+ * This is not a known breakpoint. Drop it (pro tem).
  */
-_dprintf(""Pwait: %i: process status change: SIGTRAP ""
- ""passed on: status %x\n"", P->pid, status);
+_dprintf(""Pwait: %i: process status change at ""
+ ""address %lx: SIGTRAP does not correspond to a ""
+ ""known breakpoint, process resumed.\n"", P->pid,
+ip);
 wrapped_ptrace(P, PTRACE_CONT, P->pid, NULL,
- SIGTRAP);
+ 0);
 return(0);
 }
 }
",1315,295
"Add missing checks for out-of-memory conditions.

A few places were simply failing to check entirely, leading to a certain
coredump if the memory allocator returned NULL in those cases.

Orabug: 20014606"," static const char *default_module_root = ""/lib/modules/"";
 static dtrace_hdl_t dt;
 static dtrace_hdl_t *dtp = &dt;
 
+
 /*
 * Override the dt_dprintf() in libdtrace with one that doesn't pull in half the
 * library, and emits errors as errors.
 find_module_ctf(const char *name)
 strcat(secname, name);
 }
 
+if (secname == NULL) {
+fprintf(stderr, ""Out of memory\n"");
+exit(1);
+}
+
 fp = load_sect(dkpp->dkp_path, secname);
 free(secname);
 return fp;
 main(int argc, char *argv[])
 dtp->dt_kernpaths = calloc(dtp->dt_kernpathbuckets, sizeof (dt_kern_path_t *));
 dtp->dt_module_path = strdup(modpath);
 
+if (dtp->dt_kernpaths == NULL ||
+ dtp->dt_module_path == NULL) {
+fprintf(stderr, ""Out of memory\n"");
+exit(1);
+}
+
 while (optind < argc)
 ctf_dump(argv[optind++]);
 
",219,46
"Fix realloc() OOM-associated problems.

There were several places where we were saying

foo = realloc(foo, ...)

which leaks memory if realloc() fails.

Fix a bit of indentation lack-of-tabdamage at the same time.

Orabug: 20014606"," static void *dt_ctf_uncompress(dt_module_t *dmp, ctf_sect_t *ctsp)
 }
 
 do {
+char *new_output;
 ret = inflate(&s, Z_NO_FLUSH);
 switch (ret) {
 case Z_STREAM_END:
 static void *dt_ctf_uncompress(dt_module_t *dmp, ctf_sect_t *ctsp)
 goto zerr;
 }
 
-output = realloc(output, out_size +
+new_output = realloc(output, out_size +
  (GZCHUNKSIZE - s.avail_out));
 
-if (output == NULL)
+if (new_output == NULL)
 goto oom;
+output = new_output;
 
 memcpy(output + out_size, out, (GZCHUNKSIZE - s.avail_out));
 out_size += (GZCHUNKSIZE - s.avail_out);
 static void *dt_ctf_uncompress(dt_module_t *dmp, ctf_sect_t *ctsp)
 
 zerr:
 inflateEnd(&s);
+free(output);
 dt_dprintf(""CTF decompression error in module %s: %s\n"", dmp->dm_name,
  s.msg);
 ctsp->cts_data = NULL;
",1168,285
"Fix dereference of null pointer on OOM.

We shouldn't write to ring[0] before checking if ring is NULL.

Orabug: 20014606"," _dtrace_debug_init(void)
 
 ring_size = size_mb * 1024 * 1024;
 ring = malloc(ring_size + 1);
-ring[0] = '\0';
 
 if (!ring) {
 dt_dprintf(""Out of memory allocating debug buffer of ""
 _dtrace_debug_init(void)
  size_mb);
 }
 
+ring[0] = '\0';
 ring_fd = fmemopen(ring, size_mb * 1024 * 1024, ""w"");
 setvbuf(ring_fd, NULL, _IONBF, 0);
 }
",121,25
"Fix tiny errno faults on process creation.

This fixes a couple of places where we experience (very unlikely) errors on
process creation, _dprintf() about them (smashing errno), and then pass the
smashed errno back to our caller.

Orabug: 20014606"," Pcreate(
 Pset_ptrace_wrapper(P, NULL);
 Pset_pwait_wrapper(P, NULL);
 if (pipe(forkblock) < 0) {
-_dprintf (""Pcreate: out of fds forking %s\n"", file);
-free(P);
 *perr = errno;
+_dprintf(""Pcreate: out of fds forking %s\n"", file);
+free(P);
 return (NULL);
 }
 
 Pcreate(
  * ptrace() the process with TRACEEXEC active, and unblock it.
  */
 if (wrapped_ptrace(P, PTRACE_SEIZE, pid, 0, PTRACE_O_TRACEEXEC) < 0) {
-_dprintf (""Pcreate: seize of %s failed: %s\n"", file,
- strerror(errno));
 rc = errno;
+_dprintf(""Pcreate: seize of %s failed: %s\n"", file,
+ strerror(errno));
 goto bad;
 }
 close(forkblock[1]);
",1322,297
"Only initialize the symbol table once.

Initializing it twice and error-checking the first instance only leaks memory.

Orabug: 20014606"," Pgrab(pid_t pid, int noninvasiveness, int already_ptraced, void *wrap_arg,
 if (Psym_init(P) < 0)
 goto bad;
 
-Psym_init(P);
 P->bkpts = calloc(BKPT_HASH_BUCKETS, sizeof (struct bkpt_t *));
 if (!P->bkpts)
 goto bad;
",1321,297
"SPARC support.

This is extremely provisional, may well not support 32-on-64 yet, probably won't
even compile, and *will* be rebased and/or adjusted accordingly.","
 #include <errno.h>
 #include <string.h>
 #include <libgen.h>
+#include <sys/ioctl.h>
 
 #include <dt_impl.h>
 #include <dt_pid.h>
+#include <port.h>
 
 #defineOP(x)((x) >> 30)
 #defineOP2(x)(((x) >> 22) & 0x07)
 dt_pid_create_return_probe(struct ps_prochandle *P, dtrace_hdl_t *dtp,
 while (text[i] == FASTTRAP_INSTR) {
 fasttrap_instr_query_t instr;
 
-instr.ftiq_pid = Pstatus(P)->pr_pid;
+instr.ftiq_pid = Pgetpid(P);
 instr.ftiq_pc = symp->st_value + i * 4;
 
 if (ioctl(dtp->dt_ftfd, FASTTRAPIOC_GETINSTR,
",216,50
"Commit changes to triggers.

These changes are necessary for the updated tests from previous commits
to actually work (tst.fds.d and begin.d). They were omitted by mistake
in the previous commits fot those tests.

Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>"," main(void)
  */
 if (sigsetjmp(env, 1) == 0) {
 for (;;)
+{
 (void) ioctl(-1, -1, NULL);
+usleep(100);
+}
 }
 
 /*
",50,6
"Add support for sparc64 to showUSDT.

Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>","
 #ifndef EM_AMD64
 # define EM_AMD6462
 #endif
+#ifndef EM_SPARC
+# define EM_SPARC2 
+#endif
+#ifndef EM_SPARCV9
+# define EM_SPARCV943 
+#endif
 #ifndef SHT_SUNW_dof
 # define SHT_SUNW_dof0x6ffffff4
 #endif
 static int readObj(const char *fn) {
 switch (ehdr.e_machine) {
 case EM_386:
 case EM_AMD64:
+case EM_SPARC:
+case EM_SPARCV9:
  arch = ehdr.e_machine;
  break;
 default:
",259,43
Fix bogus indentation in the bogus-ioctl trigger.," main(void)
  * ioctl() calls until DTrace hits us with a SIGUSR1 to start the test.
  */
 if (sigsetjmp(env, 1) == 0) {
-for (;;)
-{
+for (;;) {
 (void) ioctl(-1, -1, NULL);
-usleep(100);
-}
+ usleep(100);
+ }
 }
 
 /*
",49,6
"Fix merge error causing fd leak on every re-exec().

A crucial close() in Pread_isa_info() migrated into an error path, leading to us
leaking an fd to the executable on every re-exec()."," Pread_isa_info(struct ps_prochandle *P, const char *procname)
 close(fd);
 return -1;
 }
+close(fd);
 
 if (memcmp(&hdr, ELFMAG, SELFMAG) != 0) {
 _dprintf(""%s is not an ELF file\n"", procname);
-close(fd);
 return -1;
 }
 
",111,25
"Fix an errno niggle.

In Pbkpt_continue(), we were looking at an errno result from ptrace(), but quite
possibly after other things (e.g. kill()) had run and perhaps perturbed it. The
check was for a can-never-happen condition, but this is still a bug (among other
things, it's not good if a can-never-happen condition is believed to have
occurred when it in fact has not.)"," Pbkpt_continue(struct ps_prochandle *P)
  */
 if (P->tracing_bkpt == 0 || !bkpt) {
 if (wrapped_ptrace(P, PTRACE_CONT, P->pid, 0, 0) < 0) {
-if (errno == ESRCH) {
+int err = errno;
+if (err == ESRCH) {
 if ((kill(P->pid, 0) < 0) && errno == ESRCH)
 P->state = PS_DEAD;
 }
 Pbkpt_continue(struct ps_prochandle *P)
  * stopped: it cannot mean that we aren't allowed to
  * ptrace() it.
  */
-if (errno != EPERM) {
+if (err != EPERM) {
 _dprintf(""%i: Unexpected error resuming: %s\n"",
- P->pid, strerror(errno));
+ P->pid, strerror(err));
 return;
 }
 }
",1330,299
"Note that we do not have valid symbol table info on processes we detached from.

This is because they may have dlopen()ed or dlclose()d since we saw them
last."," Puntrace(struct ps_prochandle *P, int state)
  (errno == ESRCH))
 P->state = PS_DEAD;
 P->ptrace_halted = FALSE;
+P->info_valid = 0;
 }
 
 if (P->ptrace_count == 0 && ptrace_lock_hook)
",1331,299
"Fix Ptrace() error handling.

This function was defined to return a negative error code, or a positive state
value, but was actually returning a *positive* error code in some error paths,
which could both lead to callers missing error and to confusion between errors
and legitimate PS_* state enums."," Ptrace(struct ps_prochandle *P, int stopped)
 
 if ((P->state != PS_TRACESTOP) &&
  (P->state != PS_STOP)) {
-err = ECHILD;
+err = -ECHILD;
 goto err2;
 }
 }
 err2:
 if (P->ptrace_count == 0 && ptrace_lock_hook)
 ptrace_lock_hook(P, P->wrap_arg, 0);
 
-if (err != ECHILD)
+if (err != -ECHILD)
 return err;
 else
-return ESRCH; /* for a clearer message */
+return -ESRCH; /* for a clearer message */
 }
 
 /*
",1331,299
"Handle non-breakpoint-related SIGTRAPs in child processes again.

This was turned off in commit e7d3c448c22ae5470115abe5722f705156987dde because
we were being spuriously hit by SIGTRAPs in multithreaded processes. Now we
remove all things that might drop breakpoints in such processes, this is no
longer appropriate, and we can reinject them, after verifying that they are not
in fact breakpoint-related. (This also means that we can re-enable the test for
proper signal handling, which was being thrown off by the discarding of
SIGTRAP.)"," Pwait_handle_waitpid(struct ps_prochandle *P, int status)
 bkpt = bkpt_by_addr(P, ip, FALSE);
 
 if ((ip < 0) || !bkpt) {
+int sig = 0;
 /*
  * This is not a known breakpoint nor a temporary
- * singlestepping breakpoint. Drop it (pro tem).
+ * singlestepping breakpoint. Reinject it.
  */
 _dprintf(""Pwait: %i: process status change at ""
- ""address %lx: SIGTRAP does not correspond to a ""
- ""known breakpoint, process resumed.\n"", P->pid,
-ip);
-wrapped_ptrace(P, PTRACE_CONT, P->pid, NULL,
- 0);
+ ""address %lx: signal %i does not correspond to a ""
+ ""known breakpoint.\n"", P->pid, ip, WTERMSIG(status));
+
+if ((WIFSTOPPED(status)) && (WSTOPSIG(status)) == SIGTRAP)
+P->state = PS_STOP;
+
+if (((WIFSIGNALED(status)) && (WTERMSIG(status) == SIGTRAP)) ||
+ ((WIFSTOPPED(status)) && (WSTOPSIG(status)) == SIGTRAP))
+sig = SIGTRAP;
+
+wrapped_ptrace(P, PTRACE_CONT, P->pid, NULL, sig);
 return(0);
 }
 }
",1429,326
"Group-stop process state fix.

Processes under trace that have received stopping signals that have been
re-dispatched into the group-stop machinery should be considered running,
not stopped, until the group-stop is received. Without this, DTrace will
fail to put the process into trace-stop state if it needs to do so for
some other reason. (Seen as a failure to get the process's executable-
mapping fd in test/internals/libproc/tst.name-lookups.sh.)"," Pwait_handle_waitpid(struct ps_prochandle *P, int status)
 if (P->ptraced) {
 wrapped_ptrace(P, PTRACE_CONT, P->pid, NULL,
  WSTOPSIG(status));
+P->state = PS_RUN;
 }
 return(0);
 }
",1505,346
"Improved version-reporting infrastructure.

This introduces a new 'dtrace -vV' which causes dtrace to emit as much version
info as it can:

dtrace: Sun D 1.6.3
This is DTrace 0.4.6
dtrace(1) version-control ID: cc8ebd4cfd793242318b6b3b844ece5ef6d10b49
libdtrace version-control ID: cc8ebd4cfd793242318b6b3b844ece5ef6d10b49

The idea is that this is enough for us to tell exactly what the user is
running, rather than having to guess, as now.","
 */
 
 /*
- * Copyright (c) 2003, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2010 -- 2015 Oracle and/or its affiliates.
+ * All rights reserved.
 */
 
 #include <sys/types.h>

 #include <dt_string.h>
 #include <dt_provider.h>
 
+#include <dt_git_version.h>
+
 #include <linux/dtrace/ioctl_debug.h>
 
 /*
 size_t _dtrace_bufsize = 512;/* default dt_buf_create() size */
 int _dtrace_argmax = 32;/* default maximum number of probe arguments */
 
 const char *const _dtrace_version = DT_VERS_STRING; /* API version string */
+const char *const _libdtrace_vcs_version = DT_GIT_VERSION; /* Build version string */
 
 typedef struct dt_fdlist {
 int *df_fds;/* array of provider driver file descriptors */
",994,129
"Always look in test/triggers for triggers.

A number of tests had crept in which looked for triggers in build/. This works
in the source tree, but the forthcoming installed testsuite will have no build/
directory."," static void *churn(void *unused)
 
 dlerror();
 if (many_lmids && loaded[n] == NULL) {
-loaded[n] = dlmopen(lmids[n], ""build/libproc-dlmlib.so.0"", RTLD_NOW);
+loaded[n] = dlmopen(lmids[n], ""test/triggers/libproc-dlmlib.so.0"", RTLD_NOW);
 fprintf(stderr, ""opened in lmid %i: %p\n"", n, loaded[n]);
 }
 else
-non_dlm = dlopen(""build/libproc-dlmlib.so.0"", RTLD_NOW);
+non_dlm = dlopen(""test/triggers/libproc-dlmlib.so.0"", RTLD_NOW);
 if ((error = dlerror()) != NULL)
 fprintf(stderr, ""Error opening library: %s\n"",
  error);
",75,16
"Fix error on dtrace -p with an invalid PID.

We were failing to set the dtrace errno from the errno, or indeed set
the errno at all, on some error-exit paths when grabbing processes,
which meant that grabbing a nonexistent process produced a ridiculous
error message.

Fixed, and added testcase to prevent regression.

Orabug: 21974221"," dt_proc_create_thread(dtrace_hdl_t *dtp, dt_proc_t *dpr, uint_t stop,
  * monitored process is dead, note as much.
  */
 if (dpr->dpr_done)
-if (!dpr->dpr_proc)
+if (!dpr->dpr_proc) {
 err = ESRCH; /* cause grab() or create() to fail */
+dt_set_errno(dtp, err);
+}
 } else {
-(void) dt_proc_error(dpr->dpr_hdl, dpr,
+dt_proc_error(dpr->dpr_hdl, dpr,
  ""failed to create control thread for pid %d: %s\n"",
  (int)dpr->dpr_pid, strerror(err));
 }
 dt_ps_proc_grab(dtrace_hdl_t *dtp, pid_t pid, int flags)
 if (!Pexists(pid)) {
 dt_dprintf(""Pgrab(%d): Process does not exist, cannot grab\n"",
  pid);
+errno = ESRCH;
+dt_set_errno(dtp, errno);
 return NULL;
 }
-
+
 if ((dpr = dt_zalloc(dtp, sizeof (dt_proc_t))) == NULL)
 return (NULL); /* errno is set for us */
 
",1134,214
"Introduce Pget_proc_status(), and use it.

This lets us rapidly determine the value of a given line in
/proc/$pid/status for a given pid. It's only used in one place right
now but will be used in more shortly."," Phastty(int pid)
 free(buf);
 return (tty != 0);
 }
+
+/*
+ * Get a specific field out of /proc/$pid/status and return the portion after
+ * the colon in a new dynamically allocated string, or NULL if no field matches.
+ */
+char *
+Pget_proc_status(pid_t pid, const char *field)
+{
+char status[PATH_MAX];
+FILE *fp;
+char *line = NULL;
+size_t len;
+
+snprintf(status, sizeof(status), ""/proc/%i/status"", pid);
+
+if ((fp = fopen(status, ""r"")) == NULL) {
+_dprintf(""Process is dead.\n"");
+return NULL;
+}
+
+while (getline(&line, &len, fp) >= 0) {
+if ((strncmp(line, field, strlen(field)) == 0) &&
+ (strncmp(line + strlen(field), "":\t"", 2) == 0)) {
+
+memmove(line, line + strlen(field) + 2,
+ strlen(line + strlen(field) + 2) + 1);
+_dprintf(""%li: %s: %s"", (long) pid, status, line);
+fclose(fp);
+return line;
+}
+}
+free(line);
+fclose(fp);
+return NULL;
+}
",1531,351
Fix memory leak on a very unlikely error path.," Phastty(pid_t pid)
 }
 
 if (getline(&buf, &n, fp) < 0) {
+free(buf);
 fclose(fp);
 return -1;
 }
",1619,374
"Delete obsolescent EM_AMD64 constant.

This is spelled EM_X86_64 on all machines running a glibc newer than
2.2.2: it has never been spelled EM_AMD64 (except perhaps on Solaris).

While we're at it, delete the EM_* redeclarations in
test/utils/showUSDT.c: the youngest of these constants was added to
glibc in 1998, before the release of glibc 2.1. (glibcs older than
that didn't support sparcv9 anyway.)"," dump_elf64(dtrace_hdl_t *dtp, const dof_hdr_t *dof, int fd)
 #if defined(__sparc)
 elf_file.ehdr.e_machine = EM_SPARCV9;
 #elif defined(__i386) || defined(__amd64)
-elf_file.ehdr.e_machine = EM_AMD64;
+elf_file.ehdr.e_machine = EM_X86_64;
 #endif
 elf_file.ehdr.e_version = EV_CURRENT;
 elf_file.ehdr.e_shoff = sizeof (Elf64_Ehdr);
 process_obj(dtrace_hdl_t *dtp, const char *obj, int *eprobesp)
 #if defined(__sparc)
 emachine1 = emachine2 = EM_SPARCV9;
 #elif defined(__i386) || defined(__amd64)
-emachine1 = emachine2 = EM_AMD64;
+emachine1 = emachine2 = EM_X86_64;
 #endif
 symsize = sizeof (Elf64_Sym);
 }
",1083,225
"Drop struct prmap.pr_offset.

After the last commit we no longer need to keep track of this."," Pupdate_maps(struct ps_prochandle *P)
 
 pmptr->pr_vaddr = laddr;
 pmptr->pr_size = haddr - laddr;
- pmptr->pr_offset = offset;
 
 /*
  * Both ld.so and the kernel follow the rule that the first
",1382,370
"Prevent debugging output from differnt threads from being intermingled.

It is possible for debugging output to be intermingled if two threads
call dt_debug() at the same time. This leads to output looking like
this:

libdtrace DEBUG 1447698316: libproc DEBUG 1447698316: blah
blah

which the testsuite then interprets as one line of debugging output and
one line of output on stderr, leading to spurious test failures.

The fundamental flaw is that while fprintf() et al lock the stream
around a single call, we emit the debugging output in multiple calls, so
we need to explicitly lock the stream around those calls to prevent
intermingling."," dt_debug_printf(const char *subsys, const char *format, va_list alist)
 return;
 
 if (!ring) {
+flockfile(stderr);
 fprintf(stderr, ""%s DEBUG %li: "", subsys, time(NULL));
 vfprintf(stderr, format, alist);
+funlockfile(stderr);
 } else {
 va_list on_err;
 size_t new_ring_end;
 
+flockfile(ring_fd);
 errno = 0;
 fprintf(ring_fd, ""%s DEBUG: %li: "", subsys, time(NULL));
 if (errno == ENOSPC) {
 dt_debug_printf(const char *subsys, const char *format, va_list alist)
 ring_start = ring_end + 2; /* not +1, as that is '\0' */
 
 ring_end = new_ring_end;
+funlockfile(ring_fd);
 }
 }
 
",128,27
"Revised modules-location code.

Reading modules.order doesn't work very well if modules install things
under kernel/, as the dtrace modules package does. Instead, read
modules.dep: it's bigger, but that's not much of a problem if we boost
the libio buffer size for that file handle: the resulting code is
actually about 20% again faster than it was before, despite doing
33% more startup-time disk I/O.

We know modules.dep must always be present, complete, and readable for a
module to be usable at all, so we can rip out all the nftw()-related
code as well.

Orabug: 22237449
Orabug: 22238204"," static const struct {
 { EDT_CORRUPT_KALLSYMS, ""/proc/kallsyms corrupt, perhaps due to ""
  ""concurrent module unload"" },
 { EDT_ELFCLASS, ""Unknown ELF class, neither 32- nor 64-bit"" },
-{ EDT_OBJIO, ""Cannot read object file"" }
+{ EDT_OBJIO, ""Cannot read object file or modules.dep"" }
 };
 
 static const int _dt_nerr = sizeof (_dt_errlist) / sizeof (_dt_errlist[0]);
",174,25
"Change @@trigger to be synchronous by default.

Introduce a new @@trigger-timing value, 'synchro', which is now the
default. This causes @@trigger to invoke the trigger by passing
-c and then the trigger name to dtrace: as such, the execution is
now synchronous.

Adjust tests to either work this way or to specify @@trigger-timing:
adjust the mmap trigger to no longer engage in useless synchronization
that is now done for it by dtrace.","
 * CDDL HEADER END
 */
 /*
- * Copyright 2005, 2011 Oracle, Inc. All rights reserved.
+ * Copyright 2005, 2011, 2015 Oracle, Inc. All rights reserved.
 * Use is subject to license terms.
 */
 

 #include <unistd.h>
 #include <fcntl.h>
 #include <sys/mman.h>
-#include <sys/swap.h>
 
 #define NUMINTS (1000)
 #define FILESIZE (NUMINTS * sizeof(int))
 int main(int argc, char *argv[])
 int fd;
 int *map;
 
-/* First, tell the script to start monitoring. */
-
-swapoff(""/non/existent/path"");
-
 foo = tmpfile();
 if (foo == NULL) {
 exit(1);
",39,7
"Wire up waitfd() properly on sparc.

This was hardwired to an x86 syscall number.","
 
 #ifndef HAVE_WAITFD
 #include <unistd.h>/* for syscall() */
-#include <sys/syscall.h>/* for __NR_* */
-
-#ifndef __NR_waitfd
-#define __NR_waitfd 473
-#endif
+#include <platform.h>
 
 int
 waitfd(int which, pid_t upid, int options, int flags)
",8,1
"drti: handle addresses in the upper half of the address space

We were using strtol() to read /proc/$pid/maps addresses, which works
less than well if they're above LONG_MAX. Fix by using strtoul()
instead.

Also armour drti.c against a failure to find an address: this armour
existed already, but only in the commented out dlinfo() portion.

Orabug: 22384028","
 * CDDL HEADER END
 */
 /*
- * Copyright 2008, 2013 Oracle, Inc. All rights reserved.
+ * Copyright 2008, 2013, 2015 Oracle, Inc. All rights reserved.
 * Use is subject to license terms.
 */
 
 dtrace_dof_init(void)
 }
 
 #if 0
-if (dlinfo(RTLD_SELF, RTLD_DI_LINKMAP, &lmp) == -1 || lmp == NULL) {
+if (dlinfo(RTLD_SELF, RTLD_DI_LINKMAP, &lmp) == -1) {
 dprintf(2, ""DRTI: Couldn't discover module name or address.\n"");
 goto out;
 }
 dtrace_dof_init(void)
 uintptr_tstart, end;
 char*p = str, *q;
 
-start = strtol(p, &p, 16);
+start = strtoul(p, &p, 16);
 if (*p != '-')
 continue;
 
-end = strtol(++p, &p, 16);
+end = strtoul(++p, &p, 16);
 
 if (start > (uintptr_t)dtrace_dof_init ||
  (uintptr_t)dtrace_dof_init > end)
 dtrace_dof_init(void)
 }
 fclose(fp);
 #endif
+if (_dt_unlikely_(lmp == NULL)) {
+dprintf(2, ""DRTI: Couldn't discover module name or address.\n"");
+ goto out;
+}
 
 if ((modname = strrchr(lmp->l_name, '/')) == NULL)
 modname = lmp->l_name;
",132,33
"Note that we are in TRACESTOP state as soon as a trap is detected.

Pget_bpkt_ip() might well check our state to be sure we are not running:
keep the state up to date so it is not misled."," Pwait_handle_waitpid(struct ps_prochandle *P, int status)
  */
 
 ip = P->tracing_bkpt;
+P->state = PS_TRACESTOP;
 if (ip == 0) {
 bkpt_t *bkpt;
 ip = Pget_bkpt_ip(P, 0);
",1620,374
"Fix PTRACE_GETREGS* on Sparc.

We want to drop the regs into the regs structure, rather than scribbling
all over the pointer to it and the stack."," getregs_sparc64(struct ps_prochandle *P, struct pt_regs *regs)
  Pstate(P) == PS_DEAD)
 return NULL;
 
-if (wrapped_ptrace(P, PTRACE_GETREGS64, P->pid, &regs) < 0)
+if (wrapped_ptrace(P, PTRACE_GETREGS64, P->pid, regs) < 0)
 return NULL;
 
 return regs;
 getregs_sparc32(struct ps_prochandle *P, struct pt_regs32 *regs)
  Pstate(P) == PS_DEAD)
 return NULL;
 
-if (wrapped_ptrace(P, PTRACE_GETREGS, P->pid, &regs) < 0)
+if (wrapped_ptrace(P, PTRACE_GETREGS, P->pid, regs) < 0)
 return NULL;
 
 return regs;
",74,19
"Fix PTRACE_GETMAPFD argument.

Even though this is a file descriptor, it still has to be a 'long'
because it is written to via a ptrace() data argument, which expects
its argument to be a long."," Pbuild_file_symtab(struct ps_prochandle *P, file_info_t *fptr)
 
 GElf_Ehdr ehdr;
 
-int fd;
+long fd;
 Elf_Data *shdata;
 Elf_Scn *scn;
 Elf *elf = NULL;
",1382,370
"Fix unbalanced Ptrace().

Ptrace() works better if you ever remember to Puntrace() again."," Pread(struct ps_prochandle *P,
 
 memcpy(buf, rbuf + (address - saddr), nbyte);
 free(rbuf);
+Puntrace(P, state);
 
 return nbyte;
 }
",1653,380
"Fix idiotic iteration errors in new Pread() code.

sizeof(long) != 1 on most systems, it turns out, so foo[i] in an array
of long is not the same thing as it would be in an array of char..."," Pread(struct ps_prochandle *P,
 
 int state;
 uintptr_t saddr = (address & ~((uintptr_t) sizeof (long) - 1));
-size_t i;
+size_t i, sz;
 long *rbuf;
 
 size_t len = nbyte + (address - saddr);
-_dprintf(""Pread(%lx from %lx) -> reading %lx from %lx\n"",
- nbyte, address, len, saddr);
 
 rbuf = malloc(len);
 if (!rbuf)
 Pread(struct ps_prochandle *P,
 }
 
 errno = 0;
-for (i = 0; i < len; i += sizeof (long)) {
+for (i = 0, sz = 0; sz < len; i++, sz += sizeof (long)) {
 long data = wrapped_ptrace(P, PTRACE_PEEKDATA, P->pid,
- address + i, NULL);
+ address + sz, NULL);
 if (errno != 0)
 break;
 rbuf[i] = data;
 }
 
-nbyte = (i > len) ? len : i - (address - saddr);
-_dprintf(""Pread(%lx from %lx) -> copying %lx from offset of %lx\n"",
- saddr, len, nbyte, address - saddr);
+nbyte = (sz > len) ? len : sz - (address - saddr);
 
 memcpy(buf, rbuf + (address - saddr), nbyte);
 free(rbuf);
",1649,380
"Fix Pget_bkpt_ip() return value.

This function returns an arbitrary pointer, so in order to be able to
represent addresses in the upper half of the address space it must
return a uintptr_t, not a long. Two unlikely addresses remain
unrepresentable: zero (no breakpoint) and (uintptr_t)-1 (error).

All arch implementations already conform to this contract: all we need
to do is fix a few declarations."," Pwait_internal(struct ps_prochandle *P, boolean_t block)
 static int
 Pwait_handle_waitpid(struct ps_prochandle *P, int status)
 {
-long ip;
+uintptr_t ip;
 
 if (WIFCONTINUED(status)) {
 _dprintf(""%i: process got SIGCONT.\n"", P->pid);
 Pwait_handle_waitpid(struct ps_prochandle *P, int status)
 ip = Pget_bkpt_ip(P, 0);
 bkpt = bkpt_by_addr(P, ip, FALSE);
 
-if ((ip < 0) || !bkpt) {
+if (((unsigned long) ip == -1) || !bkpt) {
 int sig = 0;
 /*
  * This is not a known breakpoint nor a temporary
 void
 Pbkpt_continue(struct ps_prochandle *P)
 {
 bkpt_t *bkpt = bkpt_by_addr(P, P->tracing_bkpt, FALSE);
-long ip;
+uintptr_t ip;
 
 if (!P->ptraced)
 return;
",1649,380
Fix a couple of silly little debugging typos.," dt_break_prepare_drop_main(uintptr_t addr, void *dpr_data)
 dt_proc_t *dpr = dpr_data;
 int ret = -1;
 
-dt_dprintf(""pid %d: breakpoint on process start()\n"",
+dt_dprintf(""pid %d: breakpoint on process start\n"",
  (int)dpr->dpr_pid);
 
 Punbkpt(dpr->dpr_proc, addr);
",1154,225
"Remove a little dead code.

This survived the dtrace sleeping revamp despite the compiler warning
about it."," dtrace_sleep(dtrace_hdl_t *dtp)
  * Regardless of why we awaken, iterate over any pending notifications
  * and process them.
  */
-hrtime_t now = gethrtime();
 (void) pthread_cond_timedwait(&dph->dph_cv, &dph->dph_lock, &tv);
 
 while ((dprn = dph->dph_notify) != NULL) {
",180,57
"Fix no-waitfd() error message.

This was emitting strerror() of an error variable which was not updated
by the call it's reporting failure of, leading to spurious 'Success'
debugging output if waitfd() is not implemented in the kernel."," dt_proc_control(void *arg)
  */
 if ((dpr->dpr_fd = waitfd(P_PID, dpr->dpr_pid, WEXITED | WSTOPPED, 0)) < 0) {
 dt_proc_error(dtp, dpr, ""failed to get waitfd() for pid %li: %s\n"",
- (long) dpr->dpr_pid, strerror(err));
+ (long) dpr->dpr_pid, strerror(errno));
 /*
  * Demote this to a mandatorily noninvasive grab: if we
  * Pcreate()d it, dpr_created is still set, so it will still get
",1154,225
"Fix up OOM error-checking at Ptrace() time.

We were returning -ENOMEM without releasing the ptrace lock."," Ptrace(struct ps_prochandle *P, int stopped)
 P->ptrace_count++;
 state = Ppush_state(P, P->state);
 if (state == NULL) {
-P->ptrace_count--;
-return -ENOMEM;
+err = -ENOMEM;
+goto err2;
 }
 
 if (P->ptraced) {
",1649,380
"Speed up tests that use readwholedir() a little.

The readwholedir()-using tests are all slowed down by the fact
that readwholedir() sleeps before termination, to allow those
of its tests that call ustack() to catch up.

Speed them up by checking the executing test name, and sleeping only
when it contains 'ustack'."," main (void)
  * Reduce the testname to a path.
  */
 
-path = getenv(""_test"");
-chop = strrchr(path, '/');
+/*
+ * We leak 'path' without compunction.
+ */
+path = strdup(getenv(""_test""));
+ chop = strrchr(path, '/');
 *chop = '\0';
 
 if ((d = opendir(path)) == NULL) {
 main (void)
 /*
  * Let dtrace catch up, for ustack() tests that need a running process.
  */
-sleep(5);
+if (strstr(getenv(""_test""), ""ustack""))
+sleep(5);
 
 return 0;
 }
",104,18
New waitfd() syscall number and translator changes for Linux kernel 4.6.,"
 static struct waitfds_tag {
 unsigned long linux_version_code;
 long waitfd;
-} waitfds[] = { { KERNEL_VERSION(4,5,0), 358 },
+} waitfds[] = { { KERNEL_VERSION(4,6,0), 360 },
+{ KERNEL_VERSION(4,5,0), 358 },
 { KERNEL_VERSION(4,1,4), 351 },
 { 0, 0 } };
 
",31,6
"Don't repeatedly rescan for rtld-related changes if nothing has changed.

RD_CONSISTENT states can be reported by rtld_db for all sorts of reasons
other than dlopen()s and dlclose()s, particularly when multiple lmids
are in use. Save a bit of time by not rescanning for changes of state
unless we see an RD_CONSISTENT which follows an RD_ADD or RD_DELETE:
ignore multiple consecutive RD_CONSISTENTs completely."," dt_proc_rdevent(rd_agent_t *rd, rd_event_msg_t *msg, void *state)
 dt_dprintf(""pid %d: rtld event, type=%d state %d\n"",
  (int)dpr->dpr_pid, msg->type, msg->state);
 
-switch (msg->type) {
-case RD_DLACTIVITY:
-if (msg->state != RD_CONSISTENT)
-break;
-dt_proc_scan(dtp, dpr);
-break;
-case RD_NONE:
-/* cannot happen, but do nothing anyway */
+/* cannot happen, but do nothing anyway */
+if (msg->type == RD_NONE)
+return;
+
+/*
+ * Call dt_proc_scan() on the first consistent report after
+ * an add or remove.
+ */
+switch (msg->state) {
+case RD_ADD:
+case RD_DELETE:
+dpr->dpr_awaiting_dlactivity = 1;
 break;
+case RD_CONSISTENT:
+if (dpr->dpr_awaiting_dlactivity) {
+dt_proc_scan(dtp, dpr);
+dpr->dpr_awaiting_dlactivity = 0;
+}
 }
 }
 
",1205,246
"dt_link: Get the BFD emulation name right for 32-bit SPARC.

""ld -m elf_i386"" doesn't work too well there.

Orabug: 24455245"," dtrace_program_link(dtrace_hdl_t *dtp, dtrace_prog_t *pgp, uint_t dflags,
 
 if (dtp->dt_oflags & DTRACE_O_ILP32) {
 snprintf(drti, sizeof (drti), ""%s/drti32.o"", libdir->dir_path);
+#if defined(__sparc)
+emu = "" -m elf32_sparc"";
+#elif defined(__i386) || defined(__amd64)
 emu = "" -m elf_i386"";
+#endif
 } else {
 snprintf(drti, sizeof (drti), ""%s/drti.o"", libdir->dir_path);
 emu = """";
",1084,227
"dtrace: terminate if the g_pslive counter underflows

if a bug somewhere leads to the prochandler (process death notifier)
being invoked more times than there are processes we have monitored,
dtrace should still terminate, rather than letting the handler underflow
and running forever.

Orabug: 24829169"," main(int argc, char *argv[])
 g_newline = 0;
 }
 
-if (done || g_intr || (g_psc != 0 && g_pslive == 0)) {
+if (done || g_intr || (g_psc != 0 && g_pslive <= 0)) {
 done = 1;
 if (dtrace_stop(g_dtp) == -1)
 dfatal(""couldn't stop tracing"");
",1333,330
"Trivial tracing improvement.

It helps to say what PID we're dealing with when relinquishing all
locks, since they're per-PID."," dt_proc_control_cleanup(void *arg)
 dt_proc_dpr_unlock(dpr);
 }
 dpr->dpr_ending = 0;
-dt_dprintf(""Relinquished all locks.\n"");
+dt_dprintf(""%i: relinquished all locks.\n"", dpr->dpr_pid);
 
 /*
  * fd closing must be done with some care. The thread may be cancelled
",1214,249
"libproc: use open(..., O_CLOEXEC).

We are using it elsewhere: we can rely on it here rather than using
fcntl()."," Pmemfd(struct ps_prochandle *P)
 if ((P->memfd != -1) || P->noninvasive)
 return (P->memfd);
 
-/*
- * Get the path to /proc/$pid.
- */
-
 snprintf(procname, sizeof (procname), ""%s/%d/"",
  procfs_path, (int)P->pid);
 fname = procname + strlen(procname);
 
 strcpy(fname, ""mem"");
-if ((P->memfd = open(procname, (O_RDONLY|O_EXCL))) < 0) {
+if ((P->memfd = open(procname, O_RDONLY | O_EXCL | O_CLOEXEC)) < 0) {
 _dprintf(""Pmemfd: failed to open %s: %s\n"",
  procname, strerror(errno));
 return (-1);
 }
 
-fcntl(P->memfd, F_SETFD, FD_CLOEXEC);
 return (P->memfd);
 }
 
",1649,380
"libproc: remove unused symn assignment from Psymbol_iter_by_addr().

Fixes a compiler warning.

Also fix some type-sizing issues in the same function."," Psymbol_iter_by_addr(struct ps_prochandle *P,
 map_info_t *mptr;
 file_info_t *fptr;
 sym_tbl_t *symtab;
-size_t symn;
+size_t count;
 const char *strs;
 size_t strsz;
 int rv;
-uint_t *map, i, count, ndx;
+uint_t *map, i, ndx;
 
 if (P->state == PS_DEAD)
 return (-1);
 Psymbol_iter_by_addr(struct ps_prochandle *P,
 return (-1);
 }
 
-symn = symtab->sym_symn;
 strs = symtab->sym_strs;
 strsz = symtab->sym_strsz;
 map = symtab->sym_byaddr;
",1381,370
Routine waitfd() syscall number update for Linux kernel 4.8.,"
 static struct waitfds_tag {
 unsigned long linux_version_code;
 long waitfd;
-} waitfds[] = { { KERNEL_VERSION(4,6,0), 360 },
+} waitfds[] = { { KERNEL_VERSION(4,8,0), 360 },
+{ KERNEL_VERSION(4,6,0), 360 },
 { KERNEL_VERSION(4,5,0), 358 },
- { KERNEL_VERSION(4,1,4), 351 },
- { 0, 0 } };
+{ KERNEL_VERSION(4,1,4), 351 },
+{ 0, 0 } };
 
 static long waitfd_nr;
 
",32,6
"Emit a debugging message when the waitfd() syscall number is not known.

This means we forgot to update the list, and is sure to cause test
failures.","
 #include <unistd.h>/* for syscall() */
 #include <linux/version.h> /* for KERNEL_VERSION() */
 #include <port.h> /* for linux_version_code() */
+#include <dt_debug.h>
 
 /*
 * Translates waitpid() into a pollable fd.
 waitfd(int which, pid_t upid, int options, int flags)
 break;
 }
 }
-if (!waitfd_nr)
+if (!waitfd_nr) {
+dt_dprintf(""waitfd() syscall number for this kernel ""
+ ""not known.\n"");
 return -ENOSYS;
+}
 }
 
 return syscall(waitfd_nr, which, upid, options, flags);
",36,6
"Emit libproc errors to the debugging log.

They tend to get entirely lost otherwise: they're only emitted on stderr
if the error is fatal."," static struct ps_prochandle *
 dt_proc_error(dtrace_hdl_t *dtp, dt_proc_t *dpr, const char *format, ...)
 {
 va_list ap;
+va_list tmp;
 
 va_start(ap, format);
+va_copy(tmp, ap);
 dt_set_errmsg(dtp, NULL, NULL, NULL, 0, format, ap);
 va_end(ap);
+dt_debug_printf(""dt_proc_error"", format, tmp);
+va_end(tmp);
 
 (void) dt_set_errno(dtp, EDT_COMPILER);
 return (NULL);
",1218,249
"tests: add new expensive exec()-and-breakpoints test

This is just like test/internals/libproc/tst.execing-bkpts.sh,
only it runs for more than ten times as long to try to tease
out related oopses.

Orabug: 24977175"," void __attribute__((__noinline__)) breakdance(void)
 
 int main (int argc, char *argv[])
 {
-int snum = 0;
+int snum = 0, total = 5000;
 char *snarg;
 char *exe;
 
 if (argc > 1)
-snum = atoi(argv[1]);
+total = atoi(argv[1]);
 
-if (snum > 5000)
+if (argc > 2)
+snum = atoi(argv[2]);
+
+if (snum > total)
 return 0;
 
 srand(snum + time(NULL));
 int main (int argc, char *argv[])
 
 asprintf(&snarg, ""%i"", ++snum);
 asprintf(&exe, ""/proc/%i/exe"", getpid());
-execl(exe, argv[0], snarg, (char *) NULL);
+execl(exe, argv[0], argv[1], snarg, (char *) NULL);
 perror(""Cannot self-exec: should never happen\n"");
 return 1;
 }
",28,6
"libproc: fix another endianness problem breaking PTRACE_GETMAPFD

This one causes the PTRACE_GETMAPFD to spuriously appear to fail after
dupping the fd, leaking a single fd per call until we run out of FDs
and bug 24977175 panics the system."," Pbuild_file_symtab(struct ps_prochandle *P, file_info_t *fptr)
  O_RDONLY);
 
 if ((!P->noninvasive) && (fd < 0)) {
+long pfd;
+
 fptr->file_init = 0;
 err = Ptrace(P, 1);
 if (fptr->file_init == 1) {
 Pbuild_file_symtab(struct ps_prochandle *P, file_info_t *fptr)
  * Even this can fail: fd table overflow, for instance.
  * Fall back, if so.
  */
-if (err >= 0)
+if (err >= 0) {
 if (wrapped_ptrace(P, PTRACE_GETMAPFD, P->pid,
 P->mappings[fptr->file_map].map_pmap->pr_vaddr,
-&fd) < 0)
+&pfd) < 0)
 fd = -1;
+else
+fd = pfd;
+}
 
 fptr->file_init = 0;
 Puntrace(P, 0);
",1421,378
"link: work around elfutils non-mmap()-path bug

This bug causes massive corruption of dtrace -G'ed object files in
as-yet-undetermined circumstances (assembling the input .o file on OL7.3
is a sufficient condition).

Orabug: 25059329"," process_obj(dtrace_hdl_t *dtp, const char *obj, int *eprobesp)
  ""failed to open %s: %s"", obj, strerror(errno)));
 }
 
-if ((elf = elf_begin(fd, ELF_C_RDWR, NULL)) == NULL) {
+if ((elf = elf_begin(fd, ELF_C_RDWR_MMAP, NULL)) == NULL) {
 return (dt_link_error(dtp, elf, fd, bufs,
  ""failed to process %s: %s"", obj, elf_errmsg(elf_errno())));
 }
",1084,227
waitfd: update syscall number for 4.9.,"
 static struct waitfds_tag {
 unsigned long linux_version_code;
 long waitfd;
-} waitfds[] = { { KERNEL_VERSION(4,8,0), 360 },
+} waitfds[] = { { KERNEL_VERSION(4,9,0), 360 },
+ { KERNEL_VERSION(4,8,0), 360 },
 { KERNEL_VERSION(4,6,0), 360 },
 { KERNEL_VERSION(4,5,0), 358 },
 { KERNEL_VERSION(4,1,4), 351 },
",37,6
"dis: disassemble predicates too

This makes it practical to identify the cause of DTrace errors
in predicates."," dt_dis_action(const dtrace_actdesc_t *ap, FILE *fp, const char *fmt)
 dt_dis_difo(dp, fp);
 }
 
+static void
+dt_dis_pred(const dtrace_preddesc_t *predp, FILE *fp)
+{
+dtrace_difo_t *dp = predp->dtpdd_difo;
+char type[DT_TYPE_NAMELEN];
+
+if (dp == NULL)
+return;
+
+fprintf(fp, ""\nPredicate DIFO %p returns %s\n"", (void *)dp,
+ dt_dis_typestr(&dp->orig_dtdo_rtype, type, sizeof (type)));
+
+dt_dis_difo(dp, fp);
+}
+
 typedef struct dt_dis_iter
 {
 FILE *fp;
 dt_dis_stmts(dtrace_hdl_t *dtp, dtrace_prog_t *pgp, dtrace_stmtdesc_t *sdp,
 void *data)
 {
 dt_dis_iter_t *d = data;
+dtrace_preddesc_t *predp = &sdp->dtsd_ecbdesc->dted_pred;
 dtrace_actdesc_t *ap = sdp->dtsd_action;
 const char *fmt = NULL;
 
 dt_dis_stmts(dtrace_hdl_t *dtp, dtrace_prog_t *pgp, dtrace_stmtdesc_t *sdp,
 fmt = pfv->pfv_format;
 }
 
+dt_dis_pred(predp, d->fp);
 dt_dis_action(ap, d->fp, fmt);
 return 0;
 }
",534,89
"dis: dump the offset as well as the instruction counter

The OFF column in DIF disassembly is actually not the offset but
a simple instruction counter, leading to endless confusion when trying
to match it up with the offset returned in kernel error messages (which
is a true offset). Dump the offset too.

Also boost the column width of both columns to three digits, since it
is fairly routine to have predicates > 100 bytes long."," dt_dis_difo(const dtrace_difo_t *dp, FILE *fp)
 ulong_t i = 0;
 char type[DT_TYPE_NAMELEN];
 
-(void) fprintf(fp, ""%-3s %-8s %s\n"",
- ""OFF"", ""OPCODE"", ""INSTRUCTION"");
+(void) fprintf(fp, ""%-3s %-4s %-8s %s\n"",
+ ""INS"", ""OFF"", ""OPCODE"", ""INSTRUCTION"");
 
 for (i = 0; i < dp->dtdo_len; i++) {
 dif_instr_t instr = dp->dtdo_buf[i];
 dt_dis_difo(const dtrace_difo_t *dp, FILE *fp)
 opcode = 0; /* force invalid opcode message */
 
 op = &optab[opcode];
-(void) fprintf(fp, ""%02lu: %08x "", i, instr);
+(void) fprintf(fp, ""%03lu %03lu: %08x "", i, i*4, instr);
 op->op_func(dp, op->op_name, instr, fp);
 (void) fprintf(fp, ""\n"");
 }
",534,89
"test: release libproc handle on error in libproc-execing-bkpts

This test was just terminating on error, leaving breakpoints outstanding
in its children, killing them and making the user think something
important was coredumping.

This is unnecessarily scary: fail more neatly.

Orabug: 25738022 (but not a full fix)"," main(int argc, char *argv[])
 int err;
 volatile int execs = 0;
 jmp_buf exec_jmp;
+int ret = 0;
 
 if (argc < 3) {
 fprintf(stderr, ""Syntax: libproc-execing-bkpts symbol process count ""
 main(int argc, char *argv[])
 if ((Pxlookup_by_name(P, PR_LMID_EVERY, PR_OBJ_EVERY, symbol, &sym, &sip) != 0) &&
  (Pstate(P) != PS_DEAD)) {
 fprintf(stderr, ""Lookup error.\n"");
-exit(1);
+ret = 1;
+goto end;
 }
 
 if (Pstate(P) == PS_DEAD)
 main(int argc, char *argv[])
 if ((Pbkpt(P, sym.st_value, 0, hit_it, NULL, NULL) != 0) &&
  (Pstate(P) != PS_DEAD)) {
 fprintf(stderr, ""Cannot drop breakpoint.\n"");
-exit(1);
+ret = 1;
+goto end;
 }
 Puntrace(P, 0); /* untracing, if exec()ed last time */
 }
 main(int argc, char *argv[])
  ""hits seen (%i/%i)\n"", execs, hits);
 
 printf(""%i exec()s, %i breakpoint hits seen\n"", execs, hits);
-
+end:
 Prelease(P, PS_RELEASE_KILL);
 Pfree(P);
 
-return (0);
+return (ret);
 }
",89,15
Routine translator and waitfd changes for 4.10.,"
 static struct waitfds_tag {
 unsigned long linux_version_code;
 long waitfd;
-} waitfds[] = { { KERNEL_VERSION(4,9,0), 360 },
- { KERNEL_VERSION(4,8,0), 360 },
+} waitfds[] = { { KERNEL_VERSION(4,10,0), 360 },
+{ KERNEL_VERSION(4,9,0), 360 },
+{ KERNEL_VERSION(4,8,0), 360 },
 { KERNEL_VERSION(4,6,0), 360 },
 { KERNEL_VERSION(4,5,0), 358 },
 { KERNEL_VERSION(4,1,4), 351 },
",38,6
Routine translator and waitfd changes for 4.11.,"
 static struct waitfds_tag {
 unsigned long linux_version_code;
 long waitfd;
-} waitfds[] = { { KERNEL_VERSION(4,10,0), 360 },
+} waitfds[] = { { KERNEL_VERSION(4,11,0), 360 },
+{ KERNEL_VERSION(4,10,0), 360 },
 { KERNEL_VERSION(4,9,0), 360 },
 { KERNEL_VERSION(4,8,0), 360 },
 { KERNEL_VERSION(4,6,0), 360 },
",39,6
"tests: filter the vDSO out of libproc create/grab pldd tests

These tests test libproc's phdr iteration and library search-path lookup
functions by running an enhanced version of ldd(1) on a test binary
(enhanced in that it can print the search path in force for each shared object,
which ldd cannot). However, this also prints out the internal entry for the
vDSO, which is problematic because the vDSO is not present on all systems
(in particular, it is not present on upstream SPARC kernels without the UEK
patches installed). The lack of the vDSO does not mean that libproc is
broken, so filter it out so its presence or absence doesn't affect us."," print_ldd(const rd_loadobj_t *loadobj, size_t num, void *state)
 return (0);
 }
 
+/*
+ * No name, no search path: vDSO, we don't care about it.
+ */
+if (buf[0] == '\0' && loadobj->rl_nscopes == 1)
+return (1);
+
 printf(""%s: dyn 0x%lx, bias 0x%lx, LMID %li: %s ("", buf, loadobj->rl_dyn,
  loadobj->rl_diff_addr, loadobj->rl_lmident, loadobj->rl_default_scope ?
  ""inherited symbol search path: "": ""symbol search path: "");
 note_ldd(const rd_loadobj_t *loadobj, size_t num, void *state)
 return (0);
 }
 
+/*
+ * No name, no search path: vDSO, we don't care about it.
+ */
+if (buf[0] == '\0' && loadobj->rl_nscopes == 1)
+return (1);
+
 libs_seen++;
 return (1);
 }
",125,27
"DTrace TCP/UDP providers, associated translators and tests

This patch adds support for TCP and UDP DTrace providers and all related
data structures and translators. Future work will include adding a
""cs_pid"" field to the csinfo_t to allow association of process ids with
tcp/udp events.

The tests require IO::Socket::IP, and will SKIP without it.

[nca: improved tests, added IO::Socket::IP requirement to specfile etc]
Orabug: 25815242"," static const dt_ident_t _dtrace_globals[] = {
 { ""inet_ntoa"", DT_IDENT_FUNC, 0, DIF_SUBR_INET_NTOA, DT_ATTR_STABCMN,
 DT_VERS_1_5, &dt_idops_func, ""string(ipaddr_t *)"" },
 { ""inet_ntoa6"", DT_IDENT_FUNC, 0, DIF_SUBR_INET_NTOA6, DT_ATTR_STABCMN,
-DT_VERS_1_5, &dt_idops_func, ""string(in6_addr_t *)"" },
+DT_VERS_1_5, &dt_idops_func, ""string(struct in6_addr *)"" },
 { ""inet_ntop"", DT_IDENT_FUNC, 0, DIF_SUBR_INET_NTOP, DT_ATTR_STABCMN,
 DT_VERS_1_5, &dt_idops_func, ""string(int, void *)"" },
 { ""ipl"", DT_IDENT_SCALAR, 0, DIF_VAR_IPL, DT_ATTR_STABCMN, DT_VERS_1_0,
",1000,130
"Ensure multiple passes through dtrace -G work on sparc64.

Due to how relocations for USDT probe locations were handled, doing a
second pass through 'dtrace -G' would cause probes to no longer be
recognized. This commit ensures that we recognize relocations of type
NONE as probe locations that were already processed rather than ignoring
them.

This was previously fixed for x86_64 (commit dbf1b361).

Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>"," dt_modtext(dtrace_hdl_t *dtp, char *p, int isenabled, GElf_Rela *rela,
 
 /*
  * We only know about some specific relocation types.
+ * We also recognize relocation type NONE, since that gets used for
+ * relocations of USDT probes, and we might be re-processing a file.
  */
 if (GELF_R_TYPE(rela->r_info) != R_SPARC_WDISP30 &&
- GELF_R_TYPE(rela->r_info) != R_SPARC_WPLT30)
+ GELF_R_TYPE(rela->r_info) != R_SPARC_WPLT30 &&
+ GELF_R_TYPE(rela->r_info) != R_386_NONE)
 return (-1);
 
 /*
",1085,228
"dtrace: eliminate spurious symbol at address 0

from /proc/kallmodsyms:
0000000000000000 4000 A irq_stack_union
0000000000000000 4000 A __per_cpu_start
0000000000004000 1000 A gdt_page
0000000000005000 5000 A exception_stacks
000000000000a000 8 A espfix_stack

irq_stack_union is just a section marker.

Fixed this on the userspace where we filter out inappropriate
kallsyms output.

The output for PC = 0 is now:
	3 chars |0x0|

Signed-off-by: Vincent Lim <vincent.lim@oracle.com>
Reviewed-by: Nick Alcock <nick.alcock@oracle.com>
Orabug: 26025761"," dt_modsym_update(dtrace_hdl_t *dtp, const char *line, dt_module_t **last_dmp)
 #define strstarts(var, x) (strncmp(var, x, strlen (x)) == 0)
 if ((strcmp(sym_name, ""__per_cpu_start"") == 0) ||
  (strcmp(sym_name, ""__per_cpu_end"") == 0) ||
+ (strcmp(sym_name, ""irq_stack_union"") == 0) || 
  (strstarts(sym_name, ""__crc_"")) ||
  (strstarts(sym_name, ""__ksymtab_"")) ||
  (strstarts(sym_name, ""__kcrctab_"")) ||
 dt_modsym_update(dtrace_hdl_t *dtp, const char *line, dt_module_t **last_dmp)
 }
 }
 #undef strstarts
+if(!dmp)
+return 0;
 
 /*
  * Add this symbol to the module's kernel symbol table.
",1175,287
"fix name of lowest bucket in dt_print_lquantize()

This is a fix for
26261502 DTrace lquantize() normalization is wrong for name of lowest bucket
If a distribution is to be normalized, only the values of the buckets should
be normalized. The lowest bucket for lquantize() also incorrectly had its
name normalized. The error is corrected and a test added.

Orabug: 26261502","
 * CDDL HEADER END
 */
 /*
- * Copyright 2009, 20111--2014 Oracle, Inc. All rights reserved.
+ * Copyright 2009, 2011--2014, 2017 Oracle, Inc. All rights reserved.
 * Use is subject to license terms.
 */
 
 dt_print_lquantize(dtrace_hdl_t *dtp, FILE *fp, const void *addr,
 
 if (i == 0) {
 (void) snprintf(c, sizeof (c), ""< %d"",
- base / (uint32_t)normal);
+ base);
 err = dt_printf(dtp, fp, ""%16s "", c);
 } else if (i == levels + 1) {
 (void) snprintf(c, sizeof (c), "">= %d"",
",1510,401
"adjust dt_print_ustack() depth for Linux

This is a fix for
26045010 DTrace jstack() may show unprintable characters
The problem was the ""depth"" at which the stack starts was
leftover from Solaris. It needed to be adapted for Linux.
The code was incorrectly reading the string table.

Orabug: 26045010"," dt_print_ustack(dtrace_hdl_t *dtp, FILE *fp, const char *format,
 uint64_t *pc = ((uint64_t *)addr) + 1;
 uint32_t depth = DTRACE_USTACK_NFRAMES(arg);
 uint32_t strsize = DTRACE_USTACK_STRSIZE(arg);
-const char *strbase = addr + (depth + 1) * sizeof (uint64_t);
+const char *strbase = addr + (depth + 2) * sizeof (uint64_t);
 const char *str = strsize ? strbase : NULL;
 int err = 0;
 
",1510,401
"tracemem: implement optional third argument (dynamic size)

This feature was added to Solaris as part of bug 15822040:
SUNBT7204136 Let tracemem() specify a dynamic size.
Here we implement this for Linux, including introducing the
new user-visible arguments
DTRACE_TRACEMEM_STATIC
DTRACE_TRACEMEM_DYNAMIC
DTRACE_TRACEMEM_SIZE
DTRACE_TRACEMEM_SSIZE
as well as refactoring
dt_print_bytes()'s raw label, making it its own function
dt_print_rawbytes().

Orabug: 26223475","
 * CDDL HEADER END
 */
 /*
- * Copyright 2009, 2012 Oracle, Inc. All rights reserved.
+ * Copyright 2009, 2012, 2017 Oracle, Inc. All rights reserved.
 * Use is subject to license terms.
 */
 
 static const struct {
 { EDT_CORRUPT_KALLSYMS, ""/proc/kallsyms corrupt, perhaps due to ""
  ""concurrent module unload"" },
 { EDT_ELFCLASS, ""Unknown ELF class, neither 32- nor 64-bit"" },
-{ EDT_OBJIO, ""Cannot read object file or modules.dep"" }
+{ EDT_OBJIO, ""Cannot read object file or modules.dep"" },
+{ EDT_TRACEMEM, ""Missing or corrupt tracemem() record"" }
 };
 
 static const int _dt_nerr = sizeof (_dt_errlist) / sizeof (_dt_errlist[0]);
",175,25
"Pread(): sparc: fix spurious errors and misreading of unaligned data

The code to read data from high addresses (needed on sparc, but not on
x86) fails to adjust the length to read to account for the fact that
only whole numbers of sizeof(unsigned long) units can be read, or
to read from the right place, or to set the number of bytes properly
afterwards.

The result is that unaligned reads (as done by e.g. the glibc
l_searchlist searching code) read the wrong data and claim that they
read more bytes than they were asked to.

Orabug: 26378141"," Pread(struct ps_prochandle *P,
 long *rbuf;
 
 size_t len = nbyte + (address - saddr);
+if (len % sizeof (long) != 0)
+len += sizeof (long) - (len % sizeof (long));
 
 rbuf = malloc(len);
 if (!rbuf)
 Pread(struct ps_prochandle *P,
 errno = 0;
 for (i = 0, sz = 0; sz < len; i++, sz += sizeof (long)) {
 long data = wrapped_ptrace(P, PTRACE_PEEKDATA, P->pid,
- address + sz, NULL);
+ saddr + sz, NULL);
 if (errno != 0)
 break;
 rbuf[i] = data;
 }
 
-nbyte = (sz > len) ? len : sz - (address - saddr);
+nbyte = (sz > nbyte) ? nbyte : sz;
 
 memcpy(buf, rbuf + (address - saddr), nbyte);
 free(rbuf);
",1679,389
"Look for cpp and ld along the PATH.

The default linker and preprocessor used internally by DTrace are hardwired
to /usr/bin/ld and /usr/bin/cpp. This is unwise, since it is commonplace to
replace the compiler by adjusting $PATH, and the compiler driver (for which
cpp is a frontend) looks for its own components along the path as well. This
means that if you e.g. scl enable devtoolset-6, you end up with a GCC 4.4 cpp
trying to invoke pieces of GCC 6. Disaster results.

The solution is to remove the path from the linker and assembler and use path
searches here, too, just like the compiler itself does.

Orabug: 26396530"," const dtrace_pattr_t _dtrace_prvdesc = {
 { DTRACE_STABILITY_UNSTABLE, DTRACE_STABILITY_UNSTABLE, DTRACE_CLASS_COMMON },
 };
 
-static const char *_dtrace_defcpp = ""/usr/bin/cpp""; /* default cpp(1) to invoke */
-static const char *_dtrace_defld = ""/usr/bin/ld""; /* default ld(1) to invoke */
+static const char *_dtrace_defcpp = ""cpp""; /* default cpp(1) to invoke */
+static const char *_dtrace_defld = ""ld""; /* default ld(1) to invoke */
 static const char *_dtrace_defproc = ""/proc""; /* default /proc path */
 static const char *_dtrace_defsysslice = "":/system.slice/""; /* default systemd
  system slice */
",1000,130
"Translator and waitfd updates for v4.12.

Much work and testing done by Vincent Lim.

Thanks-to: Vincent Lim <vincent.lim@oracle.com>
Signed-off-by: Nick Alcock <nick.alcock@oracle.com>","
 */
 
 /*
- * Copyright 2011 -- 2016 Oracle, Inc. All rights reserved.
+ * Copyright 2011 -- 2017 Oracle, Inc. All rights reserved.
 * Use is subject to license terms.
 */
 

 static struct waitfds_tag {
 unsigned long linux_version_code;
 long waitfd;
-} waitfds[] = { { KERNEL_VERSION(4,11,0), 360 },
+} waitfds[] = { { KERNEL_VERSION(4,12,0), 361 },
+{ KERNEL_VERSION(4,11,0), 361 },
 { KERNEL_VERSION(4,10,0), 360 },
 { KERNEL_VERSION(4,9,0), 360 },
 { KERNEL_VERSION(4,8,0), 360 },
",40,6
"UPL relicensing, stage 1: manual modifications.

This relicenses everything that cannot be relicensed automatically
and is long enough to be meaningfully copyrightable at all (and
not automatically generated and uncopyrightable, like the .r files).

In addition, various copyrights that span lines or are sufficiently
nonstandard that the automated tooling will not pick it up are
reworded to the Oracle standard form.","
 * CDDL HEADER END
 */
 /*
- * Copyright 2009, 2011, 2012, 2013, 2014, 2015 Oracle, Inc.
- * All rights reserved. Use is subject to license terms.
+ * Copyright  2009, 2015, Oracle and/or its affiliates. All rights reserved.
+ * Use is subject to license terms.
 */
 
 /*
",156,24
"Drop dtrace_ioctl_sizes() usage.

It is unecessarily hard to provide in the new merged, relicensed world,
and is only occasionally useful.","
 
 #include <dt_git_version.h>
 
-#include <linux/dtrace/ioctl_debug.h>
-
 /*
 * Stability and versioning definitions. These #defines are used in the tables
 * of identifiers below to fill in the attribute and version fields associated
 alloc:
  dt_cpp_add_arg(dtp, utsdef) == NULL)
 return (set_open_errno(dtp, errp, EDT_NOMEM));
 
-dtrace_ioctl_sizes();
-
 if (flags & DTRACE_O_NODEV)
 bcopy(&_dtrace_conf, &dtp->dt_conf, sizeof (_dtrace_conf));
 else if (dt_ioctl(dtp, DTRACEIOC_CONF, &dtp->dt_conf) != 0)
",998,130
"Fix up copyrights

Replace special char usage with regular ascii representation.

Signed-off-by: Tomas Jedlicka <tomas.jedlicka@oracle.com>
Reviewed-by: Kris Van Hees <kris.van.hees@oracle.com>","
 /*
 * Oracle Linux DTrace.
- * Copyright  2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
 * Licensed under the Universal Permissive License v 1.0 as shown at
 * http://oss.oracle.com/licenses/upl.
 */
",219,46
"fix error messages when wrong number of args and expected number is not unique

Fix copyright and license notices.

Orabug: 26402731

Signed-off-by: Eugene Loh <eugene.loh@oracle>
Reviewed-by: Tomas Jedlicka <tomas.jedlicka@oracle.com>","
 /*
 * Oracle Linux DTrace.
- * Copyright (c) 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2007, 2017, Oracle and/or its affiliates. All rights reserved.
 * Licensed under the Universal Permissive License v 1.0 as shown at
 * http://oss.oracle.com/licenses/upl.
 */
",769,183
"Fix comment.

We haven't read modules.order to find kernel modules since commit
ce28470e6f82f480ed0df474c44b19239e68f948, nearly two years ago: we only
read from modules.order for two days!

Reviewed-by: Tomas Jedlicka <tomas.jedlicka@oracle.com>","
 /*
 * Oracle Linux DTrace.
- * Copyright (c) 2009, 2015, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2009, 2017, Oracle and/or its affiliates. All rights reserved.
 * Licensed under the Universal Permissive License v 1.0 as shown at
 * http://oss.oracle.com/licenses/upl.
 */

 * Kernel module list management. We must maintain bindings from
 * name->filesystem path for all the current kernel's modules, since the system
 * maintains no such list and all mechanisms other than find(1)-analogues have
- * been deprecated or removed in kmod. However, we can rely on modules.order
- * for all in-kernel modules: it's only out-of-tree modules in other paths that
- * we must do fs walks to find.
+ * been deprecated or removed in kmod. However, we can rely on modules.dep
+ * to contain paths to all modules, in- or out-of-tree.
 */
 
 #include <sys/types.h>
",156,24
"dtrace: 3-arg tracemem changes from release branch

The release branch accumulated several changes to the 3-arg
tracemem support which never landed on master, but the master
commit is so far back that squashing them in seems unhelpful
and unclear. So add them as a separate commit.

None of them should have any functional effect."," dt_print_tracemem(dtrace_hdl_t *dtp, FILE *fp, const dtrace_recdesc_t *rec,
 return (dt_set_errno(dtp, EDT_TRACEMEM));
 
 dpositive = drec->dtrd_arg == DTRACE_TRACEMEM_SIZE ||
- (dsize & (1 << drec->dtrd_size * NBBY - 1)) == 0;
+ (dsize & (1 << (drec->dtrd_size * NBBY - 1))) == 0;
 
 if (dpositive && dsize < size)
 size = (size_t)dsize;
",1681,451
dtrace: Add 4.13 into waitfd/translators,"
 static struct waitfds_tag {
 unsigned long linux_version_code;
 long waitfd;
-} waitfds[] = { { KERNEL_VERSION(4,12,0), 361 },
+} waitfds[] = { { KERNEL_VERSION(4,13,0), 361 },
+{ KERNEL_VERSION(4,12,0), 361 },
 { KERNEL_VERSION(4,11,0), 361 },
 { KERNEL_VERSION(4,10,0), 360 },
 { KERNEL_VERSION(4,9,0), 360 },
",41,6
Routine 4.14 porting changes.,"
 static struct waitfds_tag {
 unsigned long linux_version_code;
 long waitfd;
-} waitfds[] = { { KERNEL_VERSION(4,13,0), 361 },
+} waitfds[] = { { KERNEL_VERSION(4,14,0), 361 },
+{ KERNEL_VERSION(4,13,0), 361 },
 { KERNEL_VERSION(4,12,0), 361 },
 { KERNEL_VERSION(4,11,0), 361 },
 { KERNEL_VERSION(4,10,0), 360 },
",42,6
"libproc: note that processes are released before we unlock

This avoids a narrow race window where a Prelease() triggered
by a terminated process or shutting-down dtrace process-
control thread collides with the Pfree() in dt_ps_proc_destroy(),
leading to an assertion failure because P->released is still
false.

So ensure that everything Prelease() needs to do to the process
is done before the unlock happens.

Signed-off-by: Nick Alcock <nick.alcock@oracle.com>
Reviewed-by: Tomas Jedlicka <tomas.jedlicka@oracle.com>
Orabug: 26848964"," Prelease(struct ps_prochandle *P, int release_mode)
 wrapped_ptrace(P, PTRACE_DETACH, (int)P->pid, 0, 0);
 
 unlock_exit:
+/*
+ * Flip the released vector *before* we release locks, because
+ * at any point after this a Pfree() can come in. and it
+ * asserts that P->released.
+ */
+P->state = PS_DEAD;
+P->released = TRUE;
+
 if (P->ptrace_count != 0 && ptrace_lock_hook &&
  release_mode != PS_RELEASE_NO_DETACH)
 ptrace_lock_hook(P, P->wrap_arg, 0);
 
-P->state = PS_DEAD;
-P->released = TRUE;
-
 dt_debug_dump(0);
 }
 
",1678,389
"dtrace: eliminate new (KPTI-related) spurious symbol at address 0

These symbols crept in as a consequence of the KPTI patches (they
denote the userspace-page-table per-CPU region).

Orabug: 27364377
Signed-off-by: Nick Alcock <nick.alcock@oracle.com>"," dt_modsym_update(dtrace_hdl_t *dtp, const char *line)
 #define strstarts(var, x) (strncmp(var, x, strlen (x)) == 0)
 if ((strcmp(sym_name, ""__per_cpu_start"") == 0) ||
  (strcmp(sym_name, ""__per_cpu_end"") == 0) ||
+ (strcmp(sym_name, ""__per_cpu_user_mapped_start"") == 0) ||
+ (strcmp(sym_name, ""__per_cpu_user_mapped_end"") == 0) ||
  (strcmp(sym_name, ""irq_stack_union"") == 0) || 
  (strstarts(sym_name, ""__crc_"")) ||
  (strstarts(sym_name, ""__ksymtab_"")) ||
",1229,304
"Support systems where char is unsigned.

Various places in DTrace, from D intrinsics through to the IS_CHAR()
macro, assume that char is the same type as signed char. This is, of
course, not guaranteed: DTrace should work when char == unsigned char,
as well.

Adjust things accordingly, using the new CTF_CHAR signedness-sensitive
macro in libdtrace-ctf 0.8.

Orabug: 27439069"," main(int argc, char *argv[])
 char modpath[PATH_MAX];
 char *revno = NULL;
 struct utsname uts;
-char opt;
+int opt;
 dt_kern_path_t *dkpp;
 
 elf_version(EV_CURRENT);
",219,46
"arm64: new architecture

This adds minimal support, and does not adjust the tests except insofar
as is needed to handle the fact that arm64 GCC does not support -m64
(but does support -m32).

Most of the libproc support is not well-tested.

Signed-off-by: Vincent Lim <vincent.lim@oracle.com>
Signed-off-by: Nick Alcock <nick.alcock@oracle.com>
Reviewed-by: Nick Alcock <nick.alcock@oracle.com>
Orabug: 27438960","
+/*
+ * Licensed under the Universal Permissive License v 1.0 as shown at
+ * http://oss.oracle.com/licenses/upl.
+ */
+
+#include <config.h>/* for HAVE_* */
+
+#ifndef HAVE_WAITFD
+#include <unistd.h>/* for syscall() */
+#include <platform.h>
+
+int
+waitfd(int which, pid_t upid, int options, int flags)
+{
+ return syscall(__NR_waitfd, which, upid, options, flags);
+}
+
+#endif
",8,1
"arm64: Flip the -x evaltime= default to exec on ARM.

Non-exec not working yet.

Signed-off-by: Nick Alcock <nick.alcock@oracle.com>
Orabug: 27438960"," alloc:
 
 bzero(dtp, sizeof (dtrace_hdl_t));
 dtp->dt_oflags = flags;
+#if defined(__aarch64__)
+/*
+ * Modes other than CREATE not working yet.
+ */
+dtp->dt_prcmode = DT_PROC_STOP_CREATE;
+#else
 dtp->dt_prcmode = DT_PROC_STOP_POSTINIT;
+#endif
 dtp->dt_linkmode = DT_LINK_KERNEL;
 dtp->dt_linktype = DT_LTYP_ELF;
 dtp->dt_xlatemode = DT_XL_STATIC;
",1007,133
"Fix order of arguments for gmatch implementation

The gmatch glob matching) implementation uses fnmatch() as the
underlying mechanism, but the arguments are passed in the wrong
order. The gmatch() function takes the string as first argument
and the pattern as second whereas fnmatch() takes the pattern as
first argument and the strong to match as second.

Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>","
 int
 gmatch(const char *s, const char *p)
 {
- return (fnmatch (s, p, 0) == 0);
+ return (fnmatch (p, s, 0) == 0);
 }
",6,1
"rtld_db: ensure that an executable has a valid object name

The rtld adds the executable in a process with l_name being the empty
string, which the rtld_db support code in libproc does not handle
correctly. Regardless, an empty string is causing matching of probe
specifications to fail as well.

This commit ensures that DTrace userspace has a valid l_name for the
executable so that the probe specification matching (on module name)
works as designed.

Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>"," map_iter(const rd_loadobj_t *lop, size_t num, void *prochandle)
 
 *fptr->file_lo = *lop;
 
-if (Pread_string(P, buf, sizeof (buf), lop->rl_nameaddr) > 0) {
+if (num == 0) {
+/*
+ * The load object name is populated as an empty string by
+ * the C library, so we use the file name from the mapping.
+ */
+if (fptr->file_lname == NULL) {
+fptr->file_lbase = NULL;
+if ((fptr->file_lname =
+ strdup(fptr->file_pname)) != NULL)
+fptr->file_lbase = basename(fptr->file_lname);
+}
+} else if (Pread_string(P, buf, sizeof (buf), lop->rl_nameaddr) >= 0) {
 if ((fptr->file_lname == NULL) ||
  (strcmp(fptr->file_lname, buf) != 0) ||
  (buf[0] != '\0')) {
",1428,381
"dtrace: disassembler does not print all actions

This patch fixes D disassembler to follow the full chain of actions
per statement.

Orabug: 27565023

Signed-off-by: Tomas Jedlicka <tomas.jedlicka@oracle.com>
Reviewed-by: Nick Alcock <nick.alcock@oracle.com>","
 /*
 * Oracle Linux DTrace.
- * Copyright (c) 2005, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2005, 2018, Oracle and/or its affiliates. All rights reserved.
 * Licensed under the Universal Permissive License v 1.0 as shown at
 * http://oss.oracle.com/licenses/upl.
 */
 dt_dis_stmts(dtrace_hdl_t *dtp, dtrace_prog_t *pgp, dtrace_stmtdesc_t *sdp,
 }
 
 dt_dis_pred(predp, d->fp);
-dt_dis_action(ap, d->fp, fmt);
+
+while (ap != NULL) {
+dt_dis_action(ap, d->fp, fmt);
+ap = ap->dtad_next;
+}
+
 return 0;
 }
 
",537,90
"Comment out unported parts of dt_pid.

The upcoming changes to dt_proc.c and the libproc proxies require *all*
use of libproc functions to go through dt_proc proxies: rather than
introduce dozens of proxies to support a pid provider which is
nonfunctional anyway, just dike most of it out of the build and
reincorporate it when the pid provider is ported and we know what
proxies are needed.

Enough of dt_pid is retained to allow USDT to continue working.

Signed-off-by: Nick Alcock <nick.alcock@oracle.com>
Reviewed-by: Kris Van Hees <kris.van.hees@oracle.com>"," static void
 dt_proc_scan(dtrace_hdl_t *dtp, dt_proc_t *dpr)
 {
 Pupdate_syms(dpr->dpr_proc);
+#if 0
 if (dt_pid_create_probes_module(dtp, dpr) != 0)
 dt_proc_notify(dtp, dtp->dt_procs, dpr, dpr->dpr_errmsg,
  B_TRUE, B_TRUE);
+#endif
 }
 
 /*
",1216,251
"Fix address-to-symbol lookup on kernels compiled with older compilers

When a sufficiently old compiler / binutils combo is used, no _end
symbol is visible in /proc/kallmodsyms. We must continue to rely
on __brk_limit to find the end of the kernel text in this case.

Orabug: 27214992
Signed-off-by: Nick Alcock <nick.alcock@oracle.com>"," dt_modsym_update(dtrace_hdl_t *dtp, const char *line)
  * modules.
  */
 
-if (strcmp(sym_name, ""_end"") == 0)
+if ((strcmp(sym_name, ""_end"") == 0) ||
+ (strcmp(sym_name, ""__brk_limit"") == 0))
 kernel_upper_bound = sym_addr;
 
 /*
",1165,287
"Improve error messages on failed symbol lookup outside modules

We were logging nothing, which made it unnecessarily hard to track down
problems with module range construction.

Add a bit of extra debugging.

Orabug: 27214992
Signed-off-by: Nick Alcock <nick.alcock@oracle.com>"," dtrace_lookup_by_addr(dtrace_hdl_t *dtp, GElf_Addr addr,
 break;
 }
 
-if (dmp == NULL)
+if (dmp == NULL) {
+dt_dprintf(""No module corresponds to %lx\n"", addr);
 return (dt_set_errno(dtp, EDT_NOSYMADDR));
+}
 
 if (dt_module_load(dtp, dmp) == -1)
 return (-1); /* dt_errno is set for us */
",1167,287
"Fix a tiny memory leak in new symbol table range formation code

If we ran out of memory expanding the new_ranges, we leaked it.

Orabug: 27214992
Signed-off-by: Nick Alcock <nick.alcock@oracle.com>"," dt_symtab_form_ranges(dt_symtab_t *symtab)
 uint_t n = num_alloc + 1024;
 dt_symrange_t *r = realloc(new_ranges,
  sizeof (dt_symrange_t) * n);
-if (r == NULL)
+if (r == NULL) {
+free(new_ranges);
 return -1;
+}
 
 num_alloc = n;
 new_ranges = r;
",362,81
"dtrace: clean up gcc compiler warnings on x86

Building dtrace-utils would typically lead to a variety of gcc compiler
warnings. At the very least, this introduces noise into the build
process. This commit fixes many of those warnings on x86. The most
common case is
 warning: <variable> may be used uninitialized in this function
 [-Wmaybe-uninitialized]

One case that remains is the use of constructor priority 0 in
include/sys/compiler.h. This priority is needed, and the issue
has been documented in that file.

Orabug: 27934422

Signed-off-by: Eugene Loh <eugene.loh@oracle.com>
Reviewed-by: Nick Alcock <nick.alcock@oracle.com>"," dt_aggregate_quantizedcmp(int64_t *lhs, int64_t *rhs)
 {
 int nbuckets = DTRACE_QUANTIZE_NBUCKETS, i;
 long double ltotal = 0, rtotal = 0;
-int64_t lzero, rzero;
+int64_t lzero = 0, rzero = 0;
 
 for (i = 0; i < nbuckets; i++) {
 int64_t bucketval = DTRACE_QUANTIZE_BUCKETVAL(i);
 dt_aggregate_valcmp(const void *lhs, const void *rhs)
 if (lagg->dtagd_nrecs < ragg->dtagd_nrecs)
 return (DT_LESSTHAN);
 
-if (lagg->dtagd_nrecs == 0)
+if (lagg->dtagd_nrecs <= 0)
  return 0;
 
 for (i = 0; i < lagg->dtagd_nrecs; i++) {
",1298,309
"Fix -c support for aarch64

Put the correct value for the breakpoint instruction, and remove the
existing workaround that forced the procmode to be STOP_CREATE.

Various tests that were amended to work around -c not working are now
restored to their former state.

Orabug: 27847946
Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>
Reviewed-by: Tomas Jedlicka <tomas.jedlicka@oracle.com>"," alloc:
 
 bzero(dtp, sizeof (dtrace_hdl_t));
 dtp->dt_oflags = flags;
-#if defined(__aarch64__)
-/*
- * Modes other than CREATE not working yet.
- */
-dtp->dt_prcmode = DT_PROC_STOP_CREATE;
-#else
 dtp->dt_prcmode = DT_PROC_STOP_POSTINIT;
-#endif
 dtp->dt_linkmode = DT_LINK_KERNEL;
 dtp->dt_linktype = DT_LTYP_ELF;
 dtp->dt_xlatemode = DT_XL_STATIC;
",998,130
"dtrace: clean up gcc compiler warnings on x86 (gcc7)

Cleans up a few more warnings that appear only when gcc7 is
used to compile userspace.

 - Init of a uint_t variable that holds CTF kind from NULL
 - snprintf warns about string being truncated. Given that
 DTrace uses gnu99 standard it is fine to use snprintf with
 size set to 0 and NULL destination to get the final string
 size.
 - Removed #pragma diagnostic that was misspelled. It has no
 impact on the code itself because it was ignored and the
 code is clean from warnings.

Orabug: 28020296

Signed-off-by: Tomas Jedlicka <tomas.jedlicka@oracle.com>
Reviewed-by: Eugene Loh <eugene.loh@oracle.com>"," dtrace_program_link(dtrace_hdl_t *dtp, dtrace_prog_t *pgp, uint_t dflags,
 char drti[PATH_MAX], symvers[PATH_MAX];
 dof_hdr_t *dof;
 int fd, status, i, cur;
-char *cmd, tmp;
+char *cmd;
 size_t len;
 int eprobes = 0, ret = 0;
 
 dtrace_program_link(dtrace_hdl_t *dtp, dtrace_prog_t *pgp, uint_t dflags,
 if (pgp == NULL) {
 const char *fmt = ""%s -o %s -r"";
 
-len = snprintf(&tmp, 1, fmt, dtp->dt_ld_path, file) + 1;
+len = snprintf(NULL, 0, fmt, dtp->dt_ld_path, file) + 1;
 
 for (i = 0; i < objc; i++)
 len += strlen(objv[i]) + 1;
 dtrace_program_link(dtrace_hdl_t *dtp, dtrace_prog_t *pgp, uint_t dflags,
 }
 snprintf(symvers, sizeof (symvers), ""%s/drti-vers"", libdir->dir_path);
 
-len = snprintf(&tmp, 1, fmt, dtp->dt_ld_path, emu, file,
+len = snprintf(NULL, 0, fmt, dtp->dt_ld_path, emu, file,
  symvers, fd, drti) + 1;
 
 cmd = alloca(len);
",1122,242
"dtrace: NULL formatting string caused disassembler to coredump

Last change to disassembler added support for doing disassembly
for every action in a statement. Every action is part of same
list, so iterator can't simply follow the chain until its end.
The iterator must only interate over the subset of a chain marked
by dtsd_action and dtsd_action_last.

Iteration over actions from different statements restuls in
undefined behavior or coredump of the dtrace utility.

Orabug: 28054399

Signed-off-by: Tomas Jedlicka <tomas.jedlicka@oracle.com>
Acked-by: Eugene Loh <eugene.loh@oracle.com>
Reviewed-by: Nick Alcock <nick.alcock@oracle.com>"," dt_dis_stmts(dtrace_hdl_t *dtp, dtrace_prog_t *pgp, dtrace_stmtdesc_t *sdp,
 
 dt_dis_pred(predp, d->fp);
 
-while (ap != NULL) {
+do {
 dt_dis_action(ap, d->fp, fmt);
-ap = ap->dtad_next;
-}
+} while (ap != sdp->dtsd_action_last && (ap = ap->dtad_next) != NULL);
 
 return 0;
 }
",536,90
"dtrace: allow usage of user provided ctf archives

At this moment DTrace looks for vmlinux.ctfa in a hardcoded location
inside the installed kernel modules file tree. In some scenarios
like containerized environments this requires installation of
multiple copies of CTF data on the same host.

New option ctfpath allows user to pass pointer to vmlinux.ctfa
directly and thus share the archive or ship it in non standard
location.

Orabug: 28178265

Signed-off-by: Tomas Jedlicka <tomas.jedlicka@oracle.com>
Reviewed-by: Nick Alcock <nick.alcock@oracle.com>"," dt_kern_module_find_ctf(dtrace_hdl_t *dtp, dt_module_t *dmp)
 char *ctfa_name;
 char *to;
 
-ctfa_name = malloc(strlen(dtp->dt_module_path) +
- strlen(""/kernel/vmlinux.ctfa"") + 1);
-to = stpcpy(ctfa_name, dtp->dt_module_path);
-stpcpy(to, ""/kernel/vmlinux.ctfa"");
+/* use user provided CTF archive. */
+if (dtp->dt_ctfa_path == NULL) {
+ctfa_name = malloc(strlen(dtp->dt_module_path) +
+ strlen(""/kernel/vmlinux.ctfa"") + 1);
+to = stpcpy(ctfa_name, dtp->dt_module_path);
+stpcpy(to, ""/kernel/vmlinux.ctfa"");
+} else {
+ctfa_name = dtp->dt_ctfa_path;
+}
 
 if ((dtp->dt_ctfa = ctf_arc_open(ctfa_name,
  &dtp->dt_ctferr)) == NULL) {
 dt_kern_module_find_ctf(dtrace_hdl_t *dtp, dt_module_t *dmp)
  ctfa_name);
 }
 }
-free(ctfa_name);
+
+if (dtp->dt_ctfa_path == NULL)
+free(ctfa_name);
 }
 
 if (dtp->dt_ctfa != NULL) {
",1170,290
"tests: add some tests for multithreaded processes

These tests verify that tracing an exec()ed multithreaded process does
not hang, and that tracing an exec()ed multithreaded process that
exec()s in the non-main thread does not hang. This which does not
happen even before the recent fix, but that is sensitive to changes in
the behaviour of waitpid() around new threads. This has changed before,
so we should have a test ready for its happening again.

One of these tests requires OMP support in the compiler: all versions of
GCC we have ever supported implement OMP.

Orabug: 28210986
Reviewed-by: Eugene Loh <eugene.loh@oracle.com>","
+/*
+ * Oracle Linux DTrace.
+ * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
+ * Licensed under the Universal Permissive License v 1.0 as shown at
+ * http://oss.oracle.com/licenses/upl.
+ */
+
+#include <stdio.h>
+
+int main(int argc, char **argv)
+{
+ printf(""TEST: start\n"");
+#pragma omp parallel num_threads(2)
+ {
+printf(""TEST: underway\n"");
+ }
+return 0;
+}
",9,1
"Do not leak the dirp and fp on failed library load

We were leaking these every time we failed to load a system library, for
whatever reason.

Orabug: 28247636
Signed-off-by: Nick Alcock <nick.alcock@oracle.com>
Reviewed-by: Tomas Jedlicka <tomas.jedlicka@oracle.com>"," dt_load_libs_dir(dtrace_hdl_t *dtp, const char *path)
 
 dtp->dt_filetag = fname;
 if (dt_lib_depend_add(dtp, &dtp->dt_lib_dep, fname) != 0)
-goto err;
+goto err_close;
 
 rv = dt_compile(dtp, DT_CTX_DPROG,
  DTRACE_PROBESPEC_NAME, NULL,
 dt_load_libs_dir(dtrace_hdl_t *dtp, const char *path)
 if (rv != NULL && dtp->dt_errno &&
  (dtp->dt_errno != EDT_COMPILER ||
  dtp->dt_errtag != dt_errtag(D_PRAGMA_DEPEND)))
-goto err;
+goto err_close;
 
 if (dtp->dt_errno)
 dt_dprintf(""error parsing library %s: %s\n"",
 dt_load_libs_dir(dtrace_hdl_t *dtp, const char *path)
 dt_lib_depend_free(dtp);
 return (0);
 
+err_close:
+(void) fclose(fp);
+(void) closedir(dirp);
 err:
 dt_lib_depend_free(dtp);
 return (-1); /* preserve dt_errno */
",1855,434
"Do not leak the kernel path or dirp

asprintf() allocates its return value itself, so malloc()ing it first
just causes a memory leak.

Also, closedir the dirp properly.

Orabug: 28247636
Signed-off-by: Nick Alcock <nick.alcock@oracle.com>
Reviewed-by: Tomas Jedlicka <tomas.jedlicka@oracle.com>"," dt_find_kernpath(dtrace_hdl_t *dtp, const char *path)
 DIR*dirp;
 
 if ((dirp = opendir(path)) == NULL)
-goto out;
+return NULL;
 
 while ((dp = readdir(dirp)) != NULL) {
 dt_version_t cur_kver;
 dt_find_kernpath(dtrace_hdl_t *dtp, const char *path)
 /* Update the iterator state. */
 kver = cur_kver;
 free(kern_path);
-kern_path = malloc(strlen(path) + strlen(dp->d_name) + 2);
-if (kern_path == NULL)
-goto out;
-
-if (asprintf(&kern_path, ""%s/%s"", path, dp->d_name) < 0)
+if (asprintf(&kern_path, ""%s/%s"", path, dp->d_name) < 0) {
 kern_path = NULL;
+break;
+}
 }
 
-out:
+(void) closedir(dirp);
 return kern_path;
 }
 
",1854,433
"pid: zero-initialize the struct fasttrap_probe_spec

Otherwise we leave some members uninitialized. The kernel happens not
to access those members, but this is a risky thing to rely upon, and
causes valgrind false-positives unless we teach valgrind an unreasonable
amount about the access patterns of this one ioctl().

It is easier just to zero-initialize it consistently.

Orabug: 28247636
Signed-off-by: Nick Alcock <nick.alcock@oracle.com>
Reviewed-by: Tomas Jedlicka <tomas.jedlicka@oracle.com>"," dt_pid_per_sym(dt_pid_probe_t *pp, const GElf_Sym *symp, const char *func)
 
 sz = sizeof (fasttrap_probe_spec_t) + strlen(pp->dpp_name);
 
-if ((ftp = dt_alloc(dtp, sz)) == NULL) {
+if ((ftp = dt_zalloc(dtp, sz)) == NULL) {
 dt_dprintf(""proc_per_sym: dt_alloc(%lu) failed\n"", sz);
 return (1); /* errno is set for us */
 }
",554,125
"Boost the timeout for one consumer test to 60.

It is timing out on some systems.","
 * Check mappings between symbol names and addresses using /proc/kallmodsyms.
 */
 
+/* @@timeout: 60 */
+
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
",241,72
"sparc: waitfd changes for 4.19.

sparc wired up a new syscall, so the waitfd syscall number has changed.

Signed-off-by: Nick Alcock <nick.alcock@oracle.com>
Reviewed-by: Eugene Loh <eugene.loh@oracle.com>","
 /*
 * Oracle Linux DTrace.
- * Copyright (c) 2011, 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
 * Licensed under the Universal Permissive License v 1.0 as shown at
 * http://oss.oracle.com/licenses/upl.
 */

 static struct waitfds_tag {
 unsigned long linux_version_code;
 long waitfd;
-} waitfds[] = { { KERNEL_VERSION(4,14,0), 361 },
+} waitfds[] = { { KERNEL_VERSION(4,19,0), 362 },
+{ KERNEL_VERSION(4,14,0), 361 },
 { KERNEL_VERSION(4,13,0), 361 },
 { KERNEL_VERSION(4,12,0), 361 },
 { KERNEL_VERSION(4,11,0), 361 },
",43,6
"pcap: allow for some distro customization

The unprivileged homedir, unprivileged uid and dumpcap group are all now
set from the top-level makefile, so that distros can customize them.
(If dumpcap is owned by the root group, as some distros have it -- you
can put the privilege boundary there by making dumpcap setuid root --
fall back to using the unprivileged uid as a gid.)

We now require wireshark at build time, because we have to look at the
group ownership of the dumpcap binary.

Orabug: 28953618
Signed-off-by: Nick Alcock <nick.alcock@oracle.com>
Reviewed-by: Alan Maguire <alan.maguire@oracle.com>"," dt_pcap_filename(dtrace_hdl_t *dtp, FILE *fp)
 struct group wsg;
 struct group *dummy;
 char groups[1024];
-gid_t wireshark_group = (gid_t) -3;
+gid_t wireshark_group = (gid_t) UNPRIV_UID;
 
-if (getgrnam_r(""wireshark"", &wsg, groups, 1024, &dummy) >= 0) {
+if (getgrnam_r(DUMPCAP_GROUP, &wsg, groups, 1024, &dummy) >= 0) {
 wireshark_group = wsg.gr_gid;
 }
 
 if (chdir(""/"") < 0)
 goto nopriv_die;
-if (setgid((gid_t) -3) < 0)
+if (setgid(wireshark_group) < 0)
 goto nopriv_die;
 if (setgroups(1, &wireshark_group) < 0)
 goto nopriv_die;
-if (setuid((uid_t) -3) < 0)
+if (setuid((uid_t) UNPRIV_UID) < 0)
 goto nopriv_die;
 }
 
 dt_pcap_filename(dtrace_hdl_t *dtp, FILE *fp)
  */
 clearenv();
 putenv(""PATH=/usr/sbin:/usr/bin:/sbin:/bin"");
-putenv(""HOME=/run/initramfs"");
+putenv(""HOME="" UNPRIV_HOME);
 putenv(""SHELL=/bin/sh"");
 putenv(""USER=nobody"");
 
",289,54
"pcap: mask SIGINT in tshark child

Alan's original submission prevented SIGINT submission to tshark by
setsid(). I took this out because it seemed unnecessary, but after
recent changes to detect tshark dying and switch to tracemem output
dynamically it has become clear that we are subject to a race when
DTrace is interrupted, where tshark can die before the DTrace probes
have emptied, and then it sprays a pile of tracemem output at the
screen.

So mask SIGINT (the only signal the user is likely to interrupt us with)
before invoking tshark.

Orabug: 28953618
Signed-off-by: Nick Alcock <nick.alcock@oracle.com>
Reviewed-by: Alan Maguire <alan.maguire@oracle.com>"," dt_pcap_filename(dtrace_hdl_t *dtp, FILE *fp)
 pid = fork();
 switch (pid) {
 case 0: {
+/*
+ * Mask SIGINT. DTrace will close the pipes to tshark when it is
+ * interrupted. (We must do this to avoid a race at termination
+ * time: if tshark dies first, then any more data flowing
+ * into the pcap action will be printed as tracemem output,
+ * which users will not expect.)
+ */
+sigset_t mask;
+
+sigemptyset(&mask);
+sigaddset(&mask, SIGINT);
+pthread_sigmask(SIG_BLOCK, &mask, NULL);
+
 /*
  * Set up our pipes.
  */
 dt_pcap_filename(dtrace_hdl_t *dtp, FILE *fp)
 putenv(""SHELL=/bin/sh"");
 putenv(""USER=nobody"");
 
-
 execlp(""tshark"", ""tshark"", ""-l"", ""-i"", ""-"", NULL);
 nopriv_die:
 fprintf(stderr, ""Cannot drop privileges or exec tshark: %s\n"",
",293,54
"pcap: do not dynamically-allocate the trace filename

The trace filename is dynamically-allocated by the freopen() code when
freopen() is in use: there is no need to re-dup it when figuring out the
trace filename, and doing so leads to a memory leak since we never try
to free the return value of dt_pcap_filename().

Orabug: 29036502
Signed-off-by: Nick Alcock <nick.alcock@oracle.com>
Reviewed-by: Kris Van Hees <kris.van.hees@oracle.com>"," dt_print_pcap(dtrace_hdl_t *dtp, FILE *fp, dtrace_recdesc_t *rec,
 caddr_tpaddr, addr;
 const dtrace_recdesc_t *prec;
 uint64_t time, proto, pktlen, maxlen;
-char *filename;
+const char *filename;
 
 addr = (caddr_t)buf + rec->dtrd_offset;
 
",1727,463
"Fix for makedev() usage in glibc 2.28

glibc 2.28 migrates major(), minor() and makedev() out of <sys/types.h>:
they are still available in <sys/sysmacros.h>. These macros have been
defined in this header since time immemorial, so we don't need to allow
for earlier versions of glibc lacking it.

Orabug: 29196221
Signed-off-by: Nick Alcock <nick.alcock@oracle.com>","
 #include <libgen.h>
 #include <sys/types.h>
 #include <sys/stat.h>
+#include <sys/sysmacros.h>
 #include <sys/ptrace.h>
 #include <port.h>
 #include <setjmp.h>
",1436,390
"hyphenation: avoid overlapping memcpy()

Valgrind shows that strhyphenate() is routinely called with overlapping
args (since of course it is, to hyphenate an existing string). Use
memmove() to do so, not memcpy().

Signed-off-by: Nick Alcock <nick.alcock@oracle.com>
Reviewed-by: Eugene Loh <eugene.loh@oracle.com>"," strhyphenate(char *s)
 for (p = s, q = p + strlen(p); p < q; p++) {
 if (p[0] == '_' && p[1] == '_') {
 p[0] = '-';
-memcpy(p + 1, p + 2, (size_t)(q - p) - 1);
+memmove(p + 1, p + 2, (size_t)(q - p) - 1);
 }
 }
 
",230,86
"libproc: drop the prf_data_map

This is not used anywhere, and just makes already tangled data
structures even more tangled.

Signed-off-by: Nick Alcock <nick.alcock@oracle.com>"," Pupdate_maps(struct ps_prochandle *P)
 pmptr->pr_mflags |= MA_READ;
 if (perms[1] == 'w') {
 pmptr->pr_mflags |= MA_WRITE;
-if (prf->prf_data_map == NULL)
-prf->prf_data_map = pmptr;
 }
 if (perms[2] == 'x') {
 char *basename = strrchr(prf->prf_mapname, '/');
",1433,389
"libproc: finding no namespaces at all implies not grokking glibc

If we should find that dl_nns is zero, we can be sure that we don't
understand glibc: fall back to ordinary symbol table lookup.
(dl_nns is statically initialized to 1 in rtld.c literally at compile
time, and is never decremented below 1.)

Signed-off-by: Nick Alcock <nick.alcock@oracle.com>
Reviewed-by: Kris Van Hees <kris.van.hees@oracle.com>
Orabug: 29589029"," dl_nns(rd_agent_t *rd)
 return 1;
 }
 
+if (buf == 0) {
+_dprintf(""%i: zero namespaces, probably incompatible glibc\n"",
+ rd->P->pid);
+rd->lmid_incompatible_glibc = 1;
+return 1;
+}
+
 return buf;
 }
 
",952,261
"tests, pldd: filter out the vDSO on later glibc versions

pldd filters out the vDSO by looking for a loadable object with no
search path and no name. This is not enough for later glibc versions,
which set the name: so also filter out loadable objects with no
search path that happen to be the second one in the list. (Even this is
more rigorous than what libproc actually does, which is just to say
""if it's the second one in the list, it's the vDSO"". This is dangerously
loose, and will be fixed in the next commit.)

Signed-off-by: Nick Alcock <nick.alcock@oracle.com>
Reviewed-by: Kris Van Hees <kris.van.hees@oracle.com>
Orabug: 29589029"," print_ldd(const rd_loadobj_t *loadobj, size_t num, void *state)
 if (buf[0] == '\0' && loadobj->rl_nscopes == 1)
 return (1);
 
+ /*
+ * Second item, no search path: vDSO (later glibc version).
+ */
+ if ((num == 1) && (loadobj->rl_nscopes == 1))
+return (1);
+
 printf(""%s: dyn 0x%lx, bias 0x%lx, LMID %li: %s ("", buf, loadobj->rl_dyn,
  loadobj->rl_diff_addr, loadobj->rl_lmident, loadobj->rl_default_scope ?
  ""inherited symbol search path: "": ""symbol search path: "");
 note_ldd(const rd_loadobj_t *loadobj, size_t num, void *state)
 if (buf[0] == '\0' && loadobj->rl_nscopes == 1)
 return (1);
 
+ /*
+ * Second item, no search path: vDSO (later glibc version).
+ */
+ if ((num == 1) && (loadobj->rl_nscopes == 1))
+return (1);
+
 libs_seen++;
 return (1);
 }
",129,31
"libproc: shared objects with a search path cannot be the vDSO

Simply declaring that the vDSO is the second item in the search path is
dangerous: while it is always second if present (a restriction enforced
by the kernel and depended on by glibc), the vDSO might not even be
enabled, and then we skip a completely random shared library.

So only skip the vDSO if this looks likely to be the vDSO. Normal
shared objects always have a search path with length > 1, so we can
use a shorter search path as a more reliable heuristic than the purely
positional one we're using now.

Signed-off-by: Nick Alcock <nick.alcock@oracle.com>
Reviewed-by: Kris Van Hees <kris.van.hees@oracle.com>
Orabug: 29589029"," map_iter(const rd_loadobj_t *lop, size_t num, void *prochandle)
 return (1);
 }
 }
-else if (num == 1) {
+else if ((num == 1) && (lop->rl_nscopes == 1)) {
 _dprintf(""map_iter: skipping vdso\n"");
 return (1);
 } else if (lop->rl_dyn == 0)
",1446,392
"libproc: further armouring against invalid DL_NNS values

We know that you can't have no namespaces, but namespaces in glibc are a
small static resource, and we know we know its maximum (because if that
maximum changes, it changes the offsets of stuff in rtld_global that we
need so we *have* to adapt).

So export the maximum number of namespaces to libproc and check it: if
there are more namespaces than that, we know we aren't looking at the
namespace count, or glibc has bumped its DL_NNS value and we must
adapt. (This is a bitness-independent value.)

Suggested-by: Eugene Loh <eugene.loh@oracle.com>
Signed-off-by: Nick Alcock <nick.alcock@oracle.com>
Orabug: 29589029"," dl_nns(rd_agent_t *rd)
 return 1;
 }
 
-if (buf == 0) {
-_dprintf(""%i: zero namespaces, probably incompatible glibc\n"",
- rd->P->pid);
+if ((buf == 0) || (buf > DL_NNS)) {
+_dprintf(""%i: %li namespaces is not valid: ""
+ ""probably incompatible glibc\n"", rd->P->pid, buf);
 rd->lmid_incompatible_glibc = 1;
 return 1;
 }
",952,262
"ctf_module_dump: rename a conflicting function name

libdtrace-ctf introduces a new ctf_dump function: rename the
identically-named function in the ctf_module_dump utility to avoid a
compilation failure.

Signed-off-by: Nick Alcock <nick.alcock@oracle.com>"," find_module_ctf(const char *name)
 * Dump the CTF in the given module.
 */
 static void
-ctf_dump(const char *name)
+ctf_module_dump(const char *name)
 {
 FILE *parent_fp = find_module_ctf(NULL);
 FILE *child_fp = NULL;
 main(int argc, char *argv[])
 }
 
 while (optind < argc)
-ctf_dump(argv[optind++]);
+ctf_module_dump(argv[optind++]);
 
 while ((dkpp = dt_list_next(&dtp->dt_kernpathlist)) != NULL)
 dtrace__internal_kern_path_destroy(dtp, dkpp);
",219,46
"dtrace: clean up gcc compiler warnings on x86 (gcc9)

Compilation of DTrace userspace with GCC 9 introduces new compilation
warnings:
 warning: '%s' directive argument is null [-Wformat-overflow=]

The problem is there are places where a ""%s"" format directive is used
with a pointer that nearby code and static examination of caller indicate
could be NULL.

Replace a potentially null pointer with an expression that reports
a meaningful string when the pointer is null.

[Orabug: 29683176]
Signed-off-by: Eugene Loh <eugene.loh@oracle.com>
Reviewed-by: Nick Alcock <nick.alcock@oracle.com>"," dt_proc_notify(dtrace_hdl_t *dtp, dt_proc_hash_t *dph, dt_proc_t *dpr,
 
 if (dprn == NULL) {
 dt_dprintf(""failed to allocate notification for %d %s\n"",
- (int)dpr->dpr_pid, msg);
+ (int)dpr->dpr_pid, msg ? msg : """");
 } else {
 dprn->dprn_dpr = dpr;
 if (msg == NULL)
",1230,253
"Convert the D compiler to generate BPF

- Force the D compiler to compile entire clauses (does not work when the
 clause uses actions like trace).
- Change from dif_instr_t to struct bpf_insn.
- Add macros to generate PF instructions.
- Update the compiler, code generator and assembler to deal with BPF.
- Update the disassembler to handle BPF.

Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>"," dtrace_handle_err(dtrace_hdl_t *dtp, dtrace_handle_err_f *hdlr, void *arg)
 if (dtp->dt_options[DTRACEOPT_GRABANON] != DTRACEOPT_UNSET)
 goto out;
 
+#if 0
 if ((pgp = dtrace_program_strcompile(dtp, _dt_errprog,
  DTRACE_PROBESPEC_NAME, DTRACE_C_ZDEFS, 0, NULL)) == NULL)
 return (dt_set_errno(dtp, dtrace_errno(dtp)));
 dtrace_handle_err(dtrace_hdl_t *dtp, dtrace_handle_err_f *hdlr, void *arg)
 edp = stp->ds_desc->dtsd_ecbdesc;
 assert(edp != NULL);
 edp->dted_uarg = DT_ECB_ERROR;
+#endif
 
 out:
 dtp->dt_errhdlr = hdlr;
",343,55
"Use MOV instead of LDDW when value is less than UINT32_MAX

When a constant value is being assigned to a register we can use a MOV
instruction with the value as immediate value rather than a LDDW. The
LDDW takes up 2 instruction slots whereas MOV is a single instruction
slot.

Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>"," dt_cg_node(dt_node_t *dnp, dt_irlist_t *dlp, dt_regset_t *drp)
 if ((dnp->dn_reg = dt_regset_alloc(drp)) == -1)
 longjmp(yypcb->pcb_jmpbuf, EDT_NOREG);
 
-dt_cg_setx(dlp, dnp->dn_reg, dnp->dn_value);
+if (dnp->dn_value > UINT32_MAX)
+dt_cg_setx(dlp, dnp->dn_reg, dnp->dn_value);
+else {
+instr = BPF_MOV_IMM(dnp->dn_reg, dnp->dn_value);
+dt_irlist_append(dlp,
+ dt_cg_node_alloc(DT_LBL_NONE, instr));
+}
 break;
 
 default:
",1257,265
"Handle empty clauses.

Specifying a probe with an empty clause caused a SEGV because the code
generator tried to free a register associated with the clause. Since the
clause is empty, no register is ever allocated and the register index that
is being free'd is -1, which is not a valid register.

The solution is trivial: when the clause is empty, there is no need to
invoke the code generator.

Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>"," dt_compile_one_clause(dtrace_hdl_t *dtp, dt_node_t *cnp, dt_node_t *pnp)
 }
 
 #if 1
-assert(yypcb->pcb_stmt == NULL);
-sdp = dt_stmt_create(dtp, edp, cnp->dn_ctxattr, cnp->dn_attr);
-dt_compile_entire_clause(dtp, cnp, sdp);
-assert(yypcb->pcb_stmt == sdp);
-dt_stmt_append(sdp, cnp);
+if (cnp->dn_acts != NULL) {
+assert(yypcb->pcb_stmt == NULL);
+sdp = dt_stmt_create(dtp, edp, cnp->dn_ctxattr, cnp->dn_attr);
+dt_compile_entire_clause(dtp, cnp, sdp);
+assert(yypcb->pcb_stmt == sdp);
+dt_stmt_append(sdp, cnp);
+}
 #else
 for (dnp = cnp->dn_acts; dnp != NULL; dnp = dnp->dn_list) {
 assert(yypcb->pcb_stmt == NULL);
",1910,442
"Add support for loading and storing global variables.

Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>"," dt_cg_node(dt_node_t *dnp, dt_irlist_t *dlp, dt_regset_t *drp)
 
 dnp->dn_ident->di_flags |= DT_IDFLG_DIFR;
 
+/* FIXME */
+if (base == 0x3000) {
+instr = BPF_ALU64_IMM(BPF_MOV, dnp->dn_reg, dnp->dn_ident->di_id);
+dt_irlist_append(dlp, dt_cg_node_alloc(DT_LBL_NONE, instr));
+instr = BPF_CALL_FUNC(1234);/* u64 dt_get_gvar(id) */
+dt_irlist_append(dlp, dt_cg_node_alloc(DT_LBL_NONE, instr));
+instr = BPF_ALU64_REG(BPF_MOV, dnp->dn_reg, BPF_REG_0);
+dt_irlist_append(dlp, dt_cg_node_alloc(DT_LBL_NONE, instr));
+} else {
 instr = BPF_LOAD(BPF_DW, dnp->dn_reg, BPF_REG_FP,
  base + dnp->dn_ident->di_id);
-
 dt_irlist_append(dlp,
  dt_cg_node_alloc(DT_LBL_NONE, instr));
+}
 break;
 }
 
",1266,266
"Bump dtrace and libdtrace version to 2.0.0.

The BPF-based DTrace implementation starts at version 2.0.0.

Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>","
 #defineDT_VERS_1_6_2DT_VERSION_NUMBER(1, 6, 2)
 #defineDT_VERS_1_6_3DT_VERSION_NUMBER(1, 6, 3)
 #defineDT_VERS_1_6_4DT_VERSION_NUMBER(1, 6, 4)
-#defineDT_VERS_LATESTDT_VERS_1_6_4
-#defineDT_VERS_STRING""Sun D 1.6.4""
+#defineDT_VERS_2_0_0DT_VERSION_NUMBER(2, 0, 0)
+#defineDT_VERS_LATESTDT_VERS_2_0_0
+#defineDT_VERS_STRING""Oracle D 2.0.0""
 
 const dt_version_t _dtrace_versions[] = {
 DT_VERS_1_0,/* D API 1.0.0 (PSARC 2001/466) Solaris 10 FCS */
 const dt_version_t _dtrace_versions[] = {
 DT_VERS_1_6_2,/* D API 1.6.2 */
 DT_VERS_1_6_3,/* D API 1.6.3 */
 DT_VERS_1_6_4,/* D API 1.6.4 */
+DT_VERS_2_0_0,/* D API 2.0.0 */
 0
 };
 
",1006,130
"Remove call to load DTrace kernel modules.

The re-implementation of DTrace based on eBPF no longer requires specific
DTrace kernel modules to be loaded when userspace starts.

Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>"," main(int argc, char *argv[])
 dtrace_optval_t opt;
 dtrace_cmd_t *dcp;
 
-int done = 0, mode = 0, tried_loading = 0;
+int done = 0, mode = 0;
 int err, i, c;
 char *p, **v;
 pid_t pid;
 main(int argc, char *argv[])
 continue;
 }
 
- if (!tried_loading) {
-const char *libdir = DTRACE_LIBDIR;
-char *script;
-
-if (getenv(""DTRACE_OPT_SYSLIBDIR"") != NULL)
-libdir = getenv(""DTRACE_OPT_SYSLIBDIR"");
-
-if (asprintf(&script, ""%s/%s"", libdir,
-""load_dtrace_modules"") >= 0) {
-tried_loading = 1;
-
-if (system(script) == 0) {
-free(script);
-continue;
-}
-free(script);
-}
-g_oflags &= ~DTRACE_O_NODEV;
- }
-
 fatal(""failed to initialize dtrace: %s\n"",
  dtrace_errmsg(NULL, err));
 }
",1118,271
"Remove integer table support.

DTrace used to store integer constants in an integer table, to allow long
integers to be encoded in instructions using less bits. In BPF we can
assign values directly using a MOV instruction (up to 32-bit) or a LDDW
instruction (64-bit). There is no need for the integer table anymore.

Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>"," dt_as(dt_pcb_t *pcb)
 dp->dtdo_strlen = (uint32_t)n;
 }
 
-/*
- * Allocate memory for the compiled integer table and then copy the
- * integer constants from the table into the final integer buffer.
- */
-if ((n = dt_inttab_size(pcb->pcb_inttab)) != 0) {
-if ((dp->dtdo_inttab = dt_alloc(dtp,
- n * sizeof (uint64_t))) == NULL)
-longjmp(pcb->pcb_jmpbuf, EDT_NOMEM);
-
-dt_inttab_write(pcb->pcb_inttab, dp->dtdo_inttab);
-dp->dtdo_intlen = (uint32_t)n;
-}
-
 /*
  * Fill in the DIFO return type from the type associated with the
  * node saved in pcb_dret, and then clear pcb_difo and pcb_dret
",316,80
"Import a partial libbpf to interact with the kernel.

This is a modified (reduced) libbpf as found in the tools/lib/bpf
directory of the kernel. It also contains a handful of header files
from tools/include that are necessary to build libbpf.

The libdtrace.so shared library is linked with the static library
libbpf.a.

Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>","
+// SPDX-License-Identifier: (LGPL-2.0+ OR BSD-2-Clause)
+/* Copyright (C) 2018 Netronome Systems, Inc. */
+
+#ifndef __TOOLS_LIBC_COMPAT_H
+#define __TOOLS_LIBC_COMPAT_H
+
+#include <stdlib.h>
+#include <linux/overflow.h>
+
+#ifdef COMPAT_NEED_REALLOCARRAY
+static inline void *reallocarray(void *ptr, size_t nmemb, size_t size)
+{
+size_t bytes;
+
+if (unlikely(check_mul_overflow(nmemb, size, &bytes)))
+return NULL;
+return realloc(ptr, bytes);
+}
+#endif
+#endif
",9,2
"Remove includes of <sys/dtrace.h> where it is not needed.

Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>","
 #include <string.h>
 #include <unistd.h>
 #include <sys/utsname.h>
-
 #include <sys/dtrace.h>
 
 #ifndef SHT_SUNW_dof
",310,52
"Convert dtrace_probedesc_t to the new form (with char * members).

The dtrace_probedesc_t used to contain statically sized character arrays
to store the module name, function name, and probe name. In the new
implementation, these members are now allocated character strings.

Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>","
 /*
 * Oracle Linux DTrace.
- * Copyright (c) 2005, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.
 * Licensed under the Universal Permissive License v 1.0 as shown at
 * http://oss.oracle.com/licenses/upl.
 */
 dt_dis_stmts(dtrace_hdl_t *dtp, dtrace_prog_t *pgp, dtrace_stmtdesc_t *sdp,
 dtrace_probedesc_t *pdp = &sdp->dtsd_ecbdesc->dted_probe;
 
 fprintf(d->fp, ""\nDisassembly of %s:%s:%s:%s\n"",
- pdp->dtpd_provider, pdp->dtpd_mod, pdp->dtpd_func, pdp->dtpd_name);
+pdp->prv, pdp->mod, pdp->fun, pdp->prb);
 d->last_ecb = sdp->dtsd_ecbdesc;
 }
 
",550,88
"Fix potential string truncation issue.

The utsdef variable was declared as a char[32] array, but the utsname
written to it (with a prefix) can be up to 64 characters long.

Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>"," dt_vopen(int version, int flags, int *errp,
 ctf_funcinfo_t ctc;
 ctf_arinfo_t ctr;
 
-char isadef[32], utsdef[32];
+char isadef[32], utsdef[4 + sizeof(dtp->dt_uts.sysname)];
 
 if (version <= 0)
 return (set_open_errno(dtp, errp, EINVAL));
 dt_vopen(int version, int flags, int *errp,
 
 dtp->dt_cpp_argv[0] = (char *)strbasename(dtp->dt_cpp_path);
 
-(void) snprintf(isadef, sizeof (isadef), ""-D__SUNW_D_%u"",
+snprintf(isadef, sizeof(isadef), ""-D__SUNW_D_%u"",
  (uint_t)(sizeof (void *) * NBBY));
 
-(void) snprintf(utsdef, sizeof (utsdef), ""-D__%s"",
- dtp->dt_uts.sysname);
+snprintf(utsdef, sizeof(utsdef), ""-D__%s"", dtp->dt_uts.sysname);
 
 if (dt_cpp_add_arg(dtp, ""-D__linux"") == NULL ||
  dt_cpp_add_arg(dtp, ""-D__unix"") == NULL ||
",910,105
"Adjust code to structure changes in dtrace_probedesc_t.

The change from statically sized character arrays for probe name elements
to const char pointers has some far reaching impact on the userspace code.
This patch adjusts code in various areas (incl. libproc) to account for
this.

These strings can originate in various places (where they are allocated),
and are free'd once we are done with them. The places where we free them
are indicated with comments and a cast to char * to keep the compiler
quiet.

Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>"," dt_aggregate_usym(dtrace_hdl_t *dtp, uint64_t *data)
 if (pid < 0)
 return;
 
-if (dt_Plookup_by_addr(dtp, pid, *pc, NULL, 0, &sym) == 0)
+if (dt_Plookup_by_addr(dtp, pid, *pc, NULL, &sym) == 0)
 *pc = sym.st_value;
 
 dt_proc_release_unlock(dtp, pid);
",1298,309
Add str2hval to calculate hash value for a string.,"
 
 #include <string.h>
 #include <stdlib.h>
+#include <stdint.h>
 #include <errno.h>
 #include <ctype.h>
 
 #include <dt_string.h>
 
+/*
+ * Calculate a hash value based on a given string and an initial value. The
+ * initial value is used to calculate compound hash values, e.g.
+ *
+ * uint32_t hval;
+ *
+ * hval = str2hval(str1, 0);
+ * hval = str2hval(str2, hval);
+ */
+uint32_t str2hval(const char *p, uint32_t hval)
+{
+uint32_t g;
+
+if (!p)
+return hval;
+
+while (*p) {
+hval = (hval << 4) + *p++;
+g = hval & 0xf0000000;
+if (g != 0)
+hval ^= g >> 24;
+
+hval &= ~g;
+}
+
+return hval;
+}
+
 /*
 * Transform string s inline, converting each embedded C escape sequence string
 * to the corresponding character. For example, the substring ""\n"" is replaced
",245,90
"Split probe implementation from provider implementation.

The implementation of probe-specific functionality creating new probes,
probe lookup, ...) was included in the provider implementation in the
dt_provider.c source code file. Since all provider and probe handling
is not being done at the userspace level, it makes sense to split them
up. This improves code clarity and it makes it easier to know where to
look for the implementation details of provider and probe handling.

Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>","
 #include <dt_pcap.h>
 #include <dt_program.h>
 #include <dt_provider.h>
+#include <dt_probe.h>
 #include <dt_printf.h>
 #include <dt_pid.h>
 #include <dt_grammar.h>
",1914,441
"Manage the collection of available probes in userspace.

Where previously, the list of probes (and related datastructures and
management code) was handled in the kernel, DTrace will now do all this
work in userspace. The list of probes and the hashtables to facilitate
fast probe lookup will now be kept in the dtrace library handle.

Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>"," list_stmt(dtrace_hdl_t *dtp, dtrace_prog_t *pgp,
 if (edp == *last)
 return (0);
 
-if (dtrace_probe_iter(g_dtp, &edp->dted_probe, list_probe, NULL) != 0) {
+if (dtrace_probe_iter(g_dtp, &edp->dted_probe, list_probe, NULL) < 0) {
 error(""failed to match %s:%s:%s:%s: %s\n"",
  edp->dted_probe.prv, edp->dted_probe.mod,
  edp->dted_probe.fun, edp->dted_probe.prb,
 main(int argc, char *argv[])
 list_prog(&g_cmdv[i]);
 
 if (g_cmdc == 0)
-(void) dtrace_probe_iter(g_dtp, NULL, list_probe, NULL);
+dtrace_probe_iter(g_dtp, NULL, list_probe, NULL);
 
 dtrace_close(g_dtp);
 return (g_status);
",1111,270
"Fix a potential memory leak.

When a new probe is being inserted into the probes catalog, the desc
allocation may succeed while the dt_probe_t allocation fails. That would
leak the memory taken up by desc.

Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>"," dt_probe_insert(dtrace_hdl_t *dtp, dt_provider_t *prov, const char *prv,
 dt_probe_t*prp;
 dtrace_probedesc_t*desc;
 
-if ((desc = dt_alloc(dtp, sizeof(dtrace_probedesc_t))) == NULL)
-return NULL;
-
-desc->id = DTRACE_IDNONE;
-desc->prv = strdup(prv);
-desc->mod = strdup(mod);
-desc->fun = strdup(fun);
-desc->prb = strdup(prb);
-
 /* If necessary, grow the probes array. */
 if (dtp->dt_probe_id + 1 > dtp->dt_probes_sz) {
 dt_probe_t **nprobes;
 dt_probe_insert(dtrace_hdl_t *dtp, dt_provider_t *prov, const char *prv,
 if ((prp = dt_zalloc(dtp, sizeof(dt_probe_t))) == NULL)
 return NULL;
 
+if ((desc = dt_alloc(dtp, sizeof(dtrace_probedesc_t))) == NULL) {
+dt_free(dtp, prp);
+return NULL;
+}
+
 desc->id = dtp->dt_probe_id++;
+desc->prv = strdup(prv);
+desc->mod = strdup(mod);
+desc->fun = strdup(fun);
+desc->prb = strdup(prb);
+
 prp->desc = desc;
 prp->prov = prov;
 
",779,181
"Emit disassembly for predicate even if there are no actions.

Previously, the disassembler would not produce any output if there were
no actions associated with it, even if there was a predicate. An ECB
with predicate but no actions can be used to trace the probe firing
event (without extra data) under conditions set in the predicate.

This patch ensures that disassembly is produced for any and all code in
the ECB, predicate and/or actions.

Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>"," dt_dis_stmts(dtrace_hdl_t *dtp, dtrace_prog_t *pgp, dtrace_stmtdesc_t *sdp,
 dtrace_actdesc_t *ap = sdp->dtsd_action;
 const char *fmt = NULL;
 
-if (ap == NULL)
+if (predp == NULL && ap == NULL)
 return 0;
 
 if (d->last_ecb != sdp->dtsd_ecbdesc) {
 dt_dis_stmts(dtrace_hdl_t *dtp, dtrace_prog_t *pgp, dtrace_stmtdesc_t *sdp,
 
 dt_dis_pred(predp, d->fp);
 
-do {
+while (ap) {
 dt_dis_action(ap, d->fp, fmt);
-} while (ap != sdp->dtsd_action_last && (ap = ap->dtad_next) != NULL);
+
+if (ap == sdp->dtsd_action_last)
+break;
+
+ap = ap->dtad_next;
+}
 
 return 0;
 }
",553,90
"Suppress parse tree (pass 3) output when parsing failed badly.

Sometimes, parsing of the input fails so badly that there is no result
whatsoever. In that case, pass 1 and 2 parse trees are skipped, yet the
pass 3 parse tree output (when -xtree=4 is supplied) was still being
generated (or at least an attempt was made). WHen parsing failed
completely, there is no tree to dump and we ended up with a NULL pointer
dereference.

This patch ensures that dtrace does not try to dump a parse tree when
the root of the tree is NULL.

Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>"," dt_compile(dtrace_hdl_t *dtp, int context, dtrace_probespec_t pspec, void *arg,
 }
 
 out:
-if (context != DT_CTX_DTYPE && DT_TREEDUMP_PASS(dtp, 3)) {
+if (context != DT_CTX_DTYPE && DT_TREEDUMP_PASS(dtp, 3) &&
+ yypcb->pcb_root) {
 fprintf(stderr, ""Parse tree (Pass 3):\n"");
 dt_node_printr(yypcb->pcb_root, stderr, 1);
 }
",1915,442
"Allow freeing %r0 from the regset.

The %r0 register is a valid general purpose register, along with also
being the register for passing a return value. It can be allocated for
use, and therefore we can also free it.

Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>"," dt_regset_alloc(dt_regset_t *drp)
 void
 dt_regset_free(dt_regset_t *drp, int reg)
 {
-assert(reg > 0 && reg < drp->dr_size);
+assert(reg >= 0 && reg < drp->dr_size);
 assert(BT_TEST(drp->dr_bitmap, reg) != 0);
 BT_CLEAR(drp->dr_bitmap, reg);
 }
",65,14
"Encode built-in BPF functions by id and emit names in disassembler.

Since various operations are being implemented as BPF functions, we need
to store the function id in the call instruction (to be patched later
with the actual function instruction offset. Disasembler output will
display the proper function name.

This patch also provides a more useful comment for instructions that
access thread-local and clause-local variables, indicating the scope of
the variable rather than just the name.

Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>","
+/*
+ * Oracle Linux DTrace.
+ * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
+ * Licensed under the Universal Permissive License v 1.0 as shown at
+ * http://oss.oracle.com/licenses/upl.
+ */
+
+#include <dt_impl.h>
+#include <dt_bpf_funcs.h>
+
+const char *
+dt_bpf_fname(int id)
+{
+switch (id) {
+case DT_BPF_GET_GVAR:
+return ""get_gvar"";
+case DT_BPF_SET_GVAR:
+return ""set_gvar"";
+case DT_BPF_GET_TVAR:
+return ""get_tvar"";
+case DT_BPF_SET_TVAR:
+return ""set_tvar"";
+#if 1 /* DEBUGGING */
+case DIF_OP_PUSHTR:
+return ""pushtr"";
+case DIF_OP_PUSHTV:
+return ""pushtv"";
+#endif
+default:
+return ""<unknown>"";
+}
+}
",22,8
"Implement actions as function calls.

The interpretation of actions changes in the new DTrace design. Since
they appear as function calls in the D syntax, it makes sense to make
them actual function calls in the eBPF-based design.

Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>"," dt_dis_call(const dtrace_difo_t *dp, const char *name,
 ann = dt_dis_bpf_args(dp, in->imm, in, buf, sizeof(buf));
 } else if (in->imm >= 0 && in->imm < __BPF_FUNC_MAX_ID) {
 fn = helper_fn[in->imm];
-} else
-fn = ""unknown"";
+} else {
+snprintf(buf, sizeof(buf), ""helper#%d"", in->imm);
+fn = buf;
+ann = ""unknown helper"";
+}
 
 if (ann)
 fprintf(fp, ""%-4s %-17s ! %s"", name, fn, ann);
",595,99
"Add support for loading strings from the string table.

This patch implements retrieving a pointer to a string from the string
table. It also adds support for listing the get_string() function in
the disassembler output, along with an annotation of the string constant.

Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>"," dt_bpf_fname(int id)
 return ""get_tvar"";
 case DT_BPF_SET_TVAR:
 return ""set_tvar"";
+case DT_BPF_GET_STRING:
+return ""get_string"";
 #if 1 /* DEBUGGING */
 case DIF_OP_PUSHTR:
 return ""pushtr"";
",24,9
"Escape characters in strings in disassembler output.

When printing strings as comments in disassembler output, convert any
special characters in C-style escape sequences.

Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>","
 #include <dt_impl.h>
 #include <dt_ident.h>
 #include <dt_printf.h>
+#include <dt_string.h>
 #include <dt_bpf_funcs.h>
 #include <bpf_asm.h>
 
 static char *
 dt_dis_bpf_args(const dtrace_difo_t *dp, uint_t id, const struct bpf_insn *in,
 char *buf, size_t len)
 {
+char *s;
+
 switch (id) {
 case DT_BPF_GET_GVAR:
 case DT_BPF_SET_GVAR:
 dt_dis_bpf_args(const dtrace_difo_t *dp, uint_t id, const struct bpf_insn *in,
 if (in->imm >= dp->dtdo_strlen)
 return NULL;
 
-snprintf(buf, len, ""\""%s\"""", dp->dtdo_strtab + in->imm);
+s = dp->dtdo_strtab + in->imm;
+s = strchr2esc(s, strlen(s));
+snprintf(buf, len, ""\""%s\"""", s ? s : dp->dtdo_strtab + in->imm);
+free(s);
 return buf;
 default:
 return NULL;
",606,102
Update copyright statements.,"
 /*
 * Oracle Linux DTrace.
- * Copyright (c) 2008, 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2008, 2019, Oracle and/or its affiliates. All rights reserved.
 * Licensed under the Universal Permissive License v 1.0 as shown at
 * http://oss.oracle.com/licenses/upl.
 */
",1298,309
"Distinguish between a D expression and an output generating action.

The parse tree output (for debugging purposes) was displaying plain D
expressions and output generating actions (trace, printf, ...) all as
D expressions. With this patch output generating actions will be shown
as 'D GENERATOR' nodes rather than 'D EXPRESSION' nodes.

Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>"," dt_node_printr(dt_node_t *dnp, FILE *fp, int depth)
 break;
 
 case DT_NODE_DEXPR:
-case DT_NODE_DFUNC:
 (void) fprintf(fp, ""D EXPRESSION attr=%s\n"", a);
 dt_node_printr(dnp->dn_expr, fp, depth + 1);
 break;
 
+case DT_NODE_DFUNC:
+(void) fprintf(fp, ""D PRODUCER attr=%s\n"", a);
+dt_node_printr(dnp->dn_expr, fp, depth + 1);
+break;
+
 case DT_NODE_AGG:
 (void) fprintf(fp, ""AGGREGATE @%s attr=%s [\n"",
  dnp->dn_ident->di_name, a);
",3454,1002
"Add support for precompiled BPF code libraries.

Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>","
 #include <dt_parser.h>
 #include <dt_provider.h>
 #include <dt_probe.h>
-#include <dt_bpf_funcs.h>
+#include <dt_bpf_builtins.h>
 #include <bpf_asm.h>
 
 static void dt_cg_node(dt_node_t *, dt_irlist_t *, dt_regset_t *);
",1661,319
"Fix disassembler output for negative offset in load and store

The disassembler was not properly accounting for the 16-bit size of
the offset field in BPF instructions which caused messed up output
for load and store instructions where the offset was negative.

Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>"," dt_dis_difo(const dtrace_difo_t *dp, FILE *fp)
 if (opcode >= sizeof (optab) / sizeof (optab[0]))
 opcode = 0; /* force invalid opcode message */
 
-fprintf(fp, ""%03lu %03lu: %02x %01x %01x %04x %08x "",
+fprintf(fp, ""%03lu %03lu: %02hhx %01hhx %01hhx %04hx %08x "",
 i, i*8, instr->code, instr->dst_reg, instr->src_reg,
 instr->off, instr->imm);
 if (instr->code != 0) {
",613,103
"Implement local variables on the stack

Local variables are stored on the stack. Up to 22 local variables are
currently supported. Only support for scalar types is supported (i.e.
no strings).

Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>"," dt_compile(dtrace_hdl_t *dtp, int context, dtrace_probespec_t pspec, void *arg,
 
 yypcb->pcb_idents = dt_idhash_create(""ambiguous"", NULL, 0, 0);
 yypcb->pcb_locals = dt_idhash_create(""clause local"", NULL,
- DIF_VAR_OTHER_UBASE, DIF_VAR_OTHER_MAX);
+ 0, DT_VAR_LOCAL_MAX);
 
 if (yypcb->pcb_idents == NULL || yypcb->pcb_locals == NULL)
 longjmp(yypcb->pcb_jmpbuf, EDT_NOMEM);
",1631,376
"Generate clause predicates as functions

The clause predicates can be compiled as functions that return 0 or 1.
This function can be called from the probe BPF trampoline, and if the
return value is 0, the trampoline can return immediately (the clause
itself is never executed). This is equivalent to the legacy behaviour
in DTrace.

The introduction of predicates as BPF functions affects the BPF probe
trampoline generator as well because that is where the predicate
function will be called from.

Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>"," dt_compile_one_clause(dtrace_hdl_t *dtp, dt_node_t *cnp, dt_node_t *pnp)
 yypcb->pcb_ecbdesc = edp;
 
 if (cnp->dn_pred != NULL) {
-dt_cg(yypcb, cnp->dn_pred);
+dt_node_tpredn;
+
+predn.dn_kind = DT_NODE_PREDICATE;
+predn.dn_pred = cnp->dn_pred;
+dt_cg(yypcb, &predn);
 edp->dted_pred.dtpdd_difo = dt_as(yypcb);
 }
 
",1634,376
"Add trampolines for SDT and syscall probes

Similar to the FBT trampoline code generated in the provider
implementation code, SDT and syscall (both implemented using Linux
tracepoints) can now generate the appropriate trampoline code.

The documentation in BPF-DESIGN has alos been updated to reflect the
latest changes.

Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>"," dt_cg(dt_pcb_t *pcb, dt_node_t *dnp)
 dxp->dx_ident->di_id = dt_regset_alloc(pcb->pcb_regs);
 dt_cg_node(dnp, &pcb->pcb_ir, pcb->pcb_regs);
 } else if (dnp->dn_kind == DT_NODE_CLAUSE) {
+if (pcb->pcb_probe && pcb->pcb_probe->prov->impl->trampoline) pcb->pcb_probe->prov->impl->trampoline(pcb, 3);
 dt_cg_prologue(pcb);
 for (act = dnp->dn_acts; act != NULL; act = act->dn_list) {
 pcb->pcb_dret = act->dn_expr;
",1714,316
"Generate trampoline, predicate, and program function together

As a first stage, it makes sense to generate the trampoline, predicate
(if any), and program code as a single instruction block. BPF expects
programs (incl. any functions that it uses) to be loaded as a single
set of instructions anyway.

As this code matures, it is anticipated that we will migrate to a
design where the trampoline, predicate and program are compiled as
separate functions. They will then be assembled into a single block of
instructions to be loaded into the kernel through a kind of linking
process.

Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>"," dtrace_probe_iter(dtrace_hdl_t *dtp, const dtrace_probedesc_t *pdp,
 }
 
 done:
-return matches ? matches
+return matches ? 0
  : dt_set_errno(dtp, EDT_NOPROBE);
 }
 
",779,181
"Record reclen in DIFO and fix clause return type

We record the trace data record length in the DIFO because we will be
needing it when creating the BPF map for scratch space. Trace data
is constructed in the scratch space so it needs to be large enough to
hold a full trace record.

This patch also fixes the clause return type (and type size).

Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>"," fail:
 pcb->pcb_difo = NULL;
 pcb->pcb_dret = NULL;
 
-/* Track the orignal type. */
-dp->orig_dtdo_rtype = dp->dtdo_rtype;
+/*
+ * Fill in the trace data record length. This is used to determine the
+ * size of the scratch space where the trace data will be assembler
+ * before it is written to the output buffer.
+ */
+dp->dtdo_reclen = pcb->pcb_bufoff;
 
 return (dp);
 }
",386,99
"Fix mem BPF map lookup in prologue

The BPF map lookup in the prologue is supposed to retrieve the value
that corresponds with the current CPU. Since the map will be created
as a per-CPU map, there is no need to perform the lookup based on the
CPU id as key. Instead, lookup with key 0 will give us the expected
behaviour, i.e. each CPU will see its own version of the value that is
associated with key 0.

Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>"," dt_cg_prologue(dt_pcb_t *pcb)
 dt_irlist_append(dlp, dt_cg_node_alloc(DT_LBL_NONE, instr));
 
 /*
+ *stdw [%fp+-32], 0
  *lddw %r1, &mem
  *mov %r2, %fp
- *add %r2, -24
+ *add %r2, -32
  *call bpf_map_lookup_elem
  *mov %r9, %r0
  */
+instr = BPF_STORE_IMM(BPF_W, BPF_REG_FP, DT_STK_SPILL(1), 0);
+dt_irlist_append(dlp, dt_cg_node_alloc(DT_LBL_NONE, instr));
 dt_cg_xsetx(dlp, mem, DT_LBL_NONE, BPF_REG_1, mem->di_id);
 instr = BPF_MOV_REG(BPF_REG_2, BPF_REG_FP);
 dt_irlist_append(dlp, dt_cg_node_alloc(DT_LBL_NONE, instr));
-instr = BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, DT_STK_CPU);
+instr = BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, DT_STK_SPILL(1));
 dt_irlist_append(dlp, dt_cg_node_alloc(DT_LBL_NONE, instr));
 instr = BPF_CALL_HELPER(BPF_FUNC_map_lookup_elem);
 dt_irlist_append(dlp, dt_cg_node_alloc(DT_LBL_NONE, instr));
",1788,317
"Determine number of CPUs and a CPU id list

We need to know how many active CPUs are on the system, and what their
CPU ids are. This information is being stored in the dt_conf member
of the DTrace handle.

Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>"," inline long NULL = 0; \n\
 * Default DTrace configuration.
 */
 static const dtrace_conf_t _dtrace_conf = {
+0,/* numcpus */
+0,/* maxcpuid */
+NULL,/* cpuids */
 DIF_VERSION,/* dtc_difversion */
 DIF_DIR_NREGS,/* dtc_difintregs */
 DIF_DTR_NREGS,/* dtc_diftupregs */
 dt_vopen(int version, int flags, int *errp,
 return (set_open_errno(dtp, errp, EDT_NOMEM));
 
 memcpy(&dtp->dt_conf, &_dtrace_conf, sizeof (_dtrace_conf));
+dt_conf_init(dtp);
+dt_dprintf(""detected %d CPUs online (highest cpuid %d)\n"",
+ dtp->dt_conf.numcpus, dtp->dt_conf.maxcpuid);
 
 if (flags & DTRACE_O_LP64)
 dtp->dt_conf.dtc_ctfmodel = CTF_MODEL_LP64;
",919,105
"Fix relocation bug for kernel symbols used in lddw.

The introduction of BPF relocations and the reworking of support for
relocations caused a problem with the lddw instruction when the
address being loaded from is a kernel symbol (and therefore subject
to relocation) and symbol resolution against the kernel is done in
a static manner. The code was flagging this as an unexpected asm
relocation for opcode 0x18. This has been corrected (no error should
be flagged because the relocation is going to be dropped).

Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>"," dt_as(dt_pcb_t *pcb)
 krel++;
 else if ((idp->di_flags & umask) == ubits)
 urel++;
-else
-goto fail;
 break;
 case BPF_JMP | BPF_CALL:/* call */
 if (dip->di_instr.src_reg == BPF_PSEUDO_CALL &&
",384,99
"Create the string table as a global resource.

D programs used to be compiled into DIF code where each DIF object
had its own string table. In the interest of avoiding duplication,
and because we need to do all program processing in userspace anyway
it makes more sense to compile a single string table that is shared
between all compiled programs in a single tracing session.

The string table will be made available to compiled programs (BPF
code) as a strtab BPF map with a singleton (key 0) element that
contains the entire collection of strings concatenated together in
a single chunk of memory.

Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>"," dt_cg_node(dt_node_t *dnp, dt_irlist_t *dlp, dt_regset_t *drp)
 longjmp(yypcb->pcb_jmpbuf, EDT_NOREG);
 
 assert(dnp->dn_kind == DT_NODE_STRING);
-stroff = dt_strtab_insert(yypcb->pcb_strtab, dnp->dn_string);
+stroff = dt_strtab_insert(yypcb->pcb_hdl->dt_ccstab,
+ dnp->dn_string);
 
 if (stroff == -1L)
 longjmp(yypcb->pcb_jmpbuf, EDT_NOMEM);
 dt_cg(dt_pcb_t *pcb, dt_node_t *dnp)
 
 dt_regset_reset(pcb->pcb_regs);
 
-if (pcb->pcb_strtab != NULL)
-dt_strtab_destroy(pcb->pcb_strtab);
-
-if ((pcb->pcb_strtab = dt_strtab_create(BUFSIZ)) == NULL)
-longjmp(pcb->pcb_jmpbuf, EDT_NOMEM);
-
 dt_irlist_destroy(&pcb->pcb_ir);
 dt_irlist_create(&pcb->pcb_ir);
 
",1785,315
"Fix compilation on aarch64

The dt_bpf_context contains a struct that holds the CPU registers,
which is typically 'struct pt_regs'. However, on aarch64 that struct
is not exposed and we need to use 'struct user_pt_regs' instead. This
struct is also passed as the BPF context (or part of the BPF context)
for some probe types.

The structure holding the CPU registers is now declared as dt_pt_regs
for all architectures that are supported, hiding the implementation
specific struct.

Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>"," static int fbt_populate(dtrace_hdl_t *dtp)
 * The trampoline function is called when a FBT probe triggers, and it must
 * satisfy the following prototype:
 *
- *int dt_fbt(struct pt_regs *regs)
+ *int dt_fbt(dt_pt_regs *regs)
 *
 * The trampoline will populate a dt_bpf_context struct and then call the
 * function that implements tha compiled D clause. It returns the value that
 static void fbt_trampoline(dt_pcb_t *pcb, int haspred)
 #define DCTX_FP(off)(-(ushort_t)DCTX_SIZE + (ushort_t)(off))
 
 /*
- * int dt_fbt(struct pt_regs *regs)
+ * int dt_fbt(dt_pt_regs *regs)
  * {
  * struct dt_bpf_contextdctx;
  *
 static void fbt_trampoline(dt_pcb_t *pcb, int haspred)
 /*
  * dctx.regs = *regs;
  */
-for (i = 0; i < sizeof(struct pt_regs); i += 8) {
+for (i = 0; i < sizeof(dt_pt_regs); i += 8) {
 instr = BPF_LOAD(BPF_DW, BPF_REG_0, BPF_REG_1, i);
 dt_irlist_append(dlp, dt_cg_node_alloc(DT_LBL_NONE, instr));
 instr = BPF_STORE(BPF_DW, BPF_REG_FP, DCTX_FP(DCTX_REGS) + i,
",230,29
"Support building on systems with older kernels and/or glibc

Systems that run older kernels and/or have an older glibc may not have
some defines that we need. THis patch makes sure dtrace can still
build.

Orabug: 30619068
Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>","
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
+#include <port.h>
 
 static int readBPFFile(const char *fn)
 {
",123,27
"Update copyright statements.

Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>","
 
 /*
 * Oracle Linux DTrace.
- * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.
 * Licensed under the Universal Permissive License v 1.0 as shown at
 * http://oss.oracle.com/licenses/upl.
 */
",56,14
"Fix register leak in trace()

The trace() implementation was incorrectly assuming that the value to be
written to the scratch buffer would be in %r0 (which is not guaranteed),
and it was not releasing the register that the value actually was stored
in. THe code now uses the register assigned to the passed argument, and
ensures that it is released.

Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>"," dt_cg_act_trace(dt_pcb_t *pcb, dt_node_t *dnp, dtrace_actkind_t kind)
 dt_cg_node(dnp->dn_args, &pcb->pcb_ir, pcb->pcb_regs);
 
 if (dt_node_is_scalar(dnp->dn_args)) {
-instr = BPF_STORE(BPF_DW, BPF_REG_9, off, BPF_REG_0);
+instr = BPF_STORE(BPF_DW, BPF_REG_9, off, dnp->dn_args->dn_reg);
 dt_irlist_append(dlp, dt_cg_node_alloc(DT_LBL_NONE, instr));
+dt_regset_free(pcb->pcb_regs, dnp->dn_args->dn_reg);
 
 return sizeof(uint64_t);
 } else if (dt_node_is_string(dnp->dn_args)) {
 dt_cg_act_trace(dt_pcb_t *pcb, dt_node_t *dnp, dtrace_actkind_t kind)
 dt_irlist_append(dlp, dt_cg_node_alloc(DT_LBL_NONE, instr));
 instr = BPF_STORE_IMM(BPF_W, BPF_REG_9, off + 4, sz >> 32);
 dt_irlist_append(dlp, dt_cg_node_alloc(DT_LBL_NONE, instr));
+dt_regset_free(pcb->pcb_regs, dnp->dn_args->dn_reg);
 
 return sz + sizeof(uint64_t);
 } else
",1787,315
"Create 'mem' map as a BPF per-CPU array map

This patch adds a global variable to dtrace_hdl_t to track the largest
seen trace buffer record size for the programs being loaded. Once all
programs have been compiled, this can be used to create the BPF per-CPU
array map that provides scratch memory for constructing a trace record.

The 'mem' BPF map contains a singleton element that is large enough to
construct any of the trace records that will be used by any of the
programs being loaded. Since the map is created as a per-CPU map, each
CPU will get its own copy of the singleton element (key 0).

Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>"," fail:
  * before it is written to the output buffer.
  */
 dp->dtdo_reclen = pcb->pcb_bufoff;
+if (dp->dtdo_reclen > dtp->dt_maxreclen)
+dtp->dt_maxreclen = dp->dtdo_reclen;
 
 return (dp);
 }
",389,100
"Remove duplicate 'strtab' map identifier

The list of identifiers to pre-populate the BPF identifier list had
two entries for 'strtab'. The second one is removed with this patch.

Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>"," static const dt_ident_tdt_bpf_symbols[] = {
 DT_BPF_SYMBOL(tvars, DT_IDENT_PTR),
 DT_BPF_SYMBOL(probes, DT_IDENT_PTR),
 DT_BPF_SYMBOL(mem, DT_IDENT_PTR),
-DT_BPF_SYMBOL(strtab, DT_IDENT_PTR),
 /* BPF internal identifiers */
 DT_BPF_SYMBOL(EPID, DT_IDENT_SCALAR),
 DT_BPF_SYMBOL(ARGC, DT_IDENT_SCALAR),
",637,137
"Make dt_dis_difo() global

The dt_dis_difo() function is the actual implementation of the code
disassembler. It was previously only used for providing disassembly
for a program compiled with DTrace. With the use of pre-compiled BPF
code, there is a use case for calling it from the BPF library loader
code. This symbol is being made available in preperation for that.
The goal is to add an option to request disassembly of loaded BPF
code for debugging purposes.

Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>"," dt_dis_rtab(const char *rtag, const dtrace_difo_t *dp, FILE *fp,
 }
 }
 
-static void
+void
 dt_dis_difo(const dtrace_difo_t *dp, FILE *fp)
 {
 static const struct opent {
",624,107
"Add logic to load BPF programs into the kernel

This patch introduces the code to load BPF program into the kernel.
Provider implementations are now required to provide a probe type
(BPF program type) that is to be used to load BPF programs. In future
revisions, this may need to be finetuned more as providers might serve
probes that map to different BPF program types.

Right before we load BPF programs, we resolve relocations for BPF maps.

Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>"," dtrace_program_exec(dtrace_hdl_t *dtp, dtrace_prog_t *pgp,
  * how many programs there are.
  */
 dt_bpf_gmap_create(dtp, 1);
+dt_bpf_prog(dtp, pgp);
 
 if ((dof = dtrace_dof_create(dtp, pgp, DTRACE_D_STRIP)) == NULL)
 return (-1);
",453,112
"Support negative jump offsets for the 'ja' instruction

The 'ja' instruction output in the disassembler was always printing
the jump offset as an unsigned int while the offset is interpreted
at exexcution time as a signed int. We now use '%d' instead of '%u'.

Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>"," dt_dis_jump(const dtrace_difo_t *dp, const char *name, ulong_t addr,
 if (in->off == 0)
 fprintf(fp, ""nop"");
 else
-fprintf(fp, ""%-4s %u\t\t\t! -> %03lu"", name, in->off,
+fprintf(fp, ""%-4s %d\t\t\t! -> %03lu"", name, in->off,
 addr + 1 + in->off);
 }
 
",624,107
"Fix argument copying

When the trampoline copies the syscall arguments into the argument
array in the DTrace context structure, it was accidentally writing
them all to the argv[0] slot. This patch ensures that arguments
end up in the correct argv[] slots.

Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>"," static void syscall_trampoline(dt_pcb_t *pcb, int haspred)
 for (i = 0; i < pcb->pcb_pinfo.dtp_argc; i++) {
 instr = BPF_LOAD(BPF_DW, BPF_REG_0, BPF_REG_1, SCD_ARG(i));
 dt_irlist_append(dlp, dt_cg_node_alloc(DT_LBL_NONE, instr));
-instr = BPF_STORE(BPF_DW, BPF_REG_FP, DCTX_FP(DCTX_ARG(0)),
+instr = BPF_STORE(BPF_DW, BPF_REG_FP, DCTX_FP(DCTX_ARG(i)),
  BPF_REG_0);
 dt_irlist_append(dlp, dt_cg_node_alloc(DT_LBL_NONE, instr));
 }
",218,28
"Fix invalid use of %r2 after function call (it got clobbered)

Registers %r0 through %r5 get clobbered by function calls, regardless
of whether the called function touches them or not. This causes a
problem for the prologue implementation because it expected that it
could use %r2 after function call.

We now explicitly retrieve the value again (from the stack) and we
switch to using %r0 since we only use it as a temporary base pointer
in the next load instruction.

Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>"," dt_cg_prologue(dt_pcb_t *pcb)
  * We read epid from dctx (struct dt_bpf_context) and store it in the
  * first 4 bytes of the output buffer. The next 4 bytes are padded
  * with 0s so that the next entry will be at a 8-byte boundary.
+ *
+ *lddw %r0, [%fp + DT_STK_DCTX]
+ *ldw %r0, [%r0 + DCTX_EPID]
+ *stw [%r9+0], %r0
+ *stw [%r9+4], 0
  */
+instr = BPF_LOAD(BPF_DW, BPF_REG_2, BPF_REG_FP, DT_STK_DCTX);
+dt_irlist_append(dlp, dt_cg_node_alloc(DT_LBL_NONE, instr));
 instr = BPF_LOAD(BPF_W, BPF_REG_0, BPF_REG_2, DCTX_EPID);
 dt_irlist_append(dlp, dt_cg_node_alloc(DT_LBL_NONE, instr));
 instr = BPF_STORE(BPF_W, BPF_REG_9, 0, BPF_REG_0);
",1813,315
"Ensure that the output buffer offset is rest between compilations

When the same clause was being compiled for two different probe specs,
the output output offset counter was not being reset, causing subsequent
compilations to store data at ever increasing offsets.

Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>"," dt_cg(dt_pcb_t *pcb, dt_node_t *dnp)
 assert(pcb->pcb_dret == NULL);
 pcb->pcb_dret = dnp;
 
+pcb->pcb_bufoff = 0;
+
 if (dt_node_is_dynamic(dnp))
 dnerror(dnp, D_CG_DYN, ""expression cannot evaluate to result ""
 ""of dynamic type\n"");
",1814,315
"dt_cg_typecast() mistakenly computes srcsize as size of dst

Signed-off-by: Eugene Loh <eugene.loh@oracle.com>
Reviewed-by: Kris Van Hees <kris.van.hees@oracle.com>"," dt_cg_typecast(const dt_node_t *src, const dt_node_t *dst,
 if (dst->dn_ctfp == NULL && dst->dn_type == CTF_ERR)
 return;
 
-srcsize = dt_node_type_size(dst);
+srcsize = dt_node_type_size(src);
 dstsize = dt_node_type_size(dst);
 
 if (dt_node_is_scalar(dst) && (dstsize < srcsize ||
",1814,315
"test: adapt test suite for DTrace v2.0

While DTrace v2.0, based on BPF, is being ramped up, adapt the
test suite based on the functionality available at this point.

Quite a few tests are expected to fail. Indicate so with XFAIL
annotations.

Note that these tests
 test/stress/fbtsafety/tst.copyin.d
 test/stress/fbtsafety/tst.copyin2.d
 test/stress/fbtsafety/tst.shortstr.d
fail even when annotated XFAIL. So mark them SKIP instead.

As the newly XFAIL-marked tests start to pass, they will XPASS.
This will provide an indication that one can remove the XFAIL
annotations.

Signed-off-by: Eugene Loh <eugene.loh@oracle.com>
Reviewed-by: Kris Van Hees <kris.van.hees@oracle.com>","
 /*
 * Oracle Linux DTrace.
- * Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.
 * Licensed under the Universal Permissive License v 1.0 as shown at
 * http://oss.oracle.com/licenses/upl.
 */
+/* @@xfail: dtv2 */
 
 /*
 * Verify that a dtrace_addr2str() of the null pointer does not
",18,2
"Give error for lack of representative probe

When a probe specification could not be resolved into a representative
probe (i.e. all probes that match the specification have the same
attributes so we can pick any one of them to use during compilation),
we would get a SEGV.

Issue an error if no representative probe can be found, and mark it as
a future feature.

Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>"," dt_cg(dt_pcb_t *pcb, dt_node_t *dnp)
 pcb,
 dnp->dn_pred != NULL);
 }
+/*
+ * FIXME: We should be able to handle this somehow or avoid
+ * it altogether. We need this to aovid a core dump.
+ */
+else
+xyerror(D_PROV_INCOMPAT, ""[Future feature] - ""
+""probe description %s:%s:%s:%s has no ""
+""representative probe\n"",
+pcb->pcb_pdesc->prv, pcb->pcb_pdesc->mod,
+pcb->pcb_pdesc->fun, pcb->pcb_pdesc->prb);
 
 if (dnp->dn_pred != NULL) {
 /*
",1776,315
"Add missing include in dt_bpf.c

With the addition of relocation resolving in dt_bpf.c, we need to
include port.h for build environments where R_BPF_64_64 etc is not
defined (older ELF headers).

Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>","
 #include <dtrace.h>
 #include <dt_impl.h>
 #include <dt_probe.h>
+#include <port.h>
 
 #include <bpf.h>
 
",143,24
"Associate BPF programs with probes (as perf events)

Once a BPF program has been loaded successfully (i.e. the verifier has
accepted it), it needs to be associated (attached) to one or more
probes. Each probe represents a perf event (identified by a unique
numeric id), and that event must be created by means of the
perf_event_open() system call. The result (if successful) will be a
file descriptor that refers to the perf event for the probe. This fd
can be used to attach the BPF program (identified by a file descriptor)
to the perf event.

Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>"," dt_probe_insert(dtrace_hdl_t *dtp, dt_provider_t *prov, const char *prv,
 prp->desc = desc;
 prp->prov = prov;
 prp->event_id = -1;
+prp->event_fd = -1;
 
 dt_htab_insert(dtp->dt_byprv, prp);
 dt_htab_insert(dtp->dt_bymod, prp);
",781,181
"Add the precompiled BPF function library as a build component

The previously added BPF function library source code is being replaced
by the source code in the bpf/ directory. It makes use of the new build
system support for compiling BPF code, thereby providing a better
integration with the DTrace build infrastructure.

(The build system changes for BPF code and this replacement for the
 previously monolithic bpf_dlib.c are inspired by a patch by Eugene Loh
 providing build time compilation of bpf_dlib.c.)

Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>","
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
+ */
+#include <linux/bpf.h>
+#include <stdint.h>
+#include <bpf-helpers.h>
+
+#ifndef noinline
+# define noinline__attribute__((noinline))
+#endif
+
+struct bpf_map_def gvars;
+
+noinline uint64_t dt_get_gvar(uint32_t id)
+{
+uint64_t*val;
+
+val = bpf_map_lookup_elem(&gvars, &id);
+return val ? *val : 0;
+}
",10,2
"add dt_bpf_map_update()

Add a convenience wrapper for updating elements in BPF maps.

Signed-off-by: Eugene Loh <eugene.loh@oracle.com>
Reviewed-by: Kris Van Hees <kris.van.hees@oracle.com>"," dt_bpf_gmap_create(dtrace_hdl_t *dtp, uint_t probec)
 /* FIXME: Need to put in the actual struct ref for probe info. */
 }
 
+/*
+ * Store the (key, value) pair in the map referenced by the given fd.
+ */
+int dt_bpf_map_update(int fd, const void *key, const void *val)
+{
+union bpf_attr attr;
+
+memset(&attr, 0, sizeof(attr));
+attr.map_fd = fd;
+attr.key = (uint64_t)(unsigned long)key;
+attr.value = (uint64_t)(unsigned long)val;
+attr.flags = 0;
+
+return bpf(BPF_MAP_UPDATE_ELEM, &attr);
+}
+
 /*
 * Perform relocation processing on a program.
 */
",188,32
"Introduce dt_calloc() for array allocations

Various places in the DTrace userspace implementation was using the
dt_alloc() and dt_zalloc() functions to allocate an array of objects.
This patch introduces dt_calloc() to do that.

Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>"," dt_action_difconst(dtrace_actdesc_t *ap, uint_t id, dtrace_actkind_t kind)
 if (dp == NULL)
 longjmp(yypcb->pcb_jmpbuf, EDT_NOMEM);
 
-dp->dtdo_buf = dt_alloc(dtp, sizeof (dif_instr_t) * 2);
-
+dp->dtdo_buf = dt_calloc(dtp, 2, sizeof(dif_instr_t));
 if (dp->dtdo_buf == NULL) {
 dt_difo_free(dtp, dp);
 longjmp(yypcb->pcb_jmpbuf, EDT_NOMEM);
",1600,367
"Interrupting tracing should not yield an error (unless we failed)

Interrupting tracing (e.g. using Ctrl-C) would yield an error that
tracing couldn't be stopped. This was caused by a remnant of the
old dtrace code using an ioctl() to signal the kernel that tracing
should be stopped.

This error condition no longer occurs because we no longer use the
ioxtl(). Additional processing when tracing should be stopped is
yet to be implemented.

Orabug: 31220520
Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>"," dtrace_stop(dtrace_hdl_t *dtp)
 if (dtp->dt_stopped)
 return (0);
 
+#if 0
 if (dt_ioctl(dtp, DTRACEIOC_STOP, &dtp->dt_endedon) == -1)
 return (dt_set_errno(dtp, errno));
+#endif
 
 dtp->dt_stopped = 1;
 
+#if 0
 /*
  * Now that we're stopped, we're going to get status one final time.
  */
 if (dt_ioctl(dtp, DTRACEIOC_STATUS, &dtp->dt_status[gen]) == -1)
 return (dt_set_errno(dtp, errno));
+#endif
 
 if (dt_handle_status(dtp, &dtp->dt_status[gen ^ 1],
  &dtp->dt_status[gen]) == -1)
",205,68
"Remove obsolete dt_fd, dt_ftfd, and dt_fterr

Given that DTrace no longer makes use of the ioctl() interface to a
DTrace kernel component we can remove all references to these members
in dtrace_hdl_t. We retain dtrace_ctlfd() because it is part of the
public API, and dt_ioctl() because various parts of libdtrace still
need to rewritten to replace the ioctl() use.

Orabug: 31220516
Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>"," dt_vopen(int version, int flags, int *errp,
 dtp->dt_xlatemode = DT_XL_STATIC;
 dtp->dt_stdcmode = DT_STDC_XA;
 dtp->dt_version = version;
-dtp->dt_fd = -1;/* FIXME: will be removed later */
-dtp->dt_ftfd = -1;/* FIXME: will be removed later */
 dtp->dt_cdefs_fd = -1;
 dtp->dt_ddefs_fd = -1;
 dtp->dt_stdout_fd = -1;
 dtrace_close(dtrace_hdl_t *dtp)
 
 dt_pcap_destroy(dtp);
 
-if (dtp->dt_fd != -1)
-close(dtp->dt_fd);
-if (dtp->dt_ftfd != -1)
-close(dtp->dt_ftfd);
 if (dtp->dt_cdefs_fd != -1)
 close(dtp->dt_cdefs_fd);
 if (dtp->dt_ddefs_fd != -1)
 dtrace_close(dtrace_hdl_t *dtp)
 dt_debug_dump(0);
 }
 
+/*
+ * DTrace no longer uses an ioctl() interface to communicate with a DTrace
+ * kernel component. We retain this function because it is part of the
+ * libdtrace API.
+ */
 int
 dtrace_ctlfd(dtrace_hdl_t *dtp)
 {
-return (dtp->dt_fd);
+return -1;
 }
",927,107
"Introduce BEGIN and END probes as functions to probe for

Orabug: 31220513
Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>"," static const struct {
 { DTRACEOPT_MAX, 0 }
 };
 
+void
+BEGIN_probe(void)
+{
+}
+
+void
+END_probe(void)
+{
+}
+
 void
 dtrace_sleep(dtrace_hdl_t *dtp)
 {
 dtrace_go(dtrace_hdl_t *dtp)
 dtrace_getopt(dtp, ""bufsize"", &size);
 dt_pebs_init(dtp, size);
 
+BEGIN_probe();
 #if 0
 if (dt_ioctl(dtp, DTRACEIOC_GO, &dtp->dt_beganon) == -1) {
 if (errno == EACCES)
 dtrace_stop(dtrace_hdl_t *dtp)
 return (dt_set_errno(dtp, errno));
 #endif
 
+END_probe();
+
 dtp->dt_stopped = 1;
 
 #if 0
",215,70
"Disable the printing of aggregations

Since aggregations are not supported yet in DTrace v2, and now that it
is possible to use the exit() action to end tracing, the auto-printing
of aggregations when tracing ends is commented out pending a working
implementation of aggregations.

Orabug: 31220520
Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>
Reviewed-by: Kris Van Hees <kris.van.hees@oracle.com>
Reviewed-by: Eugene Loh <eugene.loh@oracle.com>","
 /*
 * Oracle Linux DTrace.
- * Copyright (c) 2006, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2006, 2020, Oracle and/or its affiliates. All rights reserved.
 * Licensed under the Universal Permissive License v 1.0 as shown at
 * http://oss.oracle.com/licenses/upl.
 */
 main(int argc, char *argv[])
 
 oprintf(""\n"");
 
+#if 0
 if (!g_impatient) {
 if (dtrace_aggregate_print(g_dtp, g_ofp, NULL) == -1 &&
  dtrace_errno(g_dtp) != EINTR)
 dfatal(""failed to print aggregations"");
 }
+#endif
 
 for (i = 0; i < g_psc; i++)
 dtrace_proc_release(g_dtp, g_psv[i]);
",1109,269
"Provide a standard dt_strtab_copystr() function

Different parts in the DTrace source code were providing their own
custom copy string function to be passed to dt_strtab_write(). All
did essentially the same thing, so it is quite easy to provide a
single generic function to do this work. It is still possible to
use the dt_strtab_write() functionality with a more fancy copy
string function if needed.

Orabug: 31220525
Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>
Reviewed-by: Kris Van Hees <kris.van.hees@oracle.com>
Reviewed-by: Eugene Loh <eugene.loh@oracle.com>"," dt_copyvar(dt_idhash_t *dhp, dt_ident_t *idp, dtrace_hdl_t *dtp)
 return (0);
 }
 
-static ssize_t
-dt_copystr(const char *s, size_t n, size_t off, dtrace_hdl_t *dtp)
-{
-memcpy(dtp->dt_strtab + off, s, n);
-return n;
-}
-
 #ifdef FIXME
 /*
 * Rewrite the xlate/xlarg instruction at dtdo_buf[i] so that the instruction's
 fail:
 longjmp(pcb->pcb_jmpbuf, EDT_NOMEM);
 
 dt_strtab_write(dtp->dt_ccstab,
-(dt_strtab_write_f *)dt_copystr, dtp);
+(dt_strtab_write_f *)dt_strtab_copystr,
+dtp->dt_strtab);
 dtp->dt_strlen = (uint32_t)n;
 
 dp->dtdo_strtab = dtp->dt_strtab;
",388,99
"Fix invalid memory access when looking for pid provider

The code to determine whether a provider name is a pid provider checks
whether the last character of the provider name is a digit. This worked
fine when the probe description name components were fixed-size character
arrays, but with the change to using allocated strings, this can result in
reading a byte *before* the allocated string if the string is an empty
string because.

Orabug: 31220517
Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>
Reviewed-by: Kris Van Hees <kris.van.hees@oracle.com>
Reviewed-by: Eugene Loh <eugene.loh@oracle.com>"," dt_setcontext(dtrace_hdl_t *dtp, dtrace_probedesc_t *pdp)
  * On an error, dt_pid_create_probes() will set the error message
  * and tag -- we just have to longjmp() out of here.
  */
-if (isdigit(pdp->prv[strlen(pdp->prv) - 1]) &&
+if (pdp->prv && pdp->prv[0] &&
+ isdigit(pdp->prv[strlen(pdp->prv) - 1]) &&
  ((pvp = dt_provider_lookup(dtp, pdp->prv)) == NULL ||
  pvp->desc.dtvd_priv.dtpp_flags & DTRACE_PRIV_PROC) &&
  dt_pid_create_probes(pdp, dtp, yypcb) != 0) {
",1765,402
"Do not allocate a 0-size strtab

If there is no stirng data to be stored in a DIFO, we were allocating
a 0-size memory block. There is no need for that - we can just assign
NULL to the dtdo_strtab member.

In the case of the dt_link_stmt() code, we also happened to take the
dtdo_strlen value from the wrong DIFO (fdp instead of dp) causing a
0-size strtab to be allocated into which we then try to write actual
data. That caused memory corruption.

Orabug: 31220517
Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>
Reviewed-by: Kris Van Hees <kris.van.hees@oracle.com>
Reviewed-by: Eugene Loh <eugene.loh@oracle.com>"," dt_link_stmt(dtrace_hdl_t *dtp, dtrace_prog_t *pgp, dtrace_stmtdesc_t *sdp,
  * Write out the new string table.
  */
 dp->dtdo_strlen = dt_strtab_size(stab);
-dp->dtdo_strtab = dt_zalloc(dtp, fdp->dtdo_strlen);
-if (dp->dtdo_strtab == NULL)
-goto fail;
-dt_strtab_write(stab, (dt_strtab_write_f *)dt_strtab_copystr,
-dp->dtdo_strtab);
+if (dp->dtdo_strlen > 0) {
+dp->dtdo_strtab = dt_zalloc(dtp, dp->dtdo_strlen);
+if (dp->dtdo_strtab == NULL)
+goto fail;
+dt_strtab_write(stab, (dt_strtab_write_f *)dt_strtab_copystr,
+dp->dtdo_strtab);
+} else
+dp->dtdo_strtab = NULL;
+
 dt_strtab_destroy(stab);
 
 /*
",1768,403
"Fix double-free of dt_datadesc_t structures

While the dt_datadesc_t structures were introduced with a reference
count (along with dt_datadesc_hold() and dt_datadesc_release() functions
to manage them), there was still a direct dt_free() of a dt_datadesc_t
structure in dtrace_stmt_destroy().

Orabug: 31220517
Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>
Reviewed-by: Kris Van Hees <kris.van.hees@oracle.com>
Reviewed-by: Eugene Loh <eugene.loh@oracle.com>"," dt_datadesc_hold(dtrace_datadesc_t *ddp)
 ddp->dtdd_refcnt++;
 }
 
-static void
+void
 dt_datadesc_release(dtrace_hdl_t *dtp, dtrace_datadesc_t *ddp)
 {
 if (--ddp->dtdd_refcnt > 0)
",405,98
"Avoid valgrind warning about conditional jump based on uninitialized value

The dt_modsym_update_alt() has conditionals based on the content of
sym_name, which is initialized from a sscanf() statement. While the
implementation ensures that a value is assigned, valgrind does not seem
to know that. By providing a default initializer value, complaints go
away.

Orabug: 31220517
Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>
Reviewed-by: Kris Van Hees <kris.van.hees@oracle.com>
Reviewed-by: Eugene Loh <eugene.loh@oracle.com>","
 /*
 * Oracle Linux DTrace.
- * Copyright (c) 2009, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2009, 2020, Oracle and/or its affiliates. All rights reserved.
 * Licensed under the Universal Permissive License v 1.0 as shown at
 * http://oss.oracle.com/licenses/upl.
 */
 dt_modsym_update_alt(dtrace_hdl_t *dtp, const char *line)
 int sym_text;
 dt_module_t *dmp;
 dtrace_addr_range_t *range = NULL;
-char sym_name[KSYM_NAME_MAX];
+char sym_name[KSYM_NAME_MAX] = """";
 char mod_name[PATH_MAX] = ""vmlinux]"";/* note trailing ] */
 int skip = 0;
 
",1305,348
"Correct BPF context mentioned in comments in providers

The dtrace and FBT providers incorrectly mentioned 'scd' as the BPF
context passed to the dt_program(). It should be 'regs'.

Orabug: 31220516
Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>
Reviewed-by: Kris Van Hees <kris.van.hees@oracle.com>
Reviewed-by: Eugene Loh <eugene.loh@oracle.com>"," static int dtrace_populate(dtrace_hdl_t *dtp)
 }
 
 /*
-* Generate a BPF trampoline for a dtrace probe (BEGIN, END, or ERROR).
+ * Generate a BPF trampoline for a dtrace probe (BEGIN, END, or ERROR).
 *
 * The trampoline function is called when a dtrace probe triggers, and it must
 * satisfy the following prototype:
 static void dtrace_trampoline(dt_pcb_t *pcb, int haspred)
 }
 
 /*
- * rc = dt_program(scd, dctx);
+ * rc = dt_program(regs, dctx);
  */
 idp = dt_dlib_get_func(pcb->pcb_hdl, ""dt_program"");
 assert(idp != NULL);
",136,13
"Ensure that both Ctrl-c and exit() terminate probing correctly

Probing can end in two ways: an exit() action or Ctrl-c. The main
difference is that exit() initiates the completion of probing from
a probe clause (producer) whereas Ctrl-c does so from the probe data
processing (consumer). In both cases, we want the END probe to fire
(if enabled), and we therefore must ensure that the code path that
trigger it is executed. This is done by ensuring that when an exit()
action is encountered the consumer ends tracing in a manner similar
it being interrupted (Ctrl-c).

Orabug: 31220520
Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>"," typedef struct dtrace_cmd {
 #defineDMODE_LIST3/* compile program and list probes (-l) */
 #defineDMODE_HEADER4/* compile program for headergen (-h) */
 
+#define DONE_SAW_END1/* If END is not enabled, we pretend */
+#define DONE_SAW_EXIT2/* exit() action processed */
+
 #defineE_SUCCESS0
 #defineE_ERROR1
 #defineE_USAGE2
 main(int argc, char *argv[])
 g_newline = 0;
 }
 
-if (done || g_intr || (g_psc != 0 && g_pslive <= 0)) {
-done = 1;
+if (done == DONE_SAW_EXIT || g_intr ||
+ (g_psc != 0 && g_pslive <= 0)) {
+done = DONE_SAW_END;
 if (dtrace_stop(g_dtp) == -1)
 dfatal(""couldn't stop tracing"");
 }
 
 switch (dtrace_work(g_dtp, g_ofp, chew, chewrec, NULL)) {
 case DTRACE_WORKSTATUS_DONE:
-done = 1;
+if (done != DONE_SAW_END)
+done = DONE_SAW_EXIT;
 break;
 case DTRACE_WORKSTATUS_OKAY:
 break;
 main(int argc, char *argv[])
 
 if (g_ofp != NULL && fflush(g_ofp) == EOF)
 clearerr(g_ofp);
-} while (!done);
+} while (done != DONE_SAW_END);
 
 oprintf(""\n"");
 
",1111,270
"Set default switchrate

Orabug: 31220520
Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>"," main(int argc, char *argv[])
 fatal(""failed to initialize dtrace: %s\n"",
  dtrace_errmsg(NULL, err));
 
-(void) dtrace_setopt(g_dtp, ""bufsize"", ""4m"");
-(void) dtrace_setopt(g_dtp, ""aggsize"", ""4m"");
+/*
+ * Set default options.
+ */
+dtrace_setopt(g_dtp, ""bufsize"", ""4m"");
+dtrace_setopt(g_dtp, ""aggsize"", ""4m"");
+dtrace_setopt(g_dtp, ""switchrate"", ""1s"");
 
 /*
  * The very first thing we do after buffer-size sanitization is run
",1112,270
"Ensure that local variables get a 0 value upon first load

Local variables are stored on the stack and BPF does not allow loading
from an uninitialized stack location. Since D expects variables to
have value 0 prior to first use, we can just pretend the load happened
and instead emit an instruction storing 0 in the destination register.

Orabug: 31220527
Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>"," dt_cg_load_var(dt_node_t *dst, dt_irlist_t *dlp, dt_regset_t *drp)
 
 idp->di_flags |= DT_IDFLG_DIFR;
 if (idp->di_flags & DT_IDFLG_LOCAL) {/* local var */
-instr = BPF_LOAD(BPF_DW, dst->dn_reg, BPF_REG_FP,
- DT_STK_LVAR(idp->di_id));
+/*
+ * If this is the first read for this local variable, we know
+ * the value is 0. This avoids storing an initial 0 value in
+ * the variable's stack location.
+ */
+if (!(idp->di_flags & DT_IDFLG_DIFW))
+instr = BPF_MOV_IMM(dst->dn_reg, 0);
+else
+instr = BPF_LOAD(BPF_DW, dst->dn_reg, BPF_REG_FP,
+ DT_STK_LVAR(idp->di_id));
+
 dt_irlist_append(dlp, dt_cg_node_alloc(DT_LBL_NONE, instr));
 } else if (idp->di_flags & DT_IDFLG_TLS) {/* TLS var */
 dt_regset_xalloc(drp, BPF_REG_1);
",1790,321
"Handle memory allocation failures when allocating trace buffers

Orabug: 31220517
Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>"," dtrace_go(dtrace_hdl_t *dtp)
 return dt_set_errno(dtp, errno);
 
 dtrace_getopt(dtp, ""bufsize"", &size);
-dt_pebs_init(dtp, size);
+if (dt_pebs_init(dtp, size) == -1)
+return dt_set_errno(dtp, EDT_NOMEM);
 
 BEGIN_probe();
 #if 0
",212,70
"Ensure that the buffer size is big enough for at least one sample

Orabug: 31220520
Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>","
 #include <time.h>
 #include <libproc.h>
 #include <port.h>
+#include <linux/perf_event.h>
 #include <sys/epoll.h>
 
 static const struct {
 dtrace_go(dtrace_hdl_t *dtp)
 if (dtp->dt_poll_fd < 0)
 return dt_set_errno(dtp, errno);
 
+/*
+ * We need enough space for the pref_event_header, a 32-bit size, a
+ * 4-byte gap, and the largest trace data record we may be writing to
+ * the buffer. In other words, the buffer needs to be large enough to
+ * hold at least one perf-encapsulated trace data record.
+ */
 dtrace_getopt(dtp, ""bufsize"", &size);
+if (size == 0 ||
+ size < sizeof(struct perf_event_header) + sizeof(uint32_t) +
+ dtp->dt_maxreclen)
+return dt_set_errno(dtp, EDT_BUFTOOSMALL);
 if (dt_pebs_init(dtp, size) == -1)
 return dt_set_errno(dtp, EDT_NOMEM);
 
",217,72
"Fix various memory leaks

Testing dtrace with valgrind identified a bunch of significant memory
leaks. These have been fixed.

There is still some loss of memory due to string elements in probe
descriptions not consistently using strdup() to ensure that they can
be freed when no longer needed, and also in the buffer handling in
the lexer. These are left for future investigation and resolution.

Orabug: 31386368
Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>
Reviewed-by: Eugene Loh <eugene.loh@oracle.com>
Reviewed-by: Kris Van Hees <kris.van.hees@oracle.com>"," chew(const dtrace_probedata_t *data, void *arg)
 if (!g_flowindent) {
 if (!g_quiet) {
 size_t len = strlen(pd->fun) + strlen(pd->prb) + 2;
-char *name = malloc(len);
+char *name = alloca(len);
 
 if (name == NULL)
 fatal(""failed to allocate memory for name"");
 main(int argc, char *argv[])
 dtrace_proc_release(g_dtp, g_psv[i]);
 
 dtrace_close(g_dtp);
+
+free(g_argv);
+free(g_cmdv);
+free(g_psv);
+
 return (g_status);
 }
",1115,270
"Implement first set of builtin variables

Variables that are currently implemented:

	arg0 .. arg9
	curthread
	pid
	tid
	uid
	gid

Orabug: 31221984
Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>"," dt_cg_load_var(dt_node_t *dst, dt_irlist_t *dlp, dt_regset_t *drp)
 if (dt_regset_xalloc_args(drp) == -1)
 longjmp(yypcb->pcb_jmpbuf, EDT_NOREG);
 if (idp->di_id < DIF_VAR_OTHER_UBASE) {/* built-in var */
-instr = BPF_MOV_IMM(BPF_REG_1, idp->di_id);
+instr = BPF_LOAD(BPF_DW, BPF_REG_1,
+ BPF_REG_FP, DT_STK_DCTX);
+dt_irlist_append(dlp, dt_cg_node_alloc(DT_LBL_NONE,
+ instr));
+instr = BPF_MOV_IMM(BPF_REG_2, idp->di_id);
 dt_irlist_append(dlp, dt_cg_node_alloc(DT_LBL_NONE,
  instr));
 idp = dt_dlib_get_func(yypcb->pcb_hdl, ""dt_get_bvar"");
",1857,340
"Fix references to BPF maps.

Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>","
 # define noinline__attribute__((noinline))
 #endif
 
-struct bpf_map_def gvars;
+extern struct bpf_map_def gvars;
 
 noinline uint64_t dt_get_gvar(uint32_t id)
 {
",10,2
"Fix SEGV when dt_set_errmsg() is called outside of compilation

Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>"," dt_set_errmsg(dtrace_hdl_t *dtp, const char *errtag, const char *region,
 s = dtp->dt_errmsg;
 n = sizeof (dtp->dt_errmsg);
 
-if (errtag != NULL && (yypcb->pcb_cflags & DTRACE_C_ETAGS))
+if (errtag != NULL && ((dtp->dt_cflags & DTRACE_C_ETAGS) ||
+ (yypcb && yypcb->pcb_cflags & DTRACE_C_ETAGS)))
 (void) snprintf(s, n, ""[%s] "", errtag);
 else
 s[0] = '\0';
",180,30
"Integrate the predicate (if any) into the main program.

The predicate was generated as a function, called from the provider
trampoline. This poses a problem when the DTrace BPF context needs
to be accessed within the predicate code (e.g. when referencing a
builtin variable).

The new implementation integrates the predicate (if any) into the
actual main program.

Orabug: 31414309
Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>"," static dtrace_attribute_tdt_bpf_attr = DT_ATTR_STABCMN;
 
 static const dt_ident_tdt_bpf_symbols[] = {
 /* BPF built-in functions */
-DT_BPF_SYMBOL(dt_predicate, DT_IDENT_FUNC),
 DT_BPF_SYMBOL(dt_program, DT_IDENT_FUNC),
 /* BPF library (external) functions */
 DT_BPF_SYMBOL(dt_get_bvar, DT_IDENT_SYMBOL),
",789,182
"Fix comment in SDT provider about the probes we skip

Signed-off-by: Eugene Loh <eugene.loh@oracle.com>
Reviewed-by: Kris Van Hees <kris.van.hees@oracle.com>"," done:
 }
 
 /*
- * The PROBE_LIST file lists all tracepoints in a <group>:<name> format. When
- * kprobes are registered on the system, they will appear in this list also as
- * kprobes:<name>. We need to ignore them because DTrace already accounts for
- * them as FBT probes.
+ * The PROBE_LIST file lists all tracepoints in a <group>:<name> format.
+ * We need to ignore these groups:
+ * - GROUP_FMT (created by DTrace processes)
+ * - kprobes and uprobes
+ * - syscalls (handled by a different provider)
 */
 static int populate(dtrace_hdl_t *dtp)
 {
",214,40
"Fix potential NULL pointer dereference issue

The dt_link_stmt() function has all failure conditions (always known
to be memory allocation issues) jump to the 'fail' label to ensure
that allocated memory is freed. However, if fdp failed to be allocated
we end up dereferencing a NULL pointer (fdp->dtdo_breltab).

Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>
Reviewed-by: Eugene Loh <eugene.loh@oracle.com>
Reviewed-by: Kris Van Hees <kris.van.hees@oracle.com>"," dt_link_stmt(dtrace_hdl_t *dtp, dtrace_prog_t *pgp, dtrace_stmtdesc_t *sdp,
 return 0;
 
 fail:
-dt_free(dtp, fdp->dtdo_breltab);
-dt_free(dtp, fdp->dtdo_buf);
-dt_free(dtp, fdp);
+if (fdp) {
+dt_free(dtp, fdp->dtdo_breltab);
+dt_free(dtp, fdp->dtdo_buf);
+dt_free(dtp, fdp);
+}
 
 return dt_set_errno(dtp, EDT_NOMEM);
 }
",1770,404
"Do not register handlers when not executing probe clauses

The various handlers that are used by consumers only apply to the
execution of probe clauses. For operating modes that do not execute
clauses there is no need to register handlers. Even worse, if e.g.
the error handler is being registered with the default error clause
and -xnolibs is used (which is common with the -h option to generate
a header file), an error will occur because bpf_get_bvar() cannot be
found.

Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>
Reviewed-by: Eugene Loh <eugene.loh@oracle.com>
Reviewed-by: Kris Van Hees <kris.van.hees@oracle.com>"," main(int argc, char *argv[])
 for (i = 0; i < g_cmdc; i++)
 g_cmdv[i].dc_func(&g_cmdv[i]);
 
-if (g_mode != DMODE_LIST) {
+/*
+ * We only need to register handler if we are going to execute probe
+ * clauses.
+ */
+if (g_mode == DMODE_EXEC) {
 if (dtrace_handle_err(g_dtp, &errhandler, NULL) == -1)
 dfatal(""failed to establish error handler"");
 
",1115,270
"Ensure record descriptors get cleaned up

When a dtrace_datadesc struct was being cleaned up (last reference
is released), any record descriptors were not cleaned up. Since the
record descriptors can contain a reference to a printf descriptor as
well, those were not being cleaned up either.

We now make sure to release all allocated memory related to this.

Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>"," dt_datadesc_hold(dtrace_datadesc_t *ddp)
 void
 dt_datadesc_release(dtrace_hdl_t *dtp, dtrace_datadesc_t *ddp)
 {
+inti;
+dtrace_recdesc_t*rec;
+
 if (--ddp->dtdd_refcnt > 0)
 return;
 
+for (i = 0, rec = &ddp->dtdd_recs[0]; i < ddp->dtdd_nrecs; i++, rec++) {
+if (rec->dtrd_format != NULL)
+dt_printf_destroy(rec->dtrd_format);
+}
 dt_free(dtp, ddp->dtdd_recs);
 dt_free(dtp, ddp);
 }
",411,100
"Remove old printf formats handling code

Now that the printff format descriptor data is integrated into the
record descriptor, there is no need to retain the old formats
handling code.

Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>"," dtrace_close(dtrace_hdl_t *dtp)
 
 dt_epid_destroy(dtp);
 dt_aggid_destroy(dtp);
-dt_format_destroy(dtp);
 dt_buffered_destroy(dtp);
 dt_aggregate_destroy(dtp);
 dt_pebs_exit(dtp);
",931,107
"Avoid out-of-memory error report when linking BPF code without relocs

When there are no BPF relocation records, an allocation of size 0 was
being attempted. Since that resulted in a NULL return value, it was
assumed that the allocation failure indicated an out-of-memory
condition.

We now simply do not try to allocate a BPF relocation table when there
are no BPF relocation records to be copied into it.

Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>"," dt_link_stmt(dtrace_hdl_t *dtp, dtrace_prog_t *pgp, dtrace_stmtdesc_t *sdp,
 if (fdp->dtdo_buf == NULL)
 goto nomem;
 fdp->dtdo_len = insc;
-fdp->dtdo_breltab = dt_calloc(dtp, relc, sizeof(dof_relodesc_t));
-if (fdp->dtdo_breltab == NULL)
-goto nomem;
+if (relc) {
+fdp->dtdo_breltab = dt_calloc(dtp, relc,
+ sizeof(dof_relodesc_t));
+if (fdp->dtdo_breltab == NULL)
+goto nomem;
+}
 fdp->dtdo_brelen = relc;
 
 /*
",1793,411
"Rename struct dt_bpf_context to dt_dctx_t (and other cleanup)

Given that struct dt_bpf_context actually contains DTrace context data
rather than anything specific to BPF, dt_dctx_t seems to be a better
name. It is also more consistent with the rest of the DTrace source
code that favours dt_*_t over struct dt_*.

The dt_bpf_ctx.h file has been renamed as dt_dctx.h.

This patch also changes:
 sizeof(((struct dt_bpf_context *)0)->argv) / 8
into
 ARRAY_SIZE(((dt_dctx_t *)0)->argv)
in order to get rid of the hardcoded argv element size (8 bytes).

Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>","
 #include <bpf-helpers.h>
 #include <dtrace/conf.h>
 #include <dtrace/dif_defines.h>
-#include <dt_bpf_ctx.h>
+#include <dt_dctx.h>
 
 #ifndef noinline
 # define noinline__attribute__((noinline))

 
 extern struct bpf_map_def cpuinfo;
 
-noinline uint64_t dt_get_bvar(struct dt_bpf_context *dctx, uint32_t id)
+noinline uint64_t dt_get_bvar(dt_dctx_t *dctx, uint32_t id)
 {
 switch (id) {
 case DIF_VAR_CURTHREAD:
",49,21
"Fix double-free on printf format structure

The printf format structure was being recorded for every data record
item corresponding to a width, precision, or conversion in the format
string. However, only the first occurrence actually gets used. When
the data records are being freed, multiple records for the same printf
would cause the printf format structure to be freed more than once.

Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>"," dt_cg_act_printf(dt_pcb_t *pcb, dt_node_t *dnp, dtrace_actkind_t kind)
 if (arg1 == NULL)
 dt_rec_add(pcb->pcb_hdl, dt_cg_fill_gap, kind, 0, 1, pfp, 0);
 else {
-for (anp = arg1; anp != NULL; anp = anp->dn_list)
+/*
+ * We pass the printf format descriptor along with the first
+ * record, and set it to NULL for subsequent records. It is
+ * only used when the first record is encountered.
+ */
+for (anp = arg1; anp != NULL; anp = anp->dn_list) {
 dt_cg_store_val(pcb, anp, kind, pfp, 0);
+pfp = NULL;
+}
 }
 }
 
",1928,348
"Fix NULL pointer dereference in dt_program_create()

If the allocation of a new program fails, a EDT_NOMEM error condition
is set. But the function continues and then tries to assign the DOF
version. But since the program is NULL at this point, that assignment
triggers a NULL pointer dereference.

The new behaviour returns NULL right away after setting the error.

Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>"," dt_program_create(dtrace_hdl_t *dtp)
 {
 dtrace_prog_t *pgp = dt_zalloc(dtp, sizeof (dtrace_prog_t));
 
-if (pgp != NULL)
-dt_list_append(&dtp->dt_programs, pgp);
-else
-(void) dt_set_errno(dtp, EDT_NOMEM);
+if (pgp == NULL) {
+dt_set_errno(dtp, EDT_NOMEM);
+return NULL;
+}
+
+dt_list_append(&dtp->dt_programs, pgp);
 
 /*
  * By default, programs start with DOF version 1 so that output files
",470,117
"Clean up obsolete dtrace_preddesc_t and dtrace_predicate_t types

Some code in the tree was still referring to dtrace_preddesc_t and
dtrace_predicate_t. These two types are obsolete and are being
removed.

Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>"," dt_dis_action(const dtrace_actdesc_t *ap, FILE *fp, const char *fmt)
 dt_dis_difo(dp, fp);
 }
 
-static void
-dt_dis_pred(const dtrace_preddesc_t *predp, FILE *fp)
-{
-dtrace_difo_t *dp = predp->dtpdd_difo;
-char type[DT_TYPE_NAMELEN];
-
-if (dp == NULL)
-return;
-
-fprintf(fp, ""\nPredicate DIFO %p returns %s\n"", (void *)dp,
- dt_dis_typestr(&dp->dtdo_rtype, type, sizeof (type)));
-
-dt_dis_difo(dp, fp);
-}
-
 typedef struct dt_dis_iter
 {
 FILE *fp;
 dt_dis_stmts(dtrace_hdl_t *dtp, dtrace_prog_t *pgp, dtrace_stmtdesc_t *sdp,
 void *data)
 {
 dt_dis_iter_t *d = data;
-dtrace_preddesc_t *predp = &sdp->dtsd_ecbdesc->dted_pred;
 dtrace_actdesc_t *ap = sdp->dtsd_action;
 const char *fmt = NULL;
 
-if (predp == NULL && ap == NULL)
+if (ap == NULL)
 return 0;
 
 if (d->last_ecb != sdp->dtsd_ecbdesc) {
 dt_dis_stmts(dtrace_hdl_t *dtp, dtrace_prog_t *pgp, dtrace_stmtdesc_t *sdp,
 fmt = pfv->pfv_format;
 }
 
-dt_dis_pred(predp, d->fp);
-
 while (ap) {
 dt_dis_action(ap, d->fp, fmt);
 
",670,109
"Clean up obsolete dtad_next, dtad_refcnt, dted_action and dtsd_action_last

Clauses are compiled as a whole which means that statements can only
contain a single action structure. We therefore clean up obsolete
dtrace_ecbdesc_t->dted_action and dtrace_stmtdesc_t->dtsd_action_last
members. We also have no further need for dtrace_actdesc_t->dtad_next
and dtrace_actdesc_t->dtad_refcnt.

Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>"," dt_stmt_append(dtrace_stmtdesc_t *sdp, const dt_node_t *dnp)
 int speculate = 0;
 int datarec = 0;
 
+#ifdef FIXME
 /*
  * Make sure that the new statement jibes with the rest of the ECB.
  */
 dt_stmt_append(dtrace_stmtdesc_t *sdp, const dt_node_t *dnp)
 if (!speculate)
 datarec = 1;
 }
+#endif
 
 /*
  * Finalize the probe data description for the statement.
",1793,412
"Store compiled code as a dt_ident_t instead of using dtrace_actdesc_t

Since clauses are compiled as entire functions instead of a list of
action, there is no further need for using dtrace_actdesc_t as the
basic unit for storing compiled code. The clause is compiled into a
function and the object code (DIFO) is stored in the BPF symbol table
as dt_clause_<num>.

Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>"," dt_bpf_load_prog(dtrace_hdl_t *dtp, const dt_probe_t *prp,
 {
 struct bpf_load_program_attrattr;
 dtrace_epid_tepid;
-const dtrace_difo_t*dp = sdp->dtsd_action->dtad_difo;
+const dtrace_difo_t*dp;
 intlogsz = BPF_LOG_BUF_SIZE;
 char*log;
 intrc;
 
+dp = dt_dlib_get_func_difo(dtp, sdp->dtsd_clause);
 epid = dt_epid_add(dtp, sdp->dtsd_ddesc, prp->desc->id);
 
 /*
",239,44
"Add TRACE_REGSET() debugging

Add a TRACE_REGSET() debugging macro to dump register set usage when
DT_DEBUG_REGSET is defined.

Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>"," dt_regset_free_args(dt_regset_t *drp)
 for (reg = 1; reg <= 5; reg++)
 dt_regset_free(drp, reg);
 }
+
+/*
+ * Dump the current register allocation.
+ */
+void
+dt_regset_dump(dt_regset_t *drp, const char *pref)
+{
+int reg;
+
+fprintf(stderr, ""%s: Regset: "", pref);
+for (reg = 0; reg < drp->dr_size; reg++) {
+fprintf(stderr, ""%c"", BT_TEST(drp->dr_active, reg) ? 'x' :
+ BT_TEST(drp->dr_spilled, reg) ? 's' :
+ '.');
+}
+fprintf(stderr, ""\n"");
+}
",118,28
"Move the dtrace_datadesc_t from the statement to the DIFO level

The data record description was assigned to a statement and retrieved
from there when creating enablings. However, the actual code that will
fill in the data record is in the DIFO for the clause identifier while
the statement covers both the trampoline and the clause.

The data record description (dtrace_datadesc_t) is now stored in the
DIFO and retrieved from there.

We are still creating the enablings based on statements, so we move the
data record description from the clause to the trampoline (which is
created as a program that gets the clause linked in).

Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>"," dt_bpf_load_prog(dtrace_hdl_t *dtp, const dt_probe_t *prp,
 intrc;
 
 dp = dt_dlib_get_func_difo(dtp, sdp->dtsd_clause);
-epid = dt_epid_add(dtp, sdp->dtsd_ddesc, prp->desc->id);
+epid = dt_epid_add(dtp, dp->dtdo_ddesc, prp->desc->id);
 
 /*
  * Check whether there are any probe-specific relocations to be
",239,44
"Slight code refactoring to eliminate gratuitous differences between providers

Signed-off-by: Eugene Loh <eugene.loh@oracle.com>
Reviewed-by: Kris Van Hees <kris.van.hees@oracle.com>"," static int populate(dtrace_hdl_t *dtp)
 dt_provider_t*prv;
 intn = 0;
 
-
 prv = dt_provider_create(dtp, prvname, &dt_dtrace, &pattr);
 if (prv == NULL)
 return 0;
",182,25
"Add ability to provide user-specified probes on demand

Signed-off-by: Eugene Loh <eugene.loh@oracle.com>
Reviewed-by: Kris Van Hees <kris.van.hees@oracle.com>"," dt_probe_iter(dtrace_hdl_t *dtp, const dtrace_probedesc_t *pdp,
 dtrace_probedesc_tdesc;
 dt_probe_ttmpl;
 dt_probe_t*prp;
+dt_provider_t*pvp;
 inti;
 intp_is_glob, m_is_glob, f_is_glob, n_is_glob;
 intrv = 0;
 dt_probe_iter(dtrace_hdl_t *dtp, const dtrace_probedesc_t *pdp,
 
 tmpl.desc = pdp;
 
+/*
+ * Loop over providers, allowing them to provide these probes.
+ */
+for (pvp = dt_list_next(&dtp->dt_provlist); pvp != NULL;
+ pvp = dt_list_next(pvp)) {
+if (pvp->impl->provide == NULL ||
+ !dt_gmatch(pvp->desc.dtvd_name, pdp->prv))
+continue;
+memcpy(&desc, pdp, sizeof(desc));
+desc.prv = pvp->desc.dtvd_name;
+pvp->impl->provide(dtp, &desc);
+}
+
 /*
  * Special case: if the probe is fully specified (none of the elements
  * are empty of a glob pattern, we can do a direct lookup based on the
",851,201
"Add provider-dependent struct in dt_probe_t

The dt_probe_t struct had members like event_id and event_fd.
This made sense for the providers we were supporting, since they
were all tracepoint-like. For future providers, however, those
members might not make sense and others will be needed. Therefore,
replace event_id and event_fd with an opaque pointer to a
provider-dependent struct.

Signed-off-by: Eugene Loh <eugene.loh@oracle.com>
Reviewed-by: Kris Van Hees <kris.van.hees@oracle.com>"," dt_bpf_load_prog(dtrace_hdl_t *dtp, const dt_probe_t *prp,
 int
 dt_bpf_attach(dtrace_hdl_t *dtp, dt_probe_t *prp, int bpf_fd)
 {
+tp_probe_t*datap = prp->prv_data;
+
 /*
  * If we have not yet created a perf event for this probe, do that now
  * and cache the file descriptor so we only need to do this once.
  */
-if (prp->event_fd == -1) {
+if (datap->event_fd == -1) {
 intfd;
 struct perf_event_attrattr = { 0, };
 
 dt_bpf_attach(dtrace_hdl_t *dtp, dt_probe_t *prp, int bpf_fd)
 attr.sample_type = PERF_SAMPLE_RAW;
 attr.sample_period = 1;
 attr.wakeup_events = 1;
-attr.config = prp->event_id;
+attr.config = datap->event_id;
 
 fd = perf_event_open(&attr, -1, 0, -1, 0);
 if (fd < 0)
 return dt_set_errno(dtp, errno);
 
-prp->event_fd = fd;
+datap->event_fd = fd;
 }
 
-if (ioctl(prp->event_fd, PERF_EVENT_IOC_SET_BPF, bpf_fd) < 0)
+if (ioctl(datap->event_fd, PERF_EVENT_IOC_SET_BPF, bpf_fd) < 0)
 return dt_set_errno(dtp, errno);
 
 return 0;
",240,44
"Add a profile provider

The probes use perf_events with PERF_TYPE_SOFTWARE and
PERF_COUNT_SW_CPU_CLOCK.

Signed-off-by: Eugene Loh <eugene.loh@oracle.com>
Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>
Reviewed-by: Kris Van Hees <kris.van.hees@oracle.com>"," const dt_version_t _dtrace_versions[] = {
 static const dt_provimpl_t *dt_providers[] = {
 &dt_dtrace,
 &dt_fbt,
+&dt_profile,
 &dt_sdt,
 &dt_syscall,
 };
",932,107
"pid: don't corrupt the names of pid modules

We compose these by doing an snprintf() to get a length, then
allocating a buffer and snprintfing into it. Unfortunately the return
value of snprintf is the number of *characters* needed, but we use it
as if it were the number of bytes needed: so the last byte is always
chopped off.

Signed-off-by: Nick Alcock <nick.alcock@oracle.com>
Reviewed-by: Eugene Loh <eugene.loh@oracle.com>"," dt_pid_objname(Lmid_t lmid, const char *obj)
 if (lmid == LM_ID_BASE)
 return strdup(obj);
 
-len = snprintf(NULL, INT_MAX, ""LM%lx`%s"", lmid, obj);
+len = snprintf(NULL, 0, ""LM%lx`%s"", lmid, obj) + 1;
 buf = malloc(len);
 if (buf)
 snprintf(buf, len, ""LM%lx`%s"", lmid, obj);
",558,123
"typedefs: do not assume that char is signed in int8_t definition

Char's signedness is implementation-defined, but int8_t's is not (it is
always signed), so make int8_t a typedef of signed char, not of char.

Signed-off-by: Nick Alcock <nick.alcock@oracle.com>
Reviewed-by: Eugene Loh <eugene.loh@oracle.com>"," static const dt_intrinsic_t _dtrace_intrinsics_64[] = {
 * These aliases ensure that D definitions can use typical <sys/types.h> names.
 */
 static const dt_typedef_t _dtrace_typedefs_32[] = {
-{ ""char"", ""int8_t"" },
+{ ""signed char"", ""int8_t"" },
 { ""short"", ""int16_t"" },
 { ""int"", ""int32_t"" },
 { ""long long"", ""int64_t"" },
 static const dt_typedef_t _dtrace_typedefs_32[] = {
 * These aliases ensure that D definitions can use typical <sys/types.h> names.
 */
 static const dt_typedef_t _dtrace_typedefs_64[] = {
-{ ""char"", ""int8_t"" },
+{ ""signed char"", ""int8_t"" },
 { ""short"", ""int16_t"" },
 { ""int"", ""int32_t"" },
 { ""long"", ""int64_t"" },
",939,109
"Raise the locked-memory limit a little bit more

Signed-off-by: Eugene Loh <eugene.loh@oracle.com>"," dt_vopen(int version, int flags, int *errp,
  * which is needed for BPF operations.
  */
 if (getrlimit(RLIMIT_MEMLOCK, &rl) == 0) {
-rlim_t lim = 16 * 1024 * 1024;
+rlim_t lim = 32 * 1024 * 1024;
 
 if (rl.rlim_cur < lim) {
 rl.rlim_cur = rl.rlim_max = lim;
",939,109
"dtrace: update bogus-ioctl test to comply with prototype for open call

Found a test failing when running on kernel 5.2.2; Ubuntu 19.04
Running:
test/unittest/io/tst.fds.d: Running trigger test/triggers/bogus-ioctl with
delay 1
Results in:
FAIL: erroneous exitcode (1).

A compile error shows:
open with O_CREAT or O_TMPFILE in second argument needs 3 arguments
The 3rd argument added is the mode of the ""file"" opened with flag O_CREAT.

Signed-off-by: David Mc Lean <david.mclean@oracle.com>
Signed-off-by: Eugene Loh <eugene.loh@oracle.com>
Reviewed-by: Kris Van Hees <kris.van.hees@oracle.com>"," main(void)
 
 fds[n++] = open(file, O_RDWR | O_APPEND | O_CREAT | O_DSYNC |
  O_LARGEFILE | O_NOCTTY | O_NONBLOCK | O_NDELAY | O_RSYNC |
- O_SYNC | O_TRUNC);
+ O_SYNC | O_TRUNC, 0);
 
 fds[n++] = open(file, O_RDWR);
 (void) lseek(fds[n - 1], 123, SEEK_SET);
",49,6
"tests: filter-out spurious references to bpf module symbols from kallmodsyms

We see references to symbols assigned to a ""bpf"" module in
/proc/kallmodsyms. We filter these references out in a few tests and in
libdtrace/dt_module.c.

The tests which were failing before the changes here include:
test/unittest/aggs/tst.aggmod_full.sh
test/unittest/aggs/tst.aggmod_full2.sh
test/unittest/consumer/tst.merge_ranges_bug25767469.c
test/unittest/consumer/tst.symbols.c

Signed-off-by: Eugene Loh <eugene.loh@oracle.com>
Signed-off-by: David Mc Lean <david.mclean@oracle.com>
Reviewed-by: Kris Van Hees <kris.van.hees@oracle.com>"," dt_modsym_update(dtrace_hdl_t *dtp, const char *line, int flag)
  || (sym_type == 'w') || (sym_type == 'W');
 mod_name[strlen(mod_name)-1] = '\0';/* chop trailing ] */
 
+if (strcmp(mod_name, ""bpf"") == 0)
+return 0;
+
 /*
  * Symbols of ""absolute"" type are typically defined per CPU.
  * Their ""addresses"" here are very low and are actually offsets.
",1200,301
"Add freopen() and system() support

Signed-off-by: Eugene Loh <eugene.loh@oracle.com>
Reviewed-by: Kris Van Hees <kris.van.hees@oracle.com>"," dt_cg_act_exit(dt_pcb_t *pcb, dt_node_t *dnp, dtrace_actkind_t kind)
 dt_regset_free(pcb->pcb_regs, dnp->dn_args->dn_reg);
 }
 
-static void
-dt_cg_act_freopen(dt_pcb_t *pcb, dt_node_t *dnp, dtrace_actkind_t kind)
-{
-}
-
 static void
 dt_cg_act_ftruncate(dt_pcb_t *pcb, dt_node_t *dnp, dtrace_actkind_t kind)
 {
 dt_cg_act_symmod(dt_pcb_t *pcb, dt_node_t *dnp, dtrace_actkind_t kind)
 {
 }
 
-static void
-dt_cg_act_system(dt_pcb_t *pcb, dt_node_t *dnp, dtrace_actkind_t kind)
-{
-}
-
 static void
 dt_cg_act_trace(dt_pcb_t *pcb, dt_node_t *dnp, dtrace_actkind_t kind)
 {
",1921,346
"Fix value of post-decrement expressions

An earlier commit (""17b0da163 Fix value of post-increment expressions"")
purported to fix postfix expressions, but it formed (1 op arg) rather than
(arg op 1), as is evident not only in the code but even in the commit
message. Arguably, the distinction is unimportant for increment, since
addition is commutative, but the patch produced incorrect results for
decrement expressions.

Fix the generated code and remove the XFAIL on the associated test.

Orabug: 31787365
Signed-off-by: Eugene Loh <eugene.loh@oracle.com>
Reviewed-by: Kris Van Hees <kris.van.hees@oracle.com>"," dt_cg_postarith_op(dt_node_t *dnp, dt_irlist_t *dlp,
 if (nreg == -1)
 longjmp(yypcb->pcb_jmpbuf, EDT_NOREG);
 
-instr = BPF_MOV_IMM(nreg, size);
+instr = BPF_MOV_REG(nreg, oreg);
 dt_irlist_append(dlp, dt_cg_node_alloc(DT_LBL_NONE, instr));
-instr = BPF_ALU64_REG(op, nreg, dnp->dn_reg);
+instr = BPF_ALU64_IMM(op, nreg, size);
 dt_irlist_append(dlp, dt_cg_node_alloc(DT_LBL_NONE, instr));
 
 /*
",1953,345
"Fix double declaration of yylineno

The yylineno variable was declared in dt_cc.c *and* in dt_lex.c (which
is generated from dt_lex.l). This poses a compilation issue with some
newer compilers. The declaration in dt_cc,c has been changed into an
extern declaration, while the one in dt_lex.c is kept as the actual
variable declaration.

Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>","
 #include <dt_bpf.h>
 #include <bpf_asm.h>
 
-int yylineno;
+extern int yylineno;
 
 #ifdef FIXME
 static const dtrace_diftype_t dt_void_rtype = {
",1924,440
"Add 'id' builtin D variable and a test for it

Signed-off-by: David Mc Lean <david.mclean@oracle.com>
Reviewed-by: Kris Van Hees <kris.van.hees@oracle.com>"," noinline uint64_t dt_get_bvar(dt_mstate_t *mst, uint32_t id)
 return mst->tstamp;
 case DIF_VAR_EPID:
 return mst->epid;
+case DIF_VAR_ID:
+return mst->prid;
 case DIF_VAR_ARG0: case DIF_VAR_ARG1: case DIF_VAR_ARG2:
 case DIF_VAR_ARG3: case DIF_VAR_ARG4: case DIF_VAR_ARG5:
 case DIF_VAR_ARG6: case DIF_VAR_ARG7: case DIF_VAR_ARG8:
",53,23
"Implement a 'state' BPF map to communicate tracing session state

The is a need to communicate information about the tracing session
between the BPF programs we generate and the userspace consumer. The
current need covers:

- DT_STATE_ACTIVITY	Records the activity state of the session
- DT_STATE_BEGANON	Records the CPU the BEGIN probe ran on
- DT_STATE_ENDEDON	Records the CPU the END probe ran on

Patches will be forthcoming that provide the implementation of these
features.

Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>
Reviewed-by: Eugene Loh <eugene.loh@oracle.com>
Reviewed-by: Kris Van Hees <kris.van.hees@oracle.com>"," static const dt_ident_tdt_bpf_symbols[] = {
 DT_BPF_SYMBOL(cpuinfo, DT_IDENT_PTR),
 DT_BPF_SYMBOL(gvars, DT_IDENT_PTR),
 DT_BPF_SYMBOL(mem, DT_IDENT_PTR),
+DT_BPF_SYMBOL(state, DT_IDENT_PTR),
 DT_BPF_SYMBOL(strtab, DT_IDENT_PTR),
 DT_BPF_SYMBOL(tvars, DT_IDENT_PTR),
 /* BPF internal identifiers */
",779,178
"Record CPU that BEGIN and END probes run on in the 'state' BPF map

In order to ensure that the BEGIN probe trace data is processed first,
and END probe trace data is processed last, we need to know what CPU
buffers their data is stored in. This patch adds code to record the
CPU on which the BEGIN and END probes run. The 'state' BPF map has
entries (DT_STATE_BEGANON and DT_STATE_ENDEDON) to store this data.

Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>
Reviewed-by: Eugene Loh <eugene.loh@oracle.com>
Reviewed-by: Kris Van Hees <kris.van.hees@oracle.com>","
 #include <dt_bpf_builtins.h>
 #include <bpf_asm.h>
 
-static void dt_cg_xsetx(dt_irlist_t *, dt_ident_t *, uint_t, int, uint64_t);
 static void dt_cg_node(dt_node_t *, dt_irlist_t *, dt_regset_t *);
 
 /*
 dt_cg_membinfo(ctf_file_t *fp, ctf_id_t type, const char *s, ctf_membinfo_t *mp)
 return (fp);
 }
 
-static void
+void
 dt_cg_xsetx(dt_irlist_t *dlp, dt_ident_t *idp, uint_t lbl, int reg, uint64_t x)
 {
 struct bpf_insn instr[2] = { BPF_LDDW(reg, x) };
",2024,349
"Split out dt_cg* function prototypes into a dt_cg.h file

The prototypes for various code generator functions (dt_cg*()) were
found in dt_impl.h even though only a small part of the libdtrace code
actually needs them.

Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>
Reviewed-by: Eugene Loh <eugene.loh@oracle.com>
Reviewed-by: Kris Van Hees <kris.van.hees@oracle.com>","
 #include <dt_ident.h>
 #include <dt_string.h>
 #include <dt_impl.h>
+#include <dt_cg.h>
 #include <dt_bpf.h>
 #include <bpf_asm.h>
 
",1928,441
"Remove dt_state.h from the list of included files in dt_impl.h

The dt_impl.h include file was pulling in dt_state.h even though not
that many source files in libdtrace actually need it.

Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>
Reviewed-by: Eugene Loh <eugene.loh@oracle.com>
Reviewed-by: Kris Van Hees <kris.van.hees@oracle.com>","
 #include <dtrace.h>
 #include <dt_impl.h>
 #include <dt_probe.h>
+#include <dt_state.h>
 #include <dt_bpf.h>
 #include <port.h>
 
",208,37
"Add macros to access (get and/or set) entries in the 'state' BPF map

Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>
Reviewed-by: Eugene Loh <eugene.loh@oracle.com>
Reviewed-by: Kris Van Hees <kris.van.hees@oracle.com>","
 #ifndef _DT_STATE_H
 #define _DT_STATE_H
 
+#include ""dt_bpf.h""
+#include ""dt_impl.h""
+
+struct dtrace_hdl;
+
 /*
 * DTrace 'state' BPF map.
 *
 typedef enum dt_activity {
 DT_ACTIVITY_STOPPED/* tracing stopped */
 } dt_activity_t;
 
+static inline uint32_t
+dt_state_get(dtrace_hdl_t *dtp, uint32_t key)
+{
+uint32_t val = 0;
+
+dt_bpf_map_lookup(dtp->dt_stmap_fd, &key, &val);
+
+return val;
+}
+
+static inline void
+dt_state_set(dtrace_hdl_t *dtp, uint32_t key, uint32_t val)
+{
+dt_bpf_map_update(dtp->dt_stmap_fd, &key, &val);
+}
+
+#define dt_state_get_activity(dtp)((dt_activity_t) \
+ dt_state_get(dtp, DT_STATE_ACTIVITY))
+#define dt_state_get_beganon(dtp)dt_state_get(dtp, DT_STATE_BEGANON)
+#define dt_state_get_endedon(dtp)dt_state_get(dtp, DT_STATE_ENDEDON)
+
+#define dt_state_set_activity(dtp, act)dt_state_set(dtp, DT_STATE_ACTIVITY, \
+ (uint32_t)(act))
+
 #endif /* _DT_STATE_H */
",27,2
"Move BPF stack, dctx, and mstate definitions out of dt_impl.h

The BPF stack layout defines do not belong in dt_impl.h and therefore
are moved to dt_dctx.h. The dt_impl.h does not need to include
dt_dctx.h either because many files do not need it.

This change has a lot of cascading effects across various source code
files due to the include file content reschuffling, so a lot of small
tweaks are included in this patch.

Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>
Reviewed-by: Eugene Loh <eugene.loh@oracle.com>
Reviewed-by: Kris Van Hees <kris.van.hees@oracle.com>","
 #include <sys/syscall.h>
 #include <dtrace.h>
 #include <dt_impl.h>
+#include <dt_dctx.h>
 #include <dt_probe.h>
 #include <dt_state.h>
 #include <dt_bpf.h>
",209,37
"Address various compiler warnings

The compilation reported many compiler warnings, often due to our
""#ifdef FIXME"" or other (sometimes temporarily) orphaned code.

Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>
Signed-off-by: Eugene Loh <eugene.loh@oracle.com>
Reviewed-by: Eugene Loh <eugene.loh@oracle.com>
Reviewed-by: Kris Van Hees <kris.van.hees@oracle.com>","
 * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
 */
 #include <linux/bpf.h>
+#include <stddef.h>
 #include <stdint.h>
 #include <bpf-helpers.h>
 #include <dtrace/conf.h>
 noinline uint64_t dt_get_bvar(dt_mstate_t *mst, uint32_t id)
 }
 case DIF_VAR_CURCPU: {
 uint32_tkey = 0;
+void*val = bpf_map_lookup_elem(&cpuinfo, &key);
 
-return bpf_map_lookup_elem(&cpuinfo, &key);
+if (val == NULL)
+return (uint64_t)NULL;/* FIXME */
+
+return (uint64_t)val;
 }
 default:
 /* Not implemented yet. */
",57,24
"Remove obsolete (PCB) pcb_dret and (DIFO) dtdo_rtype

Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>
Reviewed-by: Eugene Loh <eugene.loh@oracle.com>
Reviewed-by: Kris Van Hees <kris.van.hees@oracle.com>"," fail:
 dp->dtdo_strtab = NULL;
 
 /*
- * Fill in the DIFO return type from the type associated with the
- * node saved in pcb_dret, and then clear pcb_difo and pcb_dret
- * now that the assembler has completed successfully.
+ *
+ * Clear pcb_difo * now that the assembler has completed successfully.
  */
-dt_node_diftype(dtp, pcb->pcb_dret, &dp->dtdo_rtype);
 pcb->pcb_difo = NULL;
-pcb->pcb_dret = NULL;
 
 /*
  * Fill in the trace data record length. This is used to determine the
",391,99
"Add clause flags

There are compile-time rules to enforce regarding which actions are
compatible with which others. E.g., data-recording actions cannot
follow commits, etc. Introduce flags that track clause actions during
compilation so that these rules can be enforced.

Signed-off-by: Eugene Loh <eugene.loh@oracle.com>
Reviewed-by: Kris Van Hees <kris.van.hees@oracle.com>"," dt_stmt_append(dtrace_stmtdesc_t *sdp, const dt_node_t *dnp)
 
 /*
  * Make sure that the new statement jibes with the rest of the ECB.
+ * FIXME: Eliminate this code once it's incorporated elsewhere.
  */
 for (ap = edp->dted_action; ap != NULL; ap = ap->dtad_next) {
 if (ap->dtad_kind == DTRACEACT_COMMIT) {
",1923,441
"Implement the ppid builtin D variable

Signed-off-by: Eugene Loh <eugene.loh@oracle.com>
Reviewed-by: Kris Van Hees <kris.van.hees@oracle.com>"," create_gmap(dtrace_hdl_t *dtp, const char *name, enum bpf_map_type type,
 return fd;
 }
 
+static int
+set_task_offsets(dtrace_hdl_t *dtp)
+{
+ctf_id_t type;
+ctf_membinfo_t ctm;
+ctf_file_t *cfp = dtp->dt_shared_ctf;
+
+type = ctf_lookup_by_name(cfp, ""struct task_struct"");
+if (type == CTF_ERR)
+return -1;
+
+if (ctf_member_info(cfp, type, ""real_parent"", &ctm) == CTF_ERR)
+return -1;
+dt_state_set_offparent(dtp, ctm.ctm_offset / NBBY);
+
+if (ctf_member_info(cfp, type, ""tgid"", &ctm) == CTF_ERR)
+return -1;
+dt_state_set_offtgid(dtp, ctm.ctm_offset / NBBY);
+
+return 0;
+}
+
 /*
 * Create the global BPF maps that are shared between all BPF programs in a
 * single tracing session:
 dt_bpf_gmap_create(dtrace_hdl_t *dtp)
 /* Populate the 'cpuinfo' map. */
 dt_bpf_map_update(ci_mapfd, &key, dtp->dt_conf.cpus);
 
+/* Set some task_struct offsets in state. */
+if (set_task_offsets(dtp))
+return dt_set_errno(dtp, EDT_CTF);
+
 return 0;
 }
 
",228,42
"Allocate exit label in dt_cg_tramp_prologue rather than each provider

Every provider implementation was allocating an id for the exit label
that is used in the trampoline prologue and epilogue. Now the label
id is allocated in and returned by dt_cg_tramp_prologue() (and its
*_act() variant). That id is to be passed to dt_cg_tramp_epilogue()
(or the *_advance() variant) to ensure that the same label is used
throughout the trampoline.

Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>
Reviewed-by: Eugene Loh <eugene.loh@oracle.com>
Reviewed-by: Kris Van Hees <kris.van.hees@oracle.com>"," static void trampoline(dt_pcb_t *pcb)
 inti;
 dt_irlist_t*dlp = &pcb->pcb_ir;
 struct bpf_insninstr;
-uint_tlbl_exit = dt_irlist_label(dlp);
+uint_tlbl_exit;
 dt_activity_tact;
 intadv_act;
 uint32_tkey = 0;
 static void trampoline(dt_pcb_t *pcb)
 adv_act = 0;
 }
 
-dt_cg_tramp_prologue_act(pcb, lbl_exit, act);
+lbl_exit = dt_cg_tramp_prologue_act(pcb, act);
 
 if (key) {
 /*
",234,30
"Verify the activity state before calling each clause

When a clause contains an exit() action, processing of all other
clauses (even for the same probe firing) must not be executed
anymore. The activity state will now be checked before every clause
within the program.

Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>
Reviewed-by: Eugene Loh <eugene.loh@oracle.com>
Reviewed-by: Kris Van Hees <kris.van.hees@oracle.com>"," static void trampoline(dt_pcb_t *pcb)
 }
 
 if (adv_act)
-dt_cg_tramp_epilogue_advance(pcb, lbl_exit);
+dt_cg_tramp_epilogue_advance(pcb, lbl_exit, act);
 else
 dt_cg_tramp_epilogue(pcb, lbl_exit);
 }
",234,30
"Include aggregates in the DIFO vartab

Aggregates used to be handled as special identifiers. Under the new
design they will be handled more like variables and it is therefore
warranted to include them in the variable table.

Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>
Reviewed-by: Eugene Loh <eugene.loh@oracle.com>"," dt_dis_difo(const dtrace_difo_t *dp, FILE *fp)
 char kind[4], scope[4], range[12], flags[16] = { 0 };
 
 switch (v->dtdv_kind) {
+case DIFV_KIND_AGGREGATE:
+strcpy(kind, ""agg"");
+break;
 case DIFV_KIND_ARRAY:
 strcpy(kind, ""arr"");
 break;
",600,95
"Remove obsolete dt_bpf_builtins.h header file

Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>
Reviewed-by: Eugene Loh <eugene.loh@oracle.com>","
 #include <dt_printf.h>
 #include <dt_provider.h>
 #include <dt_probe.h>
-#include <dt_bpf_builtins.h>
 #include <bpf_asm.h>
 
 static void dt_cg_node(dt_node_t *, dt_irlist_t *, dt_regset_t *);
",2253,444
"Add BPF compiled functions even if no relocations

Signed-off-by: Eugene Loh <eugene.loh@oracle.com>
Reviewed-by: Kris Van Hees <kris.van.hees@oracle.com>"," done:
 dp = fp->difo;
 relc = dp->dtdo_brelen;
 if (relc == 0)
-continue;
+goto setdata;
 
 stab = dt_strtab_create(BUFSIZ);
 dp->dtdo_breltab = dt_calloc(dtp, relc, sizeof(dof_relodesc_t));
 done:
 
 dt_strtab_destroy(stab);
 
+setdata:
 idp = fp->ident;
 dt_ident_morph(idp, idp->di_kind, &dt_idops_difo, dtp);
 dt_ident_set_data(idp, fp->difo);
",781,178
"Compute lquantize() bin only once

First, quantize the value into a 0-based bin number. As was done for
quantize(), use C code in the bpf/ subdirectory to be cross-compiled
into BPF when DTrace is built.

Then, the ""implementation"" function -- which needs to run twice, once
per aggregation copy -- is simply dt_cg_agg_quantize_impl(). That is,
we reuse the same function for lquantize() that was originally introduced
for quantize().

Signed-off-by: Eugene Loh <eugene.loh@oracle.com>
Reviewed-by: Kris Van Hees <kris.van.hees@oracle.com>","
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ */
+#include <linux/bpf.h>
+#include <stdint.h>
+#include <bpf-helpers.h>
+
+#ifndef noinline
+# define noinline__attribute__((noinline))
+#endif
+
+noinline uint64_t dt_agg_lqbin(int64_t val, int32_t base, uint64_t levels,
+ uint64_t step)
+{
+uint64_t level;
+
+if (step == 0 || val < base)
+return 0;
+level = (val - base) / step;
+if (level > levels)
+level = levels;
+return level + 1;
+}
",14,4
"Change dt_cg_agg_lquantize() arg check to agree with message

We check limitval<baseval, but the error message is ""base must
be less than limit"". Make the check more stringent to agree
with the error message.

Note that this behavior dates back to DTrace v1:
 # dtrace -n 'BEGIN {@ = lquantize(8, 4, 4); exit(0) }'
 dtrace: invalid probe specifier:
 lquantize( ) step (argument #3) too large:
 must have at least one quantization level
That is, the arguments pass the check but are then caught by a
later, rather confusing, message.

Add a test to catch this case.

Signed-off-by: Eugene Loh <eugene.loh@oracle.com>
Reviewed-by: Kris Van Hees <kris.van.hees@oracle.com>"," dt_cg_agg_lquantize(dt_pcb_t *pcb, dt_ident_t *aid, dt_node_t *dnp,
 dnerror(arg2, D_LQUANT_LIMVAL, ""lquantize( ) argument #2 must ""
 ""be a 32-bit quantity\n"");
 
-if (limitval < baseval)
+if (limitval <= baseval)
 dnerror(dnp, D_LQUANT_MISMATCH,
 ""lquantize( ) base (argument #1) must be less than ""
 ""limit (argument #2)\n"");
",2339,454
"Handle steps==0 error for llquantize

We can get divide-by-zero failures if we do not explicitly check.

KVH: Renamed err.D_LLQUANT_STEPVAL.neg.d to err.D_LLQUANT_STEPTYPE.neg.d
 to accomodate this change.

Signed-off-by: Eugene Loh <eugene.loh@oracle.com>
Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>
Reviewed-by: Kris Van Hees <kris.van.hees@oracle.com>"," dt_cg_agg_llquantize(dt_pcb_t *pcb, dt_ident_t *aid, dt_node_t *dnp,
 dnerror(arg3, D_LLQUANT_HMAGVAL, ""llquantize( ) argument #3 ""
 ""(high magnitude) will cause overflow of 64 bits\n"");
 
-if (arg4->dn_kind != DT_NODE_INT)
+if (!dt_node_is_posconst(arg4))
 dnerror(arg4, D_LLQUANT_STEPTYPE, ""llquantize( ) argument #4 ""
-""must be an integer constant\n"");
+""must be a non-zero positive integer constant\n"");
 
 steps = (uint64_t)arg4->dn_value;
 
",2339,454
"Fix bitwise negation

Orabug: 32125018
Signed-off-by: Eugene Loh <eugene.loh@oracle.com>
Reviewed-by: Kris Van Hees <kris.van.hees@oracle.com>"," dt_cg_node(dt_node_t *dnp, dt_irlist_t *dlp, dt_regset_t *drp)
 case DT_TOK_BNEG:
 dt_cg_node(dnp->dn_child, dlp, drp);
 dnp->dn_reg = dnp->dn_child->dn_reg;
-emit(dlp, BPF_ALU64_IMM(BPF_XOR, dnp->dn_reg, 0));
+emit(dlp, BPF_ALU64_IMM(BPF_XOR, dnp->dn_reg, -1));
 break;
 
 case DT_TOK_PREINC:
",2439,462
"Restore error message

An error message was ""#if 0""ed out during development,
producing behavior like this:
 # dtrace -n 'BEGIN {avg(1); exit(0)}'
 dt_cg_node() - FUNC aggregating function avg()
 dtrace: description 'BEGIN ' matched 1 probe
 BPF: call to invalid destination
 BPF: verification time 14 usec
 BPF: stack depth 0+0
 BPF: processed 0 insns (limit 1000000) max_states_per_insn 0 ...
 dtrace: could not enable tracing: BPF program load for 'dtrac...

Restore the message. Add a test.

Signed-off-by: Eugene Loh <eugene.loh@oracle.com>
Reviewed-by: Kris Van Hees <kris.van.hees@oracle.com>"," dt_cg_node(dt_node_t *dnp, dt_irlist_t *dlp, dt_regset_t *drp)
 
 switch (dnp->dn_kind) {
 case DT_NODE_FUNC:
-if ((idp = dnp->dn_ident)->di_kind != DT_IDENT_FUNC)
- fprintf(stderr, ""%s() - FUNC %s %s()\n"", __func__, dt_idkind_name(idp->di_kind), idp->di_name);
-#if 0
 if ((idp = dnp->dn_ident)->di_kind != DT_IDENT_FUNC) {
 dnerror(dnp, D_CG_EXPR, ""%s %s( ) may not be ""
  ""called from a D expression (D program ""
  ""context required)\n"",
  dt_idkind_name(idp->di_kind), idp->di_name);
 }
-#endif
 
 dt_cg_arglist(dnp->dn_ident, dnp->dn_args, dlp, drp);
 
",2437,460
